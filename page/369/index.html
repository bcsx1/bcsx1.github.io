<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbbfc9677835a76f7dbac8995fa014d5/" rel="bookmark">
			Navicat使用bug (查询Oracle序列步长显示有问题)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一:Navicat-12.1.18在查询序列时有返回结果的bug
本来设置的序列步长为1,执行select语句时发现每次执行的结果相差的步长为2(正常情况下应该为 1)。
使用其他工具如DataGrip无此问题.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5e4f6a4ff93ece4deadd15380431e82/" rel="bookmark">
			MVC框架——页面开发辅助类HtmlHelper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MVC框架——页面开发辅助类HtmlHelper 为什么要使用页面开发辅助类HtmlHelper，与传统手写标签方式比较 手写Html标签效率较低，可重用度较低:
传统标签要根据路由规则来写，路由修改则这种书写方式也得进行修改
在Index视图中：
一般情况下使用标签的方式：
&lt;a href="/Home/About?name=tom" style="color:aqua"&gt;跳转到About&lt;/a&gt; 还有两种方式可以实现标签：
1.1 通过url内置对象的方法action()实现
这里的action有9个重载方法
&lt;a href="@Url.Action("about","home",new { name = "tom"})"&gt;通过url跳转到About&lt;/a&gt; &lt;a href="@Url.Action("about")"&gt;通过url跳转，此时跳转的控制器就是当前视图默认所属的控制器&lt;/a&gt; public virtual string Action( string actionName, string controllerName, object routeValues); &lt;hr/&gt; url内置对象的方法action()：
使用指定的操作名称、控制器名称和路由值生成操作方法的完全限定 URL。
参数:
actionName: 操作方法的名称
controllerName: 控制器的名称
routeValues: 一个包含路由参数的对象。通过检查对象的属性，利用反射检索参数。该对象通常是使用对象初始值设定项语法创建的
返回结果: 操作方法的完全限定 URL
1.2 使用HtmlHelper辅助类对象Html中avtionlink()方法实现页面跳转
@Html.ActionLink("通过html跳转到about","about","home",new { name = "tom"},new { style = "color:aqua"}) @Html.ActionLink("通过html跳转到about", "about", "home") @Html.ActionLink("通过html跳转到about", "about", "home", new { name = "tom" }) 此时，ActionLink为Html类的扩展方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5e4f6a4ff93ece4deadd15380431e82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a623627b9fbb196ef0ef82fa2292189/" rel="bookmark">
			Maven 学习笔记 - 跳过测试 skipTests
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maven 学习笔记 - 跳过测试 方案一 idea中操作方案二 maven命令方案三 maven打包插件配置1. 跳过所有测试2. 详细指定：包含、排除 参考资料 方案一 idea中操作 打开后测试出现删除线 test
方案二 maven命令 package -D skipTests
方案三 maven打包插件配置 1. 跳过所有测试 &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.2&lt;/version&gt; &lt;configuration&gt; &lt;!--开启跳过--&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 2. 详细指定：包含、排除 包名路径，文件名要带后缀。支持统配符号 *：
2.1 任何包：**
2.2 任何字符：*excludes 优先级高于 includes &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.2&lt;/version&gt; &lt;configuration&gt; &lt;!--详细指定要跑的测试--&gt; &lt;includes&gt; &lt;include&gt;com/jerry/AppTest*.java&lt;/include&gt; &lt;/includes&gt; &lt;!--详细指定排除的测试--&gt; &lt;excludes&gt; &lt;exclude&gt;com/jerry/AppTest.java&lt;/exclude&gt; &lt;exclude&gt;com/jerry/AppTest1.java&lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 执行打包效果：
[INFO] [INFO] --- maven-surefire-plugin:2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a623627b9fbb196ef0ef82fa2292189/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a399f74926273133faa11d5b6684bce4/" rel="bookmark">
			stm32 keil5写的结构体为什莫没有自动补全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为路径是中文的，改成全英文路径就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2522c347dbf1403756c114042172dc5/" rel="bookmark">
			vue原理之observer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上节课我们讲了vue五种类型中的vue 实现data响应
这节课我们讲第二中类型observer
Observer 功能
负责把 data 选项中的属性转换成响应式数据
data 中的某个属性也是对象，把该属性转换成响应式数据
数据变化发送通知
具体代码实现如下 class Observer { constructor(data) { this.walk(data) } // 1. 判断数据是否是对象，如果不是对象返回 // 2. 如果是对象，遍历对象的所有属性，设置为 getter/setter walk(data) { if (!data || typeof data != 'object') { return } Object.keys(data).forEach(key =&gt; { this.defineReactive(data, key, data[key]) }) } // 定义响应式成员 即对data总的数据实现setter和getter defineReactive(data, key, val) { const that = this // 如果 val 是对象，继续设置它下面的成员为响应式数据 this.walk(val) Object.defineProperty(data, key, { enumerable: true, configurable: true, get() { return val; }, set(newValue) { if (val === newValue) { return } // 如果 newValue 是对象，设置 newValue 的成员为响应式 that.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2522c347dbf1403756c114042172dc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23bc6486c42827a085d1b0edfaceecf3/" rel="bookmark">
			Java面向对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java面向对象 面向对象面向过程思想面向对象思想什么是面向对象 方法类的调用方法之间的调用值传递（Java都是值传递）引用传递 对象的创建分析类&amp;对象对象的创建与初始化构造器 面向对象的三大特性封装继承super(&lt;---&gt;this)方法重写 多态instanceof类型转换static关键字 抽象类和接口抽象类(abstract)接口 内部类 面向对象 面向过程&amp;面向对象
面向过程思想 步骤清晰简单，第一步，第二步…适合处理较为简单的问题 面向对象思想 分类的思维模式，分而治之适合处理较为复杂的问题以及需要多人协作的问题 对于描述复杂的事物，为了从宏观上把握、整体上合理分析，需使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍需用面向过程的思路去处理。
什么是面向对象 面向对象的本质：以类的方式组织代码，以对象的形式封装数据
核心思想：抽象
三大特性：
封装继承多态 从认识论角度考虑是先有对象后有类。对象：具体的事物；类（抽象的）：是对对象的抽象从代码运行角度考虑是先有类后又对象。类是对象的模板 方法 类的调用 package dengaku; public class Test { public static void main(String[] args){ //非静态方法的调用 //须先实例化类：对象类型 对象名 = 对象值 Test1 test1 = new Test1(); test1.say1(); //静态方法的调用 test1.say2(); } } package dengaku; public class Test1 { //非静态方法 public void say1(){ System.out.println("say"); } //静态方法 public static void say2(){ System.out.println("say static"); } } /* 输出：say say static */ 方法之间的调用 当方法都是静态或非静态时可以互相调用静态方法可以直接调用，而非静态方法需要实例化之后才能调用 package dengaku; public class Test { public static void main(String[] args) { } //静态方法和类一起加载 public static void a(){} //非静态方法类实例化之后才存在 public void b(){} } 值传递（Java都是值传递） package dengaku; public class Test { public static void main(String[] args) { int a = 1; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23bc6486c42827a085d1b0edfaceecf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bced312b9a5077edd74d5b1ceb0cf2d9/" rel="bookmark">
			SQL Server 设置编辑所有行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL Server 默认的情况，只能编辑一个表的前200行；
进入如下界面；从 工具-选项 菜单；
把200改为0；确定；
然后再看，可以编辑所有行了；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cc01fd6a1a964d2fdf1d732731bee5e/" rel="bookmark">
			转录组分析流程：比对（有参）及统计Counts矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 质控 fastqc * multiqc * trimmomatic_run.sh #去掉前9个碱基 trimmomatic_run.sh
#! /bin/bash #history: #	Gossie V1 20190101 #用trimmomatic对进行测序数据质量控制 #输入文件为包含样本名称的单列文件 #线程 t=1 # 模式PE（双端）或者SE（单端） mode='PE' #以下参数适情况修改、添加。 #ILLUMINACLIP模式 #接头文件，fasta格式。注意：不同的命名格式有差别。 fastaWithAdapterEtc='/Trimmomatic-0.38/adapters/TruSeq3-PE-2.fa' #第一步搜索时允许搞错错配碱基个数，通常为1-2. seed_mismatches=2 #双端测序的palindrome模式下，连上接头的两条reads的比对阈值 palindrome_clip_threshold=30 #切除的接头序列的最低比对分值，通常为7-15. simple_clip_threshold=10 #仅对palindrome模式有效，双端测序palindrome模式下，可以切除的接头的最短长度。默认是8。但，可以设置为1. minAdapterlength=8 #仅对palindrome模式有效。默认为false。 keepBothReads=true # SLIDINGWINDOW:滑窗模式。从5‘端开始滑动，切除平均质量小于阈值的片段。 #窗口大小 windowSize=0 #质量 requiredQuality=0 #LEADING:切除起位置小于阈值的碱基 lead_quality=0 #TRAILING:切除末尾位置小于阈值的碱基 trail_quality=0 #CROP:从末尾切除read部分碱基，使reads达到指定长度. crop_length=150 #HEADCROP:切除起始位置特定长度的碱基 headcrop=9 #MINLEN:舍弃小于给定长度的 minlen=50 #AVGQUAL：舍弃平均质量低于给定水平的read avgqual=20 while read id do nohup trimmomatic PE -threads $t ${id}_1.fastq.gz ${id}_2.fastq.gz -baseout ${id}.fastq.gz HEADCROP:$headcrop ILLUMINACLIP:$fastaWithAdapterEtc:$seed_mismatches:$palindrome_clip_threshold:$simple_clip_threshold:$minAdapterlength:$keepBothReads MINLEN:$minlen &amp; done &lt; $1 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cc01fd6a1a964d2fdf1d732731bee5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be18f18a6ee999ce14206452137109d0/" rel="bookmark">
			软件测试经验与教训
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、测试员的角色 1、测试员为很多客户服务
2、迅速找出重要程序问题
首先测试经过变更的部分，然后测试没变化的部分
首先测试核心功能，然后测试辅助功能
首先测试能力，然后测试可靠性
首先测试常见情况，然后测试少见情况
首先测试常见威胁，然后测试罕见威胁
首先测试影响大的问题，然后测试影响小的问题
首先测试最需要的部分，然后测试没有要求的部分
3、询问一切，但不不定外露
4、测试员关注失效，客户才能关注成功
5、不会发现所有程序问题
6、测试员不能有产品发布与否的权力
二、按测试员的方式思考 1、测试需要推断，并不只是做输出与预期结果的比较
2、优秀测试员会进行技术性、创造性、批判性和实用性的思考
3、为了测试，必须探索
4、当测试复杂产品时：陷入与退出
三、测试手段 1、关注测试员的基于人员的测试手段
用户测试
α测试
β测试
强力测试
有关领域的专家测试
成对测试
自用测试
2、关注测试内容的基于覆盖率的测试手段
功能测试
特性或功能集成测试
菜单浏览
域测试
等价类分析
边界测试
最佳代表测试
输入字段测试大纲或矩阵
用各种方法映射和测试编辑字段
逻辑测试
基于状态的测试
路径测试
语句与分支覆盖率
配置覆盖率
基于规格说明的测试
基于需求的测试
组合测试
3、关注测试原因（针对风险测试）的基于问题的测试手段
输入约束
输出约束
计算约束
存储（或数据）的约束
4、关注测试方法的基于活动的测试手段
回归测试
脚本测试
冒烟测试
探索式测试
游击式测试
场景测试
安装测试
负载测试
长序列测试
性能测试
5、关注测试是否通过的基于评估的测试手段
自检验数据
与已保存的结果进行比较
与规格说明书或其他权威文档比较
基于理念的测试
6、根据自己的看法对测试手段分类
四、程序错误分析 1、测试员的程序错误分析会推动改正所报告的错误
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be18f18a6ee999ce14206452137109d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dde972991190077f81a514fd34dc1e2f/" rel="bookmark">
			python 批量切割语音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python批量切割语音文件（可以灵活控制切割长度） 话不多少，直接上代码：
def file_name(file_dir): ''' 输入文件夹名称，并返回该文件夹下所有语音文件的完整路径(list类型) :param file_dir: :return: ''' L = [] for root, dirs, files in os.walk(file_dir): for file in files: if file.split('.')[-1] == 'wav': L.append(os.path.join(root, file)) return L def cut_to_3s(src_dir,des_3s_dir,seconds_per_split_file): ''' 切割语音长度 :param src_dir: 用户需要切割的某个语音文件夹 :param des_3s_dir: 切割后文件存储文件夹 :param seconds_per_split_file: 切割后每个语音长度 :return: ''' # 获取该文件夹下所有语音数据 filenames = file_name(src_dir) # 对每一个语音数据进行切片 for filename in filenames: # 获取文件名字 print("当前切割语音文件： ", filename) sound = AudioSegment.from_wav(filename) # 获取音频持续时间（单位为秒s）,并计算可以切割多少段？ seconds_of_file = sound.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dde972991190077f81a514fd34dc1e2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd23379cd0af97b0fa55bfbbc71ef299/" rel="bookmark">
			C&#43;&#43; 字符串和数字之间的相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		能完成字符串和数字转换的方法多种多样：
1.使用string自带函数 数字转字符串：to_string()
字符串转数字：stoi()、stol()、stof()、stod()等等
例：
int i = 42; string s = to_string(i); double d = stod(s); 字符串转数字的各个函数还可以选择从字符串的哪个位置开始转换，转换成整型量还可以选择不同的进制，具体见C++primer 328页。
2.使用stringstream 首先要包含sstream头文件，这个类继承自iostream，可以对string进行读写数据。
通过stringstream可以直接完成字符串和数字的互相转换。
例：
//数字转字符串 int num = 12; string s; stringstream strs; strs &lt;&lt; num; strs &gt;&gt; s; //s = “12” //字符串转数字 string s = "123"; int num; stringstream strs; strs &lt;&lt; s; strs &gt;&gt; num; //num = 123 这里的字符串类型不仅可以是string，也可以是char[ ]。当然，C++推荐我们能用string、vector等容器就不要用数组；能用迭代器就不要用普通指针。
3.使用sprintf、sscanf 需要include&lt;stdio.h&gt;
// 数字转字符串 sprintf(str, “%d”, num); // 字符串转数字 sscanf(str, “%d”, &amp;rsl); 通过字符串和数字之间的相互转换，我们可以更灵活的处理数据、解决问题，比如下面这个例题：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd23379cd0af97b0fa55bfbbc71ef299/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3583534bd601170c3c38b34ee99fca60/" rel="bookmark">
			redis6中的线程，单线程，多线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis6中终于引入了万众期待的多线程支持，之前在大家的传统概念里面，redis都是单线程来处理请求的，那么redis6中多线程又究竟是怎么回事呢？难道redis6中整个架构都调整了？不在是单线程来处理了？
要解答上面的问题，我们还需要重redis的历史设计中来找到答案。
总所周知，早前的TCP网络处理模式都是基于BIO模型，即所谓的阻塞IO来处理网络请求：一个客户端的请求建立，server端就对应用一个线程来处理这个客户端的读写，如果没有数据传输，则这个线程一直阻塞等待，知道有数据到来。
这种模型的缺点很明显，当并发量比较小的时候没有什么问题，但是如果并发量比较大的时候，每个请求都生成一个线程，非常耗资源。
随着计算机的发展，诞生了非阻塞IO,也可以理解为传说中的IO多路复用。一般底层系统调用基于select、epoll。当使用这种模型的时候，每个连接都会在内核注册一个文件句柄，内核会监测该句柄上的相关读写请求，当有请求到来的时候，内核会通知对应的程序来处理，这里的多路复用，可以理解为由原来的每个请求都要调用一次系统命令优化为 调用一次系统命令来获取所有有请求数据到来的连接，然后程序就可以对这些有数据的请求来进行处理。
redis的设计者也曾说过，redis的瓶颈并不在于cpu，基于内存的处理IO是可以忽略不计的，redis的瓶颈在于网络IO的读写请求。如果引入多线程来处理数据的话性能提升并不明显，反而由多线程带来的数据同步而影响性能。
因此redis在处理相关读写请求和数据处理的时候用的是单线程模型，这样能够避免线程上下文切换以及线程同步带来的问题，简化了编程模型，提高了系统的健壮性。
但是我们说的redis是单线程，并不是说redis中只有一个线程处理所有的事情，比如：
redis中rdb持久化，就是通过系统底层调用，fork一个子进程，在子进程中完成了将内存中的数据写入到rdb文件中，父进程中的写入和读取通过写时复制，不会更改子进程中的内存数据，这时候父子进程各有一份自己的数据redis 4版本中引入了laze free，何谓lazy free，这个一般是用来删除大键或者flush db的时候，由于要删除的数据量太多，如果是在主线程-单线程中操作，会造成redis的堵塞，因此引入了lazy free的概念，主线程没有做实际的内存回收删除，只是做了unlink操作，将对应的key和内存解绑，由后台线程去做实际的删除、释放内存，没有laz free之前，为了不阻塞其他操作，删除大量数据只能每次删除100个这样的客户端循环发送删除命令。redis4中引入lazy free的同时也将原来redis整体设计中的聚合类型的存储结构进行了改进，在这之前redis内部用了很多的共享对象，比如客户端的输出缓存，redis并没有加锁来避免线程冲突（这时候就是单线程），redis去掉了共享对象，采用了数据拷贝。去掉了共享对象不仅实现了lazy free，也为后续的redis多线程带来了可能。 redis6中的所谓多线程的实现原来如下：
当客户端有请求时，主线程将有请求数据的读事件给到IO线程处理完成读操作，所有IO线程读取完数据之后，主线程开始处理这些请求（这里还是单线程），处理完之后将这些写事件分配给所有的IO线程进行写处理，等待所有的IO线程写处理完成。 可以看到redis6中所谓的多线程，并不是说处理数据采用多线程处理，redis还是单线程处理，只不过在网络IO这块，采用的多线程来处理读写，仅局限于网络IO的读写，而且redis的网络IO的多线程并不是我们理解的多线程，而是一次要么都是读，要么都是写，没法同时对网络IO进行读写。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cf013efa605652fa84fbcdf1a51ac93/" rel="bookmark">
			快速通俗易懂的理解PID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PID控制理论框图 r(t): 最终希望达到的值
e(t): 所希望的值与实际值的差（误差值）
u(t): 给被控对象的值
y(t): 被控对象实际输出的值
举个简单的例子，控制智能车的速度。（飞卡比赛基础四轮车）
为了方便，这里以纯P控制，假设其值为Kp=2.
上电后,智能车摄像头采集回来图像，通过图像处理，我们判断出这是直道，想让其以4000的占空比前进(满占空比10000)，既40%的速度。此时，r(t)就可以是4000，由于刚上电，此时轮子没有转起来，既编码器采集到的轮子的速度为0（被控对象实际输出的值），所以y(t)=0;误差就为e(t)=r(t)-y(t)。通过比例系数的控制后，u(t)=2*4000=8000(给电机的占空比)。之后继续重复以上控制。PD控制、PI控制、也是如此。
常见的控制方式 一、P控制 接下来在matlab中进行仿真，仿真图如下：
其中这个模块
是PID控制器。相当于PID控制框图的☟
下面这个相当与被控对像。（就像上面讲到的电机）
设定P的值为10，查看输出的波形。
下面是输出的波形：
上图中蓝色的是PID处理后的值，而黄色是误差值。由波形可知，其最终经过PID处理后，其值基本保持在9附近，并没有保持在10。
接下来我们继续增大P的值，将其设置为30，并将P=10，和P=30经过PID处理后，查看其波形，波形如下：
蓝色的波形是P=30，黄色的P=10。
通过图可以看出，P=30,最终基本稳定在9.67左右，相比与P=10(稳定在9左右),更加的接近我们所期望的值，但是随着P的增大，其系统的稳定性下降，波动太大。
也就说，P的作用为：
系统一旦出现偏差，比例调节立即产生调节作用用以减少偏差，比例作用大，可以加快调节，减少调节时间，减少稳态误差，过大的比例作用，使系统的稳定性下降，甚至造成系统的不稳定。
下面，来看一下P=10和30，系统的实际输出波形比较，其也能很好的理解P的作用。
上图中蓝色的是P=30,黄色的是P=10。
二、PD控制 在只有P控制的条件下，加入D的控制。我们这里的PD控制，与上一个纯P控制作比较。
1、P相同的条件下 （P相同是指纯P控制的P值，与PD控制的P值相同。改变其D值，观察其实际输出波形的区别）
（1） P=10,D=2
其纯P控制实际输出波形，与PD控制实际输出波形如下：
蓝色的是PD控制，黄色的是纯P控制。明显可以看出加入了D,使其波形更加的稳定。在微分时间选择合适情况下， 可以减少超调， 减少调节时间，使其更快的保持在我们所希望的值附近。
（2）在上一步的基础上，增加D的值，观察其输出的波形。增大为D=7,(P=10)。
该波形为系统的输出波形，其中，黄色的线是P=10,D=2;蓝色的线是P=10,D=7。
从中可以看出，D的作用为：
减小超调量，减小调节时间（与P控制相比较而言）增强系统稳定性
三、PID控制 在上一个的基础上，加入积分项（I）,P=10,i=1,D=7。
该波形为系统的输出波形，其中，黄色的线是P=10,D=7，i=0;蓝色的线是P=10,D=7,i=1。
从波形可以明显看出，加入积分项后，其输出波形最终稳定9.9左右。所以其有消除稳态误差的作用。
继续增大I，查看其输出波形
蓝色的为i=5,黄色的为i=1,从中可以看出积分项有明显的消除稳态误差的作用。
总结 1、比例（P）控制 具有P控制的系统，其稳态误差可通过P控制器的增益Kp来调整：Kp越大，稳态误差越小；反之，稳态误差越大。但是Kp越大，其系统的稳定性会降低。
由上式可知，控制器的输出u(t)与输入误差信号e(t)成比例关系，偏差减小的速度取决于比例系数Kp：Kp越大，偏差减小的越快，但是很容易引起振荡；Kp减小，发生振荡的可能性小，但是调节速度变慢。单纯的P控制无法消除稳态误差。
2、比例微分（PD）控制 规律：可以反应输入信号的变化趋势，具有某种预见性，可为系统引进一个有效的早期修正信号，以增加系统的阻尼程度，而从提高系统的稳定性。（tao为微分时间常数）
3、比例积分微分（PID）控制 除了积分环节提高了系统型别，微分环节提高了系统的动态性能。
观察PID的公式可以发现：Kp乘以误差e(t)，用以消除当前误差；积分项系数Ki乘以误差e(t)的积分，用于消除历史误差积累，可以达到无差调节；微分项系数Kd乘以误差e(t)的微分，用于消除误差变化，也就是保证误差恒定不变。由此可见，P控制是一个调节系统中的核心，用于消除系统的当前误差，然后，I控制为了消除P控制余留的静态误差而辅助存在，对于D控制，所占的权重最少，只是为了增强系统稳定性，增加系统阻尼程度，修改PI曲线使得超调更少而辅助存在。
也就是说，通过PID控制，可以使得系统稳、准、快的调节到我们所期望的值
**稳定性（P和I降低系统稳定性，D提高系统稳定性）：**在平衡状态下，系统受到某个干扰后，经过一段时间其被控量可以达到某一稳定状态；
**准确性（P和I提高稳态精度，D无作用）：**系统处于稳态时，其稳态误差；
**快速性（P和D提高响应速度，I降低响应速度）：**系统对动态响应的要求。一般由过渡时间的长短来衡量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92540ecd198f1d5c74006b84e4697d6c/" rel="bookmark">
			实验8   综合实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验名称 实验8 综合实验 日期 2020年 6 月 19 日 一、实验目的：
(1)理解触发器的用途、类型和工作原理
(2)掌握利用T-SL语句创建和维护触发器的方法
(3)掌握利用企业管理器创建、维护触发器的方法
二、实验环境：
PC + Windows + SQL Server
三、实验内容
创建 after/触发器
(1)创建一个在插入时触发的触发器sc_insert，当向sc表插入数据时，须确保插入的学号己在 Student表中存在，并且还须确保插入的课程号在 Course表中存在:若不存在，则给出相应的提示信息，并取消插入操作，提示信息要求指明插入信息是学号不满足条件还是课程号不满足条件(注: Student表与sc表的外键约束要先取消)。
if exists(select name from sysobjects where name='sc_insert' and type='tr') drop trigger sc_insert go create trigger sc_insert on SC after insert as if not exists(select * from Student,inserted where Student.Sno=inserted.Sno) begin print '插入信息的学号不在学生表中！' if not exists(select * from Course,inserted where Course.Cno=inserted.Cno) print '插入新的课程号不在课程表中！' rollback end else begin if not exists(select * from Course,inserted where Course.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92540ecd198f1d5c74006b84e4697d6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbc08d3565826ed5cf52510aa4ee8c8b/" rel="bookmark">
			FPGA中“与-或-非”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 定义输入为A,B,C,D，输出为F，则与-或-非门电路程序为：
module AOI(A,B,C,D,F); //模块名为AOI（端口列表A,B,C,D,F） input A,B,C,D; //模块的输入端口为A,B,C,D output F; //模块的输出端口为F wire A; //定义信号的数据类型 wire B; wire C; wire D; wire F; assign F = ~((A&amp;B) | (C&amp;D); //逻辑功能描述 endmodule 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5813ba46f34f53d005b1a8a51e464129/" rel="bookmark">
			Java Instrument实践应用：运行中修改程序的Class
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Provides services that allow Java programming language agents to instrument programs running on the JVM. The mechanism for instrumentation is modification of the byte-codes of methods.【用于允许Java编程语言代理检测运行在JVM上的程序提供服务。检测的机制是修改方法的字节码。】
这是java.lang.instrument包的描述。使用 Instrumentation，使得开发者可以构建一个独立于应用程序的代理程序（Agent），用来监测和协助运行在 JVM 上的程序，甚至能够替换和修改某些类的定义。
如果还没入门或者想要更多知识，可以查阅
官方文档：https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html优秀博客：https://www.jianshu.com/p/b72f66da679f 我为什么会研究这个，刚开始是基于这样一个需求：有个远古项目是专门做直播APP的活动，每个活动都有对应的生命周期，加上没有做成模块化（我也在考虑怎么搞），久了之后大部分的活动都已经下线，只有极少的活动还在运营，就想着有什么办法可以检测到哪些代码是还会执行的，以便迁移。想过定时jstack或者Spring AOP，发现都不适合，幸好之前了解过这方面的知识，就觉得可以派上用场了。认真看了之后，发现平时遇到的几个痛点，也可以用Java Instrument解决（原本的需求后面再研究了...囧）：
线上定位问题，想要知道某个变量执行时的值（IDEA远程Debug？）：临时加日志记录变量的值性能优化，需要知道线上执行每一段代码的耗时：临时加日志记录代码执行耗时协助Tester去测试不可以造数据的场景（比如特定日期特定时间的逻辑）：临时写死某个变量的值 以上都涉及一个相同的需求：临时修改方法体。这时候，我们就可以使用Instrumentation的redefineClasses。
1、开发Agent-Class package cn.zhh; import java.io.IOException; import java.lang.instrument.ClassDefinition; import java.lang.instrument.Instrumentation; import java.nio.file.Files; import java.nio.file.Paths; /** * Agent-Class */ public class AgentMain { /** * 运行中代理入口 * * @param agentArgs 自定义参数 * @param inst 增强类 * @throws Exception 异常 */ public static void agentmain(String agentArgs, Instrumentation inst) throws Exception { // 自定义参数英文逗号分隔：[0]-class文件绝对路径，[1]-class全名 String[] args = agentArgs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5813ba46f34f53d005b1a8a51e464129/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cecbcfef0135fcb77b2c5efabe5f335/" rel="bookmark">
			Kotlin协程是个什么东西？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		theme: juejin 协程是什么 根据维基百科的定义，协程(Coroutine)是计算机程序的一类组件，推广了协作式多任务的子程序，允许执行被挂起与被恢复。
协程(Coroutine)并不是一个新词，马尔文·康威于1958年发明了术语“coroutine”，并将它用于汇编程序。而在其他语言，如Go、Python也都有协程的概念，所以它也不是Kotlin独有的。
在不同的语言层面上，协程的实现方式是不太一样的，本文介绍的Kotlin协程在本质上，它是一种轻量级的线程。
Kotlin协程是运行在线程中的，这里的线程可以是单线程，也可以是多线程。在单线程使用协程，比不使用协程的耗时并不会少。
上面介绍的都是协程的一些概念，以及Kotlin协程的特点。那究竟为什么会有Kotlin协程？它究竟比线程好在哪里？我们继续往下看。
Kotlin协程初认识 在Kotlin中，协程就是线程的封装，它提供了一套标准的API来帮助我们写并发任务。回想一下，在Java和Android中，我们是怎么写并发任务的？
Java实现多任务并发 在Java中，我们可以使用线程或者线程池来实现多任务并发： ``` //线程 new Thread(new Runnable() { @Override public void run() { //耗时的工作 } }).start();
//线程池 ExecutorService executor = Executors.newFixedThreadPool(3); executor.execute(new Runnable() { @Override public void run() { //耗时的工作 } }); ```
Android实现多任务并发 在Android中，除了可以通过Java的方式，创建线程、使用线程池实现多任务并发之外，还可以AsyncTask等方式来实现多个耗时任务的并发执行： //AsyncTask public abstract class AsyncTask&lt;Params, Progress, Result&gt; { //线程池中执行，执行耗时任务 protected abstract Result doInBackground(Params... params); //UI线程中执行，后台任务进度有变化则执行该方法 protected void onProgressUpdate(Progress... values) {} //UI线程执行，耗时任务执行完成后，该方法会被调用，result是任务的返回值 protected void onPostExecute(Result result) {} } 无论是Java还是Android提供的组件，都可以实现多任务并发的执行，但是上面的组件都或多或少存在着问题： - 耗时任务执行结束后，子线程要将结果传递回主线程，两者之间的通信不太方便。 - AsyncTask处理的回调方法比较多，当有多个任务时可能会出现回调嵌套。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cecbcfef0135fcb77b2c5efabe5f335/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7cf84d68bbd2e25c94e8854e77a821a/" rel="bookmark">
			ubuntu 优先无线上网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想必大家使用Ubuntu或其他版本Linux系统上网的时候，常常遇到这样一种情况，如果电脑同时连着有线网络跟无线(Wifi)网络，系统会默认(优先)使用有线网络，即使用有线网络的网关作为默认路由。这种情况下，如果无线(Wifi)能上外网，而有线却只能上内网，则系统因为默认走有线路由而无法上外网，唯一便捷的解决办法便是断开有线。然而在某些情况下，我们既需要连接无法上外网的有线(如与有线局域网内的他人共享文件)，又需要通过无线(Wifi)上外网，这样就需要更改系统的默认路由了。
因为本人经常遇到这种情况，有线IP地址192.168.200.69，无线IP地址：192.168.18.127，所以特意写了一个Shell脚本来解决这个问题，当无线网卡跟有线网卡同时启用时，优先使用无线路由器的网关。脚本代码如下：
#!/bin/sh # /home/trevor/cpplive/WifiGateway.sh wifi=`iwconfig | head -1 | awk '{print $1}'` echo "Wifi interface: $wifi" gw=`ip addr show $wifi | head -3 | tail -1 | awk '{print $2}'` echo "Wifi IP: "$gw gw=`echo $gw | awk -F. '{printf("%s.%s.%s.1",$1,$2,$3)}'` echo "Wifi gateway: "$gw echo "Set the Wifi gateway as the default gw now" route delete default route add default gw $gw echo "Set the Wifi gateway as the default gw end"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7cf84d68bbd2e25c94e8854e77a821a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2db89d75bd4049805b56ae2921929c1/" rel="bookmark">
			LAN8720A网络模块关于时钟的使用问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微雪的LAN8720A驱动电路：
正点原子LAN8720A驱动电路：
1、 nINTSEL Configuration 从原理图中可以看出正点原子的LAN8720A模块所使用的晶振是25M,而微雪的LAN8720A模块使用的晶振是50M,根据数据手册和结合原理图可以看出，
微雪的LAN8720A的nINTSEL没有接下拉，则是默认使用内部上拉到高电平，即nINTSEL=1，为REF_CLK In Mode模式，所以选用50M的晶振。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93e8c1d284a0631061dc765506e9c02f/" rel="bookmark">
			QListWidget使用体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主窗口继承QWidget
class CustomListWidgetDemo : public QWidget 自定义CustomListWidget继承QListWidget
class CustomListWidget:public QListWidget 主窗口添加CustomListWidget
注意事项：
1、主窗口添加CustomListWidget不能在使用paintEvent()，否则item显示不出来
2、主窗口用于绘制，但是获取不到落在CustomListWidget上的鼠标事件
3、CustomListWidget可以重写鼠标事件，但是不会响应绘制事件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbeed2e57e28fde111744fe064996c90/" rel="bookmark">
			iOS在手动kill进程时，再次调用了main函数的初始化流程问题排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iOS 应用在手动kill进程时，却再次调用了main函数的初始化，进而调用了AppDelegate的相关方法，进一步调用了部分页面的生命周期；
现象：app启动时没有调用部分接口，而是kill进程时调用了，再一些业务场景内是不能满足业务需求的
排查原因如下：
app的通知角标显示清除功能相关代码造成
- (void)bk_clearBadge { // 注释iOS11及以上代码，在iOS11及以上的APP沙盒内查看启动次数 if (@available(iOS 11.0, *)) { [UIApplication sharedApplication].applicationIconBadgeNumber = -1; } else if (@available(iOS 10.0, *)) { UNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init]; content.badge = @(-1); UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:@"clearBadge" content:content trigger:nil]; [[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) { }]; } else { UILocalNotification *clearEpisodeNotification = [[UILocalNotification alloc] init]; clearEpisodeNotification.fireDate = [NSDate dateWithTimeIntervalSinceNow:1]; clearEpisodeNotification.timeZone = [NSTimeZone systemTimeZone]; clearEpisodeNotification.applicationIconBadgeNumber = -1; [[UIApplication sharedApplication] scheduleLocalNotification:clearEpisodeNotification]; } } 在进入后台时，*- (void)applicationDidEnterBackground:(UIApplication )application; 内调用清除角标时，存在以下2种情况；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbeed2e57e28fde111744fe064996c90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b51a3777090b78416ebe030a91c90b58/" rel="bookmark">
			flutter全屏背景图(包括appbar和状态栏)以及沉浸状态栏的设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置背景图还是挺简单的，直接container里加个decration然后加个图片就行了，就像这样
import 'package:flutter/material.dart'; void main() =&gt; runApp(MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(title: 'Flutter Demo Home Page'), ); } } class MyHomePage extends StatefulWidget { MyHomePage({Key key, this.title}) : super(key: key); final String title; @override _MyHomePageState createState() =&gt; _MyHomePageState(); } class _MyHomePageState extends State&lt;MyHomePage&gt; { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(widget.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b51a3777090b78416ebe030a91c90b58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c39cba559cdde1d4a14a4149ae9cee0/" rel="bookmark">
			【Java 8 新特性】Java 8 Collectors: partitioningBy示例（将List按照满足条件和不满足条件分组）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 8 Collectors.partitioningBy是一种将流的元素始终分为两部分的方法。
它返回一个在Map中存储值的收集器。
在Map中的key只能是true或false。
此方法接收一个Predicate和返回一个Collector(收集器)。
语法如下
public static &lt;T&gt; Collector&lt;T,?,Map&lt;Boolean,List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate) 代码示例 Student.java
package com.concretepage.util.stream; public class Student { private String name; private int age; public Student(String name,int age){ this.name=name; this.age=age; } public String getName() { return name; } public int getAge() { return age; } } 我们将根据学生的年龄来划分他们。例如，我们将所有20岁的学生进行分区。年龄超过20岁的学生将是一个分区，其余的将是另一个分区。
核心代码
Map&lt;Boolean, List&lt;Student&gt;&gt; stdByClass = list.stream().collect(Collectors.partitioningBy(s -&gt; s.getAge() &gt; 20)); Collectors.partitioningBy接受将被定义为返回true或false的Predicate。
这个Predicate应用于流的所有元素。
Collectors.partitioningBy通过Stream.collect方法返回一个Map 收集器。
在Map中的key只能是true或false。
CollectorsPartitioningBy.java
package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c39cba559cdde1d4a14a4149ae9cee0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db9b43e13b2ffbe21d09392363fdd4c5/" rel="bookmark">
			链家武汉租房信息爬取并可视化数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬取的信息内容：区域,标题,二级区域,小区名字,大小,朝向,户型,租金
项目下载
链接：https://pan.baidu.com/s/15LcBtBARBlqs5xuJW4TgWQ
提取码：njp8
复制这段内容后打开百度网盘手机App，操作更方便哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a052efc78cfc1a515e3c08ce4f4e5b92/" rel="bookmark">
			html5 实现文件夹上传(保留目录结构)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们平时经常做的是上传文件，上传文件夹与上传文件类似，但也有一些不同之处，这次做了上传文件夹就记录下以备后用。
首先我们需要了解的是上传文件三要素：
1.表单提交方式:post (get方式提交有大小限制,post没有)
2.表单的enctype属性:必须设置为multipart/form-data.
3.表单必须有文件上传项:file，且文件项需要给定name值
上传文件夹需要增加一个属性webkitdirectory，像这样：
&lt;input id="fileFolder" name="fileFolder" type="file" webkitdirectory&gt;
不过webkitdirectory属性有个问题，只能支持高版本的chrome，不能支持低版本的IE，如ie6,ie7,ie8，不能做到全浏览器适配，运行环境比较单一。
js中可以判断文件夹中文件数量及文件夹大小是否符合要求，不符合要求不能向后台提交：
前台HTML模板
this.GetHtmlFiles = function()
{
var acx = "";
acx += '&lt;div class="file-item" id="tmpFile" name="fileItem"&gt;\
&lt;div class="img-box"&gt;&lt;img name="file" src="js/file.png"/&gt;&lt;/div&gt;\
&lt;div class="area-l"&gt;\
&lt;div class="file-head"&gt;\
&lt;div name="fileName" class="name"&gt;HttpUploader程序开发.pdf&lt;/div&gt;\
&lt;div name="percent" class="percent"&gt;(35%)&lt;/div&gt;\
&lt;div name="fileSize" class="size" child="1"&gt;1000.23MB&lt;/div&gt;\
&lt;/div&gt;\
&lt;div class="process-border"&gt;&lt;div name="process" class="process"&gt;&lt;/div&gt;&lt;/div&gt;\
&lt;div name="msg" class="msg top-space"&gt;15.3MB 20KB/S 10:02:00&lt;/div&gt;\
&lt;/div&gt;\
&lt;div class="area-r"&gt;\
&lt;span class="btn-box" name="cancel" title="取消"&gt;&lt;img name="stop" src="js/stop.png"/&gt;&lt;div&gt;取消&lt;/div&gt;&lt;/span&gt;\
&lt;span class="btn-box hide"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a052efc78cfc1a515e3c08ce4f4e5b92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e43095eee539188473ef3cbed9b698c3/" rel="bookmark">
			用EasyExcel读取excel文件并传入数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目要求将excel文件中的课程数据传到数据库中，并且excel中的数据使分类的。
0.前言
整个流程介绍
现在controller中声名路径，通过调用方法saveSubject()来上传excel文件，在service中创建saveSubject()中，在serviceImpl中实现此方法，saveSubject中调用EasyExcel的read方法
，此方法必须实现监听器SubjectExcelListener，在监听器中来读取excel数据，是一行一行的读取的。根据文件的特点，第一分类和第二分类的名字不能重复，传入的名字为空则加入，不为空则拒绝添加。所以，设置一个方法来解决这个问题，设比如前端为第一分类，vue为第二分类，每个名都有一个id和一个parent_id，第一分类的parent_id就是0，第二分类的p_id就是第一分类的id，通过传入的名称和p_id=0通过subjectService.getOne(wrapper);此方法判断第一分类是否为空，判断第二分类同样的方法。添加的时候来调用这两个方法来判断第一分类和第二分类是否添加。
还有因为SubjectExcelListener不能交给spring管理，需要 自己new，不能注入其他对象，所以要自己传入serviceimpl，具体是实现代码中已经写了
1.用代码生成器生成所需要文件夹及java文件
具体在这篇如何使用代码生成器
用代码生成器也创建了与数据库所对应的实体类
注意：时间使用的自动填充机制
@Data @EqualsAndHashCode(callSuper = false) @Accessors(chain = true) @TableName("edu_subject") @ApiModel(value="Subject对象", description="课程科目") public class Subject implements Serializable { private static final long serialVersionUID = 1L; @ApiModelProperty(value = "课程类别ID") @TableId(value = "id", type = IdType.ID_WORKER_STR) private String id; @ApiModelProperty(value = "类别名称") private String title; @ApiModelProperty(value = "父ID") private String parentId; @ApiModelProperty(value = "排序字段") private Integer sort; @ApiModelProperty(value = "创建时间") @TableField(fill = FieldFill.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e43095eee539188473ef3cbed9b698c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/157d9e7595e701cb748ff6fc1f9837e8/" rel="bookmark">
			spring boot使用redis、缓存穿透、雪崩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot连接redis 使用redisTemplate该类可以存放任意类型的数据，但是该类型的数据 必须实现序列，获取redis中对应的数据时，会进行反序列化。 如果 使用RedisTemplate建议大家指定key，value，以及hashkey的序列 化方式 配置 配置类
@EnableCaching @Configuration public class RedisConfig extends CachingConfigurerSupport { @Bean public CacheManager cacheManager(RedisConnectionFactory factory) { RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); //解决查询缓存转换异常的问题 ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); // 配置序列化（解决乱码的问题）,过期时间600秒 RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofSeconds(600)) //缓存过期10分钟 ---- 业务需求。 .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))//设置key的序列化方式 .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer)) //设置value的序列化 .disableCachingNullValues(); RedisCacheManager cacheManager = RedisCacheManager.builder(factory) .cacheDefaults(config) .build(); return cacheManager; } } redis使用场景 （1）作为缓存 1. 减少数据库的访问频率。 提高数据的访问率。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/157d9e7595e701cb748ff6fc1f9837e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4565a3dbb11ed83dd8c441c7cfc4ba1a/" rel="bookmark">
			SQLServer msdb备份信息清除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信数据库运维同学都知道，随着时间的推移，每天备份产生的记录累计越来越多。不仅在系统数据库 msdb 记录下来，SQL Server 的错误日志也会记录相应信息。如果我们不定时清理，长此以往使数据越来越多。
我们查看msdb数据库，看看哪张表数据较多。
select OBJECT_NAME(id),rows from msdb.sys.sysindexes where indid in(0,1)and rows &gt; 0order by rows desc 有2个系统存储过程，可将这些记录清除。
sp_delete_backuphistory [ @oldest_date = ] 'oldest_date' sp_delete_database_backuphistory [ @database_name = ] 'database_name' sp_delete_backuphistory 按日期删除；
sp_delete_database_backuphistory 按数据库删除；
存储过程将清除以下表数据：
backupfile
backupfilegroup
restorefile
restorefilegroup
restorehistory
backupset
backupmediafamily
backupmediaset
不过，上面并非最优方法。当这些表数据量较多的时候，删除是非常慢的，因为这些表之间有外键关联。较好的方法是使用 truncate 清空表数据。毕竟这些记录我们暂时没什么用。在 truncate 前，先把外键给删除掉。
use msdb go select oMain.name AS [主表名称],oSub.name AS [子表名称],fk.name AS [外键名称],MainCol.name AS [主表列名],SubCol.name AS [子表列名] ,'ALTER TABLE [dbo].['+oSub.name+'] DROP CONSTRAINT ['+fk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4565a3dbb11ed83dd8c441c7cfc4ba1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9027e4a227d6a3dbd33e0b9e795155c/" rel="bookmark">
			restTemplate返回字符乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.乱码原因返回的中文以ISO_8859_1编码返回，编码转换即可
new String(body.getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8); 具体解决实例如下
RequestEntity&lt;String&gt; gh = RequestEntity.post(new URI("")).header("GH", "").body(""); ResponseEntity&lt;String&gt; exchange = restTemplate.exchange(gh, String.class); String body = exchange.getBody(); String s = new String(body.getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8); 另外乱码2情况，经过url编码的解码即可
URLDecoder.decode("", StandardCharsets.UTF_8.toString()); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8543c3e9fea9022be3618a562184b230/" rel="bookmark">
			games101【lecture13-16】Ray Tracing—辐射度量学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Basic radiometry (辐射度量学) 学习思路：为甚要学？学的是什么？它是怎样做的
提出动机 Blinn-Phong model 存在一定的问题——光的一些强度之类精确定义 定义及作用 如何去描述光照定义了光的属性： Radiant fluxintensityirradianceradiance Radiant Energy and Flux (Power) lm = lumen 表示灯泡有多亮
或者说flux为一个感光元件，单位时间内感受到的光。
光的衡量 Radiant Intensity ：任何一个物体散发的能量Irradiance：物体表面接收到的能量Radiance：光线传播过程中的能量
Radiant Intensity 定义 The radiant (luminous) intensity is the power per unit solid angle emitted by a point light source. （立体角上的能量）
立体角的探讨 2D：对于一个θ角，其等于l/r，也就是弧长和半径的比值，总的角度为2Π3D：推广到三维则有Ω= A/(r的平方)，也就是因此其立体角则可根据如下计算得到，θ为球体在z轴的夹角，Φ为x轴的夹角
Irradiance **定义：**The irradiance is the power per unit area incident on a surface point. （**光线投射垂直到接受面的面积，类比与之前的Lambert’s Cosine Law **）
已知irradiance是单位面积上能量，那么可以看作如下方式计算：从半径为1，和半径为r上去计算点光源圆周单位面积的能量。实际上并不是光的intensity在衰减，而是随着距离增加，其irradiance在衰减。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8543c3e9fea9022be3618a562184b230/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6eeb6d8a824ddfc2c085f71ee0b60ea/" rel="bookmark">
			node.js动态加载数据库数据响应到html页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		node.js响应html页面 // http.js // 开启监听，将请求处理放在luyou页面上 // 服务器启动模块 var http = require('http'); var luyou = require('./luyou'); // 创建服务 var server = http.createServer(); // 调用luyou模块中的bind方法，设置监听事件 luyou.bind(server) // 设置服务器的监听端口 server.listen(8090, function() { console.log('访问127.0.0.1:8090') }) //luyou.js // 将响应逻辑放在yewu.js页面 var yewu = require('./yewu') var fs = require('fs') // 导出数据（bind方法） // bind设置监听 module.exports.bind = function(server) { server.on('request', function(request, response) { const url = request.url; if (url == '/') { // 调用yewu模块获取data response.end(yewu.data) } else { // 接收静态资源请求并安装请求路径响应 fs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6eeb6d8a824ddfc2c085f71ee0b60ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ba44ad5719d90c234584f564bfe08f7/" rel="bookmark">
			Java数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java数组 数组概述数组声明、创建及初始化数组特点内存分析数组边界 数组使用For-Each循环 多维数组Arrays类冒泡排序稀疏数组 数组概述 数组的定义：
数组是相同数据类型的有序集合数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成每个数据称作一个数组元素，每个数组元素可以通过一个下标来访问 数组声明、创建及初始化 //数组声明 dataType[] arrayRefVar;//首选方法 dataType arrayRefVar[];//效果同上，但非首选 //数组创建 arrayRefVar = new dataType[arraySize];//创建 dataType[] arrayRefVar = new dataType[arraySize];//声明+创建 //数组初始化 //静态初始化 int[] a = {1,2,3}; Man[] mans = {new Man(1,1),new Man(2,2)};//引用类型 //动态初始化：包含默认初始化 int[] a = new int[2]; a[0] = 1; a[1] = 2; //默认初始化 //数组是引用类型，数组元素相当于类的实例变量，因此数组一经分配空间，每个元素也被按照实例变量同样的方式隐式初始化	/* 注：数组的元素是通过索引访问的，数组索引从0开始 通过array.length获取数组长度 */ 数组特点 长度确定，数组一旦被创建，大小不可变元素必须是相同类型数组元素可以是任何数据类型数组变量属于引用类型数组本身就是对象，Java中对象在堆中，所以无论数组保存原始类型还是其他对象类型，数组对象本身是在堆中的 内存分析 堆：存放new的对象和数组；可以被所有的线程共享，不会存放别的对象引用栈：存放基本变量类型（包含具体值）；引用对象的变量（包含引用在堆里的具体地址）方法区：可以被所有的线程共享，包含所有的class和static变量 数组边界 下标的合法区间：[0,length-1]
数组下标越界异常：ArrayIndexOutOfBoundsException
数组使用 For-Each循环 //没有下标地遍历数组 int[] arrays = {1,2,3,4,5}; for(int array : arrays){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ba44ad5719d90c234584f564bfe08f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eb5085ccf74a484eb30aa4b5cd190d9/" rel="bookmark">
			docker启动redis|mysql服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker pull redis
docker pull mysql
拉取redis、mysql 镜像
docker 启动 redis 服务
docker run # -itd (i)以交互模式运行容器，通常与 -t 同时使用 (t)为容器重新分配一个伪输入终端，通常与 -i 同时使用(t)后台运行容器，并返回容器ID
-p 16379:6379 # 端口映射
--name redis_26379 # 容器名称
-v /docker/redis/redis.conf:/etc/redis/redis.conf # 映射配置
-v /docker/redis/data:/data # 映射数据持久化位置
-itd redis redis-server /etc/redis/redis.conf # 根据配置进行启动
--requirepass "123456" # 设置密码
--appendonly yes # 数据持久化
docker run --privileged=true -p 6379:6379 --name myredis -v /home/workspace/redis:/home/workspace/redis -v /home/workspace/redis/redis.conf:/etc/redis.conf -itd redis redis-server /etc/redis.conf redis.conf
daemonize no port 6379 #unixsocket /home/workspace/redis/run/myredis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7eb5085ccf74a484eb30aa4b5cd190d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4fb4dadaea7163984c1e1649d0f2159/" rel="bookmark">
			keep-alive include和exclude无效问题，踩坑！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		include 使该标签作用于所有name属性的值跟此标签 include的属性值一致的vue页面
exclude 使该标签不作用于所有name属性的值跟此标签 exclude的属性值一致的vue页面
然后我就掉进坑里了，配置了一堆路由的name！！！！！无效！！！
使用include/exclude 属性需要给所有vue类的name赋值（注意不是给route的name赋值），否则 include/exclude不生效
正确写法是：
export default { name:'a', // include 或 exclude所使用的name data () { return{ } }, } 路由：
// 保持 name为a和b的组件
&lt;keep-alive include="a,b"&gt; &lt;router-view/&gt; &lt;/keep-alive&gt; vue2.0版本后，keep-alive内置组件已经封装了两个属性，include和exclude表示那些组件需要缓存那些组件不需要缓存，用法大致如下:
另外：
activated,deactivated这两个生命周期函数一定是要在使用了keep-alive组件后才会有的，否则则不存在
原文链接：https://blog.csdn.net/qq_31173561/article/details/89518759
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99a9d3aaa6fd157af1fc47eb4654cfb0/" rel="bookmark">
			材质和着色器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是我在《Unity游戏优化 (第2版)》看的，记录一下~ 在Unity中，渲染状态本质是通过材质呈现给开发者的
那么材质是啥呢？
材质是着色器的容器
着色器又是啥呢？
着色器是一种用于定义GPU应该如何渲染输入顶点和纹理数据的简短程序
本身没有必要的状态信息来完成任何有价值的工作
需要诸如漫反射纹理、法线映射和光照信息之类的输入，并有效地规定了为了呈现传入的数据需要设置哪些渲染状态变量
PS：
着色器最初仅实现为处理对象的光照和着色
现在已经有额外的功能了，但是还用这个名字
其关系：
每个着色器都需要一个材质，每个材质必须有一个着色器
导入新场景中的网格，如果没有赋予材质，就会被自动赋予默认材质
如果需要对一个网格使用多个着色器，需要将多个材质赋予该网格的不同部位
如果想最小化渲染状态修改的频率，可以减少场景中使用的材质数量
Game窗口中的Stats弹出的 Batches 值共有8个批处理，该值严格等于渲染场景使用的Draw Call数量
（需要关闭影子显示以及静态动态批处理）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/293c6bc92f148ec03cb0500379a75934/" rel="bookmark">
			网站故障案例总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、写日志引发故障 【故障现象】：应用服务集群发布后不久就出现多台服务器相继报警，硬盘可用空间低于警戒值，并且很快有服务器宕机。登录在线上服务器，发现 log 文件夹里面的文件迅速增加，不断消耗磁盘空间。
【原因分析】：这是一个普通的应用服务器集群，不需要存储数据，因此服务器使用的是一块 100GB 的小硬盘，安装完操作系统、Web 服务器、Java 虚拟机、应用程序后，空闲空间就剩几十GB，正常情况下这些磁盘的空间足够，但是该应用的开发人员将 log输出的 level全局配置为 Debug。这样一次简单的 web请求就会产生大量的 log文件输出，在高并发的用户请求下，很快就消耗完不多的磁盘空间。
OFF：OFF Level是最高等级的，用于关闭所有日志记录。
FATAL：FATAL Level指出每个严重的错误事件将会导致应用程序的退出。
ERROR：ERROR Level指出虽然发生错误事件，但仍然不影响系统的继续运行。
WARN：WARN Level表明会出现潜在错误的情形。
INFO：INFO Level表明 消息在粗粒度级别上突出强调应用程序的运行过程。
DEBUG：DEBUG Level指出细粒度信息事件对调试应用程序是非常有帮助的。
TRACE：TRACE Level最详细的日志信息。
ALL：ALL Level是最低等级的，用于打开所有日志记录。
【经验教训】：①、应用程序的日志输出配置和第三方组件日志输出要分别配置；②、检查生产 log配置文件，日志输出级别至少为 WRAN，并且检查 log输出代码调用，调用级别要符合其真实日志级别。③、有些开源的第三方组件也会不恰当地输出太多的 Error日志，需要关闭这些第三方库的日志输出。
二、高并发访问数据库故障 【故障现象】：某应用发布后，数据库 Load居高不下，远超过正常水平，持续报警。
【原因分析】：检查数据库，发现报警是因为某条 SQL 引起的，这条 SQL 是一条简单的有索引的数据查询，不应该引发报警。继续检查，发现这条 SQL 执行频率非常高，远远超过正常水平。追查这条 SQL，发现被网站首页应用调用，首页是被访问最频繁的网页，这条 SQL 被首页调用，也就被频繁执行。
【经验教训】：①、首页不应该访问数据库，需要的数据可以从缓存服务器或者搜索引擎服务器获取。②、首页最好是静态的。
三、缓存引发的故障 【故障现象】：没有新应用发布，但是数据库服务器访问突然飙升，并很快失去响应。DBA 将数据库访问切换到备库，Load 也很快飙升，并失去响应。最终引发网站全部瘫痪。
【原因分析】：缓存服务器在网站服务器集群中的地位一直较低，服务器配置和管理级别都比其他服务器要低一些。认为缓存时改善性能的手段，丢失一些缓存也没关系，有时候关闭一两台缓存服务器也确实对应用没有明显影响，所以长期疏于管理缓存服务器。结果这次缺乏经验的工程师关闭了缓存服务器集群中全部的十几台缓存服务器，导致网站瘫痪的重大事故。
【经验教训】：当缓存已经不仅仅是改善性能，而是成为网站架构不可或缺的一部分时，对缓存的管理就需要提高到和其他服务器一样的级别。
四、应用启动顺序引发的故障 【故障现象】：某应用发布后立即崩溃。
【原因分析】：应用程序 WEB环境使用 Nginx+Jetty 的模式，用户请求通过 Nginx 转发给 Jetty。在发布时，Nginx 和 Jetty 同时启动，有于 Jetty 启动需要加载很多应用并初始化，花费时间较长，结果 Jetty 还没有完全启动，Nginx 就应经启动完成开始接收用户请求，大量请求阻塞在 Jetty 进程中，最终导致 Jetty 崩溃。网站中还有很多类似的场景，都需要后天服务准备好，前台应用才能启动，否则就会出现故障。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/293c6bc92f148ec03cb0500379a75934/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/116124bbe1bd52229fdbb4422fcd9250/" rel="bookmark">
			IntelliJ IDEA远程连接虚拟机Linux服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 在虚拟机上安装openssh-server 1.1 安装openssh-server sudo apt-get install openssh-server 1.2 开启openssh服务 sudo /etc/init.d/ssh start 1.3 验证是否开启服务 如果有输出 sshd 证明已经开启ssh服务
ps -e | grep ssh 2. 查看虚拟机IP地址 2.1 安装网络工具包 sudo apt install net-tools 2.2 查看虚拟机IP地址 ifconfig inet后面的即为虚拟机的IP地址
3. IntelliJ IDEA远程连接虚拟机Linux服务器 3.1 打开配置 3.2 选择SFTP进行配置 3.3 对SSH进行配置 主机：虚拟机IP
端口：默认22
用户名：虚拟机用户名
密码：虚拟机用户密码
3.4 测试 最后，点击测试连接即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f665f77ca5ef20866ba24188afaa236/" rel="bookmark">
			性能测试自动化平台（三）后端逻辑实现（python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		入口 from flask import Flask from flask_cors import * app=Flask(__name__) CORS(app, supports_credentials=True) @app.route('/') def index(): return 'index' from vuejmeterauto.uploadfile import * app.register_blueprint(upload_blue) from vuejmeterauto.updatejenkins import * app.register_blueprint(update_blue) from vuejmeterauto.MatchFilename import * app.register_blueprint(match_blue) from vuejmeterauto.Getjmxdata import * app.register_blueprint(getjmx_blue) if __name__ == '__main__': app.run(host='XXX', port='50055', debug=True) 在线编辑页面的相关操作 from flask import request,Blueprint import os import re import threading from vuejmeterauto.uploadfile import file_to_git getjmx_blue = Blueprint("getjmx",__name__) file_path = r"E:\test\esg-cemp-core-auto-test-project" #获取jmx文件 @getjmx_blue.route('/getjmxfile',methods=['GET','POST']) def getjmxfile(): jmx_name = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f665f77ca5ef20866ba24188afaa236/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da6845cf5c09b935b48bd3b10d994ea7/" rel="bookmark">
			【PAT B1030/A 1085】 完美数列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个正整数数列，和正整数 p，设这个数列中的最大值是 M，最小值是 m，如果 M≤mp，则称这个数列是完美数列。
现在给定参数 p 和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
输入格式：
输入第一行给出两个正整数 N 和 p，其中 N（≤10^ 5​ ）是输入的正整数的个数，p（≤10^ 9 ）是给定的参数。第二行给出 N 个正整数，每个数不超过 10^9。
输出格式：
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
输入样例：
10 8 2 3 20 4 5 1 6 7 8 9 输出样例：
8 思路：首先将数列元素从小到大排序，从i=0开始扫描，用j记录扫描的位置，为了节省时间，j的扫描起始位置设为i+之前完美数列的长度，若满足定义，则不断更新结果，直到不满足时跳出循环，i从下一个位置接着开始。
#include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; const int maxn = 100010; int a[maxn]; int main() { int N; long long p;//防止p*a[i]时溢出 scanf("%d %lld", &amp;N, &amp;p); for (int i = 0; i &lt; N; i++) { scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da6845cf5c09b935b48bd3b10d994ea7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d4ac18c60fd870cdbec674f1e799dea/" rel="bookmark">
			结构光三维-精度不够解决方案：双目结构光
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）增加相机分辨率
https://blog.csdn.net/clipp_Huang/article/details/78802487?spm=1001.2014.3001.5501 作者测试，使用500w相机比130相机精度提高了10倍，到0.005mm，130w的是0.05mm
2）使用双目结构光
单目与双目的区别：
双目只需要两个相机单独标定然后两个相机联合标定，不需要与结构光做相位展开标定，但需要做相位匹配才能重建。利用的就是双目视差原理获取深度信息（三维信息）
单目需要与结构光做相位展开标定，得到相位解包裹数据后，使用标定参数换算三维数据，这种方案不用做双目的相位匹配，所以速度快。
相同分辨率下双目精度高,如果单目的分辨率高于双目那单目的精度也会高些
***这种方案能重建的区域只是双目的公共区域
双目结构光实现：
结合立体视觉极线约束确定左右相机的对应性关系；最后，根据预先标定好的系统参数通过三角测量法计算三维坐标。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ea56bb800dfc0dbbe1c1c7b2c090738/" rel="bookmark">
			中文字体的FontMetrics解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中文字体的FontMetrics解析 因行业对字体大小要求严格参考相关规范，因此对通过渲染引擎绘制的文本字体把控严格。
而在Skia/openGL/Qt等主流渲染引擎中，所有设置字体大小（FontSize），都是以英文字体大小作为标准的，准确来说，对应的应该是FontMetrics中的CapHeight作为英文字体高度。
笔者发现在网络上相关资料中，很少有关于中文字符的FontMetrics解析。通过多日研究后，在此详细解析一下中文字体的FontMetrics。
一、FontMetrics标准解析 研究发现，基本所有的渲染引擎都采用以下的字体绘制结构，以下简称标准
这里各个属性都已经描述的很清楚了，网络上其余各个版本的，都不太正确。
为了对比，我使用Skia渲染引擎绘制了同样的文字来做对比，效果如下：
实际上实测的效果还是与网上流传的示意图有一定差异的。
1、大部分字体，字符的顶部触碰不到AscentLine。AscentLine用于带上标的字符、拉丁文字符等
2、对于输入的字符不同，计算的Top、Bottom位置并非不变的。(例如斜体单个字符h的Top、Bottom就要比非斜体jEh要窄些)
大体上都参考标准，研究得出几条结论：
1、英文正常高度为Baseline到CapHeight线
2、最低位置到Descent线处
3、带上标的字符最高到Ascent线处
4、斜体并不改变字体高度
二、中文字符的FontMetrics 绘制引擎就是按照英文字符构造来设计的几条线，压根没考虑中文字符的感受。
假设设置字体高度为100像素，绘制出来的英文字体为100个像素，对于中文来说，往往是会放大。所有的字体的中文的字符都不会在CapHeight内
以宋体和等线体为例：
注：与上图英文字符的绘制线一样，绿色的Ascent与Descent和Top与Bottom几条线重合了，因此绿色看不出来是绿色了。
可以清楚的看到，无论哪种字体，中文字符都不在CapHeight和BaseLine之间。而且并不与任一条线接触。
理论上来说，我们需要将中文字符的高度改成我们设置的高度，就需要缩放。
公式为：
因此，想要知道需要设置的字体高度，公式为：
其中，中文字符应有高度为100像素，当前设置字体高度为100像素，所以只需要量算出中文字符当前高度，就能计算出这个应设置的字体高度。
但是目测量算的都不准确，应该使用FontMetrics中有的属性来确定真实值。
经过多测量算、推演，得出以下规律：
1、以宋体、仿宋体等为代表的标准中文字体类型：
上下两条紫色线为中文字符上下限高度
中文字符下限为UnderLinePos，上限为 Capheight + DescentLine
是的没有看错，上线是DescentLine(即BaseLine到DescentLine的距离)，而不是AscentLine。
实际上AscentLine与Top重合了，是要比DescentLine要大一点
至于为什么是DescentLine实际上我也不明白，但能肯定的是这不是偶然。无论如何缩放这个值始终是能和中文字符上线重合，一定存在规律。
2、以等线体为代表的的中英文字体类型：
这类字体非常奇怪，首先英文字符的下限并没有到Descent，甚至没有到UnderLine，与纯英文字体如Times NewRoman等规律就不同。
中文字符也是不能符合上面宋体的规律。
但经过多次推算（不同尺度下），发现一个规律：
中文字符高度 = CapHeight + UnderLinePos
能得出这个结论我也是比较疑惑的，没有任何API、文献资料能证明这条规律，但事实上它就是如此。
得出中文字符高度后，再带入公式，求出应该设置的FontSize，再设置新FontSize，绘制出来的中文字符，就是我们想要的字体高度了。 至此，中文字符高度的计算工作完毕。
期间使用到的代码：
1.绘制字体基准线代码
paint.setStyle(SkPaint::kStroke_Style); paint.setStrokeWidth(3); paint.setColor(0xffff0000);//红色为fTop\fBottom\BaseLine double y = p.y(); canvas-&gt;drawLine(p.x(), y, p.x() + length, y, paint); y = p.y() - font_m.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ea56bb800dfc0dbbe1c1c7b2c090738/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddfb88ac59f6dad107b812a7022918d7/" rel="bookmark">
			“Caused by: org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:”的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android studio升级到最新版本之后出现 “Caused by: org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:”的报错提示：
如下图：
解决方法： 将 “File – Project Structure – Project ”路径下的Gradle version改为最新版本：
步骤如下：
1）点击左上角的File--&gt;Project Structure
2）将Gradle Version 里的版本号改为最新的版本号（例如我原本这里是默认选择了6.5版本，最新版本是7.0，那么就选择7.0版本的）
3）接下来就会Android studio 就会去下载你选择的那个gradle version,下载成功之后就能够正常编译了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b56e1aeaf2eab99ba1dc8036d37e1b3c/" rel="bookmark">
			zset实现奖牌排行榜案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现效果
首先创建需要一个JavaBean来存储数据
@Data @AllArgsConstructor @NoArgsConstructor public class Rank { private String country; private int score; private int goldCount; private int silverCount; private int copperCount; } service层
@Service @Slf4j public class RankingServiceImpl implements RankingService { @Autowired private RedisTemplate&lt;String,String&gt; redisTemplate; @Override public List&lt;Rank&gt; ranking(String country,Double score) { if(country==null||country.equals("")){ }else{ redisTemplate.opsForZSet().incrementScore("rank",country,score); } Set&lt;String&gt; set = redisTemplate.opsForZSet().reverseRange("rank", 0, -1); List&lt;Rank&gt; list=new ArrayList&lt;&gt;(); for (String s : set) { Rank rank1 = new Rank(); Double rank = redisTemplate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b56e1aeaf2eab99ba1dc8036d37e1b3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5c434619d35584b6ca492d939235da6/" rel="bookmark">
			用Redis实现限制登录功能案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		限制登录功能 需求描述：
用户在2分钟内，仅允许输入错误密码5次。 如果超过次数，限制其登录1小时。（要求每登录失败时，都要给相应提式） service层
@Service public class LoginServiceImpl implements LoginService { @Autowired private RedisTemplate&lt;String,String&gt; redisTemplate; @Override public int login(String username, String password) { //判断用户名是否存在 if(!redisTemplate.hasKey(username)){ return 3800; } //判断当前用户是否被限制，若被限制，返回剩余限制时间 if(redisTemplate.hasKey("username"+username)){ long time = redisTemplate.opsForValue().getOperations().getExpire("username" + username); return (int) time; } //根据用户名获取密码 String pwd = redisTemplate.opsForValue().get(username); //判断数据库中是否有登录次数标记，如果没有说明当前用户还没有登录过，将次数设置为5次，时间设置为2分钟 if(!redisTemplate.hasKey("count"+username)){ redisTemplate.opsForValue().set("count"+username,"3675"); redisTemplate.opsForValue().set("counttime"+username,"",2,TimeUnit.MINUTES); } //判断当前用户2分钟内是否已经输了五次密码，没有输到五次，则重置2分钟内可登录5次 if(!redisTemplate.hasKey("counttime"+username)){ redisTemplate.opsForValue().set("count"+username,"3675"); redisTemplate.opsForValue().set("counttime"+username,"",2,TimeUnit.MINUTES); } //如果密码一致，就删除次数的记录和2分钟的时间记录 if(password.equals(pwd)){ redisTemplate.delete("count"+username); redisTemplate.delete("counttime"+username); return 3665; }else{ //如果密码不一致，计数器减一 redisTemplate.opsForValue().decrement("count"+username); String count = redisTemplate.opsForValue().get("count"+username); //如果输入五次不正确，添加当前用户被限制登录1小时的倒计时,并且删除次数标记和2分钟时间标记 if(count.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5c434619d35584b6ca492d939235da6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4ffcb2b118df7b1b0290739078f66b3/" rel="bookmark">
			stl标准库系列之--deque
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、概述 deque 是 double-ended queue 的缩写，又称双端队列容器。是由一段一段的定量连续空间构成，可以向两端发展，因此不论在尾部或头部安插元素都十分迅速。 在中间部分安插元素则比较费时，因为必须移动其它元素。
我们看下deque的示意图。
2、与vector的区别 vector是单向开口的连续性空间，deque则是双向开口的连续空间（连续是假象）。deque 容器也擅长在序列尾部添加或删除元素（时间复杂度为O(1)），而不擅长在序列中间添加或删除元素。vector扩容时经历了申请空间、复制、释放原空间的过程，deque是在头或尾增加一端定量的连续空间，动态的以分段连续空间组合而成。vector对头部的操作比较耗时，但deque擅长对头部元素进行操作，时间复杂度为O(1)。vector存储的元素是在连续的空间中，deque不能保证连续空间。deque的迭代器较vector迭代器来说复杂的多，因此，除非必要，请尽可能选择vector而非deque。 3、中控器的概念 上面我们看到了，deque与vector还是有明显的区别的。并且deque的连续空间是断章取义的。deque有一段一段的定量连续空间构成。如果在deque的头或者尾增加新空间。deque便会配置一段定量的连续空间，拼接在deque的头或者尾部。保证这些连续空间上的连续假象。避免和vector一样申请、复制、释放。代价是比较复杂的迭代器设计。
deque采取一块有连续空间的map（该map非stl中map）作为中控。该map的元素（我们可以看作是链表中的节点 - node），都是指针。指向另一段比较大的连续空间（称作缓冲区）。这些缓存区才是deque容器的存储主体。
简单来说，我们可以理解为：在内存中有大小相同、彼此不连续的 n 个空间（这些空间各自是连续的）。另外有一块连续的空间，这个空间里面保存了前面的那 n 个空间的指针。我们把这一块连续的空间，称作是deque的中控器。
举个简单的例子，我家有好多粮仓，但是了这些粮仓遍布在整个城市的各个区域，而在郊外的大别墅里面了，有一块地方保存着去这些粮仓的地图。
template &lt;class _Tp, class _Alloc&gt; class _Deque_base { public: typedef _Deque_iterator&lt;_Tp,_Tp&amp;,_Tp*&gt; iterator; typedef _Deque_iterator&lt;_Tp,const _Tp&amp;,const _Tp*&gt; const_iterator; protected: _Tp** _M_map;	//中控器 size_t _M_map_size; //中控器的大小 }; 由上面的定义我们可以很明显的看出，map是一个指针，并且定义了size_t类型的变量来表示map的大小。我们再来看下map的初始化。
template &lt;class _Tp, class _Alloc&gt; void _Deque_base&lt;_Tp,_Alloc&gt;::_M_initialize_map(size_t __num_elements) { size_t __num_nodes = __num_elements / __deque_buf_size(sizeof(_Tp)) + 1; _M_map_size = max((size_t) _S_initial_map_size, __num_nodes + 2); _M_map = _M_allocate_map(_M_map_size); _Tp** __nstart = _M_map + (_M_map_size - __num_nodes) / 2; _Tp** __nfinish = __nstart + __num_nodes; __STL_TRY { _M_create_nodes(__nstart, __nfinish); } __STL_UNWIND((_M_deallocate_map(_M_map, _M_map_size), _M_map = 0, _M_map_size = 0)); _M_start.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4ffcb2b118df7b1b0290739078f66b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc07453f440be674952e7212faa0ae3e/" rel="bookmark">
			win10安装vue-devtools 、Node.js、 npm和 yarn 总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装NODE.JS npm 和 cnpm 进入网站 http://nodejs.cn/download/ 下载稳定版的x64的msi文件，双击安装Node.js到D:\ProgramData\nodejs 目录下，安装时选择 Add To PATH , 安装完成后finish.
win +R 打开打开CMD ，输入 echo %PATH% 检查npm的本地仓库 C:\Users\Administrator\AppData\Roaming\npm 和 安装目录 D:\ProgramData\nodejs\;是否在环境变量中；
输入node -v 和npm -v 检查是否正常显示版本号；cmd输入命令安装cnpm： npm install -g cnpm --registry=https://registry.npm.taobao.org 再输入： cnpm -v 检查版本。
在安装目录 D:\ProgramData\nodejs下新建两个文件夹 node_cache 和node_global ， 用来存储C盘移动过来 的用户目录和缓存目录； cmd运行以下命令来完成移动
5. 以下要输的命令很多：
npm config set prefix "D:\ProgramData\nodejs\node_global"
npm config set cache "D:\ProgramData\nodejs\node_cache"
输入命令npm list -global 查看 npm的本地仓库；它显示D:\ProgramData\nodejs\node_global `-- (empty) 输入命令npm config set registry=http://registry.npm.taobao.org 配置镜像站
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc07453f440be674952e7212faa0ae3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05ee8f990c449011699a23864cf8c31d/" rel="bookmark">
			gitlab ci 集成gtest
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gitlab的ci/cd功能为工程中的持续集成与部署带来便利，让项目快速迭代，但是也许你的公司内使用的步骤只有编译和发布，这样是没有问题（在大多数情况下）。不过ci中其实是可以集成单元测试的，这样会让程序更稳定、可靠。
集成的方法：
1.首先在仓库的根目录要有“.gitlab-ci.yml”这个文件，这个是gitlab执行ci的脚本文件是yml格式的
2.了解该文件的基本语法，以及执行ci的命令，一般执行build的命令大致为：
stages: - build before_script: - your_before_script docker-build: stage: build script: - your_docker_build_script after_script: - your_after_script only: - web when: manual tags: - your_runner web：对于使用GitLab UI中的“运行管道”按钮创建的管道。only：限制创建作业的时间；
tags：用来构建工程的runner；
when：manual，手动执行。
3. 集成单元测试gtest：
其实就是在stages里加上test项
stages: - test - build before_script: - your_before_script unit-test: stage: test script: - docker build -f ./Dockerfile_test . only: - web when: manual tags: - your_runner docker-build: stage: build script: - your_docker_build_script after_script: - your_after_script only: - web when: manual tags: - your_runner 核心语句是“- docker build -f .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05ee8f990c449011699a23864cf8c31d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fcd318f15da6d0f5287d760bf116021/" rel="bookmark">
			Minio报错Access denied 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 java程序在调用Minio api报错信息如下 Error occurred: error occurred ErrorResponse(code=AccessDenied, message=Access denied, bucketName=f3e0a479-60da-45c8-9ac2-5b744a92d419, objectName=null, resource=/f3e0a479-60da-45c8-9ac2-5b744a92d419, requestId=15E37CD9D06980DF, hostId=null) request={method=HEAD, url=http://125.220.157.228:83/f3e0a479-60da-45c8-9ac2-5b744a92d419, headers=Host: 125.220.157.228:83 User-Agent: MinIO (amd64; amd64) minio-java/dev x-amz-date: 20191225T023929Z } response={code=403, headers=Server: nginx/1.13.6 Date: Wed, 25 Dec 2019 02:39:29 GMT Content-Length: 0 Connection: keep-alive Accept-Ranges: bytes Content-Security-Policy: block-all-mixed-content Vary: Origin X-Amz-Request-Id: 15E37CD9D06980DF X-Xss-Protection: 1; mode=block } 解决方案：
1. 校验minio部署服务器的时间与程序运维主机时间是否相差太大，尽量保持一致
2. 若Minio服务器使用nginx进行代理，请检查nginx 是否按照如下标准的格式进行配置
server { listen 80; server_name example.com; // 主机名 location / { proxy_set_header Host $http_host; proxy_pass http://localhost:9000; // 你的Minio服务器地址 } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa581ce0a3140c26751c00bb3763b25f/" rel="bookmark">
			Vue Cli3 项目打包优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.项目优化 实现步骤：
清除生产环境中的console.log语句生成打包报告，根据报告优化项目第三方库启用CDN路由懒加载首页内容定制 2.执行build 2.1 清除生产环境中的console.log语句 安装一个插件（babel-plugin-transform-remove-console）在项目build阶段移除所有的console信息
2.1.1 安装开发依赖babel-plugin-transform-remove-console
npm i babel-plugin-transform-remove-console -D 2.2.2 打开babel.config.js，编辑代码如下：
// 项目发布阶段需要用到的babel插件 const productPlugins = [] // 判断是开发还是发布阶段 if (process.env.NODE_ENV === 'production') { // 发布阶段 productPlugins.push('transform-remove-console') } module.exports = { presets: [ '@vue/cli-plugin-babel/preset', ['@babel/preset-env', { modules: false }] // 让babel转码不要将es6的模块化语法转化为common.js中的require ], plugins: [ ...productPlugins ] } 3. 生成打包报告 3.1 命令行形式生成打包报告 控制台执行命令：
vue-cli-service build --report 3.2 使用Vue-Cli3的图形界面查看打包报告 在cmd命令行运行命令： vue ui，可以开启Vue-cli3中提供的一个图形化页面的工具
在Vue项目管理器中，选择导入自己的项目文件夹
点击“任务”=&gt;“build”=&gt;“运行”。运行完毕之后点击右侧“分析”，“控制台”面板查看报告
4. 修改webpack的默认配置 默认情况下，vue-cli 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa581ce0a3140c26751c00bb3763b25f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c87c23e56dadfbca09885069540aacd3/" rel="bookmark">
			CSS颜色渐变样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用CSS渐变 CSS渐变类型的一种特殊类型 表示，由两种或多种颜色之间的渐进过渡组成。您可以选择三种类型的渐变：线性 (由 linear-gradient 函数创建)，径向(由 radial-gradient() 函数创建) 和圆锥 (由 conic-gradient (en-US) 函数创建)。您还可以使用 repeating-linear-gradient 和 repeating-radial-gradient 函数创建重复渐变。
渐变可以在任何使用 的地方使用，例如在背景中。 由于渐变是动态生成的，因此它们可以消除对传统用于实现类似效果的栅格图像文件的需求。 此外，由于渐变是由浏览器生成的，因此在放大时它们看起来比栅格图像更好，并且可以动态调整大小。
我们将从线性渐变开始介绍，然后以线性渐变为例介绍所有渐变类型支持的功能，然后继续介绍径向渐变，圆锥渐变和重复渐变。
使用线性渐变 线性渐变创建了一条沿直线前进的颜色带。
基础线性渐变 要创建最基本的渐变类型，您只需指定两种颜色即可。 这些被称为色标。 至少指定两个色标，也可以指定任意数量。
.simple-linear { background: linear-gradient(blue, pink); } 改变渐变方向 默认情况下，线性渐变的方向是从上到下， 你可以指定一个值来改变渐变的方向。
.horizontal-gradient { background: linear-gradient(to right, blue, pink); } 对角线渐变 你甚至可以设置渐变方向为从一个对角到另一个对角。
.diagonal-gradient { background: linear-gradient(to bottom right, blue, pink); } 设置渐变角度 如果你想要更精确地控制渐变的方向，你可以给渐变设置一个具体的角度。
.angled-gradient { background: linear-gradient(70deg, blue, pink); } 在使用角度的时候, 0deg 代表渐变方向为从下到上, 90deg 代表渐变方向为从左到右，诸如此类正角度都属于顺时针方向。 而负角度意味着逆时针方向。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c87c23e56dadfbca09885069540aacd3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/368/">«</a>
	<span class="pagination__item pagination__item--current">369/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/370/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>