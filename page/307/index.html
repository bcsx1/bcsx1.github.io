<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b013e0d9ce32911552cf510ef7ff9729/" rel="bookmark">
			torch来查看自己的gpu
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看gpu信息
import torch print(torch.cuda.is_available() )# cuda是否可用 print(torch.cuda.device_count() )# gpu数量 print(torch.cuda.current_device())# 当前设备索引, 从0开始 print(torch.cuda.get_device_name(0))# 返回gpu名字 使用GPU
device = torch.cuda.current_device() if args.cuda else torch.device('cpu') device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu") os.environ['CUDA_VISIBLE_DEVICES']='0' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/585a646dc21b23a53d671969b33f4222/" rel="bookmark">
			从网瘾少年到网管，再到程序员，看他的逆袭路，哭了……
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 都说郎怕入错行，行业对职场人的影响不言而喻。刚毕业的薪资可能跟学历有关，但有的行业天花板很低，直接就决定了你的薪资上限，再努力都很难突破。而IT互联网行业的薪资天花板就高的多。究竟能拿多少，完全看个人了。
从网瘾少年到月薪3k的网管，再到月薪9k的程序员，他经历了什么？今天给大家分享一则网瘾少年的逆袭故事：
吃不了读书的苦就得吃生活的苦 我从小到大，不爱学习，就爱玩游戏，整个人都沉迷在网络世界里面，见识很短。我高中的时候，每次考试都是倒数第一，写卷子只写选择题。
17年高中毕业在村子里暑假又玩了两个月，后面想了想考上的专科也不去读了。一个人17周岁做火车来上海这边打工，我第一份工作当网管，包吃住3000。我当时觉得真好，后面干了一个月，因为网吧有老虎机那种涉嫌赌博的机子，整个网吧被查封掉了。
第二份工作在汉堡店后厨包汉堡炸鸡腿，包住一个月4000块，我觉得也还行。在汉堡店工作期间，结识了很多来我们店拿外卖的美团、饿了么骑手，我就发现买个电瓶车送外卖，工作时间自由，工资还不少，我就辞职去做美团外卖骑手。
2018年2月正式成为一名骑手，这一送就是两年。但是随着时间的推移，好像很多人都觉得送外卖这工作可以，都争着来当外卖员，然后员工一多，公司制度越来越苛刻，工资也越来越少，后面浦东交警针对外卖员、电瓶车查的也越来越严，我就在想，我这两年是不是过的太舒服了，别人都在上大学，努力学知识，我每天就打酱油送个外卖，一个月挣五六千混混日子，没有什么一技之长，难道就这样一辈子送外卖么？两年间，我很多外卖团队的大哥，还有我父母，都跟我说趁年轻去学个技术，年纪轻轻的送什么外卖，但是我不知道学啥，我没有方向。
人生的转机 我人生的转机是在2020年冬天那会儿，我很多高中的朋友，专科毕业都找工作开始上班了，不少人的工作就是跟电脑有关的，我也是那会儿才知道，程序员有前端、Java、软件测试、大数据、运维很多种类。我想这工作真好啊，做电脑前面敲一敲键盘，就把钱挣了。送外卖风里来雨里去，这不比当骑手好多了，我也想当程序员。
我咨询了一位高中的朋友，现在在腾讯做开发，他建议我学Python，门槛低，易学。说来命运真是神奇，高中的上下铺，曾经一起吃饭、一起打球的哥们儿，人生的际遇千差万别。他在高中时学习就非常努力，考入了一所985大学，而我考上了专科还没去读。
然后我就去网上看资料，看看Python怎么学，有哪些方向，我就发现数据分析对学历要求低，入门简单，就是工资也还行，我就觉得这数据分析很适合我。
到网上找了很多Python的零基础学习课程还有书籍，有朋友给我做指导感觉学习的内容不是很难，但我尤为重视。因为万丈高楼平地起，打好基础是前提。好在我的沟通能力还算可以，脸皮也比较厚。哪里不会我会记录下来，在朋友有空的时候问他。加了很多Python的技术交流群，群成员也会热心的帮忙解答。
后面学习了五个月的时间，我仿佛吸收了比上学以来加起来还要多的知识。先到网上找了一些兼职练手，发现自己都能顺利完成了，然后在外面开始找正式的工作。
一周时间，面了六家，拿了三个offer，一个5000的爬虫，两个8000，9000的数据分析，跟我其他做编程的同学比起来，这个工资不高，但跟我自己比起来，这份工作比之前送外卖好很多，但是我不觉得我比别人差。
以前我只会玩游戏，很自卑，啥也不会，还让父母操心，现在每年我都能给父母三万块钱，让他们不再那么辛苦。
纵有疾风起，人生不言弃。
关于Python技术储备 学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
一、Python所有方向的学习路线 Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、学习软件 工欲善其事必先利其器。学习Python常用的开发软件都在这里了，给大家节省了很多时间。
三、全套PDF电子书 书籍的好处就在于权威和体系健全，刚开始学习的时候你可以只看视频或者听某个人讲课，但等你学完之后，你觉得你掌握了，这时候建议还是得去看一下书籍，看权威技术书籍也是每个程序员必经之路。
四、入门学习视频 我们在看视频学习的时候，不能光动眼动脑不动手，比较科学的学习方法是在理解之后运用它们，这时候练手项目就很适合了。
四、实战案例 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
五、面试资料 我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
这份完整版的Python全套学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08cdaff568b9e7d2febbf38c59814e14/" rel="bookmark">
			第三章 ARM汇编语言程序设计——ARM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.ARM汇编的语句格式 汇编语言都具有一些相同的基本特征。
一条指令一行。
使用标号（label）给内存单元提供名称，从第1列开始书写。
指令必须从第2列或能区分标号的地方开始书写。
注释跟在指定的注释字符后面（ARM使用的是“;”），一直书写到行尾。
ARM汇编语言基本的的语句格式如下：
{symbol} {instruction |directive | pseudo-instruction} {;comment} 符号 指令、伪指令或伪操作	[; 注释] (1)符号命名规则： 符号由大小写字母、数字及下画线组成，符号不能用数字开头。符号区分大小写，同名的大、小写符号会被编译器认为是两个不同的符号。符号在其作用范围内必须唯一。自定义的符号名不能与系统的保留字相同。符号名不应与指令或伪指令同名。 (2)伪操作 伪操作（Directive）是ARM汇编语言程序里的一些特殊的指令助记符，其作用主要是为完成汇编程序做各种准备工作，对源程序运行汇编程序处理，而不是在计算机运行期间由处理器执行。
常用伪操作列表：
操作符 语法格式 功能描述 ARM ARM 指示编译器处理的是32位ARM指令 CODE32	CODE32	指示编译器处理的是32位ARM指令 THUMB	THUMB 指示编译器处理的是16位THUMB指令 CODE16	CODE16	指示编译器处理的是16位THUMB指令 AREA	AREA name{attr} {attr}	段属性定义 ENTRY	ENTRY	声明程序的入口 END	END	源程序结尾标识 EQU	name EQU expr{，type}	定义常量或标号名称 EXPORT	EXPORT name	声明全局标号 IMPORT	IMPORT name 外部符号声明 介绍：
ENTRY 和 END
定义程序入口点伪指令 ENTRY用于指定汇编程序的入口点汇编结束伪指令 END 用于通知编译器汇编工作到此结束，不再往下汇编了 EXPORT(或GLOBAL)和 IMPORT(或EXTERN)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08cdaff568b9e7d2febbf38c59814e14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57f134cf257cebfc447074e58b129f1f/" rel="bookmark">
			【KEIL】 __FPU_PRESENT出现重定义的警告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HAL库更新了版本，升级了最新HAL库后出现__FPU_PRESENT重定义警告。
.warning: '__FPU_PRESENT' macro redefined [-Wmacro-redefined]
在.h文件提示已被定义
在工程配置中添加有此定义，但是以前都可以正常使用。
经过对比发现stm32h743xx.h中以前是
#define __FPU_PRESENT 1
库升级后
#define __FPU_PRESENT 1U
最终确定是这个U导致的，在工程配种中改成__FPU_PRESENT=1U或者删除即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cbc5601a7491736055d28b287c074ca/" rel="bookmark">
			dockerfile 部署在线推理tensorflow-serving&#43;tornado&#43;python3.5深度学习模型服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#安装unbuntu FROM ubuntu:18.04 #安装python3.5 RUN sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list &amp;&amp; apt-get clean # ADD sources.list /etc/apt/ 这个sources.list换源还有问题，待改进 RUN apt-get update -y &amp;&amp; \ apt-get install -y zbar-tools libzbar-dev python-zbar RUN dpkg -L libzbar-dev; ls -l /usr/include/zbar.h RUN apt-get update -y RUN apt-get install -y python3.5 RUN rm /usr/bin/python RUN ln -s /usr/bin/python3.5 /usr/bin/python RUN apt-get install -y python3-pip #复制gitlab 的requirement.txt 的进行安装python需要的包 tornado ,requets,numpy COPY requirements.txt . #这个自己定义requirements.txt 里面需要安装的包 RUN pip3 install -U -i https://pypi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cbc5601a7491736055d28b287c074ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43901358846c945373f7d9d9a610964a/" rel="bookmark">
			Blender 插件开发 将object设置成bpy.context.object
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 公司开始使用blender后一直忙着写插件，最近准备把一些有用的东西写成博客记录一下吧
在使用一些bpy.ops.object下的函数时由于无法传参数，基本默认都是调用bpy.context.object或者是选中的模型，所以记录一下怎么将object设置成bpy.context.object
# 将所有选中的模型变成False bpy.ops.object.select_all(action='DESELECT') # 有Cube模型获取Cube if 'Cube' in bpy.data.objects: ob = bpy.data.objects['Cube'] # 将Cube变成选中状态 ob.select_set(True) # 将Cube设置成bpy.context.object bpy.context.view_layer.objects.active = ob print(bpy.context.object.name) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d73d50fcb4de6d32213c3292cc46838e/" rel="bookmark">
			报错：Uncaught SyntaxError: Cannot use import statement outside a module
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 语法错误 ： 无法在模块外部使用导入语句
在js中使用模块化的导入导出功能，必须要声明 js是模块化的。
举个简单的例子：
// a.js const tools = {label:'商品' } export defalut tools; // b.js import tools from './a.js' //1.html &lt;script src="./a.js"&gt;&lt;/script&gt; //直接这样写的话会报上面的错，原因就是引入的a.js使用了import 的语法 // 解决：加一个模块化的属性即可 &lt;script type="module" src="./a.js"&gt;&lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a61a13bf7008fcfacb0a62bb2f5883bc/" rel="bookmark">
			设计模式之游戏--观察者模式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入问题 在我们的游戏开发中，我们常常会遇见这种场景，比如在战斗系统中如果敌人死亡，我们要通知UI系统，成就系统，关卡系统等一些其它系统做出相应的行为。你可能做出如下设计
方法1：让战斗系统亦或者敌人持有其它系统的的引用，然后在敌人死亡时调用其它系统的相应方法。
方法2：让各系统时时监听敌人的相应状态，敌人死亡时调用系统的相应方法
这两种方法看起来没多大毛病，但仔细分析我们就就会发现其实是有所欠缺的。
方法1：当我们后期需求变更，增加了一个新的系统或者一个新的功能，那么我们就需要修改战斗系统或者敌人的代码，使之符合我们的要求，但这显然不符合我们的开闭原则。
方法2：时时监听，在我们的Unity具体来说就是Update(),FixedUpdate()等函数，在这些函数写入过多的诸如此类的判断，很可能会引发性能瓶颈，常见的就是卡顿，掉帧。
为了解决上述诸如此类的问题，我们引入的观察者模式。
定义 它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。当这个主题对象在状态变化时，会通知所有的观察者对象并使它们能够自动更新。所以说这种模式有时又称作发布-订阅模式。
UML Subject：抽象主题（抽象被观察者），抽象主题对象把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供相应接口，可以增加和删除观察者对象。
ConcreteSubject：具体主题（具体被观察者），它实现抽象目标中的通知方法，在具体主题的对应状态发生改变时，给所有注册过的观察者发送通知。
Observer：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。
ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。
具体示例： 下面我们以游戏中的敌人死亡后，通知各个系统做出相应响应为例， 实现观察者模式。
using System.Collections; using System.Collections.Generic; using UnityEngine; public abstract class GameEventSubjects { protected List&lt;GameEventObserver&gt; observers = new List&lt;GameEventObserver&gt;(); public virtual void AddOBS(GameEventObserver observer) { observers.Add(observer); } public virtual void RemoveOBS(GameEventObserver observer) { observers.Add(observer); } public abstract void Notify(); } public class EnemyDeathSubject : GameEventSubjects { public override void Notify() { foreach (var item in observers) { item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a61a13bf7008fcfacb0a62bb2f5883bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/405435b2691b6ae04727a8dbae402a6f/" rel="bookmark">
			电商搜索文本匹配使用BM25算法召回&#43;其他匹配特征
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文的主要想做的事情就是尽可能的理解文本匹配下面这段话：
1.首先进行数据的前处理去除特殊符号可以下载stop_words.txt中文的特殊符号得到mat.xlsx import pandas as pd data=pd.read_excel('mat.xlsx') #mat.xlsx 为物料数据 这里不方便放出来 数据可以自己去淘宝 京东爬取 dd=set(data['product_title'].tolist()) # 获取商品名称 2.bm25算法模型结构 这里面需要注意一下 参数的设置调整，我这边也是调试了一下场景是短文本，还可以继续调整
import math from six import iteritems from six.moves import xrange # BM25 parameters. PARAM_K1 = 10 PARAM_B = 0.9 EPSILON = 0.25 class BM25(object): def __init__(self, corpus): self.corpus_size = len(corpus) self.avgdl = sum(map(lambda x: float(len(x)), corpus)) / self.corpus_size self.corpus = corpus self.f = [] self.df = {} self.idf = {} self.initialize() def initialize(self): for document in self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/405435b2691b6ae04727a8dbae402a6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57df369583ad09f4112b45ffb85ad10b/" rel="bookmark">
			AutoFac多个实现类中获取指定实现类的三个方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个业务接口有多个实现类的情况是很多的，
如果我们都讲他们配置进容器，那么当要找到特定的实现类就会有些麻烦了
这里总结几种方法去获取指定的实现类
1.把所有实现类作为IEumnable集合都注入进来 public interface IService { void DoSomething(); } public class HumanService : IService { public void DoSomething() { Console.WriteLine("Human dosomething"); } } public class AnimalService: IService { public void DoSomething() { Console.WriteLine("Animal dosomething"); } } public class Sample { //用一个集合类型把所有的实现类都注入进来 public IEnumerable&lt;IService&gt; Services { get; set; } public Sample(IEnumerable&lt;IService&gt; services) { Services = services; } public void HumanServiceMethod() { foreach (var service in Services) { //需要去手动的判断需要用到的实现类 if(service is HumanService) { service.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57df369583ad09f4112b45ffb85ad10b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75aae8115a85db7609310009efeff4d2/" rel="bookmark">
			Redis知识点(未完待续)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. Redis的介绍 1.1 引言 由于用户量增大, 请求数量也增大, 数据库压力过大多台服务器之间, 数据不同步多台服务器之间的锁, 已经不存在互斥性了 1.2 NoSql Redis就是一款NoSql
NoSql -&gt; 非关系型数据库 -&gt; Not Only Sql
Key - Value : Redis…文档型 : ElasticSearch, Solr, Mongodb…面向列 : Hbase, Cassandra…图像化 : Neo4j… 除了关系型数据库都是非关系型数据库
NoSql只是一个概念, 泛指非关系型数据库, 目的是为了和关系型数据库做一个区分
1.3 Redis介绍 有一位意大利人, Salvatore, 在开发一款LLOOGG的统计页面时, 因为MySQL的性能不好, 自己研发了一款非关系型数据库, 命名为Redis.
Redis ( Remote Dictionary Server ) 即远程字典服务
Redis由c语言编写, 是基于Key - Value的NoSqlRedis基于内存存储数据, 还提供了多种持久化机制, 性能可以达到110000次/s读取数据以及81000次/s写入数据Redis提供了主从, 哨兵以及集群的搭建方式, 可以更加方便的进行横向扩展和垂直扩展 二. Redis的安装 2.1 安装Redis docker-compose.yml
version: '3.1' services: redis: image: daocloud.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75aae8115a85db7609310009efeff4d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a534ac0af401cd9c4df0105f4d6d8e1/" rel="bookmark">
			两种最小生成树的方法——普里姆算法、克鲁斯卡尔算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、最小生成树的概念
二、MST性质
1、性质
2、 证明
二、普里姆(Prim)算法
1、算法思想
2、图形解析
3、逐步实现
（1）建立无向图的邻接矩阵
（2）找出辅助数组中与closedge代价最小的顶点的位置
（3）普里姆核心算法
4、总代码
5、时间复杂度
三、克鲁斯卡尔(Kruskal)算法
1、算法思想
2、图形解析
3、逐步实现
（1）构建无向图的邻接表
（2）找到可连接的边
（3）判断最小生成树是否完成
（4）克鲁斯卡尔核心算法
4、总代码
5、时间复杂度
一、最小生成树的概念 在连通网的所有生成树中，所有边的代价和最小的生成树。
二、MST性质 构建最小生成树的算法有多种，比如普里姆算法、克鲁斯卡尔算法。其中多数算法利用了最小生成树的下列一种简称MST的性质。 1、性质 假设N=( V , { E } )是一个连通网，U是顶点集V的一个非空子集。若（u，v）是一条具有最小权值的边，其中u∈U，v∈V-U，则必存在一颗包含边（u，v）的最小生成树。
图1 连通图N 2、 证明 利用反证法证明。
假设网N的任意一颗最小生成树都不包含（u，v）。
设T是连通网上的一颗最小生成树。
当将边（u，v）加入到T中时，由生成树的定义，T中必存在一条包含（u，v）的回路。另一方面，由于T是生成树，则在T上必存在另一条边（u’，v’），其中u’∈U，v’∈V-U，且u和u’之间，v和v’之间均有路径相通。删去边（u’，v’），便可消除上述回路，同时得到另一颗生成树T’。因为（u，v）的代价不高于（u’，v’），则T’的代价也不高于T，T’是包含（u，v）的一颗最小生成树。
由此与假设矛盾，性质正确。
图2 假设的最小生成树T 图3 实际的最小生成树T ’
二、普里姆(Prim)算法 1、算法思想 (1)设G=(V，E)是连通图，TE是N上最小生成树中边的集合。
(2)初始令U={u0}，(u0∈V)，TE={ }。
(3)在所有u∈U，v∈V-U的边（u，v）∈E中，找一条代价最小的边（u0，v0）。
(4)将（u0，v0）并入集合TE，同时v0并入U。
(5)重复上述操作直至U=V为止，则T=（V，TE）为N的最小生成树。
2、图形解析 图4 普里姆算法的图解 3、逐步实现 （1）建立无向图的邻接矩阵 int CreateGraph(MGraph&amp; G) { //创建无向网的邻接矩阵 int v1,v2,w; //邻接两点v1，v2,以及所构成边的权值w printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a534ac0af401cd9c4df0105f4d6d8e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff63d33d097bd7c764346a056aa7011a/" rel="bookmark">
			【正点原子FPGA连载】 第二十三章 EEPROM读写测试实验-摘自【正点原子】领航者ZYNQ之FPGA开发指南_V2.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）实验平台：正点原子领航者ZYNQ开发板
2）平台购买地址：https://item.taobao.com/item.htm?&amp;id=606160108761
3）全套实验源码+手册+视频下载地址：http://www.openedv.com/thread-301505-1-1.html
4）对正点原子FPGA感兴趣的同学可以加群讨论：994244016
5）关注正点原子公众号，获取最新资料更新
第二十三章 EEPROM读写测试实验 EEPROM是一种用于计算机系统的非易失性存储器，也常在嵌入式领域中作为数据的存储设备，在物联网及可穿戴设备等需要存储少量数据的场景中也有广泛应用。本章我们学习EEPROM的读写操作并进行EEPROM读写实验。
本章包括以下几个部分：
23.1 EEPROM简介
23.2 实验任务
23.3 硬件设计
23.4 程序设计
23.5 下载验证
23.1 EEPROM简介
EEPROM (Electrically Erasable Progammable Read Only Memory，E2PROM)即电可擦除可编程只读存储器，是一种常用的非易失性存储器（掉电数据不丢失），EEPROM有多种类型的产品，我们领航者ZYNQ开发板上使用的是ATMEL公司生产的AT24C系列的AT24C64这一型号。AT24C64具有高可靠性，可对所存数据保存100年，并可多次擦写，擦写次数达一百万次。
一般而言，对于存储类型的芯片，我们比较关注其存储容量。我们这次实验所用的AT24C64存储容量为64Kbit，内部分成256页，每页32字节，共有8192个字节，且其读写操作都是以字节为基本单位。可以把AT24C64看作一本书，那么这本书有256页，每页有32行，每行有8个字，总共有256328=65536个字，对应着AT24C64的64*1024=65536个bit。
知道了AT24C64的存储容量，就知道了读写的空间大小。那么我们该如何对AT24C64进行读写操作呢？
由于AT24C64采用两线串行接口的双向数据传输协议——I2C协议实现读写操作，所以我们有必要了解一下I2C协议。
I2C即Inter-Integrated Circuit(集成电路总线），是由Philips半导体公司（现在的NXP半导体公司）在八十年代初设计出来的一种简单、双向、二线制总线标准。多用于主机和从机在数据量不大且传输距离短的场合下的主从通信。主机启动总线，并产生时钟用于传送数据，此时任何接收数据的器件均被认为是从机。
I2C总线由数据线SDA和时钟线SCL构成通信线路，既可用于发送数据，也可接收数据。在主控与被控IC之间可进行双向数据传送，数据的传输速率在标准模式下可达100kbit/s，在快速模式下可达400kbit/s，在高速模式下可达3.4Mbit/s，各种被控器件均并联在总线上，通过器件地址（SLAVE ADDR，具体可查器件手册）识别。我们领航者I2C总线物理拓扑结构如下图所示。
图 7.5.13.1 领航者I2C总线物理拓扑结构图
图中的I2C_SCL是串行时钟线，I2C_SDA是串行数据线，由于I2C器件一般采用开漏结构与总线相连，所以I2C_SCL和I2C_SDA均需接上拉电阻，也正因此，当总线空闲时，这两条线路都处于高电平状态，当连到总线上的任一器件输出低电平，都将使总线拉低，即各器件的SDA及SCL都是“线与”关系。
I2C总线支持多主和主从两种工作方式，通常工作在主从工作方式，我们的开发板就采用主从工作方式。在主从工作方式中，系统中只有一个主机，其它器件都是具有I2C总线的外围从机。在主从工作方式中，主机启动数据的发送（发出启动信号）并产生时钟信号，数据发送完成后，发出停止信号。
I2C总线结构虽然简单，使用两线传输，然而要实现器件间的通信，需要通过控制SCL和SDA的时序，使其满足I2C的总线传输协议，方可实现器件间的数据传输。那么I2C协议的时序是怎样的呢？
在I2C器件开始通信（传输数据）之前，串行时钟线SCL和串行数据线SDA线由于上拉的原因处于高电平状态，此时I2C总线处于空闲状态。如果主机（此处指FPGA）想开始传输数据，只需在SCL为高电平时将SDA线拉低，产生一个起始信号，从机检测到起始信号后，准备接收数据，当数据传输完成，主机只需产生一个停止信号，告诉从机数据传输结束，停止信号的产生是在SCL为高电平时，SDA从低电平跳变到高电平，从机检测到停止信号后，停止接收数据。I2C整体时序如下图。起始信号之前为空闲状态，起始信号之后到停止信号之前的这一段为数据传输状态，主机可以向从机写数据，也可以读取从机输出的数据，数据的传输由双向数据线（SDA）完成。停止信号产生后，总线再次处于空闲状态。
图 7.5.13.2 I2C整体时序图
了解到了整体时序之后，我们可能有疑问，数据是以什么样的格式传输的呢？满足怎样的时序要求呢？是在任何时候改变都可以吗？怎么知道从机有没有接收到数据呢？带着这些疑问，我们继续学习I2C。
由于只有一根数据线进行数据的传输，如果不规定好传输规则肯定会导致信息错乱，如同在单条道路上驾驶，没有交通规则，再好的道路也会发生拥堵甚至更糟。采用两线结构的I2C虽然只有一根数据线，但由于还有一条时钟线，可以让数据线在时钟线的带领下有顺序的传送，就好像单条道路上的车辆在交警或信号指示灯的指示下有规则的通行。那么I2C遵循怎样的规则呢？
图 7.5.13.3 I2C具体时序图
如果要想回答这些问题，我们得读懂图 7.5.13.3。由图 7.5.13.3可知，我们在起始信号之后，主机开始发送传输的数据；在串行时钟线SCL为低电平状态时，SDA允许改变传输的数据位（1为高电平，0为低电平），在SCL为高电平状态时，SDA要求保持稳定，相当于一个时钟周期传输1bit数据，经过8个时钟周期后，传输了8bit数据，即一个字节。第8个时钟周期末，主机释放SDA以使从机应答，在第9个时钟周期，从机将SDA拉低以应答；如果第9个时钟周期，SCL为高电平时，SDA未被检测到为低电平，视为非应答，表明此次数据传输失败。第9个时钟周期末，从机释放SDA以使主机继续传输数据，如果主机发送停止信号，此次传输结束。我们要注意的是数据以8bit即一个字节为单位串行发出，其最先发送的是字节的最高位。
I2C的时序部分已经基本介绍完了，但还有一个小问题，就是当多个I2C器件挂接在总线上时，怎样才能与我们想要传输数据的器件进行通信。这就涉及到了器件地址（也称从机地址，SLAVE ADDRESS）。
每个I2C器件都有一个器件地址，有些I2C器件的器件地址是固定的，而有些I2C器件的器件地址由一个固定部分和一个可编程的部分构成，这是因为很可能在一个系统中有几个同样的器件，器件地址的可编程部分能最大数量的使这些器件连接到I2C总线上，例如EEPROM器件，为了增加系统的EEPROM容量，可能需要多个EEPROM。器件可编程地址位的数量由它可使用的管脚决定，比如EEPROM器件一般会留下3个管脚用于可编程地址位。但有些I2C器件在出厂时器件地址就设置好了，用户不可以更改（如实时时钟PCF8563的器件地址为固定的7’h51）。所以当主机想给某个器件发送数据时，只需向总线上发送接收器件的器件地址即可。
对于AT24C64而言，其器件地址为1010加3位的可编程地址，3位可编程地址由器件上的3个管脚A2、A1、A0（见图 7.5.13.2）的硬件连接决定。当硬件电路上分别将这三个管脚连接到GND或VCC时，就可以设置不同的可编程地址。对于我们的开发板，这3个管脚连接到地。
进行数据传输时，主机首先向总线上发出开始信号，对应开始位S，然后按照从高到低的位序发送器件地址，一般为7bit，第8bit位为读写控制位R/W，该位为0时表示主机对从机进行写操作，当该位为1时表示主机对从机进行读操作，然后接收从机响应。对于AT24C64来说，其传输器件地址格式如下图所示。
图 7.5.13.4 器件地址格式示意图
发送完第一个字节（7位器件地址和一位读写控制位）并收到从机正确的应答后就开始发送字地址（Word Address）。一般而言，每个兼容I2C协议的器件，内部总会有可供读写的寄存器或存储器，对于我们本次实验用到的EEPROM存储器，内部就是一系列顺序编址的存储单元。所以，当我们对一个器件中的存储单元（包括寄存器）进行读写时，首先要指定存储单元的地址即字地址，然后再向该地址写入内容。该地址为一个或两个字节长度，具体长度由器件内部的存储单元的数量决定，当存储单元数量不超过一个字节所能表示的最大数量（2^8=256）时，用一个字节表示，超过一个字节所能表示的最大数量时，就需要用两个字节来表示，例如同是 EEPROM存储器，AT24C02的存储单元容量为2Kbit=256Byte（一般bit缩写为b，Byte缩写为B），用一个字节地址即可寻址所有的存储单元，而AT24C64的存储单元容量为64Kb=8KB，需要13位（2^13=8KB）的地址位，而I2C又是以字节为单位进行传输的，所以需要用两个字节地址来寻址整个存储单元。图 7.5.13.5 和图 7.5.13.6分别为单字节字地址和双字节字地址器件的地址分布图，其中单字节字地址的器件是以存储容量为2Kb的EEPROM存储器AT24C02为例，双字节字地址的器件是以存储容量为64Kb的EEPROM存储器AT24C64为例，WA7即字地址Word Address的第7位，以此类推，用WA是为了区别前面器件地址中的A。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff63d33d097bd7c764346a056aa7011a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ada96f0b212bc7de323da526445bebc/" rel="bookmark">
			Browserslist: caniuse-lite is outdated. Please run: npx browserslist@latest --update-db
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 主要是说Browserslist太老旧了，需要更新了…
操作步骤：
1、删除 package-lock.json 2、删除 node_modules 3、重新安装 yarn install 4、执行命令行 npx browserslist@latest –update-db 问题二、Unknown browser query –update-db. Maybe you are using old Browserslist or made typo in query.
1、关闭再次：npx browserslist@latest –update-db 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dab348d33d8a81f35a549cc08effd692/" rel="bookmark">
			【KAWAKO】speechmetrics-语音方面评价指标库的安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
简介
安装
将工程以压缩包形式下载到本地
把压缩包传到服务器（你想部署的地方）上进行解压
用编辑器打开setup.py进行修改
在工程目录下进行安装
测试
简介 speechmetrics库提供了对语音质量进行评估的各种指标，包括MOSNet、BSSEval、STOI、PESQ、SRMR、SISDR等，方便我们对模型进行快速评估。
github链接在这里。
安装 由于【pip install git+http://......】会出现一些问题，再加上国内的种♂种♂原♂因，用speechmetrics官方提供的安装方式无法成功安装。
亲测有效的安装方式如下：
将工程以压缩包形式下载到本地 如果下载速度慢的话可以考虑使用魔♂法。
把压缩包传到服务器（你想部署的地方）上进行解压 用编辑器打开setup.py进行修改 将21~24行的https改为git
在工程目录下进行安装 进入工程目录，直接使用如下命令进行安装
pip install ./ 安装过程中会下载一大堆依赖库，首次下载会花费相对较长的时间，耐心等待即可（或者使用魔♂法）。
测试 测试代码如下
import speechmetrics #定义窗长，每多少秒评价一次，None则对完整音频进行评价 window_length = None # seconds #加载metric，在这里定义需要评价的指标 metrics = speechmetrics.load(['pesq', 'stoi', 'sisdr'], window_length) #对音频进行评价 score = metrics("./DCCRN-C.wav", "./0-clean.wav") #params: denoised.wav, clean.wav print(score) ''' {'nb_pesq': 2.7491965293884277, 'pesq': 1.773357629776001, 'sisdr': 8.636653915700691, 'stoi': 0.9070218637754633} ''' 用DCCRN官方公布的测试音频（simulated WSJ0 and MUSAN data中0db音频的DCCRN-C效果）进行测试，可以看到窄带PESQ的值跟DCCRN论文中的值还是比较接近的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/360f6d4cef67afc636bdcf8098f771b9/" rel="bookmark">
			vue使用Echarts渲染图表 请求的后台数据返回{ob: Observer}
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将后台请求回来的数据和图表结合的时候，发现图表并没有被渲染出来，但是写死数据就可以，网上搜说是因为{ob: Observer}是只读属性，后面的__ob__: Observer以后,我们会获取不到该数组里面的值,它是不可枚举的,这时候我们需要用JSON.parse(JSON.stringify(该数组))重新生成一个可枚举数组.{ob: Observer} 这种格式的是 Vue 对数据监控添加的属性。
但试了半天根本没用，之前我是在created请求数据，图表的渲染在mounted中，以为这个先后顺序可以成立，没成想created请求数据没那么快，导致渲染的时候加载不上去，解决方法其实很简单：因为异步的原因统计图在渲染的时候后台还没有请求到数据，图表的渲染不要放在生命周期moutend中，而是在后台数据请求完成之后再渲染，怎么样，就一句话不需要做任何改动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89ea2c15a4574e61a629b2c2ec4bb2be/" rel="bookmark">
			Spring Boot 集成 Druid 批量插入数据和效率监控配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近新的项目写了不少各种 insertBatch 的代码，例如excle导入，批量导入的方式很多，如何选择困扰着大家。下面为大家分析常见的批量插入方法和效率。本文只设计单线程，多线程甚至生产者消费者模式后续补充。
测试环境：
SpringBoot 2.5Mysql 8JDK 8Druid 搭建测试环境 Druid是Java语言中最好的数据库连接池，并且能够提供强大的监控和扩展功能。
业界把 Druid 和 HikariCP 做对比后，虽说 HikariCP 的性能比 Druid 高，但是因为 Druid 包括很多维度的统计和分析功能，所以这也是大家都选择使用它的原因。
下面来说明如何在 spring Boot 中配置使用Druid
1、添加Maven依赖 (或jar包)
&lt;dependency&gt;
&lt;groupId&gt;com.alibaba&lt;/groupId&gt;
&lt;artifactId&gt;druid&lt;/artifactId&gt;
&lt;version&gt;1.0.15&lt;/version&gt;
&lt;/dependency&gt;
2、配置数据源相关信息
#datasource
spring.datasource.url=jdbc:mysql://192.168.10.20:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;rewriteBatchedStatements=true
spring.datasource.username = root
spring.datasource.password = password
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
#pool Initialization spring.datasource.initialSize=5 spring.datasource.minIdle=5 spring.datasource.maxActive=20 #overtime
spring.datasource.maxWait=60000 spring.datasource.timeBetweenEvictionRunsMillis=60000 spring.datasource.minEvictableIdleTimeMillis=300000 spring.datasource.validationQuery=SELECT 1 FROM DUAL spring.datasource.testWhileIdle=true spring.datasource.testOnBorrow=false spring.datasource.testOnReturn=false spring.datasource.poolPreparedStatements=true spring.datasource.maxPoolPreparedStatementPerConnectionSize=20 spring.datasource.filters=stat,wall,log4j spring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000
#spring.datasource.useGlobalDataSourceStat=tru
#server
server.port=8081
sql 文件：
drop database IF EXISTS test; CREATE DATABASE test; use test; DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` int(11) NOT NULL, `name` varchar(255) DEFAULT "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89ea2c15a4574e61a629b2c2ec4bb2be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9da23d13df026a3c07d6a0b250a3608/" rel="bookmark">
			Java尚硅谷project03总结学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近忙了点别的事情，学习进度收到一点点耽误，终于在昨天把project03给完结了，下面对project03进行复盘学习一下。project03整体还是采用MVC的设计模式，每个包的功能明显。
M: 这里面主要是涉及到一个父类和一个接口的问题，一个Employee类和一个Equipment接口。
其中由于接口中不能有构造器，不能对接口实例化，大多数还是在接口中写抽象方法，进而再实现接口。Equipment接口代码如下：
package project03.team.domain; public interface Equipment { public abstract String getDescription(); } 实现接口的代码有PC、NoteBook和Printer类，下面是三个实现类的代码。
PC类：有两个属性，一个是机器型号，另一个是显示器名称，另外是构造器和get/set方法
package project03.team.domain; public class PC implements Equipment { private String model;// 机器型号 private String display;// 显示器名称 // 接口实现 public String getDescription() { return model+"("+display+")"; } // 构造器 public PC() { super(); } public PC(String model, String display) { super(); this.model = model; this.display = display; } // get/set方法 public String getModel() { return model; } public void setModel(String model) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9da23d13df026a3c07d6a0b250a3608/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8a7fcf2eec5ff4e089a9a19511cde52/" rel="bookmark">
			EasyExcel实现excel操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EasyExcel实现excel操作
在SpringBoot中集成EasyExcel非常简单，仅需一个依赖即可。
com.alibaba easyexcel 3.0.5 使用 EasyExcel和EasyPoi的使用非常类似，都是通过注解来控制导入导出。接下来我们以会员信息和订单信息的导入导出为例，分别实现下简单的单表导出和具有一对多关系的复杂导出。 简单导出
我们以会员信息的导出为例，来体验下EasyExcel的导出功能。
首先创建一个会员对象Member，封装会员信息，这里使用了EasyExcel的注解；
/**
购物会员Created by macro on 2021/10/12.
*/
@Data
@EqualsAndHashCode(callSuper = false)
public class Member {
@ExcelProperty(“ID”)
@ColumnWidth(10)
private Long id;
@ExcelProperty(“用户名”)
@ColumnWidth(20)
private String username;
@ExcelIgnore
private String password;
@ExcelProperty(“昵称”)
@ColumnWidth(20)
private String nickname;
@ExcelProperty(“出生日期”)
@ColumnWidth(20)
@DateTimeFormat(“yyyy-MM-dd”)
private Date birthday;
@ExcelProperty(“手机号”)
@ColumnWidth(20)
private String phone;
@ExcelIgnore
private String icon;
@ExcelProperty(value = “性别”, converter = GenderConverter.class)
@ColumnWidth(10)
private Integer gender;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8a7fcf2eec5ff4e089a9a19511cde52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/269e17107d853de2c0bd24d1b26413b2/" rel="bookmark">
			C语言十进制转八进制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 输入
12
输出
14
#include&lt;stdio.h&gt; int main() { int n; scanf("%d", &amp;n); int i = 0; int a[100]; int count; while (1) { a[i] = n % 8; n = n / 8; if (n == 0) { break; } i++; } int j; for (j = i; j &gt;= 0; j--) { printf("%d", a[j]); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78d25df5d9819815cb10fa6c0ceafe9e/" rel="bookmark">
			leetcode445 剑指 Offer II 025. 链表中的两数相加 python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述：
题解：栈
1.用stack1保存链表l1中节点，stack2保存链表l2中节点值。
2.创建一个初始为None的节点，表示进位数字的into，初始为0.
3.当stack1或stack2不为空或into不为0的时候执行加法：stack1栈顶元素值保存在a，stack2栈顶元素值保存在b，如果栈为空，则对应的值为0.
4.计算a+b+into的值，(a+b+into)%10为当前位的和，(a+b+into)//10为当前位向前一位的进位，更新into。
5.创建一个新节点newnode，val为(a+b+into)%10，next为curr，然后将curr更新为newnode。
class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: stack1 = [] stack2 = [] node1 = l1 node2 = l2 while node1: stack1.append(node1) node1 = node1.next while node2: stack2.append(node2) node2 = node2.next curr = None into = 0 while stack1 or stack2 or into!=0: a = 0 if len(stack1)==0 else stack1.pop().val b = 0 if len(stack2)==0 else stack2.pop().val result = (a+b+into)%10 into = (a+b+into)//10 newnode = ListNode(result,curr) curr = newnode return curr 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c1ae8b90a885a6379e1ba7cc609493c/" rel="bookmark">
			Flink Table 的三种 Sink 模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为计算引擎 Flink 应用的计算结果总要以某种方式输出，比如调试阶段的打印到控制台或者生产阶段的写到数据库。而对于本来就需要在 Flink 内存保存中间及最终计算结果的应用来说，比如进行聚合统计的应用，输出结果便是将内存中的结果同步到外部。
就 Flink Table/SQL API 而言，这里的同步会有三种模式，分别是 Append、Upsert 和 Retract。实际上这些输出计算结果的模式并不限于某个计算框架，比如 Storm、Spark 或者 Flink DataStream 都可以应用这些模式，不过 Flink Table/SQL 已有完整的概念和内置实现，更方便讨论。
基础原理 相信接触过 Streaming SQL 的同学都有了解或者听过流表二象性，简单来说流和表是同一事实的不同表现，是可以相互转换的。流和表的表述在业界不尽相同，笔者比较喜欢的一种是: 流体现事实在时间维度上的变化，而表则体现事实在某个时间点的视图。如果将流比作水管中流动的水，那么表将是杯子里静止的水。
将流转换为表的方法对于大多数读者都不陌生，只需将聚合统计函数应用到流上，流很自然就变为表（值得注意的是，Flink 的 Dynamic Table 和表的定义有细微不同，这将在下文讲述）。比如对于一个计算 PV 的简单流计算作业，将用户浏览日志数据流安 url 分类统计，变成 (url, views) 这样的一个表。然而对于如何将表转换成流，读者则未必有这么清晰的概念。
假设一个典型的实时流计算应用的工作流程可以被简化为下图:
其中很关键的一点是 Transformation 是否聚合类型的计算。若否，则输出结果依然是流，可以很自然地使用原本流处理的 Sink（与外部系统的连接器）；若是，则流会转换为表，那么输出的结果将是表，而一个表的输出通常是批处理的概念，不能直接简单地用流处理的 Sink 来表达。
这时有个很朴素的想法是，我们能不能避免批处理那种全量的输出，每次只输出表的 diff，也就是 changelog。这也是表转化为流的方法: 持续观察表的变化，并将每个变化记录成日志输出。因此，流和表的转换可以以下图表示:
其中表的变化具体可以分为 INSERT、UPDATE 和 DELETE 三类，而 Flink 根据这些变化类型分别总结了三种结果的输出模式。
模式 INSERTUPDATEDELETEAppend支持不支持不支持Upsert支持支持支持Retract 支持支持支持 通常来说 Append 是最容易实现但功能最弱的，Retract 是最难实现而功能最强的。下文分别谈谈三种模式的特点和应用场景。
Append 输出模式 Append 是最为简单的输出模式，只支持追加结果记录的操作。因为结果一旦输出以后便不会再有变更，Append 输出模式的最大特性是不可变性（immutability），而不可变性最令人向往的优势便是安全，比如线程安全或者 Event Sourcing 的可恢复性，不过同时也会给业务操作带来限制。通常来说，Append 模式会用于写入不方便做撤回或者删除操作的存储系统的场景，比如 Kafka 等 MQ 或者打印到控制台。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c1ae8b90a885a6379e1ba7cc609493c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/babfd461d4e26c9a69e41fb006b4345f/" rel="bookmark">
			springBoot学习笔记（2.2）—— 整合mybatis之递归子查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更多文章 更多系列文章在个人网站
springBoot学习系列笔记文章 springBoot学习笔记（1）—— 搭建springBoot项目
提示：
文章目录 更多文章springBoot学习系列笔记文章前言一、搭建步骤1.构建实体类和表结构2.Dao接口详情3. Mapper文件内容 （重点）4.service层方法5.controller层方法6.运行截图 二、使用递归算法构建树状数据1.mapper内容2.service层中算法 总结 前言 提示：前两篇文章研究了spring Boot整合mybaits，现在这篇文章研究mybatis中递归子查询的问题。至于编写application.yml配置文件此次不再赘述
一、搭建步骤 1.构建实体类和表结构 @Data public class Dept { /** * 主键id */ private Long id; /** * 部门名称 */ private String deptName; /** * 父类id */ private Long parentId; /** * 排序码 */ private String orderCode; /** * 是否开启使用(0否,1是) */ private Integer isStart; /** * 说明 */ private String description; /** * 地址 */ private String address; /** * 人员数据 */ private List&lt;User&gt; userList; } CREATE TABLE dept( id BIGINT (15) NOT NULL AUTO_INCREMENT COMMENT '主键id', dept_name VARCHAR (50) NOT NULL DEFAULT '' COMMENT '部门名称', parent_id VARCHAR (50) NOT NULL DEFAULT '' COMMENT '父类id', order_code VARCHAR (50) NOT NULL DEFAULT '' COMMENT '排序码', is_start INT (11) NOT NULL DEFAULT 0 COMMENT '是否开启使用(0否,1是)', description VARCHAR (50) NOT NULL DEFAULT '' COMMENT '说明', address VARCHAR (50) NOT NULL DEFAULT '' COMMENT '地址', PRIMARY KEY (id) )ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT 'dept'; 部门表根据id和parent_id 相互关联，表数据可以自己构建，此处不单独引入。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/babfd461d4e26c9a69e41fb006b4345f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dc5d8a7563125c8424a802e506b6923/" rel="bookmark">
			Spring学习笔记之Spring-02-DataSource-xml(用xml配置数据源)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 这是我学习黑马SSM教程P21-P27时记下的笔记，项目的地址在：https://github.com/RamboKingder/Spring_Learning
这一节其实没啥太新的东西，就是数据源对象需要用set方法去设置：driver、url、username、password参数 但是配置的方式分为很多种：
一、平时最常用的方法就是在代码里面new DataSource对象，然后把字符串传给datasource的setXXX()方法，例如： DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver"); dataSource.setUrl("jdbc:mysql://localhost:3306/test_db"); dataSource.setUsername("LongXiaolan"); dataSource.setPassword("rootpassword"); Connection conn = dataSource.getConnection(); System.out.println(conn); conn.close(); 上面看到，dataSource需要的参数直接用字符串给出的，后续维护代码需要来找这部分，很麻烦
而且在实际开发中，通常喜欢把数据库相关的参数放到一个properties文件中，把它单独配置，于是有了下面的方法：
二、通过properties文件保存和加载数据源需要的dirver, url, username, password等参数： // 路径在resources下，且不需要文件的扩展名 ResourceBundle rb = ResourceBundle.getBundle("jdbc"); String driver = rb.getString("jdbc.driver"); String url = rb.getString("jdbc.url"); String username = rb.getString("jdbc.username"); String password = rb.getString("jdbc.password"); ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(driver); dataSource.setJdbcUrl(url); dataSource.setUser(username); dataSource.setPassword(password); Connection conn = dataSource.getConnection(); System.out.println(conn); conn.close(); 这样的话，后续我们只需要去修改properties文件就行了，而不用去找对应的代码了
但是这样还是存在一个问题：我们违反了Spring的控制反转思想
这个数据源对象是我们在代码中new出来的，这个应该交给Spring容器去做才行
三、直接在xml中创建一个数据源的Bean，并在其中直接去配置它的参数 &lt;bean id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dc5d8a7563125c8424a802e506b6923/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35cedb722a832809749719cb6025cbb9/" rel="bookmark">
			推荐一个开源的任务管理工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天推荐一个开源的任务管理工具，该工具会提供各类文档协作功能、在线思维导图、在线流程图、项目管理、任务分发、即时 IM，文件管理等等。该开源项目使用到 Vue、Element-UI、ECharts 等技术栈。
开源地址：www.github.com/kuaifan/dootask
预览地址：www.dootask.com/login
01. 系统预览
1. 登录系统
2. 系统总览，仪表盘
3. 日历功能，方便安排日程
4. 即时通信功能
5. 文件管理
6. 同时，还能设置共享某个文件
7. 创建复杂的文档、专业的电子表格以及令人赞叹的演示文稿、支持主流格式：docx、xlsx、pptx、ods、doc、txt、ppt等。
8. 这个功能比较强大，可以创建流程图
9. 周报管理
10. 里程碑管理
11. 调研需求管理
02. 部署项目 在部署项目之前，必须安装 Docker 和 Docker Compose，下面是部署该项目的流程。 # 1、克隆项目到您的本地或服务器 # 使用ssh git clone git@github.com:kuaifan/dootask.git # 或者你也可以使用https git clone https://github.com/kuaifan/dootask.git # 2、进入目录 cd dootask # 3、一键构建项目 ./cmd install 部署完毕后即可在浏览器访问项目地址为：http://IP:PORT
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b00f3e2069d03873d46ba19bd423079c/" rel="bookmark">
			ASCII的最大值到底是127还是255
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ASCII 问题引入 我们知道，字符类型占一个字节，也就是八位，那平时我们所讲的ASCII范围只是0-127啊，那也就才7位，剩下的那一位呢？
解释 我们所讲的是标准ASCII，范围是0-127，剩下的那一位是奇偶校验位（有点类似于汉明码），不过后来我们发现，这些字符不太能满足我们的需要，所以就有了扩展ASCII，范围是0-255，正好占八位（一个字节），下面摘录一段百度百科的内容。
摘录 ASCII 码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。
前128个叫标准ASCII 码，也叫基础ASCII码，使用7 位二进制数（剩下的1位二进制为0）来表示有的大写和小写字母，数字0 到9、标点符号，以及在美式英语中使用的特殊控制字符。
同时还要注意，在标准ASCII中，其最高位用作奇偶校验位。所谓奇偶校验，是指在代码传送过程中用来检验是否出现错误的一种方法，一般分奇校验和偶校验两种。奇校验规定：正确的代码一个字节中1的个数必须是奇数，若非奇数，则在最高位添1；偶校验规定：正确的代码一个字节中1的个数必须是偶数，若非偶数，则在最高位添1 。 后128个称为扩展ASCII码。许多基于x86的系统都支持使用扩展（或“高”）ASCII。扩展ASCII 码允许将每个字符的第8 位用于确定附加的128 个特殊符号字符、外来语字母和图形符号 [1] 。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e03f62591140234207c8e9a086c7d96/" rel="bookmark">
			leetcode 647 剑指 Offer II 020. 回文子字符串的个数python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述：
题解：中心拓展
思路：对每个可能的回文中心分别向两侧进行拓展，判断当前对应的子字符串是否回文。回文中心分为奇数和偶数两种情况。
以s=abba，s长度为4为例，可能的回文中心有：a ab b bb b ba a7种，回文中心起始和终止位置如下：
第i组回文中心的左右边界分别为：l = i//2 j = l+i%2
然后分别判断s[l]与s[j]是否相同，相同则说明找到一个回文字串，然后l r分别向左和向右移动，知道超出范围或两个位置的字符不相等。
class Solution: def countSubstrings(self, s: str) -&gt; int: count = 0 n = len(s) for i in range(2*n-1): l = i//2 r = l+i%2 while l&gt;=0 and r&lt;n and s[l]==s[r]: l = l-1 r = r+1 count = count+1 return count 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eac107f97056162d8ce4d33911b32d2/" rel="bookmark">
			Cross-Modality Domain Adaptation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cross-Modality Domain Adaptation for Medical Image Segmentation Unsupervised 3D Semantic Segmentation Domain Adaptation
领域适应（DA）最近引起了医学成像界的强烈兴趣。通过鼓励算法对未知情况或不同的输入数据域具有鲁棒性，域自适应提高了机器学习方法对各种临床环境的适用性。虽然已经提出了各种各样的 DA 技术用于图像分割，但这些技术中的大多数已经在私有数据集或小型公共可用数据集上得到验证。此外，这些数据集主要解决单类问题。为了解决这些限制，crossMoDA 挑战引入了第一个用于无监督跨模态域自适应的大型多类数据集。
Domain Adaptation (DA) has recently raised strong interests in the medical imaging community. By encouraging algorithms to be robust to unseen situations or different input data domains, Domain Adaptation improves the applicability of machine learning approaches to various clinical settings. While a large variety of DA techniques has been proposed for image segmentation, most of these techniques have been validated either on private datasets or on small publicly available datasets.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9eac107f97056162d8ce4d33911b32d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3e76b24886c24510fe859783fa3258b/" rel="bookmark">
			技术分享 | MySQL Binlog 通过 MySQL 客户端导入数据库效率低的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：郭斌斌
爱可生 DBA 团队成员，负责项目日常问题处理及公司平台问题排查。
本文来源：原创投稿
*爱可生开源社区出品，原创内容未经授权不得随意使用，转载请联系小编并注明来源。
一、背景 客户反馈生产环境中，MySQL 5.7 通过 xtrabackup+ Binlog 做基于时间点的恢复操作时，持续卡在 Binlog 的回放阶段，旷日持久，久到离谱。他对于这种旷日持久的操作产生了怀疑，想要确认数据库的这种行为是否合理，因此有了本文的 Binlog 回灌验证操作。
二、复现前提 MySQL Version：5.7.22
Binlog format： Row
准备 Delete 800多万记录的 Binlog
三、复现准备 3.1 创建表、构造数据
mysql&gt; create table t1(id int primary key,name varchar(10)); Query OK, 0 rows affected (0.02 sec) mysql&gt; insert into t1 values(1,repeat('a',10)); Query OK, 1 row affected (0.01 sec) mysql&gt; insert into t1 select (select count(1) from t1)+id,name from t1; Query OK, 1 row affected (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3e76b24886c24510fe859783fa3258b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f43e92c6f3f501de67512a586cbabcd4/" rel="bookmark">
			List去重的三种种方法--C#
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		List去重–C#
class List去重的方法//List如何去重 { #region //自定义去重方法 public static void Main() =&gt; useDistinctMethod(); public static void diyMethod() { // 创建并给 List 赋值 List&lt;Person&gt; list = new List&lt;Person&gt;(); list.Add(new Person{ name= "李四" , password = "123456", age = 20 }); list.Add(new Person{ name = "张三", password = "123456", age = 18 }); list.Add(new Person{ name = "王五", password = "123456", age = 22 }); list.Add(new Person{ name = "张三", password = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f43e92c6f3f501de67512a586cbabcd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be9e56205cee6bc31a123e5b2ecc144a/" rel="bookmark">
			linux uevent 机制中的udev 和mdev
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Uevent机制 1.前提摘要
（1）Sysfs文件系统 内核设备模型主要的模块和用户之间能看到的相关部分就是sysfs文件系统了。内核在启动的时候会注册sysfs文件系统，并且在启动系统的初期。通过mount命令挂载sysfs文件系统到/sys挂载点。
Mount -t sysfs sysfs /sys
那么sysfs文件系统的作用是什么呢。概括的说有三点：
1）、建立系统中总线、驱动、设备三者之间的桥梁
2）、像用户空间展示内核中各种设备的拓扑图
3）、提供给用户空间对设备获取信息和操作的接口，部分取代ioctl功能。
2）Kobject：Sysfs文件系统中最基本的结构就是kobject，kobject可以代表一个设备，一条总线等。在sys目录下直观的以一个目录表示出来。
（3）Uevent机制
上面的分析其实只是对Linux设备模型做了一些基础性的了解。也就是一个穿针引线的作用，如果要细致了解，需要仔细阅读代码。有了上面对于sysfs的基础。接下来我们来比较详细的了解一下uevent机制。
什么是uevent机制。这个得从热插拔设备开始说起。最简单的一个例子就是U盘了。当我们在计算机上插上一个U盘的时候，系统的USB hub会检测到U盘设备接入，并且完成设备枚举过程(从设备上读出相应的设备信息)，并在内核中创建相应的设备结构体。但是，usb设备千奇百态，内核不可能预先将所有usb设备驱动都增加到内存中来。也就是当插入U盘设备的时候，内核中不一定存在对应这个设备的usb驱动。这个时候USB驱动也许以模块的形式保存在硬盘上。载入驱动必然只能从用户态来进行，那这时候应该怎么办呢？
看到这里的时候，有人一定会想，人工敲入命令载入驱动，呵呵。这必然是一种方法，但是是一种很古老的方法。Linux对类似的情况设计了一种uevent的机制。当有新的设备加入的时候，将设备的信息发送消息到用户态。而用户态有一个udev的进程监听这个信息。当收到信息后做一定的解析，根据解析到的结果和用户程序的配置做一些处理，也包括加载驱动程序。
2.具体介绍（Linux设备模型(3)_Uevent）
Uevent是Kobject的一部分，用于在Kobject状态发生改变时，例如增加、移除等，通知用户空间程序。
用户空间程序收到这样的事件后，会做相应的处理。
该机制通常是用来支持热拔插设备的，例如U盘插入后，USB相关的驱动软件会动态创建用于表示该U盘的device结构（相应的也包括其中的kobject），并告知用户空间程序，为该U盘动态的创建/dev/目录下的设备节点，
更进一步，可以通知其它的应用程序，将该U盘设备mount到系统中，从而动态的支持该设备。
Uevent在kernel中的位置
由此可知，Uevent的机制是比较简单的，设备模型中任何设备有事件需要上报时，会触发Uevent提供的接口。Uevent模块准备好上报事件的格式后。
可以通过两个途径把事件上报到用户空间：一种是通过kmod模块，直接调用用户空间的可执行文件；
另一种是通过netlink通信机制，将事件从内核空间传递给用户空间。
注1：有关kmod和netlink，会在其它文章中描述，因此本文就不再详细说明了。
Uevent的内部逻辑解析
Uevent的代码比较简单，主要涉及kobject.h和kobject_uevent.c两个文件，如下：
include/linux/kobject.hlib/kobject_uevent.c 前面有提到过，在利用Kmod向用户空间上报event事件时，会直接执行用户空间的可执行文件。而在Linux系统，可执行文件的执行，依赖于环境变量，因此kobj_uevent_env用于组织此次事件上报时的环境变量。
说明：怎么指定处理uevent的用户空间程序(简称uevent helper)？
上面介绍kobject_uevent_env的内部动作时，有提到，Uevent模块通过Kmod上报Uevent时，会通过call_usermodehelper函数，调用用户空间的可执行文件（或者脚本，简称uevent helper ）处理该event。而该uevent helper的路径保存在uevent_helper数组中。
可以在编译内核时，通过CONFIG_UEVENT_HELPER_PATH配置项，静态指定uevent helper。但这种方式会为每个event fork一个进程，随着内核支持的设备数量的增多，这种方式在系统启动时将会是致命的（可以导致内存溢出等）。因此只有在早期的内核版本中会使用这种方式，现在内核不再推荐使用该方式。因此内核编译时，需要把该配置项留空。
在系统启动后，大部分的设备已经ready，可以根据需要，重新指定一个uevent helper，以便检测系统运行过程中的热拔插事件。这可以通过把helper的路径写入到"/sys/kernel/uevent_helper”文件中实现。实际上，内核通过sysfs文件系统的形式，将uevent_helper数组开放到用户空间，供用户空间程序修改访问，具体可参考"./kernel/ksysfs.c”中相应的代码，这里不再详细描述。
3.实例分析（Uevent 上报event事件给上层的详细讲解_sunweizhong1024的专栏-CSDN博客_add_uevent_var）headphone_event 上报事件的分析
本文章讲解插入headphone的时候，向上层上报event函数的整个过程
#ifdef CONFIG_I_LOVE_PBJ30
void headphone_event(int state)
{
switch_set_state(&amp;wired_switch_dev, state);
}
EXPORT_SYMBOL_GPL(headphone_event);
#endif
headphone_event 函数会调用switch_set_state函数进行上报事件
接下来会调用kobject_uevent_env函数进行上报事件。
最终调用add_uevent_var（）将用户空间需要的参数添加到环境变量中去，如
retval = add_uevent_var(env,"ACTION=%s", action_string);
if (retval)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be9e56205cee6bc31a123e5b2ecc144a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a30b1d57446e03219df3d084ab91718e/" rel="bookmark">
			记一记redis命令，老是记不住
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		key 相关 exists keyexpire key seconds (秒)pexpire key msceonds (毫秒)expireat key timestamp (秒级时间戳)pexpireat key mtimestamp (毫秒级时间戳)del keykeys pattern (与 pattern 匹配的所有 key，如 keys * 返回所有 key)persist key (保留 key 为永久)rename key newkeyrenamenx key newkey (newkey 不存在时才替换) string 相关 (以下 key 表示 string) set key valuemset key val [key1 val1 ...]setnx key val (key 不存在才 set)msetnx key val [key1 val1 ...] (要么所有成功要么都不成功)setex key seconds val (seconds: 过期时间)setbit key offset val (设置 key 的第 offset 位 bit 为 val，val 只能为 0 或 1)setrange key start val (从第 start 为开始设置值为 val，以覆盖每一位的方式，如 get name 返回 wong，set name 1 haha 返回 whaha，set name 0 hua 返回 huaha)get keymget key [key1 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a30b1d57446e03219df3d084ab91718e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dac438099357d1bd3bf59c98a805590/" rel="bookmark">
			linux设备驱动 device add详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux设备驱动的模型，是建立在sysfs设备文件系统和kobject上的，由总线（bus）、设备（device）、驱动（driver）和类（class）所组成的关系结构，在底层，Linux系统中的每个设备都有一个device结构体的实例。struct device已在上一博文中介绍，下面按顺序详细介绍device的主要API。
1.device_create
source位于：drivers\base\Core.c。向sysfs注册一个device，提供了强大的格式化注册接口
/**
* device_create - creates a device and registers it with sysfs
* @class: pointer to the struct class that this device should be registered to
* @parent: pointer to the parent struct device of this new device, if any
* @devt: the dev_t for the char device to be added
* @drvdata: the data to be added to the device for callbacks
* @fmt: string for the device's name
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dac438099357d1bd3bf59c98a805590/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9afbfe4b22c58e3c44d0b3c3a635cb47/" rel="bookmark">
			【正点原子FPGA连载】 第十八章 RGB LCD彩条显示实验 -摘自【正点原子】领航者ZYNQ之FPGA开发指南_V2.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）实验平台：正点原子领航者ZYNQ开发板
2）平台购买地址：https://item.taobao.com/item.htm?&amp;id=606160108761
3）全套实验源码+手册+视频下载地址：http://www.openedv.com/thread-301505-1-1.html
4）对正点原子FPGA感兴趣的同学可以加群讨论：994244016
5）关注正点原子公众号，获取最新资料更新
第十八章 RGB LCD彩条显示实验 TFT-LCD是一种液晶显示屏，它采用薄膜晶体管（TFT）技术提升图像质量，如提高图像亮度和对比度等。相比于传统的CRT显示器，TFT-LCD有着轻薄、功耗低、无辐射、图像质量好等诸多优点，因此广泛应用于电视机、电脑显示器、手机等各种显示设备中。
本章包括以下几个部分：
18.1 RGB LCD简介
18.2 实验任务
18.3 硬件设计
18.4 程序设计
18.5 下载验证
18.1 RGB LCD简介
TFT-LCD的全称是Thin Film Transistor-Liquid Crystal Display，即薄膜晶体管液晶显示屏，它显示的每个像素点都是由集成在液晶后面的薄膜晶体管独立驱动，因此TFT-LCD具有较高的响应速度以及较好的图像质量。正点原子推出的RGB LCD液晶屏较多，7寸RGB LCD屏的实物图如下图所示：
第十八章 RGB LCD彩条显示实验
TFT-LCD是一种液晶显示屏，它采用薄膜晶体管（TFT）技术提升图像质量，如提高图像亮度和对比度等。相比于传统的CRT显示器，TFT-LCD有着轻薄、功耗低、无辐射、图像质量好等诸多优点，因此广泛应用于电视机、电脑显示器、手机等各种显示设备中。
本章包括以下几个部分：
18.1 RGB LCD简介
18.2 实验任务
18.3 硬件设计
18.4 程序设计
18.5 下载验证
18.1 RGB LCD简介
TFT-LCD的全称是Thin Film Transistor-Liquid Crystal Display，即薄膜晶体管液晶显示屏，它显示的每个像素点都是由集成在液晶后面的薄膜晶体管独立驱动，因此TFT-LCD具有较高的响应速度以及较好的图像质量。正点原子推出的RGB LCD液晶屏较多，7寸RGB LCD屏的实物图如下图所示：
图 7.5.13.1 ATK-7’RGB接口TFT液晶屏模块
液晶显示器是现在最常用到的显示器，手机、电脑、各种人机交互设备等基本都用到了LCD，最常见的就是手机和电脑显示器了。由于笔者不是LCD从业人员，对于LCD的具体原理不了解，百度百科对于 LCD的原理解释如下：
LCD的构造是在两片平行的玻璃基板当中放置液晶盒，下基板玻璃上设置 TFT（薄膜晶体管），上基板玻璃上设置彩色滤光片，通过TFT上的信号与电压改变来控制液晶分子的转动方向，从而达到控制每个像素点偏振光出射与否而达到显示目的。我们现在要在领航者开发板上使用LCD，所以不需要去研究LCD 的具体实现原理，我们只需要从使用的角度去关注 LCD 的几个重要点：
1、分辨率
提起LCD显示器，我们都会听到720P、1080P、2K或4K这样的字眼，这个就是LCD显示器分辨率。 LCD显示器都是由一个一个的像素点组成，像素点就类似一个灯(在OLED显示器中，像素点就是一个小灯)，这个小灯是RGB灯，也就是由R(红色)、G(绿色)和B(蓝色)这三种颜色组成的，而RGB就是光的三原色。 1080P的意思就是一个LCD屏幕上的像素数量是1920*1080个，也就是这个屏幕一列1080个像素点，一共 1920列，如图 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9afbfe4b22c58e3c44d0b3c3a635cb47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82661ddd0f4f289145bb2c6b81c8f6d2/" rel="bookmark">
			Ubuntu virtualenv环境转移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		$ sed -i 's/\/media\/acat\/H\/vvv/\/home\/haha\/software\/virtualenv_env/g' `grep "/media/acat/H/vvv" -rl .` 其中，/media/acat/H/vvv是旧的路径，/home/haha/software/virtualenv_env是新的路径。/在正则表达式中需要转义，即使用\/来表示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb3c266e845425b3da0bfe4f63f26b05/" rel="bookmark">
			Power BI与PowerQuery、PowerPivot的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念介绍： 1.Power Query（查询——数据处理）：
一个插件，相当于Excel中的数据选项卡下的数据查询，可以弥补 Excel 的不足，处理数据的能力边界大大提升。PQ用到的语言是M语言，学习 PP 就是学习 Power BI 中的数据处理模块
2.Power Pivot（透视——数据建模）：
相当于Excel中的数据透视表，但是PP功能更强大。PP 用到的语言是 DAX，学习 PP 就是学习 Power BI 的数据建模
*注意：Power View 和 Power Map：PV ——数据可视化；PM ——数据地图（内嵌到PowerBI 且功能更加强大）
二、Power Query详细介绍： 1.用途：将多个工作簿的数据合并到一个表上。
2.优势：数据量无限制、自动化，处理过程全记录，每次数据源更新后刷新即可，无需重复劳动
3.过程：
1）数据获取：
数据的获取上不仅支持微软自己的数据格式，比如 Excel、SQL Server、Access 等;还支持
SAP、Oracle、MySQL、DB2 等几乎能见到的所有类型的数据格式。不仅能从本地获取数据，还能从网页抓取数据。
2）数据清洗：
步骤1：提升标题
方法1）：点击「转换」的将第一行作为标题，即可完成
方法2）：点击将第一行作为标题旁边的下拉按钮，还有个将标题作为第一行，实际上就是拉低标题
步骤2：更改数据类型
方法1）：在 转换-数据类型 里设置
方法2）：在标题栏里右键设置
步骤3：删除错误/空值（数据导入后，有可能出现错误（Error）或者空值（null））
在标题栏里右键-删除/替换错误
在标题栏右下角箭头点击-去掉勾选null
步骤4：删除重复项
选中需要删除的列，右键选择「删除重复项」即可
步骤5：填充
转换-填充-向下填充
步骤6：合并列
转换-合并列
步骤7：拆分
可以选着按字符数，也可以选择按分隔符，如果列中包含多个分隔符，还可以选择按哪个位置的分隔符来拆分
步骤8：分组
转换-分组依据-填上相应参数
步骤9：提取
可以按照长度、首字符、尾字符、范围等来提取
步骤10：行列转置
先将标题最为第一行-转置-再将第一行升为标题
步骤11：行列操作
步骤12：逆透视列
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb3c266e845425b3da0bfe4f63f26b05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec96715b2aa37ce4c4c2a9ad43cbb93a/" rel="bookmark">
			海康、大华rtsp流地址格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		海康： 1、 rtsp://admin:admin123@192.168.0.100:554/Streaming/Channels/101?transportmode=unicast
2、不带用户名密码： rtsp://192.168.0.100:554/Streaming/Channels/101?transportmode=unicast
3、 rtsp://admin:admin123@192.168.0.110:554/Streaming/tracks/101?starttime=20220104t130000z&amp;endtime=20220104t131000z
大华： 1、rtsp://admin:admin123@192.168.0.154:554/cam/realmonitor?channel=1&amp;subtype=0
2、 不带用户名密码：rtsp://192.168.0.154:554/cam/realmonitor?channel=1&amp;subtype=0
3、 rtsp://admin:admin123@192.168.0.154:554/cam/playback?channel=1&amp;subtype=0&amp;starttime=2022_01_04_13_00_00&amp;endtime=2022_01_04_13_10_00
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e12a849f13a410f976502eb22c7a4212/" rel="bookmark">
			spring boot 集成 flowable &#43; mybatisplus冲突解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发项目使用技术栈spring boot 2 + mybatis-plus + flowable 6.3时， 启动报错，如下：
Description:
An attempt was made to call a method that does not exist. The attempt was made from the following location:
com.baomidou.mybatisplus.core.MybatisMapperAnnotationBuilder.getLanguageDriver(MybatisMapperAnnotationBuilder.java:384)
The following method did not exist:
org.apache.ibatis.session.Configuration.getLanguageDriver(Ljava/lang/Class;)Lorg/apache/ibatis/scripting/LanguageDriver;
The calling method's class, com.baomidou.mybatisplus.core.MybatisMapperAnnotationBuilder, was loaded from the following location:
jar:file:/D:/maven/repository/com/baomidou/mybatis-plus-core/3.4.3.4/mybatis-plus-core-3.4.3.4.jar!/com/baomidou/mybatisplus/core/MybatisMapperAnnotationBuilder.class
The called method's class, org.apache.ibatis.session.Configuration, is available from the following locations:
jar:file:/D:/maven/repository/org/mybatis/mybatis/3.4.5/mybatis-3.4.5.jar!/org/apache/ibatis/session/Configuration.class
The called method's class hierarchy was loaded from the following locations:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e12a849f13a410f976502eb22c7a4212/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78430f87289a63fd76b7c036e3e525b0/" rel="bookmark">
			vue echarts地图省市区下钻详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 哈喽你们好！我是小邱，应该会有很多朋友和我都是全栈，我希望今天发表的文章对大家能够有所帮助。
今天我又要说下我不太熟练地vue技术了
虽然不熟练啊但是思路清晰哈哈上码
如果你觉得我文章还不错就点个关注吧！
一、首先vue代码 1.关键引要用到json文件 json文件地址在：阿里云 DataV - 数据可视化平台 2.点击复制按钮，当然这是中国地图的，也可以指定假如要河北的吧，就点击河北省那片区域他这个框住的也会动态变成河北省的 3.创建json文件 我是直接在这里创建的，创建完成之后把你刚刚复制的粘贴进去 4.引入近vue文件里 5.引入进来以后就完成一半了 6.这四行是关键是完成地图的那个25%，其次25%就是地图的配置了，千万要注意这里如果没成功的朋友可以在仔细回头看看这里 定义组件 7.父组件 还得截一下开头好麻烦哈哈事件给忘记了 二、后端 方法我就不展示了主要是的是数据格式 一个name和value我这里columns没用到，因为echarts吗之前是v-charts 好了今天就这样吧，一定要坚持！never say never 永不言败！哈哈！ never say never - Justin 比伯唱的好像 也许未来会有很多困难在等着我们，但是永远不要放弃，加油！程序员们 —— 《小邱》 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dfdbfc60942a86991b02f214abd4d1f/" rel="bookmark">
			【Matlab/Simulink】UDP通信在Matlab/Simulink中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将详细叙述如何在Matlab/Simulink中使用UDP通信协议进行数据传输。
一、 Simulink端发送数据，Simulink端接收数据
1. Simulink端发送数据
我们以打包发送两个single和double数据为例子, 所使用模块依次为Constant,Data Type Conversion，Byte Packing，UDP Send（Instrument Control Toolbox）模块。当发送数据为多个相同类型数据时，通过Mux模块整个输入Byte Packing模块即可。当发送单个数据时候，不需要使用Byte Packing模块。
Byte Packing
该模块主要设置数据的输出输入类型，输出数据类型根据需要进行设置，这里设置为uint8（设置为其他会报错哈哈哈）; 输入数据类型根据输入数据类型来写，以数据格式表示每个输入数据，有几个数据就写几个数据格式，同时出现相应地输入端口。特别地，当多个同类型数据经Mux模块整合输入时，只需要写一个数据格式就可以了。
UDP Send（Instrument Control Toolbox）
该模块主要设置远程IP地址端口和数据打包大小。想把数据发送到那个端口就把Remote address和Remote port设置成相应端口；UDP packet size的设置量应不小于发送数据的个数。
2. Simulink端接收数据
Subsystem1
我们这里使用了Enable使能模块，但没有写使能条件，默认直连就可以了。
UDP Receive(Simulink Real-Time)
这里主要设置接收数据的IP地址端口和接收收据长度。这里的Local IP address和Local port和发送端的Remote address和Remote port保持一致。Receive width表示接收数据的字节长度，这里根据当前情况设置为12（single占4个字节，double占用8个字节，uint8占用1个字节）。
Byte Unpacking
Output port (unpacked) data types：依次填写数据包包含的数据类型
Output port (unpacked) dimensions：每种数据类型对应的数量
二、 Matlab端发送数据，Matlab端接收数据
1. Matlab端发送数据脚本代码
u1=udp('10.1.1.198','RemotePort',11100,'LocalPort',55001);%设置将数据发送 %到哪个IP端口，即第一项和第二项RemotePort，第三项不用管 a=[5 5 1 2 7 1 2 6 1 2 3 4 1 2]; %发送数据示例 for i=1:14 fopen(u1); data_send=a(i); fwrite(u1,data_send,'single');%往端口写入数据，指定端口，数据，格式 pause(5);%每5秒发一次 fclose(u1);%关闭端口 end delete(u1);%删除端口 clear u1;%清理缓存 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dfdbfc60942a86991b02f214abd4d1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f6d43010df98cae480c648e7f5eb2e0/" rel="bookmark">
			微信小程序：javascript调用另一个js文件的函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将一些通用的公共方法抽出来，在根目录下新建一个utils文件夹，新建utils.js在这里我们可以将通用的方法写在这。
每个函数都要写到： module.exports = { getCurrDate, getCurrTime, ......, ......, } // utils.js // 获取当前日期 function getCurrDate() { var date = new Date(); var year = date.getFullYear(); var month = date.getMonth() + 1; // 月份 var day = date.getDate(); if (month &lt; 10) { month = "0" + month; } if (day &lt; 10) { day = "0" + day; } return year + "-" + month + "-" + day; } // 获取当前时间 function getCurrTime(){ // return: 12:01 var date = new Date(); var hours = date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f6d43010df98cae480c648e7f5eb2e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad67eb9370bcc0ec2f817cffbc933a61/" rel="bookmark">
			关于Keil打开工程中的.c文件就无响应卡死的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现这个问题一般是在打开别人的工程文件时，由于对方的keil版本与自己keil版本不一致引起的，只要删除这个工程文件下的.uvopt文件即可解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a0661be622a8dbcd0186c5b1cf1d26b/" rel="bookmark">
			【同一电脑原win用户信息迁移到新Win用户下python interpreter显示 no interpreter问题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 问题解决 问题 原来的win用户下系统突然报错，所有的win的设置点击都会闪退，朋友说是微软的uwp全挂了，经过各种办法尝试仍未解决，最后偶然间发现创建新用户后，电脑能正常使用。于是把原win用户下所有文件以及软件拷贝到新的win用户下，但是有关环境的设置并不能拷贝，于是出现pycharm打开后，右上角所有环境都带叉号。edit configuration中python inperpreter显示no interpreter。多win用户使用同一conda环境也可以参考
解决 发现原来只是pycharm没有找到环境变量路径，于是找到conda环境路径，手动添加一下就好了。流程如下
,
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/300b11feffaacb406e8d6896d1ada289/" rel="bookmark">
			3.9 状态模式(行为)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明:来源课程讲义资料
目录 状态模式1、概念2、 角色和职责3、案例 状态模式 1、概念 State模式也叫状态模式，是行为设计模式的一种。State模式允许通过改变对象的内部状态而改变对象的行为，这个对象表现得就好像修改了它的类一样。
状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转译到表现不同状态的一系列类当中，可以把复杂的判断逻辑简化。
2、 角色和职责 Context：用户对象
拥有一个State类型的成员，以标识对象的当前状态；State：接口或基类
封装与Context的特定状态相关的行为；ConcreteState：接口实现类或子类
实现了一个与Context某个状态相关的行为。
适用于：
对象的行为，依赖于它所处的当前状态。行为随状态改变而改变的场景。
适用于：通过用户的状态来改变对象的行为。 3、案例 #include &lt;iostream&gt; using namespace std; class Worker; class State { public: virtual void doSomeThing(Worker *w) = 0; }; class Worker { public: Worker(); int getHour()	{	return m_hour;	} void setHour(int hour)	{	m_hour = hour;	} State* getCurrentState(	)	{	return m_currstate;	} void setCurrentState(State* state)	{	m_currstate = state;	} void doSomeThing() {	m_currstate-&gt;doSomeThing(this);	} private: int	m_hour; State	*m_currstate; //对象的当前状态 }; class State1 : public State { public: void doSomeThing(Worker *w); }; class State2 : public State { public: void doSomeThing(Worker *w); }; void State1::doSomeThing(Worker *w) { if (w-&gt;getHour() == 7 || w-&gt;getHour()==8) { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/300b11feffaacb406e8d6896d1ada289/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/131a8dcf77c5bc2767ec707b50d271ce/" rel="bookmark">
			3.10 解释模式(行为)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明:来源课程讲义资料
目录 解释模式1、概念2、角色和职责3、案例 解释模式 1、概念 2、角色和职责 Context
解释器上下文环境类。用来存储解释器的上下文环境，比如需要解释的文法等。AbstractExpression
解释器抽象类。ConcreteExpression
解释器具体实现类。 3、案例 #include &lt;iostream&gt; using namespace std; #include "string" class Context { public: Context(int num)	{	m_num = num;	} public: void setNum(int num)	{	m_num = num;	} int getNum()	{	return m_num;	} void setRes(int res)	{	m_res = res;	} int getRes()	{	return m_res;	} private: int m_num; int m_res; }; class Expression { public: virtual void interpreter(Context *context) = 0; }; class PlusExpression : public Expression { public: virtual void interpreter(Context *context) { int num = context-&gt;getNum(); num ++ ; context-&gt;setNum(num); context-&gt;setRes(num); } }; class MinusExpression : public Expression { public: virtual void interpreter(Context *context) { int num = context-&gt;getNum(); num -- ; context-&gt;setNum(num); context-&gt;setRes(num); } }; void main() { Context *pcxt = new Context(10); Expression *e1 = new PlusExpression; e1-&gt;interpreter(pcxt); cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/131a8dcf77c5bc2767ec707b50d271ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80a0a06049f5d98a1360f3a777ef5bb6/" rel="bookmark">
			数据链路层协议 笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 数据链路层是oSI参考模型中的第二层，介乎于物理层和网络层之间。数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自物理层来的数据可靠地传输到相邻节点的目标机网络层。
说白了就是将网络层给的数据包进行封装，封装就是加个帧头和帧尾，封装完了过后就发给物理层进行传输，反之就是将物理层传上来的比特流解封而后交给网络层处理。
上面说了，帧是封装了数据包过后而形成的，帧的格式是这样的。
帧格式 帧有两种格式 以太网上使用的有两种帧格式，分别是：eternal_II 和 IEEE802.3
Data是就是数据包 他前面的都称为mac子层头，后面的FCS就是帧校验序列（就喊帧尾就行了），在数据链路层加的就是这几个东西。
以太网 II类帧格式 D.MAC：目的MAC地址（对面的）6字节
S.MAC：源MAC地址（我自己的）6字节
Type：类型字段，用于标识数据字段中包含的高层协议，该字段长度为2个字节。类型字段取值为0x0800的帧代表IP协议帧;类型字段取值为0x0806的帧代表ARP协议帧。
FCS：用于检验帧传输过程中的完整性 4字节
802.3格式 Length：定义了Data字段包含的字节数。
LLC：D.SAP、S.SAP、Control字段的组成
SNAP：由机构代码（Org Code）和type字段组成 org code3个字节都为0，type与以太网II的type相同。
MAC地址详解 MAC地址:也称为物理地址，是被固化到网卡的全球唯一标识。
1.如同每一个人都有一个名字一样，每一台网络设备都用物理地址来标识自己，这个地址就是MNAc地址。
2.网络设备的MAC地址是全球唯一的。
3. MAC地址长度为48比特，通常用十六进制表示。
4.MAC地址包含两部分:前24比特是组织唯一标识符（Organizationally Unique Tdentifier)，由IEEE统一分配给设备制造商。例如，华为的网络产品的WAc地址前24比特是0x00e0fc。后24位序列号是厂商分配给每个产品的唯一数值，由各个厂商自行分配(这里所说的产品可以是网卡或者其他需要NAc地址的设备)。
MAC地址=厂家标识+内部编号====实现了全球唯—!
MTU分析 以太网和802.3对数据帧的长度都有一个限制，其最大值分别是1500字节和1492字节。链路层的这个特性称为MTU，即最大传输单元。不同类型网络的数帧长度大多数都有一个上限。如果IP层有一个数据报要传，而且数据帧的长度比链路层的MTU还大，那么IP层就需要进行分片即把数据报分成干片，这样每一片就都小于MTU
简单来讲就是 每一帧 以太网最大传输1500字节 802.3最大传输1492字节，如果一个包超过了这个字节数，那么就会被非为两个帧来传输。
数据帧如何传输 数据帧传输方式有三种，分别是单播、广播和组播。
单播：指从单一的源端发送到单一的目的端 如图所示，在冲突域中，主机A发送一个单播帧给主机B，其他所有的主机都能收到这个单播帧，但是其他主机发现目的MAC地址与本机的MAC地址不一样后会丢弃收到的帧，只有真正的目的地主机（主机B）才会接受并处理收到的帧。
广播：表示帧从单一的源发送到共享以太网上的所有主机。广播帧的目的MAc地址为十六进制的FF:FF:FF:FF:FF:FF，所有收到该广播帧的主机都要接收并处理这个帧。 主机A要向所有主机发送信息，就会选择广播，广播的目的MAC地址就是12个F，其余主机接受到数据帧过后发现目的MAC地址是FF:FF:FF:FF:FF:FF就会直接接受并处理，但是广播方式会产生大量的流量，导致带宽利用率降低，影响整个网络性能。但是紧急情况该用还是要用。
组播：组播转发可以理解为选择性的广播，主机侦听特定组播地址，接收并处理目的MAC地址为该组播MAC地址的帧。组播比广播更加高效。 通俗理解：我们将主机ABD分在一个组播地址里面，C没有在，所以B/D能收到A发出的信息，C却不能。
当需要网络上的一组主机(而不是全部主机)接收相同信息，并且其他主机不受影响的情况下通常会使用组播方式。
数据帧的发送和接收 1.帧从主机的物理接口发送出来后，通过传输介质传输到目的端。共享网络中，这个帧可能到达多个主机。主机检查帧头中的目的MAC地址，如果目的MAC地址不是本机MAC地址，也不是本机侦听的组播或广播MAC地址，则主机会丢弃收到的帧。 2.如果目的MAC地址是本机MAC地址，则接收该帧，检查帧校验序列(FCS)字段，并与本机计算的值对比来确定帧在传输过程中是否保持了完整性。如果帧的FCS值与本机计算的值不同，主机会认为帧已被破坏，并会丢弃该帧。如果该帧通过了FCS校验，则主机会根据帧头部中的Type字段来确定将帧发送给上层哪个协议处理。Type字段的值为0x0800,表明该帧需要发送到IP协议上处理。如果type中的字段是0x0806则表示送到ARP协议上处理。在发送给IP/ARP协议之前，帧的头部和尾部会被剥掉。
交换机的基本工作原理 主机A、主机B、主机C分别对应交换机的端口G0/0/1、2、3，主机A发送信息给C则会通过交换机进行转发，交换机中有一个MAC地址表，这个表里面所存储的就是主机设备的MAC与端口对应的信息比如：
00-01-02-03-04-AAG0/0/100-01-02-03-04-BBG0/0/200-01-02-03-04-CC G0/0/3
A要发送给C，那么交换机就会检测数据帧中的目的mac和那个端口对应的就会直接通过端口发送，MAC地址表中的信息在主机没有任何信息发送的情况下最多保存300秒。
1.如果进入交换机的是一个单播帧，则交换机会去MAc地址表中查找这个帧的目的MAc地址。
1）如果查不到这个MAC地址，则交换机执行泛洪操作。
2）如果查到了这个NAC地址，则比较这个NAc地址在MAc地址表中对应的端口是不是这个帧进入交换机的那个端口。如果不是，则交换机执行转发操作。如果是，则交换机执行丢弃操作。
2.如果进入交换机的是一个广播帧，则交换机不会去查MAc地址表，而是直接执行泛洪操作。
交换机的转发行为 1.泛洪:交换机把从某一端口进来的帧通过所有其它的端口转发出去（注意，“所有其它的端口”是指除了这个帧进入交换机的那个端口以外的所有端口)。 ⒉.转发:交换机把从某一端口进来的帧通过另一个端口转发出去（注意，“另一个端口”不能是这个帧进入交换机的那个端口)。
3.丢弃:交换机把从某一端口进来的帧直接丢弃。
该文灵感以来自于 B站 千峰网络安全 投稿的视频 网址：https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80a0a06049f5d98a1360f3a777ef5bb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba68e6dbbe1cfcc3c887a1a496c3c40f/" rel="bookmark">
			【变废为宝】电信IPTV中兴zxv10 b860Av1.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最新版免拆解将电信机顶盒变成智能盒子 以前父母捡了一个电信机顶盒，很多功能、IPTV都无法使用，但我看到盒子上有很多接口，也许还有许多可玩性。于是我想到了变废为宝，变成一个像小米盒子一样的智能盒子。在百度上找了很久，但是很多方法都失效了，而且电信机顶盒也更新了新的算法。我自己研究了一下，在这里分享一个简单的方法。 进入机顶盒设置，湖北电信的设置password是123456，其他地方password网上也能找到。连接WiFi，确保电脑和盒子连接同一个WiFi（或同一局域网）在最下面的运维调试中打开ADB
这里会给出MAC地址和五位或六位随机数（新OTA是六位，C开头的），ADBpassword需要使用ChashCode软件，链接： #http://www.bkill.com/download/171986.html#soft-downUrl 输入MAC地址和随机数点击2018（新OTA算法）就能计算出ADBpassword，电视会提示ADB成功激活
打开好ADB后，使用电脑最新版TV盒子助手（自行百度下载），通过局域网IP地址连接盒子（IP地址在设置里面）安装当贝桌面和当贝市场
注意不要用TV盒子助手自带的软件，自己去官网下载apk安装安装好后重启电信盒子，就能进入当贝桌面了，通过当贝市场也能下载各种视频软件
最后注意使用过程中不要按菜单键，否则就回到了IPTV系统，按home键会自动回到当贝桌面 觉得有用的话就点个赞吧，遇到什么问题也欢迎大家在评论区留言
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50464bcb8936270e735a77f4affe16c3/" rel="bookmark">
			JeecgBoot 升级springboot版本到2.6.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 环境描述
Jeecgboot 3.0，他所依赖的springboot版本为2.3.5Release，将springboot版本升级为2.6.0。过程全纪录，从2开始描述。
2. 修改springboot版本号
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; 修改后，自动导入，导入完成后，运行后端，提示的错误信息有。
3. JeecgRedisCacheWriter错误
根据提示，重新复写3个方法，用默认的。
@Override public CacheStatistics getCacheStatistics(String cacheName) { return null; } @Override public void clearStatistics(String name) { } @Override public RedisCacheWriter withStatisticsCollector(CacheStatisticsCollector cacheStatisticsCollector) { return null; } 4. RedisUtil错误
@SuppressWarnings("unchecked") public void del(String... key) { if (key != null &amp;&amp; key.length &gt; 0) { if (key.length == 1) { redisTemplate.delete(key[0]); } else { redisTemplate.delete(CollectionUtils.arrayToList(key)); } } } 将最后一条语句加上显示转换
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50464bcb8936270e735a77f4affe16c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c25b87d6de786a316be56e8c6e527fc/" rel="bookmark">
			mysql总结(1)-数据库表基础操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql命令学习总结（数据库版本：8.0.21）
在mysql客户端工具中打开mysql命令：以navicat15为例，工具 -&gt; 命令列界面
1、展示、切换数据库
show databases; // 查看所有数据库
use flyfish; // 选择一个数据库进行操作
select database(); // 查看当前所在的数据库
select version(); // 查看当前数据库版本
exit; // 退出命令行界面
2、对数据库表结构进行操作 (在mysql命令列界面操作)
// 建表
CREATE TABLE emp(
id BIGINT NOT NULL auto_increment,
ename VARCHAR(10) COMMENT '员工姓名',
birthdate DATE COMMENT '员工生日',
sal DECIMAL(10,2) COMMENT '员工薪酬',
deptno INT(2) COMMENT '员工所在部门',
PRIMARY key(id)
)ENGINE=INNODB DEFAULT CHARSET=utf8 COMMENT '员工表';
// 查看表信息
show create table emp;
desc emp;
// 修改表结构(但不能修改表名)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c25b87d6de786a316be56e8c6e527fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/955a6e524ba59d9d2fc55faf7f0caf1d/" rel="bookmark">
			git commit后，如何撤销commit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行commit后，还没执行push时，想要撤销这次的commit，该怎么办？ 打开项目目录，git-git bash here--执行命令git reset --soft HEAD^
在看项目里边，已经commit过的文件都回来了
想要连着add也撤销怎么办？ --soft改为--hard（删除工作空间的改动代码）。
命令解释： 1. HEAD^ 表示上一个版本，即上一次的commit，也可以写成HEAD~1
如果进行两次的commit，想要都撤回，可以使用HEAD~2
2. --soft
不删除工作空间的改动代码 ，撤销commit，不撤销git add file
3. --hard
删除工作空间的改动代码，撤销commit且撤销add
4. 如果commit注释写错了，想要改一下注释
git commit --amend
这时候会进入vim编辑器，修改完成你要的注释后保存即可。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/306/">«</a>
	<span class="pagination__item pagination__item--current">307/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/308/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>