<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d2dd4ec3a90b922b6231f055c07c31a/" rel="bookmark">
			Vue使用iconfont（阿里图标库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、进入阿里图标库，注册登录 iconfont-阿里巴巴矢量图标库
2、搜索所需要的图标，加入购物车
3、只是需要单一的可以直接下载，通常将项目所需要的图标一次性加入完成后（可以创建项目），在我的项目统一下载，通常会选择font class下载，如果input的placeholder属性也要使用图标时选择Unicode进行下载
4、在assets下创建iconfont文件夹，将下载的文件解压，将文件中的以下文件，放入到iconfont文件
5、然后在main.js中全局引入对应的css文件
//引入图标库 import "@/assets/iconfont/iconfont.css" 6、然后就可以直接使用啦
&lt;i class="iconfont icon-password"&gt;&lt;/i&gt; 注意 ：在input的placeholder使用时，需要下载的是Unicode版才行，而且不能直接使用，如下实列，也可以参照官网iconfont-阿里巴巴矢量图标库
&lt;input type="text" class="iconfont-unicode" placeholder="&amp;#xe60a;请输入商品名"&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19d123143510472702d93dc381b50b18/" rel="bookmark">
			获取文件类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 package com.yi21.files; import java.io.IOException; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; public class Yi21FilesProbeContentType { public static void main(String[] args) { try { Path path = Paths.get("com\\yi21\\files\\Yi21FilesProbeContentType.java"); String type = Files.probeContentType(path); System.out.println(path + " 的类型为: " + type); } catch (IOException e) { System.out.println("出错: " + e.getMessage()); } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e19efc29f23db43234a358e9592fcb22/" rel="bookmark">
			vue开发问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取指定月份的天数 const days = new Date(2022,2,0).getDate() // 28 重置vue data中的数据 Object.assign(this.$data, this.$options.data()); echarts缩放缩率图不显示（zoomLock需要添加brushSelect、showDataShadow为false） dataZoom: [ { // type: 'inside', show: true, zoomLock: true,//锁定不缩放 height: computeMaxSize(15), brushSelect: false,//不显示缩率图 showDataShadow: false,//不显示缩率图 bottom: computeMaxSize(5), start: 0, end: 0, }, ], echarts 数据量大时dataZoom指定显示个数 option.dataZoom[0].end = (4 / xData.length) * 100;//4指想要显示的个数 子组件调用父组件的函数 // 父组件 &lt;Father @fatherClick="fatherClick"&gt;&lt;/Father&gt; //子组件 &lt;Child v-on="$listeners"&gt;&lt;/Child&gt; //孙组件 &lt;Sun&gt;&lt;/Sun&gt; this.$emit('fatherClick',true) 动态计算字体大小 // 计算1920适配值 export function computeMaxSize(baseSize) { return document.documentElement.clientWidth / 1920 * baseSize; } echarts图在页面缩放时没有变化 window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e19efc29f23db43234a358e9592fcb22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d171ebda5ffa37dc64ea8581b4a9c10/" rel="bookmark">
			Hadoop之SSH无密登录配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.hadoop102上生成公钥和私钥：
[atguigu@hadoop102 /atguigu]$ ssh-keygen -t rsa 然后敲（三个回车），就会生成两个文件id_rsa（私钥）、id_rsa.pub（公钥）
2.切换到 ssh目录
#ssh 是隐藏的一个目录 使用 ll -al来显示所有文件 [root@hadoop102 atguigu]# ll -a [root@hadoop102 atguigu]# cd .ssh 3、将hadoop102公钥拷贝到要免密登录的目标机器上
[atguigu@hadoop102 .ssh]$ ssh-copy-id hadoop102 [atguigu@hadoop102 .ssh]$ ssh-copy-id hadoop103 [atguigu@hadoop102 .ssh]$ ssh-copy-id hadoop104 4、分别配置
#同理 切换到hadoop103配置 [atguigu@hadoop103 .ssh]$ ssh-keygen -t rsa [atguigu@hadoop103 .ssh]$ ssh-copy-id hadoop102 [atguigu@hadoop103 .ssh]$ ssh-copy-id hadoop103 [atguigu@hadoop103 .ssh]$ ssh-copy-id hadoop104 #切换到hadoop104配置 [atguigu@hadoop104 .ssh]$ ssh-keygen -t rsa [atguigu@hadoop104 .ssh]$ ssh-copy-id hadoop102 [atguigu@hadoop104 .ssh]$ ssh-copy-id hadoop103 [atguigu@hadoop104 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d171ebda5ffa37dc64ea8581b4a9c10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7985b411aac5b4c56bc738319e915c2/" rel="bookmark">
			apifox 前置操作用在json中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1beac9558c70920af6311abe544fd7f4/" rel="bookmark">
			(function(){})()立即执行函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		立即执行函数(function(){})() 关键词: 立即执行函数 匿名函数 作用域
格式: (function())()
作用: 立即执行函数(function())()是匿名函数, 主要利用函数的作用域, 减少全局变量的使用。
解释 前提知识
js中的函数通常有两种命名方式,分别是声明式函数 和 函数表达式。
// 声明式函数function func() {}// 函数表达式const func = function() {} 分析
当我们的有些简单函数只执行一次的时候,我们通常会这么做。
// 声明式函数function func () {console.log('I am a cat')}func() // I am a cat// 表达式函数const func = function () {console.log('I am a cat')} // 方法1func() // I am a catconst func = function () {console.log('I am a cat')} () // 方法2func // I am a cat 这时候我们会注意到函数的调用都要用到函数名, 那么如果我们不想要这个函数名呢?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1beac9558c70920af6311abe544fd7f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6d7b9a3cc46503dda6e1a1e209a5b3f/" rel="bookmark">
			动态规划求解正则表达式：给定一个字符串 (s) 和一个字符模式 (p)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个字符串 s 和一个字符模式 p。实现支持 ‘.’ 和 ‘*’ 的正则表达式匹配。
‘.’ 匹配任意单个字符
‘*’ 匹配零个或多个前面的那一个元素
说明: 匹配应该覆盖整个字符串 (s) ，而不是部分字符串。
s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
暴力递归 bool isMatch(string text, string pattern) { if (pattern.empty())return text.empty(); bool first = false; if (!text.empty() &amp;&amp; (pattern[0] == text[0] || pattern[0] == '.')) { first = true; } if (pattern.size() &gt;= 2 &amp;&amp; pattern[1] == '*') { return isMatch(text, pattern.substr(2)) || (first &amp;&amp; isMatch(text.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6d7b9a3cc46503dda6e1a1e209a5b3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e50ee1e74e5151b583ae2f65200bd579/" rel="bookmark">
			如何查看网页元素使用的js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种方法： 1.VisualEvent
下载地址：插件下载
2.使用方法：直接将.crx文件拖到浏览器（目前只支持与谷歌浏览器内核一样的浏览器，360浏览器也可以），如果没有效果，找到扩展管理或者管理，然后在拖动就行。（建议谷歌浏览器）
3截图：
一般就是上面的效果,这样就能查看到js
第二种方法：
例如我们想查看京东导航的js
调出控制台，点击右边的Event开头的，里面是元素所包含的js.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d841c1501875d3ab8d3adc25c18d1c0a/" rel="bookmark">
			Unity中刚体rigidybody的velocity和Addforce方法的不同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初学Unity，把自己的心得体会记录一下。如有错误欢迎指正。
从字面理解velocity是速度，force是推力。veloctiy是瞬间让刚体朝一个方向达到一个速度，会无视已经作用在物体上的其他物理移动。例如：一个球体在平面断桥上滚动，连续用velocity方法让其向前滚动，会直接通过断桥，不会掉下去。如果 球体在向前滚动时通过velocity方法给一个vector3.up方向的速度球体会垂直向上原地 弹起，这说明球体无视了原来向前滚动的力量惯性。如果用addforce方法给一个vector3.up的力，球体会向前跳起，考虑了原来已经作用在球体上向前的惯性。 Addforce方法还有四种不同模式，目前还没搞懂太清楚。弄清楚了再来记录一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e415ca768215fda67af09d632ad0f77d/" rel="bookmark">
			压力测试-JMeter的多种形式参数化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用JMeter做压力测试/接口测试时，面对数据量比较大的情况下一个一个的去设置肯定会非常影响效率，所以参数化的方式必不可少，本文分享JMeter常用的几种参数化的形式。 准备工作：
创建基础API框架：新建测试计划-创建线程组-创建HTTP请求-创建查看结果树
第一种参数化形式：
1、右键线程组-添加-配置元件-用户定义的变量
2、添加变量名和变量值
3、调用变量的方法：使用${变量名}的形式即可调用
第二种参数化形式：
1、 在测试计划中添加变量，使用方法和第一种参数化形式完全一样，只是入口不同
第三种参数化形式：
1、线程组上点鼠标右键-添加-前置处理器-用户参数 2、添加用户和变量（使用时一次只传一个值）
3、因为添加了2个用户，在实际应用时线程数需要改成2，运行后才会依次执行同一个参数带来的不同结果
4、结果会发现两个用户分别赋值给了2个HTTP请求
第四种参数化形式：
1、右键线程组-添加-配置元件-CSV Data Set Config
2、准备CSV文件
3、导入CSV文件
4、引入参数方法
5、 修改线程数后即可运行
6、拓展（其它几个选项的功能）
以上就是Jmeter的四种参数化的形式了，如有疑问欢迎评论区留言讨论~
❤关注我，不迷路❤
******我的本文相关专栏******
软件测试-压力测试专栏（单击此处进入）
******我的其它作品专栏******
PC常见故障汇总专栏（点击进入）
EXCEL综合场景应用详解（点击此处进入）
全国计算机等级考试-二级python基础（点击此处进入）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed7d262e6f7179c93e98d8ae2ebbc9cb/" rel="bookmark">
			vue3移动端触底滚动&#43;返回顶部实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 触底滚动+返回顶部 踩坑：body、html的高度不能设置为100%，不然监听scroll事件无法生效
window.addEventListener('scroll', () =&gt; { let scrollTop = document.documentElement.scrollTop || document.body.scrollTop let windowHeight = document.documentElement.clientHeight || document.body.clientHeight let scrollHeight = document.documentElement.scrollHeight || document.body.scrollHeight if (scrollTop + windowHeight == scrollHeight) { //加载下一页数据 //判断是否存在下一页数据 const totalPage = Math.ceil(tableState.value.total / tableState.value.pagination.pageSize) if (tableState.value.pagination.currentPage &lt;= totalPage){ debounceFn() } } if (scrollTop &gt;= 400) { goTop.style.display = 'block' } else { goTop.style.display = 'none' } goTop.onclick = ()=&gt;{ document.body.scrollTop = 0 document.documentElement.scrollTop = 0 } }) 高度获取 scrollTop：获取滚动的距离clientHeight：元素内部高度，包含内边距padding，不包含border、marginscrollHeight：元素内容的高度，包括不可见部分 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8d06bb17c550414bda9512ce7de442b/" rel="bookmark">
			软件工程 第三章 需求分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 需求分析的任务是什么。需求包含的内容 任务：用户和软件人员双方一起来充分地理解用户的要求，并把双方共同的理解明确地表达成一份书面文档—需求说明书
内容：功能需求和非功能需求
2 需求获取来源有哪些？ 客户或用户标准法律或政策系统或过程文档相关领域专家 3 需求具体包含的哪些方面的内容。 功能需求、性能需求、用户需求、环境需求、界面需求、文档需求、数据需求、资源使用需求、安全保密需求、可靠性需求、软件成本消耗与开发进度需求以及其他非功能性要求。
4 需求获取有哪些手段。 用户面谈需求专题讨论会调查问卷现场考察原型化方法基于用例的方法 5 需求报告的作用是什么？ 作为用户和软件人员之间的合同，为双方相互了解提供基础反映出问题的结构，可以作为软件人员进行设计和编写的基础作为验收的依据，即作为选取测试用例和进行形式验证的依据 6 需求报告的主要内容有哪些？ 介绍总体描述外部接口需求用例非功能需求其他需求全局功能定义（可选） Ps：不应该包括在SRS中的内容：
项目开发计划：诸如成本、人员、进度、工具、方法等产品保证计划：诸如配置管理、验证与测试、质量保证等软件设计细节：需求通常用于表达“做什么”，而不描述“如何做”。 7 写作技术文档的注意事项。 简洁：保持语句和段落的简短；一致：上下文用语一致，陈述风格应该具有一致的样式。具体：系统必须…；或者；用户必须…要紧跟着一个行为动作或可观察的结果。
eg：计算过程中出现除零错误时，系统必须给出提示信息（不好！不具体）；
计算过程中出现除零错误时，系统必须立即弹出对话框显示该错误，并进行声音提示（好！）。必须避免模糊的，主观的术语，减少不确定性
eg：用户友好、容易、简单、美观、迅速、有效、支持、许多、最新技术、优越的、可接收的和健壮的避免使用比较性词汇
eg：提高、最大化、最小化、最佳化。
定量地说明所需要提高的程度或者说清一些参数可接受的最大值和最小值不应该把多个需求集中在一个冗长的叙述段落中
eg：务必记住不要在需求说明中使用“和/或”，“等等”之类的连词（这个等，对于测试人员来说就是灾难…) 8 对需求报告做评审检查的时候，应该从那几个基本方面进行评审（需求文档的质量属性有哪些）？ 作为需求分析阶段的复查手段，在需求分析的最后一步，应该对功能的正确性、完整性和清晰性，以及其他需求给予评价。
质量属性指非功能要求，软件需求规格说明书的质量特性包括正确性、无二义性、完整性、可验证性、一致性。
9 如何确保需求规格说明书的质量（验证需求的方法有哪些）？ 需求验证是检验需求能否满足客户的意愿。
需求评审：由不同代表（如分析员、客户、设计人员、测试人员）组成的评审小组以会议形式对需求进行系统性分析。原型评价：客户和用户在一个可运行的系统上实际检验系统是否符合他们的真正需要。测试用例生成：通过设计具体的测试方法，发现需求种的许多问题。 10 需求建模时，除了可以使用数据流图数据字典之外，还有哪些需求建模手段？ 实体联系方法（E-R图）状态变迁图和状态迁移表判定表和判定树UML建模工具 Ps：加工逻辑描述工具的选择
a.不太复杂的判断逻辑，使用判断树比较好；
b.复杂的判断逻辑，使用判断表比较好；
c.若一个处理逻辑既包含了一般的顺序执行动作，又包含了判断或循环逻辑，则使用结构化语言比较好。
11 判定表包含哪些要素？（要求：判定表要会画，判定树要能读懂） 一张判定表通常由四部分组成，：左上部列出的是所有的条件，左下部为所有可能的操作，右上部分表示各种条件组合的一个矩阵，右下部分是对应于每种条件组合应有的操作。
12 需求跟踪矩阵的内容是什么？解决什么问题？ 内容：需求跟踪矩阵（ Requirement tracking matrix ，RTM ）是一种主要管理需求变更和验证需求是否得到了实现的有效工具，是一种把产品需求从其来源连接到能满足需求的可交付成果的一种表格(需求→生产制造→可交付成果)，借助RTM，可以跟踪每个需求的状态。
解决问题：
（1） 在需求变更、设计变更、代码变更、测试用例变更时，需求跟踪矩阵是目前经过实践检验的进行变更波及范围影响分析的最有效的工具，如果不借助RTM，则发生上述变更时，往往会遗漏某些连锁变化。
（2） RTM也是验证需求是否得到了实现的有效工具，借助RTM，可以跟踪每个需求的状态：是否设计了，是否实现了，是否测试了。
13 什么是SA建模方法，SA建模图？ 定义：
结构化分析方法（Structured Analysis，简称SA方法）是70年代中期提出的一种面向数据流、自顶向下、逐步求精进行需求分析的方法。
适用情况：
结构化分析方法适用于分析大型的数据处理系统，特别适用于企事业管理系统。
结构化分析方法通常与设计阶段的结构化设计方法（Structured Designed，简称SD方法）衔接起来使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8d06bb17c550414bda9512ce7de442b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ef0b3d76dc79284c630084b1dac2d06/" rel="bookmark">
			Mac怎么在Docker容器中访问本地数据库或从Docker容器内部连接到计算机问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 当应用某个应用使用本地Docker容器部署，但是还需要访问本地服务时（如数据库），使用宿主机IP，127.0.0.1，localhost均无法访问，后2者好理解，都属于Docker容器的回环地址，前者：相当于Docker本身，对于Docker来说，容器与宿主机是用Docker虚拟机的网关来通讯，所以无法联接。
环境 Docker：Docker version 20.10.0, build 7287ab3
MacOS Catalina 10.15.7
官方给出的解决方案：
I want to connect from a container to a service on the host
The host has a changing IP address (or none if you have no network access). We recommend that you connect to the special DNS name host.docker.internal which resolves to the internal IP address used by the host. This is for development purpose and does not work in a production environment outside of Docker Desktop.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ef0b3d76dc79284c630084b1dac2d06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf112d4a394cacf8a597403f3594e349/" rel="bookmark">
			深度学习中常用的损失函数(一) —— MSELoss()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nn.MSELoss() 该函数叫做平均平方误差，简称均方误差。它的英文名是mean squared error，该损失函数是挨个元素计算的。该元素的公式如下：
其连个输入参数，第一个参数是输出的参数，第二个参数是与之对比的参数。
loss= torch.nn.MSELoss(reduce=True, size_average=True)
1、 如果reduce = False，返回向量形式的 loss　2、如果reduce = True， 返回标量形式的loss
3、如果size_average = True，返回 loss.mean();
4、如果 size_average = False，返回 loss.sum()
默认情况下：两个参数都为True．
其代码如下： import torch from torch import nn loss = nn.MSELoss() input = torch.randn(3, 5, requires_grad=True) target = torch.randn(3, 5) output = loss(input, target) output.backward() # 反向传播 print('Loss: ',output.item()) # Loss: 1.120721459388733 import torch from torch import nn loss = nn.MSELoss(size_average=False) # 以向量的形式返回 input = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf112d4a394cacf8a597403f3594e349/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f56c9156a8f4949cac1aedda9faa64da/" rel="bookmark">
			Android面经6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、viewModel怎么实现的？ ViewModel实现原理
2、ViewModel是不是一直存在内存中 ViewModel是Android Jetpack组件库中的一个组件，在Android MVVM模式中被广泛使用。
ViewModel的主要特性是以注重生命周期的方式存储和管理数据。
这种特性体现在ViewModel与Android组件（Activity、Fragment和Service）的生命周期相绑定，在组件的生命周期中ViewModel的数据会一直保存在内存中，即便是在系统配置变更时也会存在
3、guideLine为什么不再布局中显示？ 因为默认是gone
4、Android中线程挂了进程会崩溃吗 结论：线程崩溃不一定导致进程崩溃。
线程崩溃的本质就是内存出错。而内存出错有时不会引起其他线程出错的，因为崩溃的线程，也就是出错的内存有时侯没有被其他线程访问，也就不会产生问题，但有时候会打乱其他线程的内存。
5、Rxjava用了那些操作符 RXJava操作符
6、数据变更UI自动更新怎么实现的，用得dataBinding嘛？ 对
dataBinding
7、有网状态下的缓存和无网状态下的缓存一样吗？ 无网络环境下，咱们仅仅能读取缓存文件，为了应用有东西显示。没有什么过时之说了。
WiFi网络环境下。缓存时间可以设置短一点，一是网速较快，而是流量不要钱。
3G流量环境下，缓存时间可以设置长一点，节省流量，就是节省金钱，而且用户体验也更好。
8、livedata粘性事件？ 简单过一遍：livedata
9、jetpack还用过那些？ jetpack简单使用
10、navigation用来做什么？ Navigation 是 Android Jetpack 组件包 中的重要一员，借助于 Single Activity 和 多个Fragment 碎片，优化 Android Activity 启动的开销和简化 Activity 之间的数据通信问题。内置支持普通 Fragment、Activity 和 DialogFragment 组件的跳转，也就是所有 Dialog 或PopupWindow 都建议使用 DialogFragment 实现，这样可以涵盖所有常用的跳转场景，统一返回栈的管理。另外，基于 Fragment 实现可以做到状态存储和恢复。 11、activity依次abcdb ，b为singletask，acd为标准模式，back三次？ abcdb以后，栈内只剩下ab，back三次，b出栈，a出栈，返回桌面
12、java状态机的理解？ 简单看：状态机
13、堆内存溢出，栈溢出相同吗？哪些场景会发生栈溢出？ 一、 栈溢出(StackOverflowError)
栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口灯信息。局部变量表又包含基本数据类型，对象引用类型（局部变量表编译器完成，运行期间不会变化）
所以我们可以理解为栈溢出就是方法执行是创建的栈帧超过了栈的深度。那么最有可能的就是方法递归调用产生这种结果。
二、 堆溢出(OutOfMemoryError:java heap space)
heap space表示堆空间，堆中主要存储的是对象。如果不断的new对象则会导致堆中的空间溢出
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b48e1904f8a8b10857933e75caa7fdf/" rel="bookmark">
			python数据分析实战：超市零售商店
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嗨害大家好鸭！我是小熊猫❤ 其实这是一个做了好久的外包
给大家来分享一下其中的思路
有什么python相关报错解答自己不会的、或者源码资料/模块安装/女装大佬精通技巧 都可以来这里：（https://jq.qq.com/?_wv=1027&amp;k=2Q3YTfym）
一、项目背景 通过"扫描"零售商店电子销售点个别产品的条形码而获得的消费品销售的详细数据。这些数据提供了有关所售商品的数量、特征和价值以及价格的详细信息。
二、数据来源 &lt;链接&gt;
三、提出问题 消费情况分析及用户购买模式分析RFM和CLV分析不同类别商品关联规则挖掘 四、理解数据 Date：购买日期Customer_ID：用户IDTransaction_ID：交易IDSKU_Category：商品分类SKU编码SKU：商品唯一SKU编码Quantity：购买数量Sales_Amount：购买金额 五、数据清洗 1.导入数据 import numpy as np import pandas as pd from matplotlib import pyplot as plt import seaborn as sns %matplotlib inline # 更改设计风格 plt.style.use('ggplot') plt.rcParams['font.sans-serif'] = ['SimHei'] np.__version__ pd.__version__ df = pd.read_csv('scanner_data.csv') df.head() df.info() 2.选择子集 第一列为数据编号，已有索引故删除 df.drop(columns='Unnamed: 0', inplace=True) df.info() ### 3.删除重复值 ```go df.duplicated().sum() 数据无重复值
### 4.缺失值处理 df.isnull().sum() 数据无缺失值
### 5.标准化处理 df.dtypes Date为对象类型，需要标准化为日期类型格式 df.Date = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b48e1904f8a8b10857933e75caa7fdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e57402af8af659ff7c3550fb6e66721/" rel="bookmark">
			Docker容器之基础命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、镜像操作
1、搜索镜像
2、下载镜像 3、查看镜像 4、为镜像添加新的标签 5、镜像导出和导入到本地 6、删除镜像 7、批量删除镜像 8、上传镜像 二、容器操作 1、容器创建
2、查看容器状态 3、启动容器 4、创建并启动容器（docker run） 5、停止容器 6、查看容器IP以及详细信息 7、进入容器 8、容器导出和导入 导出
导入 9、将容器内部的文件传出，将本地文件传入 10、删除容器
一、镜像操作 1、搜索镜像 docker search nginx 2、下载镜像 docker pull nginx #从仓库中下载镜像，若没有指定标签，则下载最新的版本，也就是标签为: latest(最新的) 下载好了的镜像可以在目录/var/lib/docker中查看 3、查看镜像 查看下载到本地的所有镜像
docker images PERPOSITORY: 镜像属于的仓库 TAG： 镜像的标签信息，标记同一个仓库中不同镜像 IMAGE ID： 镜像创建时间 VIRTAL SIZE： 镜像大小 查看单个镜像的详细信息 docker inspect [镜像id或名称] #主要是获取到镜像的唯一标识符，来查看该镜像的详细信息，唯一标识符肯定是ID号，也可以是镜像名称 4、为镜像添加新的标签 docker tag nginx:latest nginx:web #将nginx镜像标签为latest的再添加一个为web标签 目的:为了见名知意 docker images 5、镜像导出和导入到本地 镜像导出到本地
#格式: docker save -o 【存储的文件名】 【存储的镜像】 docker save -o nginx nginx:latest #将镜像名为nginx标签为latest的镜像导出到本地，并命名为nginx 导出到指定目录 将本地镜像导入到镜像库 docker load &lt; nginx #或 docker load -i nginx 6、删除镜像 docker rmi 【镜像库名:标签】 #当一个镜像都多个标签时，只是删除其中指定的标签 #或 docker rmi -f 【镜像id】 #会彻底删除该镜像(如果有多个标签，会报错) 7、批量删除镜像 docker images -q #加载所有镜像id docker rmi `docker images -q` #批量删除所有镜像 docker images |awk 'NR&gt;=2{print "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e57402af8af659ff7c3550fb6e66721/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96f532da7e0d336050eb0145cb8deaa3/" rel="bookmark">
			微信小程序自定义navigationBar、自定义标题栏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做小程序项目，需要用到自定义navigationBar，之前用过colorUI等组件库的navigationBar组件，但是现在想自己写一个，所以有了今天的小记
在做navigationBar之前我们先了解一下navigationBar是什么 ？ 微信小程序一般来说有两个bar，一个导航栏，一个tabbar（小程序下方一排切换按钮），实现下方自定义tabbar的方法一般来说较为简单，现在着重叙述上方自定义导航栏的实现。
为什么要自定义navigationBar？
原生导航栏的限制
除了胶囊按钮以外，原生导航栏只会出现返回按钮和当用户打开的小程序最底层页面是非首页时，默认展示的“返回首页”按钮 。原生导航栏的标题文字的颜色只有黑白。布局无法改变，不能做定制。 产品需求
如果说原生导航栏的限制还不足以让你加入自定义导航栏，那么产品需求绝对是更大的推动力。
自定义导航栏除了不能自定义胶囊按钮以外，其他的范围都是程序员的掌控范围，所以使用自定义导航栏无疑可以满足产品的各种需求。
实际的开发过程中我们会用到以下方法： wx.getSystemInfo() 用于获取系统信息（如设备品牌、设备型号、屏幕大小等，具体参数在文章末尾）wx.getMenuButtonBoundingClientRect() 用于获取小程序的胶囊信息 了解了自定义NAVIGATIONBAR之后我们需要知道怎么做？ 去掉原生导航栏。 将需要自定义navigationBar页面的page.json的navigationBarTitleText去掉。加上"navigationStyle"："custom"，这样原生的导航栏就已经消失，甚至后退键也不会出现，需要自定义。另外，早在2016年微信已经开始适配沉浸式状态栏，目前几乎所有的机型里微信都是沉浸式状态栏，也就是说去掉原生导航栏的同时，整个屏幕已经成为可编程区域。 2.计算navigationBar高度。 原生的胶囊按钮当然存在，那么下一步就需要你去定位出自定义的导航栏高度以及位置。对于不同的机型，对于不同的系统，状态栏以及胶囊按钮的位置都不确定，所以需要用到一定的计算，从而面对任何机型都可以从容判定。 使用"wx.getSystemInfo()“获取到"statusBarHeight”，这样就确定了导航栏最基本的距离屏幕上方的距离。使用"wx.getMenuButtonBoundingClientRect()"获取到小程序的胶囊信息（注意这个api存在各种问题，在不同端表现不一致，后面会叙述这个api调用失败的处理情况），如下图，以下坐标信息以屏幕左上角为原点。 3.以下图为例，上面的红色框是statusBar，高度已知；下面的红色框是正文内容，夹在中间的就是求解之一navigationBarHeight；而黄色的是原生胶囊按钮也是在垂直居中位置，高度为胶囊按钮基于左上角的坐标信息已知，不难得出，navigationBarHeight = 蓝色框高度 × 2 + 胶囊按钮.height。（蓝色框高度 = 胶囊按钮.top - statusBarHeight）
最后的计算公式为：navigationBarHeight = （胶囊按钮.top - statusBarHeight） × 2 + 胶囊按钮.height。navigationBar 距屏幕上方的距离即为navigationBarHeight。
这种计算方法在各种机型以及安卓ios都适用。
针对"wx.getMenuButtonBoundingClientRect()"获取错误或者获取数据为0的极少数情况，只能够去模拟，对于android，一般navigationBarHeight为48px，而对于ios一般为40px，所有机型的胶囊按钮高度是32px笔者也是通过网上很多的文章和自测得出的，这种误差一般可以忽略。当然最理想的就是微信可以hold住所有机型，呵呵。最后提醒一下仅以真机为准，开发者工具的bug就更多不说了。
代码实现 获取本机信息，笔者一般写在App的onLaunch中。 app.js
//计算导航栏高度 const { statusBarHeight, platform } = wx.getSystemInfoSync() const { top, height } = wx.getMenuButtonBoundingClientRect() // 状态栏高度 wx.setStorageSync('statusBarHeight', statusBarHeight) // 胶囊按钮高度 一般是32 如果获取不到就使用32 wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96f532da7e0d336050eb0145cb8deaa3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17133929d23b56c06af13d6ebdf91800/" rel="bookmark">
			Java接收JSON数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、接收单个简单对象 1，需要接收的JSON数据：
{ "userId": 123, "name": "哈哈哈" } 2，对应的Java类：
@Data @ToString public class UserDto extends BaseDto { private Long userId; private String name; } 3，用来接收JSON数据的方式
public Result test2(@RequestBody UserDto userDto) 二、接收数组 1，需要接收的JSON数据：
[ "img/accessory1", "img/accessory2" ] 2，对应的Java类：String
3，用来接收JSON数据的方式
public Result test2(@RequestBody List&lt;String&gt; stringList) 三、接收简单对象数组 1，需要接收的JSON数据：
[ { "userId":123, "name":"哈哈哈" }, { "userId":666, "name":"嘟嘟嘟" } ] 2，对应的Java类
@Data @ToString public class UserDto extends BaseDto { private Long userId; private String name; } 3，用来接收JSON数据的方式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17133929d23b56c06af13d6ebdf91800/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d926caa325830f5ab210067fbde51bf/" rel="bookmark">
			vben admin框架 useForm 时间选择器 开始时间,结束时间解析.懒人方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为搜索部分需要一个创建时间范围,
因为DatePicker返回的是一个数组,开始自己在useTable()中的beforeFetch中拦截请求,然后解析参数,重组参数.这样有好多表格组件的时候,就需要写多个beforeFetch,然后闲来无事 ,就看官网手册,就看到useForm中有一个配置项fieldMapToTime:将表单内时间区域的值映射成 2 个字段,就是相当于开始时间和结束时间给解构出来.这个方法就很方便了.下面是格式
useForm({ fieldMapToTime: [ // data为时间组件在表单内的字段，startTime，endTime为转化后的开始时间于结束时间 // 'YYYY-MM-DD'为时间格式，参考moment ['datetime', ['startTime', 'endTime'], 'YYYY-MM-DD'], // 支持多个字段 ['datetime1', ['startTime1', 'endTime1'], 'YYYY-MM-DD HH:mm:ss'], ], }); 一定是要写在useForm中的喔.因为展示form的配置项.
还有遇到的很多其他问题,想起来再接着写吧.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1435345ef4470b0c03b33c4b1b17ef8a/" rel="bookmark">
			uniapp发布到微信小程序提示 ： Bad value with message: unexpected 的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原因是某些地方用了中文，比如
&lt;view class=" commoncss01 "&gt; &lt;text&gt; 上级姓名: &lt;/text&gt; &lt;text style="color:red;font-size:15px;"&gt;{{上级姓名}} &lt;/text&gt; &lt;/view&gt; 比如我这个上级姓名就用了中文，当时忘了改回来了
改成这样微信开发工具就能编译通过了
&lt;view class=" commoncss01 "&gt; &lt;text&gt; 上级姓名: &lt;/text&gt; &lt;text style="color:red;font-size:15px;"&gt;{{superiorName}} &lt;/text&gt; &lt;/view&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ca0e4167933d2ec8a7365399686f289/" rel="bookmark">
			selenium打开网页并下拉到网页底部的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以打开百度为例：
from selenium import webdriver
driver = webdriver.Chrome() #以谷歌浏览器驱动为例
url = 'https://www.baidu.com'
driver.get(url) #按网址获取网页
js = "window.scrollTo(0, document.body.scrollHeight)" driver.execute_script(js) # 模拟鼠标滚轮，滑动页面至底部 这样就可以把网页下拉到底部，主要用于获取某些网页下面的页码，利于获取元素并点击。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c889e39289d68ac0cc8504dad020b0f0/" rel="bookmark">
			零基础教学之爬取电影的简单分析和实现（附带python代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新一期教学开始啦，本人也是初学，记录下爬取电影的方式，这个比较复杂了，网上的教学也比较少，希望能火吧我这里以某电影网站为例进行爬取
1.首先需要知道，很多的电影网站会用采用m3u8视频分段的方式来加载视频，可不是咱想象中的一整个文件，分段加载的好处就是加载快，这里说到m3u8这其实是个文件，请看截图：
打开f12可以看到有两个m3u8结尾的链接，如果打开这个链接会下载m3u8文件，这里我们来下载看看这个文件的内容，
很明显这个不是真正的m3u8文件，
但是里面有一条地址这个才是真正的文件地址，我们根据地址打开真实文件(这里需要拼接下，真实地址为“https://tv.某某网.com/20191213/ny37lszg/hls/index.m3u8”)，这是我们看到他的真面目
#EXTM3U #EXT-X-VERSION:3 #EXT-X-TARGETDURATION:11 #EXT-X-MEDIA-SEQUENCE:0 #EXT-X-KEY:METHOD=AES-128,URI="https://v.zdubo.com/20191213/ny37lszg/hls/key.key" #EXTINF:10.023, https://v.某某网.com/20191213/ny37lszg/hls/DMTmLuLL.ts #EXTINF:10, https://v.某某网.com/20191213/ny37lszg/hls/sFnwy1KT.ts #EXTINF:10, https://v.某某网.tv/20191213/ny37lszg/hls/sjv8BH0a.ts #EXTINF:10, https://v.某某网.com/20191213/ny37lszg/hls/pOGumGn6.ts #EXT-X-ENDLIST 里面有很多的ts结尾的地址，这里的ts其实就是一个个视频，不过都是片段，把这些ts合并后才是真正的我们要的电影
2.然后我们获取到了ts文件地址，所以你以为结束了吗，不，如果你下载了其中一个ts文件你会发现，根本打不开，这是因为视频进行了加密，这时我们注意到在m3u8文件中有这么一句代码
#EXT-X-KEY:METHOD=AES-128,URI="https://v.某某网.com/20191213/ny37lszg/hls/key.key" 其中的AES-128是加密方式，其中的key是。。。，就是一个key，可以理解为钥匙，我们下载下这个文件
4b56f3209ca9bbef 我们发现里面只有个这玩意，所以我们钥匙有了，锁也有了，到这基本可以去想想代码该怎么实现了
钥匙都给你了，锁也给你了，所以该用钥匙打开锁就要靠你们百度了，这里只讲解怎么用python实现，其他语言咱也么写过
import os import requests import re from Crypto.Cipher import AES from bs4 import BeautifulSoup """ 下载M3U8文件里的所有片段 """ def combine_mp4(path): # 合并ts文件 os.chdir(path) shell_str = '+'.join(os.listdir(path)) shell_str = 'copy /b ' + shell_str + ' ' + '1.mp4' os.system(shell_str) # 删除ts文件 os.system('del /Q *.ts') def download(url): # os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c889e39289d68ac0cc8504dad020b0f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2412210a9a60bb7832e9ab2f3174ea2d/" rel="bookmark">
			Hive入门详解操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hive 第一章 Hive简介 1.1. Hive的简介 1.1.1 hive出现的原因 FaceBook网站每天产生海量的结构化日志数据，为了对这些数据进行管理，并且因为机器学习的需求，产生了hive这门技术，并继续发展成为一个成功的Apache项目。
1.1.2 什么是hive hive是一个构建在Hadoop上的数据仓库工具(框架)，可以将结构化的数据文件映射成一张数据表，并可以使用类sql的方式来对这样的数据文件进行读，写以及管理（包括元数据）。这套HIVE SQL 简称HQL。hive的执行引擎可以是MR、spark、tez。
如果执行引擎是MapReduce的话，hive会将Hql翻译成MR进行数据的计算。 用户可以使用命令行工具或JDBC驱动程序来连接到hive。
1.1.3 为什么使用hive 因为直接使用MapReduce，需要面临以下问题:
- 人员学习成本高 - 项目周期要求太短 - MapReduce实现复杂查询逻辑开发难度大 1.1.4 hive的优缺点 1） hive的优点
1.学习成本低 提供了类SQL查询语言HQL(简单，容易上手)，避免了直接写MapReduce（适合java语言不好的，sql熟练的人），减少开发人员的学习成本。 2.可扩展性好 为超大数据集设计了计算/扩展能力（MR作为计算引擎，HDFS作为存储系统），Hive可以自由的扩展集群的规模，一般情况下不需要重启服务。 3.适合做离线分析处理(OLAP) Hive的执行延迟比较高，因此Hive常用于数据分析，对实时性要求不高的场合。 4.延展性好 Hive支持用户自定义函数，用户可以根据自己的需求来实现自己的函数。 5.良好的容错性 某个数据节点出现问题HQL仍可完成执行。 6.统计管理 提供了统一的元数据管理 2） hive的缺点
1. hive的HQL表达能力有限 - 迭代式算法无法表达，比如PageRank(网页排名) - 数据挖掘方面，比如kmeans(k均值聚类算法) 2. hive的效率比较低 - hive自动生成的mapreduce作业，通常情况下不够智能化 - hive调优比较困难，粒度较粗 1.2. Hive架构和原理 1.2.1 hive的架构简介 从上图可以看出，Hive的体系结构分为以下几部分:
1. 用户连接接口 CLI：是指Shell命令行 JDBC/ODBC:是指Hive的java实现，与传统数据库JDBC类似。 WebUI:是指可通过浏览器访问Hive。 2. thriftserver： hive的可选组件,此组件是一个软件框架服务，允许客户端使用包括Java、C++、Ruby和其他很多种语言，通过编程的方式远程访问Hive。 3. 元数据 Hive将元数据存储在数据库中，如mysql、derby。Hive中的元数据包括(表名、表所属的数据库名、表的拥有者、列/分区字段、表的类型（是否是外部表）、表的数据所在目录等） 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2412210a9a60bb7832e9ab2f3174ea2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/364dbd9251aecfe32a2f3a28dde38b92/" rel="bookmark">
			【Unity】设置UI显示分数和胜利
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		游戏是给用户玩的，所以需要设置一些UI提示给用户看。
文章目录 分数UI胜利UI完整脚本 分数UI 创建Text（新版本这个组件隐藏在旧版中了），设置为ScoreText；
双击文本组件，并设置为2D视图，可以修改属性；
然后添加文本，首先加入头文件：
using UnityEngine.UI; 设置分数初值并定义分数文本：
public int score = 0; //分数初值 public Text scoreText; //定义分数UI 然后在触发检测中设置每吃掉一个Food加+1：
score++; //吃一个Food分数+1 scoreText.text = "分数：" + score; 胜利UI 同理，添加胜利文本，但要注意一点就是，默认情况下这个文本是不显示的（组件取消勾选），只有分数达到胜利的标准才会显示该文本：
然后添加脚本：
public GameObject winText; //将胜利的UI定位为游戏物体（默认不显示，结束后显示） 添加判断胜利逻辑：
//判断游戏胜利 if (score == 8) { winText.SetActive(true); //激活UI } 完整脚本 using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; public class Player : MonoBehaviour { public Rigidbody rd; //public或者private（接口） public int score = 0; //分数初值 public Text scoreText; //定义分数UI public GameObject winText; //将胜利的UI定位为游戏物体（默认不显示，结束后显示） // Start is called before the first frame update void Start() { //Debug.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/364dbd9251aecfe32a2f3a28dde38b92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4514250dab1407536b59118d4e0f4e27/" rel="bookmark">
			oracle循环执行存储过程，指定循环日期区间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、功能：存储过程中for循环调用存储过程
2、场景：跑历史数据
create or replace procedure sp_loop_run is Cursor datekeey is select to_number(to_char(datekeey,'yyyyMMdd')) datekeey from (select date'2021-01-01' + (rownum - 1) datekeey from dual connect by rownum &lt;= (date'2021-06-30' - date'2021-01-01' + 1)) order by datekeey; --从xx到xx遍历日期 i number; begin for i in datekeey LOOP begin sp_pub_fund_quo_adj(i.datekeey); --调用存储过程 end; end LOOP; commit; end sp_loop_run; 参考地址：https://blog.csdn.net/shammy_feng/article/details/124475214
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/711a884495d7d6303d56f09aa0a342f7/" rel="bookmark">
			冒泡排序和快速排序的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		冒泡排序,
就是将相邻的两个元素进行比较，那个大放到了右边，j和j+1
其中i=0；i&lt;n是遍历 了n次，；
遍历一次就少了一个位置，所以j&lt;brr.length-i 其中i是从0开始的就-1
package com.itheima;
import java.util.Arrays;
import java.util.Random;
public class Test02 {
public static void main(String[] args) {
int[] brr=new int[]{10,20,3,88,2,8,3,48,23,39};
for (int i = 0; i &lt; brr.length; i++) { for (int j = 0; j &lt; brr.length-i-1; j++) {//大的值放到后面 if(brr[j]&gt;brr[j+1]) { int temp=brr[j]; brr[j]=brr[j+1]; brr[j+1]=temp; } } } System.out.println("排序后："); System.out.println(Arrays.toString(brr)); } }
排序算法
是数组的下标一个位置不变
，然后和其他剩余的的元素进行比较，
找到最小的放到了，下标i的位置，（进行了元素的交换）
package com.itheima;
import java.util.Scanner;
public class Test {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/711a884495d7d6303d56f09aa0a342f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a311eb2271bdc7e4b45905420516b1c/" rel="bookmark">
			Ubuntu 系统下如何远程访问 Windows 桌面 ?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你一定听说过 Windows 应用程序远程桌面连接。该应用程序系统自带不用安装，并允许您远程访问另一台 PC 或服务器。它使用远程桌面协议建立远程桌面连接会话。
一些 Linux 发行版可能会提供 RDP 客户端来连接到 Windows 系统。但是，对于某些 linux 发行版，您可能需要安装 RDP 客户端来建立远程桌面连接。
作为一个 Linux 用户，有一些可用的 rdp 工具，您可以安装并用于 windows 远程连接。在这篇文章中，我们将解释如何在 Ubuntu linux 上安装 RDP 客户端，并使用它们访问(或连接)远程 windows 桌面。
Reminna Reminna 是一个免费的、开源的、功能强大的远程桌面客户端，用于远程桌面共享。由于它提供了许多有用的特性，大多数 Linux 和 UNIX 用户都采用 remna 客户端来连接远程桌面。
Ubuntu 系统上，使用如下命令安装
$ sudo apt update $ sudo apt install -y remmina remmina-plugin-vnc 安装完 remmina，就可以访问 gui 进行远程桌面连接。
输入您的 windows 系统 IP 地址并按 Enter。系统将提示您输入用户名和密码的详细信息。提交所有详细信息并控制远程桌面。
Vinagre Vinagre 是 GNOME 桌面环境的 SSH，VNC 和 RDP 客户端。它具有高级功能，例如同时连接多个服务器并使用选项卡之间切换。Vinagre 还支持客户端和服务器之间的复制 / 粘贴。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a311eb2271bdc7e4b45905420516b1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37288436d7b0be8f76a78997ccac6827/" rel="bookmark">
			PLSQL——游标（显式游标、隐式游标、REF游标）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.游标简介 游标逐行处理查询结果，以编程的方式访问数据
它实际上是一个指针，它在一段Oracle存放数据查询结果集或数据操作结果集的内存中(数据的缓存区)，游标就是指向这个缓冲区的一个指针
2.游标的类型 1，隐式游标：在 PL/SQL 程序中执行DML SQL 语句时自动创建隐式游标，名字固定叫sql。 (固定存在的)
2，显式游标：显式游标用于处理返回多行的查询。
3，REF 游标：REF 游标用于处理运行时才能确定的动态 SQL 查询的结果
3.游标的属性 %found:返回一个布尔类型的值，如果游标指向的数据不为空，那么返回true，否则返回false
%notfound:和%found相反，指向的数据是空，返回true
%rowcount:它可以表示游标指向的缓冲区（结果集）的数据条数
%isopen:返回一个布尔类型的值，判断当前游标是否打开，如果是打开的返回true，否则返回false
注：boolean布尔类型：只有三个值，true,false,null
4.显式游标 显式游标在 PL/SQL 块的声明部分定义查询，该查询可以返回多行
显式游标，就是自己定义的游标
显式游标的使用：
（1）游标变量的声明
cursor 游标名 is select语句; （指向集而并非第一条数据）
cursor cur_emp is select * from emp;
(2)打开游标
open 游标名称;
open cur_emp;
(3)fetch into 当前游标指向下一条数据并把数据保存在一个变量中
fetch 游标变量 into 变量
fetch cur_emp into v_emp;
(4)关闭游标
close 游标名称
close cur_emp;
如：
--使用游标打印所有员工信息 declare --声名一个游标变量，指向所有员工的信息select * from emp; cursor c_emp is select * from emp; --声名一个emp%rowtype类型的变量用来保存游标中的一条记录 v_emp emp%rowtype; begin --打开游标 open c_emp; --遍历游标 loop --fetch into游标指向下一条数据，并保存数据到变量v_emp中 fetch c_emp into v_emp; --判断游标是否还有数据，如果没有数据，就退出循环 exit when c_emp%notfound; --把这条员工信息打印出来 dbms_output.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37288436d7b0be8f76a78997ccac6827/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e6c03044ed2934b5f6689feb166eff9/" rel="bookmark">
			hidl之client/server端的双向死亡监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在AIDL跨进程通信中知道，可以通过Binder的linkToDeath()实现client/server端的双向死亡监听。那么HIDL可以吗？本文以Android应用为client端，Hal Service为server端。一起看看吧~~
基础知识参考官方文档。https://source.android.com/docs/core/architecture/hidl（打不开链接的小伙伴，不可能是长得太帅）
1.Server端 TestManager继承了类 hidl_death_recipient并重新它的serviceDied方法，从而实现死亡监听。
TestManager.h中部分代码：
class TestManager : public hidl_death_recipient { ... void serviceDied(uint64_t cookie, const android::wp&lt;::android::hidl::base::V1_0::IBase&gt;&amp; who) override; ... }; TestManager.cpp中部分代码：
//register callback and return cookie id int32_t TestManager::subscribe(const sp&lt;ITestServerCallback&gt;&amp; callback) { ALOGI("TestManager subscribe, callback=%p\n", callback.get()); lock_guard&lt;mutex&gt; lk(mMut); ALOGI("TestManager subscribe&gt;&gt;&gt;mDeathCount =%lu\n", mDeathCount); int32_t cookie = 0; mCallbackMap.insert(std::pair&lt;int, sp&lt;ITestServerCallback&gt;&gt;(mDeathCount, callback)); if (mChd != nullptr) { ALOGI("TestManager subscribe&gt;&gt;&gt;linkToDeath\n"); callback-&gt;linkToDeath(mChd, mDeathCount); cookie = mDeathCount; mDeathCount++; } else { ALOGI("TestManager mChd is null\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e6c03044ed2934b5f6689feb166eff9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98d7aaf192ad2108cff8263a2070b19c/" rel="bookmark">
			CentOS 7 重启网络失败&amp;无法ping
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错： systemctl restart network 重启网络失败
无法ping
查看服务状态为failed
原因：虚拟机不正确关闭造成(eg.直接叉掉)
解决： 临时关闭 systemctl stop NetworkManager 永久关闭 systemctl disable NetworkManager 重启 systemctl restart network centos关机命令 reboot 重启halt 立刻关机 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c06484539a231afcb02ec2c544250e7/" rel="bookmark">
			网络安全系统性学习路线「全文字详细介绍」
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基础与准备（导图已备好↓） 1. 网络安全行业与法规
想要从事网络安全行业，必然要先对行业建立一个整体的认知，了解网络安全对于国家和社会的作用，避免出现“一叶障目，不见森林”的情况。
2. Linux 操作系统（网安）
很多初学者也常忽略Linux的重要性，认为学习的重头戏在框架等方面，但其实Linux也是重中之重。
3. 计算机网络基础
计算机网络基础是网络/运维工程师都需掌握的知识，但往往会被忽略。但是它是非常重要的。
4. HTML（网安）
作为任何一门编程语言，掌握编程核心总是由浅入深的。通过网页的开发制作过渡成为一个合格的编程者！
5. JavaScript 入门（网安）
6. HTML / CSS
作为任何一门编程语言，掌握编程核心总是由浅入深的。通过网页的开发制作过渡成为一个合格的编程者！
7. JavaScript 入门与程序设计
8. PHP 零基础入门到实战
PHP主要用于开发网站和互联网软件，它安全、简单易学、免费、跨平台、执行速度快，是各IT公司首选的互联网编程语言,目前国内外很多网站都是使用的PHP语言开发的，作为网络安全从业人员，我们会接触到很多PHP语言开发的网站，所以我们必须对PHP语言有一定的了解，为后面PHP漏洞的学习打下基础。
9. MySQL 基础
MySQL数据库是我们学习网络安全必不可少的，以及后面对SQL语句的了解以及可以对SQL注入进行更好的判断。
10. Python 语法
Python作为方便、上手简单的面向对象编程语言，其中存在许多的第三方库供大家使用，还可以使用Python进行网络渗透和使用Python去开发渗透工具都是不错的选择，所以学习Python也是必不可少的。
【环境搭建资料、工具包、全套视频…等籽料】点此聆取
二、渗透与防御 11. SQL 注入的渗透与防御
SQL注入是我们学习渗透测试接触的第一类漏洞，也是web漏洞中最经典的漏洞。SQL注入式攻击技术，一般针对基于Web平台的应用程序，造成SQL注入攻击漏洞的原因，是由于程序员在编写Web程序时，没有对浏览器端提交的参数进行严格的过滤和判断。用户可以修改构造参数，提交SQL查询语句，并传递至服务器端，从而获取想要的敏感信息，甚至执行危险的代码或系统命令。
12. XSS 渗透与防御
XSS漏洞是Web应用程序中最常见的漏洞之一。这类漏洞能够使得攻击者嵌入恶意脚本代码到正常用户会访问到的页面中，当正常用户访问该页面时，则可导致嵌入的恶意脚本代码的执行，从而达到恶意攻击用户的目的。攻击者可以使，用户在浏览器中执行其预定义的恶意脚本，其导致的危害可想而知，如劫持用户会话，插入恶意内容、重定向用户、使用恶意软件劫持用户浏览器、繁殖XSS蠕虫，甚至破坏网站、修改路由器配置信息等。
13. CSRF 漏洞渗透与防御
CSRF：CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装成受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。
14. 文件上传漏洞利用与防御
文件上传漏洞是指用户上传了一个可执行的脚本文件,并通过此脚本文件获得了执行服务器端命令的能力。
15. 文件包含漏洞利用与防御
随着网站业务的需求，程序开发人员一般希望代码更灵活，所以将被包 含的文件设置为变量，用来进行动态调用，但是正是这种灵活性通过动态变 量的方式引入需要包含的文件时，用户对这个变量可控而且服务端又没有做 合理的校验或者校验被绕过就造成了文件包含漏洞。
16. SSRF 渗透与防御
SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。利用的是服务端的请求伪造。ssrf是利用存在缺陷的web应用作为代理攻击远程和本地的服务器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c06484539a231afcb02ec2c544250e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9858d184a7cdc69d9caaaac000add390/" rel="bookmark">
			Centos 7 操作系统的优化项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第1章 优化的第一阶段01 更改yum源02 安装常用工具03 清空系统版本显示04 关闭selinux05 关闭firewalld防火墙06 让用户密码永不过期07 命令行及命令行文件对历史操作的记录08 不记录命令行以空格开头的操作记录09 给危险命令rm做别名10 设置支持中文字符集11 更改/etc/rc.d/rc.local文件权限74412 校准和更新操作系统的时间13 调整swap交换页面14 防止Cannot allocate memory(无法分配内存)14 调整limit限制15.创建普通用户,让其可以su到超级用户17.ssh服务优化 二、脚本 第1章 优化的第一阶段 以下列出的是一些优化项，并不是说得按照这个顺序来一项一项的优化，你得根据你的场景、你的需求以及你对当前操作系统的梳理。并且有些优化项不是千遍一律的。
01 更改yum源 ### 更改base源为阿里云的源 curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo ### 更改epel源 yum install -y epel-release 02 安装常用工具 yum install -y \ tree telnet lrzsz wget ntpdate vim nc namp dos2unix tcpdump pstree expect sshpass elinks unzip psmisc \ lsof net-tools htop iproute bridge-utils \ bind-utils nscd \ gcc gcc-c++ make cmake libaio zlib-devel pcre-devel \ psmisclsof sysstat yum-utils 03 清空系统版本显示 &gt;/etc/issue &gt;/etc/issue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9858d184a7cdc69d9caaaac000add390/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e76a4c43d8e139614f7b9962689369bd/" rel="bookmark">
			Vue Element ui导航栏选中高亮,刷新后选中消失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		侧边菜单 导航栏选中后重新刷新页面会发现选中的导航栏高亮消失了，或者跳到了其它选项，这里的思路就是定义方法，把路由存入到sessionStorage，页面重新加载的时候从sessionStorage中获取
&lt;!--侧边菜单--&gt; &lt;el-menu :default-active="active" class="el-menu-vertical-demo" router&gt; &lt;router-link to="/user" style="text-decoration: none"&gt; &lt;el-menu-item index="/user" v-if="isflag" @click="selectMenuItem('/user')"&gt; &lt;el-icon&gt;&lt;User /&gt;&lt;/el-icon&gt; &lt;span&gt;User Information&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/router-link&gt; &lt;el-menu-item index="order" v-if="isflag" @click="selectMenuItem('order')"&gt; &lt;el-icon&gt;&lt;Tickets /&gt;&lt;/el-icon&gt; &lt;span&gt;Order Management&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index="manage" v-if="userInfo.rolename=='op' ? false : true" @click="selectMenuItem('manage')"&gt; &lt;el-icon&gt;&lt;Reading /&gt;&lt;/el-icon&gt; &lt;span&gt;Task Management&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index="task" v-if="isflag" @click="selectMenuItem('task')"&gt; &lt;el-icon&gt;&lt;Calendar /&gt;&lt;/el-icon&gt; &lt;span&gt;Schedule&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/el-menu&gt; data() { return { active: "/user", }; }, mounted(){ this.active = window.sessionStorage.getItem("activerouter"); }, methods: { selectMenuItem(path) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e76a4c43d8e139614f7b9962689369bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6822b4a561b18ed1519a310ae55cd903/" rel="bookmark">
			困扰了三天的mysql存储过程问题报错[1267]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		困扰了三天的mysql存储过程问题，解决了，记录一下
报错类型：[1267] Illegal mix of collations (utf8mb4_unicode_ci,IMPLICIT) and (utf8mb4_0900_ai_ci,IMPLICIT) for operation ‘=’
mysql版本：mysql8.0
工具：DBeaver，UItraEdit
复现过程：将原有正常使用的存储过程复制到文本编辑器UItraEdit，修改为满足需求的过程后，在数据库中替换原存储过程，call执行后报错Illegal mix of collations (utf8mb4_unicode_ci,IMPLICIT) and (utf8mb4_0900_ai_ci,IMPLICIT) for operation ‘=’
解决过程：将上面修改好的存储过程复制，到DBevar 中点开原存储过程，粘贴后保存，在弹出页面复制，
然后在UItraEdit新建空白文档，粘贴后保存编码为UTF-8，关闭后重新打开，复制内容，然后在DBevar 新建sql编辑器，粘贴后执行
然后CALL调用，即可正常使用了
虽然问题解决了，但是原因是什么目前还在找，欢迎大佬指教，共同进步
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/210b765c7ed246331fd77fb232e1f54a/" rel="bookmark">
			（一）PaddlePaddle（深度学习框架）的搭建、使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PaddlePaddle是百度公司2016年开源的深度学习框架，现如今可以方便部署到服务器、智能手机和嵌入式设备中。PaddlePaddle还开源大量常用的深度学习模型。 一、PaddlePaddle快速入门： （1）PaddlePaddle的大部分API都在paddle.fluid中。接着定义两个PaddlePaddle常量x1和x2，形状是[2，2]，也叫维度，并赋值为1，类型为int64，得到一个张良[[1，1]，[1，1]]，代码： # PaddlePaddle的大部分API都在paddle.fluid中。 import paddle # 兼容PaddlePaddle2.0 paddle.enable_static() # 接着定义两个PaddlePaddle常量x1和x2，形状是[2，2]，也叫维度，并赋值为1，类型为int64，得到一个张良[[1，1]，[1，1]] x1 = fluid.layers.fill_constant(shape=[2, 2], value=1, dtype='int64') x2 = fluid.layers.fill_constant(shape=[2, 2], value=1, dtype='int64') # 将x1与x2两个张量相加 # PaddlePaddle支持使用算术运算符号，如改成x1+x2 y1 = fluid.layers.sum(x=[x1, x2]) # 然后创建一个执行器，执行器用于把数据传入模型中，并执行模型中。执行器可以使用place参数指定CPU或GPU进行计算 # place = fluid.CUDAPlace(0) # 使用GPU，其中0是指序号为0的显卡 place = fluid.CPUPlace() # 使用CPU exe = fluid.executor.Executor(place) # 使用fluid.Executor()函数执行fluid.default_startup_program()函数，对整个PaddlePaddle程序进行参数随机初始化 exe.run(fluid.default_startup_program()) # PaddlePaddle中两个程序默认：default_startup_program()、default_main_program() # 使用fluid.Executor()函数执行，主程序参数值是fluid.default_main_program() result = exe.run(program=fluid.default_main_program(), fetch_list=[y1]) print(result) 运行结果： （2）PaddlePaddle定义两个变量，赋值，然后相加： import paddle.fluid as fluid import numpy as np import paddle # 兼容PaddlePaddle2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/210b765c7ed246331fd77fb232e1f54a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b200c8f618d6ca955173c03bbffef30/" rel="bookmark">
			内核 3-对象模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、对象
1.1、继承关系
1.2、静态对象和动态对象
1.3、rt_object_class_type枚举类型(对象类型)
1.3.1、RT_Object_Class_Static作用 1.4、rt_object结构体(对象结构体)
1.4.1、对象flags说明
2、对象容器
2.1、rt_object_info_type枚举
2.1.1、RT_Object_Info_Unknown作用
2.2、rt_object_information结构体(对象信息)
2.3、rt_object_container结构体
2.3.1、RT_USING_XXX宏
2.3.2、_OBJ_CONTAINER_LIST_INIT宏
3、函数
3.1、rt_object_init()函数
3.2、rt_object_allocate()函数
3.3、rt_object_detach()函数
3.4、rt_object_delete()函数
3.5、rt_object_is_systemobject()函数
3.6、rt_object_get_type()函数
3.7、rt_object_get_information()函数
3.8、rt_object_find()函数
3.9、rt_object_get_length()函数
3.10、rt_object_get_pointers()函数
4、IPC对象
4.1、IPC控制块
4.2、函数
4.2.1、rt_ipc_object_init()函数
4.2.2、rt_ipc_list_resume()函数
4.2.3、rt_ipc_list_resume_all()函数
4.2.4、rt_ipc_list_suspend()函数
1、对象 RT-Thread 内核采用面向对象的设计思想进行设计，系统级的基础设施都是一种内核对象，例如线程，信号量，互斥量，定时器等。
1.1、继承关系 从面向对象的观点，可以认为每一种具体对象是抽象对象的派生，继承了基本对象的属性并在此基础上扩展了与自己相关的属性。
1.2、静态对象和动态对象 内核对象分为两类：静态内核对象和动态内核对象。静态对象会占用 RAM 空间，不依赖于内存堆管理器，内存分配时间确定。动态对象则依赖于内存堆管理器，运行时申请 RAM 空间，当对象被删除后，占用的 RAM 空间被释放。
静态对象标识对象是静态的(存放在数据段)。动态对象标识对象是从堆中分配的，不需要时需要释放！ 1.3、rt_object_class_type枚举类型(对象类型) enum rt_object_class_type { RT_Object_Class_Null = 0, /* 未使用 */ RT_Object_Class_Thread, /* 线程 */ RT_Object_Class_Semaphore, /* 信号量*/ RT_Object_Class_Mutex, /* 互斥量 */ RT_Object_Class_Event, /* 事件 */ RT_Object_Class_MailBox, /* 邮箱 */ RT_Object_Class_MessageQueue, /* 消息队列 */ RT_Object_Class_MemHeap, /* 内存堆 */ RT_Object_Class_MemPool, /* 内存池 */ RT_Object_Class_Device, /* 设备 */ RT_Object_Class_Timer, /* 定时器 */ RT_Object_Class_Module, /* 模块 */ RT_Object_Class_Unknown, /* 未知 */ RT_Object_Class_Static = 0x80 /* 静态对象 */ }; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b200c8f618d6ca955173c03bbffef30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2d8bdb992b27f4769834667ea1d6412/" rel="bookmark">
			Windows系统安装配置MinGw64位详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MinGW(全称为，Minimalist GNU for Windows)，它实际上是将经典的开源 C语言编译器 GCC 移植到了 Windows 平台下，并且包含了 Win32API ，因此可以将源代码编译为可在 Windows 中运行的可执行程序。而且还可以使用一些 Windows 平台不具备的，但是Linux平台具备的开发工具和API函数。用一句话来概括就是：MinGW 就是 GCC 的 Windows 版本 。
MinGW-w64原本是MinGW项目的分支，后来成为独立发展得项目，由于仅有MinGW-w64被GCC官方所支持, 而MinGW早已停止更新, 因此推荐使用MinGW-w64。
MinGW-w64 与 MinGW 的区别在于 MinGW 只能编译生成32位可执行程序，而 MinGW-w64 则可以编译生成 64位 或 32位 可执行程序
之前电脑装置32位导致出现错误，故重新安装64位
一般安装MinGw有两种情况：
第一种：在线下载：http://mingw-w64.org/doku.php/start通过官网下载，下载后为一个几百k的文件，运行后打开如下。
Version：指你选择GCC编译器版本，当前选择最新版文8.1.0，一般也比较建议选择最新版本
Architecture：指电脑类型，如果是32位则选择i686版本，64位则选择x86_64版本（之前就是选错了导致重新安装）
Threads：线程模式：如果是Linux系统下的选择posix
如果是Windows系统下选择Win32就行（Win64位照我的选就可以了）
Exception：
Exception选项：指的是异常处理模型。i686系统架构有2种选择：dwarf 和 sjlj。x86_64系统架构也有2种选择：seh 和 sjlj。由于我选择的是64位的系统架构，所以可供选择的异常处理模式是：seh 和 sjlj。下面说明sjlj, seh, dwarf三者的区别：
在C++中有 try..throw..catch，当它执行这种结构时，它需要保存现场还原现场，而 sjlj, seh, dwarf 正是实现这类过程的三种方式。
sjlj 全称是 SetJump / LongJump，前者设还原点，后者跳到还原点。可用于32位或者64位系统。
seh (Structured Exception Handling，结构化异常处理) 是 Borland 公司的，微软买了其专利使用权，它利用了FS段寄存器，将还原点压入栈，收到异常时再弹出。相较而言，sjlj 是 C 标准库就有的东西，seh 在 2014 年前是有专利的，从性能上说 seh 比 sjlj 快。只用于64位系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2d8bdb992b27f4769834667ea1d6412/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c00c99f7d0d8ad3902f846ddfcd4555d/" rel="bookmark">
			内核7-线程间同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、信号量
1.1、信号量机制
1.2、信号量的使用场合
1.2.1、线程同步
1.2.2、锁
1.2.3、中断与线程的同步
1.2.4、资源计数
1.3、信号量控制块
1.4、函数
1.4.1、rt_sem_init()函数
1.4.2、rt_sem_create()函数
1.4.3、rt_sem_detach()函数
1.4.4、rt_sem_delete()函数
1.4.5、rt_sem_take()函数
1.4.6、rt_sem_trytake()函数
1.4.7、rt_sem_release()函数
1.4.8、rt_sem_control()函数
2、互斥量
2.1、互斥量机制
2.1.1、优先级反转
2.2、优先级继承算法
2.3、互斥量的使用场合
2.4、互斥量控制块
2.5、函数
2.5.1、rt_mutex_init()函数
2.5.2、rt_mutex_create()函数
2.5.3、rt_mutex_detach()函数
2.5.4、rt_mutex_delete()函数
2.5.5、rt_mutex_take()函数
2.5.6、rt_mutex_release()函数
2.5.7、rt_mutex_control()函数
3、事件集
3.1、事件集机制
3.1.1、事件集特点
3.2、事件集控制块
3.3、函数
3.3.1、rt_event_init()函数
3.3.2、rt_event_create()函数
3.3.3、rt_event_detach()函数
3.3.4、rt_event_delete()函数
3.3.5、rt_event_send()函数
3.3.6、rt_event_recv()函数
3.3.7、rt_event_control()函数
1、信号量 1.1、信号量机制 信号量值使用 16位的无符号整数表示。
1.2、信号量的使用场合 信号量是一种非常灵活的同步方式，可以运用在多种场合中。形成锁、同步、资源计数等关系，也能方便的用于线程与线程、中断与线程间的同步中。
1.2.1、线程同步 线程同步是信号量最简单的一类应用。例如，使用信号量进行两个线程之间的同步，信号量的值初始化成 0，表示具备 0 个信号量资源实例；而尝试获得该信号量的线程，将直接在这个信号量上进行等待。
当持有信号量的线程完成它处理的工作时，释放这个信号量，可以把等待在这个信号量上的线程唤醒，让它执行下一部分工作。这类场合也可以看成把信号量用于工作完成标志：持有信号量的线程完成它自己的工作，然后通知等待该信号量的线程继续下一部分工作。
1.2.2、锁 锁，单一的锁常应用于多个线程间对同一共享资源（即临界区）的访问。信号量在作为锁来使用时，通常应将信号量资源实例初始化成 1，代表系统默认有一个资源可用，因为信号量的值始终在 1 和 0 之间变动，所以这类锁也叫做二值信号量。
注：二值信号量不适合用作锁，因为存在优先级反转的问题。
1.2.3、中断与线程的同步 信号量也能够方便地应用于中断与线程间的同步，例如一个中断触发，中断服务例程需要通知线程进行相应的数据处理。这个时候可以设置信号量的初始值是 0，线程在试图持有这个信号量时，由于信号量的初始值是 0，线程直接在这个信号量上挂起直到信号量被释放。当中断触发时，先进行与硬件相关的动作，例如从硬件的 I/O 口中读取相应的数据，并确认中断以清除中断源，而后释放一个信号量来唤醒相应的线程以做后续的数据处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c00c99f7d0d8ad3902f846ddfcd4555d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28f645a83b8f52062eea631b5c4fe32f/" rel="bookmark">
			CTF-PWN环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CTF-PWN环境搭建 注：此次环境搭建使用的系统是最新版kali2022，从官网下载直接导入虚拟机，按下图操作即可，不会出什么问题
这里使用的默认的kali官方源，如有需要也可以换，不过我这里测试的是默认源，没有出一点问题
kali https://www.kali.org/get-kali/#kali-virtual-machines GDB kali2022默认是不带gdb的，需要安装
sudo apt update sudo apt install gdb pwndbg git clone https://github.com/pwndbg/pwndbg cd pwndbg sudo ./setup.sh cp /root/.gdbinit /home/zhou/.gdbinit sudo cp /root/.gdbinit /home/kali/.gdbinit gdb 在安装pwndbg会自动安装pwntools ROPgadget git clone https://github.com/JonathanSalwan/ROPgadget.git cd ROPgadget sudo python setup.py develop LibcSearcher git clone https://github.com/lieanu/LibcSearcher.git cd LibcSearcher sudo python3 setup.py develop 测试：
from LibcSearcher import * #执行这句话没有报错即可 one_gatget sudo apt install ruby sudo apt install gem sudo gem install one_gadget vscode 下载deb安装包 sudo dpkg -i 本地安装包路径 安装玩之后，输入 code checksec git clone https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28f645a83b8f52062eea631b5c4fe32f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cec25c0719f511daa35bd1411561fa20/" rel="bookmark">
			AJAX异步请求（Asynchronous Javascript And Xml）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、传统请求及缺点（1）传统的请求（2）传统请求存在的问题 2、AJAX概述3、XMLHttpRequest对象4、AJAX GET请求5、AJAX GET请求缓存问题6、AJAX POST请求（1）案例一：使用AJAX POST请求实现用户注册的时候，用户名是否可用。（2）案例二：用户点击按钮之后，发送AJAX请求，显示学生列表。 7、基于JSON的数据交换格式8、基于XML的数据交换9、AJAX乱码问题10、AJAX的异步与同步11、AJAX代码的封装12、AJAX实现省市联动13、AJAX跨域问题（1）跨域（2）同源还是不同源（3）跨域解决方案方案一：设置响应头方案二：jsonp方案三：jQuery封装的jsonp方案四：代理机制（httpclient） 14、AJAX实现搜索联想 自动补全 1、传统请求及缺点 （1）传统的请求 ①直接在浏览器地址栏上输入URL。
②点击超链接
③提交form表单
④使用JS代码发送请求
window.open(url)
document.location.href = url
window.location.href = url
…
（2）传统请求存在的问题 页面全部刷新导致了用户的体验较差。
传统的请求导致用户的体验有空白期。（用户的体验是不连贯的）
2、AJAX概述 （1）AJAX不能称为一种技术，它是多种技术的综合产物。
（2）AJAX可以让浏览器发送一种特殊的请求，这种请求可以是：异步的。
（3）AJAX代码属于WEB前端的JS代码。和后端的java没有关系，后端也可以是php语言，也可以是C语言。
（4）AJAX 应用程序可能使用 XML 来传输数据，但将数据作为纯文本或 JSON 文本传输也同样常见。
（5）AJAX可以更新网页的部分，而不需要重新加载整个页面。（页面局部刷新）
（6）AJAX可以做到在同一个网页中同时启动多个请求，类似于在同一个网页中启动“多线程”，一个“线程”一个“请求”。
同步请求：
异步请求
3、XMLHttpRequest对象 （1）XMLHttpRequest对象是AJAX的核心对象，发送请求以及接收服务器数据的返回，全靠它了。
（2）XMLHttpRequest对象，现代浏览器都是支持的，都内置了该对象。直接用即可。
（3）创建XMLHttpRequest对象语法
var xhr = new XMLHttpRequest(); （4）XMLHttpRequest对象的方法
方法描述abort()取消当前请求getAllResponseHeaders()返回头部信息getResponseHeader()返回特定的头部信息open(method, url, async, user, psw)规定请求method：请求类型 GET 或 POSTurl：文件位置async：true（异步）或 false（同步）user：可选的用户名称psw：可选的密码send()将请求发送到服务器，用于 GET 请求send(string)将请求发送到服务器，用于 POST 请求setRequestHeader()向要发送的报头添加标签/值对 （5）XMLHttpRequest对象的属性
属性描述onreadystatechange定义当 readyState 属性发生变化时被调用的函数readyState保存 XMLHttpRequest 的状态。0：请求未初始化 1：服务器连接已建立 2：请求已收到 3：正在处理请求 4：请求已完成且响应已就绪responseText以字符串返回响应数据responseXML以 XML 数据返回响应数据status返回请求的状态号200: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cec25c0719f511daa35bd1411561fa20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e775ec30da79aee083ba898175e088f/" rel="bookmark">
			python 3.8 安装蓝牙pybluez 以及anconda虚拟环境问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载pybluez 官方地址：https://github.com/pybluez/pybluez
下载后解压到python安装目录下，我这里解压在我的虚拟环境中的Scripts文件目录下，D:\anaconda3\envs\mobileData\Scripts\
二、anconda虚拟环境安装pybluez及问题解决 1 首先进入虚拟环境，然后卸载已有的版本（没安装可以忽略） conda activate mobileData pip uninstall pybluez 2 进入安装目录进行安装 D: cd D:\anaconda3\envs\mobileData\Scripts\pybluez-master python setup.py install 这里可能会有报错的情况，我这边报错是： error: Microsoft Visual C++ 14.0 or greater is required. Get it with "Microsoft C++ Build Tools": https://visualstudio.microsoft.com/visual-cpp-build-tools/
1 解决办法我参考了这位大佬的文章：Microsoft Visual C++ 14.0 or greater is required. Get it with "Microsoft C++ Build Tools"的解决办法 - 知乎
2 解决后重新执行
python setup.py install 3 安装完成 查看pybluez版本可以看到
pip list 参考文章：
Python 连接蓝牙 python3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e775ec30da79aee083ba898175e088f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf2acbcec561d858f8e5c5553c2e7a8a/" rel="bookmark">
			[每周一更]-(第16期)： IOPS的介绍说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IOPS介绍基础概念
1、IOPS是什么? IOPS（Input/Output Operations Per Second）是一个用于电脑存储设备（如硬盘（HDD）、固态硬盘（SSD）或存储区域网络（SAN））性能测试的量测方式，可以视为是每秒的读写次数。
量测说明总IOPS每秒读写次数的总和（混合读取及写入测试）随机读取IOPS每秒平均的随机读取次数随机写入IOPS每秒平均的随机写入次数循序读取IOPS每秒平均的循序读取次数循序写入IOPS每秒平均的循序写入次数 1.1、影响硬盘性能的因素 1.1.1 、寻道时间1.1.2 、旋转延迟1.1.3 、 数据传输时间 1.2、衡量性能的指标 1.2.1、 IOPS IOPS（Input/Output Per
Second）即每秒的输入输出量（或读写次数），即指每秒内系统能处理的I/O请求数量。随机读写频繁的应用，如小文件存储等，关注随机读写性能，IOPS是关键衡量指标。可以推算出磁盘的IOPS = 1000ms / (Tseek +
Trotation + Transfer)，如果忽略数据传输时间，理论上可以计算出随机读写最大的IOPS。
常见磁盘的随机读写最大IOPS为：
7200rpm的磁盘 IOPS = 76 IOPS10000rpm的磁盘IOPS = 111 IOPS15000rpm的磁盘IOPS = 166 IOPS 1.2.2、 吞吐量 吞吐量（Throughput），指单位时间内可以成功传输的数据数量。 吞吐量是指系统在单位时间内处理请求的数量。
CentOS中测试硬盘：
yum -y install hdparm hdparm -Tt --direct/dev/sdb1 #/dev/sdb1*部分可改 -t 评估硬盘的读取效率。-T 评估硬盘快取的读取效率。 以 阿里云服务器为例子（8C16G，云盘260GiB (9600 IOPS)）
[root@izwz96bg1pf5e43r6m2zvpz fio-2.0.7]# hdparm -Tt --direct /dev/vda1 /dev/vda1: Timing O_DIRECT cached reads: 520 MB in 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf2acbcec561d858f8e5c5553c2e7a8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ee4b52cf4237a3548bbf93efd56dd7a/" rel="bookmark">
			内核6-时钟管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、时钟节拍
1.1、时钟节拍的实现方式
1.2、函数
1.2.1、rt_tick_increase()函数
1.2.2、rt_tick_get()函数
1.2.3、rt_tick_set()函数
1.2.4、rt_tick_from_millisecond()函数
2、定时器
2.1、工作流程
2.1.1、硬件定时器工作流程
2.1.2、软件定时器工作流程
2.2、函数
2.2.1、_rt_timer_init()函数
2.2.2、_rt_timer_remove()函数
2.2.3、rt_timer_list_next_timeout()函数
2.2.4、rt_timer_count_height()函数
2.2.5、rt_timer_dump()函数
2.2.6、rt_timer_init()函数
2.2.7、rt_timer_create()函数
2.2.7、rt_timer_detach()函数
2.2.8、rt_timer_delete()函数
2.2.9、rt_timer_start()函数
2.2.10、rt_timer_stop()函数
2.2.11、rt_timer_control()函数
2.2.12、rt_timer_check()函数
2.2.13、rt_soft_timer_check()函数
2.2.14、rt_thread_timer_entry()函数
2.2.15、rt_system_timer_init()函数
2.2.16、rt_system_timer_thread_init()函数
3、高精度延时
3.1、高精度延时示例
1、时钟节拍 任何操作系统都需要提供一个时钟节拍，以供系统处理所有和时间有关的事件，如线程的延时、线程的时间片轮转调度以及定时器超时等。时钟节拍是特定的周期性中断，这个中断可以看做是系统心跳，中断之间的时间间隔取决于不同的应用，一般是 1ms–100ms，时钟节拍率越快，系统的额外开销就越大，从系统启动开始计数的时钟节拍数称为系统时间。
RT-Thread 中， 时 钟 节 拍 的 长 度 可 以 根 据 RT_TICK_PER_SECOND 的 定 义 来 调 整， 等 于 1/RT_TICK_PER_SECOND 秒。
1.1、时钟节拍的实现方式 时钟节拍由配置为中断触发模式的硬件定时器产生，当中断到来时，将调用一次rt_tick_increase()，通知操作系统已经过去一个系统时钟；
1.2、函数 1.2.1、rt_tick_increase()函数 此函数将通知内核经过了一个tick,该函数通常由时钟ISR调用。
1）递增tick
2）当前线程remaining_tick减1,当减为0时让出CPU控制权并进行调度
3）检查硬件定时器是否超时
void rt_tick_increase(void) { struct rt_thread *thread; ++ rt_tick; //rt_tick加1 thread = rt_thread_self(); //获取当前线程 /* 检 查 时 间 片 */ -- thread-&gt;remaining_tick; //线程remaining_tick减1 if (thread-&gt;remaining_tick == 0) //线程remaining_tick为0 { thread-&gt;remaining_tick = thread-&gt;init_tick; //设置线程的remaining_tick为init_tick rt_thread_yield(); //让出控制权，重新进行一次调度 } rt_timer_check(); //检查硬件定时器 } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ee4b52cf4237a3548bbf93efd56dd7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/966a8b50ddaeb543a0aeb796eac17ebd/" rel="bookmark">
			科技与狠活？JDK19中的虚拟线程到底什么鬼？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，JDK 19发布了，推出了几个新的特性，其中有一个比较值得关注的那就是新增了虚拟线程。
很多人可能比较疑惑，到底什么是虚拟线程，和我们现在使用的平台线程有啥区别呢？
要说清楚JDK 19中的虚拟线程，我们要先来了解一下线程都是怎么实现的。
线程的实现方式 我们都知道，在操作系统中，线程是比进程更轻量级的调度执行单位，线程的引入可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源，又可以独立调度。
其实，线程的实现方式主要有三种：分别是使用内核线程实现、使用用户线程实现以及使用用户线程加轻量级进程混合实现。
使用内核线程实现
内核线程（Kernel-Level Thread,KLT）就是直接由操作系统内核（Kernel，下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上，并向应用程序提供API接口来管理线程。
应用程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Light Weight Process,LWP），轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。
有了内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作。
但是轻量级进程具有它的局限性：首先，由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。
使用用户线程实现 在用户空间建立线程库，通过运行时系统(Run-time System)来完成线程的管理，因为这种线程的实现是在用户空间的，所以操作系统的内核并不知道线程的存在，所以内核管理的还是进程，所以这种线程的切换不需要内核操作。
这种实现方式下，一个进程和线程之间的关系是一对多的。
这种线程实现方式的优点是线程切换快，并且可以运行在任何操作系统之上，只需要实现线程库就行了。但是缺点也比较明显，就是所有线程的操作都需要用户程序自己处理，并且因为大多数系统调用都是阻塞的，所以一旦一个进程阻塞了，那么进程中的所有线程也会被阻塞。还有就是多处理器系统中如何将线程映射到其他处理器上也是一个比较大的问题。
使用用户线程加轻量级进程混合实现 还有一种混合实现的方式，就是线程的创建在用户空间完成，通过线程库进行，但是线程的调度是由内核来完成的。多个用户线程通过多路复用来复用多个内核线程。这个就不展开讲了
Java线程的实现方式 以上讲的是操作系统的线程的实现的三种方式，不同的操作系统在实现线程的时候会采用不同的机制，比如windows采用的是内核线程实现的，而Solaris则是通过混合模式实现的。
而Java作为一门跨平台的编程语言，实际上他的线程的实现其实是依赖具体的操作系统的。而比较常用的windows和linux来说，都是采用内核线程的方式实现的。
也就是说，当我们在JAVA代码中创建一个Tread的时候，其实是需要映射到操作系统的线程的具体实现的，因为常见的通过内核线程实现的方式在创建、调度时都需要进行内核参与，所以成本比较高，尽管JAVA中提供了线程池的方式来避免重复创建线程，但是依旧有很大的优化空间。而且这种实现方式意味着受机器资源的影响，平台线程数也是有限制的。
虚拟线程
JDK 19引入的虚拟线程，是JDK 实现的轻量级线程，他可以避免上下文切换带来的的额外耗费。他的实现原理其实是JDK不再是每一个线程都一对一的对应一个操作系统的线程了，而是会将多个虚拟线程映射到少量操作系统线程中，通过有效的调度来避免那些上下文切换。
而且，我们可以在应用程序中创建非常多的虚拟线程，而不依赖于平台线程的数量。这些虚拟线程是由JVM管理的，因此它们不会增加额外的上下文切换开销，因为它们作为普通Java对象存储在RAM中。
虚拟线程与平台线程的区别 首先，虚拟线程总是守护线程。setDaemon (false)方法不能将虚拟线程更改为非守护线程。所以，需要注意的是，当所有启动的非守护进程线程都终止时，JVM将终止。这意味着JVM不会等待虚拟线程完成后才退出。
其次，即使使用setPriority()方法，虚拟线程始终具有normal的优先级，且不能更改优先级。在虚拟线程上调用此方法没有效果。
还有就是，虚拟线程是不支持stop()、suspend()或resume()等方法。这些方法在虚拟线程上调用时会抛出UnsupportedOperationException异常。
如何使用虚拟线程 接下来介绍一下，在JDK 19中如何使用虚拟线程。
首先，通过Thread.startVirtualThread()可以运行一个虚拟线程：
Thread.startVirtualThread(() -&gt; { System.out.println("虚拟线程执行中..."); }); 其次，通过Thread.Builder也可以创建虚拟线程，Thread类提供了ofPlatform()来创建一个平台线程、ofVirtual()来创建虚拟现场。
Thread.Builder platformBuilder = Thread.ofPlatform().name("平台线程"); Thread.Builder virtualBuilder = Thread.ofVirtual().name("虚拟线程"); Thread t1 = platformBuilder .start(() -&gt; {...}); Thread t2 = virtualBuilder.start(() -&gt; {.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/966a8b50ddaeb543a0aeb796eac17ebd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a43acb175e1c135f114300853c80febc/" rel="bookmark">
			前端八股
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面试题预测之八股 前言HTML CSS0、选择器优先级1、块级元素与行内元素区别2、script的defer async标签3、css的flex布局4、grid网格布局5、清除浮动的方式6、BFC是什么 如何触发7、 px rem em vh vw8、 HTML5新特性9、CSS3新特性10、DOM事件流和事件委托10.1事件流10.2事件委托 11、盒模型 JS1、数据类型2、如何判断数据类型3、== 与 ===4、call apply bind1 区别2 手写 5、手写new6、setTimeOut()与setInterval() JS新特性1、作用域与作用域链2、变量声明提升和函数声明提升3、闭包4、执行上下文与执行栈1 执行上下文2 执行栈 5、原型与原型链1 原型2 原型链 6、继承1 原型继承2 构造继承3 组合继承4 寄生组合继承5 extends继承 7、箭头函数和普通函数的区别8、函数的this指向9、深拷贝与浅拷贝10、节流与防抖11、ES6新特性之set12、clientHeight offsetHeight scrollHeight13、JS性能优化1.引入库 计算机基础知识1、经典排序算法（1）冒泡排序（2）选择排序（3）插入排序（4）快速排序 2、B树3、数组遍历的方式4、数组去重的方式5、数组中常见的方法6、OSI七层模型7、三次握手8、四次挥手9、状态码10、sessionStorage localStorage cookie10.1localStorage10.2 sessionStorage10.3 cookie10.4使用场景 11、http https12、tcp udp13、get post14、从输入url到获取页面经历什么 Vue1、双向绑定原理2、MVVM3、nextTick()4、生命周期函数5、computed watch method6、vue优化方式6.1代码层面6.2webpack层面6.3web技术层面优化 7、vue-router路由导航7.1安装配置7.2使用7.3路由重定向、路由模式、懒加载、动态路由7.4路由导航守卫 8、虚拟DOM及优缺点9、diff算法9.1diff算法如何比较 10、v-for key10.1 v-for更新数据列表绑定key10.2 diff算法中使用Key 11、vue组件通信方式11.1父子通信11.2跨代通信11.3任意组件间通信 12、vuex12.1普通使用12.2模块化使用 13、data写成函数式14、v-model15、keep-alive16、vue3与vue2 的对比17、v-if v-show 总结 前言 提示：这里可以添加本文要记录的大概内容：
例如：随着人工智能的不断发展，机器学习这门技术也越来越重要，很多人都开启了学习机器学习，本文就介绍了机器学习的基础内容。
提示：以下是本篇文章正文内容，下面案例可供参考
HTML CSS 0、选择器优先级 !important无条件优先内联样式 style = ‘color:red’ 1000id选择器 100class类选择器 伪类选择器 属性选择器10元素选择器 伪元素选择器 1*通配符选择器 &gt;子类选择器 +兄弟选择器 0继承来的没有优先级 1、块级元素与行内元素区别 块级元素独占一行，可以设置宽度和高度；行内元素会在一行显示，不能设置宽度高度 padding margin，由元素的内容撑开的通过display:inline display:block转换两者行内块元素inline-block既有块级元素可以设置宽高的特性，也有行内元素一行显示的特性，行内块元素独有一个vertical-align属性块级：div p h ul li ol form行内：span input img a select 2、script的defer async标签 script会阻塞DOM加载，从外部引入js会出现空白页问题，引入defer async属性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a43acb175e1c135f114300853c80febc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bffd373c386dca069ec48e2f8e43f99e/" rel="bookmark">
			WSL Ubuntu18中运行gui程序报错：libGL error: No matching fbConfigs or visuals found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WSL Ubuntu18中运行gui程序时发现报如下错误：
libGL error: No matching fbConfigs or visuals found libGL error: failed to load driver: swrast 解决方法：重启Xlaunch，并取消Native opengl的选择，如图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34984df9b340242c5576c2b722c92164/" rel="bookmark">
			初学XDP记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
一、环境准备
二、使用步骤
总结
前言 本文仅作为本人初学XDP的记录，水平很低，酌情参考！
提示：以下是本篇文章正文内容，下面案例可供参考
一、环境准备 我使用的虚拟机环境为CENTOS7，内核版本Linux5.4.215-1.el7.elrepo.x86_64，在开始前需要安装一系列的依赖。
Libbpf简化了bpf程序的开发和加载。库libbpf是tools/lib/bpf下的内核树的一部分，但是Facebook工程师在GitHub上https://github.com/libbpf/libbpf下维护一个独立的构建。
主要依赖项有libbpf、llvm、clang和libelf。LLVM+clang将我们的限制性c程序编译成bpf字节码，存储在ELF对象文件(libelf)中，libbpf通过bpf系统调用将该文件加载到内核中。这些依赖在xdp依赖安装里有详细描述。
LLVM这个依赖项不能使用系统yum默认安装的旧版本，需要自行安装最新版本，在centos7源码编译安装LLVM11.0.0有详细描述，麻烦得很，但必不可少（此生不愿再尝试）。
二、使用步骤 我使用的xdp抓包工具在github上找到——https://github.com/xdp-project/xdp-tools，但在./configure执行后，make可能会出现一些问题，解决办法就是去更新libbpf或者内核版本。
在安装完成后，在系统命令行终端就可以使用xdpdump命令进行抓包了。
Usage: xdpdump [options] XDPDump tool to dump network traffic Options: --rx-capture &lt;mode&gt; Capture point for the rx direction (valid values: entry,exit) -D, --list-interfaces Print the list of available interfaces -i, --interface &lt;ifname&gt; Name of interface to capture on --perf-wakeup &lt;events&gt; Wake up xdpdump every &lt;events&gt; packets -p, --program-names &lt;prog&gt; Specific program to attach to -s, --snapshot-length &lt;snaplen&gt; Minimum bytes of packet to capture --use-pcap Use legacy pcap format for XDP traces -w, --write &lt;file&gt; Write raw packets to pcap file -x, --hex Print the full packet in hex -v, --verbose Enable verbose logging (-vv: more verbose) --version Display version information -h, --help Show this help 我们可以使用如下命令检查xdpdump是否能够正常抓取网卡上的包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34984df9b340242c5576c2b722c92164/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/076008300e4555b1c1225b90972acf0a/" rel="bookmark">
			Cantata 测试工具基本使用介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写本文是因为没有带办公电脑，在个人电脑上先写，然后复制到公司内部网络。需要软件自行联系国内代理商，勿扰
概述 Cantata QA 工具是德国斯图加特的一家名为QA System技术股份有限公司的产品，国内名称为北京旋极信息技术股份有限公司，在北京上海深圳均有办公点。
工具本身在汽车行业符合26262规范工具能够创建自动化测试集。能够支持MCDC测试，有便捷的硬件模拟测试，方便的驱动测试支持。工具官网介绍链接《Cantata Datasheet》工具支持Jenkins和Eclipse，Jenkins介绍《Cantata in a DevOps Pipeline》 国内合作的企业有
测试例 测试的方式与Vector测试工具一样，根据当前代码自动化生成测试代码然后，相当于把待测试的代码嵌入到一个main函数内单独测试，能嵌入的待测是代码不仅仅是一个函数还可以是函之间相互调用的多个函数。
单元测试例注入目标值与输入值
在该界面填写某个运行分支流程的期望值与输入值。然后运行该用例，使其运行达到预期值，测试某一条逻辑分支。
注入数据追踪
通过不同的输入数据将其组合在不同的用例之中，组成不同的测试例。
开始测试
点击图中开始的红色按钮开始测试，测试过程包括测试脚本代码的生成以及测试结果的显示。
规则覆盖率查看
一个逻辑分支的通过并不能测试全部代码，例如有IF判断语句时，输入值为真，则只能测试判断语句中为真的一个分支，想要测试全部代码则还需要添加判断条件为假的输入值。
测试代码显示
在这里可以显示已经测试的代码和未测试的代码 ，已经测试的显示为绿色，未测试的显示为红色，但是这里该工具不如vector，在vector中会用表格的形式对判断条件显示，会展示当前条件还有那些未通过，那些已通过，在MCDC的测试中显得更为清晰明了。
打桩库函数
这里提供了库函数的打桩的方式，直接界面话的选入就好，这里是要比vector工具更为方便的。
测试报告 报告导出
整体看来网页版的报告中详细的细节是要比电子表格更详细的，但是展示篇幅有限在此处就不再详细贴图。
电子表格版本
HTML版本报告总览图
特色功能 cantata自己展示的特色功能
能够与QAC相结合，使其在修改代码的时候可以同时使用QAC和单元测试工具，更便捷的查看报告快速的修改处符合规范的代码。
用例报告
团队总体报告
方式 https://www.watertek.com/ 使用总结 总体看来Cantata与Vector很是类似,不论是测试的方式方法，测试集的建立，还是最后报告的输出，甚至支持的持续集成引擎，两者都没有功能性的差别，两者的选择还是根据已有的工具使用配合以及项目预算来做决定最好。
在测试例的调试部分，Cantata并没有找到相管的资源，Vector可以在英飞凌的平台相关调试中调用Trace32工具软件进行调试，在其他的测试例上可以使用GDB工具对单个用力进行调试。
在硬件的模拟测试上Cantat是优于Vector的，Vector是个纯软件角度的测试工具，而Cantata的测试做了更好的驱动硬件模拟，此外对测试的逻辑顺序也有较好的支持，从这个角度来说，Cantata是更利于嵌入式软件的测试的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/062bd5f7eef2132e64fdb28ae1d33776/" rel="bookmark">
			Elasticsearch7.17学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本学习笔记主要基于 阅读Elasticsearch7.17版本官方文档和实操总结而来，官方文档地址https://www.elastic.co/guide/en/elasticsearch/reference/7.17/index.html
目录
一、ES的存储形式
二、使用方式
2.1 向ES中添加文档
2.2 搜索
2.3 get specific fields 2.4 范围查询
2.5 extract fields from unstrctured content 从非结构化内容中提取fields
2.6 Combine queries 组合查询
2.7 Aggregate data 聚合数据
2.8 图解一个请求​
2.9 field data type 字段包括哪些类型
2.10 解释 结构化数据、非结构化数据、半结构化数据
2.11 term和match区别
三、Query DSL
3.1 dis_max 分离最大化
3.2 boosting query 3.3 constant_score 3.4 function_score query 用户自定义score机制
3.5 intervals query 间隔查询
3.6 match query 3.7 combined_feilds 多个字段
3.8 multi_match
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/062bd5f7eef2132e64fdb28ae1d33776/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/221/">«</a>
	<span class="pagination__item pagination__item--current">222/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/223/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>