<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8e179f1a1c858a78e4e034b5cdb94d3/" rel="bookmark">
			雅虎前端性能优化的35条军规
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无论是在工作中，还是在面试中，Web前端的性能优化都是非常重要的，那么我们进行性能优化需要从哪些方面入手呢？可以遵循雅虎前端性能优化的35条军规，这样我们的优化就有一个比较清晰的方向。
1、尽量减少HTTP请求个数——须权衡
合并图片（如css sprites，内置图片使用数据）、合并CSS、JS，这一点很重要，但是要考虑合并后的文件体积。
2、使用CDN（内容分发网络）
这里可以关注CDN的三类实现：镜像、高速缓存、专线，以及智能路由器和负载均衡；
3、为文件头指定Expires或Cache-Control，使内容具有缓存性。
区分静态内容和动态内容，避免以后页面访问中不必要的HTTP请求。
4、避免空的src和href
留意具有这两个属性的标签如link，script，img，iframe等；
5、使用gzip压缩内容
Gzip压缩所有可能的文件类型以来减少文件体积
6、把CSS放到顶部
实现页面有秩序地加载，这对于拥有较多内容的页面和网速较慢的用户来说更为重要，同时，HTML规范清楚指出样式表要放包含在页面的&lt;head /&gt;区域内；
7、把JS放到底部
HTTP/1.1 规范建议，浏览器每个主机名的并行下载内容不超过两个，而问题在于脚本阻止了页面的平行下载，即便是主机名不相同
8、避免使用CSS表达式
页面显示和缩放，滚动、乃至移动鼠标时，CSS表达式的计算频率是我们要关注的。可以考虑一次性的表达式或者使用事件句柄来代替CSS表达式。
9、将CSS和JS放到外部文件中
我们需要权衡内置代码带来的HTTP请求减少与通过使用外部文件进行缓存带来的好处的折中点。
10、减少DNS查找次数
我们需要权衡减少 DNS查找次数和保持较高程度并行下载两者之间的关系。
11、精简CSS和JS
目的就是减少下载的文件体积，可考虑压缩工具JSMin和YUICompressor。
12、避免跳转
为了确保“后退”按钮可以正确地使用，使用标准的 3XXHTTP状态代码；同域中注意避免反斜杠 “/” 的跳转；
跨域使用 Alias或者 mod_rewirte建立 CNAME（保存一个域名和另外一个域名之间关系的DNS记录）
13、剔除重复的JS和CSS
重复调用脚本，除了增加额外的HTTP请求外，多次运算也会浪费时间。在IE和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。
14、配置ETags
Entity tags（ETags）（实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制（“实体”就是所说的“内 容”，包括图片、脚本、样式表等），是比last-modified date更加灵活的机制，单位时间内文件被修过多次，Etag可以综合Inode(文件的索引节点(inode)数)，MTime(修改时间)和Size来精准的进行判断，避开UNIX记录MTime只能精确到秒的问题。 服务器集群使用，可取后两个参数。使用ETags减少Web应用带宽和负载。
15、使AJAX可缓存
利用时间戳，更精巧的实现响应可缓存与服务器数据同步更新。
16、尽早刷新输出缓冲
尤其对于css，js文件的并行下载更有意义
17、使用GET来完成AJAX请求
当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数据。在url小于2K时使用GET获取数据时更加有意义。
18、延迟加载
确定页面运行正常后，再加载脚本来实现如拖放和动画，或者是隐藏部分的内容以及折叠内容等。
19、预加载
关注下无条件加载，有条件加载和有预期的加载。
20、减少DOM元素个数
使用更适合或者在语意是更贴切的标签，要考虑大量DOM元素中循环的性能开销。
21、根据域名划分页面内容
很显然， 是最大限度地实现平行下载
22、尽量减少iframe的个数
考虑即使内容为空，加载也需要时间，会阻止页面加载，没有语意，注意iframe相对于其他DOM元素高出1-2个数量级的开销，它会在典型方式下阻塞onload事件，IE和Firefox中主页面样式表会阻塞它的下载。
23、避免404
HTTP请求时间消耗是很大的，有些站点把404错误响应页面改为“你是不是要找***”，这虽然改进了用户体验但是同样也会浪费服务器资源（如数据库等）。最糟糕的情况是指向外部 JavaScript的链接出现问题并返回404代码。首先，这种加载会破坏并行加载；其次浏览器会把试图在返回的404响应内容中找到可能有用的部分当作JavaScript代码来执行。
24、减少Cookie的大小
去除不必要的coockie
使coockie体积尽量小以减少对用户响应的影响
注意在适应级别的域名上设置coockie以便使子域名不受影响
设置合理的过期时间。较早地Expire时间和不要过早去清除coockie，都会改善用户的响应时间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8e179f1a1c858a78e4e034b5cdb94d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6801ebfdeb81fee3a16803bf6ddc7bfc/" rel="bookmark">
			《Qt5&#43;QAxObject操作Excel》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt5操作Excel需要用到QAxObject类，还需要在pro文件中添加QT+=axcontainer。
QAxObject类 The QAxObject class provides a QObject that wraps a COM object. Header:#include &lt;QAxObject&gt;qmake:QT += axcontainerInherits:QObject and QAxBaseInherited By: QAxScriptEngine
新建项目 打开Qt，新建一个Qt Widgets Application项目，转到设计师模式，从左侧工具栏添加两个PushBotton控件到窗口上，调整PushBotton控件的大小，分别为两个PushBotton控件添加槽并修改按钮名字为创建Excel和添加数据，具体做法如下：
选中按钮，右键，转到槽...，选择clicked()，OK
添加代码 选择项目文件名，右键，选择添加新文件，类名为Exchange，然后分别添加代码如下：
Pro文件
#------------------------------------------------- # # Project created by QtCreator 2018-11-06T14:28:30 # #------------------------------------------------- QT += core gui greaterThan(QT_MAJOR_VERSION, 4): QT += widgets TARGET = QtExcel TEMPLATE = app QT+=axcontainer # The following define makes your compiler emit warnings if you use # any feature of Qt which has been marked as deprecated (the exact warnings # depend on your compiler).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6801ebfdeb81fee3a16803bf6ddc7bfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93f6f7ce2dac2f5b3c45b3eed1cb446d/" rel="bookmark">
			FlexCel 插入公式和插入新行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//http://www.tmssoftware.biz/flexcel/doc/vcl/api/FlexCel.Core/TExcelFile/InsertAndCopyRange.html#texcelfileinsertandcopyrangetxlscellrange-integer-integer-integer-tflxinsertmode //http://www.tmssoftware.biz/flexcel/doc/vcl/api/FlexCel.Core/TFlxInsertMode.html xls.InsertAndCopyRange(new TXlsCellRange(10, 1, 10, 9), 11, 1, 1, TFlxInsertMode.ShiftRowDown); //插入公式 xls.SetCellValue(10, 3, new TFormula("=Sum(D9:D20)")); 转载于:https://www.cnblogs.com/LCX/p/9852568.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d52a4e4d3636415c68216c40c9a0a4a3/" rel="bookmark">
			pyinstaller使用遇到错误Error: import module hook setuptools.extern.six.moves, No module named _vendor.six
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近因为要将写的.py文件转换为.exe文件，于是查了一些方法。使用的是pyinstaller, 但是在转换的过程中出现了一个错误： import module hook setuptools.extern.six.moves, No module named _vendor.six。于是在网上搜索各种方法，开始时先安装了six包，但是问题并没有解决，于是继续搜索，终于在GitHub的一个角落中找到了跟我一样的问题https://github.com/pyinstaller/pyinstaller/issues/3777，
于是试之，完美解决。
方法：
I have same problem. Was able to work around by running:
pip install --force-reinstall --no-binary :all: pyinstaller from this issue
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a231bee9f8ea5ea3ef3360d5af88664a/" rel="bookmark">
			使用awk分割字符串并且获取分割后的最后一个字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		示例:从字符串"you-me-he"中获取he
echo "you-me-he" |awk -F '[-]' '{print $NF}' 转载于:https://www.cnblogs.com/dakewei/p/9848176.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af9f399f66014a6fbf6ef33c5ce32410/" rel="bookmark">
			PX4的软件仿真(SITL)环境配置过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方地址：https://dev.px4.io/en/simulation/gazebo.html
框架图，各个UDP端口一目了然，仅有连接到模拟器的udp端口是随机的，从下图的启动界面可以看出，模拟器在等待14560端口的初始化数据，onboard运行在14540端口，和GSC通讯端口是14550
下面是编译不同飞机模型的一些命令：
cd ~/src/Firmware #Quadrotor make posix_sitl_default gazebo #Quadrotor with Optical Flow make posix gazebo_iris_opt_flow #3DR Solo make posix gazebo_solo #Standard Plane make posix gazebo_plane #Standard VTOL make posix_sitl_default gazebo_standard_vtol #Tailsitter VTOL make posix_sitl_default gazebo_tailsitter #Ackerman vehicle (UGV/Rover) make posix gazebo_rover #HippoCampus TUHH (UUV: Unmanned Underwater Vehicle) make posix_sitl_default gazebo_hippocampus #起飞
pxh&gt; commander takeoff # The default takeoff location in SITL Gazebo can be overridden using environment variables.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af9f399f66014a6fbf6ef33c5ce32410/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6ed3ff86b4f56cfdec9661930e83ae2/" rel="bookmark">
			MFC 添加皮肤库方法步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中使用的库文件，下载地址：
https://download.csdn.net/download/byh371256/10741951
//VC皮肤库文件SkinPlusPlusDLL实现步骤：
1、在stdafx.h中 引入头文件和库文件 并且工程中添加头文件SkinPlusPlus.h
#include "SkinPlusPlus.h" #pragma comment(lib, "SkinPlusPlusDLL.lib") 2、在App类在其虚函数InitInstance（）中 AfxEnableControlContainer(); 后面添加如下代码
#ifdef _AFXDLL Enable3dControls(); #else Enable3dControlsStatic(); #endif InitializeSkin(("Minimized.ssk"));//初始化 3、重载App的ExitInstance函数添加ExitSkin（）函数
在APP的.h头文件中 virtual int ExitInstance();//重写声明 //重写实现 int CConnectSerialPortApp::ExitInstance() { ExitSkin(); return CWinApp::ExitInstance(); } 4、在界面初始化函数 OnInitDialog()中添加
LoadSkin("XPCorona.ssk"); 初始化皮肤库文件 srand(time(NULL)); //使用srand()用来设置rand()产生随机数时的随机数种子 用time函数值（即当前时间）， //因为两次调用rand()函数的时间通常是不同的，这样就可以保证随机性了。 int nRand = rand() % 3; theApp.m_nRand = nRand; switch (nRand) { case 0: InitializeSkin("Minimized.ssk"); break; case 1: InitializeSkin("SoftCrystal.ssk"); break; case 2: InitializeSkin("XPCorona.ssk"); break; } //加载皮肤库文件 BOOL CConnectSerialPortDlg::OnInitDialog() { CDialogEx::OnInitDialog(); switch (theApp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6ed3ff86b4f56cfdec9661930e83ae2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f97b5f3957bdd40dba03c9a333b4c1f9/" rel="bookmark">
			使用envi将遥感数据从uint16转为uint8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正如我们所知道的，我们从卫星上下载的数据基本都是uint16类型，但是我们显示只能是uint8类型的。所以这就需要我们将uint16转为uint8。
在这里可以使用envi快速完成。
选择Toolbox-&gt;Raster Management-&gt;Masking-&gt;Stretch Data工具进行降位，Data Type设置为Byte。
然后参数设置如下：
特别感谢秋叶无私的帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f370d564b012102dc93cd1ce83e85de5/" rel="bookmark">
			（软件工程）——需求分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件需求分析的任务 1、深入描述软件的功能和性能
2、确定软件设计的约束和软件同其他系统元素的结构细节
3、定义软件的其他有效性需求
一致性、完整性、现实性、有效性、可验证性、
需求分析的任务：借助于当前系统的逻辑模型导出目标系统的逻辑模型，解决目标系统的“做什么”的问题。
需求分析的过程 (1)、问题识别 从系统的角度来理解软件并评审 软件范围是否前挡
确定对目标系统的综合要求，即软件的需求
提出这些需求实现条件，以及需求应达到的标准
软件的需求包括：功能需求、性能需求、环境需求、可靠性需求、安全保密要求、用户界面需求、资源使用需求、成本消耗需求、开发进度需求、预先估计以后系统可能达到的目标。
问题识别的另一项工作是建立分析所需要的通信路径，以保证能顺利地对问题进行分析。
(2)、分析与综合 从信息流和信息结构出发，逐步细化所有的软件功能，找出系统各元素之间的联系、接口特性和设计上的约束，分析它们是否满足功能要求，是否合理。
常用的分析方法：
面向数据流的结构化分析方法（SA）
面向数据结构的Jackson方法（JSD）
结构化数据系统开发方法（DSSD）
面向对象的分析方法（OOA）等
(3)、编制需求分析阶段的文档 软件需求说明书；数据需求说明书；初步的用户手册；修改、完善和确定软件开发实施计划
(4)、需求分析评审 系统定义的目标是否与用户的要求一致；
系统需求分析阶段提供的文档资料是否齐全；
文档中的所有描述是否完整、清晰、准确反映用户要求、
与所有其他系统成分的重要接口是否都已经描述
需求分析主要分四部： 理解当前的现实系统；从当前系统的现实模型中，抽象出当前系统的逻辑模型；分析目标系统和现有系统的区别，建立目标系统的逻辑模型；为目标系统的逻辑模型做相应的补充。
软件需求分析的原则 需要能够表达和理解问题的信息域和功能域
要能以层次化的方式对问题进行分分解和不断细化
针对需求分析的指导性原则 1、在开始建立分析模型前，先理解问题
2、开发原型，使得用户能够了解将如何发生人机交互
3、记录每个需求的起因以及原因
4、使用多个需求视图，
5、给需求赋予优先级
6、努力删除含糊性
软件需求方法 1、需求分析方法由对软件问题的信息域和功能域的系统分析过程及其表示方法组成
2、大多数的需求分析方法是由信息驱动的
结构化分析方法 1、面向数据流进行需求分析的方法
2、结构化分析方法适合于数据处理类型软件的需求分析
数据流与数据加工之间的关系
数据流图的层次结构 为了表达数据处理过程的数据加工情况，需要采用层次结构的数据流图。
检查和修改数据流图的原则 1、数据流图上所有图形符号只限于前述四种基本图形元素
2、数据流图的主图必须包括前述四种基本元素，缺一不可
3、每个加工至少有一个输入数据流和一个输出数据流
4、在数据流图中，需按层给加工框编号。编号表明该加工所处层次及上下层的亲子关系
5、规定任何一个数据流子图必须与它上一层的一个加工对应，两者的输入数据流和输出数据流必须一致。
6、图上每个元素都必须有名字
7、数据流图中不可夹带控制流
8、初画时可以忽略琐碎的细节，以集中经历于主要数据流
数据字典 数据字典与数据流图配合，能清楚地表达数据处理的要求
词条描述——对于在数据流图中每一个被命名的图形元素，均加以定义，其内容有：名字，别名或编号，分类，描述，定义，位置，其他，等
用于写加工逻辑说明的工具：结构化英语、判断表、判断树
1、结构化英语 结构化英语的词汇表由：英语命令动词、数据字典中定义的名字、有限的自定义词、逻辑关系词
是一种介于自然语言和形式化语言之间的语言
语言的正文用基本控制结构进行分割，加工中的操作用自然语言短语来表示
基本控制结构有三种：简单陈述句结构、重复结构、判定结构
2、判定表 如果数据流图的加工需要依赖于多个逻辑条件的取值，使用判定表来描述比较合适。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f370d564b012102dc93cd1ce83e85de5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4eda5275ea3b859c03ec43c21ce5677a/" rel="bookmark">
			自定义注解 aspectj方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自定义注解 aspectj方式
spring-servlet.xml
&lt;!-- aop 注解实现 --&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; @IpLoginAnnotation
@Documented @Target(ElementType.METHOD) @Inherited @Retention(RetentionPolicy.RUNTIME) public @interface IpLoginAnnotation { boolean IpLogin() default true; } LogAspect.class
package com.ccd.util.annotation.iplog; import javax.servlet.http.HttpServletRequest; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.Signature; import org.aspectj.lang.annotation.AfterReturning; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.springframework.stereotype.Component; @Aspect //该注解标示该类为切面类 @Component //注入依赖 public class LogAspect { //标注该方法体为后置通知，当目标方法执行成功后执行该方法体 @Before(value = " @annotation(rl)") public void addLogSuccess(JoinPoint jp, IpLoginAnnotation rl){ HttpServletRequest request = null; System.out.println("进入"); Object[] parames = jp.getArgs();//获取目标方法体参数 for (int i = 0; i &lt; parames.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4eda5275ea3b859c03ec43c21ce5677a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4d193065cebce6855ccf6fee73e1c53/" rel="bookmark">
			因式分解机（Factorization Machines，FM ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FM优化（0）：因式分解机（Factorization Machines，FM ）
FM优化（1）：基于地理因式分解法的POI推荐排序算法（Rank-GeoFM）
前言FM背景FM模型FM算法详解FM模型为什么优于多项式和线性模型 前言 FM全称为factorization machine, 可以用解决回归、二分类问题
FM模型在基本的线性模型上引入一个交叉项，交叉项系数是定义一个辅助变量v,利用正定矩阵来估计交叉项的系数。
FM主要是考虑了特征之间的关联。
目的：解决高维稀疏数据中特征组合问题，适用于categorical feature。
背景 强调一点，FM的适用对象是稀疏数据。
任何研究过点击预测问题或推荐系统的人都会面临类似的情况：由于数据集非常庞大，因此使用有限的计算资源对这些数据集进行预测变得非常困难。
但是，在大多数情况下，这些数据集是稀疏的（每个训练示例只有少数变量为非零）。在数据稀疏的情况下，满足求解参数都不为0的情况很少，所以很难训练。然而因子分解机有助于从从现有的原始数据中，提取最重要的潜在的或隐藏的特征。
一般来说，可以使用低维密集矩阵来表示对象和预测器之间关系，而分解有助于与前者建立大致相同的关联。
FM模型 step1：一般的线性模型为（n表示n维特征）：
y = w 0 + ∑ i = 1 n w i x i y = w_0+ \sum_{i=1}^nw_ix_i y=w0​+i=1∑n​wi​xi​
step2：如果在线性模型中加入二阶特征的组合，那么会是这个样子的
y ^ ( x ) = w 0 + ∑ i = 1 n w i x i + ∑ i = 1 n − 1 ∑ j = i + 1 n w i j x i x j \hat y(x) =w_0 + \sum_{i=1}^nw_ix_i + \sum_{i=1}^{n-1}\sum_{j=i+1}^nw_{ij}x_ix_j y^​(x)=w0​+i=1∑n​wi​xi​+i=1∑n−1​j=i+1∑n​wij​xi​xj​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4d193065cebce6855ccf6fee73e1c53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d366ec9737a54486309e4ac3772c21be/" rel="bookmark">
			MQ（message queue）使用 Spring整合 MQ下载 五分钟上手使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MQ百度云下载
链接：https://pan.baidu.com/s/1h3s1RF4FE6hN7aUlLuDmkA 提取码：6bit 1、ActiveMQ简介 什么是ActiveMQ
ActiveMQ工作原理
1、 解决服务之间代码耦合
2、 使用消息队列，增加系统并发处理量
ActiveMQ应用场景分析：
1、 当系统使用短信平台、邮件平台的时候。
用户注册，重点使用用户信息数据库保存，而发短信、发邮件，增加业务处理复杂度，这时候使用MQ， 将发短信、发邮箱，通知MQ，由另外服务平台完成。解决了代码的耦合问题。
2、 当系统使用搜索平台、缓存平台的时候。
查询数据，建立缓存、索引 ，当再次查询相同数据的时候，不从数据库查询，从缓存或者索引库查询
当增加、修改、删除数据时，发送消息给MQ， 缓存平台、索引平台 从MQ获取到这个信息，更新缓存或者索引
总结：使用MQ作为系统间数据调用的中转站。
下载安装 运行activemq.bat文件 3. 网页访问 访问：&lt;http://localhost:8161/&gt; 点击：[Manage ActiveMQ broker](http://localhost:8161/admin/) 用户名和密码 都是admin ActiveMQ使用的是标准生产者和消费者模型
有两种数据结构 Queue、Topic 1、Queue 队列 ，生产者生产了一个消息，只能由一个消费者进行消费
2、Topic 话题，生产者生产了一个消息，可以由多个消费者进行消费
maven引入mq依赖 &lt;!--activemq--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt; &lt;/dependency&gt; 编写config配置类
加入application.properties配置
# MQ的服务器地址 spring.activemq.broker-url=tcp://127.0.0.1:61616 # 是否使用内置MQ spring.activemq.in-memory=false # 用户名 spring.activemq.password=admin # 密码 spring.activemq.user=admin import org.apache.activemq.command.ActiveMQQueue; import org.apache.activemq.command.ActiveMQTopic; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d366ec9737a54486309e4ac3772c21be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a7a53424d667383ceab4caacaf68b73/" rel="bookmark">
			js中 mouseout/mouseleave事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js的mouseout和mouseover事件 mouseover事件mouseout和mouseleave事件例子 mouseover事件 mouseover在鼠标停留在某个元素时触发，有点类似与hover
mouseout和mouseleave事件 mouseout 与 mouseleave 事件不同，不论鼠标指针离开被选元素还是任何子元素，都会触发 mouseout 事件。只有在鼠标指针离开被选元素时，才会触发 mouseleave 事件。 例子 &lt;div class="header-right"&gt; &lt;a i18n="myOrder_person" id="private_person" class="private_person" onmouseover="personCenter_show()" &gt;個人中心&lt;/a&gt; &lt;ul id="private_person_list" onmouseleave="personCenter_hide()" &gt; &lt;li i18n="myOrder_order"&gt;我的訂單&lt;/li&gt; &lt;li i18n="myOrder_interests"&gt;我的權益&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 样式如下：
当鼠标经过俩个&lt; li &gt;元素的中间间隔时，无论时mouseout,还是mouseleave都是会被触发的，因为已经离开了事件指向的元素！
我们可以将&lt; li &gt;元素的中间空隙用border填充，使用mouseleave事件，则可以在ul列表中停留，不会触发mouseleave事件，只有当鼠标离开了ul元素才会触发。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f128bcd7eaffc41b4a0f55ed25f378b2/" rel="bookmark">
			GitHub笔记（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、GitHub是什么？可以做什么？
GitHub是一个基于git的代码托管平台，免费用户可以使用公共仓库，进行建立、下载、提交等代码管理工作。上传代码的同时相当于贡献个人代码，是一个程序猿进行文明和精神交流的去处。简单的说，就是可以学习别人的代码，可以上传自己的代码进行版本管理，追溯自己代码的版本
二、GitHub客户端下载地址
https://desktop.github.com/
备注：下载速度十分感人，请耐心等待
三、GitHub客户端的使用
1.安装GitHub Desktop，直接登录账号密码（可以在官网先进行账号的设置，此处不做阐述），默认安装位置在C:\Users\...AppData\Local\GitHubDesktop\app-1.4.3
2.File-&gt;New repository... 新建一个仓库
3.File-&gt;Add local repository... 添加一个本地仓库
4.File-&gt;Clone repository... 下载网上的仓库，点进去会有3中选择，GitHub.com/enterprise/URL，选择URL，local path选择本地要存放仓库的路径
5.option：个人一些信息，界面显示、shell配置等
6.Exit：退出桌面程序
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baf45cb964cd6d85a6ee1813e957fb4d/" rel="bookmark">
			史上最好的团队
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在创建一个团队的时候，不仅仅要考虑相互之间的关系，最重要的是考虑成员之间的知识、资源、能力或技术上的互补性，充分发挥个人的知识和经验优势。成员的知识结构越合理，创业的成功性越大，这种互补将会有助于强化团队成员间彼此的合作。
史上最好的团队当属唐僧师徒四人的西天取经团队，取经团的领导者唐僧虽然能力不足，肩不能挑手不能扛，生就一双肉眼凡胎，遇见妖精只会帮倒忙，但终极目标十分明确，并且意志坚定，尽管多次差点就被妖怪们当延年益寿的补品煮来吃掉，仍然百折不饶，朝着西天的目标勇往直前，是一个合格的团队领导者；团队的精英骨干力量孙悟空，既有一对火眼金睛又懂得七十二般变化，一个筋斗十万八千里，上得天庭下得地府，见妖捉妖见鬼打鬼，虽然桀骜不驯性格散漫，经常开罪顶头上司，但团队领导唐僧的挟制（紧箍咒）让他渐渐步入正轨；作为取经团队中的落后分子八戒来说，他是团队中的情感调节器，他出身良好、能力中上，是团队中感情最外露的一个，经常出来插科打诨，使得枯燥的取经过程变得趣味盎然；沙僧是团队中最老实忠厚的成员，能力一般但是脚踏实力任劳任怨，那副西游的时候最沉重的担子总是压在他的肩头，并且对领导者忠心耿耿。悟空经常闹着要回花果山，八戒动不动就说要回高老庄，没有听沙僧说过要回流沙河。
设想一下，如果没有唐僧，这个团队根本就组织不起来。如果三个徒弟都是孙悟空，那谁还服谁，唐僧这个师傅还管得了吗？恐怕最终也是一哄而散，剩下唐僧个光杆司令。如果三个都是沙僧，听话是听话，那谁来降妖除魔？还不早都给妖怪吃了。猪八戒别看缺点一大堆，但大师兄临时不在的时候他的钉耙还能顶个一阵子，况且八戒是个活宝，少了他这漫漫取经路上不少了许多乐趣吗？所以说，这师徒弟四人每个人都有自己的用处，缺了谁还都不行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/213bc76ea31a9d8a3fbb969d6b945d92/" rel="bookmark">
			org.eclipse.jdt.core引入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做AST相关的工作，看了网上很多教程，发现很多都没有说怎么引入org.eclipse.jdt.core这个包，最后再在官网发现了引入方法：
Maven: &lt;!-- https://mvnrepository.com/artifact/org.eclipse.jdt/org.eclipse.jdt.core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jdt&lt;/groupId&gt; &lt;artifactId&gt;org.eclipse.jdt.core&lt;/artifactId&gt; &lt;version&gt;3.15.0&lt;/version&gt; &lt;/dependency&gt; Gradle: // https://mvnrepository.com/artifact/org.eclipse.jdt/org.eclipse.jdt.core compile group: 'org.eclipse.jdt', name: 'org.eclipse.jdt.core', version: '3.15.0' SBT: // https://mvnrepository.com/artifact/org.eclipse.jdt/org.eclipse.jdt.core libraryDependencies += "org.eclipse.jdt" % "org.eclipse.jdt.core" % "3.15.0" Ivy: &lt;!-- https://mvnrepository.com/artifact/org.eclipse.jdt/org.eclipse.jdt.core --&gt; &lt;dependency org="org.eclipse.jdt" name="org.eclipse.jdt.core" rev="3.15.0"/&gt; Grape: // https://mvnrepository.com/artifact/org.eclipse.jdt/org.eclipse.jdt.core @Grapes( @Grab(group='org.eclipse.jdt', module='org.eclipse.jdt.core', version='3.15.0') ) Leiningen: ;; https://mvnrepository.com/artifact/org.eclipse.jdt/org.eclipse.jdt.core [org.eclipse.jdt/org.eclipse.jdt.core "3.15.0"] Buildr: # https://mvnrepository.com/artifact/org.eclipse.jdt/org.eclipse.jdt.core 'org.eclipse.jdt:org.eclipse.jdt.core:jar:3.15.0' 最后我还是在eclipse中使用了maven引入的，成功解决问题。
附上官方原址：
mvnrepository Java Development Tools Core » 3.15.0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b35a68bd49338eea659f01fcec6f92f/" rel="bookmark">
			基于opencv的一种快速有效椭圆检测方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇介绍的椭圆检测方法来自以下论文，论文作者提供了测试代码。本文主要是对这个方法做出详解。
参考论文：A fast and effective ellipse detector for embedded vision applications
代码链接：fast_ellipse_detector
一、调用及参数说明 Size	szPreProcessingGaussKernelSize = Size(5,5); //高斯滤波窗体大小 double	dPreProcessingGaussSigma = 1.0；//高斯滤波 Sigma float fThPosition = 1.0；//依据相关凸性（弧的相对位置）移除某些点 float	fMaxCenterDistance = 100*0.05；// 两个中心点最大距离 int	iMinEdgeLength = 16；//单段弧最小边界尺寸 float	fMinOrientedRectSide = 3.0；//最小包含圆弧方向包围盒尺寸 float	fDistanceToEllipseContour = 1.0；//椭圆上的点到椭圆边界的最大容忍距离 float	fMinScore = 0.4；//椭圆有效的最低分数 float	fMinReliability= 0.4；//椭圆有效的最低辅助分数 int iNs = 16；//此参数决定 遍历还是抽样弧上的点 int main() { Mat1b input；//输入图像 vector&lt;Ellipse&gt; ellipseDst;//输出椭圆 CEllipseDetectorYaed yaed;//初始化椭圆检测算子 //初始化参数 yaed.SetParameters( szPreProcessingGaussKernelSize, dPreProcessingGaussSigma, fThPosition, fMaxCenterDistance, iMinEdgeLength, fMinOrientedRectSide, fDistanceToEllipseContour, fMinScore, fMinReliability, iNs ); //调用椭圆检测 yaed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b35a68bd49338eea659f01fcec6f92f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1500c42ebc2e559cf0b2bb5e6323b4c/" rel="bookmark">
			基于OpenPose的人体姿态检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 OpenPose最开始由卡内基梅隆大学提出，其主要基于先后发表的几篇文章中提出的模型中进行实现： CVPR 2016： Convolutional Pose Machine（CPM）CVPR2017 ： realtime multi-person pose estimationCVPR2017 ： Hand Keypoint Detection in Single Images using Multiview Bootstrapping 但运行计算量非常大，通常得在GPU上运行，并且帧率较低（低于5fps）,在此后也陆续出现了一些改进版改进版主要在模型上进行了一些改进或裁剪，另外移动端(如各种尬舞app) 为能够跑通OpenPose,在改网络结构的同时，对算法本身也进行了优化，减少了计算量，但与此同时准确性也有相应地降低。 二、简化版OpenPose实现代码 代码来源GitHub：human-pose-estimation-opencv其代码较为简单，模型（较小：7.8M）已经训练好在graph_opt.pb文件中,其中全部实现代码在openpose.py文件中，下面是实现代码及测试效果： # To use Inference Engine backend, specify location of plugins: # export LD_LIBRARY_PATH=/opt/intel/deeplearning_deploymenttoolkit/deployment_tools/external/mklml_lnx/lib:$LD_LIBRARY_PATH import cv2 as cv import numpy as np import argparse parser = argparse.ArgumentParser() parser.add_argument('--input', help='Path to image or video. Skip to capture frames from camera') parser.add_argument('--thr', default=0.2, type=float, help='Threshold value for pose parts heat map') parser.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1500c42ebc2e559cf0b2bb5e6323b4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2712434e1dab2ea857ef7463afcfb428/" rel="bookmark">
			U盘读写删除等操作需要管理员权限的解决方法-WIN10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		U盘读写删除等操作需要管理员权限的解决方法-WIN10 问题： 不知道啥时候开始，从U盘内进行读写删除等操作到时候开始需要管理员权限，会弹出一个如下的窗口，我们需要点击继续才能执行操作，那么如何解决呢？
解决方法： step1：右键U盘，点击属性，选择安全，点击下方的编辑按钮。
step2：点击添加
step3：在下面空白框中填写everyone，点击右侧检查名称，会出现查到的对象名：Everyone，点击确定
step4：选中Everyone，在下面的允许权限下全打勾，然后确定即可。
step5：电脑自动设置完安全信息就可以正常使用了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f3734a456da6dd6963596242b3a2985/" rel="bookmark">
			MySQL WorkBench添加表列不见了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 点击这里 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/845c1d7a3f5c0fce6e6f6d92debb50bf/" rel="bookmark">
			IGMP 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IGMP 简介 IGMP是 Internet Group Management Protocol（互联网组管理协议）的简称。它是 TCP/IP 协议族中负责 IP 组播成员管理的协议，用来在 IP 主机和与其直接相邻的组播路由器之间建立、维护组播组成员关系.
IGMP 的版本 到目前为止， IGMP 有三个版本：
IGMPv1（由 RFC 1112 定义）IGMPv2（由 RFC 2236 定义）IGMPv3（由 RFC 3376 定义） 所有版本的 IGMP都支持ASM（Any-Source Multicast，任意信源组播）模型； IGMPv3 可以直接应用于 SSM（Source-Specific Multicast，指定信源组播）模型，而IGMPv1 和** IGMPv2** 则需要在IGMP SSM Mapping 技术的支持下才能应用于 SSM 模型。
IGMPv1 工作机制 IGMPv1主要基于查询和响应机制来完成对组播组成员的管理。
当一个网段内有多台组播路由器时，由于它们都能从主机那里收到 IGMP 成员关系报告报文（Membership Report Message，此只需要其中一台路由器发送 IGMP 查询报文（Query Message）就足够了。这就需要有一个查询器（Querier）的选举机制来确定由哪台路由器作为 IGMP查询器。
对于 IGMPv1 来说，由组播路由协议（如 PIM）选举出唯一的组播信息转发者 DR（Designated Router，指定路由器）作为 IGMP 查询器。
如图所示，假设Host B与Host C想要收到发往组播组G1 的组播数据，而Host A想要收到发往
组播组G2 的组播数据，那么主机加入组播组以及IGMP查询器（Router B）维护组播组成员关系的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/845c1d7a3f5c0fce6e6f6d92debb50bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ab723242f4737504181f5f8aa95b78b/" rel="bookmark">
			JAVA 线程协同合作(等待子线程运行完了 继续线面主线程的运行)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中自带的countdownLatch 可以设置同时并发的线程数，一旦并发的线程数达到了0 countdownlatch.countdown() ，就可以继续走下面的线程 countdownlatch.await()方法等待，比如主线程必须等待子线程操作了之后 获取到子线程的数据，再继续下面的操作，此时可以用countdownlatch类。
第二种方式
private static Handler sHandler = new Handler(Looper.getMainLooper()); /** * 在主线程运行runnable * * @param waitUntilDone 直到等待完成 * @param job runnable接口 */ public static void dispatch(final boolean waitUntilDone, final Runnable job) { if (job == null) { return; } //主线程的标志 boolean alreadyInMain = Thread.currentThread() == Looper.getMainLooper().getThread(); if (alreadyInMain) { //如果是在主线程的话,直接运行 job.run(); } else { //如果不是在主线程的话,那么需要用到handler异步处理消息机制 //这个Semaphore被称为信息量,http://www.jianshu.com/p/0090341c6b80(我暂时还没有看懂) final Semaphore semaphore = new Semaphore(0); //在主线程创建handlder sHandler.post(() -&gt; { job.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ab723242f4737504181f5f8aa95b78b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7486f84f5f6854a2cb4af946747b83a9/" rel="bookmark">
			Bootstrap 组件对齐方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址 您可以使用实用工具 class .navbar-left 或 .navbar-right 向左或向右对齐导航栏中的 导航链接、表单、按钮或文本 这些组件。这两个 class 都会在指定的方向上添加 CSS 浮动。下面的实例演示了这点：
&lt;nav class="navbar navbar-default" role="navigation"&gt; &lt;div class="container-fluid"&gt; &lt;div class="navbar-header"&gt; &lt;a class="navbar-brand" href="#"&gt;菜鸟教程&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;!--向左对齐--&gt; &lt;ul class="nav navbar-nav navbar-left"&gt; &lt;li class="dropdown"&gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown"&gt; Java &lt;b class="caret"&gt;&lt;/b&gt; &lt;/a&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="#"&gt;jmeter&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;EJB&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Jasper Report&lt;/a&gt;&lt;/li&gt; &lt;li class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;分离的链接&lt;/a&gt;&lt;/li&gt; &lt;li class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;另一个分离的链接&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class="navbar-form navbar-left" role="search"&gt; &lt;button type="submit" class="btn btn-default"&gt; 向左对齐-提交按钮 &lt;/button&gt; &lt;/form&gt; &lt;p class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7486f84f5f6854a2cb4af946747b83a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29fe86d460983f37bde72f75b52d9d2f/" rel="bookmark">
			linux 输入、输出重定向的概念和用法详解（Day01）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍重定向之前先来介绍几个重要的概念：（笔记不易---- 转载请注明出处） 1.linux 的标准输入与输出 linux标准输入设备指的是键盘，标准输出设备指的是显示器，标准错误输出指的是显示器。
设备设备名文件描述符类型键盘/dev/stdin0标准输入显示器/dev/stdout1标准输出显示器/dev/stderr2标准错误输出 在解释什么是重定向之前，再来说说什么是文件描述符
2.Linux 文件描述符 文件描述符可以理解为 Linux 系统为文件分配的一个数字，范围是 0-3 ，用户也可以自定义文件描述符，但是自定文件描述符不在这里的讨论范围
一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：
标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。 3.什么是输入重定向 输入重定向：是指不使用系统提供的标准输入端口，而进行重新的指定。换言之，输入重定向就是不使用标准输入端口输入文件，而是使用指定的文件作为标准输入设备。（重定向简单理解就是使用 “&lt;”符来修改标准输入设备）
比如,默认情况下，cat命令会接受默认标准输入设备键盘的输入，并显示到控制台，但是可以通过“&lt;”符号修改标准输入设备,指定文件作为标准输入设备，那么cat命令将指定的文件作为输入设备，并将文件中的内容读取并显示到控制台。
输入重定向类型符号（语法）功能标准输入命令&lt;文件1命令把文件1的内容作为标准输入设备标识符限定输入命令&lt;&lt;标识符命令把标准输入中读入内容，直到遇到“标识符”分解符为止输入输出重定向（同时使用）命令&lt; 文件1 &gt;文件2命令把文件1的内容作为标准输入，把文件2作为标准输出。 #cat /etc/passwd 它是以键盘作为标准输入设备，并将文件内容显示到控制台
语法1: # cat &lt; /etc/passwd 而输入重定向，cat &lt; /etc/passwd ，它是将passwd文件指定为输入设备，并将内容显示到控制台。
语法2.# cat &lt;&lt; delimiter
# cat &lt; &lt;delimiter （这个字符串字符是任意的，没有任何含义）
它的作用是将这个 delimiter 字符之前的内容(document) 作为输入传递给 cat
碰到delimiter将自动结束输入,并将输入的内容显示出来;
语法3:# cat /etc/passwd &lt; a &gt; b.txt ：将文件passwdt输入重定向到a，输出重定向到b.txt文件
4.输出重定向：（通俗的讲，重定向输出就是把要输出的文件信息写入到一个文件中去，而不是将要输出的文件信息输出到控制台（显示屏）） 在linux中，默认的标准输出设备是控制台（或称为显示器）,用户输出的信息默认情况下都会显示到控制台,
比如：cat /etc/passwd ,它是使用控制台显示内容。 默认情况下，标准输出设备是控制台，所以cat命令将文件信息输出到控制台，但是，我们可以使用“&gt;”修饰符修改标准输出设备,使用指定的文件做为标准输出设备，来显示文件。输出重定向的概念就出现了。
4.1什么是输出重定向？
输出重定向就是指不使用linux默认的标准输出设备显示信息，而是指定某个文件做为标准输出设备来存储文件信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29fe86d460983f37bde72f75b52d9d2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae3905a27f896f3937f4783cbe36c1d7/" rel="bookmark">
			使用notepad&#43;&#43;批量在每行首尾添加内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 简介 在程序员开发过程中，一个不错的工具是notepad++，该工具为notepad的增强，增强了许多的功能，包括程序员喜欢的列块编辑模式，支持众多的插件，例如json格式化，支持markdown语法。
一种场景是这样的，
比如说上传的工资单中的标题栏为以上的内容，因此，在输入数据库的时候，我们需要把所有这些内容变成字符串，但一个一个操作又非常麻烦，这样如何使用notepad++快速的实现在行头和行尾添加需要的字符呢？
2 操作步骤 2.1 提取Excel中工资单标题行内容 把工资行标题行的内容转置成列的形式，如前图所示。
2.2 使用列块编辑模式为行首添加” 首先把光标放置在序号之前，然后点击编辑，选择列块编辑，也可以在把光标放置在序号之前之后，使用快捷键Alt+C，快速打开列块编辑对话框。
结果如下：
2.3 在行末添加”, 使用notepad++替换功能在每行末尾添加”,，构成所需要的字符串内容
点击确定之后，执行全部替换，效果如下：
2.4 去掉每行的换行符 由于可能有很多行，因此在工作时，可能会导致代码行数暴增，因此可以使用通配符匹配的方式删掉每行末尾的换行符，这样精简代码操作如下：
注意：换行可能是"\n"（此居多）或者"\r"或者"\r\n"
效果如下：
3 总结 使用notepad++批量操作，列块编辑是非常赞的特性，可以为程序员提升效率，减少枯燥的拷贝动作，值得积累。
4引用和文档 文档
https://download.csdn.net/download/lk142500/10728022
引用
https://blog.csdn.net/hgg923/article/details/43228729
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fed29b87f4e82b742604b6057e0cb112/" rel="bookmark">
			树莓派3b&#43;编译安装Python3.7.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 一、更新树莓派系统 sudo apt-get update sudo apt-get upgrade 二、安装python需要的依赖 sudo apt-get install build-essential libsqlite3-dev sqlite3 bzip2 libbz2-dev 三、下载Python的源代码并解压 cd mydownload wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz tar zxvf Python-3.7.0.tgz 四、配置、编译、安装 sudo mkdir /usr/local/python370 sudo ./configure --prefix=/usr/local/python370 sudo make sudo make install 五、创建符号链接
sudo ln -s /usr/local/python370/bin/python3 /usr/bin/python370 sudo ln -s /usr/local/python370/bin/python3 /usr/bin/python3.7.0 sudo ln -s /usr/local/python370/bin/pip3 /usr/bin/pip370 sudo ln -s /usr/local/python370/bin/pip3 /usr/bin/pip3.7.0 六、测试
python370 --version 转载于:https://my.oschina.net/mengyoufengyu/blog/2248239
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4189e3e8c0cdf8b3ca25b97b76e4889/" rel="bookmark">
			神经网络中的各种优化方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		神经网络中的各种优化方法 大家耳熟能详的优化方法有梯度下降法（Gradient Descent）、随机梯度下降法（Stochastic Gradient Descent）、Adam方法等等。虽然很多听过甚至用过这些方法，但是却未必能够说出他们的区别，已经什么时候改用什么样的优化算法。这篇文章将会从原理、区别和使用场景等角度详细介绍神经网络中的各种优化算法。
什么是优化算法 优化算法就是一种能够帮我们最小化或者最大化目标函数（有时候也叫损失函数）的一类算法。而目标函数往往是模型参数和数据的数学组合。例如给定数据 X X X和其对应的标签 Y Y Y，我们构建的模型是一个线性模型 f ( x ) = W x + b f(x)=Wx+b f(x)=Wx+b，有了模型后，根据输入 x x x就可以得到预测输出 f ( x ) f(x) f(x)，并且可以计算出预测值和真实值之间的差距 ( f ( x ) − Y ) 2 \left (f(x)-Y\right)^2 (f(x)−Y)2，这个就是损失函数。我们的目的是找到合适的 W , b W, b W,b时上述的损失函数的值达到最小，损失值越小，则说明我们的模型越接近于真实情况。
通过上面的描述可以知道，模型的内参（ W , b W, b W,b） 在模型中扮演着非常重要的角色，而这些内参的更新和优化就用到我们所说的优化算法，所以优化算法也层出不穷，而一个好的优化算法往往能够更加高效、更加准确的训练模型的内参。
优化算法的种类 一般的，根据优化算法在优化过程中使用的导数阶数。可以将优化算法可以分为两大类，一阶优化算法和二阶优化算法。
1、 一阶优化算法 一阶优化算法是指使用参数梯度值来最小化或者最大化损失函数的优化算法。最为广泛应用的就是梯度下降法，参数的一阶导能够清晰的告诉我们损失函数在某个特定点上是增加的还是减少的。那什么是梯度呢？简而言之，梯度就是函数输出关于输的偏导数，只不过这里的输入和输出并不是简单的数值，而是向量。梯度与导数的区别就是导数是单个变量的，而梯度是多个变量的。梯度往往采用雅克比矩阵（Jacobian Matrix）进行表达。
2、二阶优化算法 顾名思义，二阶优化算法就是采用二阶导数进行优化算法。二阶导数，有时候也被成为海森矩阵（Hessian）。因为二阶导数要求两次导数，尤其是在矩阵中进行求导，运算量会非常的大，所以二阶优化算法被用的比较少。
各种梯度下降法 1、Gradient Descent 梯度下降法是最重要的一种方法，也是很多其他优化算法的基础。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4189e3e8c0cdf8b3ca25b97b76e4889/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1936605a178a22e054fb9ea858d10e9/" rel="bookmark">
			基于vs实现的socket—udp通信实例详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、UDP协议二、vs 实现udp通信2.1 服务器端编程的步骤2.2 客户端编程的步骤2.3 udp通信图解 三、知识分解3.1 pragma comment(lib,"Ws2_32.lib")3.2 WASDATA3.3 MAKEWORD(a, b)3.4 WSAStartup(sockVersion, &amp;wsadata)3.5 sockaddr结构3.6 c_str3.7 memset3.8 recvfrom3.9 sendto 四、实战篇——代码分析4.1 服务端4.2 客户端4.3 通信4.4 发送结束标志4.5 问题error C4996 一、UDP协议 udp是一种面向无连接，不可靠的传输层协议。upd的连接过程
二、vs 实现udp通信 2.1 服务器端编程的步骤 创建套接字（socket）将套接字和IP地址、端口号绑定在一起（bind）等待客户端发起数据通信（recvfrom/recvto）关闭套接字 2.2 客户端编程的步骤 创建套接字（socket）向服务器发起通信（recvfrom/recvto）关闭套接字 2.3 udp通信图解 三、知识分解 在vs中一般使用Winsock2实现网络通信功能，所以需要引进头文件winsock2.h和库文件"ws2_32.lib"。
1. WinSock2 是连接系统和用户使用的软件之间用于交流的一个接口，这个功能就是修复软件与系统正确的通讯的作用。
2. Winsock2 SPI（Service Provider Interface）服务提供者接口建立在Windows开放系统架构WOSA（Windows Open System Architecture）之上，是Winsock系统组件提供的面向系统底层的编程接口。
Winsock系统组件向上面向用户应用程序提供一个标准的API接口；向下在Winsock组件和Winsock服务提供者（比如TCP/IP协议栈）之间提供一个标准的SPI接口。
各种服务提供者是Windows支持的DLL，挂载在Winsock2 的Ws2_32.dll模块下。
对用户应用程序使用的Winsock2 API中定义的许多内部函数来说，这些服务提供者都提供了它们的对应的运作方式(例如API函数WSAConnect有相应的SPI函数WSPConnect)。
多数情况下，一个应用程序在调用Winsock2 API函数时，Ws2_32.dll会调用相应的Winsock2 SPI函数，利用特定的服务提供者执行所请求的服务。
详细参考
Windows下的库文件目录(以便以后使用[Windows10]):
C:\Program Files (x86)\Windows Kits\8.1\Lib\winv6.3\um\x86
3.1 pragma comment(lib,“Ws2_32.lib”) 表示链接Ws2_32.lib这个库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1936605a178a22e054fb9ea858d10e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4c39cde0e7926fe694caa5c1a4e9684/" rel="bookmark">
			解决SVN Can’t open file ‘/XXX/xxx/db/txn-current-lock’错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一： 百度上有一种方法就是给db目录的其他用户赋予读写权限即：chmod -R o+rw /XXX/xxx/db
方法二： 如果上述方法解决不了的话那可能就是selinux的问题（selinux阻止不安全的修改）。因为一开始系统没有出现selinux trouble shoot的提示，还以为selinux默认没有开启。后来打开/etc/selinux/config，才发现是enforcing，解决办法：vim /etc/selinux/config 将enforcing修改为disabled
点击查看selinux详解链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/208b3c58643e73dfc14d04ba79f93572/" rel="bookmark">
			dev_set_drvdata和dev_get_drvdata函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dev_set_drvdata函数用来设置device 的私有数据，
dev_get_drvdata函数用来获取device 的私有数据。
两个函数的定义如下：
/* * These exports can't be _GPL due to .h files using this within them, and it * might break something that was previously working... */ void *dev_get_drvdata(const struct device *dev) { if (dev &amp;&amp; dev-&gt;p) return dev-&gt;p-&gt;driver_data; return NULL; } EXPORT_SYMBOL(dev_get_drvdata); int dev_set_drvdata(struct device *dev, void *data) { int error; if (!dev-&gt;p) { error = device_private_init(dev); if (error) return error; } dev-&gt;p-&gt;driver_data = data; return 0; } EXPORT_SYMBOL(dev_set_drvdata); dev_set_drvdata函数一般在初始化 dev后执行， dev_get_drvdata函数主要在于其他子系统交互的函数中执行，用来获取当前driver data。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/208b3c58643e73dfc14d04ba79f93572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e975fb1688440c3ccc8aa37866545d88/" rel="bookmark">
			解决vue项目在浏览器中打开后，#后面的链接被截取的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做微信公众号下载的时候遇到了这个问题：
微信公众号下载，做的是弹框提示，在浏览器中打开，结果在手机浏览器中打开的总是#之前的链接：
例如：http://yy2jd7.natappfree.cc/#/download,手机浏览器上打开的页面链接：http://yy2jd7.natappfree.cc/#/
在查了好长时间的资料之后，才知道有可能是浏览器缓存的问题，加上随机数，防止浏览器缓存；
链接格式如下：http://yy2jd7.natappfree.cc/?time='+new Date()+'#/download
参考资料：https://blog.csdn.net/qq449736038/article/details/80762606
https://blog.csdn.net/llorjj999/article/details/7732773
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76f1991c56d4d78ae79ec4494dcd00d2/" rel="bookmark">
			负电压
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是负电压 电压的大小是相对于选择的参考而言的，当实际电压低于比较电压时，电压值为负。另一种情况：当选择的电压参考方向和电流参考方向相反时，参考电压为实际电压的相反数。
负电压是相对而言的。首先我们要有一个参照物。举个例子：现有一电压要求为4.0V那么比4.0高的就是正电压，小的就是负电压。现在有一种电源模块可以同时输出正电压和负电压就是这样。并不是说真的能输出-*的多少电压。
负电压的产生电路图原理 在电子电路中我们常常需要使用负的电压，比如说我们在使用运放的时候常常需要给他建立一个负的电压。下面就简单的以正5V电压到负电压5V为例说一下他的电路。
通常我需要使用负电压时一般会选择使用专用的负压产生芯片，但这些芯片都比较贵比如ICL7600，LT1054等等。哦差点忘了MC34063了这个芯片使用的最多了，关于34063的负压产生电路我这里不说了在datasheet中有的。下面请看我们在单片机电子电路中常用的两种负压产生电路。
现在的单片机有很多都带有了PWM输出，我们在使用单片机的时候PWM很多时候是没有用到的用他辅助产生负压是不错的选择。
上面的电路是一个最简单的负压产生电路了。他使用的原件是最少的了我们只需要给他提供1kHZ左右的方波就可以了，相当的简单。这里需要注意这个电路的代负载能力是很弱的，同时在加上负载后电压的降落也比较大。
由于上面的原因产生了下面的这个电路：
负电压产生电路分析 电压的定义：电压（voltage），也称作电势差或电位差，是衡量单位电荷在静电场中由于电势不同所产生的能量差的物理量。其大小等于单位正电荷因受电场力作用从A点移动到B点所做的功，电压的方向规定为从高电位指向低电位的方向。
说白了就是：某个点的电压就是相对于一个参考点的电势之间的差值。V某=E某-E参。一般我们把供电电源负极当作参考点。电源电压就是Vcc=E电源正-E电源负。
想产生负电压，就让他相对于电源负极的电势更低即可。要想更低，必须有另一个电源的介入，根本原理都是利用两个电源的串联。电源2正极串联在参考电源1的负极后。电源2负极就是负电压了。
一个负电压产生电路：利用电容充电等效出一个新电源，电容串联在GND后，等效为电源2。则产生负电压。
1、电容充电
2、电容C1充满电
3、电容C1作为电源，C1高电势极串联在参考点。C1放电，从C2续流，产生负电压。
产生负电压（-5V）的方案 7660和MAX232输出能力有限，做示波器带高速运放很吃力，所以魏坤也得用4片并联的方式扩流。
第一版是7660两片并联的。
用普通的DC/DC芯片都可以产生负电压，且电压精确度同正电压一样，驱动能力也很强，可以达到300mA以上。
一般的开关电源芯片都能产生负电压，实在不行用用开关电源输出的PWM去推电荷泵，也可以产生较大的电流，成本也很低，不知纹波要求多少，电荷泵用LC滤波之后纹波相当小的。7660是电荷泵所以电流很小。
整个示波器的设计数字电源的+5V和模拟电源的+５V是分开供电的，但是数字地和模拟地应该怎么处理呢？
数字地和模拟地是一定要连在一起的，不然电路没法工作。
数字部分的地返回电流不能流过模拟部分地，两个地应该在稳定的地参考点连在一起。
负电压的意义 1、人为规定。例如电话系统里是用-48V来供电的，这样可以避免电话线被电化学腐蚀。当然了，反着接电话也是可以工作的，无非是电压参考点变动而已。
2、通讯接口需要。例如RS232接口，就必须用到负电压。-3V～-15V表示1，+3～+15V表示0。这个是当初设计通讯接口时的协议，只能遵守咯。PS:MAX232之类的接口芯片自带电荷泵，可以自己产生负电压。
3、为（非轨到轨）运放提供电源轨。老式的运放是没有轨到轨输入/输出能力的，例如OP07，输入电压范围总是比电源电压范围分别小1V，输出分别小2V。这样如果VEE用0V，那么输入端电压必须超过1V，输出电压不会低于2V。这样的话可能会不满足某些电路的设计要求。为了能在接近0V的输入/输出条件下工作，就需要给运放提供负电压，例如-5V，这样才能使运放在0V附近正常工作。不过随着轨到轨运放的普及，这种情况也越来越少见了。
4、这个比较有中国特色，自毁电路。一般来说芯片内部的保护电路对于负电压是不设防的，所以只要有电流稍大，电压不用很高的负电压加到芯片上，就能成功摧毁芯片。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae73c1eeab4aa67f278b263df84c107f/" rel="bookmark">
			手机里实现图片文字识别的实用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		突然接到老板给的一个任务——把一篇文章排版出来，你会怎样做？
是一个字一个字手动手动输入呢？还是语音识别呢？
当然，这两种方法都可行，但是不够简单方便。手动输入太慢，语音识别又有点麻烦，如果普通话不好，识别很可能会出错。
那什么方法，实现图片文字识别最简单，最方便，还很精确呢？
今天就来和大家分享一下，手机里的逆天黑科技，实现图片文字识别，只需5秒钟！
方法一：
打开QQ，左上角【扫一扫】——手机相册选择图片——确定
方法二：
1.打开微信，菜单栏选择【发现】——【小程序】——搜索迅捷【文字识别】
2.进入迅捷文字识别小程序主页，依次点击【照片/拍照】——【选择图片】——【原图，完成】
3.等待5秒钟识别完成，我们可以对识别出来的内容进行，英汉翻译，复制到备忘录，发送给好友等操作！
方法三：
其实迅捷文字识别，不仅有小程序版还有APP版。实用起来也和方便！
打开进入APP，点击下方菜单栏【图片识别】——【立即使用】——选择图片【完成】等待识别完成。 2.识别完成以后，你可以对识别出的内容进行复制，翻译，校对等操作
以上就是今天分享的图片文字识别的方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b21a87bf50b76ada8e9bb938cf6b0b1f/" rel="bookmark">
			面试常问到：如何优化数据库？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据库访问优化的五个法则
在实际开发，我们主要是需要对SQL语句进行优化，我们需要快速定位能性的瓶颈点，也就是说快速找到我们SQL主要的开销在哪里？根据木桶原理可以知道，最慢的设备往往是性能瓶颈。例如：互联网运用中的带宽，本地数据复制时的硬盘的访问速度。
根据当前计算机硬件的基本性能指标及其在数据库中主要操作内容，可以整理出如下五条性能基本优化法则：
（1）减少数据访问（减少磁盘访问）
（2）返回更少数据（减少网络传输或磁盘访问）
（3）减少交互次数（减少网络传输）
（4）减少服务器CPU开销（减少CPU及内存开销）
（5） 利用更多资源（增加资源）
由于每一层优化法则都是解决其对应硬件的性能问题，所以带来的性能提升比例也不一样。传统数据库系统设计是也是尽可能对低速设备提供优化方法，因此针对低速设备问题的可优化手段也更多，优化成本也更低。我们任何一个SQL的性能优化都应该按这个规则由上到下来诊断问题并提出解决方案，而不应该首先想到的是增加资源解决问题。
以下是每个优化法则层级对应优化效果及成本经验参考：
优化法则
性能提升效果
优化成本
减少数据访问
1~1000
低
返回更少数据
1~100
低
减少交互次数
1~20
低
减少服务器CPU开销
1~5
低
利用更多资源
@~10
高
二、数据库访问优化法则详解
2.1、减少数据访问
（1）正确创建索引
索引有哪些种类？
常见的索引有B-TREE索引、位图索引、全文索引，位图索引一般用于数据仓库应用，全文索引由于使用较少，这里不深入介绍。B-TREE索引包括很多扩展类型，如组合索引、反向索引、函数索引等等，以下是B-TREE索引的简单介绍：
B-TREE索引也称为平衡树索引(Balance Tree)，它是一种按字段排好序的树形目录结构，主要用于提升查询性能和唯一约束支持。B-TREE索引的内容包括根节点、分支节点、叶子节点。
我们一般在什么字段上建索引？
这是一个非常复杂的话题，需要对业务及数据充分分析后再能得出结果。主键及外键通常都要有索引，其它需要建索引的字段应满足以下条件：
1、字段出现在查询条件中，并且查询条件可以使用索引；
2、语句执行频率高，一天会有几千次以上；
3、通过字段条件可筛选的记录集很小，那数据筛选比例是多少才适合？
这个没有固定值，需要根据表数据量来评估，以下是经验公式，可用于快速评估：
小表(记录数小于10000行的表)：筛选比例&lt;10%；
大表：(筛选返回记录数)&lt;(表总记录数*单条记录长度)/10000/16
单条记录长度≈字段平均内容长度之和+字段数*2
索引对DML(INSERT,UPDATE,DELETE)附加的开销有多少？
这个没有固定的比例，与每个表记录的大小及索引字段大小密切相关，以下是一个普通表测试数据，仅供参考：
索引对于Insert性能降低56%
索引对于Update性能降低47%
索引对于Delete性能降低29%
因此对于写IO压力比较大的系统，表的索引需要仔细评估必要性，另外索引也会占用一定的存储空间。
（2）只通过索引访问数据
有些时候，我们只是访问表中的几个字段，并且字段内容较少，我们可以为这几个字段单独建立一个组合索引，这样就可以直接只通过访问索引就能得到数据，一般索引占用的磁盘空间比表小很多，所以这种方式可以大大减少磁盘IO开销。
（3）优化SQL执行计划
SQL执行计划是关系型数据库最核心的技术之一，它表示SQL执行时的数据访问算法。由于业务需求越来越复杂，表数据量也越来越大，程序员越来越懒惰，SQL也需要支持非常复杂的业务逻辑，但SQL的性能还需要提高，因此，优秀的关系型数据库除了需要支持复杂的SQL语法及更多函数外，还需要有一套优秀的算法库来提高SQL性能。
2.2、返回更少的数据
减少数据的返回也是优化的重要手段，主要有两种方法 分页 和 只返回需要的字段。
（1）分页
分页总共包括三种分页方式：客户端分页、服务端分页、数据库分页。
客服端分页：将数据从应用服务器全部下载到本地应用程序或浏览器，在应用程序或浏览器内部通过本地代码进行分页处理。
优点：编码简单，减少客户端与应用服务器网络交互次数
缺点：首次交互时间长，占用客户端内存
适应场景：客户端与应用服务器网络延时较大，但要求后续操作流畅，如手机GPRS，超远程访问（跨国）等等。
服务端分页：将数据从数据库服务器全部下载到应用服务器，在应用服务器内部再进行数据筛选。
优点：编码简单，只需要一次SQL交互，总数据与分页数据差不多时性能较好。
缺点：总数据量较多时性能较差。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b21a87bf50b76ada8e9bb938cf6b0b1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b711a7b854bda16a2339fc9bb887736/" rel="bookmark">
			地区选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目中需要使用地区选择，于是做了一个选择三级地区结构的示例，希望对大家有所帮助。
允许用户选择到省、市、区（地区选择下载地址）
效果如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7668b5dd9d33a9b92d35b39fb11c291a/" rel="bookmark">
			Flink及Storm、Spark主流流框架比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://www.sohu.com/a/142553677_804130
引言
随着大数据时代的来临，大数据产品层出不穷。我们最近也对一款业内非常火的大数据产品 - Apache Flink做了调研，今天与大家分享一下。Apache Flink(以下简称flink) 是一个旨在提供‘一站式’ 的分布式开源数据处理框架。是不是听起来很像spark？没错，两者都希望提供一个统一功能的计算平台给用户。虽然目标非常类似，但是flink在实现上和spark存在着很大的区别，flink是一个面向流的处理框架，输入在flink中是无界的，流数据是flink中的头等公民。说到这里，大家一定觉得flink和storm有几分相似，确实是这样。那么有spark和storm这样成熟的计算框架存在，为什么flink还能占有一席之地呢？今天我们就从流处理的角度将flink和这两个框架进行一些分析和比较。
1 本文的流框架基于的实现方式
本文涉及的流框架基于的实现方式分为两大类。第一类是Native Streaming，这类引擎中所有的data在到来的时候就会被立即处理，一条接着一条（HINT： 狭隘的来说是一条接着一条，但流引擎有时会为提高性能缓存一小部分data然后一次性处理），其中的代表就是storm和flink。第二种则是基于Micro-batch，数据流被切分为一个一个小的批次， 然后再逐个被引擎处理。这些batch一般是以时间为单位进行切分，单位一般是‘秒‘，其中的典型代表则是spark了，不论是老的spark DStream还是2.0以后推出的spark structured streaming都是这样的处理机制；另外一个基于Micro-batch实现的就是storm trident，它是对storm的更高层的抽象，因为以batch为单位，所以storm trident的一些处理变的简单且高效。
2 流框架比较的关键指标
从流处理的角度将flink与spark和storm这两个框架进行比较，会主要关注以下几点，后续的对比也主要基于这几点展开：
• 功能性（Functionality）- 是否能很好解决流处理功能上的痛点 , 比如event time和out of order data。
• 容错性（Fault Tolerance） - 在failure之后能否恢复到故障之前的状态，并输出一致的结果；此外容错的代价也是越低越好，因为其直接影响性能。 • 吞吐量(throughputs)&amp; 延时(latency) - 性能相关的指标，高吞吐和低延迟某种意义上是不可兼得的，但好的流引擎应能兼顾高吞吐&amp;低延时。
功能性（Functionality）
01 Event time&amp;Window Operation
1.Event time• event time - 指数据或者事件真正发生时间 , 比如用户点击网页时产生一条点击事件的数据，点击时间就是这条数据固有的event time。 • processing time - 指计算框架处理这条数据的时间。 （具体关于时间的定义可以参看flink文档 http://t.cn/RaTnsdy。）
spark DStream和storm 1.0以前版本往往都折中地使用processing time来近似地实现event time相关的业务。显然，使用processing time模拟event time必然会产生一些误差， 特别是在产生数据堆积的时候，误差则更明显，甚至导致计算结果不可用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7668b5dd9d33a9b92d35b39fb11c291a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59f4907b191996bbab44ce91d601fb87/" rel="bookmark">
			java 下载apk并安装-代码实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public class MainActivity extends Activity { private File apkFile; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } public void downloadAPK(View v) { //1). 主线程, 显示提示视图: ProgressDialog final ProgressDialog dialog = new ProgressDialog(this); dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL); dialog.show(); //准备用于保存APK文件的File对象 : /storage/sdcard/Android/package_name/files/xxx.apk apkFile = new File(getExternalFilesDir(null), "update.apk"); //2). 启动分线程, 请求下载APK文件, 下载过程中显示下载进度 new Thread(new Runnable() { @Override public void run() { try { //1. 得到连接对象 String path = "http://192.168.10.165:8080/Web_Server/L04_DataStorage.apk"; URL url = new URL(path); HttpURLConnection connection = (HttpURLConnection) url.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59f4907b191996bbab44ce91d601fb87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b5035f072caccf970a6f0788911eb83/" rel="bookmark">
			jupyter notebook 添加 conda 环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 激活conda环境 source activate cym
2. 安装ipykernel conda install ipykernel
3. 将环境写入notebook的kernel中 python -m ipykernel install --user --name 环境名 --display-name “python 环境名”
python -m ipykernel install --user --name cym --display-name “python cym”
4. 打开notebook jupyter notebook
PS: 有时候第1步，安装完ipykernel后，打开jupyter notebook,就自动检测到本地的conda环境的. 所以可以安装完ipykernel后，先打开jupyter notebook看看有没有自动检测到了自己的conda环境：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49f5ef6e6a7485dd6a99a754fb84dcd0/" rel="bookmark">
			仿支付宝实现密码框输入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目中需要使用在线交易，于是仿照支付宝输入密码框做了一个示例，希望对大家有所帮助。
效果如图：
仿支付宝实现密码框输入
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fdbd2eeddca2eea62108ab3fab13686/" rel="bookmark">
			HTML5录制音频文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://github.com/wangpengfei15975/recorder.js
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00ff50cfa7c8bd0b6c33281a16fdc86a/" rel="bookmark">
			如何查看到chrome缓存真实的内容？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、缓存的路径：
C:\Users\你的用户名\AppData\Local\Google\Chrome\User Data\Default\Cache。然而当你打开它时，会发觉文件夹里都是些不知所云的文件。然而我是想看到缓存文件本尊，比如图片，视频，js。
像这样：
2、可以在浏览器中输入chrome://cache，可以查看缓存（我的谷歌不给力没法查看），据说根据链接点出来的东西也是二进制码的没法看。
3、非得找个好东西，帮我们剖析缓存，让缓存现出原形才行！
就是这个ChromeCacheView. 我下载的中文版，是这个链接：ChromeCacheView。
看，下面就是我期待看到的结果，分析后的结果。缓存内容已向你敞开，尽管拿吧！
另外：还有个专门取缓存中视频的小工具，Video cache View，IE/FF/Chrome通杀，听说也很好用。
分析网页性能的时候，还可以用Chrome Cache View查看浏览器缓存的各项设置。
参考：
https://blog.csdn.net/fengyinchao/article/details/50518834
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbe71d8a3388ce5c4ef260c6b6d9063d/" rel="bookmark">
			docker设置了端口映射，不能访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#docker ps 查看， 所有端口都 做了映射，
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 764b158ba491 open-falcon-plus-02:v-daiyi-01 "/bin/bash" 2 days ago Up 3 hours 0.0.0.0:4444-&gt;4444/tcp, 0.0.0.0:6030-6031-&gt;6030-6031/tcp, 0.0.0.0:6070-6071-&gt;6070-6071/tcp, 0.0.0.0:6080-6081-&gt;6080-6081/tcp, 0.0.0.0:8080-8081-&gt;8080-8081/tcp, 0.0.0.0:8433-&gt;8433/tcp, 0.0.0.0:9912-&gt;9912/tcp, 0.0.0.0:14444-&gt;14444/tcp, 0.0.0.0:16060-&gt;16060/tcp, 0.0.0.0:18433-&gt;18433/tcp, 8082/tcp open-falcon-plus-daiyi-01 #但是查看日志
tail -40 /home/work/open-falcon/agent/logs/agent.log
test@ubuntu-10:/tmp/bak$ tail -40 /home/work/open-falcon/agent/logs/agent.log 2018/10/14 20:27:09 transfer.go:48: call Transfer.Update fail: &amp;{{2 1} &lt;nil&gt; 10.0.10.103:8433 1s} dial tcp 10.0.10.103:8433: getsockopt: connection refused 2018/10/14 20:27:09 var.go:95: &lt;= &lt;Total=0, Invalid:0, Latency=0ms, Message:&gt; 2018/10/14 20:27:09 rpc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbe71d8a3388ce5c4ef260c6b6d9063d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/771ff021f687fe0849f78e24b223c397/" rel="bookmark">
			Spyder的python2.7导入gdal/ogr报错：gdal ImportError: DLL load failed: 找不到指定的程序。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请注明作者（独孤尚良dugushangliang）出处：https://blog.csdn.net/dugushangliang/article/details/83059285
承接上文：https://blog.csdn.net/dugushangliang/article/details/83055390
可惜的是，我cmd可以用gdal，但Spyder不可。
_mod = imp.load_module('_gdal', fp, pathname, description)
gdal ImportError: DLL load failed: 找不到指定的程序。
我无奈之下，找了许多的网页，一再尝试也没有解决。
多亏了我前行的好友、同志、战友、队长，丞相仁兄，睿智的他指导我解决了这个问题。
https://me.csdn.net/weixin_40450867
他推荐了：https://blog.csdn.net/nima1994/article/details/79207805/
于是我在网址 https://www.lfd.uci.edu/~gohlke/pythonlibs/#gdal 下载对应python版本的whl文件后，打开cmd，在命令行中执行安装。
卸载了一个高版本，装了个低版本，至少我可以用了。Spyder中导入gdal和ogr没问题了。
独孤尚良dugushangliang——著
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fe00ef58ff4e487c4b8979232c65260/" rel="bookmark">
			10.15
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库: 数据库是一些关联表的集合。.
数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。
列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。
行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。
冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。
主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。
外键：外键用于关联两个表。
复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。
索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。
参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。
转载于:https://www.cnblogs.com/zzy7372/p/9791081.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1bd2a453d9d2fe597aba925acf4c1fa/" rel="bookmark">
			某保险公司后台验证身份证真伪(亲测有效)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		身份证真伪 package pasexmlutil; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.GregorianCalendar; import java.util.Hashtable; import java.util.regex.Matcher; import java.util.regex.Pattern; public class 身份证真伪 { public static String IDCardValidate(String IDStr) throws ParseException { IDStr = IDStr.toLowerCase(); String errorInfo = ""; String[] ValCodeArr = { "1", "0", "x", "9", "8", "7", "6", "5", "4", "3", "2" }; String[] Wi = { "7", "9", "10", "5", "8", "4", "2", "1", "6", "3", "7", "9", "10", "5", "8", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1bd2a453d9d2fe597aba925acf4c1fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d82e697e0a74fa1849834c4d9fe96b6b/" rel="bookmark">
			解决新版Pycharm无法显示动态图片的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、打开File，选择Settings
2、选择Tools，点击Python Scientific
3、默认是勾选的，去掉勾选即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c05b79848d9307e3e8742cbca01e421c/" rel="bookmark">
			第十讲：贝叶斯学习与EM算法（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
贝叶斯学习
1.1 MLE
1.2 MAP
1.3 贝叶斯估计
1 贝叶斯学习
本讲我们将为大家介绍贝叶斯学习的内容，着重分析最大似然估计以及贝叶斯估计这两种方法在参数估计问题上的差异。虽然这两种方法得到的结果通常是很接近的，但是其本质却有很大的差别。
最大似然估计将待估计的参数看做是确定性的量，只是其值我们暂时还不知道；而贝叶斯估计则将待估计的参数看成是符合某种先验概率分布的随机变量。对样本进行观测的过程，就是把先验概率密度转化为后验概率密度，这样就利用样本的信息修正了对参数的初始估计值。这个过程也可以看成是贝叶斯学习的过程。
1.1 MLE
先来回顾一下最大似然估计（maximum likelihood estimation, MLE）的内容：
用途：估计模型参数
✓ 似然函数取最大时的参数值作为估计值
估计过程如下：
1）假设有一批数据X，且x均服从某种参数为的分布：
2）因为x服从独立同分布，参数向量的MLE就是使达到最大值的那个参数向量：
3）取对数：
这样描述可能有些抽象，下面来举几个例子，加深对MLE的理解。假设我们的x服从接下来的各个分布，看一看MLE是如何进行参数估计的：
举例：贝努利分布
以抛硬币为例，正面朝上概率为p，反面为1-p。
参数估计：
求导：
假设抛一枚硬币n次，其中正面朝上的次数用#head表示，那么问你正面朝上的概率为多少呢？相信很多人都会计算：#head/n。
那么从上面的推导中也可以看到正面朝上的概率p通过MLE方法得到的值与我们日常中估计的方法一致。
举例：多项式分布
以抛骰子为例
则有：
取对数，求导：
可以看到得出的参数的计算方式依旧与我们日常中的思路一致（假设掷一枚骰子n次，点数为1朝上的概率为在1朝上的次数除以总次数n）。
举例：高斯分布
假设有一批数据D，且x服从均值为，方差为σ^2的高斯分布。数据D是如下图x轴坐标所示，那么哪一个模型比较好的刻画数据D的分布呢？
很显然，中间的红色的曲线比较能够好的刻画D的分布，下面我们从MLE的角度分析一下。
同样需要取对数，求导：
得到的方差为所有样本的均值，对应于上图，即高斯分布的中轴线的位置，差不多红色曲线中轴线的位置与数据均值的位置最为相近。当然，此刻我们得到的参数只是对于真实值的一个估计，其对于真实值的接近程度是受训练样本数量限制的。如果训练样本数量越多，那么对于参数的估计值也就越接近与真实值。
1.2 MAP
说完MLE，就不得不说说另外一种估计方法----最大后验估计（Maximum a posteriori estimation，MAP）。
其中为参数的先验概率。即上述贝叶斯过程可以这样描述：
所以，上文说述的MLE可以说是当先验概率为均匀分布时的MAP。
举例：单变量高斯分布的均值
简单起见，我们只考虑只有均值μ未知的情况，且参数μ也服从高斯分布（均值、方差已知）。
采用MAP：
求导：
可以看到求得的μ为MLE得到的μ以及的加权和，且权值之和为1。这种组合称为凸组合，当n很大的时候，即训练样本充足，μ的取值与接近，这说明此时采用极大似然估计比较可靠；反之，当n很小时，参数原始的分布更可靠一些。譬如对于抛硬币来说，我抛了一枚硬币两次，结果两次有头像的一面都朝上，然后兴冲冲的跑去告诉老师结论，有头像的一面朝上的概率为1。老师说，不对，一般情况下，有头像的一面朝上的概率为0.5，你在多抛几次试试。从这个过程中，我们看到老师所拥有的先验信息（p=0.5）在试验次数较少时，应该占主要部分，当试验次数比较多时，根据大数定律，此时通过MLE得到的概率估计（#head/n）则占主要部分，（就好比说，我试验了那么多次，总该在样本中分布中有所体现吧），这样得出的概率估计才比较合理。
举例：回归模型
其中服从均值为0，方差为1的高斯分布，则p(y)服从均值为，方差为1的高斯分布，且参数w也服从一个高斯分布。
取对数，求导：
可以看到整个优化过程，从贝叶斯的角度来看是一种贝叶斯最大后验估计，正则化项变成了一种先验信息。
1.3 贝叶斯估计
在贝叶斯学习方法中， 我们把参数向量本身看成是一个随机变量，已有的训练样本使我们能够对于的初始的密度估计转化为后验概率密度。
◇ 先验信息：看到样本前关于参数的信息
◇ 样本似然：当分布的参数确定下来后，看到这些样本的可能性
用概率图模型表示：
已知一组训练数据X，这些样本都是从固定但未知的概率密度函数中独立抽取的，要求根据这些样本估计，这就是贝叶斯学习的核心问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c05b79848d9307e3e8742cbca01e421c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adbbd79fd9e588ab8d0d974da0cca642/" rel="bookmark">
			Spring获取代理对象的真实实例遇到的一个坑（多重代理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 最近在做一个项目，项目中需要使用反射来获取实例方法上的注解，但是却获取不到真实实例上方法。后来发现因为对象是从Spring容器中获取的，为代理对象，所以拿不到真实实例，于是在网上参考到别人写的代码。
问题初解决 参考别人如下的工具代码，问题得到了解决，成功拿到了实例对象。
package com.autumn.utils.spring; import java.lang.reflect.Field; import org.springframework.aop.framework.AdvisedSupport; import org.springframework.aop.framework.AopProxy; import org.springframework.aop.support.AopUtils; /** * 代理对象获取工具 * @Title: Snippet.java * @Package com.autumn.base.utils * @Description: TODO * @author Autumn、 * @date 2018年10月7日 */ public class AopTargetUtils { /** * 获取 目标对象 * @param proxy 代理对象 * @return 目标对象 * @throws Exception */ public static Object getTarget(Object proxy) throws Exception { if (!AopUtils.isAopProxy(proxy)) { return proxy; } if (AopUtils.isJdkDynamicProxy(proxy)) { return getJdkDynamicProxyTargetObject(proxy); } else { return getCglibProxyTargetObject(proxy); } } private static Object getCglibProxyTargetObject(Object proxy) throws Exception { Field h = proxy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adbbd79fd9e588ab8d0d974da0cca642/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a87267198f36fb7135b81c06011d164f/" rel="bookmark">
			数据结构中的抽象数据类型（ADT）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先了解什么是数据类型？
数据类型：是一组性质相同的值的集合以及定义在此集合上的一些操作的总称。
解释：数据类型是按值的不同进行划分的。在高级语言中，每个变量、常量及表达式都有各自的取值范围，类型就用来说明变量或表达式的取值范围和所能进行的操作。
在C语言中，按照取值不同，数据类型可分为两类：
①、原子类型：是不可再分解的基本类型，包括整型、实型、字符型等。
②、结构类型：由若干的类型组合而成，是可以再分解的。例如：整型数组是由若干整型数据组合而成的。
比如：在C语言中，声明变量int a,b,这就意味着在给变量a、b赋值时不能超出int的取值范围，变量a和b的运算只能是int类型所允许的运算。
不管什么计算机或计算机语言都会面临着整型运算、实数运算、字符运算等操作，我们可以考虑把他们抽象出来。那么什么是抽象呢？
2、抽象是指抽取出事物具有普遍性的本质。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了复杂的细节，只保留了实现目标所必须的信息。
3、抽象数据类型（Abstract Data Type，ADT）是指一个数据模型以及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。
本文转自https://jingyan.baidu.com/article/22a299b5ca07a49e19376a2a.html，如有错误，欢迎指正，如有冒犯，多有得罪！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dc3a904b98522d862297f7254c2764f/" rel="bookmark">
			Java实现窗口退出确认框，确认框取消按钮问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java学习GUI时难免会遇到点击框架退出时需要弹出确认提示框的需求，废话不多说，直接上代码,下面是主程序，MenuFrame是继承JFame的类
public class Test_19 { public static void main(String[] args) { EventQueue.invokeLater(() -&gt; { MenuFrame frame = new MenuFrame(); //不执行任何操作;要求程序在已注册的 WindowListener 对象的 windowClosing 方法中处理该操作 frame.setDefaultCloseOperation(DO_NOTHING_ON_CLOSE); frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { int result = JOptionPane.showConfirmDialog(null, "确认退出?", "确认", JOptionPane.OK_CANCEL_OPTION, JOptionPane.INFORMATION_MESSAGE); if(result == JOptionPane.OK_OPTION){ System.exit(0); } } }); frame.setTitle("第二次作业"); frame.setVisible(true); }); } } 代码是挺短的，逻辑也很简单，首先为frame添加了一个监听窗口事件的方法addWindowListener，然后使用了匿名内部类的方法，,将WindowAdapter的对象传给这个方法，然后在匿名类中重写了windowClosing的方法，接着在方法里面显示了确认的对话框，对确认按钮进行监听，并实现退出。
上面代码亲测有效，不过有些坑我觉得还是得提出来，有些人可能会碰到某些问题，能够弹出确认框，但点击取消按钮后还是退出了程序，其实程序并没有结束，只是被隐藏了起来，如何解决呢？ 网上很多做法是直接删去下面这行代码： frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 这句代码是默认会结束程序，但我尝试后并没有解决问题，后来看来某百度知道才终于解决了问题 JFrame的关闭不像Frame，点关闭按钮自己会关闭，但是那样做不好.可以用setDefaultCloseOperation(int operation);其中operation有以下几种:
DO_NOTHING_ON_CLOSE(在 WindowConstants 中定义):不执行任何操作;要求程序在已注册的 WindowListener 对象的 windowClosing 方法中处理该操作。
HIDE_ON_CLOSE(在 WindowConstants 中定义):调用任意已注册的 WindowListener 对象后自动隐藏该窗体。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dc3a904b98522d862297f7254c2764f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/498/">«</a>
	<span class="pagination__item pagination__item--current">499/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/500/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>