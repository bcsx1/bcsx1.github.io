<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc549a0f2fa71b9e8f3ce7829aa493e4/" rel="bookmark">
			iframe嵌入本地视频或者http链接视频禁止自动播放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本地视频禁止自动播放
&lt;iframe :src="item.url" sandbox="" frameborder="0" allowfullscreen="true" style="width: 100%; height: 100%;"&gt;&lt;/iframe&gt; http链接视频禁止自动播放
在视频链接后加上&amp;autoplay=0即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2205380a410420830bd9d6d0764462d1/" rel="bookmark">
			YOLOv7保姆级教程（个人踩坑无数）----训练自己的数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言：
二、YOLOv7代码下载
三、环境配置
四、测试结果
五、制作自己的数据集
六、训练自己的数据集
一、前言： 上一篇已经详细讲解了如何安装深度学习所需要的环境，这一篇则详细讲解如何配置YOLOv7，在本地电脑或者服务器都可，然后利用自己的数据集进行训练、推理、检测等。
二、YOLOv7代码下载 YOLOv7是原YOLOv4团队打造，在精度与速度之间取得较好的平衡，并且是现在较为优秀的目标检测模型
论文地址：https://arxiv.org/abs/2207.02696
论文代码下载地址：mirrors / WongKinYiu / yolov7 · GitCode
这块直接下载zip安装包打开就可以了。
三、环境配置 如果是windows系统的话，打开Anaconda的终端。如果是远程服务器的话，直接创建一个就可以了。剩下的windows和服务器都是一个操作了。
如下：输入 conda create -n yolov7(代表环境名称) python=3.8 （使用Python的版本），然后创建就可以了
环境安装完成后，conda activate yolov7进入刚才创建的环境(这块我设置的为yolov7_1,只是一个名称，无伤大雅)
然后cd切换至刚才下载解压后的yolov7-main文件夹中
接下来安装requirements.txt文件就可以了，后面加这个清华的镜像源会快点。
pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple 这块，我个人的torch与trochvison是直接指定的，你们按照官方来的就可以。(这块库里也写了torch版本不能等于1.12.0，torchvision不能等于0.13.0，所以一定要注意。)
接下来有一个很重要的点一定要强调！！！
（1）numpy库如果安装最新的1.24.1，会发生module numpy has no attribute int 错误，这个错误我找了很久, 这个是因为numpy版本的原因，1.24以上的版本没有int了，改为inf了，换成1.23的版本就好了，或者把报错出的int改成inf就可以了,所以requirements.txt中的numpy库建议直接替换成numpy==1.23.0，这个就没有问题了。
等安装输入pip list 可以查看一下安装的对不对
这块其实就能看到，其实torch和torchvision都是cpu版本的，而不是gpu版本的， 需要在这个网站上找寻适合自己cuda版本的torch口令然后下载
pytorch下载地址：Previous PyTorch Versions | PyTorch
例如我的是11.3的cuda版本复制这条指令
pip install torch==1.11.0+cu113 torchvision==0.12.0+cu113 torchaudio==0.11.0 --extra-index-url https://download.pytorch.org/whl/cu113 等安装完毕后 就可以看到后面多了+cu113，gpu的训练环境就基本配置结束了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2205380a410420830bd9d6d0764462d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b657e41cb3742910e2cac2ad63782e67/" rel="bookmark">
			python 数据、曲线平滑处理——基于Numpy.convolve实现滑动平均滤波——详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 基于Numpy.convolve实现滑动平均滤波1.1 滑动平均概念1.2 滑动平均的数学原理1.3 语法1.4 滑动平均滤波示例 2 曲线平滑处理——Savitzky-Golay 滤波器——详解3 基于Numpy.convolve实现滑动平均滤波——详解 1 基于Numpy.convolve实现滑动平均滤波 1.1 滑动平均概念 滑动平均滤波法 （又称：递推平均滤波法），它把连续取N个采样值看成一个队列 ，队列的长度固定为N ，每次采样到一个新数据放入队尾，并扔掉原来队首的一次数据(先进先出原则) 。把队列中的N个数据进行算术平均运算，就可获得新的滤波结果。
N值的选取：流量，N=12；压力：N=4；液面，N=4 ~ 12；温度，N=1~4
滑动平均的优缺点：
优点： 对周期性干扰有良好的抑制作用，平滑度高，适用于高频振荡的系统。
缺点： 灵敏度低，对偶然出现的脉冲性干扰的抑制作用较差，不易消除由于脉冲干扰所引起的采样值偏差，不适用于脉冲干扰比较严重的场合，比较浪费RAM 。
1.2 滑动平均的数学原理 滑动平均滤波法计算类似一维卷积的工作原理，滑动平均的N就对应一维卷积核大小（长度）。 区别在于：
（1）步长会有些区别，滑动平均滤波法滑动步长为1，而一维卷积步长可以自定义；
（2）一维卷积的核参数是需要更新迭代的，而滑动平均滤波法核参数都是1。
我们应该怎么利用这个相似性呢？其实也很简单，只需要把一维卷积核大小（长度）和N相等，步长设置为1，核参数都初始为1就可以了。由于一维卷积计算速度快，因此我们可以使用一维卷积来快速高效地实现这个功能。
滑动平均值是卷积数学运算的一个例子。对于滑动平均值，沿着输入滑动窗口并计算窗口内容的平均值。对于离散的1D信号，卷积是相同的，除了代替计算任意线性组合的平均值，即将每个元素乘以相应的系数并将结果相加。那些系数，一个用于窗口中的每个位置，有时称为卷积核。现在，N值的算术平均值是( x1 + x2 + . . . + xN ) / N ，所以相应的内核是( 1/N , 1/N , . . . , 1 / N ) ，这正是我们通过使用得到的np.ones((N,))/N。
1.3 语法 通过Numpy库中的convolve()函数可以实现这些功能。
def np_move_avg(a,n,mode="same"): return(np.convolve(a, np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b657e41cb3742910e2cac2ad63782e67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05fa24ac93faa724114037a95daa224c/" rel="bookmark">
			关于MobaXterm的tab键无法补齐和回车键无法使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		针对于以下情况
修改：
成功：
注：每打开一个界面都要重新设置 永久设置来了！ 这个文件用TXT方式打开
找到并添加这三行！
然后再打开软件就解决啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6e163897462a8b49f26d53f9885cdc5/" rel="bookmark">
			超图RTSP视频投放示例步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载并配置ffmpeg 环境变量设置Path，追加ffmpeg的路径
二、下载 rtsp-simple-server 下载地址 ：GitHub - aler9/rtsp-simple-server: ready-to-use RTSP / RTMP / LL-HLS / WebRTC server and proxy that allows to read, publish and proxy video and audio streams. Also known as MediaMTX
三、StreameDian 服务 Streamedian-WS-RTSP-Proxy-Server-3.1
参考地址：RTSP数据的无插件播放与超图三维iClient3D的视频投射_web 三维视频投射_右手向北的博客-CSDN博客
四、视频流启动
(1)启动tsp-simple-server (2)CMD 方式 运行 FFmpeg ，输入
ffmpeg -stream_loop -1 -re -i D:\01.mp4 -rtsp_transport tcp -vcodec h264 -f rtsp rtsp://127.0.0.1:8556/test
(3)启动 Streamedian-WS-RTSP-Proxy-Server-3.1
五、下载 StreameDian 示例 HTML5 RTSP video player
六、替换 超图示例 代码部分
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5295ebadd542242a6acea680ea7b3975/" rel="bookmark">
			MyBatis-Plus 超详细笔记｜配置使用｜多种查询｜常用注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mybatis-Plus可以节省大量时间，所有的CRUD代码都可以自动化完成。
MyBatis-Plus是一个MyBatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。其在 MyBatis 的基础上提供了很多方便的 CRUD 操作、分页查询、逻辑删除、自动填充等功能。
1 使用流程 添加MyBatis-Plus的依赖 在Maven项目中，需要在pom.xml中添加以下依赖：
&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt; &lt;version&gt;最新版本号&lt;/version&gt; &lt;/dependency&gt; 编写配置文件 当我们使用springboot时，可以直接使用properties文件来直接配置，而不再是xml文档。
编写application.properties ：
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:xxxx/database?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8 spring.datasource.username=xxx spring.datasource.password=xxx server.port=8080 配置MyBatis-Plus的Mapper扫描 在Spring Boot项目中，可以通过配置类来配置MyBatis-Plus的Mapper扫描：
@Configuration @MapperScan("com.example.mapper") public class MybatisPlusConfig { } 其中，com.example.mapper是Mapper接口所在的包名。
创建实体类 创建实体类，用于映射数据库表。例如：
@Data @TableName("user") public class User { @TableId(type = IdType.AUTO) private Long id; private String name; private Integer age; private String email; } 在实体类上可以使用@TableName注解指定对应的数据库表名，使用@TableId注解指定主键，type属性指定主键生成策略。
创建Mapper接口 创建Mapper接口，用于执行CRUD操作。例如：
@Mapper public interface UserMapper extends BaseMapper&lt;User&gt; { } 在Mapper接口上可以使用@Mapper注解标识该接口为MyBatis的Mapper接口，使用BaseMapper作为父接口，可以自动获得一些常用的CRUD方法，无需手动编写SQL语句。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5295ebadd542242a6acea680ea7b3975/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8216066d7e72a4cfef53bb84ceec668/" rel="bookmark">
			对比 5 种分布式事务方案，还是宠幸了阿里的 Seata（原理 &#43; 实战）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本来不知道写点啥，正好手头有个新项目试着用阿里的 Seata 中间件做分布式事务，那就做一个实践分享吧！
介绍 Seata 之前在简单回顾一下分布式事务的基本概念。
分布式事务的产生 我们先看看百度上对于分布式事务的定义：分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。
额~ 有点抽象，简单的画个图好理解一下，拿下单减库存、扣余额来说举例：
当系统的体量很小时，单体架构完全可以满足现有业务需求，所有的业务共用一个数据库，整个下单流程或许只用在一个方法里同一个事务下操作数据库即可。此时做到所有操作要么全部提交 或 要么全部回滚很容易。
分库分表、SOA 可随着业务量的不断增长，单体架构渐渐扛不住巨大的流量，此时就需要对数据库、表做 分库分表处理，将应用 SOA 服务化拆分。也就产生了订单中心、用户中心、库存中心等，由此带来的问题就是业务间相互隔离，每个业务都维护着自己的数据库，数据的交换只能进行 RPC 调用。
当用户再次下单时，需同时对订单库 order、库存库 storage、用户库 account 进行操作，可此时我们只能保证自己本地的数据一致性，无法保证调用其他服务的操作是否成功，所以为了保证整个下单流程的数据一致性，就需要分布式事务介入。
Seata 优势 实现分布式事务的方案比较多，常见的比如基于 XA 协议的 2PC、3PC，基于业务层的 TCC，还有应用消息队列 + 消息表实现的最终一致性方案，还有今天要说的 Seata 中间件，下边看看各个方案的优缺点。
2PC 基于 XA 协议实现的分布式事务，XA 协议中分为两部分：事务管理器和本地资源管理器。其中本地资源管理器往往由数据库实现，比如 Oracle、MYSQL 这些数据库都实现了 XA 接口，而事务管理器则作为一个全局的调度者。
两阶段提交（2PC），对业务侵⼊很小，它最⼤的优势就是对使⽤⽅透明，用户可以像使⽤本地事务⼀样使⽤基于 XA 协议的分布式事务，能够严格保障事务 ACID 特性。
可 2PC的缺点也是显而易见，它是一个强一致性的同步阻塞协议，事务执⾏过程中需要将所需资源全部锁定，也就是俗称的 刚性事务。所以它比较适⽤于执⾏时间确定的短事务，整体性能比较差。
一旦事务协调者宕机或者发生网络抖动，会让参与者一直处于锁定资源的状态或者只有一部分参与者提交成功，导致数据的不一致。因此，在⾼并发性能⾄上的场景中，基于 XA 协议的分布式事务并不是最佳选择。
3PC 三段提交（3PC）是二阶段提交（2PC）的一种改进版本 ，为解决两阶段提交协议的阻塞问题，上边提到两段提交，当协调者崩溃时，参与者不能做出最后的选择，就会一直保持阻塞锁定资源。
2PC 中只有协调者有超时机制，3PC 在协调者和参与者中都引入了超时机制，协调者出现故障后，参与者就不会一直阻塞。而且在第一阶段和第二阶段中又插入了一个准备阶段（如下图，看着有点啰嗦），保证了在最后提交阶段之前各参与节点的状态是一致的。
虽然 3PC 用超时机制，解决了协调者故障后参与者的阻塞问题，但与此同时却多了一次网络通信，性能上反而变得更差，也不太推荐。
TCC 所谓的 TCC 编程模式，也是两阶段提交的一个变种，不同的是 TCC 为在业务层编写代码实现的两阶段提交。TCC 分别指 Try、Confirm、Cancel ，一个业务操作要对应的写这三个方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8216066d7e72a4cfef53bb84ceec668/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a57e1e2738eae46a29e97617a20fb07e/" rel="bookmark">
			前端使用ajax发送数据遇到后端接口有{}的特殊字符的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）问题： 在做前端项目的时候，遇到后端给的接口中含有特殊的字符{}。如下图所示：
其中在这里power是我发送过去的数据，这个接口的意思就是前端发生过去的数据power作为后端的接口路劲。
前端使用ajax发送数据时会出现访问接口成功但是没有数据返回的问题：
2）问题原因查找 使用类似postman工具进行调试发现，接口成功和我使用ajax发生数据接口失败的不同点。
成功调用接口并返回数据的调试：
调用接口成功但是不返回数据的接口：
从上面失败和成功的接口对比，发现：
调试工具发生成功是因为将接口中的{power}直接转为前端发生的数据1，而我自己写的ajax发生数据好像接口并不能将{power}替换为1，而且发现我写的ajax接口在浏览器上请求的网址后面还有%7Bpower%7D这样的乱码。
我猜这里是使用ajax进行发生数据，ajax传递的路径好像解码不了{}这样的特殊字符。
3）我的解决方法： 我发生过去的power只有1或2这两个值，1对应A接口，写2时对应的就是B接口，我直接将1或2写在接口的后面，并不发送power数据过去，我猜我发送的power应该是先放在接口的路劲上，后端并不是直接接受我发送的power数据，而是直接在接口路劲上进行截取获取power的数据，我改后的代码如下：
这样改我就调用接口成功并能够接收数据：
所以如果接口上要前度传递什么数据过去，可以使用url拼接的方式去使用ajax发送数据，如果还有问题就先使用类似postman的网页调试工具，成功发生请求后和自己发生的请求进行对比看哪里不同。
4）我的思考： 因为我没学vue框架，不知道使用es6进行传递数据的话是不是传递的数据就可以放在接口的路径上，有大神有什么好的方法希望分享一下，谢谢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0317d9fc5b11a5a3b32ff91ab480995/" rel="bookmark">
			python十进制转二进制方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Python中，十进制数可以转换成二进制数。例如： 但是，十进制数不是直接转换成二进制，而是先转换成二进制数，再转换成十进制。接下来我们来看看具体的实现方法： 首先我们来看一个例子： 上面代码中，使用了循环遍历的方法。从这个例子中我们可以发现，需要遍历一次。因为每个数字都是16个位，所以一共需要遍历64次。在 Python中，使用循环的方式实现需要遍历一次的代码如下： 因此，可以看到第一行的代码使用了循环遍历的方法实现了16次遍历，第二行使用了二进制遍历的方法实现了16次遍历。 因此我们可以看到，只需要用两行代码就完成了一次循环遍历。
一、十进制数转换成二进制
这里使用的方法是 float （），因为这种方法只需要在数组的最后面放上一个数，就可以对这个数进行转换。下面是一个例子： 第一行：输入十进制数字0到9,输出二进制数字0到9。上面的代码使用的是 float （）方法来实现十进制转二进制的。这里使用了一个方法 float （）来对转换后的二进制数据进行处理。 在上面的代码中用了三个方法来对数据进行处理： 使用 float （）方法转换后得到的二进制数据是16位，因此需要将其转换成二进制数后再进行存储。 使用 float （）方法将16位的二进制数转换成了10位的二进制数。
二、循环遍历
循环遍历的实现原理是：一个字符串如果出现了两次，就会被重复执行，直到出现第三次为止。 但是这里出现了一个问题：为什么要在第二行中使用循环遍历呢？ 这是因为：我们在第一行中使用了循环遍历的方式，这里只需要用到第一行中的第一个字符串就可以实现16次遍历。但是，我们还需要先把第二行的第二个字符串也加进来。 因此，这里的第二个字符串必须要加进来。 当然，也可以使用二进制遍历的方法实现循环遍历：
1、十进制转二进制
既然十进制转二进制是循环遍历，那么我们可以直接用循环的方式来实现十进制转二进制。在上面的例子中，我们只需要把第二行的第二个字符串也加进来就可以了，但是在上面的例子中，我们还需要把第二行的第一个字符串也加进来。因为这里要将十进制转二进制，所以我们需要用到第二行第一个字符串： 这就是循环遍历了，接下来我们通过 if语句来实现循环遍历： 在这个例子中，我们使用了 if语句来判断第二行的第一个字符串是否为0,如果为0的话，则进入循环遍历；如果不是0的话，则把第二行的第二个字符串也加进来。
三、使用二进制数据
十进制数转换成二进制数的方法，我们可以使用下面的方法进行尝试： 上面代码中，使用了循环遍历的方法，一共需要遍历16次，最后使用了二进制的方法，只需要两行代码就可以完成。如果我们想要遍历更多的次数，也可以使用循环遍历和二进制遍历两种方法结合使用。可以看到，通过上面两种方法，一共遍历了16次，最终只需要遍历4次。因此上面两种方法的使用技巧是： 第一种方法使用循环遍历的方法对数据进行遍历；第二种方法是先用二进制遍历一次，再用循环遍历一次。 通过上面代码可以看到，虽然十进制数转换成二进制数据后需要遍历64次，但是我们可以通过下面两种方法结合起来使用。 首先是使用循环遍历的方法对数据进行遍历。因为数据是16位的二进制数，所以每遍历一次需要遍历第2位，也就是16-2=12。 但是如果采用二进制算法对数据进行遍历的话，就可以只遍历第1-32位了。 由于上面两种方法都可以使用循环的方式实现对数据的遍历，因此我们也可以用循环的方式对16个位数进行遍历。
四、使用十进制数组
对于十进制数，可以使用十个十进制数来组成一个数组。这样的数组可能是以1开头，也可能是以0开头，但都是以1开始，并且不会重复。从上面的代码中可以看到，这个数组由4个数组成，其中每个数都包含了两个十进制数字：0和1。
常用的python十进制转二进制代码：
1. 使用内置函数bin()将十进制数转换为二进制数：
```python
decimal_num = 10
binary_num = bin(decimal_num)
print(binary_num)
```
输出结果为：`0b1010`
2. 使用位运算符将十进制数转换为二进制数：
```python
decimal_num = 10
binary_num = ""
while decimal_num &gt; 0:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0317d9fc5b11a5a3b32ff91ab480995/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9794b9b3bb2dbd9680fa059844a7f448/" rel="bookmark">
			Chatgpt-3数据集处理代码和训练代码使用的主要编程语言和框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GPT-3的数据集处理和训练代码主要使用Python编程语言。
具体来说，OpenAI使用Python代码和PyTorch框架来构建了GPT-3的训练模型。
此外，OpenAI还使用了其他Python的包来处理和准备数据集，例如NLTK和spaCy等。
GPT-3还使用了C++和CUDA等语言来进行一些低级优化，以加快模型训练和推理速度
GPT-3 使用了多种机器学习框架，其中最主要的是TensorFlow和PyTorch。 TensorFlow是由Google开发的开源机器学习框架，具有高效、灵活和易于使用的特点，适合于深度学习的应用场景。
PyTorch是由Facebook开发的另一种流行的深度学习框架，与TensorFlow类似，具有动态图形特性，可以更方便地进行模型的构建和训练,PyTorch更适合用于快速开发原型，而且相对来说更易用一些，另外也因为PyTorch的动态计算图设计有助于灵活地处理不同形状的输入数据。
除了这两个主要的框架外，GPT-3 也使用了其他一些机器学习框架，例如Keras和MXNet等，以及一些自定义的库和工具，如JAX和Flax等。这些框架和工具都有其各自的优势和特点，并且可以根据具体场景和需求进行调整和使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30fd76923b339a74d45d14000eaf061d/" rel="bookmark">
			servlet封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：在web项目的时候，要想实现不同的功能，通常需要请求不同的资源路径，而每一个资源路径都对应者一个servlet类，非常麻烦，所以，现在让我们来使用一个servlet来搞定 通常servlet类会使用@WebServlet(“/”)注解来表示当前servlet类对应者哪一个资源路径，当我们在浏览器访问该资源路径时，会根据请求的方式不同而自动调用doGet（）或者doPost（）方法，而service（）方法则会根据我们请求自动调整，也就是只需要重写service（）方法就可以。
先写一个HttpServlet类的子类，重写service方法
public abstract class BaseServlet extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } } 我们可以在该类定义一些方法，然后根据请求参数的不同，去自动调用不同的方法，从而达成前言所说的目的
先获取浏览器请求的url中的指定属性，然后将我们定义的方法的方法名设置成该属性的值，当url传递到这个BaseServlet的请求资源路径后，获取该属性的值，再利用反射的知识，去调用指定方法，从而实现需求。
自定义方法
我们需要写3个方法，分别实现3种需求：转发，重定向，返回JavaBean对象
创建一个BaseServlet的子类，代码如下
import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet("/test") public class MyWork extends BaseServlet{ //重定向 public String redirectTest(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.sendRedirect("https://www.baidu.com"); //重定向到百度 } //转发 public String forwardTest(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30fd76923b339a74d45d14000eaf061d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3adb7b07ceff372ce2cbee06ce1f12b6/" rel="bookmark">
			华为悦盒EC6108V9通刷固件及教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为悦盒EC6108V9（海思芯片）当贝纯净桌面通刷固件及教程
固件特点：
1、删除原机IPTV等APP高度精简；
2、删除在线升级功能；
3、支持多屏互动功能；
4、内置U盘自动安装程序功能，USB设备新建文件夹命名为YueMe_BOX，将自己需要安装的apk程序放在这个文件夹，USB设备插入到机顶盒即可自动安装程序，无需繁杂的反复按键手动安装；也可以选择使用当贝市场-文件管理安装自己的程序包；
刷机方法： EC6108V9 CA版机器进rec升级，将update.zip文件拷贝到U盘根目录或者upgrade目录下，机器通电开机同时不停按遥控器待机键或者左右键，等待出现recovery界面选择apply update fromexternal storage进行刷机 EC6108V9 CA版机器需拆机短接强刷，将下载到的压缩包文件夹中的5个文件解压到U盘根目录，U盘插在机顶盒上；短接机顶盒J15或J16点机器通电进行救砖式刷机，出现机器人再松开直到刷机完成！
声明：本安卓固件，仅供内部测试和技术交流使用，任何非法商业使用及商业利益冲突带来的法律纠纷，与本人无关，本人概不负责，请下载后24小时内删除，谢谢合作！刷机既有乐趣也有风险，请慎重选择，一切源于刷机造成的后果自负，本人概不负责！
刷机包获取：
链接: https://pan.baidu.com/s/1qSmtBgSEbKs6ZFm-yCr-XQ
提取码: nnw3
声明：本安卓固件，仅供内部测试和技术交流使用，任何非法商业使用及商业利益冲突带来的法律纠纷，与本人无关，本人概不负责，请下载后24小时内删除，谢谢合作！刷机既有乐趣也有风险，请慎重选择，一切源于刷机造成的后果自负，本人概不负责！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a0a6aef896089cb28bf7c5bb60d9439/" rel="bookmark">
			四则运算12
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 a=int(input()) op=input() b=int(input()) if op=='+': print("%d%c%d=%d"%(a,op,b,a+b)) elif op=='-': print("%d%c%d=%d"%(a,op,b,a-b)) elif op=='*': print("%d%c%d=%d"%(a,op,b,a*b)) elif op=='/': print("%d%c%d=%.1f"%(a,op,b,1.0*a/b)) 从键盘输入两个整数a,b，一个操作符op，计算并输出a op b的结果。（无需考虑除数为0的情况）
输入格式: 分三行输入。
注意：
输入使用input()，不要增加额外的提示信息在python3中从键盘读入的都为字符串，数值类型需要使用 int(input()) 或 eval(input()) 来进行转换。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬ 输出格式: 要求列出式子，具体格式见输出样例
输入样例1: 2 + 3 输出样例1: 2+3=5 输入样例2: 6 / 2 输出样例2: 6/2=3.0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cadad8348a1efd0c191156a93944aaff/" rel="bookmark">
			Python通用验证码识别OCR库ddddocr的安装使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python通用验证码识别OCR库ddddocr的安装使用 一、前言二、Python安装（Python版本必须&gt;=3.8）三、安装ddddocr3.1 解决ssl module 的问题3.1.1升级OpenSSL到1.1.13.1.2 重新编绎Python 3.2 yum安装ddddocr 四、写代码测试ddddocr识别效果 一、前言 之前写了一篇关于java使用tess4j进行图片文字识别.md的，对于应付简单的数字识别还是能应付，但总体效果、识别率很一般，后来同事找到了这一篇写的，(亲测好用便捷)Python通用验证码识别OCR库ddddocr的安装使用教程，试用了下确实效果要好很多，因此也记录一下，算是白嫖了这篇文章自己的一个使用总结，细化了里面的一些安装过程，具体如下说明。
ddddocr项目地址：https://github.com/sml2h3/ddddocr
安装环境： linux centos7.x
二、Python安装（Python版本必须&gt;=3.8） ddddocr的使用需要python3.8以上，默认centos系统里面一般自带了2.7版本，因此python3的安装就采用全新安装与python的2版本同时共存，之前也写了一篇如下：centos7安装python3简单步骤，可参与这篇进行安装，采用的是3.10.0的源码编绎方式。
#准备依赖 yum -y install gcc yum -y install zlib-devel #下载源码 wget https://www.python.org/ftp/python/3.10.0/Python-3.10.0.tgz #解压安装 tar -xvf Python-3.10.0.tgz cd Python-3.10.0 ./configure --prefix=/usr/local/python3 make &amp;&amp; make install #软连接 ln -s /usr/local/python3/bin/python3 /usr/local/bin/python3 ln -s /usr/local/python3/bin/pip3 /usr/local/bin/pip3 #查看安装后的版本号 python3 -V #测试hello world脚本准备 cat &gt; hello.py &lt;&lt; EOF #!/usr/local/bin/python3 # -*- coding: utf8 -*- print("hello world") EOF #执行查看测试效果 [testuser@localhost ~]$ /usr/local/bin/python3 hello.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cadad8348a1efd0c191156a93944aaff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cb3d7649e6463e9efff44cc65f661fa/" rel="bookmark">
			clion&#43;wsl&#43;perf 工具进行性能分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WSL 1 不支持perf
首先升级WSL 2
WSL1升级为WSL2
https://zhuanlan.zhihu.com/p/356397851
在wsl中安装并测试perf
https://scicoding.com/how-to-perform-perf-profiling-in-wsl2/
在clion中使用perf
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aad452bfdb9498b1e98eb00840088224/" rel="bookmark">
			matlab：plot线型和颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matlab：plot线型和颜色 在Matlab中，我们可以使用不同的线型和颜色来绘制图形。这些选项可以帮助我们更好地展示数据和结果。 线型选项：
实线：使用默认的plot命令绘制的线条就是实线。
虚线：可以使用“–”选项来绘制虚线。例如：plot(x,y,‘–’)。
点线：可以使用“:”选项来绘制点线。例如：plot(x,y,‘:’)。
点划线：可以使用“-.”选项来绘制点划线。例如：plot(x,y,‘-.’)。
颜色选项：
Matlab中有许多预定义的颜色选项，可以在plot命令中使用。以下是一些常用的颜色选项：
红色：‘r’
蓝色：‘b’
绿色：‘g’
黑色：‘k’
白色：‘w’
黄色：‘y’
紫色：‘m’
青色：‘c’
除了这些预定义的颜色选项外，我们还可以使用RGB颜色代码来自定义颜色。例如：plot(x,y,‘color’,[0.5 0.5 0.5])，这个命令将绘制灰色的线条。
在Matlab中，我们可以使用这些线型和颜色选项来创建各种不同类型的图形，以更好地展示数据和结果。
该博文为原创文章，未经博主同意不得转载。
本文章博客地址：https://cplusplus.blog.csdn.net/article/details/129864060
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54fac9778a2a6492f62c3cec8b0b3bb7/" rel="bookmark">
			UG二次开发 获取零件的中心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取实体、组件的中心点，这里有2种方法供参考：
1、通过UF_MODL_ask_bounding_box获取边界，然后间接获取对象的中心点
//通过ufun函数获取boundbox的边界 double[] bounding_box = new double[6] { 0, 0, 0, 0, 0, 0 }; theUFSession.Modl.AskBoundingBox(txtBodyList[0].Tag, bounding_box); //零件的中心点 double[] pointCenter = new double[3] { 0, 0, 0 }; pointCenter[0] = (bounding_box[3] + bounding_box[0]) / 2; pointCenter[1] = (bounding_box[4] + bounding_box[1]) / 2; pointCenter[2] = (bounding_box[5] + bounding_box[2]) / 2; double boundHeight = Math.Abs(bounding_box[1] - bounding_box[4]); double boundLen = Math.Abs(bounding_box[0] - bounding_box[3]); double[] pointCenter1 = new double[3] { 0, 0, 0 }; //创建坐标系 Tag matrix_id = Tag.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54fac9778a2a6492f62c3cec8b0b3bb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55dccdb381d9dbe95e33192aee3640a8/" rel="bookmark">
			el-input设置背景色，改变样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template slot="birthday"&gt; &lt;el-input :class="age == false ? 'birthday' : ''" size="mini" disabled v-model="form.birthday" &gt;&lt;/el-input&gt; &lt;/template&gt; ::v-deep .birthday .el-input__inner { background-color: yellow !important; color: red !important; } 思路：在浏览器控制台的元素中发现el-input是两层，div里套了个input，直接在&lt;el-input&gt;中设置颜色的话无法达到效果，查看发现el-input__inner才是真正input的那层，设置一个class名称来定位到此，style样式中用了scoped，在css样式中加上deep和important
效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e21f3e2e6bfec43eed753614716d8c70/" rel="bookmark">
			Ubuntu20.04 解决有线宽带网络连接(转载—用作备忘)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 、新装的Ubuntu无法连接有线（无有线标志） 1.lspci命令（查看网卡型号）
看到最后一行
2e:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. Device 8125 (rev 05)
因此我们的网卡驱动版本为8125
2、官网下载
官网网址：Realtek PCIe FE / GBE / 2.5G / Gaming Ethernet Family Controller Software 进行下载
3、安装
找到压缩包，解压：
tar -jxvf r8125-9.011.00.tar.bz2 解压后进入文件夹
执行：
sudo sh ./autorun.sh 安装完成可以发现插上网线已经可以上网了
二、解决有线宽带网络连接问题 备注：关闭WiFi；有线连接取消“自动连接”
1.打开终端
2.nmcli con edit type pppoe con-name "My DSL"
（“My DSL”是你设置的网络的名字）
3.set pppoe.username ISPUsername
“ISPUsername” 填入账户名
4.set pppoe.password PASSWORD
“PASSWORD”填入密码
5.save
yes
6.quit
之后在 设置 -&gt; 网络找到便可连接上网络
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e21f3e2e6bfec43eed753614716d8c70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d887195170814c193955a4a47e717ab6/" rel="bookmark">
			【计算机毕业设计】151人力资源管理系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、系统截图（需要演示视频可以私聊） 摘 要 传统信息的管理大部分依赖于管理人员的手工登记与管理，然而，随着近些年信息技术的迅猛发展，让许多比较老套的信息管理模式进行了更新迭代，员工信息因为其管理内容繁杂，管理数量繁多导致手工进行处理不能满足广大用户的需求，因此就应运而生出相应的人力资源管理系统。
本人力资源管理系统分为管理员还有用户两个权限，管理员可以管理用户的基本信息内容，可以管理汽车信息以及汽车的租赁信息，能够与用户进行相互交流等操作，用户可以查看员工信息，可以查看应聘以及查看管理员回复信息等操作。
该人力资源管理系统采用的是WEB应用程序开发中最受欢迎的B/S三层结构模式，使用占用空间小但功能齐全的MySQL数据库进行数据的存储操作，系统开发技术使用到了JSP技术。该人力资源管理系统能够解决许多传统手工操作的难题，比如数据查询耽误时间长，数据管理步骤繁琐等问题。总的来说，人力资源管理系统性能稳定，功能较全，投入运行使用性价比很高。
关键词：人力资源管理系统；MySQL数据库；SSM技术
目 录 摘 要 Abstract 目 录 第一章 课题背景及研究内容 1.1 课题背景 1.2 开发目的和意义 1.3 论文研究内容 第二章 相关技术 2.1 B/S结构 2.2 MySQL数据库 第三章 系统分析 3.1可行性分析 3.1.1时间可行性 3.1.2 经济可行性 3.1.3 操作可行性 3.1.4 技术可行性 3.1.5 法律可行性 3.2系统流程分析 3.3系统功能需求分析 3.4 系统非功能需求分析 第四章 系统设计 4.1 总体功能 4.2 系统模块设计 4.3 数据库设计 4.3.1 数据库设计 4.3.2 数据库E-R 图 4.3.3 数据库表设计 第五章 系统实现 5.1 管理员功能模块的实现 5.1.1 员工列表 5.1.2 招聘信息管理 5.1.3 应聘记录管理 第六章 系统测试 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d887195170814c193955a4a47e717ab6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82c668a32313078691f83f45c29cbdb8/" rel="bookmark">
			2023前端进阶及相关知识整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经过几年前端开发的经验以后，必然会发现每天工作的内容其实大部分都是类似的，而这个时候往往就会出现迷惘，感觉自己的工作知识技能基本上都停留在一个层次。其实前端是很广泛的领域，我们要学的会有很多，而许多东西未必会出现在工作中，但是一旦需要那又必须得去掌握去开发，因此利用业余时间去学习，看api文档，做demo示例这些是非常有必要的，最好做些自己的项目
本文对当前的自己做个知识总结。
如还有其他哪些需要学习的知识补充，可在下面留言！！！
基础知识 计算机网络基础知识 链接数据结构与算法 链接js设计模式 链接js编译原理 链接JavaScript 运行原理解析 链接HTML渲染过程详解 链接html，css在浏览器渲染渲染原理 链接函数式编程入门 链接前端优化 链接 前端知识 HTML 教程 链接CSS 教程 链接less 链接 / sass 链接 两者选其一ajax 链接fetch 新一代的网络请求方式 ，可以替代ajax 链接js (es5) 链接js (es6 以及后续的版本) 链接ts 现在非常火的一个js超集(许多项目会看到) 链接Dom/Bom 以及 对浏览器运行前端项目理解 前端框架技术和相关库 vue2 相关全家桶vue3 相关全家桶 链接nuxtjs 一个vue的srr框架 链接uniapp(小程序,h5,app一套式开发) 链接微信小程序和公众号h5 原生开发 链接地图-可以完成api基本开发 （随便一个国内地图如高德）echarts-可以完成api基本开发（echarts社区图集） 链接GIS 和 geoJson 进行自定义地图开发深入一点的3d 相关开发如 D3 、 threejs、 thingjs各种工具如 ：腾讯IM 、webpack、git、npm、各种图标库(阿里巴巴图标库)、eslint、vscodeui框架(element/vant/uview)微前端 （single-spa、乾坤微前端）pc桌面开发项目electron (基于js开发pc桌面应用)各种web相关使用的插件 （vue插件库）(富文本编辑器wangEditor)各种工具（在线工具）走react路线的要学习taro、react系相关库，reactNative最新的serverless nodejs开发后端相关的库和框架 nodeJS 基础知识 链接 （nodejs中文社区）express (链接)、koa/koa2持久层框架（mongoose) 、（TypeORM）数据库 （MongoDB介于关系数据库和非关系数据库）(MySQL (经典的关系数据库)) （Redis (基于内存亦可持久化的数据库)）mysql数据库使用工具 navicat经典框架 egg(阿里的) 、midway(新一代后端框架)、nestjs(推荐的新一代后端Nodejs框架)linux操作系统基本使用(会安装软件如(mysql)，会操作文件，会写启动代码)nginx的使用(会写配置内容)各种云，如阿里云，会租服务器，会配置服务器和域名、cdn等postman，Fiddler 代码管理和博客相关 CSDN、博客园、简书、掘金、知乎等github是项目代码托管和寻找别人优秀项目的最佳选择 项目工程 axure （产品原型开发）蓝湖 (ui相关的)禅道(测试相关的)gitLab （可以本地安装私有git）jenkins（项目构建打包部署）docker （项目部署、镜像） 综合 上面整理的各种内容在现在五花八门的库、框架面前算是比较少了，但是也基本上囊括了当前前端常用的以及需要掌握的各种内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82c668a32313078691f83f45c29cbdb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/725b0e7bf8688893617a9010c6affd26/" rel="bookmark">
			[Java Web]Session | 一文详细介绍会话跟踪技术中的Session
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⭐作者介绍：大二本科网络工程专业在读，持续学习Java，努力输出优质文章
⭐作者主页：@逐梦苍穹
⭐所属专栏：Java Web
目录 Session1、介绍2、工作流程3、工作原理4、基本使用5、Session的钝化与活化5.1、提出问题5.2、🔺解决问题 6、Session销毁 Session 1、介绍 简单概述Session：
服务端会话跟踪技术：将数据保存到服务端。Session是存储在服务端而Cookie是存储在客户端存储在客户端的数据容易被窃取和截获，存在很多不安全的因素存储在服务端的数据相比于客户端来说就更安全 详细介绍：
Session（会话）是一个在Web应用程序中跨多个请求维护客户端状态的机制。在Web应用程序中，HTTP协议是无状态的，这意味着每个请求都是独立的，服务器不能识别不同请求之间的关联。Session解决了这个问题，它允许Web应用程序在客户端和服务器之间存储和共享状态数据。
当客户端第一次访问Web应用程序时，服务器会创建一个唯一的会话ID，并将其存储在客户端的Cookie中。
会话ID通常是一个长的随机字符串，用于识别客户端。每个后续请求都将包含这个会话ID，使得服务器能够识别客户端，并且能够在不同请求之间共享数据。
在会话中，可以存储任意数据，例如用户信息、购物车内容等。服务器会将这些数据存储在内存或持久化存储中（如数据库或文件系统），并且只在会话有效期内保留。通常情况下，会话有效期是30分钟到几个小时，但可以根据需要进行配置。
总之，Session是一种在Web应用程序中维护客户端状态的机制，它通过在客户端和服务器之间存储和共享状态数据，解决了HTTP协议无状态的问题。
2、工作流程 在服务端的ServletA获取一个Session对象，把数据存入其中在服务端的ServletB获取到相同的Session对象，从中取出数据，就可以实现一次会话中多次请求之间的数据共享了 那么如何保证ServletA和ServletB使用的是同一个Session对象？下面进行原理分析
3、工作原理 前提条件：Session是基于Cookie实现的
Session的工作原理如下：
当客户端第一次访问Web应用程序时，服务器会创建一个唯一的Session ID，这个Session ID通常是一个长的随机字符串。服务器将Session ID存储在Cookie中，并将Cookie发送给客户端浏览器。客户端浏览器会将Cookie保存在本地，并在后续的每个请求中发送给服务器。当客户端发送一个请求时，服务器会读取请求中的Session ID，并使用它来查找与该Session ID相关联的Session对象。如果服务器找到了Session对象，它将使用该对象存储和读取与该会话相关的数据。如果服务器没有找到Session对象，则会创建一个新的Session对象，并将其与Session ID相关联。服务器会将Session对象存储在内存或持久化存储中（如数据库或文件系统），并在会话过期之前保留它。当客户端关闭浏览器或者Session过期后，服务器会删除该Session对象，并释放与之相关联的资源。关闭打开浏览器后，因为浏览器的cookie已被销毁，所以就没有JESSIONID的数据，服务端获取到的session就是一个全新的session对象 总之，Session的工作原理是通过在客户端浏览器和服务器之间传递Session ID来维护客户端状态，并在服务器上存储和共享会话数据，以便跨多个请求共享和使用该数据。
4、基本使用 在JavaEE中提供了HttpSession接口，来实现一次会话的多次请求之间数据共享功能。
具体的使用步骤为:
使用request对象获取Session对象-&gt;HttpSession session = request.getSession();Session对象提供的功能：
a. 存储数据到session域中-&gt;void setAttribute(String name,Object o)
b. 根据Key获取值-&gt;Object getAttribute(String name)
c. 根据Key删除该键值对-&gt;void removeAttribute(String name) 下面通过一个简单Demo来实现Session的简单使用：
需求:在一个Servlet中往Session中存入数据，在另一个Servlet中获取Session中存入的数据
1.创建名为SessionDemo1的Servlet类
2.创建名为SessionDemo2的Servlet类
3.在SessionDemo1的方法中：获取Session对象、存储数据
4.在SessionDemo2的方法中：获取Session对象、获取数据
5.启动测试
创建SessionDemo1并存储数据：
创建SessionDemo2并获取数据：
启动Tomcat服务器，访问sessionDemo1，然后再访问sessionDemo2，查看控制台，可以看到：
此时查看浏览器缓存的Cookie：
下面在代码中测试两次获取的Session是不是同一个对象：
可以看到，是同一个对象。这是通过第一次获取对象生成的JESSIONID唯一标识来识别的。
前面讲工作原理的时候提到，如果把浏览器关闭或者开启新的会话窗口，那么Session对象就会不一样。同时，如果把浏览器关闭再重新打开，去查看浏览器缓存的Cookie时，会发现之前存储的Session对象的Cookie被销毁了。
这也很好的印证了：Session是基于Cookie实现的，Session本质上还是实现的同个会话中的数据共享。
5、Session的钝化与活化 5.1、提出问题 服务器重启后，Session对象存储的数据是否还在？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/725b0e7bf8688893617a9010c6affd26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d0a262f4bc0049360edcbd634230f12/" rel="bookmark">
			让你的shell在后台运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		让你的shell在后台运行 pc帮助我们搬砖，总不能傻傻的等在terminal等着跑完吧。万一terminal
让进程后台运行 使用&amp;可以让程序后台运行，比如我
for i in {1..10000}; do echo $i; sleep 1; done &amp; 已经后台执行，我用ctrl+c也无法打断，因为进程已经在后台跑了
jobs查看当前终端后台运行 jobs只查询当前终端的运行程序
输出重定向 由于输入没有重定向，所以还是输出到当前的终端。
重定向输出到文件中。
for i in {1..10000}; do echo $i; sleep 1; done &gt; my.log &amp; 这样就不会在控制台输出呗干扰了
让进程不依赖当前shell运行 由于此后台运行的程序依赖当前shell，当我退出的时候，程序也推出了
都是由2666966这个进程带起来的
通过disown命令，把进程用不依赖当前terminal。disown后，jobs已经是空的
nohub运行， nohup 和 &amp; 的区别 为了避免我每次都到输入disown，如果能让进程启动时，就不跟随系统，可以使用nohub
nohup bash -c 'for i in {1..10000}; do echo $i; sleep 1; done ' &gt; my.log 2&gt;&amp;1 &amp; 这样运行的程序默认就是不依赖当前terminal的。
nohub ： 应用程序不再和terminal关联，默认不会后台运行
&amp;：后台运行
后台运行程序再次接入 在后台运行的程序，有时候想重新接入前台，使用fg(Foreground)，可以拉起，但必须jobs是以看到进程的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d0a262f4bc0049360edcbd634230f12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6f25a00b2fc2627103cd9b83ea031ff/" rel="bookmark">
			STM32最小系统板上所有电路的认识和学习。（晶振电路（电容的作用），复位电路，下载端口，供电电路）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32最小系统板介绍 在STM32最小系统板上，系统电路包括以下内容：
外部晶体振荡电路：用于提供系统时钟。电源电路：包括5V稳压芯片和3.3V稳压芯片，用于提供芯片和外围器件所需的电压。复位电路：包括复位电路和手动复位按键，用于确保系统的可靠启动。调试接口：包括SWD调试接口和UART串口调试接口，用于芯片的调试和程序下载。 以上是STM32最小系统板上常见的系统电路，具体实现方式和组成元件可能因不同厂家和不同型号的系统板而有所差异。
晶振电路 在STM32最小系统板上，8M晶振是用于提供系统时钟的外部晶体振荡电路之一。
具体计算方法如下：
晶振频率 = 8MHz
晶振周期 = 1 / 晶振频率 = 0.125us
如果需要一个1秒的周期，需要多少个晶振周期？
1s / 0.125us = 8000000个周期
因此，如果使用8MHz晶振，系统需要运行8000000个晶振周期才能完成一个1秒的周期。
晶振旁的俩个电容到底有啥作用 主要作用是平衡晶振引脚的电感的。因为晶振在高频工作时有寄生电感,为了平衡电感,起到谐振的作用。所以要用两个小电容来平衡电感。一般电容的选20pf–30pf的就可以了。具体的大小请参看晶振厂家提供的数据手册。
芯片晶振引脚的内部通常是一个反相器，芯片晶振的两个引脚之间还需要连接一个电阻，使反相器在振荡初始时处与线性状态，但这个电阻一般集成在芯片的内部，反相器就好像一个有很大增益的放大器，为了方便起振，晶振连接在芯片晶振引脚的输入和输出之间，等效为一个并联谐振回路， 振荡的频率就是石英晶振的并联谐振频率。
晶振旁边的两个电容需要接地，，其实就是电容三点式电路的分压电容，接地点就是分压点，以分压点为参考点，振荡引脚的输入和输出是反相的，但从晶振两端来看，形成一个正反馈来保证电路能够持续振荡。
芯片设计的时候，其实这两个电容就已经形成了，一般是两个的容量相等，但容量比较小，不一定适合很宽的振荡频率范围，所以需要外接两个负载电容。
晶振旁边的负载电容怎么选择？ 负载电容需要根据晶振的规格来选择，晶振的规格书都会标示出负载电容的大小，一般都是几pF到几十pF。
假如晶振规格要求用20pF的负载电容，因为两个负载电容是串联的，理论上需要选择两个40pF的负载电容。
实际上MCU内部和PCB的线路上都会有一定的寄生电容，晶振的负载电容=［（C1*C2）/（C1+C2）］+Cic+△C，Cic+△C 为MCU内部电容和PCB线路的寄生电容，一般是35pF，所以，在实际应用中会考虑用30pF36pF的负载电容。
晶振和负载电容布线注意事项
为了让晶振能够可靠、稳定的起振，我们在布线时，需要让晶振和负载电容尽量的靠近芯片的晶振引脚。
启动配置 在STM32系列芯片中，BOOT引脚的设置是非常重要的。因为它决定了芯片启动时使用哪种模式，从而影响了芯片的功能和使用方式。以下是一些常见的BOOT引脚设置方式：
1. 通过引脚电平来选择模式 当BOOT引脚接地时，芯片会进入System Memory模式。而当BOOT引脚悬空或接高电平时，则会进入Flash模式。这种设置方式比较简单，但需要注意确保BOOT引脚的电平正确，否则可能会导致芯片无法正常启动。
2. 通过BOOT0和BOOT1引脚的组合来选择模式 在一些型号的芯片中，除了BOOT引脚外，还有专门的BOOT0和BOOT1引脚。通过这两个引脚的组合，可以选择不同的模式。具体的组合方式可以查看芯片的数据手册。
3. 通过系统软件来选择模式 在一些特殊情况下，需要通过系统软件来选择启动模式。这种方式需要在程序中加入相应的代码，通过修改寄存器的值来实现。这种方式比较灵活，但需要开发者有一定的编程能力。
总之，在使用STM32系列芯片时，正确设置BOOT引脚是非常重要的。开发者需要根据具体的需求和芯片型号来选择合适的设置方式，以确保芯片能够正常启动并发挥出最佳性能。
复位电路 单片机的外部按键复位电路主要是为了在单片机出现异常情况时，通过按下复位按键来使单片机重新启动，使其恢复正常工作状态。以下是实现外部按键复位电路的基本步骤：
将复位按键连接到单片机的复位引脚上，一般复位引脚的编号为RST或RESET，需要根据单片机型号进行确认。在复位按键的一端接上一个电阻，另一端连接到单片机的电源引脚上。电阻的阻值需要根据实际情况进行选择，一般为10kΩ左右。为了防止按键弹跳和干扰，还需要在按键的两端分别连接一个电容，并将电容接地。电容的容值一般为0.1uF左右。 通过以上步骤的实现，就可以实现单片机的外部按键复位电路。当单片机出现异常情况时，只需要按下复位按键，就可以使单片机重新启动，使其恢复正常工作状态。
下载端口 SWD下载端口详细介绍 SWD (Serial Wire Debug)下载端口是一种用于调试和编程ARM Cortex处理器的接口。它可以通过两根线（SWDIO和SWCLK）实现调试和编程功能。下面是SWD下载端口的详细介绍：
SWDIO线
SWDIO线是SWD下载端口中的数据线，用于传输调试和编程命令以及数据。它可以同时作为输入和输出端口使用。在调试模式下，SWDIO线被用来读取处理器的寄存器值和内存数据。在编程模式下，SWDIO线被用来传输编程命令和数据到处理器。
SWCLK线
SWCLK线是SWD下载端口中的时钟线，用于控制数据传输的时序。它提供了用于同步SWDIO线上的数据传输的时钟信号。SWCLK线的频率可以由调试器或编程器进行控制，通常在1MHz至4MHz之间。
当然了，GND 和VCC是必须要有的。
STM32芯片和供电电路 1. 稳定的电源 STM32芯片需要稳定的电源以确保其正常工作。设计供电电路时，必须考虑到可用的电源类型，例如直流电源或电池。确保电源电压的稳定性非常重要，因为电压波动可能会导致芯片损坏。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6f25a00b2fc2627103cd9b83ea031ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cf0b08c70ea24167f3fe82050154e86/" rel="bookmark">
			Android FFmpeg系列04--FFmpeg调用MediaCodec进行硬解码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、引言 在上篇文章中我们通过FFmpeg软解并渲染了本地的一个mp4视频
Android FFmpeg系列03--视频解码与渲染
本文基于之前的Demo添加了FFmpeg使用MediaCodec来硬解码的方式，包括解码出buffer再利用OpenGL进行渲染上屏和直接解码到Surface然后上屏两种方式
FFmpeg使用MediaCodec可以在解封装后拿到AVPacket再利用jni将buffer回调到java层，然后在java层调用MediaCodec；也可以直接在native层利用AMediaCodec
用于测试的mp4采用H264编码
所以使用上述两种调用MediaCodec方式的时候需要先通过
“h264_mp4toannexb” filter
将AVPacket进行转换一次，相关背景可以参考H264码流之AnnexB和AVCC
不过在本系列教程中使用的FFmepg5.0.1版本，bitstream filter的相关接口都已经被移除
所以接下来采用FFmpeg在3.1之后提供的直接调用MediaCodec的C接口来实现硬解码
（HWAccelIntro – FFmpeg）
可以看到目前还只支持解码而不支持编码
2、编译 在之前的编译脚本中打开如下三个配置即可（详情参考Android FFmpeg系列01--编译与集成）
--enable-jni \ --enable-mediacodec \ --enable-decoder=h264_mediacodec \ 不需要再配置h264_mediacodec的硬件加速（list中已经查找不到了）
--enable-hwaccel=h264_mediacodec
解码出Buffer
解码流程和软解类似，不再赘述，重点描述一下流程不一样的地方
2.1 将JVM实例设置给FFmpeg // libavcodec/jni.h // int av_jni_set_java_vm(void *vm, void *log_ctx); // 方式一，在so加载的JNI_OnLoad方法中调用 // 方式二，在用到ffmpeg的模块调用即可，该方法可以多次调用，只要jvm实例相同即可 JavaVM *javaVm = nullptr; env-&gt;GetJavaVM(&amp;javaVm); if (javaVm != nullptr) { av_jni_set_java_vm(javaVm, nullptr); } 2.2 通过"h264_mediacodec"查找解码器 由于h264_mediacodec解码器和h264解码器id相同，所以
// 软解时 avcodec_find_decoder(id); // 使用mediacodec硬解时 avcodec_find_decoder_by_name(“h264_mediacodec”); 之后的步骤和软解步骤完全相同，不需要做任何更改
本地测试采用软解出来的AVFrame格式是AV_PIX_FMT_YUV420P，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cf0b08c70ea24167f3fe82050154e86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64fe2bcecd7cd33a3d4221c04e4b9139/" rel="bookmark">
			mongodbTemplate更新或删除子元素为数组的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mongodb数据库中的数据如下：
{ "orgid": "5", "orgname": "机构名称", "orgdata": [ { "date": "20230329", "data": { "incomeDay": "3.47", "incomeSameDay": "34.58", "incomeYearOnYearDay": "-90.0", "incomeZYDay": "3.47" }, "detailDataMZ": [ ], "totalDataMZ": { "regTotalAccount": NumberInt("0"), "regFirstAccount": NumberInt("0"), "regSecondAccount": NumberInt("0"), "inpAccount": NumberInt("0"), "lostAccount": NumberInt("0"), "lostPerAccount": "" }, "detailDataZY": [ { "deptname": "一病区", "lastAt": "53", "inp": "0", "out": "0", "at": "53" }, { "deptname": "三病区", "lastAt": "64", "inp": "0", "out": "0", "at": "64" } ], "totalDataZY": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64fe2bcecd7cd33a3d4221c04e4b9139/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee87ba9c24b9bb6b6e6a1403539764c3/" rel="bookmark">
			MATLAB矩阵操作1——删除全0列和nan列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB矩阵操作1——删除全0列和nan列 1. 对全0列或行的删除2. 对全为NAN列的删除3. 对存在NAN列的删除 1. 对全0列或行的删除 clear a = [0	0	0	NaN	0	NaN NaN	NaN 0	0	0.5	0	0	NaN	0	NaN 0	0	0.5	0	0.5	NaN 0	NaN] % 删除全为0的列 a(:, all(a==0)) = [] 删除结果如下：
2. 对全为NAN列的删除 % 删除全为nan的列 a(:, all(isnan(a))) = [] 删除结果如下：
3. 对存在NAN列的删除 % 删除存在nan的列 a(:, any(isnan(a))) = [] 删除结果如下：
上述代码可以直接复制到MATLAB中使用，或者下载下面的CSDN资源来使用代码
https://download.csdn.net/download/qq_57971471/87630683
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f19de6649a9bf8d85eb08f34dbf38359/" rel="bookmark">
			Java提供了哪些加密方式（来自chatGpt回答）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java提供了很多加密方式，以下是几种常见的：
1. 对称加密
对称加密采用同一把密钥进行加密和解密，常见算法有AES、DES、3DES等。优点是加密和解密速度快，缺点是密钥的安全性要求高，需要实现密钥分发、管理等功能。
2.非对称加密
非对称加密采用公钥加密、私钥解密，或者私钥加密、公钥解密。常见算法有RSA、DSA等。优点是密钥对的安全性比较高，缺点是加密和解密速度较慢。
3.哈希加密
哈希加密将一段消息转换成一个固定长度的值，常见算法有MD5、SHA-1等。优点是加密速度快，不可逆，缺点是容易被暴力破解。
4.数字签名
数字签名是对数据进行哈希值计算，并使用私钥进行加密，以确保数据的完整性和真实性。常见算法有RSA、DSA等。
综上所述，不同的加密方式有各自的优缺点和适用场景。在实际应用中，应根据实际情况综合选择适合的加密方式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c676cf8970b57f0deb8799eb8d6d3b10/" rel="bookmark">
			Trojan客户端使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Trojan客户端使用教程 此教程使用的是 Centos7 x86_64系统
1.开启Trojan客户端代理服务 使用此命令下载Trojan客户端
官方版本(GitHub)： cd /usr/src &amp;&amp; wget https://github.com/trojan-gfw/trojan/releases/download/v1.15.1/trojan-1.15.1-linux-amd64.tar.xz
解压Trojan文件 tar xvf trojan-1.15.1-linux-amd64.tar.xz
打开配置文件 cd /usr/src/trojan
vi config.json
按i进入编辑模式
run_type 修改为 “client”
local_port 修改为 1080
remote_addr 修改为 vpn.xxx.cn
remote_port 修改为 443
password 修改为 [“123456”] trojan服务端验证密码
示例如下
“run_type”: “client”,
“local_addr”: “0.0.0.0”,
“local_port”: 1080,
“remote_addr”: “jpo123.ovod.me”,
“remote_port”: 443,
“password”: [“123456”],
ssl中的 verify 值修改为 false （如果配置文件中没有，则添加这个配置）
​ ssl中的 verify_hostname 值修改为 false （如果配置文件中没有，则添加这个配置）
​ ssl中的 cert 修改为 “” （改成空的）
示例如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c676cf8970b57f0deb8799eb8d6d3b10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7cc41dda19284babd700d9ce2e5d0c4/" rel="bookmark">
			Unity中Z-buffer、G-buffer、D-buffer的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Z-Buffer：存储的是depthValue和StencilTest的结果。
G-Buffer：全称Geometry Buffer，是在deferred shading中，存储中间结果，存储的信息有颜色、法线、世界空间下的坐标。deferred shading对于多灯光，多物体的场景，能够节省计算开销。
D-Buffer：在Unity中，Dbuffer是一个实时渲染技术，它使用Deferred Rendering（延迟渲染）的方法来处理透明物体和深度信息。
在传统的Deferred Rendering中，深度缓冲区只记录不透明物体的深度信息，透明物体需要使用额外的技巧来进行渲染，这可能会导致较多的开销和不自然的效果。而Dbuffer技术则扩展了深度缓冲区，以记录透明物体的深度信息和其他属性信息，从而可以更准确地处理透明物体，并且使它们能够像不透明物体一样进行正确的光照计算。
通过使用Dbuffer技术，Unity可以在处理复杂的场景和大量透明物体时提供更好的性能和效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/354293ffdc30ae2a67638025e2205b99/" rel="bookmark">
			数据库的主要设计步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库设计是指根据应用环境的需求，构造（设计）优化的数据库逻辑模式和物理结构，并根据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据处理要求。[4]
通常，数据库设计可以分为以下 6 个主要步骤[3]：
需求分析：分析数据存储的要求，产出物有数据流图、数据字典、需求说明书等。概念结构设计：也称为 E-R 图设计，这一步骤旨在设计实体-属性图，即 E-R 图，与具体的实现方式无关，说明有哪些实体，实体有哪些属性等。逻辑结构设计：将 E-R 图转换成关系模式，也即转换成实际的关系。在这一步中，需要选择合适的数据模型，确定数据库表之间的关系，设计数据完整性约束等。物理结构设计：指怎样组织数据在磁盘存储器上的存储结构，也就是数据在存储介质上的组织形式。这一步需要考虑到数据的存储方式、数据的读写效率以及数据的安全性等因素。数据库实施：在这一步中，需要创建数据库及其表、设置索引、定义存储过程和触发器等。数据库的运行和维护：包括数据库的备份与恢复、数据迁移、优化数据库查询等。 在具体进行数据库设计时，还需要考虑以下几个方面：
数据库的范围和目的：包括哪些数据、数据如何组织，以及数据库的使用目的等。数据库的安全性：包括访问控制、数据加密、安全审计和漏洞管理等。数据库的性能：包括查询和更新的速度、并发处理、容量和伸缩性等。数据库的扩展性：如何处理未来的需求变化和新业务增加等。数据库的可靠性：包括数据的完整性、可用性、可恢复性和容错性等。 综上所述，数据库设计是一个复杂的过程，需要考虑多方面的问题。在设计过程中，需要充分理解应用环境和用户需求，选择合适的数据模型和设计原则，并结合具体的技术实现，才能构建出高效、稳定、安全的数据库系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c467a7519ad47f80a4aced3aeeb9131/" rel="bookmark">
			xshell命令搜索日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 cat -n 1000 /opt/apache-tomcat-8/logs/catalina.out | grep 'XX' cat -n 1000 /opt/apache-tomcat-8/logs/catalina.out | tail -n +7830 | head -n 220 cat -n 1000 test.log.2023-02-22.log catalina.out | grep 'XX' cat -n 1000 test.log.2023-02-22.log catalina.out | tail -n +21913 | head -n 220 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/176fc36dc32586c28f16a68f0412ba65/" rel="bookmark">
			allowedOriginPatterns和allowedOrigins方法有什么不同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		allowedOriginPatterns 和 allowedOrigins 都是用来设置允许跨域请求的来源，其中 allowedOriginPatterns 是在 Spring 5.3 版本引入的新方法，而 allowedOrigins 是旧版本中的方法。
它们的主要区别在于使用方式和匹配规则。allowedOrigins 方法使用的是字符串匹配，即只能指定具体的跨域来源，而不能使用通配符；而 allowedOriginPatterns 方法使用的是 Ant 风格的路径匹配规则，可以使用通配符来匹配多个来源。
通配符是一种表示可以匹配任意字符或者任意字符串的符号，通常用于模式匹配或者模糊匹配。
举个例子，如果你的前端应用需要从 http://localhost:8080 和 https://www.example.com 两个不同的来源获取数据，你可以这样配置：
registry.addMapping("/**") .allowedOrigins("http://localhost:8080", "https://www.example.com") .allowedMethods("GET", "POST") .allowCredentials(true) .maxAge(3600); 这段代码表示，允许来自 http://localhost:8080 和 https://www.example.com 这两个来源的跨域请求访问任何请求路径，允许的 HTTP 方法包括 GET 和 POST，启用允许发送凭据，预检请求的缓存时间为 1 小时。
使用 allowedOriginPatterns 方法可以这样配置：
registry.addMapping("/**") .allowedOriginPatterns("http://localhost:*", "https://*.example.com") .allowedMethods("GET", "POST") .allowCredentials(true) .maxAge(3600); 这段代码表示，允许来自以 http://localhost: 开头的任意端口和以 https:// 开头的以 .example.com 结尾的任意二级域名的跨域请求访问任何请求路径，允许的 HTTP 方法包括 GET 和 POST，启用允许发送凭据，预检请求的缓存时间为 1 小时。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbbe33e6bad775b914ec3d521f2724e0/" rel="bookmark">
			vite &#43; vue3 &#43; ts &#43; esLint &#43; prettier 配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用pnpm创建一个新的Vue 3 + TypeScript项目
pnpm create vite my-project --template vue-ts cd my-project pnpm install pnpm run dev 2.安装EsLint
pnpm install -D eslint 3.初始化配置EsLint
npx eslint --init 3.1 选择模式： (To check syntax and find problems)
You can also run this command directly using 'npm init @eslint/config'. ? How would you like to use ESLint? ... To check syntax only &gt; To check syntax and find problems To check syntax, find problems, and enforce code style 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbbe33e6bad775b914ec3d521f2724e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d7ce866f15e6d7efecd6fbaeb2a72b1/" rel="bookmark">
			前后端交互学习笔记（五）：express&#43;mysql&#43;身份认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		express+mysql+身份认证 文章目录 express+mysql+身份认证expressexpress基本使用托管静态资源nodemon工具 express路由express中间件中间件的分类自定义中间件CORS接口跨域问题 Mysql基本概念SQL的使用mysql模块 前后端身份认证开发模式身份认证Session 实现JWT认证机制JWT使用 express express基本使用 Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架。通俗的理解：Express 的作用和 Node.js 内置的 http 模块类似，是专门用来创建 Web 服务器的。express是基于http内置模块封装得来的。Express 的本质：就是一个 npm 上的第三方包，提供了快速创建 Web 服务器的便捷方法。使用 Express，我们可以方便、快速的创建 Web 网站的服务器或 API 接口的服务器。 http://www.expressjs.com.cn/
安装 npm i express基本创建服务器方法： // 1. 导入 express const express = require('express') // 2. 创建 web 服务器 const app = express() // 4. 监听客户端的 GET 和 POST 请求，并向客户端响应具体的内容 app.get('/user', (req, res) =&gt; { // 调用 express 提供的 res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d7ce866f15e6d7efecd6fbaeb2a72b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5144bd8d98f84f2e955eadf0d2b93e4f/" rel="bookmark">
			缓存服务Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Redis 简介 Redis 是一个使用 ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对(key-value)存储数据库。从2015年6月开始，Redis的开发由 Redis Labs 赞助，而2013年5月至2015年6月期间，其开发由Pivotal赞助。在2013年5月之前，其开发由VMware赞助。根据月度排行网站DB-Engines.com的数据显示，Redis是最流行的键值对存储数据库。
数据来源：DB-Engines Ranking - popularity ranking of database management systems Redis采用内存(In-Memory)数据集(DataSet) 。 支持多种数据类型，支持字符串(string)、列表(list)、集合(set)、散列(hash)、有序集合(zset) 五种数据类型 运行于大多数 POSIX 系统，如Linux、*BSD、OS X等。 Redis作者： Salvatore Sanfilippo 作者GitHUB: GitHub - redis/redis: Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values are supported: Strings, Lists, Sets, Sorted Sets, Hashes, Streams, HyperLogLogs, Bitmaps. 1、Redis 软件获取和帮助 官方网站：https://redis.io 官方各版本下载地址：Index of /releases/ Redis 中文命令参考：http://redisdoc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5144bd8d98f84f2e955eadf0d2b93e4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e14ebf52fd1a84e297fa3fe547537c3/" rel="bookmark">
			Spring Security初步理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。Spring Security是一个专注于为Java应用程序提供身份验证和授权的框架。与所有Spring项目一样，Spring安全性的真正威力在于它可以很容易地扩展以满足定制需求。
一般Web应用的需要进行认证和授权。
用户认证（Authentication）：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户。用户授权（Authorization）：经过认证后判断当前用户是否有权限进行某个操作。在一个系统中，不同用户所具有的权限是不同的。 Spring Security与Shiro的区别 Spring Security 是 Spring家族中的一个安全管理框架。相比与另外一个安全框架Shiro，它提供了更丰富的功能，社区资源也比Shiro丰富。相对于Shiro，在SSH/SSM中整合Spring Security都是比较麻烦的操作，但有了Spring boot之后，Spring Boot 对于 Spring Security 提供了 自动化配置方案，可以零配置使用 Spring Security。因此，一般来说常见的安全管理技术栈组合是：
SSM+ShiroSpring Boot /Spring Clound +Spring Security 简单使用 登录校验流程 引入Security 在SpringBoot项目中使用SpringSecurity只需要引入依赖即可。
&lt;!-- spring security 安全认证 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; 设置用户名和密码 在application.properties中添加属性：
server.port=8080 #spring.security.user.name=root #spring.security.user.password=123456 #mysql数据库连接 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/security?serverTimezone=GMT%2B8 spring.datasource.username=root spring.datasource.password=123456 但是在application.properties中添加属性意味着登录系统的用户名的密码都是固定的，不推荐。可以使用配置类，在配置类中设置，配置类的优先级更高。
使用配置类 @EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true) public class SecurityConfig extends WebSecurityConfigurerAdapter { /** * 自定义用户认证逻辑 */ @Autowired private UserDetailsService userDetailsService; /** * 认证失败处理类 */ @Autowired private AuthenticationEntryPointImpl unauthorizedHandler; /** * 退出处理类 */ @Autowired private LogoutSuccessHandlerImpl logoutSuccessHandler; /** * token认证过滤器 */ @Autowired private JwtAuthenticationTokenFilter authenticationTokenFilter; /** * 解决 无法直接注入 AuthenticationManager * * @return * @throws Exception */ @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception { return super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e14ebf52fd1a84e297fa3fe547537c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8b15c39b9504c2f835ce719bc12c9b5/" rel="bookmark">
			Windows11下pytorch深度学习环境配置（cuda显卡问题相关）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：Torch1.10.0+cuda11.3+torchvision0.10.0
1 PyTorch+CUDA安装问题 如果电脑本来装了cuda，那么直接pip安装torch也不会自动配上cuda， 会安装成cpu版的。
如果要安装特定版本的pytorch，我建议是直接到这个链接torch_stable去下载whl文件，然后直接pip install (目录文件名).whl
我下载的是这个，cuda对应11.3，torch是1.10.0
我发现一件神奇的事情是，他有的版本下载速度快，有的版本速度慢，这也是挺迷的。
另外，直接下载whl文件的好处是，方便挂梯子下载，如果安装失败或者错误方便重来，并且在一开始就已经确定好了cuda的版本和torch的版本。在官网给的命令总是容易出问题。
torchvision和torchaudio也通过这种方式下载whl文件即可。
2 NVIDIA卸载问题 如果要卸载或者更换cuda版本，要看清楚卸载哪些东西。我之前是看了一个博主（报错：Torch not compiled with CUDA enabled看这一篇就足够了）说，要把所有NVIDIA相关的全部卸载。我的建议是不要这样。因为会带着驱动一起卸载了，下面图片标的是驱动相关的，这些就不要卸载了。其他的是安装cuda的时候产生的， 应该可以卸载。
如果全卸载了，那么电脑所有显卡相关的东西都被移除了，直接导致的就是显卡无法使用了，我记得我刚全卸载完，扩展屏就不显示了。
此外，如果在命令行输入nvidia-smi也报错，说没有该命令，那么大概率就是驱动被卸载了。
再去官网安装对应的显卡驱动就好，安装完就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cd2a7ee0fcf3dcac16e351ef104bf23/" rel="bookmark">
			客户端软件中显示报警信息的实现探讨
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.功能背景 很多情况下，软件需要将运行过程中产生的必要信息（日志或报警信息）实时输出，以便用户及时关注到系统健康状态，如下图。
二.实现方式探讨 在客户端软件中，一般有专门的窗口来显示报警信息，但报警信息的产生却可能发生在系统的各个地方，如UI层的不同窗口，业务层的方法。
1.第一种实现方式 经常见到的一种实现方式是使用事件机制，如下示例代码，在产生报警信息的窗口Form1、Form2...中定义事件：
public partial class Form1 : Form { /// &lt;summary&gt; /// 定义产生日志的事件 /// &lt;/summary&gt; public event LogEventHandler LogGenerate; /// &lt;summary&gt; /// 实例对象，便于访问 /// &lt;/summary&gt; public static Form1 Instance = new Form1(); public Form1() { InitializeComponent(); } } public partial class Form2 : Form { /// &lt;summary&gt; /// 定义产生日志的事件 /// &lt;/summary&gt; public event LogEventHandler LogGenerate; /// &lt;summary&gt; /// 实例对象，便于访问 /// &lt;/summary&gt; public static Form2 Instance = new Form2(); public Form2() { InitializeComponent(); } } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cd2a7ee0fcf3dcac16e351ef104bf23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3f6bed41c56cd5fb078e0c6c995c5a0/" rel="bookmark">
			Java设计模式之单例模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义与类型 定义：保证一个类仅有一个实例，并提供一个全局访问点
类型：创建型
单例模式使用场景 想确保任何情况下都绝对只有一个实例
例如：线程池，数据库连接池一般都为单例模式
单例模式优点 在内存中只有一个实例，减少内存开销可以避免对资源的多重占用设置全局访问点，严格控制访问 缺点 没有接口，扩展困难
单例模式-重点 私有构造器线程安全（重点）延迟加载（重点）序列化和反序列化安全（序列化和反序列化会破坏单例模式）反射（防止反射攻击） 实现单例模式-懒汉式 /** * 懒汉式 */ public class LazySingleton { private static LazySingleton lazySingleton = null; private LazySingleton(){ } public static LazySingleton getInstance(){ if (lazySingleton == null){ lazySingleton = new LazySingleton(); } return lazySingleton; } } 将构造器私有化，提供一个静态类来获取对象实例
但是该方法是线程不安全的，如果在LazySingleton未实例化前，多个线程同时调用，例如线程1判断lazySingleton为null，进入下一步并没有创建对象时，另一个对象也判断lazySingleton为空这时就会出现创造出多个实例的错误。
使用多线程debug方式显示问题 在idea中想要使用多线程debug方式需要按如图所示修改，将断点改为Thread级别
在Test的main方法中开辟两个线程
public class Test { public static void main(String[] args) { // LazySingleton instance = LazySingleton.getInstance(); Thread t1 = new Thread(new T()); Thread t2 = new Thread(new T()); t1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3f6bed41c56cd5fb078e0c6c995c5a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e2f335b6bbb4db422d71cf815beaf4f/" rel="bookmark">
			高可用利器-限流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		限流基本概念 限流是**流量限速（Rate Limit）**的简称，是一种常见的系统流量控制方式，它通过限制系统的请求或流量，来保证系统的稳定性和可靠性。对于Server而言，限流保证一部分的请求流量可以得到正常的响应，总好过全部的请求都不能得到响应，甚至导致系统雪崩。
熔断、降级、限流这三者经常会混淆，在这里介绍一下：
熔断：在分布式系统中，下游应用会调用上游提供的服务，如果下游出现问题，下游还是盲目的调用上层的服务，这样会产生两个问题：① 增加整个链路的请求时间；② 下游出现问题，不断请求上层服务会加重系统问题，恢复困难。这个时候需要使用熔断，上游服务为了保护系统整体的可用性，可以暂时切断下游服务的调用。降级：在高并发场景下，由于资源是有限的而请求是无限的，如果不做服务降级处理，一方面肯定会影响整体服务的性能，严重的话可能会导致宕机某些重要的服务不可用。服务降级是指当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心业务正常运作或高效运作。 看到了一个很形象的比喻：
熔断：相当于你的一颗卒被围死了，就不要利用其它棋去救它了，弃卒保帅，否则救他的棋也可能被拖死。降级：相当于尽量不要走用处不大的棋了，浪费走棋机会（资源），使已经过河的棋有更多的走棋机会（资源）发挥最大作用。限流： 相当于尽量避免同时和两三个人同时下。 为什么需要限流？ 因为目前互联网系统通常都要面对高并发的场景，在突发情况下（最常见的场景就是秒杀、抢购），瞬时大流量会直接将系统打垮，无法对外提供服务。为了防止出现这种情况最常见的解决方案之一就是限流，当请求达到一定的并发数或速率，就进行等待、排队、降级、拒绝服务等。
常见的限流的方式 虽然绝大多数情况下限流都是发生在服务端的，但也并不是只有在服务端可以发生限流：
客户端限流：可以通过在客户端设置请求的速率等限制参数，或者在客户端缓存一定量的数据，减轻服务器的压力。这种方式当达到阈值时遍不会请求服务端，避免服务端产生额外的资源消耗。但这种方式在遇到客户端数量增加或减少的情况就需要重新计算每个客户端的限流阈值，且当下游服务较多时，每个服务的不同API有不同的限流配额，会增加客户端限流的复杂性。服务端限流：可以通过限制QPS、并发量或连接数等参数进行限流。这种方式不会因客户端数量增加或减少而改变，方便对不同上游服务进行不同阈值的限流策略。但这种方式通常只针对QPS限流，而不考虑连接数（服务在建连过程中也会产生一些资源消耗，而这些压力往往可能会成为瓶颈），如果对连接数进行限制，会造成因某个业务或服务的连接过多而其他服务的连接被限制。网关限流：可以通过设置访问速率和黑名单等参数进行限流。这种方式可以很好的保护整个集群的负载压力，服务端数量增加或减少，则网关进行相应的阈值调整即可，对不同的上游业务的服务设置不同的限流配额和不同的限流策略。但这种方式需要消耗网关资源，且要保证网关本身具有高可用性。 常见的限流粒度 通常根据场景的不同，又可以选择不同的限流粒度：
服务粒度：一个服务提供一个统一的限流的策略。虽然非常简单，但很容易造成限流失效，无法保护服务本身及下游（下游请求过多导致下游崩溃）。API粒度：不同的API进行不同的限流策略，这种方式相对复杂些，但是更为合理，也能很好的保护服务。需要注意的是：增加或减少API，则限流策略要做相应的调整，若请求处理实现发生改变则需要重新对限流阈值进行调整，避免因增加业务逻辑导致服务本身或者校友服务过载。API参数粒度：针对一些特殊场景，比如对于热点数据的访问频繁访问引起限流导致其他商品服务无法完成。 常见的限流后的处理方法 如果流量达到了设置的阈值，我们还需要对请求进行处理，常见的处理方法有：
返回错误信息：对于被限制的请求，可以返回适当的错误信息，告知用户该请求被限流了，并提供一些相关的提示或建议，例如稍后再试或减少请求频率等。排队等待处理：对于需要等待处理的请求，可以将它们排队，并逐个处理。这样可以避免请求过载导致系统崩溃，并保证每个请求都得到及时处理。排队等待处理可以使用队列、消息中间件等技术实现。降级处理：对于一些不是必须的请求，可以进行降级处理，例如在高峰期暂停某些功能、使用缓存等方式。这样可以降低系统的负载，并保证核心功能的正常运行。重试处理：对于因为限流而被拒绝的请求，可以尝试重新发送。这样可以提高请求的成功率，并减少因为限流而导致的不必要的请求失败。 常见的单机限流算法 实现单机限流的算法有多种，比如固定窗口算法、滑动窗口算法、令牌桶算法、漏桶算法，下面依次详细介绍。
固定窗口算法 固定窗口算法是将我们的每秒钟分成固定大小的时间窗口，并在每个窗口时间内限制请求的数量。
固定窗口算法的实现很简单，我们只需要记录一个计数器，并在每个时间窗口结束时将其重置为零。每当请求进入系统时，我们都会将计数器加一，并检查它是否超过了限制的阈值。如果超过了限制的阈值，则拒绝该请求。
这种方式的缺点是：窗口是固定的，且在两个窗口边界可能会有突发流量问题。具体而言，时间窗口为1s，1s的限制阈值是4，如果一个恶意用户在1s的后500ms内发送了3个请求，又在下一秒的前500ms内发送了3个请求，相当于1s内接收了6请求，会出现超过流量限制的情况。
滑动窗口算法 滑动窗口算法是对固定窗口算法的改进，解决了两个窗口边界可能会有突发流量问题。
滑动窗口算法的基本思想是在固定窗口算法的基础之上，将一个窗口分为若干个等份的小窗口，每个小窗口对应不同的时间点，拥有独立的计数器，当请求的时间点大于当前窗口的最大时间点时，则将窗口向前平移一个小窗口。如果请求数量超过了小窗口的限制的阈值，则拒绝该请求。
如下图所示，对1s的窗口划分为2个等长的小窗口，1s的限制阈值是4，那每个小窗口的限制阈值为2。
令牌桶算法 与滑动窗口算法不同，令牌桶算法可以更加精细地控制请求速率。
令牌桶算法的基本思想是维护一个令牌桶，其中每个令牌表示可以处理的一个请求。令牌桶以固定速率生成令牌，并将其放入桶中。每当一个新的请求进入系统时，我们尝试从令牌桶中获取一个令牌。如果令牌桶为空，则拒绝该请求；否则，将令牌从令牌桶中移除，并处理该请求。
详细参考Guava的RateLimiter源码阅读。
漏桶算法 漏桶算法用于平滑限制请求速率。漏桶算法的基本思想是，维护一个固定大小的漏桶，并在漏桶中存储请求。每当一个新的请求进入系统时，我们将其放入漏桶中。如果漏桶已满，则拒绝该请求；否则，允许该请求进入漏桶，并以固定的速率将请求从漏桶中移除。这样，可以平滑地限制请求速率。
算法比较 固定窗口算法 VS 滑动窗口算法 固定窗口算法是最为简单的限流算法，但是它存在边界可能会有突发流量问题。滑动窗口算法对固定窗口算法的改进，如果滑动窗口的精度越高，需要的存储空间就越大。
令牌桶算法 VS 漏桶算法 令牌桶是按照固定速率往桶中添加令牌，请求是否被处理需要看桶中令牌是否足够，当令牌数减为零时则拒绝新的请求；漏桶则是按照常量固定速率流出请求，流入请求速率任意，当流入的请求数累积到漏桶容量时，则新流入的请求被拒绝。令牌桶限制的是平均流入速率，允许突发请求，只要有令牌就可以处理，支持一次拿3个令牌，4个令牌；漏桶限制的是常量流出速率，即流出速率是一个固定常量值，比如都是1的速率流出，而不能一次是1，下次又是2，从而平滑突发流入速率。令牌桶允许一定程度的突发，而漏桶主要目的是平滑流出速率。 关于漏桶不适合应对突发情况的解释：这是因为漏桶以固定速率取出请求的。
举个例子，漏桶的容量为10，请求处理速率为2/s，那么可以容纳8个突发请求放入桶中，其他等待或者丢弃。
常见的分布式限流方案 单节点限流最大的问题是当服务节点动态添加或减少后，每个服务的限流配额也要跟随动态改变。而分布式限流则避免了这种问题，通过像Redis集群或发票服务器这种取号的方式来限制某个资源的流量。
Redis限流 基于Redis的单线程及原子操作特性来实现限流功能，这种方式可以实现简单的分布式限流。但是Redis本身也容易成为瓶颈，且Redis不管是主从结构还是其Cluster模式，都存在主节点故障问题。
方案一：固定窗口计数器 将要限制的资源名+时间窗口为精度的时间戳作为Redis的key，设置略大于时间戳的超时时间，然后用Redis的incrby的原子特性来增加计数。（存放当前窗口下的流量）
具体的lua脚本为：
local key = KEYS[1] local limit = tonumber(ARGV[1]) local acquireCount = tonumber(ARGV[2]) local current = tonumber(redis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e2f335b6bbb4db422d71cf815beaf4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/415eb480af73c38c12f73f0ce71e517e/" rel="bookmark">
			关于使用swagger时出现在浏览器输入网址无法访问的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
当我按照网上教程学习时，在SpringBoot上面集成了swagger后（引入
springfox-swagger2和 springfox-swagger-ui依赖 ）依赖是3.0.0最新版，按照老师的教程里面的网址进行访问：http://localhost:8080/swagger-ui.html然后先是项目启动不起来
此时idea报错信息：
为了解决无法启动的问题，进网上查询得知
错误原因：SpringBoot2.6.x使用PathPatternMatcher匹配路径，Swagger引用的Springfox基于AntPathMatcher匹配路径。匹配方式不同，导致错误。
解决办法：将SpringBoot的匹配路径方式更改为AntPathMatcher，两者相同即可。添加配置信息如下 spring.mvc.pathmatch.matching-strategy=ANT_PATH_MATCHER 虽然现在可以成功启动了，可又出现404的问题；
又从网上得知可能是地址的问题，我是使用的不同于老师的swagger版本
这是我导入的最新的3.0.0版本的:
低版本的长这样： 于是乎我意识到是因为资源文件名改变了的缘故，于是我马上将地址栏上面地址改为:http://localhost:8080/swagger-ui/index.html，结果还是404
从最开始的项目启动不了--到改变了地址还是无法访问 属实有点闷了
然后又去网上查找解决方案：
网上说如果你的地址是对的，还访问不了，大概率是请求被拦截了，写个配置类重写
WebMvcConfigurer类，重写 addResourceHandlers就行了 于是马上赋值粘贴 就修改了下pattern
最后运行，依旧404
最后没办法了不要高版本的了，换用了2.9.2版本的
重启项目，结果报了占用端口的错误，无论我怎么改变端口，都是已被占用
最后将所有的java进程全部关闭，最后重启项目，访问网站，最终访问成功
总结：不要使用高版本的swagger与SpringBoot的这个版本不兼容，使用低版本的就行了；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c21b6d40b22e74147464020d18ff04fb/" rel="bookmark">
			ubuntu系统硬盘挂载教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3 ubuntu系统硬盘挂载教程_哔哩哔哩_bilibili
今天我教大家怎么样去挂载自己的硬盘。
那为什么我们要挂载硬盘呢？那是因为ubuntu系统没有盘符的概念。
如下图所示：我们安装的ubuntu系统大概是100G左右，可能会不够用。现在大家看到的计算机就是我们安装好的ubuntu系统：
那我们看一下其它的位置，在其它的位置中有一个2T的硬盘：
为了增加ubuntu系统硬盘的空间，我们准备去挂载2T的这个硬盘。
操作步骤描述如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e707d13738c2591db280069051b7f2a3/" rel="bookmark">
			mysql 索引失效总结10种场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在实际工作中，有没有遇到过下面的这两种情况：
明明在某个字段上加了索引，但实际上并没有生效。索引有时候生效了，有时候没有生效。 准备工作 创建表和造数据
DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` int NOT NULL AUTO_INCREMENT, `code` varchar(20) COLLATE utf8mb4_bin DEFAULT NULL, `age` int DEFAULT '0', `name` varchar(30) COLLATE utf8mb4_bin DEFAULT NULL, `height` int DEFAULT '0', `address` varchar(30) COLLATE utf8mb4_bin DEFAULT NULL, PRIMARY KEY (`id`), KEY `idx_height` (`height`), KEY `idx_code_age_name` (`code`,`age`,`name`) ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin INSERT INTO `user` (`id`, `code`, `age`, `name`, `height`, `address`) VALUES (1, '101', 21, '周星驰', 175, '香港'); INSERT INTO `user` (`id`, `code`, `age`, `name`, `height`, `address`) VALUES (2, '102', 18, '周杰伦', 173, '台湾'); INSERT INTO `user` (`id`, `code`, `age`, `name`, `height`, `address`) VALUES (3, '103', 23, '荷逸', 174, '济南'); 此外，还创建了三个索引：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e707d13738c2591db280069051b7f2a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45230a6e815daff884305859b6f78e0e/" rel="bookmark">
			信号与系统–为什么零输入响应满足线性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零状态响应满足线性很好理解，响应扩大n倍，输出响应扩大n倍，那为什么零输入响应，初始条件也满足线性呢，首先不要被零输入响应的名字所迷惑，它其实本质也是一个微分方程的齐次解，只不过它的系数不一样，不妨假设一个二阶的LTI系统，假设其零输入响应的通解为Y=C1exp(-x)+C2exp(-2x)，很明显我们需要两个初始条件来确定C1和C2，一般都是y(0)和y‘(0)来确定系数，分别代入y(0)和y’(0)得到，C1+C2=y(0)和-C1-2C2=y’(0)两个方程，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b72724e9885cb7d1f3b3d96c120afc06/" rel="bookmark">
			C&#43;&#43;内存泄漏/内存越界的各种情况，以及预防与排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、内存泄漏
一、介绍
二、几种内存泄露的场景
三、预防与排查
1、valgrind
二、内存越界
一、介绍
二、几种内存越界的情况
三、预防与排查
一、内存泄漏 一、介绍 内存泄漏，是指在程序代码中动态申请的、堆上的内存 由于某种原因、在使用后没有被释放，进而造成内存的浪费。少部分的内存泄漏不会影响程序的正常运行，不过如果是持续的内存泄漏会耗光系统内存，最终会导致程序卡死甚至系统崩溃。为了避免系统崩溃，在无法申请到内存的时候，要果断调用exit()函数主动杀死进程，而不是试图挽救这个进程。 二、几种内存泄露的场景 1、malloc/new申请的内存没有主动释放
void test1() { char* str = new char[100]; /*delete[] str; 这里忘记delete了 */ } 2、new与free混用，malloc与delete混用
class Base { public: int* values; Base() { values = new int[100]; } ~Base() { delete[] values; } }; void test2() { Base* pBase = new Base; free(pBase);	/* 错误，这样只会释放pBase指向的内存，却不会调用Base的析构函数 会导致Base中的values指向的内存无法被释放 */ delete pBase;	/* 正确 */ } 3、使用new开辟数组时，delete忘记加[]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b72724e9885cb7d1f3b3d96c120afc06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/331c5683e16e6c1c044d1cdeb3322f71/" rel="bookmark">
			【docker】x【Mysql】对docker mysql数据库定时异地备份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近业务中遇到需要对数据库进行定时备份的情况，但是数据库是docker启动的mysql镜像，查找一番资料后找到下面这种方便快捷的方式。
docker启动的mysql备份脚本 这里的容器名称和密码替换成自己的，同时还使用-mtime +30 -delete删除最后修改时间为30天的文件，方式备份太多吧硬盘撑爆。
#!/bin/bash #定义备份文件的名称 BACKUP_NAME=$(date +"%Y%m%d%H%M%S").sql #定义备份目录 BACKUP_DIR=/mysql/backup #定义容器名称 CONTAINER_NAME=mysql #执行备份命令 docker exec $CONTAINER_NAME /usr/bin/mysqldump -u root --password=password chatgpt &gt; $BACKUP_DIR/$BACKUP_NAME #压缩备份文件 gzip $BACKUP_DIR/$BACKUP_NAME #删除一个月前的备份 find $BACKUP_DIR -type f -name "*.gz" -mtime +30 -delete #记录备份日志到out.log文件 echo "Backup completed at $(date)" &gt;&gt; $BACKUP_DIR/out.log 定时任务设置 使用常用的crontab进行定时任务执行。
crontab -e #最后一行加上 SHELL=/bin/bash PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root # For details see man 4 crontabs # Example of job definition: # .---------------- minute (0 - 59) # | .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/331c5683e16e6c1c044d1cdeb3322f71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53f7cf70f7e61e677dbab57b5eba09f9/" rel="bookmark">
			RStudio直接读取文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、import dataset
首次导入需要安装包 ------ readxl 稍等一会就会安装好
安装好就可以开始导入路径
写入链接以后，就会显示预览图像 （xls或者xlsx文件）
在点击import就可导入
如果是csv文件
点击from text 然后等待下载包，再导入就可以
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cffb64a2c30b3892ac41fadb757896af/" rel="bookmark">
			前后端交互学习笔记(四)：ajax及http
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ajax学习笔记1. 服务器的基本概念2. ajax的基本使用3. form表单的基本使用3. ajax提交form表单4. 模板引擎（根据返回的数据动态生成结果）5. XHR的基本使用6. 数据交换格式7. 封装自己的ajax函数8. XHR level2新特性使用jq实现上述文件上传功能 9. axios10. 同源策略与跨域JSONP 11.防抖与节流12. HTTP协议简介HTTP请求消息HTTP响应消息HTTP请求方式HTTP响应状态码 ajax学习笔记 1. 服务器的基本概念 上网过程中，负责存放和对外提供资源的电脑，叫做服务器。负责获取和消费资源的电脑，叫做客户端。URL（全称是UniformResourceLocator）中文叫统一资源定位符，用于标识互联网上每个资源的唯一存放位置。浏览器只有通过URL地址，才能正确定位资源的存放位置，从而成功访问到对应的资源。url地址一般由三个部分组成，如下所示：
打开 Chrome 浏览器，Ctrl+Shift+I 打开 Chrome 的开发者工具，切换到 Network 面板，选中 Doc 页签，刷新页面，分析客户端与服务器的通信过程客户端发送数据请求服务器，服务器发送数据，响应客户端如果要在网页中请求服务器上的数据资源，则需要用到 XMLHttpRequest 对象。XMLHttpRequest（简称 xhr）是浏览器提供的 js 成员，通过它，可以请求服务器上的数据资源。最简单的用法 var xhrObj = new XMLHttpRequest()资源的请求方式，get从服务器拿资源，post，向服务器发送资源 2. ajax的基本使用 Ajax 的全称是 Asynchronous Javascript And XML（异步 JavaScript 和 XML）。通俗的理解：在网页中利用 XMLHttpRequest 对象和服务器进行数据交互的方式，就是Ajax。用户与网页进行数据的交互，而网页与服务器之间的交互使用的是ajaxjq中的三个ajax请求，$.get()//拿资源 $.post()//发送资源 $.ajax()//即可拿，又可发送get的使用，回调函数里面就是拿到服务器返回的数据，谷歌调试工具中的Network下的XHR可以监听ajax的请求： $.get(url, [data], [callback]) 如下述写法，res打印出服务器返回的数据：
$.get('http://www.liulongbin.top:3006/api/getbooks', { id: 1 },function (res) { console.log(res) }) post的使用，语法如下，无论post 还是get，data这个参数是要用对象的形式表示： $.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cffb64a2c30b3892ac41fadb757896af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/320e57bdbb2cb15023c0b95ada9dc7d8/" rel="bookmark">
			vscode同时注释掉多行代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用鼠标选择多行代码，然后按下Ctrl + /键即可在所有选定的行上添加//注释。 如果想撤销多行注释，和添加一样，用鼠标选择多行代码，然后按下Ctrl + /键即可在所有选定的行上删除//注释。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/159/">«</a>
	<span class="pagination__item pagination__item--current">160/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/161/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>