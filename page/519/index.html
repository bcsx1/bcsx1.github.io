<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9acfc7c6076ad64f5f9aa06ebf0d534e/" rel="bookmark">
			矩阵乘法及矩阵快速幂运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设矩阵为n*n(n&lt;N)的矩阵，代码如下： const int N = 100; void matmul(long long a[][N], long long b[][N], long long n) { long long temp[N][N]; memset(temp, 0, sizeof(temp)); for (long long i = 1; i &lt;= n; i++) for (long long j = 1; j &lt;= n; j++) for (long long k = 1; k &lt;= n; k++) temp[i][j] += a[i][k] * b[k][j]; for (long long i = 1; i &lt;= n; i++) for (long long j = 1; j &lt;= n; j++) a[i][j] = temp[i][j]; } void quick_pow(long long a[][N], long long n) { long long ans[N][N]; for (int i = 0; i &lt; N; i++) for (int j = 0; j &lt; N; j++) ans[i][j] = 1; while (n !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9acfc7c6076ad64f5f9aa06ebf0d534e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/514ec01ea6aa904952545514d315099b/" rel="bookmark">
			docker基于centos的ssh镜像的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker基于centos的ssh镜像 docker rm -f $(docker ps -aq)删除所有容器 1：拉取centos镜像 docker pull centos 2：创建容器docker run -itd –name test docker.io/centos /usr/sbin/init 3：进入容器docker exec -ti test /bin/bash 4：yum -y update 5：yum install -y openssh-server 6：修改config文件 cd /etc/ssh vi sshd_config
Port 22 ListenAddress 0.0.0.0 ListenAddress :: PermitRootLogin yes 开放这四个选项 7：在宿主机生成密钥 ssh-keygen -t rsa cat /root/.ssh/id_rsa.pub 将生成的密钥copy到容器中的authorized_keys文件中 mkdir /root/.ssh vi authorized_keys 8:pam问题
sed -ri 's/session required pam_loginuid.so/#session required pam_loginuid.so/g' /etc/pam.d/sshd 9：设置启动脚本 vi run.sh
#!/bin/bash /usr/sbin/sshd -D 授权chmod +x run.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/514ec01ea6aa904952545514d315099b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/234b462126aac0182e36fb514aa75ade/" rel="bookmark">
			mybatis &#43; pagehelper 数据库翻页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mybatis + pagehelper 数据库翻页 Mybatis的一个插件，PageHelper，非常方便mybatis分页查询。
优点： 不需要自己在每个 mapper文件中写 limit x,x 这样的代码，引入插件调用pagehelper即可自动注入分页。
地址： https://github.com/pagehelper/Mybatis-PageHelper
1，引入jar &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt; &lt;/dependency&gt; 2,配置插件拦截规则 方法一，在 MyBatis 配置 xml 中配置拦截器插件 在mybatis-config.xml中配置
&lt;!-- plugins在配置文件中的位置必须符合要求，否则会报错，顺序如下: properties?, settings?, typeAliases?, typeHandlers?, objectFactory?,objectWrapperFactory?, plugins?, environments?, databaseIdProvider?, mappers? --&gt; &lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor="com.github.pagehelper.PageInterceptor"&gt; &lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt; &lt;property name="param1" value="value1"/&gt; &lt;/plugin&gt; &lt;/plugins&gt; 方法二，在 Spring 配置文件中配置拦截器插件 &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 注意其他配置 --&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt; &lt;property name="properties"&gt; &lt;!--使用下面的方式配置参数，一行配置一个 --&gt; &lt;value&gt; params=value1 &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 网上大多用的第一个配置方法，我用的第二种如下 3,调用 //第一种，RowBounds方式的调用 List&lt;Country&gt; list = sqlSession.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/234b462126aac0182e36fb514aa75ade/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/618c624b58380ffa5d9b457a63e631df/" rel="bookmark">
			QT界面技巧-QComboBox的QSS设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#QT界面技巧-QComboBox的QSS设置 如需转载请标明出处：http://blog.csdn.net/itas109 QQ技术交流群：129518033
环境：
QT版本：5.6.2
操作系统：windows 7 64bit
##1.QComboBox设置下拉框item高度
/*global QComboBox height*/ QComboBox QAbstractItemView::item { height: 50px; } 注意：在QSS中设置完后，需要调用如下代码，否则会使用默认的item样式，导致设置无效
//if no this code, the style sheet wont be applied to the default combobox item view. ui-&gt;comboBox-&gt;setView(new QListView()); 默认样式：
修改后样式：
##2.QComboBox设置下拉框item的字体大小
/*global QComboBox font size*/ QComboBox QAbstractItemView{ font-size: 18px; } 注意：在QSS中设置完后，需要调用如下代码，否则会使用默认的item样式，导致设置无效
//if no this code, the style sheet wont be applied to the default combobox item view. ui-&gt;comboBox-&gt;setView(new QListView()); 默认样式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/618c624b58380ffa5d9b457a63e631df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ad48193ebb24ed01a62af55e806b815/" rel="bookmark">
			深度学习在视频分析中的架构、算法及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直播与短视频业务的兴起，代表了一种内容交互方式的变化，更加追求强交互，这种变化催化了很多技术和架构的转型，由传统的传输、存储优先演进为计算与智能。本文是由360人工智能研究院视频大数据组技术负责人陈强在LiveVideoStackCon 2017上的演讲整理而成，分享了深度学习在视频业务中的一些实践案例，并由点及面介绍了相应的实现架构、算法与应用。
演讲 / 陈强
整理 / LiveVideoStack
首先进行下自我介绍，我是360人工智能研究院的陈强，我的工作更偏向于AI方向，从趋势上来看AI的落地会跟音视频紧密结合，本次的分享将在两者的交叉点，以及基础技术、产品的应用等方面，跟大家进行交流，希望能和大家相互交流，碰撞出火花。
一、前言
今天主要分享的主题是深度学习在视频分析中的应用与基础算法，先来介绍一下为什么要做这个方向。首先从目前360的主要业务方向来说：
第一点众所周知是安全，360从08、09年就开始用机器学习、人工智能的方法去做网络安全。最近几年开始做Safety的一些问题，即将线上安全转移到线下安全。线下安全很多都涉及到摄像头，比如在摄像头（监控）中遇到的异常事件和行为：家中老人跌倒、商店里进来了陌生人或小偷，这些需要用AI的方法实时对视频内容进行分析等等。
第二点是为了360内容服务业务，包括搜索、广告等一些传统的互联网产业的产品。这两年比较火的直播业务种，比如花椒直播，也使用了很多视频分析的技术。在2017年，360的重点内容方向也转为了短视频产品——从生产到分发的整个产业链的内容。这其中也涉及到了很多音视频的内容分析。做短视频的分析，实际上是要知道该视频本身在讲什么事情——一个社会类新闻或者场景化的直播类小视频，需要可以推荐给合适的人。这也是AI在音视频在内容分析的应用场景。
目前360人工智能研究院基于这两个方面跟各个业务线的合作非常紧密，研究院更多承担是技术上的支持。而我所在的是360人工智能研究院下面的视频大数据组，主要负责两块内容：
一是结合IOT和短视频等业务线场景做视频内容的分析，将场景分析、人脸人形检测等技术结合实际的业务场景来解决产品需求。
二是大数据技术，我们主要是利用深度学习技术来结合业务部门的实际数据进行有效建模和优化，以提升业务指标为目的。过去两年，主要精力放在了搜索的排序、广告的CTR预估，而现在更多是在做短视频的推荐等关键技术问题上。
今天的分享主要围绕视频分析来展开。我们视频分析以及大数据系统整个技术栈都依赖于深度学习这种比较新的方法，这样不会有太多的历史包袱。而过去两年中，我们花了很大精力在公司做了一个跨部门、跨平台的深度学习平台，包括从文本分析、到音频分析、到视频分析将之合并为360NET。另外我们在公司层面做了大规模的GPU集群，以及和公司的系统部合作开发了一个系统调度平台。
二、视频分析
视频内容分析是要对视频内容有一个比较完整的理解，它是通过摄像头或者通过视频，要站在机器的角度去看而不是以人的身份区理解和分析视频内容。我们主要的业务落地场景可大致区分为云端和移动端两种模式。云端对计算的复杂度要求相对没有那么严苛，更多的是系统latency问题。而移动端的任务往往技术难度更大。因为在移动端我们面临着有限的计算资源，对算法和系统结构提出的要求会更严苛。从数据角度来首，我们会根据数据将业务场景拆分成几个核心的技术问题：检测、识别、分割以及跟踪，针对这些问题以持续去做优化。
1.核心问题
因为今天很多朋友来自于音视频编码及传输领域，我先简单介绍一些基本概念。我们经常所说的识别问题：也就是对整个视频或者整个图像做一个抽象化的描述，它可以是物体级别、的也可以是一个场景级别的、甚至可以抽象为一个style。识别是告诉我们视频中大致的主体内容，如果想要知道视频中更细节的内容，比如商标或者里面人物，那么就必须要落到检测去定位物体在视频中的位置。再进一步，如果能够做到分割（语义级别的分割），就可以知道视频中每个pixel都会发生什么事情，这样想象空间就会特别大。而往往越是细致的信息的更有价值和具有想象空间：比如要在视频中插播广告，就可以通过分割来找到合适的位置插入相匹配的广告内容。
上图显示的是移动端实时的数据处理，我们需要实时知道路上发生了什么事情，包括车道线、前面的行人、车流量、路牌等等，这是一个综合检测和跟踪技术的实践。
2.算法基础
接下来介绍算法基础，首先要谈到传统算法和深度学习算法的区别。传统算法中，音视频处理中我们经常在开始时会有很多数据预处理，比如图像裁减、音视频平衡化等等，按照传统分类框架会提取各种特征：点特征、边缘特征、轮廓特征等等，音频中会有频谱特征以及一些实际特征。特征提取完成之后，需要串联一个比较强的分类器（SVM、random forest等）以及各种算法，针对各种问题再加入一些后处理，来进行分类识别。
现在比较常见的方式是直接用端到端（数据到目标）的卷积神经网络，完整替代前面说的四个步骤。对于数据端而言，所需要的数据最好不是人抽象化的数据，而是原始数据：例如对于视频来说就是RGB的值，对于AlphaGo围棋来说则是每次落子的位置，而不再需要抽象化的盘面特征预估。对于学习的目标端，需要能够把各种损失函数和优化目标定义清楚。给定了数据和优化目标，深度学习的过程就是一个自我迭代，逐步优化收敛的过程。
以CNN为例子，CNN从直觉上来说它就是一个Filter，比如对一个K×K或者R×R这样一个小的二维片面，用filter对新来的图片进行整体的卷积，卷积完成后输出Output Image，所以从前端的Filter到中间的输入数据，产生一个新的Channel。最近流行的卷积神经网络，和90年代的CNN还是有比较大的区别：现在我们不单单只有一个Filter，可能是M个Filter（M会很大），这样最后输出的Channel数也会很多，同样是M的级别。另外一个比较大的特点就是中间会加入各种非线性层，最经典的来说会加各种pooling层，在时序上或者空间上对它进行各种抽样化的概念；另外会使用各种非线性转移化的方程，比如最经典的sigmoid方程，现在比较流行的ReLU以及各种演化版本。目前的CNN模型往往是将多层卷积进行多层串并联以获得最大的拟合能力。 总结来说，卷积神经网络相比传统机器学习网络不同的特点：首先它是一个深层非线性系统的一个叠加，传统方法会更浅、拟合性能也更差，而卷积神经网络提供了一种方式——能够用理论性比较强、较稳定的方式训练出非线性系统；第二个好处在于它是一个端到端的系统，不需要再人为去设计各种特征，可以将精力都放在数据和模型两个层面。由此也带来第三个好处——低层次和高层次的特征级别，比如从视觉角度来说，将十层CNN拿出来具像化地去看，可以很明显看到，它第一层其实是low lever的特征，比如点、线等小局部的特征，而高层则会显现出一些结构化的特征，比如眼睛的样子、圆形、方形的概念，同样的在音频中也是如此。
3.算法框架
接下来介绍一下我们如何利用cnn进行视频分析：我们是把各种任务在inference层次做了参数共享和并对多任务进行了multi task learning。见上图， Forward Block是CNN的基本Blok，针对分割问题需要做Deconvolution的操作；对于识别问题，会在大的CNN架构上加一些Local CNN structure去做识别问题；而检测问题其实是识别问题在图像层面做进行遍历滑动；对应到视频分析，还需要进行物体跟踪。我们做了一个比较通用的模型，每一帧都有一些信息产生，我们将它们串联在一起，这里使用的是现在比较流行的RNN算法去做时序之间的拟合，最后总的输出就能够达到最后需要的全场景化的识别框架。
这样能带来几个好处：首先它的结构特别清晰，不是针对各个业务层来做的，更多是把它抽象成为几个核心的技术模块，这样就能极大效果的按照各种计算调优的方式来解决问题；第二点从实际经验来说，因为很多参数本身就是共享的，而所有视频进来都能够一次forward得到所有的结果，因此通过共享计算能够提高算法效率，并且通过多个相关任务共同学习来提高算法性能；最后对于视频分析来说比较大的一个问题是标注，视频级别的分析所需要数据的标注量很大，统一框架之后只需要做关键帧的标注就可以，因为在训练的过程中就会把数据前后帧串联起来。
4.三个核心维度——小、快、准
上面提到的框架可能大家都会在做，我这里特别提下人工智能研发的三个核心维度，这些问题可能更多是针对业务性的：首先是在移动端如何把模型变小，前两年用的比较多的方法是用低秩直接分解，而近两年一些新的网络架构本身效率各方面提升了很多；第二点是线上速度要快，毕竟对于直播来说，如果反映效果超过一分钟，可能监管层面就会有问题；第三个是核心指标问题，也就是inference效果必须要准，预测层肯定是从数据和模型两方面来去做优化，数据层面我们会更多希望业务部门来共享数据，而我们则侧重于模型的调优。总体而言，从目前AI核心研发纬度上来看，我们还是相信深度学习已经逐步取代各种传统方法。
5.深度学习原创的贡献
针对前面提到的问题，我们从13年开始做视频分析到现在也有一些比较原创的积累：首先是我们提出的NIN的structure，之前介绍经典的CNN的structure，它是输入层-卷积层-输出层-输入层……这样一个Building block，每层之间只有一层非线性层，在NIN中，我们将中间的每个卷积层都看作一个小的网络，也就是卷积操作不再是一个单层的卷积操作，将其定义成小的一个NewWork，在此过程中，它局部拟合的能力就大为增强了。在具体实现来说，我们可以把卷积操作并联到N个1×1的卷积，来合成比较大的一个小的NetWork。
在2016-2017，我们提出了Dual-path NetWork，这是建立在此前其他研究的基础上，把ResNeXt Network和Dense Network两条Path合并在一起。在实验和理论分析上，我们发现Res Network特别容易凝聚到具体概念上，缺少较好的泛化能力，因此我们在上下层之间引入了DenseNet，使得模型对特征的利用更加充分，我们把这个structure叫做双通路的神经网络，并利用他参加了今年的ImageNet定位竞赛。最后的定位检测任务错误率是6.2%，也就是一个图片中可能存在有一千种物体，对其中任意三个或者五个进行判断错误可能是6.2%，而头部指标会更低。
三、业务结合
1.人工智能与短视频业务
介绍完技术层面的实现，我们接下来一同看下实际业务的结合，360一直在布局短视频业务，大体分为几个层次：首先是短视频生产，我们需要提供比较便利的工具给UGC、PGC的生产者，这里会有一个快卷积的工具性产品，包括移动端和Web端。
生产完成后，从消费者角度来说需要各种分层性的问题，这时我们做了花椒相机增强现实类，提供美容、美颜、抠图等等功能，目前我们的重点更多慢慢转移到视频理解方面，这也是差异化的地方，理解层会细分为几个问题：人的识别、场景识别，包括对视频内容做标签化。到具体应用场景还会再做细分，比如针对分发任务来说，我们一个移动端APP快视频，并不需要做很直接、很明确的语义理解，它更多的是需要知道用户共性的问题，而用户共性来自于视频共性，因此所要做的就是把视频共性体现出来即可，那么我们的侧重点就不在于各种语义化标签，而是把共性问题体现出来。再往下比如短视频的理解上升到如何去做商业化的问题。
2.视觉相关研发
上图是视觉相关研发的总览，从我们内部来说现在分为几个大的业务块：首先是人脸分析，它也是在直播和短视频应用中最广泛的，因为人永远是视频和直播的一个主题，因此我们做了比较细致的人物属性分析比如性别、年龄、颜值、表情等，另外也在有美化或增强这些问题上进行核心攻坚。
另一部分是视频内容分析，即上面提到的检测、分割，而我们认为最重要的一部分内容是抠图，因为它提供了一个虚拟化的场景，可以把人和背景分割出来，给产品够提供很多想象的空间，而且这也是AR主打的概念——来源于生活，但比现实更丰满。此外我们也做了一些3D和SLAM相关的内容，这里就不做重点介绍。
图像识别
接下来我们结合例子来讲技术算法具体实现，这张图来自于ImageNet，它是一个标准的数据集——有一千多个类别、每个类别有一千到十万不同级别的视频图像数量，我们的目标是给定任何一张图都能够把它的标签找出来，知道图片里的内容是是什么，这就是一个标准数据集的问题。我们通过原图提取前面提到的卷积特征做预测，具体到业务场景来说，可能需要判断里面是否是一个黄色网站或是黄色图片，那么可以标注一堆图然后给出反例，通过制作和管理资源模型最后得到这样的效果。
但这样的方式带到视频分析中并不是特别合适，这里有一个比较明显的问题：因为前面提到的数据集其实是已经花费很大力气整理出来的，但在现实中业务数据很难对外公开，也没法找很多人来进行标注，尤其视频内容是非常难标注的。
视频分析——Tags
针对上面提出的问题，我们首先想到的方式是如何能够加快视频标注，当给定一组视频到通过模型最后产生数据，我们所需要的不是最后产出层的内容，而是用中间层的特征来做聚类模型，通过聚类出来的效果就可以看到共性，这样通过几十万级别的聚类效果去做各种标注，再对标注的数据做分类tag，这样就解决了两个问题：一是缺乏标注数据，二是没有良好的标注体系。目前我们已经用到短视频分发平台上，对推进指标提升的效果还是挺明显的。
人脸分析
我们在花椒直播做了人脸检测，首先是人脸上67个关键点的检测，这里比较难的是无法对主播进行控制，因为他会有各种姿态、遮挡、表情，并且主播来源也不同，那么在这个过程中要鲁棒的时刻跟踪到这67个点是很难的，我们当时更多是局部采样、局部增强。而有了这67个点就可以衍生出很多好玩的功能，比如换脸，而最常用的就是人脸识别。
短视频风格化
此外我们还在做短视频的风格化，比如给定一个真实的场景——可能是图片、也可能是视频，通过选定一些Style把两者结合变成虚拟化的、增强化的图像或视频，相比于每一种风格都要重新渲一个模型来说，它在产品化上的体验就比较差，因为每一个模型或模板都需要两三兆，而我们在后台只需要一个模型，通过给定不同参数来变化风格，而参数可能只有几百K，这里需要把用户自定义的风格图片上传到云端，通过云端训练完成后下载到手机本地做inference，整个过程从用户体验上来说是一个会是一个很实时，很顺畅的感觉。
以上是我今天的分享，大概从360的业务场景介绍了一些基础的视频分析算法和应用。希望后面能跟大家进行更深入的交流，谢谢。
WebRTCon 2018 8折报名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ad48193ebb24ed01a62af55e806b815/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baf215b19644077b1e0b2e5f7946c5bd/" rel="bookmark">
			vim常用命令总结（ideavim）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vim常用命令总结（ideavim） vim常用命令总结ideavim 插入命令删除命令复制命令选中命令光标移动功能命令标记命令 1. 插入命令 “i” 命令可以在当前光标之前插入文本。“I” 命令可以在当前行首插入文本。“a” 命令可以在当前光标之后插入文本。“A” 命令可以在当前行尾插入文本。“o” 命令可以在当前行的下面另起一行.“O” 命令(注意是大写的字母O)将在当前行的上面另起一行。“c” 修改，类似delete与insert的组和。删除一个字组、句子等之资料，并插入新建资料。“cc”修改整行的内容。“C” 删除游标所在位置到行末资料，并进入输入模式。“s” 删除游标所在之字元，并进入输入模式。“S” 删除游标所在之该行资料，并进入输入模式。“r” 用接於此指令之后的字元取代(replace)游标所在字元。如：ra将游标所在字元以 a 取代之。“R” 进入取代状态。 2. 删除命令 “x” 删除游标所在该字元。“X” 删除游标所在之前一字元。“dd” 删除一整行内容使用”dd”命令。删除后下面的行会移上来填补空缺。“J” 删除换行符。在Vim中你可以把两行合并为一行，也就是说两行之间的换行符被删除了。“D” 以行为单位，删除游标后之所有字元。“yy”使游标所在该行复制到记忆体缓冲区。 3. 复制命令 剪切、复制、删除 ”d” 剪切“y” 复制。“p” 粘帖，与 d 和 y 配和使用。可将最后d或y的资料放置於游标所在位置之行列下。移动文本 以”d”或”x”这样的命令删除文本时，被删除的内容还是被保存了起来。你还可以用p命令把它取回来。”P”命令是把被去回的内容放在光标之前，”p”则是放在光标之后。对于以”dd”删除的整行内容，”P”会把它置于当前行的上一行。”p”则是至于当前行的后一行。也可以对命令”p”和”P”命令使用命令记数。它的效果是同样的内容被取回指定的次数。这样一来”dd”之后的”3p”就可以把被删除行的3 份副本放到当前位置。复制文本（VIM编辑器内复制） “y”操作符命令会把文本复制到一个寄存器3中。然后可以用”p”命令把它取回。因为”y”是一个操作符命令，所以你可以用”yw”来复制一个word. 同样可以使用命令记数。如下例中用”y2w”命令复制两个word，”yy”命令复制一整行，”Y”也是复制整行的内容，复制当前光标至行尾的命令是”y$”。 4. 选中命令 查找与替换 % 查找“(”，“)”，“{”，“}”的配对符。 另外：将光标移动在选定单词下方按*，则可以选中此单词作为查询字符，可以避免输入一长串字符的麻烦。(vim) 大小写替换 首先用按V开启选择功能，然后用↑↓←→键来选定所要替换的字符，若是小写变大写，则按U;反之按u; 如果是选择单词，则可以在按v后，按w，最后按U/u,这样就可以将字符随意的改变大小写了，而不用删除后重新敲入。 5. 光标移动 “m”&lt;a-z&gt; 设置书签“`”（在Esc键下面）&lt; 移至书签处“0” 移至该行之首“$” 移至该行之末。“e” 移动到下个字的最後一个字母“w” 移动到下个字的第一个字母。“b” 移动到上个字的第一个字母。“^” 移至该行的第一个字元处。“H” 移至视窗的第一行。“M” 移至视窗的中间那行。“L” 移至视窗的最后一行。“G” 移至该文件的最后一行。 用”G”命令指定一个命令计数，这个命令就会把光标定位到由命令计数指定的行上。比如”33G”就会把光标置于第33行上。没有指定命令计数作为参数的话, “G”会把光标定位到最后一行上。”gg”命令是跳转到第一行的快捷的方法。“%” 另一个移动到某行的方法是在命令”%”之前指定一个命令计数比如”50%”将会把光标定位在文件的中间.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/baf215b19644077b1e0b2e5f7946c5bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2014f3db6929d8b48775feb1e629d1db/" rel="bookmark">
			(转)解决apt-get install E: 无法定位软件包问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在etc/apt 的sources.list 添加镜像源 deb http://archive.ubuntu.com/ubuntu/ trusty main universe restricted multiverse
deb http://cz.archive.ubuntu.com/ubuntu trusty main universe 然后 sudo apt-get update 接着安装就可以了
转载于:https://www.cnblogs.com/-1339513141/p/8441099.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a798285020c3aba91bdb6191b5da4a2/" rel="bookmark">
			字符串系列（一）——伟大的字符串Hash
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在刷省选时，我们时常会遇到一些字符串的题目。也有许多的算法供我们选择，如：
KMP、拓展KMP、最小表示法、Manacher、Trie、后缀数组、后缀自动机、AC自动机（树上KMP）等等等，日后我会逐一填坑。今天先来介绍一个最暴力且用途最大的——字符串Hash。
首先，要想学好Hash，必须要明白一件事：两个元素若全等，其哈希值必定也相等；但哈希值相等，两个元素未必全等（哈希值相等是两个元素全等的必要不充分条件）。
看了这句话我想大家都明白，Hash时要尽量使冲突概率趋近于0，即，尽量的满足其充分性。下面介绍一种Hash方法。
先取一固定值P（prime的首字母，可以看出这个P取质数最好，而且一般用大质数），把字符串看作一个P进制的数。（我想这个并不难理解，因为16进制中也包含着一些字母）然后取出另一固定值M，求出该P进制数对M取余的结果，即为字符串哈希值。M我们一般取2的64次方，但实际操作时呢我们不需要对M取模（取模是个效率极低的运算）。我们用unsigned long long类型保存哈希值，让其自然溢出就好，因为此类型是不会出现负数的（无符号位）。P的话我参考了李煜东前辈的给出的值——131或13331，此时冲突概率极低。
如果你还是不放心，那可以同时做好多组P与M，判断时多判断几次，如果所有的哈希值都相等，再得出结论。
在处理子串问题时，我们一般采用前缀和去维护哈希值（当然，你可以使用树状数组啊，平衡树啊，去动态维护整个序列，比如bzoj1014，后续我会给出题解）。这里介绍一个前缀和的方法。首先按照进制法则预处理出每一个前缀的哈希值，代码如下：
for(int i = 1; i &lt;= n; ++i) hash[i] = hash[i - 1] * P + str[i] - 'a'; 如果我们需要取出某段子串（str[l~r]）的哈希值，代码如下：
inline ull getsub(int l, int r) {return hash[r] - hash[l - 1] * bin[r - l + 1];} 也就是：hash[l~r] = hash[1~r] - hash[l - 1] * pow(P, r - l + 1);
这个bin数组也是ull类型的，bin[i]表示P的i次方64位自然溢出的结果，也就是：
hash[l~r] = hash[1~r] - hash[1~l - 1] * pow(P, r - l + 1); 为了效率，我们提前用O(n)的时间预处理了bin。我第一次做字符串Hash时（poj3974），自然是没有暴力算pow。我使用了快速幂【捂脸】，一个logn直接导致超时（可怕的logn）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a798285020c3aba91bdb6191b5da4a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5a8d9226aac1e28a7600179e92d99ea/" rel="bookmark">
			基于HttpClient实现RPC远程服务调用功能【SpringBoot项目】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是RPC? RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。
RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。
二、为什么要使用RPC？ 在大型项目开发的过程中，为了减轻服务器的负载就要进行分模块来布置项目，从开发到运行都不可能仅仅只是在一个服务器节点上的，它们会按照各个模块，比如前端，后端，数据库等等模块来搭建分布式系统。这时我们要考虑一个问题，当各个模块之间进行交互的时候该怎么办？这里我们举一个简单的例子，我们把一个醒目分为两个模块，用户信息模块，订单模块，当订单项目需要查询用户信息的时候怎么查询？这时我们可以用户信息模块设计一个用户信息的接口然后在订单项目中使用RPC进行远程服务调用该接口，这样就轻松实现了两个项目之间的访问。不过这种方式在有很多服务嵌套调用的时候效率会降低，所以尽量不要使用。
下面，我们来实现上面的这个例子，通过demo我们会很轻松的理解RPC远程调用。
三、实战 1.创建两个maven项目，添加springboot项目依赖。
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.8.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 根据我们上面的分析，要在订单系统中访问用户系统中的信息，我们应该在订单系统中实现RPC来调用用户系统中的接口，所以我们要在订单系统中添加HttpClient依赖：
&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;/dependency&gt; 2.我们搭建好项目后就开始编写代码，这里我们在DAO层写入固定的值，只是为了测试就不用访问数据库了。下面是用户系统中的代码：
UserEntity.java
public class UserEntity { private Integer id; private String username; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5a8d9226aac1e28a7600179e92d99ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4919ce0a52ded46e11b84e4cf750cba/" rel="bookmark">
			get和post的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GET和POST是HTTP请求的两种基本方法，HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。最直观的区别是：GET把参数包含在URL中，POST通过request body传递参数。数据量：GET传送的数据量较小，不能大于2KB。POST传送的数据量较大，一般默认为不受限制。安全性：传统的比较都是觉得GET安全性非常低，POST安全性较高。因为GET请求的数据会暴露在地址栏中，而POST请求则不会。效率：GET的执行效率比POST方法好。GET产生一个TCP数据包;POST产生两个TCP数据包。 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。那是否用get替换post？ 不行，因为：
GET与POST都有自己的语义，不能随便混用。
据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。
并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。
形象解释参考get与post的区别
建议： 1、get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式； 2、在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0d24519442bcfe455bbcb5caf6c6aab/" rel="bookmark">
			2-1000之间的完数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述： 编写程序显示2-1000之间的说有完数，所谓完数是指，该数的各因子之和正好等于该数本身。
代码： #include&lt;stdio.h&gt; int main() { //注释部分用于显示因子 //int c=0,temp[500]; for(int i=2;i&lt;=1000;i++) { int sum=1; for(int j=2;j&lt;=i/2;j++) { if(i%j==0) { sum+=j; //temp[c++]=j; } } if(sum==i) { printf("%d\n",i); } } } 注：选自武大2014年复试真题。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ef7e2d67277ed75096fdbf8eeb34bb7/" rel="bookmark">
			OpenCVSharp特征点匹配及全景拼接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前连续写了一些列关于OpenCV在Unity平台的入门基础，这次增加难度，来一个特征提取和拼接的案例。由于OpenCVForUnity没有实现Stitcher的功能，转而使用OpenCVSharp。可以去github的官方项目里找最新的OpenCVSharp.dll文件，不过官方提供的是.Net4.6版本（没有尝试是否可以自行编译成.Net3.5）。那我们就先把Unity项目设置为4.6的框架。
Player Settings -&gt; Other Settings -&gt; Configuration OpenCVSharp 对 Mat 和 Texture2D 转换没有做专门的API，所以我们先把这个复杂的转换过程做成一个工具类。
using UnityEngine; using OpenCvSharp; public class Utils { /// &lt;summary&gt; /// Mat转Texture2D /// &lt;/summary&gt; /// &lt;param name="mat"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Texture2D MatToTexture2D(Mat mat) { Texture2D t2d = new Texture2D(mat.Width, mat.Height); t2d.LoadImage(mat.ToBytes()); t2d.Apply(); //赋值完后为什么要Apply //因为在贴图更改像素时并不是直接对显存进行更改，而是在另外一个内存空间中更改，这时候GPU还会实时读取旧的贴图位置。 //当Apply后，CPU会告诉GPU你要换个地方读贴图了。 return t2d; } } Part.I 特征匹配 案例中我使用的是ORB特征提取，其他主流的算法还有SURF，SIFT，FAST、BRISK、FREAK等，当然数学层面上都已经通过OpenCV的函数实现了。写两个函数热热身，熟悉一下使用ORB进行特征点检测。
void Detect() { var gray = new Mat(Application.streamingAssetsPath + "/Textures/p1.jpg", ImreadModes.GrayScale); KeyPoint[] keyPoints = null; using (var orb = ORB.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ef7e2d67277ed75096fdbf8eeb34bb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e94c5de58f22e6074b29816a64d4957e/" rel="bookmark">
			电脑蓝屏提示unexpected store exception的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们使用电脑的过程中常常会遇到许多问题，对于许多不熟悉电脑的用户常常摸不着头脑，而部分用户在使用电脑时，电脑常常出现蓝屏的情况，并提示你的电脑遇到问题需要重新启动，与此同时，其报告错误代码为“unexpected store exception”，用户按照提示重新启动后，虽然能够解决解决此问题，但是其会常常反复出现此蓝屏提示，小编这里为您分享了详细的解决方法，遇到同样问题的用户赶紧来了解一下吧！
方法/步骤 1、如图，在我们使用电脑时，常常弹出如下的滥情提示，其错误代码提示为“unexpected store exception”，许多用户不知道是什么原因造成的，一般来说，造成此问题是由于sata硬盘驱动程序与系统出现了冲突所导致的。
2、其实，想要解决此问题，我们只需要打开卸载sata硬盘驱动程序即可，我们通过组合键"win+R"呼出运行窗口，在打开一栏中输入“devmgmt.msc”，点击确定，进入如下的设备管理器窗口，随后我们即可在IDE ATA/ATAPI控制器下找到如下的驱动程序，我们鼠标右击选择卸载，等待卸载完成。
3、用户卸载成功用户后其将显示为“标准 SATA AHCI 控制器”，其可能要求用户重启电脑，重启后可以解决，但有时可能无法进入系统，因此建议电脑小白不通过卸载的方式，小白用户可以到官网下载低版本来直接安并覆盖即可。
4、若用户原先使用win7、win8等其他Windows系统，未遇到过此问题，而是将系统升级至win10以后才遇到的，则是系统的兼容或者说bug问题，建议用户重新回到原先的系统。
5、另外，若用户加装内存条后，如果安装了两根内存条也可能会遇到此问题，这时需要需要取下一根内存条。
以上就是电脑蓝屏提示unexpected store exception的解决方法，步骤非常的简单，有需要的用户赶紧来了解一下吧！
原文地址： http://www.pc0359.cn/article/qita/74080.html
转载于:https://www.cnblogs.com/yechangzhong-826217795/p/8430448.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4a5ce5e83294f4ad17cc7179f9adfef/" rel="bookmark">
			apache 配置安装ssl证书实现https安全访问全过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		apache 配置安装ssl证书实现https安全访问全过程
安装证书（贴上未来智库站配置ssl的代码内容），官方的配置复杂且不具有通用性。 1.#修改httpd.conf文件 LoadModule ssl_module modules/mod_ssl.so
Include conf/extra/httpd-ssl.conf
#去掉上面两行前的"#"
2.打开extra目录下的httpd-ahssl.conf文件 将下载的证书四个文件放置在conf下的ssl目录。 httpd-ahssl.conf添加如下代码 Listen 443 https
&lt;VirtualHost _default_:443&gt; SSLEngine on ServerName www.7428.cn:443 SSLCertificateFile "${SRVROOT}/conf/ssl/214329625123456.pem" SSLCertificateKeyFile "${SRVROOT}/conf/ssl/214329625 123456.key" php_admin_value open_basedir "${SRVROOT}/htdocs/ www7428cn;C:/windows/TEMP" DocumentRoot "${SRVROOT}/htdocs/www7428cn" ErrorDocument 404 "/404/" # DocumentRoot access handled globally in httpd.conf # CustomLog "${SRVROOT}/logs/ssl_request.log" \ # "%t %h %{SSL_PROTOCOL}x %{SSL_CIPHER}x \"%r\" %b" &lt;Directory "${SRVROOT}/htdocs/7428cnwww"&gt; # Options Indexes Includes FollowSymLinks Options Includes FollowSymLinks AllowOverride AuthConfig Limit FileInfo Require all granted &lt;/Directory&gt; &lt;/virtualhost&gt; &lt;VirtualHost _default_:443&gt; SSLEngine on ServerName 7428.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4a5ce5e83294f4ad17cc7179f9adfef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6619748a8dfedacd4a86ab021faa5e06/" rel="bookmark">
			JTextField 默认文字提示功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当JTextField没有输入时，显示提示文字，类似于
通过实现FocusListener来实现。
import java.awt.Color; import java.awt.event.FocusEvent; import java.awt.event.FocusListener; import javax.swing.JTextField; public class JTextFieldHintListener implements FocusListener { private String hintText; private JTextField textField; public JTextFieldHintListener(JTextField jTextField,String hintText) { this.textField = jTextField; this.hintText = hintText; jTextField.setText(hintText); //默认直接显示 jTextField.setForeground(Color.GRAY); } @Override public void focusGained(FocusEvent e) { //获取焦点时，清空提示内容 String temp = textField.getText(); if(temp.equals(hintText)) { textField.setText(""); textField.setForeground(Color.BLACK); } } @Override public void focusLost(FocusEvent e) {	//失去焦点时，没有输入内容，显示提示内容 String temp = textField.getText(); if(temp.equals("")) { textField.setForeground(Color.GRAY); textField.setText(hintText); } } } 然后直接使用JTextField调用即可 JTextField jTextField = new JTextField(); jTextField.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6619748a8dfedacd4a86ab021faa5e06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb0c8a827b85df05d177d809ab4ba99c/" rel="bookmark">
			asp.net 在后台给前台的控件设置Style属性与坐标，后台设置CSS样式，后台获取前台控件坐标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先是后台给前台设置Style属性，设置控件坐标 前台控件： Html代码 &lt;asp:Label ID = "lblDSRText" Text = "当事人" runat = "server" name="label" Style="left: 300px; position: absolute;top:200px" BackColor="silver" &gt;&lt;/asp:Label&gt; 后台代码： C#代码 Response.Write(lblDSRText.Style["top"] );//获得Style中top的值，获得值可以这样获得，给前台控件赋值时要用Style["Style"] lblDSRText.Style["Style"] = "left: 500px; position: absolute;top:400px";//设置lblDSRText控件的样式 解释： lblDSRText为控件ID Style为设置lblDSRText控件的样式 ["Style"]为设置lblDSRText控件的节点 下边为转载： 教你在asp.net中动态变更CSS 在asp.net中，有的时候要动态变换CSS，比如有的时候做个性化页面，可以这样做 Html代码 &lt;head&gt; &lt;link id="MyStyleSheet" rel="stylesheet" type="text/css" runat="server" /&gt; &lt;/head&gt; 之后，在要更换CSS的页面中，使用如下代码 C#代码 Sub Page_Load(Sender As Object, E As EventArgs) If Not (IsPostBack) MyStyleSheet.Attributes.Add("href","/css/flostyle.css") End If Style与Attributes属性 作者： 1.Style属性 样式表(Cascading Style Sheets简称CSS)CSS通过其丰富的属性，将目标标签定义成各种样式，比如可以定义文字大小、标签位置等。在ASP.net中，同样可以使用样式表，不过HTML控件与web控件两者在使用方法上有所不同。下面将讨论HTML控件的样式定义。 由于HTML控件均由普通HTML标签衍生而来，所以定义HTML标签样式表的方法同样适用于HTML控件： Html代码 &lt;a style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb0c8a827b85df05d177d809ab4ba99c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46e37d99d8828f1d15bdf8c702718304/" rel="bookmark">
			unity 内嵌网页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 注意事项： 1.刷新网页时 ，如果网页和unity 有交互，不要用 browser.Reload() 用下面两行代码，而且顺序不能写反
browser.LoadURL("地址", true); browser.RegisterFunction("Func", JSCallback); unity 内嵌网页 插件Embedded Browser 可与unity互相调用 下载地址：https://www.assetstore.unity3d.com/#!/content/55459 1.新建Canvas/RawImage，命名为TestBroswer 2.给TestBroswer添加Broswer组件、GUIBroswerUI组件 3.创建TestExchange.cs 脚本， 给TestBroswer 添加TestExchange.cs脚本 TestExchange.cs：
void Start() { Broswer broswer=GetComponent&lt;Broswer&gt;(); //浏览器调用unity 方法,传值 broswer.RegisterFunction("HtmlCallUnity",CallByBroswer) broswer.LoadUrl("ip",true); } //当html执行HtmlCallUnity方法，就会调用 CallByBroswer prvite void CallByBroswer(JSONNode args) { Debug.Log("Broswer call unity value:"+args[0]); } void Update() { if(input.GetKeyUp(KeyCode.H)) { broswer.CallFunction("UnityCallHtml","unity value"); } } 4 html代码
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script&gt; //Unity调用网页函数 function UnityCallHtml(str) { console.log("UnityCallHtml: " + str); } //网页调用Unity函数 function HtmlCallUnity(str) { } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46e37d99d8828f1d15bdf8c702718304/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d9df0cad047fd446b86d09ee807bf1b/" rel="bookmark">
			c3p0多数据源与mybatis,spring想结合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接：http://blog.csdn.net/csdiary/article/details/49024827
然后在dao中
public static final String DATA_SOURCE_TO = "dataSource2"; public Properties getById(String id){
DBContextHolder.setDBType(DBContextHolder.DATA_SOURCE_TO); return (Properties) this.getSqlSessionTemplate().selectOne("Properties.select", id);
}
设置使用哪个数据源就可以调用了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65d0795e2c2f67c54f3fc95bc29f8da4/" rel="bookmark">
			安装phpstudy与原来的mysql冲突怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装phpstudy与原来的mysql冲突怎么处理
下载最新的phpstudy进入官方http://www.phpstudy.net/
如果下载的zkams是utf8版本，
phpstudy---其他选项菜单---MYSQL工具---设置或修改密码----字符集必须是UTF8
如果下载的zkams是GBK版本，
phpstudy---其他选项菜单---MYSQL工具---设置或修改密码----字符集必须是GBK
PHPSTUDY mysql的默认数据库用户和密码都是root
修改mysql密码
phpstudy---其他选项菜单---MYSQL工具---设置或修改密码
phpstudy安装的时候如果原来就安装了mysql了怎么办
在phpstudy管理界面上：
其他选项菜单----服务管理器----MYSQL----安装服务
然后
其他选项菜单----服务管理器----打开服务管理器----找到MYSQLa，然后手动启动这项。
如果启动失败，那就是端口3306冲突了，可以将原来mysql目录下的my.ini修改3306成3307，
或者停止原来的mysql。
智库论文资讯
phpstudy如何选择版本？
管理界面中间区域有一个切换版本的字眼，点击就会出现各个版本
zkams不兼容最低一个5.2的版本，其他均兼容。
笔之家
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99f3f2b62ffee75e0554b4f822293bf5/" rel="bookmark">
			数据结构与算法(Python)——常见数据结构Part5(二叉搜索树BST和AVL)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 在上一节part4我们熟悉了二叉树结构，以及其遍历算法，本节将继续学习常见的树结构，包括二叉搜索树和一种自平衡的二叉搜索树AVL。
1. 二叉搜索树 二叉搜索树(Binary Search Tree):二叉查找树，也称二叉搜索树、有序二叉树（ordered binary tree），排序二叉树（sorted binary tree）。它或者是一棵空树；或者是指具有如下性质的二叉树:
(1)若它的左子树不为空，则左子树上所有的节点的值均小于它的根节点的值 (2) 若它的右子树不为空，则右子树上所有结点的值均大于它的根结点的值(3) 它的左、右子树也分别为二叉搜索树。
上面的定义是一种递归定义，例如下图所示为一棵BST:
定义二叉搜索树如下:
class BinarySearchTree(BinaryTree): """ 二叉搜索树 """ def __init__(self): self.root = None 1.1 插入操作 插入二叉树时，插入元素需要与树中已有元素对比，插入到合适位置，以保持二叉树的特性，这个过程可以看做是一个递归的过程，插入元素为e, 插入节点从树的根节点开始，这一过程描述为:
case 1: e如果比当前节点大，则与当前节点的右孩子的根节点比较,即当前节点右孩子设为当前节点，继续比较； case 2: e如果比当前节点小，则与当前节点的左孩子的根节点比较,即当前节点左孩子设为当前节点，继续比较； case 3: e如果与当前节点相等，则不插入。
这个过程即可使用迭代实现，也可以递归实现，一般采用递归比较简洁，描述为:
def add(self, value): if not self.root: self.root = TreeNode(value) return True else: return BinarySearchTree.__add_value(self.root, value) @staticmethod def __add_value(node, value): if not node: return False if node.data == value: return False # duplicate elif value &lt; node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99f3f2b62ffee75e0554b4f822293bf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0537bf17ac7d8f0f179c4ac2092961e/" rel="bookmark">
			走着走着，就散了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		感觉就像做梦一般，昨天还在室友家里一起唠嗑，现在又回到往常平静般的生活。
从补习那年，认识的室友到现在还能愉快的聚在一起实在是一种缘分，回想到补习那年和这些室友度过的那段艰难岁月现在想一想就觉得时间就像一把杀猪刀，真的是任他宰割，你只能接受、面对时间带来的残痕。
昨天我们谈着各自的走向，有的选择考研、有的选择直接工作，不得不承认， 没一条选择代表不同的人生走向，二我么呢只能去接受并去规划好自己的人生方向，虽然谁也不知道今后的人生会是什么样，但是至少我们还能在各自都有的时间内难得的聚在一起，对于我而言，其实能有几个说的来的朋友就足矣了。
想想我们几个的专业大多是IT，其他的几个差不多也是工科类的，在专业上可能没有什么交集，但是在一起还是能聊得来的，可能几年就是我们几个最后的一次聚会，如果以后要聚在一起这么齐可怕是很难的了，不过还是真的挺开心 的还能在一起聚一次会，希望各自好好努力，加油。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57a64d6f71f1f2b85ee2af7aed1540d3/" rel="bookmark">
			交叉验证与训练集、验证集、测试集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：李航–《统计学习方法》 https://www.jianshu.com/p/7e032a8aaad5 https://zhuanlan.zhihu.com/p/20900216?refer=intelligentunit
训练集、验证集、测试集 如果给定的样本数据充足，我们通常使用均匀随机抽样的方式将数据集划分成3个部分——训练集、验证集和测试集，这三个集合不能有交集，常见的比例是8:1:1。需要注意的是，通常都会给定训练集和测试集，而不会给验证集。这时候验证集该从哪里得到呢？一般的做法是，从训练集中均匀随机抽样一部分样本作为验证集。
训练集 训练集用来训练模型，即确定模型的权重和偏置这些参数，通常我们称这些参数为学习参数。
验证集 而验证集用于模型的选择，更具体地来说，验证集并不参与学习参数的确定，也就是验证集并没有参与梯度下降的过程。验证集只是为了选择超参数，比如网络层数、网络节点数、迭代次数、学习率这些都叫超参数。比如在k-NN算法中，k值就是一个超参数。所以可以使用验证集来求出误差率最小的k。
测试集 测试集只使用一次，即在训练完成后评价最终的模型时使用。它既不参与学习参数过程，也不参数超参数选择过程，而仅仅使用于模型的评价。 值得注意的是，千万不能在训练过程中使用测试集，而后再用相同的测试集去测试模型。这样做其实是一个cheat，使得模型测试时准确率很高。
交叉验证 之所以出现交叉验证，主要是因为训练集较小。无法直接像前面那样只分出训练集，验证集，测试就可以了（简单交叉验证）。 需要说明的是，在实际情况下，人们不是很喜欢用交叉验证，主要是因为它会耗费较多的计算资源。一般直接把训练集按照50%-90%的比例分成训练集和验证集。但这也是根据具体情况来定的：如果超参数数量多，你可能就想用更大的验证集，而验证集的数量不够，那么最好还是用交叉验证吧。至于分成几份比较好，一般都是分成3、5和10份。
交叉验证的实现 首先我们给出下面的图 图上面的部分表示我们拥有的数据，而后我们对数据进行了再次分割，主要是对训练集，假设将训练集分成5份（该数目被称为折数，5-fold交叉验证），每次都用其中4份来训练模型，粉红色的那份用来验证4份训练出来的模型的准确率，记下准确率。然后在这5份中取另外4份做训练集，1份做验证集，再次得到一个模型的准确率。直到所有5份都做过1次验证集，也即验证集名额循环了一圈，交叉验证的过程就结束。算得这5次准确率的均值。留下准确率最高的模型，即该模型的超参数是什么样的最终模型的超参数就是这个样的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d32e563f6c7c8438055521a476df481/" rel="bookmark">
			python pip install 报错PermissionError: [WinError 5] 拒绝访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新安装python3.6版本后使用pip安装第三方模块失败，报错信息如下：
C:\Users\linyfeng&gt;pip install lxml Collecting lxml Downloading http://pypi.doubanio.com/packages/fb/41/b8d5c869d01fcb77c72d7d226a847a3946034ef19c244ac12920b71cd036/lxml-3.8.0-cp36-cp36m-win32.whl (2.9MB) 100% |████████████████████████████████| 2.9MB 4.6MB/s Installing collected packages: lxml Exception: Traceback (most recent call last): File "c:\program files (x86)\python36-32\lib\site-packages\pip\basecommand.py", line 215, in main status = self.run(options, args) File "c:\program files (x86)\python36-32\lib\site-packages\pip\commands\install.py", line 342, in run prefix=options.prefix_path, File "c:\program files (x86)\python36-32\lib\site-packages\pip\req\req_set.py", line 784, in install **kwargs File "c:\program files (x86)\python36-32\lib\site-packages\pip\req\req_install.py", line 851, in install self.move_wheel_files(self.source_dir, root=root, prefix=prefix) File "c:\program files (x86)\python36-32\lib\site-packages\pip\req\req_install.py", line 1064, in move_wheel_files isolated=self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d32e563f6c7c8438055521a476df481/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b867d2d482a12147cfc6085cf7f0a6ba/" rel="bookmark">
			Kettle的使用分享（重点是看：“常用组件介绍”的官方链接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（重点是看：“常用组件介绍”的官方链接，具体讲解了每个页面每个功能项的作用）
一、下载与安装 下载地址：https://sourceforge.net/projects/pentaho/files/Data%20Integration/ 将下载的zip文件解压到任意路径（最好是英文不带空格的路径，以免引起乱码等未知问题） 文件结构：(不包括打马赛克的文件夹)
lib目录：存放jar包，包括jdbc驱动包。 pwd目录：Kettle集群配置文件。 samples:自带的示例。 simple-jndi:JNDI连接的配置。 Carte.bat / Carte.sh 启动集群命令。 Encr.bat / Encr.sh Kettle提供的加密算法。 Kitchen.bat / Kitchen.sh 运行Job的命令。 Pan.bat / Pan.sh 运行转换的命令。 set-pentaho-env.bat / set-pentaho-env.sh 设置环境变量脚本。 Spoon.bat / Spoon.sh 启动KettleUI界面。 SpoonDebug.bat / SpoonDebug.sh 以debug方式启动Kettle。 安装JDK，设置JAVA_HOME变量并加入环境变量。 Windows 下双击Spoon.bat启动Kettle(Linux下执行sh spoon.sh)
二、启动 kettle在启动时候，会加载环境变量，jar包等初始化信息，并会生成一个.kettle windows下默认是在C:\Users\用户名.kettle Linux默认路径是~/.kettle 设置KETTLE_HOME=F:\data-integration-7.0 可改变此文件生成的路径 Windows：%KETTLE_HOME%.kettle。比如：F:\data-integration-7.0.kettle Linux： KETTLEHOME.kettle此文件夹下面文件说明：kettle.properties，变量的定义文件。比如：STARTDATE=2017−07−01在转换/job里面这样使用变量, {START_DATE}. repositories.xml: 存储设置的资源库信息。 shared.xml： 存储共享的对象信息。比如：db connecttions，partitions，steps等 其它文件无关紧要， .languageChoice，语言设置信息。 .spoonrc Kettle的工作区属性设置信息。如：背景色，字体等. db.cache-* 数据库缓存信息。
创建资源库 不同版本创建方式不一样，在Kettle 7.0里面，点右上角的Connect，弹出创建对话框。 这里选择Other Repositories。
然后选择File Repository （不选择Database Repository是因为无法进行版本控制） 然后点Get Started 连接资源库后，打开或者保存都会只显示相对路径 设置资源库的前提下，如果打开一个任务或者是转换，在保存时候，打开相应的属性界面(双击空白处也可打开)如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b867d2d482a12147cfc6085cf7f0a6ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f76409c527ee8e31f4410401e52d2ac6/" rel="bookmark">
			[matlab] Matlab绘图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.plot函数 plot(x,y,desc,PropertyName,PropertyValue...) 1.1线条形状 符号（线型）含义.点-实线–虚线-.画点线:点线*/x/+星号/x号/+号s/d/p/h正方形/菱形/五角星/六角星^/ &lt; /&gt;三角形 1.2线条颜色 b/g/r/c/m/y/k/w 分别代表蓝色、绿色、红色、青色、品红色、黄色、黑色、白色 1.3修饰命令集 变量含义LineWidth曲线线宽（数值）MarkerEdgeColor标记点边框线条颜色（颜色字符）MarkerFaceColor标记点填充颜色（颜色字符）MarkerSize标记点大小 plot(x,y,'k:','Linewidth',1.2,'MarkerSize',2) 1.4同一个坐标系下绘制多个线段 hold on命令
1.5绘制子图 subplot(3,4,1) plot.... subplot(3,4,2) plot.... 1.6添加标题，横纵坐标，线条描述 plot(x,y1) title('这是图一') xlabel('这是x轴') ylabel({'这是y轴';'this is y label'})%双行显示 legend('这是图例') legend(['这是图例',sprintf('\n'),'this is label'])%多行图例 1.7设置横纵坐标范围 plot(x,y) axis([xmin xmax ymin ymax])%设置横纵坐标范围 1.8同一个图绘制两个纵坐标不同的曲线 plotyy(x,y1,x,y2,'plot') legend(['图例一',sprintf('\n'),'one'],'图例二') [AX,HDv1,ADv1]=plotyy(x,y2,x,y1,'plot') set(AX(1),'ylim',[-10,10]);%设置纵坐标范围 set(AX(2),'ylim',[0,2]);%设置纵坐标范围 1.9添加网格 plot(x,y) ... grid on 2.三维图形绘制 2.1曲线图绘制 t=-1.1*pi:0.008*pi:1.1*pi; plot3(cos(2*t).*sin(2*t),sin(2*t),t,'rp') xlabel('x') ylabel('y') zlabel('z') title('title') legend('图例') grid on 2.2曲面图绘制 mesh(x,y,z,C) %其中x，y为向量，z是length(x)*length(y)的矩阵，以矩阵C来进行颜色设置 %图形颜色深浅与z的高度成正比 z=peaks(35) mesh(z) meshc(z)%在网格线的下方绘制一个等值线图 meshz(z)%在网格线的周围绘制一个窗帘图 3.饼状图与条形图 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f76409c527ee8e31f4410401e52d2ac6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4443955332f11bdab183b75f17b545bd/" rel="bookmark">
			could not open `D:\java\lib\amd64\jvm.cfg&#39;解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题介绍：
JDK安装好配置好后输入javac可以显示安装好的程序，但执行javac -version会出现 could not open `D:\java\lib\amd64\jvm.cfg' 问题
解决方法：
删除C:\windows\system32下的 java.exe、 javaw.exe、javaws.exe三个文件
点击查看原文
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51b51ebaa939abadefcc4d76088d7edd/" rel="bookmark">
			Qt程序打包（使用windeployqt工具加入程序所需要的依赖库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.简介：
Qt官方IDE(集成开发环境)使用的是动态链接库的方式，发布可执行文件exe时，需要添加一些库，也就是我们常见的dll文件，如果我们不去添加这些dll文件，发布的exe很可能在别人的机器上无法运行，而如果我们自己去手动地添加dll,很可能添加不全。因此Qt开发环境里自带了一个叫做windeployqt.exe的工具，通过这个工具我们就能实现自动添加Qt程序所需要的一些库文件了。下面以Qt 5.9.2+MinGW开发环境为例，演示如何操作windeployqt工具实现自动添加库。
第一步：找到windeployqt工具：
从开始菜单--&gt;找到Qt Creator 4.4.1点击右键--&gt;更多--&gt;打开文件位置--&gt;5.9.2--&gt;MinGW 5.3.0(32-bit)--&gt;Qt 5.9.2 for Desktop(MinGW 5.3.0 32-bit)从这里执行windeployqt工具自动添加库文件
集成开发环境QtCreator生成图形化界面程序exe大致可以分为两类：Qt Widgets Application 和Qt Quick Application
下面重点讲述第一种Qt Widgets Application的执行windeployqt.exe的方法
1、Qt Widgets Application
1）首先使用Qt Creator新建一个Qt Widgets Application项目，直接使用默认的QMainWindow程序就可以了，项目名字假设叫untitled,然后以release方式编译生成exe.
2)生成的程序运行正常之后，找到项目生成目录，比如项目源码路径：E:\Qt Project\,进入他的生成目录，拷贝出exe文件，例如放在E:\QtApp中。
此时点击发现执行不了
第二步：然后用上面第一步的方法找到windeployqt工具
a.输入命令 ：cd /d E:\QtApp 进入目录
b.然后使用 windeployqt 工具命令：windeployqt untitled.exe(可以直接拖动exe文件到黑框)，就可以看到自动添加库的过程了
c.之后就可以看见windeployqt 工具自动复制的插件文件夹和dll文件、qm文件。这时候得到的就完整的可执行程序发布集合，依赖关系都解决好了
此时再点击untitled.exe是可以运行的
2、Qt Quick Application 由于Qt Quick Application用的比较少，所以只简单地介绍一下，如有需求可以联系我一起探讨一下，QQ:1126502922 新建方式和生成Widgets程序相同，只是在查找依赖的时候不同，需要使用命令windeployqt TestQt.exe --qmldir 指定qml目录，进行复制依赖，之后打包方式也相同。
参考文章
http://blog.csdn.net/graceland525/article/details/52167944
侵删
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b7a900028fdbc506203c46fc8bf3460/" rel="bookmark">
			中国移动光猫无线路由一体机如何再接另外一个无线路由器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将无线路由器连接光猫。用一条网线一端接入光猫网口1或网口3或网口4,另一端接入无线路由器WAN接口.
将无线路由器连接电脑。用一条网线一端接入无线路器LAN接口，另一端插入电脑。
光猫的默认地址为192.168.1.1，所以无线路由器的LAN口需要配其他网段的地址。
配置方法：登陆到无线路由器，IP设置为192.168.2.1
WAN口设置。由无线路由器的网络参数——WAN口设置——WAN口连接类型：选择动态IP完成以上步骤后就可以通过路由器上网了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/518418c7f550b548e17a6413b4e9dec9/" rel="bookmark">
			算法----句子翻转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述 给定一个句子（只包含字母和空格）， 将句子中的单词位置反转，单词用空格分割, 单词之间只有一个空格，前后没有空格。 比如： （1） “hello xiao mi”-&gt; “mi xiao hello” 输入描述: 输入数据有多组，每组占一行，包含一个句子(句子长度小于1000个字符) 输出描述: 对于每个测试示例，要求输出句子中单词反转后形成的句子 示例1 输入 hello xiao mi 输出 mi xiao hello
#include&lt;iostream&gt; #include&lt;string&gt; #include&lt;stack&gt; using namespace std; int main() { string str; stack&lt;string&gt;s; while(cin&gt;&gt;str){ s.push(str); } while(s.size()!=1){ cout&lt;&lt;s.top()&lt;&lt;" "; s.pop(); } cout&lt;&lt;s.top()&lt;&lt;endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a098e2f6c0f80f4bbad2c4ea16ac0880/" rel="bookmark">
			微信公众号获取微信的access_token出现失效情况处理。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信access_token是公众号的全局唯一票据，公众号调用各接口时都需使用access_token。正常情况下access_token有效期为7200秒，重复获取将导致上次获取的access_token失效。
公众号可以使用AppID和AppSecret调用本接口来获取access_token。
http请求方式: GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET
正常返回 {“access_token”:”ACCESS_TOKEN”,”expires_in”:7200}
正常情况下，我们基本上都是把 access_token 本地缓存化，在缓存时间内进行调取缓存使用，这样可以保证在一定时间内不在请求微信接口，提交功能的访问效率等等。最近遇到一个问题，网站的微信模块授权等等都是正常进行授权访问，但是突然某一天微信授权全部都报警了，所有用户显示的都是授权失败，追到底最后就是根据access_token获取用户信息这个接口一直返回的是错误信息。也就是access_token失效了。但是access_token生成这一块一直都是按照正常的过期时间去缓存，缓存失效在请求接口，缓存本地。但是怎么突然会失效呢？这一个非常奇怪的问题，解决办法：
1.确保最近没人修改此微信模块的程序。
2.在没人修改更新程序的前提下，去微信生成access_token缓存的地方写文件，每生成一次写一次日志文件。通过一段时间日志记录，分析我的日志发现了问题。有时候在一秒内有多次请求access_token的接口。这就是并发了，也就是有并发请求access_token接口。
针对并发请求access_token 的接口，微信方处理肯定是有并发处理的，但是我们的程序在存access_token缓存的时候是否考虑了并发，如果没有考虑，有时候我们存储的缓存未必是最后一次请求的结果，这样将直接导致access_token失效，导致相关功能程序出现bug。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fe635ca6b75ebe51b673864f12d13f7/" rel="bookmark">
			Snmp弱口令检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先有了snmputil工具，然后执行命令： Snmputil.exe walk IP public .1.3.6.1.2.1.1
snmputil.exe walk 对方IP public .1.3.6.1.2.1.25.4.2.1.2??//**进程列表 snmputil.exe walk 对方IP public .1.3.6.1.4.77.1.2.25.1.1??//**用户列表 snmputil.exe get 对方IP public .1.3.6.1.4.77.1.4.1.0??//**域名 snmputil.exe walk 对方IP public .1.3.6.1.2.1.25.6.3.1.2??//**安装的软件 snmputil.exe walk 对方IP public .1.3.6.1.2.1.1??//**系统信息
参考1:http://blog.chinaunix.net/uid-29353685-id-4160768.html 参考2：http://blog.csdn.net/archersaber39/article/details/78932252
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd5ad9fb8795c5c04ccaa3bd0f5d9446/" rel="bookmark">
			runtime  error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		runtime error （运行时错误）就是程序运行到一半，程序就崩溃了。 比如说： ①除以零 ②数组越界：int a[3]; a[10000000]=10; ③指针越界：int * p; p=(int *)malloc(5 * sizeof(int)); *(p+1000000)=10; ④使用已经释放的空间：int * p; p=(int *)malloc(5 * sizeof(int));free(p); *p=10; ⑤数组开得太大，超出了栈的范围，造成栈溢出：int a[100000000];一般来说，在 oj上做题都把数组设成全局变量，减少5出现的可能。
有的时候再出现这样的错误还会给提示 Runtime Error(ARRAY_BOUNDS_EXCEEDED) // array bounds exceed 数组越界 Runtime Error(DIVIDE_BY_ZERO) //divisor is nil 除零 Runtime Error(ACCESS_VIOLATION) //illegal memory access 非法内存读取 Runtime Error(STACK_OVERFLOW) //stack overflow 系统栈过载 10 这样可以照着上面查找错误。以上内容直接赋值粘贴别人的博客，方便自己查阅
在G++编译器main函数必须返回整数0,如果返回1被操作系统认为是不正常结束的还是会出现Runtime Error.
在处理问题的时候一定要考虑边界，本人在做大整数加法的时候测试案例就有 0+0=0，导致我的程序逻辑没错但是一直过不了，花了一晚上都没有找出问题所在，第二天看别人的程序才发现自己没有处理的边界情况。血的教训.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdca2193a246bdd9b2dbdc2dfaf87790/" rel="bookmark">
			后台执行命令 nohup 以及强制结束进程命令 kill
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过终端远程操作服务器时，难免要使特定进程处于持续运行状态，例如深度学习训练网络参数，但又不可能长时间不间断操作终端，我们希望将进程保持后台持续运行，这里提供两个思路：（1）docker 内运行，退出但不终止程序；（2）nohup 命令与 &amp; 结合。
这里只讲第二个思路：nohup 命令与 &amp; 结合。
举个例子，我们需要保持 test.py 程序的持续运行（用于长时间训练神经网络），并且将控制台输出重定向到日志文件中，那么如下命令可以轻松办到：
nohup python test.py &gt; log.txt &amp; 在使用 nohup 后台运行命令之后，需要使用 exit 正常退出当前账户，这样才能更好地保证命令一直在后台运行。
上述进程保持持续运行一段时间后，若想停止运行，即杀掉该进程，有如下操作：
ps -ef | grep python 通过用户名以及程序名等信息找到对应的 PID，使用 kill 命令强制终止进程（若PID为2223）：
kill -s 9 2223 由此便完成了对进程的强制结束。kill 命令实际上是很常见的 linux 命令，在很久之前也就接触过，这里作为总结和回顾，也一并作了相应介绍。更多技巧操作，后续不断更新！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/007cdaa6558b11fdf093c3e95a2195ba/" rel="bookmark">
			GPU状态监测 nvidia-smi 命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行深度学习实验时，GPU 的实时状态监测十分有必要。今天详细解读一下 nvidia-smi 命令。
上图是服务器上 GeForce GTX 1080 Ti 的信息，下面一一解读参数。 上面的表格中的红框中的信息与下面的四个框的信息是一一对应的：
GPU：GPU 编号； Name：GPU 型号； Persistence-M：持续模式的状态。持续模式虽然耗能大，但是在新的GPU应用启动时，花费的时间更少，这里显示的是off的状态； Fan：风扇转速，从0到100%之间变动； Temp：温度，单位是摄氏度； Perf：性能状态，从P0到P12，P0表示最大性能，P12表示状态最小性能（即 GPU 未工作时为P0，达到最大工作限度时为P12）。 Pwr:Usage/Cap：能耗； Memory Usage：显存使用率； Bus-Id：涉及GPU总线的东西，domain:bus:device.function； Disp.A：Display Active，表示GPU的显示是否初始化； Volatile GPU-Util：浮动的GPU利用率； Uncorr. ECC：Error Correcting Code，错误检查与纠正； Compute M：compute mode，计算模式。
下方的 Processes 表示每个进程对 GPU 的显存使用率。
第二个命令：nvidia-smi -L 该命令用于列出所有可用的 NVIDIA 设备信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1a6867d27e4f8916e10338acc291ae2/" rel="bookmark">
			Intellij IDE使用 ideavim，不能复制文档到系统粘贴板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vim的yank命令默认不会复制到系统粘贴板，而是粘贴到寄存器。你可以使用* 或　+寄存器来访问系统粘贴板。
在~/.ideavimrc (如果不存在就创建) 中添加下列选项
set clipboard+=unnamed
这是标准vim的特性，对于ideavim,除了配置文件的名字不同没有其他特殊的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f97072402ad8c9e20f0c9736af357ad/" rel="bookmark">
			mysql在Linux下的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mysql 5.7.20安装配置方法图文教程(Linux)
1. 系统约定
安装文件下载目录: /data/software
Mysql目录安装位置: /usr/local/mysql
数据库保存位置: /opt/mysql/data
日志保存位置: /data/log/mysql
2. 下载mysql
在官网: https://dev.mysql.com/downloads/mysql/ 中,选择以下版本的mysql下载:
执行如下命令(直接下载到服务器上):
#mkdir /data/software
#cd /data/software
#wget http://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.20-linux-glibc2.12-x86_64.tar
3. 检查数据库文件是否存在,如果存在则删除.
[root@localhost ~]# rpm -qa | grep mysql mysql-5.7.20-linux-glibc2.12-x86_64
[root@localhost ~]# rpm -e mysql-5.7.20-linux-glibc2.12-x86_64 --nodeps
4. 检查mysql组和用户是否存在,如不存在则创建.
[root@localhost ~]# cat /etc/group | grep mysql
[root@localhost ~]# cat /etc/passwd | grep mysql
(下图是mysql组和用户存在:)
// useradd -r 参数表示mysql用户是系统用户,不可用于登录系统.
[root@localhost ~]# groupadd mysql
[root@localhost ~]# useradd -r -g mysql mysql
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f97072402ad8c9e20f0c9736af357ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71af90cb8a83cfc8a9255a611d541bbb/" rel="bookmark">
			Mybatis报“无效字符”的错的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 mybatis报ORA-00911: 无效字符。原因是：在mapper配置中有“；”。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38e9104e548e57477eda459415a799e1/" rel="bookmark">
			千分位分隔数字并自定义保留小数位数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		功能：可实现不同符号分隔数字，可自定义分隔后数字保留的小数位数。
实现思路 使用正则，用数字中的小数点做匹配尾部参考，来匹配某个数字后面的一个或多个连续3位数字，如果匹配到把该数字替换成自身加分隔符，如下：
示例 1、 分隔数字：123456.1
解释：3和.之间有一个连续3位数字（456），那么给3后面添加一个分隔符得到结果：123,456.1。
2、分隔数字：1234567.1
解释：1和.之间有两个连续3位数字（234和567），那么给1后面添加一个分隔符，然后数字4后面也存在一个连续三位数字（567），那么也给4后面添加一个分隔符，最终得到结果1,234,567.1
匹配的正则表达式 /(\d)(?=(\d{3})+\.)/g; 这里最难理解的就是(?=(\d{3})+\.)，且看语法： x(?=y)：正向肯定查找，匹配后面带有y的x项目 那么在这里意思是：查找一个和“.”之间带有一个或多个连续3位数字的数字（x） 复制代码 最终实现 /** *num 要分隔的数字（必填） *n 保留的小数位数（可选） *symbol 分隔数字使用的符号（可选，默认为","） */ function splitNum(num,n,symbol) { if(!num)throw new Error('splitNum需要传入一个待转换的数据'); if(typeof num!=='number')throw new TypeError('num参数应该是一个number类型'); if(n&lt;0)throw new Error('参数n不应该小于0'); var hasDot=parseInt(num)!=num;//这里检测num是否为小数，true表示小数 var m=(n!=undefined&amp;&amp;n!=null)?n:1; num=m==0?num.toFixed(m)+'.':hasDot?(n?num.toFixed(n):num):num.toFixed(m); symbol=symbol||','; num=num.toString().replace(/(\d)(?=(\d{3})+\.)/g,function(match, p1,p2) { return p1 + symbol; }); if(n==0||(!hasDot&amp;&amp;!n)){//如果n为0或者传入的num是整数并且没有指定整数的保留位数，则去掉前面操作中的小数位 num=num.substring(0,num.indexOf('.')); } return num; } 复制代码 难点解惑
1、也许有人会问，这里是用“.”号做参考进行匹配的，如果传进来的数字是一个整数呢，不就没“.”号了吗，所以在方法内部定义了m变量使其在操作过程中总能有个“.”号。
2、num=m==0?num.toFixed(m)+'.':hasDot?(n?num.toFixed(n):num):num.toFixed(m);
num=m==0?num.toFixed(m)+'.':hasDot?(n?num.toFixed(n):num):num.toFixed(m); 作用：这里的操作保证的是小数传n、小数不传n、整数传n、整数不传n四种情况都能正确返回小数位数 详解： 1、如果m为零（传入n=0）则直接经toFixed操作后再后面补“.” 2、如果m不为0， a、如果传入数为小数 a'、如果传了n表示要保留小数，那么需要num.toFixed(n) b'、如果没传n表示不需要对小数进行操作，直接返回原num b、如果传入数为整数 a'、直接对num进行toFixed(m)操作 复制代码 说明：该方法只适用于常用数字的操作，当数字超过一定位数时产生的精度问题这里暂不做处理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38e9104e548e57477eda459415a799e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba2974acf01a6bcc632b23926aeb6a9d/" rel="bookmark">
			C语言 extern 数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在一个文件中定义一个字符数组 （如 char data[100] )，在另一个文件使用extern引用的方式。 test.cpp
// char data[100] = {10}; char data[100] = {0, 0, 0, 0，1}; char data[100] = {0, 0, 0, 1}; main.cpp
#include &lt;iostream&gt; #include &lt;string.h&gt; extern char *data; //extern char data[]; int main(int argc, char** argv) { const char *src = "123456789"; // strncpy(data, src, strlen(src)); // for (int i = 0; i &lt; strlen(src); ++i) { // std::cout &lt;&lt; data[i] &lt;&lt; std::endl; // // } std::cout &lt;&lt; (unsigned int)data &lt;&lt; std::endl; return 0; } 如果在main文件中使用extern char *data, 编译不回出错，先让char data[100] = {10};， 然后打印data的值是10， 所以猜测main文件中data的值是test文件data指针指向地址内容，继续验证让char data[100] = {0, 0, 0, 0，1};，打印的值是0，再让char data[100] = {0, 0, 0，1};，打印的值是16777216（就是小端模式下的 0x1000000)，所以引用方式是错误，编译器把数组的内容解释为指针值（地址），只取数组的前4个字节（32位模式）。 应该保持类型匹配，使用extern char data[]，编译器就会把data值设置为数组首地址。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed1713338515355be21405c5197eb982/" rel="bookmark">
			Vim快速移动光标至行首和行尾 、第一行和最后一行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vi中跳到文件的第一行和最后一行 由于vi编辑器不能使用鼠标，所以一个大文件如果要到最后一行只用键盘下键的话会是一个很痛苦的过程，还好有各种比较快捷的方法归我们使用：
1. vi 编辑器中跳到文件的第一行：
a 输入 :0 或者 :1 回车
b 键盘按下 小写 gg
2.vi 编辑器跳到文件最后一行：
a 输入 :$ 回车
b 键盘按下大写 G
c 键盘按 shift + g (其实和第二种方法一样)
Vim快速移动光标至行首和行尾
1、 需要按行快速移动光标时，可以使用键盘上的编辑键Home，快速将光标移动至当前行的行首。除此之外，也可以在命令模式中使用快捷键"^"（即Shift+6）或0（数字0）。
2、 如果要快速移动光标至当前行的行尾，可以使用编辑键End。也可以在命令模式中使用快捷键"$"（Shift+4）。与快捷键"^"和0不同，快捷键"$"前可以加上数字表示移动的行数。例如使用"1$"表示当前行的行尾，"2$"表示当前行的下一行的行尾。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f19346f0284a182decb0e28afe8be3a6/" rel="bookmark">
			MMORPG手游制作-任务10.C#基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		属性：
自动属性：
构造函数：
方法：
事件=特殊的委托
1.定义委托 2.定义事件
3.执行方法
protected ：继承类可以访问
子类访问：可以使用base关键字
引用类型和值类型： 对象为引用类型，改变引用
sting类型的 特殊
break 跳出循环 continue 进行下一次循环 return用于方法值的返回
集合删除数据方法：
枚举：
使用枚举：
扩展方法：静态类的静态方法
写法：xx（this xxx）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9570c3890c9d43582554bf1799c9716f/" rel="bookmark">
			数据结构中双向链表的基本操作(源代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef int Elemtype; typedef struct Node{ Elemtype data; struct Node *prior; //前驱指针 struct Node *next;	//后继指针 }Node,*LinkList; //创建头结点 void create_ListHead(LinkList *pHead)	//初始化链表必须用二级指针 这里省略对指针参数的检查 { *pHead=(LinkList)malloc(sizeof(Node)); if(NULL!=pHead) { (*pHead)-&gt;next=*pHead; (*pHead)-&gt;prior=*pHead; } else printf("开辟内存失败\n"); } //创建新结点 LinkList get_newNode(Elemtype e) { LinkList newNode=(LinkList)malloc(sizeof(Node)); if(NULL!=newNode) { newNode-&gt;data=e; newNode-&gt;prior=NULL; newNode-&gt;next=NULL; return newNode; } else { printf("开辟内存失败\n"); return 0; } } //头插 void push_Front(LinkList *L,Elemtype e) { LinkList p; p=get_newNode(e); p-&gt;prior=*L; p-&gt;next=(*L)-&gt;next; p-&gt;next-&gt;prior=p; p-&gt;prior-&gt;next=p; } //尾插 void push_Back(LinkList *L,Elemtype e) { LinkList tail,p; tail=*L; while(tail-&gt;next!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9570c3890c9d43582554bf1799c9716f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d5523c26d6d033275085ac65e1e50b2/" rel="bookmark">
			java实现非对称加密(RSA算法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java实现非对称加密(RSA算法) java需要运行commons-codec-1.10.jar下载地址 http://download.csdn.net/download/weixin_39549656/10233215
介绍 RSA公钥加密算法是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。1987年7月首次在美国公布，当时他们三人都在麻省理工学院工作实习。RSA就是他们三人姓氏开头字母拼在一起组成的。 RSA是目前最有影响力和最常用的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准。 今天只有短的RSA钥匙才可能被强力方式解破。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。但在分布式计算和量子计算机理论日趋成熟的今天，RSA加密安全性受到了挑战和质疑。 RSA算法基于一个十分简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。
安全性 RSA的安全性依赖于大数分解，但是否等同于大数分解一直未能得到理论上的证明，因为没有证明破解RSA就一定需要作大数分解。假设存在一种无须分解大数的算法，那它肯定可以修改成为大数分解算法。 RSA 的一些变种算法已被证明等价于大数分解。不管怎样，分解n是最显然的攻击方法。人们已能分解多个十进制位的大素数。因此，模数n必须选大一些，因具体适用情况而定。
代码例子 package 加密; import java.security.KeyFactory; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.PrivateKey; import java.security.PublicKey; import java.security.interfaces.RSAPrivateKey; import java.security.interfaces.RSAPublicKey; import java.security.spec.PKCS8EncodedKeySpec; import java.security.spec.X509EncodedKeySpec; import javax.crypto.Cipher; import org.apache.commons.codec.binary.Base64; public class 加密 { private static String src ="my name is cuichongdong"; public static void main(String[] args) { jdkRSA(); } public static void jdkRSA(){ //1.初始化秘钥 try { KeyPairGenerator keyPairGenerator = KeyPairGenerator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d5523c26d6d033275085ac65e1e50b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dda47822b3fa8b05987198d216e16bf2/" rel="bookmark">
			中奖概率的谬误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中奖概率期望的谬误 问题：假设独立事件发生概率为P，那么重复多少次，独立事件期望发生，即期望值为1？ 回答：这个问题很简单，有点概率论基础的，都知道： E=1/p。即独立事件的概率是50%，那么期望重复两次就能发生，例如抛硬币问题。
在生活中，人们总是会想当然的认为期望值达到了，事件就一定会发生。就像抛硬币两次应该就会出现至少一次正面了，潜意识中认为这个概率是很大的，但实际上这个概率有多大呢？ 1−50%∗50%=75% 1 − 50 % ∗ 50 % = 75 % ，看上去还是蛮不错的。
别急，还有呢？如果事件概率是0.01， 重复100次， 是不是至少发生1次的概率很高呢？如果你认为这是100%发生，或者90%发生，那么就在错特错了，让我们科学的计算一下这个概率值： 1−0.99100=63.40% 1 − 0.99 100 = 63.40 % 看看，是不是有点意外，这个概率好像没有想象的那么高啊，是吧！
如果独立事件概率是0.001呢？0.0001呢？ 或者是更小呢？重复期望值的重复次数，发生至少一次的概率，最后算出来会发现基本上稳定在63%左右。
EP=1−(1−P)1/P E P = 1 − ( 1 − P ) 1 / P 为什么独立事件的概率越来越小，EP会稳定在63%左右呢？ (1−p)1/p=((1+1/（1/−p）)1/−p)−1 ( 1 − p ) 1 / p = ( ( 1 + 1 / （ 1 / − p ） ) 1 / − p ) − 1 let:x=1/−p l e t : x = 1 / − p then:EP=1−((1+1/x)x)−1 t h e n : E P = 1 − ( ( 1 + 1 / x ) x ) − 1 p→0,x→无穷，EP=1−e−1=1−1/e;e是自然常数 p → 0 , x → 无 穷 ， E P = 1 − e − 1 = 1 − 1 / e ; e 是 自 然 常 数 是不是很神奇？当独立事件概率小到趋进零时，重复期望次数，至少发生一次的概率趋向1减自然常数 e e （2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dda47822b3fa8b05987198d216e16bf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/629b569418c6c65a2ad6a85b28b4e8f1/" rel="bookmark">
			LUCI自行定义表单处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小小前言 前一章里我阐述了利用LUCI的自身机制实现表单的构建及配置的读取，现在我来说一下自行构建表单进行提交处理的方法。个人认为，掌握了这个，才不会被LUCI的架构所局限。刚接触那会，我是花了蛮长的时间才弄通了这一点，也因为在网上没找到什么资料，所以想把自己的经验写下来，也希望能帮到大家。
具体步骤如下：
确定配置文件编写路由建立表单编写处理方法 1. 确定配置文件 这一个在前一章也有说过，大家可以先看看我的这一篇文章：
LUCI 使用其原有机制的建立新的页面
这里我们仍然沿用之前的network配置的interface那项配置就好：
config interface testnets option ifname 'testnet' option type 'test' option ipaddr '192.168.1.1' option net '192.168.251.1' 2. 编写路由 个人习惯，我喜欢先定好路由规则再往下写。大家若是不想后面二进宫，那么可以先进行第3步。
话不多话，接下来我们到luci/controller/admin/net.lua里编写路由：
module luci.controller.admin.net function index() entry({"admin", "testnet", "form"}, template("test/form"), translate("Form"), 12) -- 表单加载页面路由 entry({"admin", "testnet", "control"}, call("form"), nil) end 3. 建立表单 好了，到了建立表单的时间。相信做过WEB开发的人都知道表单如何建立，其实就是一个HTML页面。但LUCI这里有所不同，用的是htm文件，但基本语法是一样的，所以不用担心。
好了，我们接下来简单写一下我们的表单页面，页面的文件路径是在luci/view/test/下的form.htm（因为之前路径定义了template("test/form)这一句）：
&lt;%+header%&gt; &lt;% local cbi = require 'luci.model.uci' local row = cbi:get("network", "testnets") %&gt; &lt;form action="&lt;%=url("admin", "testnet", "control")%&gt;" method="post"&gt; &lt;div&gt;&lt;label&gt;Ifname: &lt;/label&gt;&lt;span&gt;&lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/629b569418c6c65a2ad6a85b28b4e8f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4514ede72163cc5bde62e12a416ee6f/" rel="bookmark">
			什么是TCP/IP协议？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“程序员小灰”，选择“置顶公众号”
有趣有内涵的文章第一时间送达！
本文转载自公众号[技术特工队]，作者整理了一些TCP/IP协议簇中需要必知必会的十大问题，既是面试高频问题，又是程序员必备基础素养。
一、TCP/IP模型 TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议。
基于TCP/IP的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示TCP/IP模型与OSI模型各层的对照关系。
TCP/IP协议族按照层次由上到下，层层包装。最上面的是应用层，这里面有http，ftp,等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。
上图清楚地表示了TCP/IP协议中每个层的作用，而TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。
上图以HTTP协议为例，具体说明。
二、数据链路层 物理层负责0、1比特流与物理设备电压高低、光的闪灭之间的互换。 数据链路层负责将0、1序列划分为数据帧从一个节点传输到临近的另一个节点,这些节点是通过MAC来唯一标识的(MAC,物理地址，一个主机会有一个MAC地址)。
封装成帧: 把网络层数据报加头和尾，封装成帧,帧头中包括源MAC地址和目的MAC地址。
透明传输:零比特填充、转义字符。
可靠传输: 在出错率很低的链路上很少用，但是无线链路WLAN会保证可靠传输。
差错检测(CRC):接收者检测错误,如果发现差错，丢弃该帧。
三、网络层 1.IP协议 IP协议是TCP/IP协议的核心，所有的TCP，UDP，IMCP，IGMP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP或UDP要做的事情。
1.1 IP地址 在数据链路层中我们一般通过MAC地址来识别不同的节点，而在IP层我们也要有一个类似的地址标识，这就是IP地址。
32位IP地址分为网络位和地址位，这样做可以减少路由器中路由表记录的数目，有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，那么路由表只需要维护一条这个网络地址的方向，就可以找到相应的这些终端了。
A类IP地址: 0.0.0.0~127.255.255.255 B类IP地址:128.0.0.0~191.255.255.255
C类IP地址:192.0.0.0~239.255.255.255
1.2 IP协议头 这里只介绍:八位的TTL字段。这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个IP数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64。
2.ARP及RARP协议 ARP 是根据IP地址获取MAC地址的一种协议。
ARP（地址解析）协议是一种解析协议，本来主机是完全不知道这个IP对应的是哪个主机的哪个接口，当主机要发送一个IP包的时候，会首先查一下自己的ARP高速缓存（就是一个IP-MAC地址对应表缓存）。
如果查询的IP－MAC值对不存在，那么主机就向网络发送一个ARP协议广播包，这个广播包里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址，如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的MAC地址的ARP包传送给发送ARP广播的主机。
而广播主机拿到ARP包后会更新自己的ARP缓存（就是存放IP-MAC对应表的地方）。发送广播的主机就会用新的ARP缓存数据准备好数据链路层的的数据包发送工作。
RARP协议的工作与此相反，不做赘述。
3. ICMP协议 IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。ICMP不是高层协议，而是IP层的协议。
当传送IP数据包发生错误。比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这 也就是为什么说建立在IP层以上的协议是可能做到安全的原因。
四、ping ping可以说是ICMP的最著名的应用，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。
例如：当我们某一个网站上不去的时候。通常会ping一下这个网站。ping会回显出一些有用的信息。一般的信息如下:
ping这个单词源自声纳定位，而这个程序的作用也确实如此，它利用ICMP协议包来侦测另一个主机是否可达。原理是用类型码为0的ICMP发请 求，受到请求的主机则用类型码为8的ICMP回应。
ping程序来计算间隔时间，并计算有多少个包被送达。用户就可以判断网络大致的情况。我们可以看到， ping给出来了传送的时间和TTL的数据。
五、Traceroute Traceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。
Traceroute的原理是非常非常的有意思，它收到到目的主机的IP后，首先给目的主机发送一个TTL=1的UDP数据包，而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的ICMP数据报给主机。主机收到这个数据报以后再发一个TTL=2的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据 报。如此往复直到到达目的主机。这样，traceroute就拿到了所有的路由器IP。
六、TCP/UDP TCP/UDP都是是传输层协议，但是两者具有不同的特性，同时也具有不同的应用场景，下面以图表的形式对比分析。
面向报文面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。
面向字节流面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。
关于拥塞控制，流量控制，是TCP的重点，后面讲解。
TCP和UDP协议的一些应用
什么时候应该使用TCP？ 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。
什么时候应该使用UDP？ 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4514ede72163cc5bde62e12a416ee6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e22eafb4902031171ea8bf06ab619200/" rel="bookmark">
			ZCMU1315: 孙子算经
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Description 《孙子算经》中的题目：有物不知其数，三个一数余二，五个一数余三，七个一数又余二，问该物总数几何？
《孙子算经》中的解法：三三数之，取数七十，与余数二相乘；五五数之，取数二十一，与余数三相乘；七七数之，取数十五，与余数二相乘。将诸乘积相加，然后减去一百零五的倍数。
解法中的三个关键数70，21，15，有何妙用，有何性质呢?首先70是3除余1而5与7都除得尽的数，所以70a是3除余a，而5与7都除得尽的数，21是5除余1，而3与7都除得尽的数，所以21b是5除余b，而3与7除得尽的数。同理，15c是7除余c，3与5除得尽的数，总加起来 70a+21b+15c 是3除余a，5除余b ，7除余c的数，也就是可能答案之一，但可能不是最小的，这数加减105（105=3×5×7）仍有这样性质，可以多次减去105而得到最小的正数解。
现在给定4个互不相等的被除数数A,B,C,D(0&lt;A,B,C,D&lt;50)和4个余数a,b,c,d(0&lt;a&lt;A,0&lt;b&lt;B,0&lt;c&lt;C,0&lt;d&lt;D)，求最小的正除数，题目保证有正解。
Input 有多组数据，每组数据有4个被除数A,B,C,D和4个余数a,b,c,d。
Output 输出相应的答案，占一行。
Sample Input 2 3 5 7 1 2 3 4 29 31 37 43 13 14 15 16 Sample Output 53
600081
while(~scanf("%d",&amp;n))
&lt;=&gt; while(scanf("%d",&amp;n)!=EOF)
1.正常输入的时候，scanf返回输入的数字如1,2,3等等，对这些数字取非，不会成为0，就会执行循环；
2.错误输入指的就是没有输入的时候，scanf返回的是EOF（End Of File），EOF=-1，对EOF取非，就是对-1取非
[~是位运算，它是将数据在内存中的每一位（当然是二进制）取反。-1在内存中所有位全部为1，~(-1)=0,即对-1取非就是0]
就会跳出循环。
#include&lt;stdio.h&gt; int main() { int A,B,C,D,a,b,c,d; long long sum; while(~scanf("%d%d%d%d%d%d%d%d",&amp;A,&amp;B,&amp;C,&amp;D,&amp;a,&amp;b,&amp;c,&amp;d))//加~ { int i; i=1; while(1) { sum=i; if(sum%A==a&amp;&amp;sum%B==b&amp;&amp;sum%C==c&amp;&amp;sum%D==d) break; i++; } printf("%lld\n",sum); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/691922870d3f9af9335b7b21e450000e/" rel="bookmark">
			BaseQuickAdapter 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、BaseQuickAdapter 简介 减少重复 Adapter 代码
添加 Item 的点击事件，长按事件以及子控件的点击事件
添加头部、尾部，下拉刷新、上拉加载（上拉加载的5种加载更多动画任你选择，后期会添加更多的加载动画）、没有更多数据
可以自定义头部、尾部、加载更多布局
添加 Item滑动动画 （9种动画切换，轻松一行代码）
添加新增、删除 Item动画 （目前支持默认的动画方式）
网格，列表，流式随意切换
添加空布局（列表无数据时，显示更加人性化）
拖拽和侧滑删除
支持多类型布局
类似淘宝列表切换
字母导航
类似探探翻牌
看了 BaseQuickAdapter 的特性，接着来看看外面如何在项目中导入（依赖）它。
BaseQuickAdapter 导入（依赖） 方式一：build.gradle 的 dependencies 添加如下代码：
//最新代码还没更新到 jcenter 仓库，推荐使用方法二依赖项目 compile 'com.github.baserecycleradapter:library:1.1.0' 如果上面的依赖不能使用，使用新的依赖 compile 'com.github.CymChad:BaseRecyclerViewAdapterHelper:2.9.22' 如果导入依赖报错： Error:(33, 13) Failed to resolve: com.github.CymChad:BaseRecyclerViewAdapterHelper:2.9.22 Show in File Show in Project Structure dialog 在导入依赖页面加上如下代码： allprojects { repositories { maven { url "https://jitpack.io" } } } 导入依赖之后 public class DeleteDemoAdapter extends BaseQuickAdapter&lt;String,BaseViewHolder&gt; { public DeleteDemoAdapter(@LayoutRes int layoutResId, @Nullable ArrayList&lt;String&gt; data) { super(layoutResId, data); } @Override protected void convert(final BaseViewHolder helper, String item) { helper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/691922870d3f9af9335b7b21e450000e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d380fbdf0131f283654c03cebf0a64c/" rel="bookmark">
			python爬虫实践——零基础快速入门（四）爬取小猪租房信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上篇文章我们讲到python爬虫实践——零基础快速入门（三）爬取豆瓣电影
接下来我们爬取小猪短租租房信息。进入主页后选择深圳地区的位置。地址如下：
http://sz.xiaozhu.com/
一，标题爬取 按照惯例，我们先复制标题的xpath信息，多复制几个进行对比：
//*[@id="page_list"]/ul/li[1]/div[2]/div/a/span //*[@id="page_list"]/ul/li[2]/div[2]/div/a/span //*[@id="page_list"]/ul/li[3]/div[2]/div/a/span //*[@id="page_list"]/ul/li[4]/div[2]/div/a/span #..... ...... 对比后发现，标题只是 li[] 序号发生改变，于是我们很快写出标题的通用 xpath 信息
//*[@id="page_list"]/ul/li/div[2]/div/a/span 这是固定套路啊。于是我们先把整页的标题爬取下来：
#-*- coding:utf-8 -*- import requests from lxml import etree import time url3 = 'http://sz.xiaozhu.com/' data3 = requests.get(url3).text h = etree.HTML(data3) titles = h.xpath('//*[@id="page_list"]/ul/li/div[2]/div/a/span/text()') time.sleep(2)#注意，小猪在发爬虫方面做得比较好，防止被封IP就加个睡眠吧 for title in titles: print (title) 注意，注意，注意~~重要的事情要说三遍，我刚开始没有加睡眠，结果他把我IP给封了，封了，我滴妈，那我还怎么展示我的结果啊，特么都不让我访问了，呜呜，所以这里大家一定要注意，加个睡眠时间，并且这个睡眠时间稍微长一点，5s 以上应该就不会被封了吧，如果还被封，那那那~就太恶心了。
哎，说多了都是泪啊，大家一定好奇我的IP后来怎么样了？
没管，第二天解封了，哈哈哈~~~
结果展示：
毗邻海上世界 交通便利 无敌海景 赛车公寓 1号主人房｜1.8米床 前海园林式小区公寓 【红山站】近深圳北站龙星河传奇宜家风一房一厅 【平时订房租二送一】近木棉湾地铁站/整租两房 CBD艺术空间大套房 深圳最中心位置 复式书房+独立花园阳台|前海园林式小区 步行至会展中心地铁上盖阳光一居室 6特价 西乡地铁站/西乡天虹楼上汇一城 下左 罗湖文锦口岸黄贝岭新秀地铁口摩登两房整租 5号飘窗次卧|前海园林式小区公寓 福田CBD会展中心旁两房 高尔夫球场边的家-趣园私人酒店公寓 深圳湾科技园高新园地铁口万象天地极简两房一厅 4西乡地铁站/西乡天虹 楼上小区 汇一城 LifeHome生活家 深圳第一最美高端民宿 2西乡地铁站/西乡天虹 楼上小区 汇一城 会展中心/福田口岸 地铁口两房 出差居家首选 1独卫主卧 西乡地铁/西乡天虹楼上小区汇一城 #栖息地#罗湖口岸/东门老街地铁口/北欧一居 【超暖和暖气】Loft大房 近深圳北 东门老街～地铁口～【清新风格】小鹿屋 超低价 近罗湖口岸火车站 国贸东门温馨两居 蛇口中心水湾地铁90平两房一低密度电梯洋房 (特惠)宝安中心/地铁口/机场高层海景1居 OK，我们再选中房屋的整体信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d380fbdf0131f283654c03cebf0a64c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55ba98e6bbcfd879fbc21f9a4e84a095/" rel="bookmark">
			K - Candies
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本题要求1~n之间相隔最大值，而题目给出的权值即为最大值，所以转化为最短路问题；照例试了四种算法，只有spfa奏效，bellman_ford超时，其余两种实现不了
spfa:
#include&lt;cstdio&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; using namespace std; typedef long long ll; const int maxn=1e6+10; const int N=6000; const int INF=1e9+10; ll dis[maxn]; int vis[maxn],head[maxn],len,n; struct node { int u,v,c,next; }p[maxn]; void add(int a,int b,int c) { p[len].u=a; p[len].v=b; p[len].c=c; p[len].next=head[a]; head[a]=len++; } void spfa(int x) { stack&lt;int&gt; q; q.push(x); dis[x]=0; vis[x]=1; while(!q.empty()) { int u=q.top(); q.pop(); vis[u]=0; for(int i=head[u];i!=-1;i=p[i].next) { int v=p[i].v; if(dis[v]&gt;dis[u]+p[i].c) { dis[v]=dis[u]+p[i].c; if(vis[v]) continue;	vis[v]=1; q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55ba98e6bbcfd879fbc21f9a4e84a095/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/518/">«</a>
	<span class="pagination__item pagination__item--current">519/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/520/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>