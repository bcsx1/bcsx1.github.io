<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/868fdf7c7000739a196a379e87363b85/" rel="bookmark">
			重装系统后出现0xc000000e解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题
今天备份系统把C盘备份了一份wim格式的文件，然后在另一台机器上安装测试，重装系统后出现0xc000000e报错，然后在网上搜了下，网上说出现这种错误的原因有三四个，我认为最有可能的错误是找不到启动引导项，所以就针对找不到引导项问题查找解决办法，以下是我整合的解决找不到引导项的问题的方法。
解决方法 1、首先出现这种情况之后，我们需要重新进入pe系统，在系统中，按组合键win+r打开运行窗口，输入cmd并按回车调出命令提示符，如图所示：
2、然后依次执行以下命令：
c:	（//注意这个，别漏了，先进入C盘） cd c:\windows\system32\	（切换到“C:WindowsSystem32”目录下(c盘为系统盘)） bcdedit /set {default} osdevice boot	（设置Windows7所在的硬盘分区为默认） bcdedit /set {default} device boot	（设置Windows7引导文件所在的分区为默认） bcdedit /set {default} detecthal 1	（从默认位置启动计算机。） 显示如下面就说明设置成功了
3、重新启动计算机看能不能正常进入系统，如果问题依旧，则尝试其他方法，或重新分区，再次重装系统。
|
|
|
你的小小一赞是我分享的动力！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d55efcb9fc11cdba843f427fbbe227bb/" rel="bookmark">
			springboot项目打包成jar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot项目打包成jar 一、为什么打包二、如何打包（1）使用IDEA进行打包（2）使用maven进行打包三、运行jar包四、注意 一、为什么打包 项目开发完毕后会将前后端应用打包，然后部署到服务器上运行。Java Web应用在Spring Boot之前，通常是打包成war包，结合Tomcat来完成部署。而对于SpringBoot，官方的建议是将Spring Boot应用打包成一个fat jar（SpringBoot默认打包方式），即项目的依赖jar包也会被包含在Spring Boot项目的jar包当中，这个fat jar会把Tomcat内置进来，所以部署时也不需要单独配置Tomcat。这样部署一个SpringBoot应用就非常简单，无需预装任何服务器，只需要上传jar包即可。
二、如何打包 （1）使用IDEA进行打包 1.打开项目，右击项目选中Open Module Settings进入project Structure，如下图所示：
选中Artifacts，点击中间的加号（Project Settings-&gt;Artifacts-&gt;JAR-&gt;From modules with dependencies ），如下图所示：
2.弹出Create JAR from Modules，选择‘Main Class’，然后点击OK
3.开始打包，点击右侧的Maven Projects，打开LIfecycle，先点击clean，再点击package，生成target文件夹，里面有以项目名命名加版本号的jar文件，至此打包完成。
（2）使用maven进行打包 SpringBoot自带一个更简单的spring-boot-maven-plugin插件可以用来打包，只需要在pom.xml中加入以下配置：
&lt;project&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 无需任何配置，这个插件会自动定位应用程序的入口Class，执行以下Maven命令即可打包：
$ mvn clean package 三、运行jar包 进入jar所在的文件夹，使用java -jar命令运行jar，项目就能启动
java -jar demoa-0.0.1-SNAPSHOT.jar 四、注意 因为springboot内置了tomcat，所以springboot项目打包成jar可以免去tomcat的配置，如果是打包成war包，则还需要配置tomcat。
打包后在target目录下有两个jar文件，其中有一个jar包后缀为.original，这是Maven标准打包插件打的jar包，它只包含我们自己的Class，不包含依赖，而后缀为.jar的是SpringBoot打包插件创建的包含依赖的jar，可以直接运行。
感谢大家的耐心阅读，如有建议请私信或评论留言
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eacd56f5e863f6873f9063fa29835913/" rel="bookmark">
			java数据结构-栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		栈 1、栈的定义 栈（Stack）：是只允许在一端进行插入或删除的线性表。首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作。
栈顶（Top）：线性表允许进行插入删除的那一端。
栈底（Bottom）：固定的，不允许进行插入和删除的另一端。
空栈：不含任何元素的空表。
栈又称为后进先出（Last In First Out）的线性表，简称LIFO结构
2、栈的常见基本操作 InitStack(&amp;S)：初始化一个空栈S。StackEmpty(S)：判断一个栈是否为空，若栈为空则返回true，否则返回false。Push(&amp;S, x)：进栈（栈的插入操作），若栈S未满，则将x加入使之成为新栈顶。Pop(&amp;S, &amp;x)：出栈（栈的删除操作），若栈S非空，则弹出栈顶元素，并用x返回。GetTop(S, &amp;x)：读栈顶元素，若栈S非空，则用x返回栈顶元素。DestroyStack(&amp;S)：栈销毁，并释放S占用的存储空间（“&amp;”表示引用调用） 3、栈的应用场景 1)子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。
2)处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。
3)表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。
4)二叉树的遍历。
5)图形的深度优先(depth一first)搜索法。
2、栈的基础入门 2.1用数组模拟栈 /** * 使用数组模拟栈 * 1.使用数组来模拟栈 * 2.定义一个top来表示栈顶,初始化为-1 * 3.入栈的操作,当有数据加入到栈时,top++,stack[top] = data； * 4.出栈的操作,int value = stack[top],top--,return value */ public class Stack { public static void main(String[] args) { ArrayStack stack = new ArrayStack(10); stack.push(1); stack.push(2); stack.push(3); stack.push(4); stack.push(5); stack.list(); System.out.println("---"); //理论上来说应该是4没有了 stack.pop(); stack.list(); } } class ArrayStack { private int maxSize;//栈的大小 private int[] stack;//数组,模拟栈,数据放在该数组 private int top = -1;//标记栈的值 //构造器 public ArrayStack(int maxSize) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eacd56f5e863f6873f9063fa29835913/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f27aa7b4f9a6a55abec676304e89905a/" rel="bookmark">
			To install it, you can run: npm install --save core-js/modules/es.error.cause.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ERROR Failed to compile with 2 errors This dependency was not found: * core-js/modules/es.error.cause.js in ./node_modules/_@babel_runtime@7.17.2@@babel/runtime/helpers/esm/nonIterableSpread.js, ./node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js??ref--13-0!./node_modules/_babel-loader@8.2.3@babel-loader/lib!./node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js??ref--1-0!./node_modules/_vue-loader@16.8.3@vue-loader/dist??ref--1-1!./src/views/setting/user/save.vue?vue&amp;type=script&amp;lang=js To install it, you can run: npm install --save core-js/modules/es.error.cause.js 解决方法：
第一步：删除node_modules
sudo rm -rf node_modules 第二步: 独立安装(core-js)
sudo cnpm install --save core-js 第三步：安装其他依赖
sudo cnpm i 第四步：运行
npm run serve 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1939fcb4bdbf52016596c85f0a748d17/" rel="bookmark">
			elasticsearch Alias field type 使用注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		elasticsearch Alias field type 使用注意事项 Alias field type注意事项The target must be a concrete field, and not an object or another field alias.The target field must exist at the time the alias is created.If nested objects are defined, a field alias must have the same nested scope as its target.A field alias can only have one targetAttempting to use an alias in an index or update request will result in a failure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1939fcb4bdbf52016596c85f0a748d17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfb15df2cb060d69ce62b6987ea2cfaf/" rel="bookmark">
			Modbus TCP 入门学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录下我入门学习的过程，供日后回看，文字部分多是转载他人blog，有注明来源地址；实验部分为真实测试结果。
1. ModBus通讯协议简介 (摘抄：来自网络)Modbus协议是一种已广泛应用于当今工业控制领域的通用通讯协议。通过此协议，控制器相互之间、或控制器经由网络（如以太网）可以和其它设备之间进行通信。Modbus协议使用的是主从通讯技术，即由主设备主动查询和操作从设备。一般将主控设备方所使用的协议称为Modbus Master，从设备方使用的协议称为Modbus Slave。典型的主设备包括工控机和工业控制器等；典型的从设备如PLC可编程控制器等。Modbus通讯物理接口可以选用串口（包括RS232和RS485），也可以选择以太网口。其通信遵循以下的过程：
●　主设备向从设备发送请求
●　从设备分析并处理主设备的请求，然后向主设备发送结果
●　如果出现任何差错，从设备将返回一个异常功能码
2. Modbus TCP 的数据帧 由MBAP 头和PDU 构成， MBAP= Modbus Application Protocol Header(Modbus应用协议) 头部
PDU = Protocol Data Unit （数据单元）
ADU：Application Data Unit
上面截图来源：http://www.modbus.org/docs/Modbus_Messaging_Implementation_Guide_V1_0b.pdf
头部MBAP：
例如：
3：功能码 来源：https://blog.csdn.net/iknow_nothing/article/details/84292914 modbus的操作对象有四种：线圈、离散输入、输入寄存器、保持寄存器
线圈：PLC的输出位，开关量，在MODBUS中可读可写
离散量：PLC的输入位，开关量，在MODBUS中只读
输入寄存器：PLC中只能从模拟量输入端改变的寄存器，在MODBUS中只读
保持寄存器：PLC中用于输出模拟量信号的寄存器，在MODBUS中可读可写
根据对象的不同，modbus的功能码有：
0x01：读线圈
0x02：读离散量输入
0x03：读保持寄存器 0x04：读输入寄存器
0x05：写单个线圈
0x06：写单个保持寄存器
0x10：写多个保持寄存器
0x0F：写多个线圈
4：实验 准备一个C# Socket的收发模型封装类，下载一个Modbus Slave工具 序列号：5455415451475662
0x01：读线圈
在从站中读1~2000个连续线圈状态，ON=1,OFF=0
下面截图来源：初识Modbus TCP-------------C#编写Modbus TCP客户端程序(一）_thebestleo的专栏-CSDN博客_c# modbus tcp
请求：MBAP 功能码 + 起始地址H 起始地址L +数量H 数量L
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfb15df2cb060d69ce62b6987ea2cfaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c5a059e785ca770f4b3aea45afe156b/" rel="bookmark">
			SQL Server使用bcp导出数据报Error = [Microsoft][SQL Server Native Client 11.0]无法打开 BCP 主数据文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果确定命令无问题，需要检查目录sql server是否有写入权限
EXEC SP_CONFIGURE 'xp_cmdshell', 1; reconfigure; DECLARE @shell VARCHAR(500); SET @shell = 'bcp 表名 out d:\sqlBack\data2.txt -T -n'; EXEC xp_cmdshell @shell; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3df858b38d782b674bc8a9612f1b2d3/" rel="bookmark">
			转载，通过 Prometheus Alertmanager 模块发送 Doris 异常信息至钉钉报警群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础环境
1.Prometheus 版本：2.22.2
下载地址：
https://github.com/prometheus/prometheus/releases/download/v2.22.2/prometheus-2.22.2.linux-amd64.tar.gz
2.Alertmanager 版本：0.23
下载地址：
https://github.com/prometheus/alertmanager/releases/download/v0.23.0/alertmanager-0.23.0.linux-amd64.tar.gz
3.prometheus-webhook-dingtalk ：1.4
下载地址：
https://github.com/timonwong/prometheus-webhook-dingtalk/releases/download/v1.4.0/prometheus-webhook-dingtalk-1.4.0.linux-amd64.tar.gz
1.新增用户和用户组
➜ groupadd prometheus➜ useradd -g prometheus -M -s /sbin/nologin prometheus 2.安装配置 Prometheus Server
详细 Prometheus 安装流程请参考：https://mp.weixin.qq.com/s/BcKN4s7qDokG_YmXn8Q-zQ
需要确保服务启动完成后，可以正常访问：http://localhost:9090，且 Doris 的 metrics 已经打入 Prometheus 中。
3.安装 AlertManager 模块
3.1 下载安装包 ➜ wget https://github.com/prometheus/alertmanager/releases/download/v0.23.0/alertmanager-0.23.0.linux-amd64.tar.gz ➜ tar xf alertmanager-0.23.0.linux-amd64.tar.gz -C /soft➜ cd /soft➜ mv alertmanager-0.23.0.linux-amd64 alertmanager➜ cd alertmanager➜ mkdir data #系统文件持久化路径➜ chown -R prometheus.prometheus /soft/alertmanager 说明：创建 data 目录是必须要操作的，不然后期启动 alertmanager 会异常。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3df858b38d782b674bc8a9612f1b2d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6b93fc53ce316eca0ea9477e308ac15/" rel="bookmark">
			职场中该如何自学？看书/看视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		职场中该如何自学？看书/看视频 随便聊点啥开端需要人手把手教？书？视频？再聊个五毛钱的最后呢？ 随便聊点啥 如题，还真就随便聊点啥。
虎年已经开始了，去年一年过的相当刺激，也尝试去做许多有意思的事情~
录制两个半教学视频（一个成功，一个审核不通过，一个录制一半（os以后大概率用不到，放弃录制了））录制抖音小视频（录制技术类发现没人看-放弃）去学校给可爱的小学弟们上（chui）课（niu）写博客（写得少） 那么新的一年还要怎么折腾才好๑乛◡乛๑… 再瞅瞅再瞅瞅๑乛◡乛๑
开端 毕业也有些念头了，中间不断的折腾，也走了不少弯路，但是有件事却是随着工作时间的不断增加，而对它的看法不断的发生转变。
比如：应该如何学习才能使得自己真的有收获！
需要人手把手教？ 呵呵~ 如果处于这种学习方式，个人估摸着在it行业，小伙子，你已经干到头了乁( ˙ ω˙乁)
书？ 初入职场那会，遇到新的技术（学校出来时，我咋觉得所有技术都是新的）会立刻购买属于这项技术的书，一本技术的应用，一本深入浅出***，一本技术的底层原理。
这样学习的好处毋庸置疑，能更全面的了解这一项技术，但是！！！也有着坏处！！
时间成本太高：当任务排期下来，公司需要的是快速落地，然而看书的话，落地成本太高！理解偏差：文字它就静静的躺在那里，作者掌握90%，文字体现80%，你的理解可能只有70%。失效性：这点是最致命的，对于技术而言，迭代太快了，导致书本的时效性大大降低（ps博主曾经对着一本Elasticsearch书啃了一个周末，几乎通宵学习，然而到公司才发现，书本是2.X版本，公司用的是7.X！！） 由此，博主开始思考如何才能快速入门新技术？
视频？ 一次偶然的机会，博主正在接触hbase，腾讯课堂弹出的广告有hbase相关的公开课(◍•͈⌔•͈◍)
进去看着看着，觉得，讲的真TM的好！深入浅出，比干看书来的要好接收（除了疯狂打广告要交钱进入培训班）
所以在那段时间中，若是想快速入门一项技术，我一般会直接去 网易云课堂/慕课网/腾讯课堂/bilibili 上寻找相关的视频进行学习，但是视频的学习也是有缺点的！
资源少：一般新的技术，或者技术新的版本，是不会有视频的，而且技术视频数量相对与书籍（博客来说会少很多，可能来来回回就那几个，毕竟录制视频成本还是远远大于编写文字的）资源质量不高：这里的不高并不是指录制的不好，而是指录制的视频往往只录制了安装和简单使用，复杂以及原理都不会讲的很多。 所以看视频往往能快速入门，可是也仅仅是入门，而且受限于录制视频的up主表达风格，时间成本也是一个雷。
再聊个五毛钱的 上面对于视频，书籍都有了一些自己的看法，那么再聊聊五毛钱的，抛开技术本身，关于对于它们的看法吧~
看视频学习，与看书学习，两者获取有效信息的效率差别还是很大的。╮(﹀_﹀”)╭
比如对于看视频而言：这一过程，是很容易受到干扰的。
首先：如果当你觉得这段信息是垃圾信息，比如up主在聊天云云，那么你就会想快进，但是又担心快进过程中会遗落有效的信息，你就会反复的尝试快进，这其实很影响接收有效信息的效率。其次：当觉得视频中某一段特别重要，视频又没办法很有效的打上标记已便于实时翻看，这就需要重新打字或者写字记录下来，这就又影响了观看效率。最后：视频有许多的场外因素，声音，画面，色彩等辅助信息，会使你分心，再一次影响观看效率，比如up主讲者讲者弹出了某些奇奇怪怪的广告▄︻┻┳═一∵∴∷∶∵ 视频有着声音画面，带着up主的情感，这些辅助信息并不是一无是处，它能让你在学习的时候显得不那么的枯燥，让有效的信息更加的形象，但是也是这种辅助的信息，会喧宾夺主，让许多人接受信息的时候把情绪当作意见，把偏见当作道理，把故事当作真相！！
对于看书而言：
首先：书不会影响观看效率，它就静静的躺在那边，观看的效率取决于自己。其次：书里不会有画面，有声音，他最多只会有一些辅助性的图案，这可以让我们专心的提取有效的信息，去思考，去筛选。最后：文字是思想最基本的逻辑，人类所有的思想都会以文字的形式存储下来，无论多么经典的视频演讲，最后都会以文字进行存储，去刨析它的内核思想。所以，读书往往是最容易抓住精髓的。 文字是人类思想展现的最好方式，也是人类抓取有效信息的最好方式。
最后呢？ 最后呢，总结一下：
如果你有一定的时间（一两天？）想要入门一项新的技术，那么不妨寻找一些教学视频看看。如果你迫切的需要解决某一项新的技术难点，那可能google逛一逛，技术的官网逛一逛会更适合！如果你有充足的时间，可以结合书籍进行学习~ 最后的最后：
如果想对一项技术有一定的研究，那么，在使用的过程中，写写博客，录制视频，都能极大程度的帮助你吃透这门技术，会它，和能教会别人用它，是两个境界。
毕竟：世界上最难的事情有两个：
把自己的思想灌注到别人的大脑中。把别人的钱拿到自己的口袋里。 希望以上这一小小的分享，能对大家有那么的一点点帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17ab75ad2ccf3067db4bb19e12db1beb/" rel="bookmark">
			elasticsearch 从 _source 与 stored_fields 获取数据不一致？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		elasticsearch 从 _source 与 stored_fields 获取数据不一致？ 问题探索 问题 如题：elasticsearch 从 _source 与 stored_fields 获取数据不一致？
大伙都知道，使用 elasticsearch 进行数据存储的时候，查询数据会默认存储在_source中，但是若开启了 store 存储（默认关闭），那么，就可以使用 stored_fields 进行查询。
但是查询出来的数据，有时候会和预想的结果不一致，那么我们来探究一下。
探索 设置一个mapping
PUT store_test_document { "mappings": { "properties": { "title": { "type": "text", "store": true }, "date": { "type": "date", "store": true }, "content": { "type": "text" } } } } 将 title 与 date 两个字段 store设置为 true，那么，这两个字段将能被 stored_fields 所查询。
接下来存储一条数据
PUT store_test_document/_doc/1 { "title": "Some short title"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17ab75ad2ccf3067db4bb19e12db1beb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ec4af56fa0c33a552ed0093ea12d5ec/" rel="bookmark">
			三维分割数据集Scannet下载代码 网盘链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接：https://pan.baidu.com/s/1PcybgtPuB-YJFB5MGuRFTg
提取码：1id0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e61c21251e9747991740c8ff36ba0ea1/" rel="bookmark">
			最小生成树（克鲁斯卡尔算法 普里姆算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最小生成树是处理图结构中，简化图的算法；即删除一些边使得图得以简化，但应保证图中任意点都是相连通的。形成的最小生成树应该使得从顶点遍历时走过边的权值和最小。（有n个节点，则最小生成树的边数应为n-1）
如：
变为最小生成树后：
处理最小生成树有两种方法：
1.克鲁斯卡尔算法（kruskal）：
这种算法是先把所有的边拿出来，按其权值从小到大的顺序排列，然后从最小的边开始还原图，即按该边连接其顶点。从权值值最小的边依次连接，每次连接都要判断本次连接是否形成了环，若是，则改变没有必要还原，当还原到已还原边数为n-1时最小生成树完成。
还原步骤：
若形成环则不还原该边。
c++代码参考代码（用到了并查集这是我对并查集的一些理解）：
#include&lt;iostream&gt; #include&lt;algorithm&gt; typedef struct//定义边的结构体 { int value; int node1,node2; }edge; #define max_size 20 int parent[20];//用于装节点的根 using namespace std; int rule(edge a,edge b)//按权值排序边时用 { return a.value&lt;b.value;//升序排序 } int find_root(int v)//找根节点函数 { if(parent[v]==-1) return v; else { parent[v]=find_root(parent[v]);//压缩找父节点的路径 return parent[v]; } } int is_cycle(int v1,int v2)//判断是否成环 { int v1_root=find_root(v1); int v2_root=find_root(v2); if(v1_root==v2_root) return 1;//两个节点的根相同，若在连接两个节点则会形成环 else { parent[v1_root]=v2_root;//连接起来，这里最好根据情况 选择把v1或v2的根作为共同的根 return 0; } } void kruskal(edge a[],edge b[],int n,int m) { sort(a,a+m,rule); for(int i=0,j=0;i&lt;m;i++) { if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e61c21251e9747991740c8ff36ba0ea1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/254f9ac09abe46829871b6f458e72e72/" rel="bookmark">
			Mysql已连接但是忘记密码如何修改密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：本文采用Navicat工具并且已连接到Mysql
进入Navicat选中已连接但是忘记密码的数据库，选中用户栏；如下图所示
双击进入root@%用户的界面如下图
在密码及确认密码框输入要修改的密码保存即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40281054382d37a1bfa2c7e54504f81b/" rel="bookmark">
			ROS项目在Docker容器中的落地应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ROS项目在Docker容器中的落地应用 疑问和解答 Q&amp;A
Q： 为什么要使用Docker容器封装上位机ROS系统？
A： ROS是驾于Linux上的一套源操作系统，由于ROS的不同版本对宿主机有一定的影响，因此将ROS封装在一个容器中。
Q: 使用Docker容器的优缺点？
A: 这样的做法有很多的好处，一是不会影响到宿主机上原本的系统，使其保证干净复用性，二是操作部署方便简单，具有拓展易用性，三是为之后做多级联动集群灾备等做铺垫。 缺点是要注意设备主机与容器之间的网络连通性，遇到一些问题的时候不好判断是容器到宿主机之间的通信问题还是其他问题。
Q: 使用Docker容器部署ROS还有哪些为解决的问题？
A: 由于个人能力以及容器在Arm工控机对OpenGL版本的高度依赖，导致我们的容器部署 在Nvidia系列上位机上时，Rviz显示异常，但在X86上已完美解决。
Q: 对ROS在Docker上使用的展望？
A: 由于ROS1天生的缺陷，其实是没有办法做真正意义上的多机联动的，但是ROS2上使 用了DDS数据分发分布式通讯，解决了ROS1的中心化强依赖Master，做到了真正的去中心化，因此使用ROS2部署在Docker容器里面后有需求的话我们可以采用kubernetes做集群化统一管理。上述有些点其实已经在AutoWare.auto上得以实现，因此相信在不久的将来ROS可以普遍的容器化管理和使用。
案例
先决条件
X86工控机上或者Windows 10 WSL1/WSL2上安装Linux（Debian/Ubuntu/CentOS/OpenSUSE/Arch Linux）系统。操作指南
这里使用一台干净的Ubuntu20.04进行测试，安装 ssh 启动后进行远程连接方便测试。 sudo apt install openssh-server sudo service ssh start 安装 Docker-ce ，删除之前Ubuntu自带的Docker。
sudo apt remove docker docker-engine docker.io containerd runc 安装一些必要依赖。
sudo apt install -y \ apt-transport-https \ ca-certificates \ curl \ gnupg-agent \ software-properties-common 配置Docker-ce源，更新源。
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo apt-key fingerprint 0EBFCD88 sudo add-apt-repository \ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40281054382d37a1bfa2c7e54504f81b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab900e4c82cffa7de9ffa3ec174dc4ec/" rel="bookmark">
			java 线程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、线程的基本概念 一个程序最少需要一个进程，而一个进程最少需要一个线程。关系是线程–&gt;进程–&gt;程序的大致组成结构。所以线程是程序执行流的最小单位，而进程是系统进行资源分配和调度的一个独立单位。
一个线程就是在进程中的一个单一的顺序控制流.
而单个进程可以拥有多个并发执行的任务，每个任务都好像有自己的CPU一样，而其底层的机制就是切分CPU的时间，也就是CPU将轮流给每个任务分配其占用时间。
每个任务都觉得自己在一直占用CPU，而事实上是将CPU时间划分成片段分配给所有的任务。
在多个CPU的环境下，多线程的运作，可以极大的提供程序的运行速度，这就是线程存在的意义。
二、线程的实现方式 一、继承Thread类创建线程类 （1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。
（2）创建Thread子类的实例，即创建了线程对象。
（3）调用线程对象的start()方法来启动该线程。
public class MYThread extends Thread{ @Override public void run() { super.run(); } } 二、通过Runnable接口创建线程类 （1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。
（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。
（3）调用线程对象的start()方法来启动该线程。
Thread(Runnable target)
Thread(Runnable target, String name)
Thread(ThreadGroup group, Runnable target)
Thread(ThreadGroup group, Runnable target, String name)
Thread(ThreadGroup group, Runnable target, String name, long stackSize)
new Thread(new Runnable() { @Override public void run() { } }).start(); 三、通过Callable和Future创建线程 （1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。
（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。
（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。
（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab900e4c82cffa7de9ffa3ec174dc4ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4588d2209b6918467f5ab50bc8f396ce/" rel="bookmark">
			前端面试题（JavaScript基础篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端面试题，JavaScript基础篇共收录面试题57道。 1、介绍JavaScript的基本数据类型？ 基本数据类型：Number、String、Boolean、Null、Undefinedobject是JavaScript中所有对象的父对象数据封装类对象：object、Array、Boolean、Number、String其它对象：Function、Arguments、Math、Date、Error、RegExp其它数据类型：Symbol 2、浅谈JavaScript中变量和函数声明的提升？ 在JavaScript中变量和函数的声明会提升到最顶部执行函数的提升高于变量的提升函数内部如果用var声明了相同名称的外部变量，函数将不会向上寻找匿名函数不会提升不同&lt;script&gt;块中的函数互不影响 3、什么是闭包，闭包有什么特性？ 闭包就是能够读取其它函数内部变量的函数闭包是指有权访问另一个函数作用域中变量的函数，创建闭包最常见的方式就是在一个函数内部创建另一个函数，通过另一个函数访问这个函数的局部变量，利用闭包可以突破作用域链闭包的特性 函数内再嵌套函数内部函数可以引用外部的参数或变量参数和变量不会被垃圾回收机制回收 4、说说对闭包的理解和闭包的作用 使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，增大内存使用量，使用不当很容易造成内存泄漏。在JS中，函数即闭包，只有函数才会产生作用域的概念闭包的最大用处有2个，一个是可以读取函数内部的变量，另一个就是可以让这些变量始终保持在内存中闭包的另一个用处是封装对象的私有属性和方法好处：能够实现封装和缓存坏处：就是消耗内存、不正当使用会造成内存溢出的问题 使用闭包的注意点
由于闭包会使得函数中的变量都保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄漏。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 5、说说对This对象的理解 this总是指向函数的直接调用者，而非间接调用者如果有new关键字，this指向new出来的那个对象在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象window 6、说说对事件模型的理解 W3C中定义时间的发生精力三个阶段 捕获阶段目标阶段冒泡阶段冒泡型事件：当你使用事件冒泡时，子元素先触发，父元素后触发捕获型事件：当你使用事件捕获时，父元素先触发，子元素后触发DOM事件流：同时支持两种事件模型，捕获型事件和冒泡型事件阻止冒泡：在W3C中，使用stopPropagation()方法；在IE下设置cancelBubble = true阻止捕获：阻止事件的默认行为，例如click - &lt;a&gt;后的跳转。在W3C中，使用preventDefault()方法，在IE下设置window.event.returnValue = false 7、new 操作符具体干了什么？ 创建一个空对象，并且this变量引用该对象，同时还继承了该函数的原型属性和方法被加入到this引用的对象中新创建的对象由this所引用，并且最后隐式的返回this 8、说说栈和堆的理解，以及它们的区别？ 栈内存：栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命后期都很短堆内存：存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆内存中，堆内存的都是放的实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也不会消失，还可以使用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，有垃圾回收机制不定时的收取 栈和堆的区别：
栈内存存储的是局部变量，而堆内存存储的是实体栈内存更新速度要快于堆内存，因为局部变量的生命周期都很短栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收 9、JS数组和对象的遍历方式，以及几种方式的比较 for in 循环for 循环forEach 循环 这里的forEach回调中两个参数分别为：value , indexforEach无法遍历对象IE不支持该方法；FireFox和Chrome支持forEach无法使用break ，continue跳出循环，且使用return是跳过本次循环for-in 需要分析出array的每个属性，这个操作性能开销很大。用在key已知的数组上是不划算的。所以尽量不要用for-in，除非你不清楚要处理哪些属性，例如JSON对象这样的情况for循环每进行一次，就要检查一下数组长度。读取属性（数组长度）要比读局部变量慢，尤其是当array里存放的都是DOM元素，因为每次读取都会扫描一遍页面上的选择器相关元素，速度会大大降低 10、map和forEach的区别 forEach方法，是最基本的方法，就是遍历与循环，默认有3个参数：分别是遍历的数组内容item、数组索引index、当前遍历的数组Arraymap方法，基本用法与forEach一致，但不同的是，它会返回一个新的数组，所以callback需要有return值，如果没有，会返回undefined 11、谈一谈箭头函数与普通函数的区别？ 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象不可以当做构造函数，也就是不可以使用new命令，否则会抛出一个错误 不可以使用arguments对象，该对象在函数体内不存在，如果要用，可以使用Rest参数代替不可以使用yield命令，因为箭头函数不可以用作Generator函数（遍历器函数） 12、JavaScript定义类的4中方法 工厂方法 function creatPerson(name, age) { var obj = new Object(); obj.name = name; obj.age = age; obj.sayName = function () { alert(this.name); } return obj; } 构造函数方法 function Person(name, age) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4588d2209b6918467f5ab50bc8f396ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b468ced44e10fb4a2039b2fb082817da/" rel="bookmark">
			PCL去除地面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如图所示:
分别是:原图-&gt;直通滤波后-&gt;取地面的图-&gt;取地面的凹凸四边行加地面上的物体图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9008a8bdd3af085fb67fcf6d6a1bab33/" rel="bookmark">
			Fiddler面试题集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Fiddler断点在工作中有什么作用？
主要是用来修改请求和响应数据的，比如我们的VX(微信)发红包功能，其实在前端是设置了一个一分钱到两百块钱的金额限制，当我们做测试的时候想要去发超过200块钱的金额就可以用Fiddler对我们的before request设置一个断点，然后修改我们的金额发送一个 超过200块钱。比如说发个520的金额红包到我们的后端，检查服务端处理是否OK。又比如测试需要返回不同 的数据来检查前端的显示，我们 可以用Fiddler来对 after response设置一个断点，修改返回数据查看前端显示的效果 。
二、说一下Fiddler怎么模拟弱网场景？你知道MQTT是 什么东西吗 ？
在Fiddler中rules右键点击 Customize Rules（自定义规则） ，然后双击打开 Customize Rules.js文档，修改文档中每上传或者是下载1kb数据所需要的时间来模拟我们的弱网环境，然后再rules–performance（性能）下面点击simulate modem speeds（模拟调制解调器速度）开启弱网环境的模拟 ，通过以上三步，就可以实现弱网测试场景的构造。
if (m_SimulateModem) { // Delay sends by 300ms per KB uploaded. oSession["request-trickle-delay"] = "300"; // Delay receives by 150ms per KB downloaded. oSession["response-trickle-delay"] = "150"; } MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。
三、网络爬虫是干什么的？
爬虫就是运用这种爬虫的技术来去互联网上获取我们一些我们想要的信息，比如我是一个做生意的，我想要去了解一下我的同行们都在卖什么货，什么货卖得比较好，那么如果只有十个八个的一些同行，那么可能我可以手工或者是人力的分析过来，但如果有上百个、上千个、上万个，那么这个时候就肯定需要借助一些工具，一些技术手段来把他们抓取过来，拿到这些数据之后，我再做一些简单的分析，来看一下哪些货卖的比较好，他们的销量各自是什么样子的，这就是我们常说的爬虫技术的一个应用领域。
四、wireshark抓包工具的主要使用场景有哪些？
wireshark抓包工具它的主要目的是用来分析测试过程中间的网络问题，比如测试某个web页面时打不开，那么我们可以通过wireshark来分析一下是客户端的问题还是服务端的问题，同时我们也可以来分析一下是哪个连接阶段出现的问题。
拿http协议我们来举例，我们可以通过wireshark进行分析得出是在TCP 3次握手过程中间发生的错误还是在握手之后进行数据传输的时候发生的错误，是客户端主动断开的连接还是说被服务器给reset，我们都可以通过wireshark抓包分析得出。
五、用F12抓包后如何解析数据？
1.直接处理。当网页返回数据就是一些文本，就是我们想要的内容，不需要过滤处理，直接处理就可以
2.Json解析。如果网页返回的不是HTML数据是JSON数据，那么就需要用到JSON解析技术
3.正则表达式。如果返回的数据是符合正则表达式的数据，就可以用正则去做解析
4.其他解析方式。常用的有XPath、BeautifulSoup和PyQuery，这些都是爬虫常用的解析库。
六、抓包工具的区别？
1.Fiddler是免费开源的，但只能在windows下使用，mac和Linux是不支持的
2.Charles支持windows、MacOS和Linux操作系统，但是它不免费
3.Wireshark可以抓取所有协议的内容，非常适合协议的学习和网络问题的分析，但是Wireshark它需要你具备一定的网络知识，所以对于初学者来说不是很友好
4.F12最简单最轻量级，但是和其他的抓包工具还是存在一定的差距
5.TCPdump主要用于Linux命令的抓包工具，前提是你要会操作Linux系统
七、Fiddler如何定位前后端bug？
1.如果Fiddler在没有设置任何过滤的情况下面，没有抓到任何的请求消息，那么大概率就是前端的bug，或者是一些很明显的js错误也是前端的bug；
2.如果抓取到的请求数据有问题，那么就是前端的问题；
3.如果抓取到的请求返回的状态码是500，说明是后端出了错误，是后端的bug；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9008a8bdd3af085fb67fcf6d6a1bab33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/172644d5f4da719588a018734a7683d3/" rel="bookmark">
			MySQL基础使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 MySQL基础 （1）什么是MySQL 数据库是一个以某种有组织的方式存储的数据集合。而SQL全称为Structured Query Language，翻译过来就是结构化查询语言，是一种专门用来与数据库通信的语言。MySQL则是一种数据库管理系统(DBMS)，是一种软件系统。
（2）数据库结构 数据库：保存有组织的数据的容器
表：某种特定类型数据的结构化清单
模式：关于数据库和表的布局以及特性的信息，也即是定义了数据在表中如何存储的。
列：每一列就是表中的一个字段。
行：每行作为表中的一个记录
主键：一列(或者一组列)，其值能够唯一区分表中的每个行。(主键不允许NULL值)
外键：为某个表的某一列，包含了另一个表的主键值，定义了两个表之间的关系
（3）数据库引擎 MySQL常用的引擎有两种，分别是InnoDB和MyISAM。
InnoDB InnoDB是MySQL默认的事务型引擎，也是最重要、最广泛的存储引擎。它的设计是用来处理大量短期事务，短期事务大部分是正常提交的，很少回滚。InnoDB的性能和自动崩溃恢复特性，使得它在非事务型存储的需求中，也很流行。除了非常特别的原因需要使用其他引擎，InnoDB也是非常好值得花时间研究的对象。
InnoDB的数据存储在表空间中，表空间是由InnoDB管理的黑盒文件系统，由一系列系统文件组成。InnoDB可以将每个表的数据和索引存放在单独的文件中。InnoDB也可以使用裸设备作为表空间存储介质。
InnoDB通过间隙锁（next-key locking）防止幻读的出现。InnoDB是基于聚簇索引建立，与其他存储引擎有很大的区别，聚簇索引对主键查询有很高的性能，不过它的二级索引（secondary index，非主键索引）必须包含主键列。所以如果主键列很大的话，索引会很大。
MyISAM 在5.1之前，MyISAM是默认的引擎，MyISAM有大量的特心态，包括全文索引、压缩、空间函数。但是MyISAM不支持事务和行级锁，而且在崩溃后无法安全恢复。即使后续版本中MyISAM支持了事务，但是很多人的概念中依然是不支持事务的引擎。
MyISAM并不是无所事处。对于一些只读数据，或者表空间较小，可以忍受恢复操作，可以使用MyISAM。MyISAM会将表存储在两个文件中：数据文件、索引文件。分别是.MYD、.MYI扩展名。MyISAM表可以包含动态或者静态行。MySQL会根据表定义选择那种行格式。MyISAM表的行记录数，取决于磁盘空间和操作系统中的单个文件最大尺寸。
在MySQL中，默认配置只能存储256TB的数据。因为指向数据记录的指针长度是6字节。需要修改可以修改表的MAX_ROWS和AVG_ROW_LENGTH选项。两个相乘是最大的大小。会导致重建索引。
MyISAM是对整个表加锁，而不是行锁，读取的时候对表加共享锁，写入的时候加排他锁。但是在表有读取查询的同时，也可以往表内写入记录。
对于MyISAM，即使是Blob，Text等等长字段，也可以基于前500字符创建索引，MyISAM支持全文索引，这是一个基于分词创建的索引，也可以支持复杂的查询。
MyISAM可以选择延迟更新索引键，在创建表的时候指定delay_key_write选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是写到缓存区，只有在清理缓存区或者关闭表的时候才会将索引写入磁盘。这可以极大的提升写入性能，但是在主机崩溃时会造成索引损坏，需要执行修复操作。
MyISAM另一个特性是支持压缩表。如果数据在写入后不会修改，那么这个表适合MyISAM压缩表。可以使用myisampack对MyISAM表进行打包，压缩表是不可以修改数据的。压缩表可以极大的减少磁盘占用，因此可以减少磁盘IO，提升性能，压缩表也支持索引，但是索引也是只读的。
整体来说MyISAM并没有那么不堪，但是由于没有行锁机制，所以在海量写入的时候，会导致所有查询处于Locked状态。
（4）MySQL使用 USE语句：USE databasename 输出：Database changed，mysql命令行程序数据库选择成功后显示。
SHOW语句：显示相关信息，支持的语句有：
1)SHOW DATABASES，返回可用数据库的一个列表;
2)SHOW TABLES，返回一个数据库内的表的列表;
3)SHOW COLUMNS FROM table1，返回table1表中各列的信息;
4)SHOW STATUS，用于显示广泛的服务器状态信息;
5)SHOW CREATE DATABASE 或 SHOW CREATE TABLE，分别用来显示创建特定数据库或表的MySQL语句;
6)SHOW GRANTS，用于显示授予用户的安全权限;7)SHOW ERRORS 和 SHOW WARNINGS用来显示服务器错误或警告信息。
SQL语句大小写：SQL语句不区分大小写，习惯上将关键字大写，表名、列名等用小写，便于区分和阅读。
二、 数据检索 （1）SELECT SELECT colname FROM table1; 返回：表table1中名为colname的列。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/172644d5f4da719588a018734a7683d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a7f13c3fcc960e437820e1c1b326db4/" rel="bookmark">
			Pycharm快捷键大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用快捷键 快捷键功能Ctrl+Q快速查看文档Ctrl + F1显示错误描述或警告信息Ctrl+ /行注释(可选中多行)Ctrl+Alt+L代码格式化Ctrl+Alt+O自动导入Ctrl+ Alt + I自动缩进Tab/ Shift + Tab缩进、不缩进当前行(可选中多行)Ctrl+C/Ctrl+Insert复制当前行或选定的代码块到剪贴板Ctrl + D复制选定的区域Ctrl + Y删除当前行Shift + Enter下一行另起一行Ctrl + J插入模版Ctrl + Shift +/-展开/折叠全部代码块Ctrl + Numpad+全部展开Ctrl + Numpad-全部折叠Ctrl + Delete删除到字符结束Ctrl + Backspace删除到字符开始Ctrl + Shift + F7将当前单词在整个文件中高亮，F3移动到下一个，ESC取消高亮Alt + up/down方法上移或下移动Alt + Shift + up/down当前行上移或下移动Ctrl + B/鼠标左键转到方法定义处Ctrl + W选中增加的代码块Shift + F6方法或变量重命名Ctrl + E最近访问的文件Esc从其他窗口回到编辑窗口Shift + Esc隐藏当前窗口，焦点到编辑窗口F12回到先前的工具窗口 全部快捷键 1、编辑(Editing) 快捷键功能Ctrl + Space基本的代码完成(类、方法、属性)Ctrl + Alt + Space快速导入任意类Ctrl + Shift + Enter语句完成Ctrl + P参数信息(在方法中调用参数)Ctrl + Q快速查看文档Shift + F1外部文档Ctrl +鼠标简介Ctrl + F1显示错误描述或警告信息Alt + Insert自动生成代码Ctrl + 0重新方法Ctrl+ Alt + T选中Ctrl+ /行注释Ctrl + Shift + /块注释Ctrl+W选中增加的代码块Ctrl + Shift + W回到之前状态Ctrl + Shift + ]/[选定代码块结束、开始Alt + Enter快速修正Ctrl+ Alt + L代码格式化Ctrl+Alt+0自动导入Ctrl+Alt+I自动缩进Tab / Shift + Tab缩进、不缩进当前行Ctrl+ X/Shift+ Delete剪切当前行或选定的代码块到剪贴板Ctrl+ C/Ctrl+Insert复制当前行或选定的代码块到剪贴板Ctrl + Y删除当前行Ctrl + Shift + J添加智能线Ctrl + Enter智能线切割Shift + Enter下一行另起一行Ctrl + Shift + U在选定的区域或代码块间切换Ctrl + Delete删除到字符结束Ctrl + Backspace删除到字符开始Ctrl + Numpad+/-展开折叠代码块Ctrl + Numpad+全部展开Ctrl + Numpad-全部折叠Ctrl + F4关闭运行的选项卡 2、查找/替换(Search/Replace) 快捷键功能F3下一个.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a7f13c3fcc960e437820e1c1b326db4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f940c9d9969bbdc73dafc18f839e571/" rel="bookmark">
			推箱子（c&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一共设计了三关
所有图像全部是用图片搞出来的
#include&lt;stdio.h&gt; #include&lt;easyx.h&gt; #include&lt;conio.h&gt; #include&lt;graphics.h&gt; #include&lt;cstring&gt; #define _CRT_SECURE_NO_WARNINGS /*1.地图打印 * 2.角色移动 *	1.按键处理 (动的只能是人和被人推动的箱子) *	2.找到人的位置，人怎么动（数组操作） * 3.多关卡设置 *	1.关卡完成设置 *	2.进入下一关卡设置 * 4.图片设计 *	1.角色设置 4 *	2.箱子 2 *	3.目的 3 *	4.墙 1 *	5.地板 0 */ IMAGE img[6];//全局变量 HWND hnd = NULL; int cos = 0,grade=0;//关卡设置 int map[3][10][10]//地图 { 1,1,1,1,1,1,1,1,1,1, 1,0,0,0,3,0,0,0,0,1, 1,0,0,0,0,0,0,1,0,1, 1,0,1,0,0,0,1,0,0,1, 1,0,0,0,4,0,0,0,0,1, 1,0,1,0,0,0,0,1,0,1, 1,0,1,1,0,1,0,1,0,1, 1,0,2,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0,0,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,0,0,0,3,0,0,0,0,1, 1,0,2,0,0,0,0,1,0,1, 1,0,1,1,0,0,1,0,0,1, 1,0,0,0,4,0,0,0,0,1, 1,0,1,0,0,0,1,1,0,1, 1,0,1,1,0,1,1,1,0,1, 1,0,0,0,2,0,0,0,0,1, 1,3,0,0,0,0,0,0,0,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,0,0,0,0,0,0,0,0,1, 1,0,0,2,0,0,0,1,3,1, 1,0,1,0,0,0,1,0,0,1, 1,3,0,0,4,0,0,0,0,1, 1,0,1,0,0,0,0,1,0,1, 1,0,1,1,0,1,2,1,0,1, 1,0,0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0,0,1, 1,1,1,1,1,1,1,1,1,1 }; void load()//加载图像 { for (int i = 0; i &lt; 6; i++) { char s[20] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f940c9d9969bbdc73dafc18f839e571/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab1ba1c4b882fc325308d2dd1f1249e9/" rel="bookmark">
			[Linux Device Driver] android 11电池温度过高导致设备反复重启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. 背景 之前有个项目要升级android 11，但是设备一直反复重启，然后他们觉得是音频导致的，还让我一个小兄弟周末也来加班。。原因是看到了音频的报错log一直在刷新：
#更新2021.08.02
这个我来更新下，随着阅历的增加，我发现这个报错是会导致进不了android的，就这个android.hardware.soundtrigger报错，我把声卡注册上才OK，由于某些音频服务报错，会一直尝试进入android，但是进入不了。
#更新2021.08.02
android.hardware.soundtrigger@2.0::ISoundTriggerHw/default [ 1240.972777] healthd: battery l=78 v=4079 t=82.8 h=3 st=4 c=0 fc=3581000 cc=0 chg=u [ 1241.570246] init: Control message: Could not find 'android.hardware.soundtrigger@2.0::ISoundTriggerHw/default' for ctl.interface_start from pid: 514 (/system/bin/hwservicemanager) [ 1242.565190] init: Control message: Could not find 'android.hardware.soundtrigger@2.0::ISoundTriggerHw/default' for ctl.interface_start from pid: 514 (/system/bin/hwservicemanager) [ 1243.571629] init: Control message: Could not find 'android.hardware.soundtrigger@2.0::ISoundTriggerHw/default' for ctl.interface_start from pid: 514 (/system/bin/hwservicemanager) [ 1244.586074] init: Control message: Could not find 'android.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab1ba1c4b882fc325308d2dd1f1249e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9cfa739c2bfff3e5879dfe0a836867d/" rel="bookmark">
			我的C语言学习历程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是小崔同学，今天入驻CSDN平台。经过了大一一年的学习，有的同学拿到了各种比赛奖项，有的同学却浑浑噩噩，甘愿堕落。未来是掌握在自己手里的，我们当然可以整日在宿舍打游戏追剧，但是，这种好日子是不长久的。想要过上梦想的生活，我们就要在对的时间做对的事情，作为一名大二的学生，我越来越意识到这种紧迫性，我认为我需要从现在开始认真规划自己的学习了，首先，作为计算机系的学生，C语言的学习是重中之重，我认为这是所有计算机语言的基础，因此，我希望以写博客的方式，一方面记录自己的学习经历与经验，一方面作为监督自己学习的一种方式。
写博客刚开始一定是一个很枯燥的过程，会很难坚持下去，我会尽可能在课间挤出时间，再难也要坚持下去，大家一起共勉!加油！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f70d38e26bab4b00e22328f0715bf90/" rel="bookmark">
			byte[]转String后再用String转回byte[]与起始byte[]不一致问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		示例:
@Test public void test1() throws UnsupportedEncodingException { String url = getUrl(); HttpRequest request = HttpUtil.createGet(url); HttpResponse execute = request.execute(); byte[] bytes = execute.bodyBytes(); System.out.println("起始byte[]大小" + bytes.length); String str = new String(bytes, "utf-8"); System.out.println("结束byte[]大小"+str.getBytes("utf-8").length); } 执行结果：
使用的编码集是utf-8 .
.
.
问题的解决 原因是默认是用UTF-8编码来生成String的，用System.getProperty(“sun.jnu.encoding”)可以得到当前默认编码是UTF-8。UTF-8是可变长度的编码，原来的字节数组就被改变了。在new String使用其他编码如GBK,GB2312的话一样也会导致字节数组发生变化，因此要想获取String里单字节数组，就应该使用iso8859-1编码。
ISO8859-1通常叫做Latin-1，Latin-1包括了书写所有西方欧洲语言不可缺少的附加字符，其中 0~127的字符与ASCII码相同，它是单字节的编码方式，这样生成的String里的字节数组就跟原来的字节数组一样。
.
编码改成 ISO8859-1 与原byte[]就一致了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6af763ecc1f465a3e0bbad2ab2cfa77/" rel="bookmark">
			《Go语言圣经》第一章 - 读书笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《Go语言圣经》第一章 - 读书笔记 第一章 Go语言入门01 Hello World02 命令行参数练习练习1.1练习1.2：练习1.3： 03 查找重复的行例子运行dup1dup2dup3 练习练习1.4： 04 GIF 动画练习练习1.5：练习1.6： 05 获取URL练习练习1.7：练习1.8：练习1.9： 06 并发获取多个URL练习练习1.10：练习1.11： 07 Web服务练习练习1.12： 08 本章要点控制流命名类型指针方法和接口包（packages）注释 第一章 Go语言入门 01 Hello World Go 是一门编译型语言（静态编译），Go语言的工具链将源代码及其依赖转换成计算机的机器指令
Go 语言提供的工具都通过一个单独的命令 go 调用
go 命令有一系列子命令，最简单的一个子命令就是 run，该命令编译一个或多个以 .go 结尾的源文件，链接库文件，并运行最终生成的可执行文件build 子命令可以生成一个可执行的二进制文件，该编译结果可长期保存，之后可以随时运行它 注意：
1、Windows系统下生成的可执行文件是 helloworld.exe，增加了 .exe 后缀名
2、Windows系统下在命令行可以直接输入helloworld.exe命令运行
3、go build 生成的可执行文件是静态编译，不需要担心在系统库更新的时候会冲突
4、静态编译和动态编译的区别
① 静态编译
编译器在编译可执行文件时，把需要用到的对应的动态链接库（.so 或 .lib）中的部分提取出来，链接到可执行文件中，是可执行文件在运行时不需要依赖于动态链接库
② 动态编译
动态编译的可执行文件需要附带一个的动态链接库，在执行时，需要调用其对应动态链接库中的命令。所以其优点有：
缩小了执行文件本身的体积
加快了编译速度，节省了系统资源
其缺点有：
即使是很简单的程序只用到了链接库中的一两条命令，也需要附带一个相对庞大的链接库如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行 Go 语言原生支持 Unicode，它可以处理全世界任何语言的文本
举例：
package main import "fmt" func main() { fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6af763ecc1f465a3e0bbad2ab2cfa77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a2b2e268718862471d090d00f357edf/" rel="bookmark">
			图像处理的基本流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般分为：
获取图像
\|/
分割图像
\|/
区域处理
\|/
特征提取
*2.分割图像：将图像分割成区域，根据图像像素数据，常用的阈值分割得到感兴趣区域，或是之前画好的经过变换得到的区域
*3.区域处理：得到区域后使用集合运算，形态学，区域变换，特征过滤筛选但等等手段对区域进行处理，从而得到目标区域。
*4.特征提取：对目标区域的参数进行提取，得到相关需要的数据结果。
*在图像处理过程中，2,3,4步是可能需要不断重复迭代的过程进行“定位特征，逐步逼近”
*通常我们定位产品，再在产品上定位需要检测的位置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63eff916af0f8b3f805f10d1357aeb09/" rel="bookmark">
			vue 中 [__ob__: Observer]问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		__ob__: Observer这些数据是vue这个框架对数据设置的监控器，一般都是不可枚举的。
我就遇到了这种，在created中已经赋值了，但在mounted中又没有，或者有取不到值，如下图
收了很多，有的说用JSON.parse(JSON.stringify(数组))再进行赋值但没有用后面看来很多终于解决了
因为vue取值的方式是Ajax异步的，我们还没取到值就开始用了，直接使用一个定时器就可以解决
mounted() { setTimeout(()=&gt;{ //这里就写你要执行的语句即可，先让数据库的数据加载进去数组中你在从数组中取值就好了 },800) } 参考链接：Vue 数组中出现__ob__: Observer无法取值[已解决]_聪明不喝牛奶的博客-CSDN博客___ob__ vue
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fec66b5c392de609cbbe9fc3e2fd3fa9/" rel="bookmark">
			监听用户更改元素属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;input type="password" id="box"&gt; &lt;script&gt; const mutationObserver = new MutationObserver((mutationsList) =&gt; { console.log(mutationsList,mutationsList[0].target) if( mutationsList[0].attributeName=="type" &amp;&amp; mutationsList[0].target.type=="text"){ console.log(document.getElementById('box')); document.getElementById('box').setAttribute('type','password') } }); mutationObserver.observe(box, { attributes: true, childList: true }); &lt;/script&gt; ResizeObserver监听元素变化 &lt;div class="wrapper" id="wrapper"&gt;&lt;/div&gt; window.onload=function(){ const resizeObserver = new ResizeObserver(entries =&gt; { console.log("我的resize变化啦"); console.log(entries); }); resizeObserver.observe(document.getElementById('wrapper')) } 取消监听 window.setTimeout(() =&gt; { myObserver.unobserve(document.getElementById('wrapper')) // 需要接收一个参数 }, 2000) https://juejin.cn/post/7064557881492209678
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07f6a010bf31c5b409dc779d209d4cfb/" rel="bookmark">
			SpringBoot -＞ 首页实现(thymeleaf-index.html)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 上结果1.蓝奏云资源2.扩展mvc:添加视图控制器3.index页面4.yaml配置:thymeleaf关闭缓存 上结果 1.蓝奏云资源 https://rod.lanzous.com/b0dkgezdc
2.扩展mvc:添加视图控制器 @Configuration public class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { // 路径"/"-跳转到index registry.addViewController("/").setViewName("index"); // 路径"/index"-跳转到index registry.addViewController("/index").setViewName("index"); } } 3.index页面 图片,css资源位置
&lt;!doctype html&gt; &lt;!--添加thymeleaf命名空间 xmlns:th="http://www.thymeleaf.org"--&gt; &lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt; &lt;meta name="description" content=""&gt; &lt;meta name="author" content="Mark Otto, Jacob Thornton, and Bootstrap contributors"&gt; &lt;meta name="generator" content="Jekyll v4.1.1"&gt; &lt;title&gt;Signin Template · Bootstrap&lt;/title&gt; &lt;!--这一行是不要的--&gt; &lt;!-- &lt;link rel="canonical" href="https://getbootstrap.com/docs/4.5/examples/sign-in/"&gt;--&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07f6a010bf31c5b409dc779d209d4cfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3a4636cb5f6da8ae18ea5f193c57cd5/" rel="bookmark">
			SpringBoot -＞ 国际化(i18n)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 上结果1.准备工作配置文件编写配置文件生效探究配置页面国际化值配置国际化解析总结:我可能骗了你们,这个看了我都总结不出什么东西 上结果 1.准备工作 先在IDEA中统一设置properties的编码问题！
编写国际化配置文件，抽取页面需要显示的国际化页面消息。我们可以去登录页面查看一下，哪些内容我们需要编写国际化的配置！
配置文件编写 1、我们在resources资源文件下新建一个i18n目录，存放国际化配置文件
**为什么是i18n的目录:**英语单词中i后面有18个字母最后一个是n,所以是i18n
2、建立一个login.properties文件，还有一个login_zh_CN.properties；发现IDEA自动识别了我们要做国际化操作；文件夹变了！
3、我们可以在这上面去新建一个文件；
弹出如下页面：我们再添加一个英文的；
这样就快捷多了！
4、接下来，我们就来编写配置，我们可以看到idea下面有另外一个视图；
这个视图我们点击 + 号就可以直接添加属性了；我们新建一个login.tip，可以看到边上有三个文件框可以输入
我们添加一下首页的内容！然后依次添加其他页面内容即可！
名字随便起,你看得懂就行
然后去查看我们的配置文件；
login.properties ：默认
英文：
中文：
OK，配置文件步骤搞定！
配置文件生效探究 我们去看一下SpringBoot对国际化的自动配置！这里又涉及到一个类：
MessageSourceAutoConfiguration:消息资源自动配置类
里面有一个方法，这里发现SpringBoot已经自动配置好了管理我们国际化资源文件的组件 ResourceBundleMessageSource；
// 获取 properties 传递过来的值进行判断 @Bean public MessageSource messageSource(MessageSourceProperties properties) { //自己先new一个东西 资源捆绑消息源 ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); //判断还有没有beanname,这个东西是什么我们看看,我找出源码看看,我贴到了这段代码的下面,解释也下面 if (StringUtils.hasText(properties.getBasename())) { // 设置国际化文件的基础名（去掉语言国家代码的） messageSource.setBasenames( //逗号分隔的列表到字符串数组;commaDelimitedListToStringArray //修剪所有空白:trimAllWhitespace //就行修剪后搞成数组放到了开始new的资源捆绑消息源中 StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(properties.getBasename()))); } //获取编码:getEncoding 如果已经有编码了,就进if if (properties.getEncoding() != null) { //把你给的编码名字搞出来,又加到new的资源捆绑消息源中 messageSource.setDefaultEncoding(properties.getEncoding().name()); } //将回退设置为系统区域设置:setFallbackToSystemLocale //正在回退到系统区域设置:isFallbackToSystemLocale //看不太懂哈;看看注解::设置如果找不到特定区域设置的文件，是否返回到系统区域设置。默认值为“true”； //大概就是如果默认是中文的,他找不到就默认中文,找到了,就设置成找到的那个 messageSource.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3a4636cb5f6da8ae18ea5f193c57cd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c68c912bfa7e7f9ecd6d802efbb88d3/" rel="bookmark">
			前端 -＞ js原生选择器,jQuery选择器 基本选择器(ID选择器,元素选择器,类名选择器,复合选择器,通配符选择器)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 jQuery基本选择器js选择器(原生选择器) jQuery基本选择器 1. ID选择器 ID选择器#id就是利用DOM元素的id属性值来筛选匹配的元素，并以iQuery包装集的形式返回给对象。 使用公式:$("#id") 示例：$("#box") //获取id属性值为box的元素 &lt;input id='box'/&gt; 2. 元素选择器 元素选择器是根据元素名称匹配相应的元素。 元素选择器指向的是DOM元素的标记名，也就是说元素选择器是根据元素的标记名选择的。 使用公式：$("element") 示例：$("div") //获取所有div元素 &lt;div&gt;&lt;/div&gt; 3.类名选择器 类选择器是通过元素拥有的CSS类的名称查找匹配的DOM元素。在一个页面中，一个元素可以有多个CSS类，一个CSS类又可以匹配多个元素，如果有元素中有一个匹配类的名称就可以被类选择器选取到。简单地说类名选择器就是以元素具有的CSS类名称查找匹配的元素。 使用公式：$(".class") 示例：$(".box") //获取class属性值为box的所有元素 &lt;p class="box"&gt;&lt;/p&gt; 4.复合选择器 复合选择器将多个选择器（可以是ID选择器、元素选择器或是类名选择器）组合在一起，两个选择器之间以逗号","分隔， 只要符合其中的任何一个筛选条件就会被匹配，返回的是一个集合形式的jQuery包装集 利用jQuery索引器可以取得集合中的jQuery对象。 注意：多种匹配条件的选择器并不是匹配同时满足这几个选择器的匹配条件的元素，而是将每个匹配的元素合并后一起返回。 使用公式：$("selector1,selector2,......,selectorN") selector1:一个有效的选择器，可以是ID选择器、元素选择器或类名选择器等 selector2:另一个有效的选择器，可以是ID选择器、元素选择器或类名选择器等 selectorN:（可选择）任意多个选择器，可以是ID选择器、元素选择器或类名选择器等 示例：$("div,#btn") //要查询文档中的全部的&lt;div&gt;元素和id属性为btn的元素 5.通配符选择器 $("*") //取得页面上所有的DOM元素集合的jQuery包装集 js选择器(原生选择器) JS选择器的主要作用 JS选择器主要用来获取HTML页面中的元素，将页面中的元素保存到一个对象中 然后就可以对这些对象的属性值进行相应操作以实现一些动态效果，以达到页面的生动，易用。 需要注意的一点是操作的一定是对象，直接将元素当做对象使用是不行的。 JS选择器是将对象对应的元素的属性直接进行操作，所以其改变的style的值是直接改变行间样式 优先级远高于CSS样式，所以使用时应注意与已经完成的CSS样式的取舍。 js中原生的选择器主要有以下四种 document.getElementById() document.getElementsByClassName() document.getElementsByName() document.getElementsByTagName() 1.document.getElementById() Id选择器 通过Id属性来获取对象 HTML部分 &lt;div id="div1"&gt;这是一个div标签&lt;/div&gt; JS部分 var d1 = document.getElementById("div1") 2.document.getElementsByClassName() ClassName选择器 通过ClassName属性获取对象 HTML部分 &lt;div class="c1"&gt;这是一个div标签&lt;/div&gt; &lt;p class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c68c912bfa7e7f9ecd6d802efbb88d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45f3a934a7dd4c3c5e8b3ee3704ba49e/" rel="bookmark">
			Linux -＞ 安装Oracle(详细版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 傻瓜式安装1 安装前环境：2 准备工作3 安装必须的包4 准备安装用户及用户组5 创建安装目录和设置文件权限6 修改内核参数配置文件7 配置oracle环境变量8 修改用户的限制文件9 编辑静默安装响应文件10 安装oracle11 静默配置监听12 静默建立新库13 修改数据库为归档模式(归档模式才能热备份，增量备份)14 修改oracle启动配置文件15 建立Oracle服务及其开机自启动16 用新建的用户连接数据库，并建立一个表附件:静默响应配置文件1. 静默安装文件2. 静默建库文件3. Oracle开机启动脚本 傻瓜式安装 1 安装前环境： 操作系统:CetnOS6.2x64 最小化安装，已配置好网络IP:172.16.2.182，物理内存8GB，硬盘100GB。
公司在\\192.168.0.200 数据库中一个叫database的zip压缩包(你们就自己下载吧)
下载：(百度网盘会失效,失效了你们就自己去找吧)
链接：https://pan.baidu.com/s/1kqCIrHPtcCvSBOZLueeQ2g
提取码：6666
linux.x64_11gR2_database_1of2.zip
linux.x64_11gR2_database_2of2.zip
位于目录/opt/ =&gt; 安装路径
2 准备工作 root用户登录
yum -y install vim //个人喜好vim编辑各种配置文件(有颜色)
yum install unzip //下载unzip,用来解压上述两个zip压缩文件
mkdir /path
mkdir /path/oracle
cd /path/oracle //下载的安装包zip放在oracle下面
unzip linux.x64_11gR2_database_1of2.zip //解压
unzip linux.x64_11gR2_database_2of2.zip
(公司就解压自己的zip就可以用) 解压后出现一个/path/oracle/database目录，里面是解压后的所有oracle安装文件。
在vim /etc/hosts文件中增加主机名(通过hostname命令获得)到回环IP的映射如下：
vim /etc/selinux/config #设置 SELINUX=disabled #Disable（关闭模式）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45f3a934a7dd4c3c5e8b3ee3704ba49e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3f6a0188b6a2bb596d7d652625f51c5/" rel="bookmark">
			vue设置显示几行，超出鼠标hover显示全部
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在组件中添加vueText
&lt;template&gt; &lt;div class="vue-text" ref="text" :style="textStyle" @mouseenter="mouseenter" @mouseleave="mouseleave" &gt; {{ value }} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { // 显示文字组件，可以设置最多显示几行，超过后会隐藏并且鼠标hover显示全部信息（需要给组件设置宽度） name: 'VueText', props: { value: { type: String, default: '' }, row: { //最多显示几行，超过后会...隐藏 为0时不隐藏 type: [Number, String], default: 0 } }, computed: { text() { return this.$refs.text } }, data() { return { isShowHover: false, textStyle: {}, div: null } }, watch: { row: function (val) { this.init() }, value: function () { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3f6a0188b6a2bb596d7d652625f51c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d9ba5281785e3b1bd3d809ba7e495a7/" rel="bookmark">
			开机时HP Hotkey UWP Service占用内存过高
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开机时HP Hotkey UWP Service占用内存过高 1.什么是热键？ 当你在屏幕前花费大量时间时，有许多键盘快捷键可以让你的生活更轻松，特别是如果你不喜欢使用鼠标。快捷键可以节省时间，提高工作效率，热键也不例外。
当与Fn键搭配使用时，热键是允许你在不进入设置的情况下执行特殊功能的键。
例如，您可以使用Fn + F6增加亮度，Fn + F10使麦克风静音，以及Fn + F4在外部显示器之间切换。这些键在符号、单词或数字周围有一个方框，以突出其特殊功能。
通常情况下，热键驱动程序是预装的，并在启动时自动运行，但有时它们会意外地停止运行，需要重新安装。这可能发生在您更新驱动程序或安装新程序时，或在自动Windows更新期间。幸运的是，这是个简单的解决方法。你甚至不需要先卸载旧的驱动程序。
2.解决方案 更改启动设置的方法如下：
1.在Windows搜索栏中 键入Services，然后单击
2.找到并右键单击“ HP Hotkey UWP服务”。
3.单击属性。
4.在“启动类型”下拉菜单下，选择“禁用”。
如果你已经禁用了热键支持，但后来又想把它打开，只需按照步骤1-2，然后右键单击HP热键UWP服务，然后单击 “开始”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0b935472703560df5f197bddd5c8f75/" rel="bookmark">
			【C语言代码写圣诞节程序】别再画圣诞树了，看都看腻了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
序
嗨，这里是狐狸~~
项目代码
图片相关操作
结构体
资源加载
初始化 绘制函数
数据更新 主函数
总结
视频讲解
序 没有雪花即使不浪漫也可过圣诞，有了祝福即使是寒冬也感到温暖
嗨，这里是狐狸~~ 今天是2021年12月20日星期一，又是美好的开始啊，距离2022年还有11天，距离2021年圣诞节还有5天，懂我什么意思了吧，圣诞节快到了，想好送啥礼物给女朋友了嘛，广大程序员uu们，嘿嘿，不知道的今天来教你们来做圣诞项目，让你们今年的圣诞节不孤单，起码还有圣诞老人陪你不是，好好看好好学！
OK，我们现在正式开始，先来看效果
不知道大家看后感觉如何呢，好叭，有想学的感觉还挺有意思的就继续看下去，觉得博主写的垃圾，档次太低的，请出门左转不送
项目代码 图片相关操作 先把我们要用到的变量进行全局化处理
IMAGE imgLand; IMAGE imgTree[10];	//圣诞树 IMAGE imgOldman;	//老人 IMAGE imgSnow[2]; bool Timer(clock_t ms, int id); 结构体 再来一个精灵结构体，控制速度 typedef struct { int x; int y; int w; int h; int frame;	//当前帧 int maxFrame;	//总帧数 int speed;	//速度 }Sprite; 资源加载 加载资源 ，找好图片的路径，选好图片的格式
void loadResource() { //加载图片 loadimage(&amp;imgLand, "Resource/land.png", getwidth(), 290); for (int i = 0; i &lt; 10; i++) { char imgFile[50] = { 0 }; sprintf_s(imgFile, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0b935472703560df5f197bddd5c8f75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e39ae2555c11515cda27428a27b1685a/" rel="bookmark">
			byte[] string转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/**
* @author zjx
* hex字符串转byte数组
* @param inHex 待转换的Hex字符串
* @return 转换后的byte数组结果
*/
public static byte[] hexStringToByteArray(String inHex){
int hexlen = inHex.length();
byte[] result;
if (hexlen % 2 == 1){
//奇数
hexlen++;
result = new byte[(hexlen/2)];
inHex=“0”+inHex;
}else {
//偶数
result = new byte[(hexlen/2)];
}
int j=0;
for (int i = 0; i &lt; hexlen; i+=2){
result[j]=(byte)Integer.parseInt(inHex.substring(i,i+2),16);
j++;
}
return result;
}
//转为16进制并去除空格 public static String bytesToHexString(byte[] src) { StringBuffer sb = new StringBuffer("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e39ae2555c11515cda27428a27b1685a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c01304e4f00b64ecc88d57bcd1b2722/" rel="bookmark">
			TransR的实体链接代码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TransR: 实体和关系分开嵌入（Learning Entity and Relation Embeddings for Knowledge Graph Completion） 问题：一个实体是多种属性的综合体，不同关系关注实体的不同属性。直觉上一些相似的实体在实体空间中应该彼此靠近，但是同样地，在一些特定的不同的方面在对应的关系空间中应该彼此远离。
方案：将实体和关系嵌入到不同的空间中，在对应的关系空间中实现翻译。
损失函数
训练集的格式
杭州,中国,省会 重庆,中国,省会 台湾,中国,省会 加州,美国,省会 杭州电子科技大学,杭州,大学 浙江大学,杭州,大学 北京大学,北京,大学 复旦大学,上海,大学 磁器口,重庆,景点 西湖,杭州,景点 故宫,北京,景点 头实体字典构造
{'unk': 0, '台湾': 3, '西湖': 10, '加州': 4, '北京大学': 7, '故宫': 11, '磁器口': 9, '复旦大学': 8, '重庆': 2, '杭州电子科技大学': 5, '杭州': 1, '浙江大学': 6}
尾实体字典构造
{'重庆': 6, '美国': 2, '中国': 1, '杭州': 3, '北京': 4, 'unk': 0, '上海': 5}
关系字典构造：
{'景点': 3, '省会': 1, '大学': 2, 'unk': 0}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c01304e4f00b64ecc88d57bcd1b2722/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1152b9b32f16348aee72813afaa2d3d7/" rel="bookmark">
			JS 数组去重 数组过滤重复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS 数组去重 数组过滤重复 JS 数组去重 数组过滤重复理论概念说明：定义：说人话： 数组去重解释：文字解释：图表解释： JS 数组去重 数组过滤重复 function array_deduplication(arr) { return arr.filter(function (c, index) { return arr.indexOf(c) === index; }); } 理论概念说明： arr.filter 定义： filter() 方法会创建一个新数组, 其包含通过所提供函数内部实现的逻辑过滤的所有元素。
说人话： 就是在 filter() 方法的回调函数中可以写一些过滤逻辑，逻辑为真的时候，当前元素将会返回，否则会被丢弃，这样就产生了一个新的数组，作为 filter() 的返回值。
数组去重解释： 文字解释： 不需去重数组
假设数组值为 [1,2,3,4]
遍历当前数组，元素1所在的位置为0、元素2的位置为1需要去重数组
假设数组值为[1,1,2,3,4]
遍历当前数组，第一个元素1所在的位置为0、第二个元素1所在的位置为1、元素2的位置为2 如果在数组中通过 indexOf 查找某个元素，获取到元素的下标和当前遍历的下标正好相等，则说明改元素是第一个出现的，如果不相同则说明是重复的。
图表解释： 如果你还在糊涂，请看下面表格
当遍历到第二个1时，通过indexOf获取到的下标是第一次出现1时的0，但是当前遍历的索引下标为1。两个值不相同则说明1不是第一次出现，因此是我们要过滤掉的对象。
因此通过该方法就可以去重数组
[1]: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
[2]: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82a22fd0bfbd7a9ad91b73ace578921c/" rel="bookmark">
			【教程】shardingjdbc(八)拓展分片算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上篇中提到可以通过spi机制拓展分布式序列算法,其实shardingjdbc很多核心组件和算法都支持自定义扩展。这篇说下通过spi机制拓展分片算法;
简单的说就是实现对应的接口，实现getType 方法和对应的分片类，然后就可以在配置文件中使用对应的类型了;
假设要扩展一个标准的分片算法
1. 首先自定义类，并实现 StandardShardingAlgorithm，其他的组合或强制路由的算法需要实现其他的那2个接口
package com.example.shardingjdbcdemo.spi; import lombok.SneakyThrows; import org.apache.shardingsphere.sharding.api.sharding.standard.PreciseShardingValue; import org.apache.shardingsphere.sharding.api.sharding.standard.RangeShardingValue; import org.apache.shardingsphere.sharding.api.sharding.standard.StandardShardingAlgorithm; import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.Collection; import java.util.Date; import java.util.Map; import java.util.Properties; import java.util.concurrent.ConcurrentHashMap; public class MonthStandardAlgorithm implements StandardShardingAlgorithm { private Properties properties = new Properties(); private static final String MONTH_FORMAT = "month_pattern"; private static final String DEFAULT_MONTH_FORMAT = "yyyy_MM"; private SimpleDateFormat dateTimeFormatter; private Map&lt;String,Boolean&gt; tableExists = new ConcurrentHashMap&lt;&gt;(); private static DateFormat parse = new SimpleDateFormat("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82a22fd0bfbd7a9ad91b73ace578921c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46f6811b34ac93b95bca933e4441e3ad/" rel="bookmark">
			45. 跳跃游戏 II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加链接描述
给你一个非负整数数组 nums ，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。
假设你总是可以到达数组的最后一个位置。
自己写出来的DP，我一看条件，1 &lt;= nums.length &lt;= 1e4，0 &lt;= nums[i] &lt;= 1000。1e7的负责度跑的完，就直接暴力dp了。dp[i]指到下标为i的点的最短距离。
const int maxn=1e4+2; int dp[maxn]; class Solution { public: int jump(vector&lt;int&gt;&amp; nums) { memset(dp,0x7f7f7f7f,sizeof(dp)); dp[0]=0; for(int i=0;i&lt;nums.size();i++) { for(int j=1;j&lt;=nums[i];j++) { if(i+j&gt;=nums.size()) break; dp[i+j]=min(dp[i]+1,dp[i+j]); } } return dp[nums.size()-1]; } }; 还有贪心的做法。
本题相对于55.跳跃游戏还是难了不少。
但思路是相似的，还是要看最大覆盖范围。
本题要计算最小步数，那么就要想清楚什么时候步数才一定要加一呢？
贪心的思路，局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最小步数。
思路虽然是这样，但在写代码的时候还不能真的就能跳多远跳远，那样就不知道下一步最远能跳到哪里了。
所以真正解题的时候，要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最小步数！
这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖。
如果移动下标达到了当前这一步的最大覆盖最远距离了，还没有到终点的话，那么就必须再走一步来增加覆盖范围，直到覆盖范围覆盖了终点。
图中覆盖范围的意义在于，只要红色的区域，最多两步一定可以到！（不用管具体怎么跳，反正一定可以跳到）
————代码随想录
https://leetcode-cn.com/problems/jump-game-ii/solution/dai-ma-sui-xiang-lu-dai-ni-xue-tou-tan-x-uqd0/
// 版本一 class Solution { public: int jump(vector&lt;int&gt;&amp; nums) { if (nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46f6811b34ac93b95bca933e4441e3ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfaf1d93d5e6f5498842ee9725e2984d/" rel="bookmark">
			C/C&#43;&#43;的日志系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 日志系统在程序运行中有着非常大的作用，用于记录程序的运行情况，在程序出错后查看日志，方便地定位出错的大概范围。
在设计日志系统之前，先考虑一下日志需要输出什么信息呢？什么信息才是有用的信息，都知道写日志是一种对文件的io操作，所以尽可能避免输出没用的信息。
有用的信息：关键变量的值、运行的位置（哪个文件、哪个函数、哪一行）、时间、线程号、进程号等等。
一、日志系统的设计 1、日志的级别
在测试、调试、交付等场景需要输出不同的级别日志。
//常见的日志级别 enum LOGLEVEL { LOG_LEVEL_NONE, LOG_LEVEL_ERROR, // error LOG_LEVEL_WARNING, // warning LOG_LEVEL_DEBUG, // debug LOG_LEVEL_INFO, // info	}; 2、日志的输出地
日志输出的地方可能不同，终端、控制台、UI界面、文件等等都有。
enum LOGTARGET { LOG_TERM = 0x00, LOG_FILE = 0x01, LOG_UI = 0x10 }; 3、日志的作用域
日志做到什么时候都可以输出，可作用于全程序文件，考虑到多线程情况下，必须保证日志的输出需要得到线程安全的保障，所以需要一个全局且唯一的日志器。
使用设计模式中的单例模式-----日志器
单例模式在上一节中讲过，可使用现代单例模式写法。
二、C++版本的日志系统的实现 Logger.h
/** * 日志类头文件, Logger.h * 2022.02.1 **/ #ifndef __LOGGER_H__ #define __LOGGER_H__ #include &lt;string&gt; #include &lt;memory&gt; #include &lt;thread&gt; #include &lt;mutex&gt; #include &lt;condition_variable&gt; #include &lt;list&gt; //struct FILE; #define LogInfo(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfaf1d93d5e6f5498842ee9725e2984d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39d4bdf56710406ed14d83209cfda449/" rel="bookmark">
			关于这个码龄……
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		真是黄豆汗！
这段时间闲了，一边鸡血儿子学编程，自己一边也打算真正掌握一两样技术。
找资料的过程中发现我居然在CSDN有账号！码龄还有十几年了！
无语~当年没有选择这个行业，从事了一个钱少事少离家近的工作。看着这码龄，真是惭愧啊……
码龄十几年的小白。哈哈哈哈！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b11c98a02b96519dc16d31283b26d46a/" rel="bookmark">
			Linux的mysql主从配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主机配置 第1步：配置master 查看是否开启binlog日志 show variables like '%log_bin%';
开启mysql的binlog日志 vim /etc/my.cnf 插入配置log-bin=/usr/local/mysql/mysql-bin mysql5.7无法启动服务改为：log-bin=mysql-bin 能正常启动server-id=123server-id的值必须与其他节点的不一样， 第2步：重启mysql systemctl restart mysqld /service mysqld restartsystemctl status mysqld重新查看bin-log日志文件 show variables like ‘%log_bin%’ log-bin ON 表示已开启
第3步：创建用户 主节点上创建有复制权限的用户，其他从节点可以通过该用户进行主从复制.create user zwh identified by ’123456’ grant all privileges on *.* to ‘zwh'@'%' identifield by ‘123456'
'%' :表示所有的ip地址都可以访问该用户
刷新权限 flush privileges 从机配置 第1步：开启中继日志 查看中继日志
show variables like '%relay%'
配置中继日志后面添加
vim /etc/my.cnf
#中继日志
server-id=124
relay-log=relay-log
relay-log-index=relay-log.index
保存之后重启
service mysqld restart 或者 systemctl restart mysql
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b11c98a02b96519dc16d31283b26d46a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee3eed134e0beee60d12b52477849eb4/" rel="bookmark">
			PySide2开发时遇到的常见问题与解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是一名热爱Python开发的初三党，当我第一次接触PySide2时，那时的官方文档不是很全，网上教程也相对较少，主要还是PySide2发布较晚的问题，那么我今天就来和大家分享一下我在使用PySide2开发图形界面时遇到的一些问题与解决方案，PyQt5、PySide6同时适用。全文无废话，直接放代码。
问题一 按钮相关问题 1、按钮绑定函数 假设我的按钮名为：yourLabelName，我需要绑定的函数为：yourFunctionName()，直接使用clicked.connect来连接到函数。
self.yourLabelName.clicked.connect(yourFunctionName) # 括号中添加绑定函数名，函数名后不添加括号 2、按钮多次触发函数 之前当我运行我的第一个按钮事件时，突然遇到个严重问题，按下后绑定的函数多次执行，解决方法：条件同上，只需在函数名后加Qt.UniqueConnection即可。解释：与槽连接时Qt默认使用AutoConnection模式，需要更改为UniqueConnection模式来防止重复连接，如果当前信号和槽已经连接过了，就不再连接了。
self.yourLabelName.clicked.connect(yourFunctionName, Qt.UniqueConnection) # 只需在后面加Qt.UniqueConnection即可 问题二 刷新页面问题 1、实现线程实时刷新页面 我之前练习做计时器时，页面刷新问题困扰我好久，直至查阅PyQt5的教程时才得以解决。详情请单击此处链接查看。
其中需要注意的：如果你使用的为Qt Designer生成Python代码，在使用该方法刷新页面时，注意：请将UI类retranslateUi函数中首行代码删除，否则刷新无效，示例如下：
def retranslateUi(self, Widget): # UI类中retranslateUi函数 Widget.setWindowTitle(QCoreApplication.translate("Widget", u"Widget", None)) # 一定要删除该行，否则刷新页面无效果 2、触发按钮刷新页面 def uiUpdate(self): # 定义槽函数，该函数请在类中插入，括号里加self，不然会报错 …… QApplication.processEvents() 学以致用，假设我的按钮名为：yourLabelName，函数绑定示例：
self.yourLabelName.clicked.connect(self.uiUpdate, Qt.UniqueConnection) # 在类中定义的函数须在前面加self 问题三 打包运行问题 1、Pyinstaller 相关 不要使用pyinstaller里 -F 单文件打包指令打包后报错提示："ModuleNotFoundError: No moduel named 'PySide2.QtXml'"时，在打包命令后加 --hidden-import PySide2.QtXml 。例如：假设我需要打包的文件名为pysideExam.pyw pyinstaller pysideExam.pyw --hidden-import PySide2.QtXml # 其中 --hidden-import 作用为导入丢弃相应报错的包 2、引用 .ui 文件相关 如果你使用直接加载 .ui 文件的方式，请将 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee3eed134e0beee60d12b52477849eb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/057e9ad837422dfe3b120bcb445bbca2/" rel="bookmark">
			日期转换知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Date date = new Date(); //建立Calendar实例(util包下的) Calendar cal = Calendar.getInstance(); cal.setTime(date); //设置当前时间 cal.add(Calendar.YEAR, 1); //在当前时间基础上加一年 //增长一个月和一天： cal.add(Calendar.MONTH, 1); cal.add(Calendar.DATE, 1); //转换成Date
cal.getTime() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d484923a217924d970ec5918ebb9e41f/" rel="bookmark">
			泛微E8设置开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先找到 Idea 开发工具的设置：
在 File Types 里面，找忽略的文件夹，是否有 classbean、如有则无法将其添加为泛微的系统库：
然后添加 Resin 目录下的 /lib 目录、项目目录下的 WEB-INF/lib 目录、项目目录下的 classbean 目录 （注意不是 classbeankeys 目录）共三个系统库。
将项目的 WEB-INF/lib 目录添加为项目的依赖库，也是必须做的。原理同上。 再设置泛微编译的输出目录为 classbean 目录。
最后在 Resin 的 /conf 目录下的 resin.xml 中，修改 &lt;web-app&gt;标签中的内容为项目目录本身。
在 Idea 开发工具中新建 Resin 服务。如果没有 Resin 实例时，需要从模板填写参数后、点击右上角的创建按钮，添加一个 Resin 服务器实例。
Server 页的配置参考如下：Deployment 页参考如下： 注意部署方式选 resin.xml，而不是 JMX。Before launch 选项只需要一个 build 。记得将项目的根目录配置到 Deployment 中。
就基本可以把测试环境运行起来了。
（完）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a23e00b995858376fc035b25090ac5b1/" rel="bookmark">
			web篇（一）过滤器、拦截器、监听器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中之前也都用过这些东西，现在写出来，一是记录在项目中的使用，二是全面认识一下三大利器。思来想去，我认为这三大利器总的目的是为了解耦，让代码更加简洁可读，所以问题来了，它是怎样实现的呢？这种方式是不是我也可以用到我自己编码的过程中呢？这都要自己一点点去探索，可能这篇不能马上解决这个问题，但在后续的文章会慢慢解读。
目录
一、过滤器和拦截器的区别
二、监听器
三、使用场景
四、总结 一、过滤器和拦截器的区别 使用范围不一样。过滤器是作用在servlet容器中的，而且拦截器是spring组件，作用在spring中的。使用的资源不一样。由于第一点，过滤器只能涉及到request/repnose等；而拦截器归spring管理，spring中的配置、bean等都可以使用。深度不一样。过滤器只在servlet前后起作用；而过滤器可以在方法前后、异常抛出前后等，拦截器有更大的灵活性，故在spring架构中，建议优先使用拦截器 二、监听器 监听器的作用是监听一些事件的发生从而进行一些操作，比如监听ServletContext,HttpSession的创建，销毁，从而执行一些初始化加载配置文件的操作，当Web容器启动后，Spring的监听器会启动监听，监听是否创建ServletContext的对象，如果发生了创建ServletContext对象这个事件(当web容器启动后一定会生成一个ServletContext对象，所以监听事件一定会发生)，ContextLoaderListener类会实例化并且执行初始化方法，将spring的配置文件中配置的bean注册到Spring容器中
常用的监听器：
1.ServletContextListener -- 监听servletContext对象的创建以及销毁
1.1 contextInitialized(ServletContextEvent arg0) -- 创建时执行
1.2 contextDestroyed(ServletContextEvent arg0) -- 销毁时执行
2.HttpSessionListener -- 监听session对象的创建以及销毁
2.2 sessionCreated(HttpSessionEvent se) -- 创建时执行
2.2 sessionDestroyed(HttpSessionEvent se) -- 销毁时执行
3.ServletRequestListener -- 监听request对象的创建以及销毁
3.1 requestInitialized(ServletRequestEvent sre) -- 创建时执行
3.2 requestDestroyed(ServletRequestEvent sre) -- 销毁时执行
4.ServletContextAttributeListener -- 监听servletContext对象中属性的改变
4.1 attributeAdded(ServletContextAttributeEvent event) -- 添加属性时执行
4.2 attributeReplaced(ServletContextAttributeEvent event) -- 修改属性时执行
4.3 attributeRemoved(ServletContextAttributeEvent event) -- 删除属性时执行
5.HttpSessionAttributeListener --监听session对象中属性的改变
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a23e00b995858376fc035b25090ac5b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54be86d0140ebdda1f0fd2151cfca61e/" rel="bookmark">
			IDEA连接码云(Gitee)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载、安装git
1.打开git官网，选择你的操作系统
官网下载地址：https://git-scm.com/downloads
2.根据你的系统位数选择相应的版本下载
系统位数一般都是64位。
3.安装
打开你下载的那个 exe 文件。
直接 next 是最简单的方式，复杂的选项就不介绍了，没必要。
注意在安装过程中记住你的安装目录。默认在“ C:\Program Files ”目录下。
4.配置全局的用户名、邮箱
安装完成以后，需要配置用户名、邮箱。你提交代码到别人仓库的时候总得有个身份吧？就是这个作用。就用你Gitee的注册邮箱吧。
打开左下角系统菜单，找到 Git Bash ，点击打开
分别输入以下代码并回车，注意把引号中的用户名、邮箱改成你自己的。
如果你没配置用户名、邮箱，以后会弹出以下窗口，也可以配置：
5.在idea中配置git目录
1.选择idea的File选项卡，选择Setting打开设置
2.选择Version Control下的Git
3.选择那三个点
4.选择你的Git安装目录下的bin–&gt;git.exe，点击OK
5.点击“Test”，出现版本号就成功了。
二、配置Gitee插件
提前准备：码云账号（https://gitee.com/）
1.选择idea的 File 选项卡，选择 Setting 打开设置
2.安装码云官方插件gitee
2.1选择Plugins，搜索框输入gitee，点击“search in repositories”搜索存储库
2.2选择搜索结果中的 Gitee 安装
2.3安装完成后点击重启IDEA即可
安装完成后重启
3.配置gitee的API token
3.1打开设置页面，选择Version Control下的“Gitee”
3.2点击右边的“Create API token”
3.3在弹出的登录框中输入登录名和密码，点击“Login”登录
注意，此处用户名并不是你的手机号、邮箱，而是你码云个人主页里的用户名
3.4登录以后测试是否成功
三、克隆与上传项目
克隆项目
在码云或GitHub这些项目托管网站找到项目地址：打开项目，点击右边的“克隆”，然后复制项目地址
选择“File”–&gt;“New”–&gt;“Project from Version Control”–&gt;“Git”
在“URL”输入第一步复制的项目地址，点击Test，“Connection successful”连接成功，在“Directory”选择保存地址以后点击“Clone”
等待克隆。打开项目，大功告成。
上传项目
1.打开项目，工具栏选择“VCS”–&gt;“Import into Version Control”–&gt;“Share Project on Gitee”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54be86d0140ebdda1f0fd2151cfca61e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33e8ce3f13104f9bb16730a7b6b8c194/" rel="bookmark">
			Java面试题之：sql优化方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java面试题之：sql优化方式 一、索引查询、避免全表扫描二、查询数据尽量避免使用or三、连续查询，能用between就用四、where查询条件，对字段进行表达式操作五、where查询条件，对字段进行函数操作六、多张数据表查询数据，使用inner join七、in()和exists()八、使用like进行数据表查询时，能用%就不建议使用双%九、最左优先十、精确类型匹配十一、表越小，查询越快十二、数据量大时，合理使用分区表十三、合理选择存储引擎十四、慢查询日志 一、索引查询、避免全表扫描 查询数据库的数据尽量使用索引来查询，避免全表扫描。尽量只查询索引条件的字段，
例如：一张名为user用户数据表的id字段为索引，name字段为用户为非索引字段，当查询某条数据时，只查询id比查询name效率会高很多。因为叶子节点存储id的值，这样不用回表查询，实现了索引覆盖。
比如：查询select id from user 比select name from user效率高。
二、查询数据尽量避免使用or 从数据库中查询数据，sql语句尽量避免使用or来连接条件查询数据。因为使用or会导致执行sql的时候进行数据范围的索引扫描或者全表扫描，效率降低。
例如：select id from user where name=‘a’ or name=‘b’，可以改为以下的形式来提高查询的效率：select id from user where name=‘a’ union select id from user where name=‘b’；改了之后，两次查询都是走索引，效率相对较高。
三、连续查询，能用between就用 在连续数值的查询中，能使用between的情况下，尽量使用between，而不使用in。in和not in可能会导致全表查询。
四、where查询条件，对字段进行表达式操作 sql语句的where查询条件，对字段进行表达式的操作，会导致mysql引擎放弃使用索引而进行全表扫描。
例如：select * from user where age/2=10(age字段有索引)(整体不走索引)。
五、where查询条件，对字段进行函数操作 sql语句的where查询条件，对字段进行函数操作，也会导致mysql引擎放弃使用索引而进行全表扫描查询。
例如：select name from user where SUBSTR(name,2,3)=‘tom’;
六、多张数据表查询数据，使用inner join 多张数据表查询数据，使用inner join，left/right join来代替子查询。因为子查询需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。
七、in()和exists() in()适合B表比A表数据小的情况，exists()适合B表比A表数据大的情况；
例如：select * from user a where exists (select name from user b where a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33e8ce3f13104f9bb16730a7b6b8c194/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2737df7d95c9d6d0f50f4026cfe1243/" rel="bookmark">
			Android hidl开发简单教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android hidl开发简单教程
开发前的准备
开发前的准备
关于hidl的前世今生就不多说了,网上百度就挺多的了,主要是我也不是很懂,哈哈哈,这个只是记录一下我在按照网上的教程开发hidl的时候遇到的一些问题,然后说一下我在跟着别人教程学习的时候遇到过的一些问题,改正后成功的例子,希望能对大家学习有一点点帮助.
开发hidl我们首先需要:
①Android的编译环境
②编译过的Android源码(我的是Android 10)
③Android 设备(我的是手机)
第一步:创建文件夹路径和.hal文件
为这个代码想一个好听的名字,我们就叫xiaoming吧,然后相应目录下创建文件夹,如下:
// 在你的Android源码的hardware/interfaces/目录下创建
mkdir -p xiaoming/1.0/default
然后,在你的1.0目录下创建Ixiaoming.hal文件
vim IXiaoming.hal
在里面输入: 1 package android.hardware.xiaoming@1.0; 2 3 interface IXiaoming { 4 helloWorld(string name) generates (string result); 5 }; 这里面只有一个简单的hellowork程序,实现会在下面介绍.
创建完成后的文件路径是这个样子的:
.
└── 1.0
├── default
└── IXiaoming.hal
第二步:使用hidl-gen工具
hidl-gen工具是Google在Android 8.1改变HAL之后,为了帮助开发者生成一些HAL层的相关代码框架和代码实例,方便开发者使用.
首先执行以下代码:(需要在源码根目录下root权限执行)
1 PACKAGE=android.hardware.xiaoming@1.0 2 LOC=hardware/interfaces/xiaoming/1.0/default/ 3 make hidl-gen 4 hidl-gen -o $LOC -Lc++-impl -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport $PACKAGE 5 hidl-gen -o $LOC -Landroidbp-impl -randroid.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2737df7d95c9d6d0f50f4026cfe1243/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/298/">«</a>
	<span class="pagination__item pagination__item--current">299/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/300/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>