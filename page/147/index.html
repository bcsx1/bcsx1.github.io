<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f3e4432b7c90c4acec7c8e297ff3b09/" rel="bookmark">
			设计模式之原型模式（深拷贝&amp;浅拷贝）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、什么是原型模式
2、前置知识（深拷贝&amp;浅拷贝）
2.1 浅拷贝
2.2 深拷贝
3、代码实现
3.1 通过Object中的clone方法实现浅拷贝
3.2 通过对象流来实现深拷贝
4、原型模式总结
4.1 优缺点
4.2 使用场景
4.3 对比直接new对象有何不同
1、什么是原型模式 原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式之一。
这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。
2、前置知识（深拷贝&amp;浅拷贝） 2.1 浅拷贝 创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原
有属性所指向的对象的内存地址。
2.2 深拷贝 创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。
3、代码实现 3.1 通过Object中的clone方法实现浅拷贝 学生类：
public class Student implements Cloneable{ //学生类，要使用clone的话要实现Cloneable接口，否则会报错 private String name; //学生姓名 private int age; //学生年龄 public Student(String name,int age){ //构造函数 this.name=name; this.age=age; } public void get(){ //输出学生信息 System.out.println("名字是："+name+"------年龄是："+age); } @Override protected Object clone() throws CloneNotSupportedException { //重写clone方法 return super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f3e4432b7c90c4acec7c8e297ff3b09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3af9719b6be786d2198cf411a48fdf85/" rel="bookmark">
			蓝牙模块---主从连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蓝牙模块主从模式
蓝牙模块的主从通信通俗来讲就是两块蓝牙之间通信，一块蓝牙作为主机，另一块为从机。当前市面上有多种蓝牙模块，有些蓝牙模块只有从机功能。再购买的时候一定要明确购买的蓝牙模块是否为主从一体式的（主从一体式的蓝牙模块价格往往要贵一点）。
配置蓝牙模块（我们拿HC-05蓝牙模块举例）
我们还需要一块USB_TTL
蓝牙模块于TTL的连线方式：
TTL HC-05
5V VCC
GND GND
RXD TXD
TXD RXD
连接好后我们就可以进行蓝牙模块的配置了
HC-05蓝牙模块有两种模式HC-05有个开关，HC-05模块上有一个小按键，不按的时候是可配对状态，1秒闪2次。按住按钮再上电HC-05就会进入AT模式了，严格的讲，它只是一个开的作用，无法退出AT模式。（退出的话可以在串口发送AT+RESET复位，或者重新上电）此时指示灯慢闪（2秒亮一次），模块进入AT状态。进入到AT模式后就可以配置蓝牙模块。
AT模式下的HC-05模块波特率为38400，所以我们需要将波特率改为38400
打开串口在发送区输入AT
点击发送如果蓝牙模块成功接收到指令就会返回OK
下面是常见一些AT指令
AT+UART?：获得串口参数，串口的参数一共有三个，波特率、停止位、检验位。
蓝牙主从机通信
1.选用其中一块为主机
AT+ROLE=1 //从机模式：0 主机模式：1 回环模式：2 初始默认为从机模式（0）
另一块为从机
2.我们需要获取蓝牙模块的地址
AT+ADDR?
3.连接蓝牙地址
主机连接从机也是如此
重新上电，连接成功后HC-05上的指示灯将进入2s周期的快速双闪,那么我们的主从机模块就算连接成功了。
下面我们就可以完成主从机通信了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/750873ec1569bf8846b28b19cdc323eb/" rel="bookmark">
			Android的RecyclerView实现两个列表一起滑动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.先看效果图，滑动左边的列表，右边的列表也会跟着滑动。滑动右边的列表，左边的列表也会跟着滑动。
这里是视频演示
RecyclerView实现两个列表一起滑动
2.主活动MainActivity2类的代码如下
import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import androidx.recyclerview.widget.LinearLayoutManager; import androidx.recyclerview.widget.RecyclerView; import android.annotation.SuppressLint; import android.os.Bundle; import android.util.Log; import com.example.myapplication001.R; import java.util.ArrayList; import java.util.List; public class MainActivity2 extends AppCompatActivity { private HomeAdapter rv_1_homeAdapter,rv_2_homeAdapter; RecyclerView rv_1,rv_2; int mDx; LinearLayoutManager rv_1_Manager,rv_2_Manager; @SuppressLint({"MissingInflatedId", "WrongViewCast"}) @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); rv_1=findViewById(R.id.rv_1); rv_2=findViewById(R.id.rv_2); List&lt;String&gt; titles = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 50; i++) { titles.add("中文"+i); } rv_1_homeAdapter = new HomeAdapter(getApplicationContext(),titles); rv_1_Manager=new LinearLayoutManager(getApplicationContext()); //这里使用垂直滑动 rv_1_Manager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/750873ec1569bf8846b28b19cdc323eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f68d242cf6f079bbd1bd6019aae71c5/" rel="bookmark">
			node.js-概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. node.js是什么 是一个app, 可以运行js的代码的一个程序
使用一套命令来操作js文件.
并不是一种编程语言.
准确的说, node.js是一个js代码的运行环境, 可以使的js代码脱离浏览器运行, 实现在操作系统上运行js的代码的目的.
基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。
2. node.js可以做什么 总所周知, 像go\java等可以构建一个后端的服务器程序, 但是go或者java一样要依赖于各自的环境, 如今的项目基本都是前后端分离的项目.
所以, node.js就是用来构建前端服务器的.
再者, 前端的框架也是基于node.js的.
构建server应用开发工具类应用: 例如webpack, vite, babel开发c端应用, 例如: vscode, figma, postman 3. 和浏览器的不同 node.js中, js的代码并不同调用到bom和dom相关的APi, 这个很好理解. 都不是一个运行环境, 怎么调的到.
在浏览器中, js的顶级对象是window, 但是在node的环境中, js的顶级对象是global.
4. node操作内存: Buffer 就是一个可以直接操作内存的, 长度固定, 不可以不改变的, 字节数组, 其实就是内存上的一段空间.
创建方式有三种:
// 1. alloc : 分配 let buf = Buffer.alloc(10); // 2. alloc : 不安全的分配 let buf2 = Buffer.allocunsafe(10); // 并不会对该内存空间做一个清零的擦除动作, 也就是说, 有会初始脏数据 // 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f68d242cf6f079bbd1bd6019aae71c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efca0b4e793dfe2f1c139ba21c784c10/" rel="bookmark">
			谷歌浏览器访问抖音网页版白屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谷歌浏览器访问抖音网页版白屏 前言解决 前言 习惯谷歌浏览器刷刷网页版抖音，最近突然作了限制除了首页都是白屏，更换浏览器正常访问。
解决 分析请求发现user-agent的型号被拦截了。
安装ModHeader，随意更改一下请求头即可正常访问。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/686bf406a1c6d0f1b9b096a2cbff5da4/" rel="bookmark">
			C&#43;&#43; STL之vector容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、vector容器的介绍
二、vector容器的使用
1.vector的构造函数
2.vector的赋值操作
3.vector的容量与大小
4.vector的插入和删除
5.vector的数据存取
6.vector的互换容器
7.算法模块在vector的应用
①find算法(std)
②sort算法(std)
一、vector容器的介绍 引用的头文件：#include&lt;vector&gt;
vector是C++ STL中的一个容器，它是一个动态数组，可以进行元素的插入和删除，在此过程中，vector会动态调整所占用的内存空间，整个过程无需手动干预。vector容器是一个封装了动态大小数组的顺序容器，能够存放各种类型的对象（包括自定义类型）。vector容器中的元素按照严格的线性顺序排序。vector容器的空间是动态增长的。
能够存放各种类型的对象：
如：vector&lt;string&gt; v1;
vector&lt;list&lt;int&gt;&gt; v2;
vector&lt;string&gt; s = {"a", "aa", "aaa"};
动态增长：当新元素插入时候，这个数组需要被重新分配大小为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector并不会每次都重新分配大小。
按照严格的线性顺序排序：允许使用容器时，进行随机访问。
通常，使用 vector 容器是最好的选择，除非你有很好的理由选择其他容器。
二、vector容器的使用 1.vector的构造函数 vector&lt;T&gt;; // 使用模板类，默认构造函数 vector&lt;T&gt;(size_t n, const T&amp; val = T()); // vector&lt;T&gt;{a, b, c, ...}; // 包含了初始值个数的元素 vector&lt;T&gt; = {a, b, c, ...}; // 等价于vector&lt;T&gt;{a, b, c, ...}; vector&lt;T&gt;(v.begin(), v.end()); // 将[v.begin(),v.end())区间中的元素拷贝给本身 vector&lt;T&gt;(size_t n, const T&amp; val = T()); // 将n个val拷贝给本身，若val未指定则以默认值初始化 vector&lt;T&gt;(const vector &amp;v); // 拷贝构造函数 使用如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/686bf406a1c6d0f1b9b096a2cbff5da4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb080e7f07e58133434071c4100ccccd/" rel="bookmark">
			渗透测试中Windows、Linux敏感文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Windows敏感文件： SAM和SYSTEM文件：SAM文件和SYSTEM文件分别存储Windows系统中的用户账户信息和安全设置信息。这些文件通常位于Windows\System32\Config目录中，并且只有系统管理员可以访问它们。攻击者可以利用特殊工具（如SAMInside）来提取这些文件中的密码哈希值，从而进行密码破解。
NTUSER.DAT文件：NTUSER.DAT文件包含当前用户在Windows系统中的配置设置。这些设置包括桌面背景、文件夹选项和应用程序设置等。攻击者可以访问NTUSER.DAT文件并进行修改，以便在用户登录时执行恶意代码或窃取敏感信息。
PAGEFILE.SYS文件：PAGEFILE.SYS文件是Windows系统中的虚拟内存文件。它通常存储在系统根目录下，并包含系统中未使用的内存页面的备份。攻击者可以利用特殊工具来分析PAGEFILE.SYS文件并提取其中的敏感信息，例如密码哈希值。
INI和CFG文件：INI和CFG文件是许多应用程序使用的配置文件。这些文件通常存储在Windows\System32或程序安装目录中，包含应用程序的设置、密码、数据库连接信息等敏感信息。攻击者可以访问这些文件并进行修改，以便执行恶意代码或窃取敏感信息。
LNK文件：LNK文件是Windows中的快捷方式文件。这些文件包含了指向其他文件或应用程序的链接。攻击者可以通过修改LNK文件中的目标路径来执行恶意代码或者欺骗用户下载恶意软件。
HIBERFIL.SYS文件：HIBERFIL.SYS文件是Windows系统中的休眠文件。它通常存储在系统根目录下，并包含当前系统状态的备份。攻击者可以利用特殊工具来分析HIBERFIL.SYS文件并提取其中的敏感信息。
boot.ini文件：boot.ini文件存储了Windows系统启动时所需的参数。这些参数包括操作系统选项、系统语言、启动顺序等。攻击者可以通过修改boot.ini文件来执行恶意代码或者修改启动参数，从而导致系统无法正常启动。
win.ini文件：win.ini文件是Windows系统中的配置文件，它包含了一些系统和应用程序的设置。这些设置包括桌面图标、字体、颜色等。攻击者可以修改win.ini文件中的配置项，以便执行恶意代码或者窃取敏感信息。
msdos.sys文件：msdos.sys文件是Windows 9x系统中的启动文件。它包含了系统启动时所需的一些参数和驱动程序。攻击者可以修改msdos.sys文件，以便在系统启动时执行恶意代码或者修改系统设置。
user.dat文件：user.dat文件包含了Windows系统中用户的个性化设置。这些设置包括桌面背景、文件夹选项和应用程序设置等。攻击者可以访问user.dat文件并进行修改，以便在用户登录时执行恶意代码或窃取敏感信息。
explorer.exe文件：explorer.exe文件是Windows系统中的文件管理器。攻击者可以利用漏洞修改explorer.exe文件，以便执行恶意代码或者窃取敏感信息。
cmd.exe文件：cmd.exe文件是Windows系统中的命令行解释器。攻击者可以利用漏洞修改cmd.exe文件，以便执行恶意代码或者窃取敏感信息。
regedit.exe文件：regedit.exe文件是Windows系统中的注册表编辑器。攻击者可以利用漏洞修改regedit.exe文件，以便执行恶意代码或者窃取敏感信息。
notepad.exe文件：notepad.exe文件是Windows系统中的文本编辑器。攻击者可以利用漏洞修改notepad.exe文件，以便执行恶意代码或者窃取敏感信息。
winver.exe文件：winver.exe文件是Windows系统中的版本信息查看器。攻击者可以利用漏洞修改winver.exe文件，以便执行恶意代码或者窃取敏感信息。
rundll32.exe文件：rundll32.exe文件是Windows系统中的动态链接库加载器。攻击者可以利用漏洞修改rundll32.exe文件，以便执行恶意代码或者窃取敏感信息。
二、Linux敏感文件： /etc/shadow文件：/etc/shadow文件存储着Linux系统中用户的加密密码。这些密码是经过哈希算法加密的，并且只有root用户才有权限查看此文件。但是，如果攻击者成功获取了root权限，他们就可以读取这个文件，并且通过暴力破解或其他手段解密密码。
/etc/passwd文件：/etc/passwd文件存储了Linux系统中的用户账户信息。这些信息包括用户名、用户ID、主目录、默认shell等。攻击者可以利用这个文件来获得系统用户的信息，并且通过修改这个文件来添加新的用户账户或者提高自己的权限。
/etc/group文件：/etc/group文件存储了Linux系统中的用户组信息。攻击者可以利用这个文件来查找用户组的信息，并且通过修改这个文件来添加新的用户组或者提高自己的权限。
/etc/hosts文件：/etc/hosts文件存储了Linux系统中的IP地址和主机名的映射关系。攻击者可以通过修改这个文件来欺骗用户访问恶意网站或者重定向网络流量。
/etc/crontab文件：/etc/crontab文件存储了Linux系统中的定时任务信息。攻击者可以利用这个文件来添加定时任务并在系统中执行恶意代码。
/etc/fstab文件：/etc/fstab文件存储了Linux系统中的文件系统信息。攻击者可以利用这个文件来挂载恶意文件系统并执行恶意代码。
/etc/sudoers文件：/etc/sudoers文件存储了Linux系统中sudo命令的配置信息。sudo是Linux系统中的一个特权命令，可以让普通用户以root用户的身份执行命令。攻击者可以利用这个文件来提高自己的权限并执行恶意代码。
/etc/shells文件：/etc/shells文件存储了Linux系统中所有可用的shell列表。攻击者可以通过修改这个文件来添加新的shell并获得系统访问权限。
/etc/sysctl.conf文件：/etc/sysctl.conf文件存储了Linux系统中内核的配置参数。攻击者可以利用这个文件来修改内核配置并执行恶意代码。
/etc/ld.so.preload文件：/etc/ld.so.preload文件存储了Linux系统中需要预先加载的动态链接库列表。攻击者可以通过修改这个文件来执行恶意代码或者提高自己的权限。
总结： 了解敏感文件在操作系统安全方面非常重要。攻击者可以通过访问和修改这些文件来执行恶意代码、窃取敏感信息或提高自己的权限。因此，管理员需要密切
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba4cd87220d9e043a5f61416a46dbcf8/" rel="bookmark">
			整数拆分(leetcode)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 题目链接：343. 整数拆分 - 力扣（LeetCode）
给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;= 2 ），并使这些整数的乘积最大化。
返回 你可以获得的最大乘积 。
示例 1:
输入: n = 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。 示例 2:
输入: n = 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 思路 使用动态规划思想
1、dp数组表示的含义？ 假设 dp[i] 表示将整数 i 拆分为 k 个正整数的和并使这些整数的乘积最大化时，可以获得的最大乘积。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba4cd87220d9e043a5f61416a46dbcf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f373b04e527ae448dd6bc83fc9142b8/" rel="bookmark">
			目录穿越/遍历漏洞及对其防御方法的绕过
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录穿越/遍历漏洞及对其防御方法的绕过 介绍： 目录穿越（目录遍历）是一个Web安全漏洞，攻击者可以利用该漏洞读取运行应用程序的服务器上的任意文件。 这可能包括应用程序代码和数据，后端系统的登录信息以及敏感的操作系统文件。目录穿越不仅可以访问服务器中的任何目录，还可以访问服务器中任何文件的内容。例如，攻击者通过浏览器访问…/…/…/…/…/…/…/…/…/…/…/…/…/…/etc/passwd（此处较多…/），就可以读取Linux服务器根目录下的etc目录下的passwd文件的内容。
目录穿越比目录浏览、目录遍历更具破坏性，目录穿越不仅可以读取服务器中任何目录及任何文件的内容，还可以执行系统命令。又例如攻击者通过浏览器访问s/…%5c…/Windows/system32/cmd.exe?/C+dir+C:，使用IIS中间件的s目录来变换目录并达到执行命令的目的。这个Web请求会返回C:所有文件列表，这是通过调用cmd.exe程序并执行dir C:命令来实现的。%5c是Web服务器的转换符，用来代表一些常见字符，这里表示的是反斜杠。
原理： 1、./是当前目录
2、…/是父级目录（回到当前文件夹下的，上一个文件夹）
3、/是根目录（回到最顶端的那个文件夹下）
看道例题（buuctf的exec1）： 联合执行ls /后发现flag文件，直接cat /flag：
发现不太行，所以要老老实实加上路径，可是不知道绝对路径，想到可以用目录穿越：
构造…/…/…/…/…/…/flag，拿到flag
反目录穿越的防御措施： 1.绝对路径： web网站有时候会采取目录遍历的防御措施，如过滤 …/ 上一级等关键字，然后简单的过滤通常会被绕过。有时候可以直接采用绝对路径，无须…/返回上一级目录遍历。
2.双写…/绕过： 有时候，防御措施是直接将 …/ 替换为空，可以直接采用双写/复写直接绕过（filename=…//…//…///etc/passwd）。
3.URL编码绕过： 也可以采用URL编码来绕过服务器对 . 或者 / 的检测（大部分情况需要双重编码）：
. =&gt; %2c
/ =&gt; %2f
% =&gt; %25 (双重URL编码)
4.截断文件后缀： 某些web对filename的文件类型作了限制，只有当后缀为图片时才解析，这时候就可以利用 %00 来截断。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61f1d129b3169b8642312376652b0cc6/" rel="bookmark">
			数字图像处理简答题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.人类视觉对颜色的主观感觉包括哪三类？
2. 图像成像的过程包括哪三步？
3.图像的采样和量化分别指什么？
4、取k=8时，将下图用相应矩阵表示
5、简述当限定了数字图像的数据量时采样和量化参数的选择遵循哪两条原则？
1.人类视觉对颜色的主观感觉包括哪三类？ 人类视觉对颜色的主观感觉可以分为以下三类：
色相（Hue）：也称色调，指的是颜色在色谱中所处的位置，比如红色、绿色、蓝色等。
饱和度（Saturation）：指颜色的纯度或强度，也就是颜色的强弱程度。当颜色的饱和度越高，它就越纯，越不含白色或灰色成分，越鲜艳醒目；当饱和度越低，颜色就越灰暗、柔和、暗淡。
亮度（Brightness）：指颜色的明暗程度，也就是颜色的亮度或暗度。亮度越高，颜色就越明亮、明亮、清晰，反之亮度越低，颜色就越暗淡、灰暗、朦胧。
2. 图像成像的过程包括哪三步？ 图像成像的过程可以分为以下三个步骤：
采集：该步骤涉及到将图像所代表的物理信息转化为数字信号，通常是通过摄像机或扫描仪进行采集。
处理：在此步骤中，数字信号会经过数字信号处理，以提高图像的质量或进行图像增强。这些处理包括去噪、增强对比度、锐化等。
显示：最后一步是将处理后的图像显示出来。这通常是通过计算机屏幕或打印机来完成的，也可以是其他的显示设备，例如投影仪或电视。
3.图像的采样和量化分别指什么？ 在数字图像处理中，采样和量化是两个重要的步骤。
采样是指将连续的模拟信号转换为离散的数字信号，这通常通过在空间和时间维度上对信号进行采样来完成。在数字图像处理中，采样通常指在图像的空间维度上进行采样，即将连续的图像转换为由像素表示的离散图像。采样的过程中，需要选择适当的采样率来平衡图像的分辨率和存储需求。
量化是指将连续的信号转换为离散的数字信号值，它涉及将采样后的数字信号映射到一组离散的取值。在数字图像处理中，量化通常指将采样后的图像像素值映射为一组离散的整数值，以便将其存储和处理。量化的过程中，需要选择适当的量化级别来平衡图像的质量和存储需求
4、取k=8时，将下图用相应矩阵表示 5、简述当限定了数字图像的数据量时采样和量化参数的选择遵循哪两条原则？ 当限定了数字图像的数据量时，采样和量化参数的选择需要遵循以下两条原则：
最大化信息保留：在限定数据量的前提下，采样和量化过程中应尽可能地最大化图像中包含的信息量。这通常需要选择适当的采样率和量化级别，以平衡图像的质量和存储需求。如果采样率过低或量化级别过低，会导致信息丢失和图像质量下降。
最小化失真：采样和量化过程中应尽量最小化图像的失真程度。采样过程中，过高或过低的采样率会导致失真；量化过程中，过高或过低的量化级别也会导致失真。因此，需要在信息保留的前提下，选择适当的采样率和量化级别，以尽量减少失真程度。
综合考虑这两条原则，可以选择适当的采样率和量化级别，以平衡图像的信息保留和失真程度，从而实现最佳的图像质量和数据存储效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90389485b46a45af542ff3ef9c54c583/" rel="bookmark">
			【目标检测】YOLOV8实战入门（五）模型预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		predict模式用于在新图像或视频上使用经过训练的YOLOv8模型进行预测，在此模式下，模型从checkpoint 文件加载，用户可以提供图像或视频来执行推理。模型预测输入图像或视频中对象的类别和位置。
from ultralytics import YOLO from PIL import Image import cv2 model = YOLO("model.pt") # 接受所有格式-image/dir/Path/URL/video/PIL/ndarray。0用于网络摄像头 results = model.predict(source="0") results = model.predict(source="folder", show=True) # 展示预测结果 # from PIL im1 = Image.open("bus.jpg") results = model.predict(source=im1, save=True) # 保存绘制的图像 # from ndarray im2 = cv2.imread("bus.jpg") results = model.predict(source=im2, save=True, save_txt=True) # 将预测保存为标签 # from list of PIL/ndarray results = model.predict(source=[im1, im2]) YOLOv8预测模式可以为各种任务生成预测，在使用流模式时返回结果对象列表或结果对象的内存高效生成器。通过在预测器的调用方法中传递stream=True来启用流模式。stream=True的流媒体模式应用于长视频或大型预测源，否则结果将在内存中累积并最终导致内存不足错误。
inputs = [img, img] # list of numpy arrays results = model(inputs, stream=True) # generator of Results objects for result in results: boxes = result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90389485b46a45af542ff3ef9c54c583/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5cbf539200c50e28b264185b9e96d2c/" rel="bookmark">
			【API】聊天机器人接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传送门： 1. 漫小猫API 2. 天行数据 3. 图灵机器人 4. 青云客网络 5. 海知智能（艾如意宝宝） 6. 腾讯AI开放平台（步骤多，太难搞） 文章目录 一、无key直接调用的api1. 接口地址2. 示例 二、需要个人密钥调用的接口1. 接口地址2. 示例 三、图灵机器人API【正式版收费，参数多】1. 接口地址2. 密钥来源3. 示例（为了方便，使用的是fetch发送请求，和ajax差不多） 四、青云客机器人API【免费，但有同源限制，要后端文件中转】1. 接口地址2. 示例（为了方便，使用的是fetch发送请求，和ajax差不多） 五、如意机器人【免费，参数多，功能多】1. 接口地址2. 机器人调教3. 获取密钥4. 示例【只接受GET请求，POST返回错误JSON】 一、无key直接调用的api 1. 接口地址 漫小猫API聊天接口（免费，还有其它蛮不错的API）
2. 示例 通过ajax发送GET/POST请求，返回JSON数据，拿到数据后输出。
&lt;!DOCTYPE html&gt; &lt;html lang="zh"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * { padding: 0; margin: 0; box-sizing: border-box; } html, body { height: 100%; } ul li { list-style: none; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5cbf539200c50e28b264185b9e96d2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f389bc6da2bb48712c4c7e7b2ce3afe1/" rel="bookmark">
			TSN （Time-Sensitive Networking）时间敏感网络介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TSN （Time-Sensitive Networking）时间敏感网络：缘起 已剪辑自: https://zhuanlan.zhihu.com/p/342279366
TSN历史与现状 前言 随着工业物联网（IIoT）的兴起和工业4.0的提出，越来越多的设计师、工程师和最终用户关注时间敏感网络（Time-Sensitive Networking，下简称为TSN）。TSN为以太网提供确定性性能，本质上是一个传统以太网的扩展集。
TSN 历史 TSN是一项从音视频领域延伸至工业、汽车、移动通信领域的技术，最初来源于音视频领域的应用需求，当时该技术被称为AVB，由于针对音视频网络需要较高的带宽和最大限度的实时，借助AVB能较好地传输高质量音视频数据。
2005年，IEEE802.1工作组成立AVB音视频桥任务组，并在随后的几年里成功解决了音频视频网络中数据实时同步传输的问题。这一点立刻受到来自汽车和工业等领域人士的关注。2012年，AVB任务组在其章程中扩大了时间确定性以太网的应用需求和适用范围，并同时将任务组名称改为现在的TSN任务组。
不论是AVB和TSN，都主要定位于数据链路层（如图1所示）；物理层方面，IEEE也做了新标准：IEEE 802.3bp和IEEE 802.3bw。
图1 传统以太网7层模型结构
传统以太网 以太网的概念是1973年提出的，使用CSMA/CD（载波监听多路访问和冲突检测）技术，通常使用双绞线（UTP线缆）进行组网。包含标准以太网（10Mbit/s）、快速以太网（100Mbit/s）、千兆网（1Gbit/s）和10G以太网（10Gbit/s）。它们符合IEEE802.3。
图2 传统以太网数据帧传输随时间分布图
以太网采用串行方式传输数据，但是带宽由多个设备共享，这也是以太网的优势所在。但是所有的发送端没有基于时间的流量控制，采用尽力而为（BestEffort）的转发机制，即这些发送端永远只是尽最大可能发送数据帧（如图2所示）。如果来自不同设备的数据流在时间上产生重叠，就会发生冲突。由于所有数据流重叠/冲突的部分会遵循QoS优先机制进行转发，这就会造成在网络负载提升以后部分数据包被延迟很久转发甚至被丢弃。在IT行业里有个不成文的规定：当某个交换机的带宽占用率超过40%后就必须要扩容，目的是通过提高带宽来避免拥堵产生。
以太网在发明之时并未考虑实时信息的传输问题。尽管我们可能熟知的广泛应用于视频会议系统、IP电话产业的实时流媒体协议（RTP）能够在一定程度上保证实时数据的传输，但由于网络传输路径的不确定性和设备处理的并发机制导致不能按顺序传送数据包来提供可靠的传输机制。如若需要排序，就需要设置缓冲区来处理数据。但是一旦采用缓冲机制就会引入新的问题—延迟。即当数据包在以太网中传输的时候从不考虑延时、排序和可靠交付。其最大的缺点是不确定性或称之为非实时性。这种不确定性导致传统以太网并不能满足准确定时通信的实时性要求，一直被视为“非确定性”的网络。
尽管传统二层网络已经引入了优先级（Priority）机制，三层网络也已内置了服务质量（QoS）机制，仍然无法满足实时性数据的传输。此外，在传统以太网中，只有当现有的包都处理完后才会处理新到的包，即使是在Gbit/s的速率下也需要几百微秒甚至更多的延迟，满足不了车内应用的需求。更何况目前是Mbit/s的速率，延迟最多可能达上百毫秒，这肯定是无法接受的。传统以太网采用的是事件触发传输模式，在该模式下端系统可以随时访问网络，对于端系统的服务也是先到先服务。事件触发模式的一个明显的缺点是当几个端系统需要在同一传输媒介上同时进行数据通讯时，所产生的传输时延和时间抖动会累积。
AVB 起因和发展 传统的音视频（AV）设备配置曾是单用途的点对点单向连接。这种专用的连接模式使得使用者在应用中需要大量的布线，导致难以管理和操作。解决这一问题有多种经认可的机制，但是所有这些机制都会存在以下一项或多项问题：不标准、难以操作和配置、不灵活、价格昂贵，迁移到以太网是公认的解决专业AV设备需求的方法。
AVB的出现源于市场上包括Dante、CobraNet、EtherSound在内的通信协议，这些协议都是各个厂家独立建立的协议标准，并不是真正的国际通用标准，这对通用性和兼容性存在一定障碍。在此情况下，电气与电子工程师学会（IEEE）802.1委员会组建了专门的工作组提出并出台了AVB技术标准。
AVB的目标是在传统以太网的基础上，通过保障带宽、限制延迟和精确时间同步三个方面来提供服务质量，统一整合实时音视频媒体流和常规异步以太网数据流，以支持各种基于音视频的网络多媒体应用。凭借AVB，管理人员能够采用混合数据网络来管理整个网络，相较于并行独立系统更省时、成本更低、效率更高。
AVB既是IEEE标准，在音频上又有着Dante般的强大优势，同时还能传输视频和控制信号，此外还有AVnu Alliance的强力推进（AVnu Alliance是思科、英特尔、三星、博通、Harman International、赛灵思联手在2009年创立了一个行业联盟，其使命是推广 AVB 标准的使用和认证，并确保AVB 设备之间的兼容性。近些年不少的音响制造商们也纷纷加入这个行列，以确保他们的研发工作都能够严格地遵循这些标准），还没有专利费用，这使得业内想不关注AVB都难。一时间人们纷纷对此给予厚望，认为AVB 的出现必将创造音视频行业的新时代，各公司的私家协议如昨日黄花不日将被淘汰，这些年各大专业展会论坛，AVB总是热门话题，相关产品和方案也是层出不穷。不过只要稍加注意就会发现，在热热闹闹的背后，AVB的实际工程案例确是少之又少，而Dante虽然相对低调，但案例确实越来越多，这是为何呢？
有专家认为： 在AVB发展前期，能够确定和使用的只有音频标准，视频标准迟迟未能确定，音视频同步本是AVB的最大特色，少了视频的AVB就如缺了一条腿，优势大减。此外AVB交换机的端口固定，不如Dante方便，Dante端口可以任意设定、即插即用零配置；同时AVB还需要硬件方面的投资，AVB技术的最重要的核心就在于AVB交换机，但它与现有的以太网交换机不同且不能兼容，这对于用户来说是一笔不小的开销。
AVB的优势就在于大型多通路项目的应用，此类项目涉及金额较大，项目方设备选择谨慎，多会选择成熟产品方案。而AVB相对较新，且支持项目不够灵活，不能兼容现有设备，加之视频标准迟迟未定，投资比市场其他协议设备也要高出不少，因此很少被采用。
诱因 2011年，美国汽车工程师学会（SAE）以TTEthernet【下简称为TTE】为核心跨界推出了AS6802标准，为了和TTE有所区别，称之为Deterministic Ethernet或 Time-Triggered Ethernet。它是飞机航天领域内的以太网应用标准，也可在汽车上使用。它将时间触发传输的实时性、确定性、容错能力与传统以太网“尽最大努力”传输的灵活性、动态性等特点相结合，可支持不同类型的应用业务。
AS6802是一个非强制性标准，其支持者包括洛克希德马丁、庞巴迪、巴西航空工业、通用动力、西科斯基飞机、霍尼韦尔、BAE、Ultra电子、GE Fanuc和TTTech。
TSN发展 IEEE受到了在2011年AS6802标准的推出的刺激，之后于2012年将AVB任务组改名为TSN，其目标不仅在车载领域，还包括专业音视频领域、工业自动化领域、移动通信领域。TSN的主要支持者包括思科、英特尔、瑞萨、德国工业机器人巨头KUKA、三星哈曼、宝马、通用汽车、现代汽车、博世、博通、德州仪器、恩智浦、三菱电机、LG、Marvell、通用电气等。
TSN是一系列标准，非常庞大，也非常灵活，可以按需求选择，不过对技术的要求较高，不易抉择。它从四个方面（时间同步、延迟、可靠性、资源管理）考虑扩展传统以太网标准，以满足不同系统在时效性方面的需求。
后记 TSN已不再只是一个理想化项目，而是已成为被行业组织认证的广泛使用的标准。从2019年年初的汉诺威工博会可略见TSN对于工业领域的重要性。其主题为“融合的工业——工业智能”，作为“工业智能”的基石，智能化技术和网络化技术自然成为本届工业展的重中之重，涉及的内容包含工业人工智能、协作机器人、数字孪生、工业互联网平台、数字物流等范畴。
在这个通信领域大军浩浩已临5G元年城下的年度，工业4.0与5G + TSN的融合是近几年的重点。TSN时间敏感网络作为在工业领域融合信息技术（Information Technology,简称为IT）和运营技术（OperationTechnology，简称为OT）的重要桥梁，由其掀起的改造工业互联网IIoT底层架构的浪潮持续演进，相关进展尤为值得关注。
车载网络架构演变和TSN 随着汽车自动驾驶的发展，软件功能虚拟化和硬件简化的重要意义将进一步提升，而这可能以几种形式成为现实。一是将硬件整合到针对不同时延性和可靠性要求的堆栈中；二是一个冗余的“超级计算机”将取代ECU的地位；三是彻底放弃控制单元的概念，转而采用智能节点计算网络。
另一方面从安全的角度出发，在今后的2到3代汽车产品上，整车企业将会安装多个具备相似功能的传感器来确保车辆具备充足的安全冗余。长期看来，行业将开发更完善的传感器解决方案来减少传感器数量和成本。而且可能传感器会变得更加智能，传感器融合和3D定位等高级功能将在中心化运算平台上进行，预处理、筛选和快速反应则很可能直接在传感器内完成。对于对可靠性要求较高的安全类关键应用，将利用冗余来完成所有对安全行驶至关重要的工作，如数据传输和电力供应等。
从长远的发展来看车载网络架构将在不同阶段呈现出不同的模式来满足需求。
传统车载网络架构 这是过去及现在车载网络的主流架构，车内ECU透过内联网及中央网关连接来在不同子网间传输数据。其中中央网关的角色至关重要，但功能较单一，主要作为信息传送、数据转换的通道，很少做数据处理。
在研架构（Domain Architecture） 随着汽车在智能驾驶领域的发展，功能越来越复杂， OEM更倾向于将车辆按照不同的功能划分不同的域，整合域中部分功能相近ECU的功能在域控制器下来管理。例如：ADAS、车载娱乐、车身控制、动力传动等域。
未来架构（Zone Architecture） 未来迈向高度自动驾驶时代，车用计算机设计将朝向集中式、具备更强大功能等方向发展，或有人称之为AI超级计算机。超级计算机负责车辆所有管理和决策工作，即前述提及的域控制器的功能弱化，并强化车用主计算机的功能；另外所有数据不需要预先处理，直接汇集至超级计算机做大数据分析、判断和决策。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f389bc6da2bb48712c4c7e7b2ce3afe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a99e4537c187712e5ac3f420cdef171/" rel="bookmark">
			java结束当前循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Java中，当我们要结束一个循环时，通常会使用循环变量的实现类来结束，但在实际开发中，我们经常会遇到某个循环结束后需要进行其他的操作的情况。此时，就需要使用循环变量来结束当前循环。 1、创建一个新的类，并把它添加到主程序中 2、将当前的循环变量设置为 cursor （） 3、在主程序中创建一个对象作为新类的实例 4、用新类替换原有循环变量 5、执行新创建的对象并释放老的循环变量 6、使用 getCursor （）方法来获取当前循环变量所对应的引用。如果没有引用，就返回 null 7、删除循环变量所对应的引用，如果是空指针，就返回 null
1、创建一个新的类，并把它添加到主程序中
首先，我们需要创建一个新的类，这个类可以是一个子程序，也可以是一个方法，它应该有自己的变量和参数。在 Java中，创建一个新的类一般都是使用 Map来实现的，如图1所示。但有些时候我们也需要自己创建一个类，如图2所示。创建类的方法如下： 通过以上的代码我们可以看到，它会先创建一个名为“cursor （）”的变量，然后将其添加到主程序中。在主程序中创建一个名为“cursor （）”的对象，然后调用方法“getCursor （）”获取当前循环变量所对应的引用。我们可以看到它的返回值为0,说明这个对象已经被回收了。
2、将当前的循环变量设置为 cursor （）
我们可以通过下面的代码来完成这个操作： 在上面的代码中，我们使用了一个类，并将其添加到主程序中。在上面的代码中，我们首先使用 cursor （）函数来获取当前循环变量所对应的引用，如果没有引用，就返回 null；如果有引用，就把它赋给了新类实例；然后将新类的实例与老的循环变量进行比较。如果两者相等，就用 return语句来终止当前的循环；如果两者不相等，就在老的循环变量上赋值给新类实例；然后执行新类实例所对应的对象。这样，就完成了结束当前循环所需做的操作。
3、在主程序中创建一个对象作为新类的实例
当我们要结束当前循环时，可以使用循环变量的实现类来结束，但如果想要在主程序中创建一个新的对象，同样可以使用循环变量来结束。 当我们创建一个新的对象时，我们需要将这个对象赋值给当前的循环变量。我们可以使用 setValue （）方法来获取当前对象的引用，如果这个引用是指向当前对象的，则返回 null；否则返回 null。在这个例子中，我们使用一个新的类来结束当前循环，而不是直接使用 cursor （）方法结束当前循环。 在 Java中，当我们需要结束一个循环时，通常会使用 cursor （）方法来结束。
4、用新类替换原有循环变量
用新类替换原有循环变量，其实是把原循环变量的作用域扩大到了新类的作用域，新类的实例不会影响原循环变量的值，而老的循环变量会被回收。不过，这种情况也不是绝对的，有些情况下，原来的循环变量仍然可以用来结束当前循环。 比如我们需要结束一个从0到num1的循环，这个时候可以使用类似这样的语句： 这样虽然也能完成这个操作，但是没有利用循环变量的作用域扩大到新类的作用域，所以性能上会比原来要低。 因此，在实际开发中，我们可以根据需要来选择是使用循环变量结束当前循环还是使用新类结束当前循环。不过要注意一点的是，我们不能只选择其中一种方式结束当前循环，否则就会出现报错。
5、执行新创建的对象并释放老的循环变量
3、在主程序中创建一个对象，并用它替换原有循环变量，然后使用 getCursor （）方法来获取当前对象所对应的引用，如果没有引用，就返回 null； 7、当主程序结束时，只需要将 cursor （）方法从主程序区块中删除即可。 8、当要释放循环变量所对应的引用时，可以使用 getDraw （）方法来获取当前对象所对应的引用。
6、使用 getCursor （）方法来获取当前循环变量所对应的引用，如果没有引用，就返回 null
7、将新添加的对象与原始的循环变量进行比较，如果相等，就释放老的循环变量所对应的引用，如果不相等，就返回 null 8、释放循环变量所对应的引用，并将其放入栈中 9、执行当前对象 10、将对象赋值给一个新的对象，并把它从循环变量中删除。如果有循环变量没有被释放，就直接从栈中取出。注意：在运行时要保证新添加的对象也被释放了。 12、执行当前对象并将其赋值给一个新的对象 14、如果循环变量没有被释放，就使用 getClass （）方法来获取当前对象并将其赋值给一个新的对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a99e4537c187712e5ac3f420cdef171/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eb3a8be0c88ca856c0d78498c1dda77/" rel="bookmark">
			React Hooks 全面详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Hooks解决的问题 （1）class组件的不足
状态逻辑难复用： 在组件之间复用状态逻辑很难，例如同一个生命周期可能会掺杂多种不相关的业务逻辑或者同一种业务逻辑会分配到不同的生命周期了。虽然可以通过 render props （渲染属性）或者 HOC（高阶组件）方案来优化此种问题，但无论是渲染属性，还是高阶组件，都会在原先的组件外包裹一层父容器（一般都是 div 元素），导致层级冗余趋向复杂难以维护：
在生命周期函数中混杂不相干的逻辑： 在生命周期函数中混杂不相干的逻辑（如：在 componentDidMount 中注册事件以及其他的逻辑，在 componentWillUnmount 中卸载事件，这样分散不集中的写法，很容易写出 bug ）
类组件中到处都是对状态的访问和处理，导致组件难以拆分成更小的组件
this 指向问题： 父组件给子组件传递函数时，必须绑定 this
（2）hooks的优势
能优化类组件的三大问题能在无需修改组件结构的情况下复用状态逻辑（自定义 Hooks ）能将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）副作用的关注点分离：副作用指那些没有发生在数据向视图转换过程中的逻辑，如 ajax 请求、访问原生dom元素、本地持久化缓存、绑定/解绑事件、添加订阅、设置定时器、记录日志等。以往这些副作用都是写在类组件生命周期函数中的。而useEffect 在全部渲染完毕后才会执行，useLayoutEffect 会在浏览器 layout 之后，painting 之前执行。 2. Hooks使用前提 只能在函数内部的最外层调用 Hook，不要在循环、条件判断或者子函数中调用只能在 React 的函数组件或者自定义Hook中调用 Hook，不要在其他 JavaScript 函数中调用 3. useState import { useState } from 'react'; function Example() { const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; ); } useState 会返回一个数组：一个 state，一个用于更新 state 的函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8eb3a8be0c88ca856c0d78498c1dda77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07211a9a279d906224dcef2770daabf7/" rel="bookmark">
			Python毕业设计之django社区报修维修预约上门服务系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发语言：Python
框架：django
Python版本：python3.7.7
数据库：mysql 数据库工具：Navicat
开发软件：PyCharm 目 录
摘 要 I
Pick to II
1绪论 1
1.1项目研究的背景 1
1.2开发意义 1
1.3项目研究现状及内容 1
1.4论文结构 2
2开发技术介绍 3
2.2 DJANGO简介 3
2.3 MySQL环境配置 3
我们最初的项目结构由五个文件组成：
manage.py：使用django-admin命令行工具的快捷方式。它用于运行与我们项目相关的管理命令。我们将使用它来运行开发服务器，运行测试，创建迁移等等。
__init.py：这个空文件告诉python这个文件夹是一个python包。
settings.py：这个文件包含了所有的项目配置。将来我们会一直提到这个文件！
urls.py：这个文件负责映射我们项目中的路由和路径。例如，如果你想在访问URL / about/ 时显示某些内容，则必须先在这里做映射关系。
wsgi.py：该文件是用于部署的简单网关接口。你可以暂且先不用关心她的内容，就先让他在那里就好了。
django自带了一个简单的网络服务器。在开发过程中非常方便，所以我们无需安装任何其他软件即可在本地运行项目。我们可以通过执行命令来测试一下它：
python manage.py runserver
myproject/ &lt;-- 高级别的文件夹
|-- myproject/ &lt;-- Django项目文件夹
| |-- myproject/
| | |-- __init__.py
| | |-- settings.py
| | |-- urls.py
| | |-- wsgi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07211a9a279d906224dcef2770daabf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/410c6d18cddb8b35be81d69bc8334aff/" rel="bookmark">
			【深度学习基础】反向传播BP算法原理详解及实战演示（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要源码请点赞关注收藏后评论区留言私信~~~
神经网络的设计灵感来源于生物学上的神经网络。如图所示，每个节点就是一个神经元，神经元与神经元之间的连线表示信息传递的方向。Layer 1表示输入层，Layer 2、Layer 3表示隐藏层，Layer 4表示输出层。我们希望通过神经网络，对输入数据进行某种变换，从而获得期望的输出，换句话说，神经网络就是一种映射，将原数据映射成期望获得的数据。BP算法就是其中的一种映射，下面通过一个具体的例子来演示BP算法的过程
假设现在的网络层如图 所示，第一层有两个神经元x1、x2，一个截距项c1；第二层有两个神经元y1、y2，一个截距项c2；第三层是输出，有两个神经元h1、h2；每条线上表示神经元之间连接的权重（具体数值如图 1‑2所示），激活函数σ选用Sigmoid函数。Sigmoid函数及其对x的导数如下所示：
输入：x_1=0.05, x_2=0.1，目标：输出h1、h2尽可能接近[0.03, 0.05]
1：前向传播 输入层-&gt;隐藏层
隐藏层-&gt;输出层
至此，已经完成了前向传播的过程，此时输出为[0.694,0.718]，和期望的输出[0.03, 0.05]相差较大。接下来，通过反向传播，更新每条边上的权值，重新计算输出
2：反向传播 计算总误差：均方误差作为我们的总误差函数
target_outℎ_i表示第i个真实值；out_ℎ_i表示预测值；N取值为2
因为每个权值对误差都产生了影响，我们希望了解每个权值对误差产生了多少影响，可以用整体误差对特定的权值求偏导来实现这一目的。从输出层到隐藏层，共有5个参数需要更新，分别为b11，b12，b21，b22，c2。以b22为例，通过链式法则进行计算，如下式：
其中ρ表示学习率，本例设定为0.5。同理可得：b_11^new=0.458，b_12^new=0.560，b_21^new=0.658
对于偏置项，求解方法类似，但由于偏置项对于每个神经元的损失都有贡献，所以应为对每个神经元求偏导后再求和。由于最后一项在本例中求导后值为1，一般情况下都为1，故可简化
隐藏层-&gt;输入层 方法与“输出层—&gt;隐藏层”类似，但是有一点区别。如图 ，可以发现神经元h1向后就直接输出了，没有再输入下一个神经元，而神经元y1的输出值要输入到神经元h1、h2，导致神经元y1会接受来自h1、h2两个神经元传递的误差，因此h1、h2均要计算
从隐藏层到输入层，共有5个参数需要更新，分别为a11，a12，a21，a22，c1，以a11为例计算
式中几项偏微分均已在输出层—&gt;隐藏层的权值更新中有相应的计算公式
同理可得，a_12^new=0.199，a_21^new=0.298，a_22^new=0.398
偏置项的求法与输出层-&gt;隐含层方法一致，这里不再赘述，但应注意的是c1的更新与y1、y2、h1、h2均有关系，带入数值可得：c_1^new=0.307
至此，所有参数均已更新完毕
利用更新完毕之后的参数可以计算得到新的输出为[0.667, 0.693] （原来的输出为[0.694, 0.718]，目标输出为[0.03, 0.05]） 新的总误差为0.44356（原来的总误差为0.444）
通过新的权值计算，可以发现输出值与目标值逐渐接近，总误差逐渐减小，随着迭代次数的增加，输出值会与目标值高度相近
3:Numpy实现反向传播算法 1：导入数据集 数据集采用sklearn.make_moons()数据集（下图），并借助sklearn包进行数据预处理，数据集可视化如下
2：预处理 我们的模型基于梯度下降的优化方式算法，为了让这类算法能更好的优化神经网络，我们需要对数据集进行归一化，我们借用sklearn的库函数完成
重新搭建一个两层的神经网络，如图所示
其中X是一个p×q的矩阵。选取交叉熵损失函数作为该神经网络的损失函数。学习率为0.05，采用梯度下降法进行参数更新
对于权重矩阵W及偏置矩阵B，采用随机初始化的方法。W和B的纬度较高时，不易手工初始化。且若W和B初始化为0或者同一个值，会导致在梯度下降的更新过程中梯度保持相等，权值相同，导致不同的隐藏单元都以相同的函数或函数值作为输入，可以通过参数的随机初始化打破这种僵局。
同时要注意参数初始化应合理，否则会出现梯度消失或梯度爆炸
在实现sigmoid时，当x很大的时候，会存在上溢问题，我们可以使用scipy.expit()实现sigmoid
至此，我们完成了基本框架的搭建，现在我们编写训练模型 我们假定 学习率为0.05
3：训练和测试 测试集预测结果如下
定义预测函数，在测试集上通过以下代码预测，并将预测结果可视化，可以发现可以较为明显的将数据集分为两类
误差绘图如下 可见在迭代次数在300次左右时基本已经趋于稳定
最后 部分代码如下
# 导入模块 import numpy as np import matplotlib.pyplot as plt %matplotlib inline from matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/410c6d18cddb8b35be81d69bc8334aff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b9ca33eac76ae8c4d89863028e2dfe3/" rel="bookmark">
			在项目中使用阿里云oss实现文件上传功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
一、需求分析
二、设计思路
三、实现步骤
3.1 预处理：先在官网上，完成OOS的配置
3.1.1 购买OSS服务。
3.1.2 创建Bucket
3.1.3 Bucket参数的配置
3.2 Java程序中使用OSS：查询开发文档
3.2.1 在控制台页面，找到OSS的Java开发文档
3.2.2 在中央仓库找到OSS坐标
3.2.3 查询文档，了解基本操作
3.2.4 参数的获取（AK参数的获取）
​编辑
3.2.5 制作自己的操作OSS的工具类
3.2.6 编写上传文件接口
四、总结
一、需求分析 在博客项目的前台中，需要完成对个人资料的更新，这其中包含对用户头像的更新，其实也就是替换掉原来的头像，另外在后台中需要在写博文中对缩略图以及文章正文中图片的添加，以及能对博文的缩略图以及正文中的图片进行修改。
二、设计思路 先来谈一下原来的处理方式，进而引出为什么现在需要这种处理方式。
因为之前做过锋迷商城这个项目，所以还是有在数据库中存图片地址的这种意识，只不过那个项目比较拉，图片都在前端项目里，当然咯，那个项目只是涉及到前台，也就是说仅仅是图片的显示，直接从数据库中查询到图片地址，然后到前端项目中去找到对应的图片即可，没有涉及到后台，也就是没有涉及到对图片的上传，另外它这个项目前台中，也没有修改图片之类的，仅仅只是单纯的对图片进行显示，看似也没有多大问题，图片存死也没啥问题，但是一旦需要扩充就比较麻烦了，需要手动的往前端项目中添加图片。另外如果我此时需要上传图片呢，如果是在前端工程中将图片写死，那么我就只能上传前端项目中的图片，因为只有这样地址才是有效的，因为你如果上传的是其它地方的图片，图片地址在前端项目中里面找不到，即使可能可以通过你选择本地图片，然后将图片保存到前端项目中，然后再返回图片地址。
其实这里总结来说在锋迷商城项目中是将图片存到前端工程里。
存到前端工程里面，当然有其优点，比如说：
1. 图片的加载速度更快，因为是直接从本地获取，而不需要访问网络。
2. 安全性高，因为图片存储到本地，没有外界能直接访问图片的接口。
3. 可靠性高，因为存储到本地，不会受到网络，以及服务器故障的影响。
总的来说优点有三点：加载快、安全、稳定。
但其缺点也很明显，就比如：
1. 存储空间受限，因为是存储到本地，所以可能会受到存储空间的限制。
2. 难以扩展，因为受到存储空间的限制，因此当面对大量的图片时，可能需要修改存储位置以及修改代码。
3. 可维护性差，因为存储到前端工程中，本质上是存储到本地磁盘中，所以就不能保证唯一的文件地址可以生效了，就比如说我的前端工程，到其它电脑上面，路径可能就会失效，就比如说在我的电脑上面地址是，c/前端项目/images自然来说项目中代码也是这个，虽然可能会在代码中写相对路径，代码中地址是/images，可是另外那台电脑连c/前端工程这个目录都没有的话，就找不到对应的文件了，因此如果存在多个开发者，就需要多交流沟通，遵循路径规范，增加维护难度。
那么如果将文件存到云端，就能解决这些问题了。
1、因为存储到云端，因为云端一般来说有着巨大的存储空间，因此一般来说不会因为存储空间的问题而发愁。
2、存储到云端后，云端会响应回来一个唯一的URL地址，无论在哪台电脑上面都能正确访问。
当然也是有缺点的，存到本地的优点的反面就是存到云端的缺点，就比如说：
1. 因为需要访问网络，可能文件的加载速度就相较于本地会慢一些。
2. 风险高了，因为存到了云端，因此存在着访问接口，因此安全性也就低一些，需要在云端，做好安全措施。
3. 因为和云服务器挂钩，因此可能会受到云服务器的影响，比如说云服务器发生故障，或者网络不好等问题。
对比了它两，但是总的来说保存到本地的缺点明显，保存的云端的优势明显，即使存在问题，也可以通过一些措施进行预防和解决。
好了，正是比较了它两，得知了存储到云端的优点，我才会选择将图片保存到云端，保存到云端也很多厂商都可以做到，七牛云、阿里云、腾讯云都可以，其实这个技术就叫做OSS(对象存储服务)，我还是比较喜欢使用阿里云的，下面我就来基于阿里云的OSS，如何实现文件的上传功能，当然这里不仅可以是文件的上传，也可以是文件的下载，以及文件夹的创建等许多需求，具体实现步骤可以参考阿里云的文档。
三、实现步骤 3.1 预处理：先在官网上，完成OOS的配置 3.1.1 购买OSS服务。 使用阿里云OSS之前，肯定得先到阿里云官网，购买OSS服务，这是使用任何服务的第一步。进入到阿里云OSS页面的步骤如下图所示：
然后选择立即购买：
然后就是规格的选择，第一次用的小伙伴就可以完全按照我下面的配置进行选择，这种配置完全够简单开发了，如果以后还有另外的需求，查阅阿里云的文档，进行配置即可，其实也就是默认配置，看得出其实OSS服务还是挺便宜的，半年才几块钱。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b9ca33eac76ae8c4d89863028e2dfe3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cd2ba30a48a7522316527fb0660b2c6/" rel="bookmark">
			设计模式 : 构造型 —— 单例模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单例模式 Creational Patterns/Singleton.md · belien/DesignPattern-23 (gitee.com)
Singleton Pattern，属于创建型设计模式，这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建，这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。
注意 单例类只有一个实例；
单例类必须创建自己的唯一实例；
单例类必须给其他所有对象提供这一实例。
基本思想 类的构造函数设为私有，然后定义一个静态的方法获取类的实例，这个静态方法中使用静态变量
定义类，所以不管调用这个方法多少次，类只实例化一次！
内容 意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点；
主要解决：一个全局使用的类频繁地创建与销毁；
优点：
在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例；
避免对资源的多重占用（比如写文件操作）。
缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化；
注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。
实现 /* * 单件模式 */ using namespace std; class Singleton { public: static Singleton &amp; getInstance() { static Singleton dp; return dp; } void message() { cout &lt;&lt; "Singleton Message" &lt;&lt; endl; } private: Singleton() { cout &lt;&lt; "construct Singleton!" &lt;&lt; endl; } }; int main(int argc, char* *argv) { Singleton::getInstance().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cd2ba30a48a7522316527fb0660b2c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/301d79b966d9a0c3ea673f99a5d18c7a/" rel="bookmark">
			机器学习之如何绘制热力图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		热力图是一种可视化工具，用于显示数据集中各个项目之间的相对频繁程度或热度。它可以帮助用户更好地理解数据集中的主要趋势和模式。热力图通常以不同的颜色或强度表示不同的数据项，并且可以在不同的维度上进行比较。
在热力图中，每个数据点或者数据项都有一个对应的频率或者热度值。可以使用不同的颜色或强度来区分不同的数据项，并通过热力图的形式来显示数据集中各个项目之间的相对频繁程度或热度。热力图经常用于数据可视化和探索性数据分析中，以帮助人们更好地理解数据并发现其中的规律和趋势。
以鸢尾花数据集为例 先对数据集进行预处理，然后训练逻辑回归模型，最后打印一下预测值。
import pandas as pd from sklearn.datasets import load_iris dataset=load_iris() features = pd.DataFrame(dataset.data,columns=['sepal length (cm)','sepal width (cm)','petal length (cm)','petal width (cm)']) targets = pd.DataFrame(dataset.target,columns=['target']) #导入数据拆分方法 from sklearn.model_selection import train_test_split feature_train,feature_test,target_train,target_test = \ train_test_split(features,targets,test_size=0.2,random_state=999)#拆分数据集，选20%数据作为测试用，随机系数999 #先打乱，在拆分，覆盖更多情况 from sklearn.linear_model import LogisticRegression #导入逻辑回归模型 model = LogisticRegression() #fit(x,y) x:特征 y：标签 model.fit(feature_train,target_train['target']) target_predicted = model.predict(feature_test) print(target_predicted) #预测结果 print(target_test['target']) #实际结果 绘制热力图 from sklearn.metrics import accuracy_score from sklearn.metrics import confusion_matrix import matplotlib.pyplot as plt import seaborn as sns #计算准确率 accuracy = accuracy_score(target_test, target_predicted) print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/301d79b966d9a0c3ea673f99a5d18c7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdb8c39e1fe702f63ded30f296d07270/" rel="bookmark">
			树莓派4B更新内核后，wlan0消失的问题解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		即ifconfig和ifconfig -a都无法查看到wlan0，解决方法如下：
在终端依次输入一下内容来手动加载相关驱动：
sudo insmod /lib/modules/6.1.23-v7l+/kernel/net/rfkill/rfkill.ko.xz sudo insmod /usr/lib/modules/6.1.23-v7l+/kernel/drivers/net/wireless/broadcom/brcm80211/brcmutil/brcmutil.ko.xz sudo insmod /lib/modules/6.1.23-v7l+/kernel/net/wireless/cfg80211.ko.xz sudo insmod /usr/lib/modules/6.1.23-v7l+/kernel/drivers/net/wireless/broadcom/brcm80211/brcmfmac/brcmfmac.ko.xz 说明：其中的 6.1.23-v7l+ 为当前树莓派的内核版本，可以在终端输入： uname -a 查看 相关驱动加载之后就可以查看到wlan0，并且可以正常连接wifi了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c5116809f23bfba1405bd5928da604d/" rel="bookmark">
			Latex中如何不显示参考文献的数字编号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方案：
重新定义标签格式以消除数字标签，在导入的包中加入以下代码：
\makeatletter \renewcommand{\@biblabel}[1]{} \makeatother 运行后：
诸如 [1]XXX,XXX,20XX,PP1-123.
将变为 XXX,XXX,20XX,PP1-123.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/507d65f69251f8857385d1bb48b17a7b/" rel="bookmark">
			PyTorch基础之模型保存与重载模块、可视化模块讲解（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 训练模型时，在众多训练好的模型中会有几个较好的模型，我们希望储存这些模型对应的参数值，避免后续难以训练出更好的结果，同时也方便我们复现这些模型，用于之后的研究。PyTorch提供了模型的保存与重载模块，包括torch.save()和torch.load()，以及pytorchtools中的EarlyStopping，这个模块就是用来解决上述的模型保存与重载问题
一、保存与重载模块 若希望保存/加载模型model的参数，而不保存/加载模型的结构，可以通过如下代码
其中state_dict是torch中的一个字典对象，将每一层与该层的对应参数张量建立映射关系
若希望同时保存/加载模型model的参数以及模型结构，而不保存/加载模型的结构，可以通过如下代码
为了获取性能良好的神经网络，训练网络的过程中需要进行许多对于模型各部分的设置，也就是超参数的调整。超参数之一就是训练周期（epoch），训练周期如果取值过小可能会导致欠拟合，取值过大可能会导致过拟合。为了避免训练周期设置不合适影响模型效果，EarlyStopping应运而生。EarlyStopping解决epoch需要手动设定的问题，也可以认为是一种避免网络发生过拟合的正则化方法 EarlyStopping的原理可以大致分为三个部分：
将原数据分为训练集和验证集；
只在训练集上进行训练，并每隔一个周期计算模型在验证集上的误差，如果随着周期的增加，在验证集上的测试误差也在增加，则停止训练；
将停止之后的权重作为网络的最终参数
初始化 early_stopping 对象：
EarlyStopping 对象的初始化包括三个参数，其含义如下：
patience(int) : 上次验证集损失值改善后等待几个epoch，默认值：7。
verbose(bool)：如果值为True，为每个验证集损失值打印一条信息；若为False，则不打印，默认值：False。
delta(float)：损失函数值改善的最小变化，当损失函数值的改善大于该值时，将会保存模型，默认值：0，即损失函数只要有改善即保存模型 定义一个函数，表示训练函数，希望通过 EarlyStopping 当测试集上的损失值有所下降时，将此时的信息打印出来，并且保存参数。 先创建将要用到的变量，以及初始化 earlystopping 对象
之后训练模型并保存损失值，计算每次迭代在训练集和测试集上的损失值得均值，并保存
调用 EarlyStopping 中的_call_()模块，判断损失值是否下降，若下降则进行保存，并打印信息
最后调用torch.load()加载最后一次的保存点，即最优模型，并返回模型，以及每轮迭代在训练集、测试集上的损失值的均值
二、可视化模块 在模型训练过程中，有时不仅需要保持和加载已经训练好的模型，也需要将训练过程中的训练集损失函数、验证集损失函数、模型计算图（即模型框架图、模型数据流图）等保持下来，供后续分析作图使用
例如，通过损失函数变化情况，可以观察模型是否收敛，通过模型计算图，可以观察数据流动情况等
Tensorboard可以将数据、模型计算图等进行可视化，会自动获取最新的数据信息，将其存入日志文件中，并且会在日志文件中更新信息，运行数据或模型最新的状态。Tensorboard中常用的模块包括如下七类
add_graph()：添加网络结构图，将计算图可视化。
add_image()/add_images()：添加单个图像数据/批量添加图像数据。
add_figure()：添加matplotlib图片。
add_scalar()/add_scalars()：添加一个标量/批量添加标量,在机器学习中可用于绘制损失函数。
add_histogram()：添加统计分布直方图。
add_pr_curve()：添加P-R（精准率-召回率）曲线。 add_txt()：添加文字
Tensorboard的整体用法，参见下图 TensorBoard中可以使用add_graph()函数保存模型计算图，该函数用于在tensorboard中创建存放网络结构的Graphs，函数及其参数如下：
model（torch.nn.Module) 表示需要可视化的网络模型；
input_to_model（torch.Tensor or list of torch.Tensor）表示模型的输入变量，如果模型输入为多个变量，则用list或元组按顺序传入多个变量即可；
verbose（bool）为开关语句，控制是否在控制台中打印输出网络的图形结构 例如，有一个数据类型为torch.nn.Module的变量model，输入的张量为input1和input2，期望返回模型计算图，则可以输入如下代码，即可在SummaryWriter的日志文件夹中保存数据流图
PyTorch中SummaryWriter的输出文件夹一般为runs文件，保存的日志文件不可以直接双击打开，需要在cmd命令窗口中将目录导航到runs文件夹的上一级目录，并输入tensorboard –logdir runs即可打开日志文件，打开后复制链接到浏览器中，即可打开保存的模型计算图或数据变量等 TensorBoard中可以使用add_scalar()/add_scalars()函数保存一个或在一张图中保存多个常量，如训练损失函数值、测试损失函数值、或将训练损失函数值和测试损失函数值保存在一张图中。
add_scalar()函数及参数如下：
tag（string）为数据标识符；
scalar_value（float or string）为标量值，即希望保存的数值；
global_step（int）为全局步长值，可理解为x轴坐标 add_scalars()函数及参数如下：
main_tag（string）为主标识符，即tag的父级名称；
tag_scalar_dict（dict）为保存tag及tag对应的值的字典类型数据；
global_step（int）为全局步长值，可理解为x轴坐标。 add_scalars()可以批量添加标量，例如，绘制y=xsinx、y=xcosx、y=tanx的图像，可以输入如下代码，保存的日志文件打开方式与上文所述相同
创作不易 觉得有帮助请点赞关注收藏~~~ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e63e1c1bcbedb5fec7017959047715ee/" rel="bookmark">
			大二一个学期学这么点内容，没有概念，只有实操
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何查看所有的数据库：
Show databases;
如何进入某个数据库：
use xxx;
如何新进数据库：
Create database jx;
如何删除数据库：
Drop database jx;
如何查看所有的表格：
Show tables;
如何创建数据表：
create table teacher(id int,name
varchar(10),address varchar(100),score float,time date);
如何修改表（添加列）：
alter table teacher add phone varchar(11);
如何修改表（删除列）：
alter table teacher drop score;
如何修改表（修改列）：
alter table teacher modify phone int;
如何删除表：
drop table student;
表的约束管理：
非空约束 not null
唯一约束 unique
主键约束 primary key
默认约束 default
示例：
create table student
(id int primary key, name varchar(10) not null, phone varchar(11) default "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e63e1c1bcbedb5fec7017959047715ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7df447ab9c3e4a1bef977ace54751fe1/" rel="bookmark">
			vue3&#43;elementPlus&#43;sortablejs实现表格行列拖拽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为是在弹层里改变表格所有我就准备了很多个数组 首先我就准备了五个数组
const col = ref([ { label: '日期', prop: 'date' }, { label: '姓名', prop: 'name' }, { label: '地址', prop: 'address' }, { label: '隐藏', prop: 'done' } ]) const dropCol = ref([ { label: '日期', prop: 'date' }, { label: '姓名', prop: 'name' }, { label: '地址', prop: 'address' }, { label: '隐藏', prop: 'done' } ]) const changeCol = ref([ { label: '日期', prop: 'date' }, { label: '姓名', prop: 'name' }, { label: '地址', prop: 'address' } ]) const tableData = ref([ { id: '1', date: '2023-04-28', name: 'aaa', address: '长沙市雨花区', done: false }, { id: '2', date: '2023-04-29', name: 'bbb', address: '长沙市岳麓区', done: false }, { id: '3', date: '2023-04-30', name: 'ccc', address: '长沙市天心区', done: false }, { id: '4', date: '2023-05-01', name: 'ddd', address: '长沙市芙蓉区', done: false } ]) let tableDataChange = ref([.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7df447ab9c3e4a1bef977ace54751fe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/290039202c3700b42e951f7b1f725c41/" rel="bookmark">
			第五届“传智杯”全国大学生计算机大赛决赛（A-E）题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A-时效「月岩笠的诅咒」 题目描述 时间节点上发生过的两件事情的时间可被看作两实数 a,b。我们称两个事件满足「周年」关系，当且仅当可以通过执行以下两种操作（可以 0 次）使其相等：
将 a 加上 1，即 a←a+1；将 b 加上 1，即 b←b+1。 现在给定实数 a,b，询问它们是否满足「周年」。
输入格式 输入共一行两个实数 a,b。输入保留到小数点后 12 位。
输出格式 输出共一行。如果存在合法方案，输出YES，否则输出NO。
题目大意： 判断两个数的差是否为整数即可
题解： 一开始想直接用如下方法直接判断两数小数部分是否相等的
a=a-(double)(int)a //a开始为double类型
可惜WA了，原因大概是精度问题，那么我们直接用字符串来做就好了
#include &lt;bits/stdc++.h&gt; using namespace std; bool check(string &amp;a, string &amp;b, int idx, int idx2) { //两个数没有小数部分，一定成立 if(idx==-1 &amp;&amp; idx2==-1) return true; //一个数有小数点，一个数没有，观察有小数点的数后面是否全为0 else if (idx == -1 &amp;&amp; idx2 != -1) { for (int i = 0; i &lt; b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/290039202c3700b42e951f7b1f725c41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d700523a0134ba8ed72048d85b3a6fc6/" rel="bookmark">
			[FPGA开发工具使用总结]VIVADO在线调试(1)-信号抓取工具的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1简介2 添加观测信号的几种方法2.1 通过定制IP核添加2.2 通过约束文件添加2.3 通过GUI生成DEBUG约束文件2.4 两种方法的优点与缺点 3在线调试方法3.1 器件扫描设置3.2 触发条件设置3.3 触发窗口设置3.4 采样过程控制 4常见问题4.1 时钟域的选择4.2 缺少LTX文件4.3 ILA无时钟 参考文档 1简介 在FPGA开发过程中，实时抓取信号进行观测是一种必不可少的问题分析手段。通常厂家会提供一种通过JTAG互联，逻辑资源定制的实时记录信号的调试手段。
通过阅读本文您可以了解到针对VIVADO开发工具的在线分析工具的使用方法。例如，如何添加被测信号，如何准确的观测到被测信号的典型现象，以及通常会遇到的问题等。
2 添加观测信号的几种方法 2.1 通过定制IP核添加 VIVADO提供了一个用于实时抓取信号的IP核，名为ILA（内部逻辑分析仪），用户使用时可在IP Catalog中直接搜索ila进行定制。
ILA core的定制非常简单，通常仅需如下配置即可满足需求。
在使用ILA Core时需要注意，输入被测信号的位宽可以小于等于ILA Core端口的位宽，但是不能使ILA Core端口为空，否则布局布线会失败。
在遇到难以解决的问题时，一个工程中会添加很多的ILA core，此时如果单独定制每一个Core会增加许多繁冗的工作，可先定制一个输入端口与位宽足够的Core，然后按需例化。
如下图是在某个工程中被调用的ILA Core,在调试时打开宏将ILA例化到工程中进行调试，完成调试后通过关闭宏屏蔽掉ILA，该方法可以避免在完成调试后删除ILA过程中的修改引入不必要的BUG。
2.2 通过约束文件添加 通过编写XDC约束文件，亦可实现ILA添加，添加ILA Core的XDC示例文件如下所示。
使用此种方式需要对约束脚本非常熟悉。若不熟悉约束脚本的编写也可通过GUI界面生成约束文件；2.3节将介绍如何生成DEBUG的约束文件。
2.3 通过GUI生成DEBUG约束文件 使用GUI生成约束文件需要先完成工程综合，然后在FlowNavigator窗口中打开Synthesized –&gt;Open Synthesized Design –&gt; Set Up Debug，等待加载设计。
被测信号筛选及添加，综合后原来的信号名基本都会发生变化，可以在信号名的后面带上*以便准确的匹配到。
若想被测信号名称在综合时不被优化掉，可以在综合之前在代码中设置约束。添加mark_debug约束后，被测信号可以很方便的被筛选出来。
添加完信号后设置采样深度等。
完成后可以在底部的Debug窗口看到添加的被观测信号，到这一步还没结束，还需要保存刚才生成的约束才可以重新编译。
直接在Synthesized Design界面中按ctrl+s即可保存刚才生成的约束，弹出下图界面及保存成功。系统会默认保存到target的xdc文件中。推荐用一个专门的XDC文件来保存DEBUG相关约束。
2.4 两种方法的优点与缺点 VIVADO提供了通过IP Core核约束的两种方式添加在线分析逻辑的方法，两种方法优缺点如下所示。
优点缺点通过IP Core添加IP Core自带网表，节省编译时间；在代码中直接例化，能够快速搭建测试平台。对跨模块的信号不太友好，代码改动较大。通过约束添加方便跨模块信号观测；不在功能代码中做修改，方便完成调试后的代码整理。编译较慢。 3在线调试方法 3.1 器件扫描设置 VIVADO器件扫描在Flow Navigator 窗口中Open Hardware Manager -&gt; Open Target –&gt;Auto Connect打开。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d700523a0134ba8ed72048d85b3a6fc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c074f0137f44050d59dbed17bc20e0d0/" rel="bookmark">
			Nginx安装配置详解（万字长文典藏版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx安装配置详解 Nginx简介 Nginx（“engine x”）是一款高性能的Web服务器和反向代理服务器，它采用事件驱动的异步结构，具有内存占用少、稳定性高、能够处理大量的并发请求，具有高效和低资源消耗等特点。 Nginx常常被用作Web服务器、负载均衡器、反向代理和缓存服务器等。
Nginx安装 在Ubuntu中，安装Nginx步骤如下：
更新软件源 可以通过运行以下命令更新软件源：
sudo apt-get update
# 在CentOS中
# sudo yum install epel-release
安装Nginx 安装Nginx服务器可以通过以下命令：
sudo apt-get install nginx
# 在CentOS中
# sudo yum install nginx
检查Nginx是否正确安装 运行以下命令可以检查Nginx是否正确安装：
# 查看nginx版本号
nginx -v
# 查看nginx版本号以及其他配置参数，包含安装、配置文件路径以及内置模块等信息
nginx -V
如果能够输出Nginx的版本号，则表示Nginx已经正确安装。
默认情况下，Nginx的安装路径为/usr/share/nginx，Nginx的配置文件路径为/etc/nginx/nginx.conf。
nginx帮助手册命令以及常用命令 # 查看nginx帮助文档
nginx -h
# 在Linux系统中，可以使用man命令查看nginx详细帮助文档
man nginx
# 检测nginx配置文件语法是否正确
nginx -t
# 检测nginx配置文件语法是否正确，并把nginx配置文件信息输出到屏幕
nginx -T
# 设置nginx使用的配置文件（默认使用：/usr/local/etc/nginx/nginx.conf）
nginx -c nginx_file.conf
# 向nginx主进程发送信号，stop, quit, reopen, reload
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c074f0137f44050d59dbed17bc20e0d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20dfef6e5a5825df5d52c90f246542bf/" rel="bookmark">
			kill -9 多个进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 kill-9 多个grep的进程
kill -9 `ps aux|grep xxx|grep -v grep |awk '{print $2}'` 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cf1195739340c653059aa07297a292e/" rel="bookmark">
			top -p 监视多个搜索进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 开发中希望用top只监视grep查询到的几个进程，又不想每次输入top -p xxx1 -p xxx2
top -c `ps aux|grep xxxs|grep -v grep|awk '{ print "-p" $2}'|tr '\n' ' '` 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37701a67e21a3e2b6380c4e4798f77e5/" rel="bookmark">
			Python第三方库——numpy【详细】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		numpy是一个第三方库，支持大量高纬度数组与矩阵运算。此外，它也针对数组运算提供大量的数字函数。机器学习涉及到大量对数组的变化和运算，numpy就成为必不可少的工具之一。
使用numpy，可以做以下操作：
1. 数组的算数和逻辑运算
2. 傅立叶变换和用于图形操作的例程【所谓例程，就是某个系统对外提供的功能接口或服务的集合】
3. 与线性代数有关的操作，numpy用于线性代数和随机数生成的内置函数
numpy的主要对象是多维数组 Ndarray，在numpy中维度Dimensions叫做轴Axes，轴的个数叫做秩Rank
需要注意的是：numpy.array和Python标准库中array.array并不相同，前者更为强大
主要的操作有：
一、数组创建
1.查看numpy的版本
import numpy as np version = np.__version__ print(version) 运行结果为：
2.通过列表创建一维数组
import numpy as np list_ = [1, 2, 3, 4, 5] arr = np.array(list_) print(arr) 运行结果为：
3.通过列表创建二维数组
import numpy as np tuple1 = (1, 2, 3) tuple2 = (4, 5, 6) # 无论是使用列表还是元组，都能进行创建 list_ = (tuple1, tuple2) arr = np.array(list_) print(arr) list_ = [list(tuple1), list(tuple2)] arr = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37701a67e21a3e2b6380c4e4798f77e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56d1ce239230bf6a77b337591dcca526/" rel="bookmark">
			文件分割指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		split -b 50M *.log -d -a 3
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/748f78a72c8b4abaf2edf6b3dbf8a86c/" rel="bookmark">
			使用Monkey进行Android手机应用的压力测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Monkey命令】：
*** 列出已连接的设备：adb devices ***找到手机中正在运行的安装包名: adb shell dumpsys window | findstr mCurrentFocus ***对指定安装包进行100次并发: adb shell monkey -p 包名 100 ***对指定安装包进行100次并发并打印日志: adb shell monkey -p 包名 100 &gt;路径 ***执行100个伪随机用户事件流，事件间隔为300毫秒: adb shell monkey -p 包名 --throttle 300 100
monkey测试的优点
简单易用，方便快捷，并且理论上可以测试到所有bug,因为理论上只要次数最够多，所有事件都会发生。
monkey测试的缺点
遍历界面有限。 在monkey测试中，由于事件的随机性，使得monkey容易卡在某些简单页面，比如登陆页面这种可操作内容很少的页面。导致测试效果不佳。测试有效性大打折扣。
无法得知Bug的复现步骤。由于Monkey的随机性，如果Bug是由于事件发生的特定序列产生的，往往很难复现Bug。
路径回环。由于monkey太过随机，最后根本无法控制，很容易陷于一个页面无法出来，或者陷入某个无关紧要的地方无法出来，导致测试结果并不具有很好的意义。这也是导致遍历界面有限的原因。
解决方案
1 二次开发
对monkey进行二次开发，例如maxin，可以通过一些黑白名单控制，或者输入指定事件流，或者指定不同的测试随机模式，深度优先或者控件识别等，同时加入一些熔断机制，在一个地方执行了太多次后可以自动触发熔断并拉起。但是这样还是会进入死循环，因为仍然不能解决路径回环的问题。
2 指定测试页面
我们可以指定测试哪些页面，但是发现如果指定某几个Activity，虽然不会陷入路径回环，但随机的意义又不是那么大了，如果在几个页面进行随机，并且页面深度不是很深，那一直在这些页面测试也没有多大意义
3.分析APP特性，选择合适的方案
可以看出，测试的随机性和上述问题的解决是很难兼得的，我们必须根据我们应用的特性选择合适的方案。
对于页面功能不多，控件简单的应用，我们可以采用自定义脚本进行测试，因为在这种情况下测试所有功能也是可能的。
对于页面结构比较规律的应用，比如直播软件，每个页面结构相对固定（直播间都长一样），或者电商app(每种商品的页面大致相同)。由于随机性，所以点击不会一直在同一个地方进行点击，所以不容易一直卡在同一个页面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/061365e53d0f02bbc65a481d4384ec55/" rel="bookmark">
			BUUCTF MISC 21 - 40
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主1：https://davidcheyenneone.github.io/Misc/BUUCTF/BUUCTF Misc 2（21-40）.html
博主2：https://blog.csdn.net/m0_52885531/article/details/117406720
博主3：https://blog.csdn.net/xuanyulevel6/article/details/126072948
21、隐藏的钥匙 用十六进制编辑器打开图片，因为图片格式为jpg，因此搜索FF D9（文件尾标识）在之后发现一串加过密的flag，base64解密即可
22、另一个世界 用十六进制编辑器打开图片，在文件尾发现一串二进制，用二进制转字符即可得到
23、FLAG 首先用十六进制器查看，没有什么发现foremost也未提取出东西，于是用zsteg查看，如图所示，确定为LSB隐写，用stegsolve查看图片
不知道为什么看不见十六进制，只能在保存的先不写文件格式。保存后用十六进制编辑器查看此文件（50 4B 03 04）是zip文件，增加文件后缀，解压得到一个未知格式的文件。
用十六进制器查看此文件。.ELF文件：文件格式，用于存储Linux程序。
由提示搜索hctf文本即可得到flag
24、假如给我三天光明 下载后得到一个加密音频和一张照片。图片下方有这样的图案，搜索后发现是Braille盲文
Braille盲文 https://www.cnblogs.com/gwind/p/8009861.html
布莱尔创造的由6个点为基础结构的盲字，在纸面上有的凸起，有的不凸起，形成64种变化，即64种符形，在每个符号（单位称“方”）左右两列，每列各三个点，从左边自上而下叫做1、2、3点，从右边自上而下叫做4、5、6点。
1. 数字盲文 解读：每个数字的盲文前面都有个“3456”点符形，是数号，表示后面的读作阿拉伯数字。
2. 英语字母盲文（英语一级盲文） 解读：英语盲文a－j都只是用了1245点位即上半截，和数字的一样；k－t是a－j下面加上了3号点位。
3. 汉语拼音盲文 汉语拼音盲文声母表（18个）
注意：声母g/k/h在韵母i/u/ü时变读为j/q/x。z/c/s/zh/ch/sh/r后面的i省略
汉语拼音盲文韵母表（34个）
明显是英语字母盲文，从左到右分别代表：kmdonowg
解压出音频，是摩斯电码，用Audacity提取
较长的蓝色即为“-”，较短的即为“.”，每一段由-和.组成的即为一个字符。用“/”间隔。
-.-./-/…-./.–/.–././…/-----/—…/–…/…–/…—/…–…/…—/…–/-…/–…/
摩斯电码 25、神秘龙卷风 打开题目提示压缩包密码为4位纯数字密码，破解后得到一个记事本。
发现是Brainfuck加密，https://www.splitbrain.org/services/ook可用此网站解密即可。
brainfuck语言常用**&gt; &lt; + - . , [ ] **八种符号来替换C语言的各种语法和命令：
eg： +.&gt;++
26、数据包中的线索 题目提示（在线交流的数据包）用wireshark打开文件，过滤出http数据包追踪TCP流
猜测可能是base64编码
base解码，使用在线网站解码发现是个图片下载即可
27、后门查杀 下载下来有很多文件，提示webshell上传，那用杀毒软件扫描就可以找到webshell
pass一般用MD5加密，应该就是它了
28、webshell后门 同上题
29、荷兰带宽数据泄露 提示是一个带宽数据文件，用RouterPassView打开文件，搜索password之类是关键词尝试提交flag即可
30、来首歌吧 看到音频文件先用Audacity查看，发现上面的音轨是莫斯密码
:::info
… -… -.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/061365e53d0f02bbc65a481d4384ec55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f234e4c63b13b49174d7d009a9f7acee/" rel="bookmark">
			BUUCTF MISC 81 - 100
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		81、吹着贝斯扫二维码 https://blog.csdn.net/m0_46631007/article/details/119965593
下载题目后得到很多未知格式的文件以及一个加密的压缩包
先用winhex随便查看一个文件，发现是JPG文件
使用cmd的ren命令批量重命名ren * *.jpg，发现是二维码碎片，但是不知道拼接的顺序
再用十六进制器查看图片，看看是否有其他提示。一般先直接到最后查看文件尾后是否藏有信息，发现每张的文件尾果然隐藏有信息，每张图片的数字都不一样，猜测可能是图片顺序。
于是尝试用python提取出文件尾的最后两个字节并对文件重命名，附上大佬代码
import os from PIL import Image # 目录路径 dir_name = r"./" # 获取目录下文件名列表 dir_list = os.listdir('./') # 从列表中依次读取文件 for file in dir_list: if '.jpg' in file: f = open(file, 'rb') n1 = str(f.read()) n2 = n1[-3:] # 经过测试发现这里要读取最后3个字节，因为最后还有一个多余的字节，不知道是不是转字符串的原因导致在末尾多了一个字符 f.close() # 先关闭文件才能重命名，否则会报`文件被占用`错误 os.rename(file, n2 + '.jpg') # 重命名文件 获得图片顺序后用PS进行拼接（懒得拼了，抄抄大佬的作业，感谢！）
扫描得BASE Family Bucket ??? 85-&gt;64-&gt;85-&gt;13-&gt;16-&gt;32，提示是base编码，后面的数字应该是编码base85-&gt;base64-&gt;base85-&gt;rot13-&gt;base16-&gt;base32
首先是压缩包给出的base32编码GNATOMJVIQZUKNJXGRCTGNRTGI3EMNZTGNBTKRJWGI2UIMRRGNBDEQZWGI3DKMSFGNCDMRJTII3TMNBQGM4TERRTGEZTOMRXGQYDGOBWGI2DCNBY
解码得到3A715D3E574E36326F733C5E625D213B2C62652E3D6E3B7640392F3137274038624148
再进行base16解码：:q]&gt;WN62os&lt;^b]!;,be.=n;v@9/17'@8bAH
再进行rot13解码：:d]&gt;JA62bf&lt;^o]!;,or.=a;i@9/17'@8oNU
再进行base85解码：PCtvdWU4VFJnQUByYy4mK1lraTA=
再进行base64解码：&lt;+oue8TRgA@rc.&amp;+Yki0
最后进行base85解码：ThisIsSecret!233尝试用此字符串解压压缩包，得到flag
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f234e4c63b13b49174d7d009a9f7acee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2669b5047e6ff7a593d941fbd452756/" rel="bookmark">
			Windows 11 本地 php 开发环境搭建：PHP &#43; Apache &#43; MySQL &#43;VSCode 安装和环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言1. PHP 的下载、安装和配置1.1 下载 php1.2 安装 php1.3 配置 php 系统变量1.4 配置 php.ini 2. Apache 的下载、安装和配置2.1 下载 Apache2.2 安装 Apache2.3 修改配置 Apache2.4 指定服务端口（非必须）2.5 配置系统变量2.6 安装服务2.7 Apache 环境开启 htaccess 伪静态（可选）2.8 启动服务 3. 整合 PHP、Apache3.1 配置 apache 支持 php3.2 修改网站默认首页3.3 修改Apache 默认的站点目录3.4 测试 php 网站 4. 安装 php 依赖管理工具：Composer4.1 下载 Composer4.2 安装 Composer：方式一4.3 安装 Composer：方式二4.4 更改 Composer 镜像 5. VsCode 配置5.1 安装 vs code 插件5.2 下载和配置 Xdebug 库5.3 调试运行 debug 6. MySQL在Windows 环境中的安装7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2669b5047e6ff7a593d941fbd452756/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb2df31feacf0cba34afffbf0feb3d85/" rel="bookmark">
			np.convolve(x,h, mode=‘##‘)的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用法： np.convolve(a,v,mode) a代表卷积数据，v卷积核大小，mode卷积方式，mode卷积方式有三种 same full valid mode可能的三种取值情况：
full’　默认值，返回每一个卷积值，长度是N+M-1,在卷积的边缘处，信号与卷积核不能完全重叠计算，会存在边缘数据无法计算到的情况，存在边际效应。‘same’　返回的数组长度为max(M, N)，是的输入数据与输出数据保持一致，也叫做等长卷积，边际效应依旧存在，但是便于计算。‘valid’ 返回的数组长度为max(M,N)-min(M,N)+1，只计算信号（输入数据）与卷积核数据完全重叠的窗口数据，得到的数据都是完全重叠的点，边际效应不存在。 三种计算方式： full: import numpy as np h=[4,3,2] x=[1,2,3,5] result_full=np.convolve(h,x,mode='full') print(result_full) 结果：
[ 4 11 20 33 21 10] 计算方式：
首先需要将h进行reverse翻转。
#mode=full 2,3,4 1,2，3,5 = 4 （存在边际效益） 2,3,4 1,2，3,5 = 3+8 =11 （存在边际效益） 2, 3, 4 1, 2，3, 5 = 2+6+12 =20 2, 3, 4 1, 2，3, 5 = 4+9+20 =33 2, 3, 4 1, 2， 3, 5 = 6+15 =21 （存在边际效益） 2, 3, 4 1, 2， 3, 5 = 10 （存在边际效益） valid 在full中不存在边际效应的数据为:20,33
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb2df31feacf0cba34afffbf0feb3d85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8748027a8b57c47c0ff13227380b6583/" rel="bookmark">
			nacos ErrMsg:caused: dom name can only have these characters: 0-9a-zA-Z-._:, current:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nacos 出现此错误;
nacos ErrMsg:caused: dom name can only have these characters: 0-9a-zA-Z-._:, current: 1. 检查下配置文件中nacos的 group 配置的后面是不是有空格了
2. 看下发送心跳的请求参数中 有哪些不符合要求的参数格式
大体是配置有问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9851c5c941117b86021686ae69aea47f/" rel="bookmark">
			【有问必答】搭建uniapp项目流程手把手教学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言🍊缘由博友有问，狗哥必答 🎯主要目标实现4大重点 🎁快速链接公众号：JavaDog程序狗🍯猜你喜欢文章推荐 🍈猜你想问如何与狗哥联系进行探讨 正文🏀前置条件1.HBuilderX2.npm Node.js 包管理工具 🍄开始1.打开工具2.创建新项目3.引入组件4.组件配置5.函数封装 😋补充 总结 前言 🍊缘由 博友有问，狗哥必答 前段时间，博友加本狗微信，询问uniapp的学习方法。本狗资历浅薄，没有专门学过uniapp，只能将自己日常开发uniapp的基本流程和步骤进行分享，希望可以略尽绵薄之力。感谢如下图所示的博友朋友的询问支持，大家的支持才是我进步的动力。
🎯主要目标 实现4大重点 uniapp项目搭建流程uniapp项目常用组件引入方式uniapp项目接口封装策略uniapp项目常用配置整理 🎁快速链接 公众号：JavaDog程序狗 关注公众号，发送 【uniapp】，无任何套路即可获得
🍯猜你喜欢 文章推荐 【项目实战】SpringBoot+vue+iview打造一个极简个人博客系统
【项目实战】SpringBoot+uniapp+uview2打造H5+小程序+APP入门学习的聊天小项目
【项目实战】SpringBoot+uniapp+uview2打造一个企业黑红名单吐槽小程序
【模块分层】还不会SpringBoot项目模块分层？来这手把手教你！
【ChatGPT】手摸手，带你玩转ChatGPT
【ChatGPT】SpringBoot+uniapp+uview2对接OpenAI，带你开发玩转ChatGPT
🍈猜你想问 如何与狗哥联系进行探讨 关注公众号【JavaDog程序狗】，里面包含狗哥联系方式，有问必答
正文 🏀前置条件 1.HBuilderX 官方IDE下载地址 https://www.dcloud.io/hbuilderx.html
2.npm Node.js 包管理工具 安装Node等相关百度即可，简单易懂
🍄开始 1.打开工具 双击打开HBuilder X
2.创建新项目 点击HBuilder X工具左上角【文件】=》【新建】=》【项目】 按照项目业务起名，如聊天系统就叫chat-uniapp，博客系统就叫blog-uniapp，这个地方不强制，个人习惯，本次实例以example-unipp作为项目名，选择默认模板，示例以vue2版本做基础，点击【创建】 初始化项目结构如下
3.引入组件 本狗在uniapp项目中，常用UI库及常用工具引入，小项目基本够用，大家可按需加载 插件版本用途uview-ui^2.0.31多平台快速开发的UI框架moment^2.29.4js工具库 uView UI，是全面兼容nvue的uni-app生态框架，其中还包含API相关JS函数，方便封装易用。
moment是时间js工具库，常用时间转化格式化等
项目根路径新建package.json，配置上述依赖组件 { "dependencies": { "moment": "^2.29.4", "uview-ui": "^2.0.31" } } 项目根路径下拉取依赖 右击项目根目录，点击【使用命令行窗口打开所在目录】，或者通过命令行进入项目路径都可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9851c5c941117b86021686ae69aea47f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/355d2ff12323843afaa6e98cba08faef/" rel="bookmark">
			git Committer identity unknown *** Please tell me who you are. Run git config --global user.email。。。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 git工具 【Git Bash Here】。。。 git init git config --global user.email "zz@163..com" //郵箱地址 git config --global user.name "zz" //名稱 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/617000d0e863d22846993704da8895bf/" rel="bookmark">
			华为机试真题Java 实现【获取最大软件版本号】【2022.11 Q4】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 Maven 版本号定义，&lt;主版本&gt;.&lt;次版本&gt;.&lt;增量版本&gt;-&lt;里程碑版本&gt;
举例3.1.4-beta 其中，主版本和次版本都是必须的，主版本，次版本，增量版本由多位数字组成，可能包含前导零，里程碑版本由字符串组成。
&lt;主版本&gt;.&lt;次版本&gt;.&lt;增量版本&gt;：基于数字比较
里程碑版本：基于字符串比较，采用字典序
比较版本号时，按从左到右的顺序依次比较。
基于数字比较， 只需比较忽略任何前导零后的整数值 。
输入2个版本号，输出最大版本号。
输入描述 输入两个版本号，按行分割，每个版本号的长度小于50
输出描述 输出较大的版本号
用例 示例1： 输入： 2.5.1-C
1.4.2-D
输出： 2.5.1-C
个人解法 不保证通过率
import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line1 = br.readLine(); String[] s1 = line1.split("\\."); String line2 = br.readLine(); String[] s2 = line2.split("\\."); String[] ss1 = s1[2].split("-"); String[] ss2 = s2[2].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/617000d0e863d22846993704da8895bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/474d9e7d5c876a1b2dc889cc792d1d12/" rel="bookmark">
			华为机试真题Java 实现【通信误码】【2022.11 Q4】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 信号传播过程中会出现一些误码，不同的数字表示不同的误码ID，取值范围为1~65535，用一个数组记录误码出现的情况，
每个误码出现的次数代表误码频度，请找出记录中包含频度最高误码的最小子数组长度。
输入描述 误码总数目：取值范围为0~255，取值为0表示没有误码的情况。
误码出现频率数组：误码ID范围为165535，数组长度为11000。
输出描述 包含频率最高的误码最小子数组长度
用例 示例1： 输入： 5
1 2 2 4 1
输出： 2
说明： 频度最高的有1和2，他们的频度均为2.可能的记录数组为[2,2]和 [1,2,2,4,1]，最短的长度为2.
示例2： 输入： 7
1 2 2 4 2 1 1
输出： 4
说明： 最短的为[2,2,4,2]
个人解法 不保证通过率
import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Arrays; import java.util.HashMap; import java.util.Map; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/474d9e7d5c876a1b2dc889cc792d1d12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b247fac6175a2ee268e04561d427197/" rel="bookmark">
			深度学习目标检测：YOLOv5实现车辆检测(含车辆检测数据集&#43;训练代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习目标检测：YOLOv5实现车辆检测(含车辆检测数据集+训练代码) 目录
深度学习目标检测：YOLOv5实现车辆检测(含车辆检测数据集+训练代码)
1. 前言
2. 车辆检测数据集说明
（1）车辆检测数据集
（2）自定义数据集
3. 基于YOLOv5的车辆检测模型训练
（1）YOLOv5安装
（2）准备Train和Test数据
（3）配置数据文件
（4）配置模型文件
（5）重新聚类Anchor（可选）
（6）开始训练
（7）可视化训练过程
（8）常见的错误
4. Python版本车辆检测效果
5. Android版本车辆检测效果
6.项目源码下载
1. 前言 本篇博客，我们将手把手教你搭建一个基于YOLOv5的车辆目标检测项目。目前，基于YOLOv5s的车辆平均精度平均值mAP_0.5=0.57192，mAP_0.5:0.95=0.41403，基本满足业务的性能需求。另外，为了能部署在手机Android平台上，本人对YOLOv5s进行了模型轻量化，开发了一个轻量级的版本yolov5s05_416和yolov5s05_320，在普通Android手机上可以达到实时的检测和识别效果，CPU(4线程)约30ms左右，GPU约25ms左右 ，基本满足业务的性能需求。
先展示一下Python版本车辆检测Demo效果：
【尊重原创，转载请注明出处】https://panjinquan.blog.csdn.net/article/details/128099672
更多项目《智能驾驶 车牌检测和识别》系列文章请参考：
智能驾驶 车牌检测和识别（一）《CCPD车牌数据集》：https://blog.csdn.net/guyuealian/article/details/128704181智能驾驶 车牌检测和识别（二）《YOLOv5实现车牌检测（含车牌检测数据集和训练代码）》：https://blog.csdn.net/guyuealian/article/details/128704068智能驾驶 车牌检测和识别（三）《CRNN和LPRNet实现车牌识别（含车牌识别数据集和训练代码）》：https://blog.csdn.net/guyuealian/article/details/128704209智能驾驶 车牌检测和识别（四）《Android实现车牌检测和识别（可实时车牌识别）》：https://blog.csdn.net/guyuealian/article/details/128704242智能驾驶 车牌检测和识别（五）《C++实现车牌检测和识别（可实时车牌识别）》：https://blog.csdn.net/guyuealian/article/details/128704276智能驾驶 红绿灯检测（一）《红绿灯(交通信号灯)数据集》：https://blog.csdn.net/guyuealian/article/details/128222850智能驾驶 红绿灯检测（二）《YOLOv5实现红绿灯检测(含红绿灯数据集+训练代码)》：https://blog.csdn.net/guyuealian/article/details/128240198智能驾驶 红绿灯检测（三）《Android实现红绿灯检测(含Android源码 可实时运行)》：https://blog.csdn.net/guyuealian/article/details/128240334 智能驾驶 车辆检测（一）《UA-DETRAC BITVehicle车辆检测数据集》：https://blog.csdn.net/guyuealian/article/details/127907325
智能驾驶 车辆检测（二）《YOLOv5实现车辆检测(含车辆检测数据集+训练代码)》：https://blog.csdn.net/guyuealian/article/details/128099672
智能驾驶 车辆检测（三）《Android实现车辆检测(含Android源码 可实时运行)》：https://blog.csdn.net/guyuealian/article/details/128190532
2. 车辆检测数据集说明 （1）车辆检测数据集 目前收集了约10W+的车辆检测数据集：UA-DETRAC车辆检测数据集+Vehicle-Dataset车辆检测数据集+BITVehicle车辆检测数据集: 关于车辆检测数据集使用说明和下载，详见另一篇博客说明：《UA-DETRAC BITVehicle车辆检测数据集(含下载地址)》
（2）自定义数据集 如果需要增/删类别数据进行训练，或者需要自定数据集进行训练，可参考如下步骤：
采集图片，建议不少于200张图片使用Labelme等标注工具，对目标进行拉框标注：labelme工具：GitHub - wkentaro/labelme: Image Polygonal Annotation with Python (polygon, rectangle, circle, line, point and image-level flag annotation).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b247fac6175a2ee268e04561d427197/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2633004fc102cccd5c88278c94cb3d12/" rel="bookmark">
			【MySQL自学之路】第4天——模式、表、视图、索引（数据定义详细版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言 数据库
数据库的建立
数据库的使用
数据库的查看
数据库的删除
模式
查看所有的模式
模式和数据库之间的关系
​编辑建立模式
删除模式
表
数据类型
查看一个数据库下面的所有表(必须进入要查看的数据库)
创建基本表
查看表结构（查看表建立的字段）
修改表结构（修改已经建立好的表）
视图
视图的作用
视图的保存的方式
建立一个视图
查看所有的视图
查询视图
删除视图
索引
建立索引的目的
索引的建立
索引的删除
前言 在上一节我们介绍了MySQL数据库服务的基本操作，初步的离开的理论，安装、操作属于我们自己的数据库。从新的一节开始，我们会从创建属于我们自己的数据库开始，逐步深入，进而掌握数据库的所有基本操作。
这一节我们将会讲述MySQL数据库模式、表、视图、索引四种结构的说明以及操作方法。
注：博客内标蓝色背景的是教材原话，黄色背景的是博主自己理解的加注，绿色背景的为引用。
数据库 我们要存放数据也好，创建模式、表、视图、索引也罢，都是在创建数据库的基础上进行的，也就是说，最初的最初，我们要先建立一个数据库，再在数据库里面建立模式、表、试图、索引等。
我们在【MySQL自学之路】第2天里面就已经进行过数据库的创建、使用，不过我们当时并没有详细说明。
数据库的建立 SQL语句：
create database sqlstudy; 注：创建一个名字为sqlstudy的数据库。如果已经创建，则不会再创建，并抛出已存在错误。
数据库的使用 SQL语句：
use sqlstudy; 注：我们一次只能在一个数据库里面操作，我们想要修改哪个数据库的数据，就要先进入（使用）哪个数据库。
数据库的查看 SQL语句：
show databases; 注：查看已经创建的所有数据库。 数据库的删除 SQL语句：
drop database sqlstudy; 模式 相比肯定会有自学MySQL的小伙伴吧，大家一般在用的时候是不是创建完数据库就直接建立表结构了？其实在建立数据库之后，还有一个层级叫做模式，只不过其可以作为数据库和表之间的一个过渡，所以好多教程或者文章并没有涉及。
注：以下内容为MySQL中使用方法，可以和其他的数据库管理系统有所出入。
查看所有的模式 SQL语句：
SELECT * FROM information_schema.schemata; 模式和数据库之间的关系 一个数据库可以建立多个模式。
在MySQL当中，建立数据库的时候默认会把其作为一个模式，并基于这个模式进行表操作。同样，建立模式的时候默认把其作为一个数据库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2633004fc102cccd5c88278c94cb3d12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e35964e7c7655ac6afd24c1c238cabd9/" rel="bookmark">
			【MySQL自学之路】第5天——对数据表数据的增删改查1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
使用的数据库
数据表
​编辑
表结构
插入数据（insert + into）
插入一条数据
插入多条数据
修改数据（update + set）
修改一条数据的值
​编辑
修改多条数据的值
删除数据（delete + from）
前言 在前几天，我们完成了对数据库的一个初步学习，对数据库的管理以及结构有了初步了解，在之后的5（增删改查1），6（增删改查2），7（安全性），8（完整性），9（触发器）天对数据库的操作知识进行最后的学习。
由于对数据的增删查改内容较多，我们分两天完成。今天主要说“增+删+改”。
注：博客内标蓝色背景的是教材原话，黄色背景的是博主自己理解的加注，绿色背景的为引用。
使用的数据库 use temp; 数据表 show tables; 表结构 desc student_table; 注：以上内容在之前的学习已经建立，如果没有建立，参考第4天。
插入数据（insert + into） 插入一条数据 SQL语句：
insert into student_table values('12345', 'mashuo', 20, 'home'); insert into student_table(sno, name, age) values('12346', 'mashuo2', 12); 注：
1.字符串类型要加引号。
2.如果字段的值可以为null，则可以不进行插入（如mashuo2）
插入多条数据 SQL语句：
insert into &lt;表名&gt;[(&lt;属性列1&gt;[,&lt;属性列2&gt;...])] 子查询; 注：插入多条数据不是指重新输入多条数据，而是通过子查询的方式对数据进行更新。 修改数据（update + set） 修改一条数据的值 SQL语句：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e35964e7c7655ac6afd24c1c238cabd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3806e3a67c9449cfaf2289987c9495ff/" rel="bookmark">
			Git（六）：基本命令（2）：复位、修改、分支合并与日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
9、reset 复位
9.1 描述
9.2 基本用法
9.2.1 回滚添加操作
9.2.2 回滚最近一次提交
9.2.3 回滚最近几次提交
9.2.4 回滚 pull
9.2.5 回滚 merge
9.2.6 区别
9.2.7 中断的工作流程处理
9.2.8 重置单独的文件
9.2.9 保留工作区并丢弃之前的提交
10、rm 删除
10.1 描述
11、mv 移动命名
11.1 描述
12、branch 分支
12.1 描述
12.2 基本用法
13、checkout 切换恢复
13.1 描述
13.2 基本用法
14、merge 合并
14.1 描述
14.2 基本用法
15、mergetool 合并冲突解决工具
15.1 描述
15.2 基本用法
16、log 日志
16.1 描述
16.2 基本用法
9、reset 复位 用于将当前 HEAD 复位到指定状态。一般用于撤销之前的一些操作(如：git add,git commit等)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3806e3a67c9449cfaf2289987c9495ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c53a2a87d7b1f7446d263d0ea9b88a8/" rel="bookmark">
			为IntelliJ IDEA安装插件~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 插件是开发工具的扩展程序，通常由第三方提供，当安装了插件后，原开发工作的菜单、按钮等开发环境可能会发生变化，例如出现了新的菜单项，或出现了新的按钮，甚至一些全新的编码方式，通常，使用插件可以使得开发某些代码或实现某些功能时更加简便。
今天呢来说说为intlliJ IDEA安装插件-----Lombok！
绝大部分的插件的安装方式都是相同的，另有一部分插件在安装成功后可能还需调整某些设置后才可以正常使用。
本次演示安装的插件是Lombok，它可以使得开发人员在编写类时，定义了属性后，不必再添加Getters &amp; Setters、hashCode &amp; equals、toString等方法，只需要添加相关注解即可。
首先，打开IntelliJ IDEA的设置（在启动界面中打开，或通过主界面的File菜单中Settings选项打开均可）：
在设置界面的左侧点击Plugins，在右侧的搜索输入框中输入lombok进行搜索，当出现了Lombok结果项后，点击对应的Install按钮即可开始安装： IntelliJ IDEA会自动下载并安装插件：
当安装完成后，会出现Restart IDE按钮，点击后IntelliJ IDEA将重启，所安装的插件将生效。
如果某插件并不需要额外的设置，则至此安装过程就已经完成了。
体验Lombok插件 重新打开设置界面，在左侧依次点击Build, Execution, Deployment &gt; Compiler &gt; Annotation Processors，在右侧选中Enable annotation processing，然后点击下方的OK表示确认并关闭设置界面：
创建新的Maven项目，自定义项目名称，确认项目的保存位置，填写GroupId和ArtifactId： 在pom.xml文件中添加Lombok的依赖代码： &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 效果如下图所示：
添加了依赖后，并不会自动下载相关的jar包文件，打开Maven面板，点击按钮栏的第1个按钮：
IntelliJ IDEA将自动下载相关的jar包文件，完成后，代码不再报错
在项目中自定义类，并声明2个属性，例如：
创建包括main方法的类，在main方法中创建类的对象，尝试调用属性对应的Setter方法，由于该方法并不存在，代码会报错：
回到自定义类，在类的声明之前添加@Setter注解：
再回到main方法，可以发现原本报错的代码将不再报错，因为Lombok框架会自动生成以上2个属性的Setter方法！（当然，通过源代码仍看不到对应的Setter方法，后续，当运行代码时，会自动生成，由于安装了插件，即使当前源代码中并没有Setter方法，但是代码也不会报错）：
同理，还可以在自定义类的声明之前添加@Getter和@ToString注解：
在main方法中可以调用对应的Getter方法、输出对象（输出对象时会自动调用toString方法）： 运行main方法，可以看到输出Getter方法和输出对象的结果： 关于Lombok框架的详细使用方式，如有不足还望补充。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6aac00a3769a42ff05c3a8db9551a81/" rel="bookmark">
			思科设备基本配置命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.console口设密码
R1(config)#line console 0
R1(config-line)#login local
R1(config-line)#login
R1(config-line)#password 123
2. console口设用户名和密码
R1(config)#line console 0
R1(config-line)#login local
R1(config-line)#exit
R1(config)#username abc password 123
3.查看当前所有配置
R1#show running-config
4.在全局模式设密码
R1(config)#enable password 123 //设置明文密码
R1(config)#enable secret 456 //设置密文密码，推荐配置
R1(config)#service password-encryption //该命令可以使明文的用户名和密码自动变成密文
5.保存配置
R1#copy running-config startup-config
R1#write
6.显示配置文件
R1#dir all
7.恢复到出厂配置
R1#delete nvram:startup-config
8.查看接口配置
R1#show running-config interface ethernet 1/0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd5706e84f218e8b364151c10482b7c3/" rel="bookmark">
			Ubuntu18.04 ORB-SLAM3配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ORB-SLAM3配置颇为麻烦，本文是对官方教程的扩展补充。
目录
1 C++11 or C++0x Compiler
2 Eigen3
3 Pangolin
4 OpenCV 5 boost
6 ORB-SLAM3
测试 参考链接
1 C++11 or C++0x Compiler 安装c++编译环境。
sudo apt-get install gcc sudo apt-get install g++ sudo apt-get install build-essential sudo apt-get install cmake 2 Eigen3 此处顺序与官方教程不同，因为Pangolin也需要Eigen，故先安装Eigen。到Eigen官网，下载3.3.0以上版本(官方教程中要求最低版本为3.1.0，但实际Sophus库需要3.3.0以上)的压缩包，解压进入该目录后，输入以下指令安装即可。
mkdir build &amp;&amp; cd build cmake .. make sudo make install 3 Pangolin Pangolin官方教程对本人来说并不直观，根据以下指令即可安装成功。
首先安装依赖。
sudo apt-get install libglew-dev sudo apt-get install libpython2.7-dev sudo apt-get install ffmpeg libavcodec-dev libavutil-dev libavformat-dev libswscale-dev libavdevice-dev sudo apt-get install libdc1394-22-dev libraw1394-dev sudo apt-get install libjpeg-dev libpng-dev libtiff5-dev libopenexr-dev 先下载代码，推荐网络不好的同学下载zip再解压，而不是使用git clone指令。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd5706e84f218e8b364151c10482b7c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2f2b5c858659b390c380037fcb0871a/" rel="bookmark">
			批量修改Mysql数据库中的索引名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发过程中肯定都有过需要批量改某个库中索引名的情况，一个表一个表的改还是麻烦的，下面的sql中对索引以表名_字段名的格式生成了指定数据库中所有索引的修改语句：
组合索引的索引名格式为表名_组合索引字段名1_组合索引字段名2.....如有其他需求可以自行更改；
使用前注意修改table_schema指定的数据库名；
-- 批量更新索引名的sql -- 查询出所有组合索引，并拼接修改索引名的语句 SELECT CONCAT( 'ALTER TABLE `', table_name, '` RENAME INDEX `', index_name, '` TO `', table_name, '_', GROUP_CONCAT( column_name ORDER BY seq_in_index SEPARATOR '_' ), '`;' ) AS RENAME_SQL FROM information_schema.statistics WHERE table_schema = 'asset_manage_local' AND index_name != 'PRIMARY' GROUP BY table_name, index_name HAVING COUNT(*) &gt; 1 -- 只处理组合索引 UNION ALL -- 查询出所有非组合索引，并拼接修改索引名的语句 SELECT CONCAT( 'ALTER TABLE `', table_name, '` RENAME INDEX `', index_name, '` TO `', table_name, '_', column_name, IF ( sub_part IS NOT NULL, CONCAT( '(', sub_part, ')' ), '' ), '`;' ) AS RENAME_SQL FROM information_schema.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2f2b5c858659b390c380037fcb0871a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/146/">«</a>
	<span class="pagination__item pagination__item--current">147/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/148/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>