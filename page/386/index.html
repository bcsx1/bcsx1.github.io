<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2c38c085aee20f6cec116a68fb09120/" rel="bookmark">
			腾讯云 DDNS shell 脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章：https://blog.csdn.net/dragon2k/article/details/88016755
在此基础上进行修改，以达到我个人日常使用的目的。
贴出代码以供参考
进都进来了，我就默认你基础的东西都弄好了，只差脚本了
#!/usr/bin/env bash # ========================================= # 个人信息 # ========================================= domain='xxx.com' subDomain='www' sId='去自己的控制台-访问密钥 获取' sKey='去自己的控制台-访问密钥 获取' # 一般不会变动，所以手动就行，包含在注释掉的打印信息中 recordId='一串数字' # ========================================= signatureMethod='HmacSHA1' timestamp=$(date +%s) nonce=$(head -200 /dev/urandom | cksum | cut -f2 -d" ") region=bj url="https://cns.api.qcloud.com/v2/index.php" # 获取 IP 的 api，可以自己替换 ip=$(curl -s ip.cip.cc) action='RecordList' src=$(printf "GETcns.api.qcloud.com/v2/index.php?Action=%s&amp;Nonce=%s&amp;Region=%s&amp;SecretId=%s&amp;SignatureMethod=%s&amp;Timestamp=%s&amp;domain=%s" $action $nonce $region $sId $signatureMethod $timestamp $domain) signature=$(echo -n $src | openssl dgst -sha1 -hmac $sKey -binary | base64) params=$(printf "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2c38c085aee20f6cec116a68fb09120/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26512c24873466058ab77b43788f29bd/" rel="bookmark">
			常量引用、非常量引用、临时对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：https://www.cnblogs.com/littleant/archive/2012/08/01/2618846.html
https://www.cnblogs.com/BensonLaur/p/5234555.html
https://blog.csdn.net/hy13684802853/article/details/87251736
产生临时对象的情况
1.按值进行函数参数传递时
2.函数返回对象时
3.发生类型转化时，例如为了使函数成功调用而进行隐式类型转换
C++中产生的临时对象是不可修改的，及默认为const的，非常量引用的初始值必须是左值，非const引用只能绑定到与该引用同类型的对象，而const引用则可以绑定到不同的但相关的对象或绑定到右值(隐式转化)，因为如果将const引用绑定到不同类型的对象（前提是被引用的类型可以转化为引用的类型），会生成一个临时对象，绑定的对象其实是这个临时对象，对这个临时对象操作并不会影响到被引用的对象，所以c++一般规定编译器自行构造的临时对象都是const的，这个也是c++禁止为非常量引用生成临时对象的原因。
const int &amp; i = 3.14; //实际过程如下 const int temp(3.14); const int &amp;i = temp; C++标准的规定：非常量的引用不能指向临时对象
void conv(string &amp;str) { } int main() { conv("dasd"); // 这里错了，编译器自动生成一个string(“dasd”)临时对象，不能将该临时对象传给非const引用 } 这里将临时对象赋给了非常量引用，会报错提示非常量限定
以C++的语义来说，如果一个程序员只想传递参数给函数，而不希望函数修改传入的参数时，那么，或者使用值传递，或者采用常量型引用(const &amp;)。考虑到大对象复制时产生的开销，一般使用常量型引用const &amp;。如果函数的参数是某个类型的一个非常量的引用，那就相当于告诉编译器，程序员希望得到函数对参数的修改结果。
临时变量是由编译器生成的，C++语言规范没规定编译器生成临时变量的规则，程序员无法得知由编译器生成的临时变量的名字，程序员无法访问那个临时变量。这意味着，以引用的方式传递一个临时变量做为函数参数，如果函数内部对此临时变量做了修改，那么函数返回后，程序员无法获得函数对临时变量的修改。函数对临时变量所做出的所有更改，都将丢失。一方面，在函数申明中，使用非常量型的引用告诉编译器你需要得到函数对某个对象的修改结果，可是你自己又不给变量起名字，直接丢弃了函数的修改结果，编译器只能说：“大哥，你这是干啥呢，告诉我把结果给你，等我把结果给你了，你又直接给扔了，你这不是在玩我吗？同时，C++的标准为了防止给常量或临时变量（只有瞬间的生命周期）赋值(易产生bug)，只许使用const引用之。
因此conv函数可以改为：
void conv(string str) { } // 值传递 void conv(const string &amp;str) { } // const引用，因为标准规定临时对象是不能更改的，所以要加上const修饰。 关于临时对象的总结
临时对象是有开销的，所以你应该尽可能的去除它们，然而更重要的是训练自己寻找可能建立临时对象的地方。
1.在任何时候只要见到常量引用（reference to const）参数，就存在建立临时对象而绑定在参数上的可能性。
2.在任何时候只要见到返回对象，就会有一个临时对象被建立（以后被释放）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15f302eab8813a6b326aa1b55aa9ebd5/" rel="bookmark">
			PageHelper分页插件的运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Pom依赖引入 &lt;!--pagehelper依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.10&lt;/version&gt; &lt;/dependency&gt; 2.yml配置 #数据库方言 pagehelper: helper-dialect: mysql 3.Controller pageNum为当前页码
pageSize为当前页包含个数
需要写PageHelper.startPage(pageNum, pageSize);在查询语句之前，将自动分页
/*查询所有成绩*/ @GetMapping("/findScoreAll") public ResultDTO findScoreAll(@RequestParam("pageNum") Integer pageNum, @RequestParam("pageSize") Integer pageSize) { PageHelper.startPage(pageNum, pageSize); List&lt;Score&gt; list = this.scoresService.findScoreAll(); PageInfo page = new PageInfo(list); ResultDTO resultDTO = new ResultDTO(0, "OK", new LinkedHashMap&lt;&gt;()); resultDTO.add("scorns", page); return resultDTO; } PageInfo page = new PageInfo(list);
包含许多常用属性，数据总个数(total)、总页数(pages)和当前页数(pageNum)等等
{ "status": 0, "msg": "OK", "body": { "scorns": { "total": 9, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15f302eab8813a6b326aa1b55aa9ebd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/decc0c5b073a6bd5d5b6f89aed9f4c69/" rel="bookmark">
			前后端分离-后端简单增删改查编写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用 generator 插件生成 pojo 和 mapper 参考：Mybatis配置generator插件
pojo 使用lombok自动生成getter，setter和toString方法
import lombok.Setter; import java.util.Date; @Getter @Setter @AllArgsConstructor @NoArgsConstructor public class Score { private Integer id; private String subject; private Float score; private String type; private Date tDate; } 二、Controller编写 增删改查编写 ResultDTO为json统一格式类
@RestController @RequestMapping("/score") public class ScoresController { @Autowired private ScoresService scoresService; /*添加成绩*/ @PostMapping("/addScore") public ResultDTO addScore(@RequestBody Score score) { this.scoresService.addScores(score); return ResultDTO.success(); } /*查询所有成绩*/ @GetMapping("/findScoreAll") public ResultDTO findScoreAll(HttpServletRequest request) { List&lt;Score&gt; list = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/decc0c5b073a6bd5d5b6f89aed9f4c69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a5a161edfc1434808c0d7a52a7979e6/" rel="bookmark">
			Spinner的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spinner的使用 1. &lt;android.support.v7.widget.AppCompatSpinner android:id="@+id/sp_select_email" android:layout_width="wrap_content" android:layout_height="wrap_content" android:entries="@array/login_company_email" android:spinnerMode="dropdown" android:theme="@style/common_spinner" /&gt; 自定义common_spinner
&lt;style name="common_spinner" parent="Widget.AppCompat.DropDownItem.Spinner"&gt; &lt;item name="android:textColor"&gt;@color/app_text_color&lt;/item&gt; &lt;item name="android:textSize"&gt;14sp&lt;/item&gt; &lt;/style&gt; 属性：
android:dropDownVerticalOffset=“5dp”//使DropDown向下偏移5个dp
android:overlapAnchor=“false”
android:spinnerMode=“dropdown”//显示模式
android:theme="@style/common_spinner"//显示文字样式
android:entries // 传入的是values文件夹下的arrayx.xml内的数据
android:spinnerMode //显示模式有popmenu和dialog两种
android:prompt //当显示模式为dialog时生效,作用为显示dialog的标题内容
事件：
mSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() { @Override public void onItemSelected(AdapterView&lt;!--?--&gt; parent, View view, int position, long id) { //选择列表项的操作 } @Override public void onNothingSelected(AdapterView&lt;!--?--&gt; parent) { //未选中时候的操作 } }); 自己定义adapter布局
ArrayAdapter arrayAdapter = new ArrayAdapter(mContext, R.layout.item_select, mList);
//传入的参数分别为 Context , 未选中项的textview , 数据源List
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a5a161edfc1434808c0d7a52a7979e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f434830946d811d3ee2ba97779beb1c/" rel="bookmark">
			ES7.x版本配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Elasticsearch7.9.3配置文件
# ======================== Elasticsearch Configuration ========================= # # NOTE: Elasticsearch comes with reasonable defaults for most settings. # Before you set out to tweak and tune the configuration, make sure you # understand what are you trying to accomplish and the consequences. # # The primary way of configuring a node is via this file. This template lists # the most important settings you may want to configure for a production cluster.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f434830946d811d3ee2ba97779beb1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf7e12df57faf07a4680fb221131b7ae/" rel="bookmark">
			C# BitConverter将字节数组转换成16进制字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 byte[] vals = { 0x01, 0xAA, 0xB1, 0xDC, 0x10, 0xDD }; string str = BitConverter.ToString(vals); Console.WriteLine(str); str = BitConverter.ToString(vals).Replace("-", ""); Console.WriteLine(str); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72e0bbce35ea4044ba39338c0a0cb83f/" rel="bookmark">
			css面试笔记（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 消除图片底部间隙 图片块状化-无基线对齐：img{display：block;}图片底线对齐：img{vertical-align：bottom;}父级设置：font-size：0;行高足够小-基线位置上移：.box{line-height：0;} 2. 文本显示行数控制 单行： p{ width: xxx; overflow: hidden; text-overflow: ellipsis; // 溢出显示... white-space: nowrap; //不进行换行 } 多行： p{ max-width: 200px; display: -webkit-box; // 将元素作为弹性伸缩盒子模型显示 overflow: hidden; text-overflow: ellipsis; -webkit-line-clamp: 2; // 限制行数 -webkit-box-orient: vertical; // 子元素的排列方式 } 不换行必须设置 word-break或while-space
3. 响应式网站 响应式网站设计是一个网站能够兼容多个终端，而不是为每个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏幕尺寸做相应的处理。
页面头部必须有meta声明的viewport
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0" min-scale="1.0" max-scale="1.0" user-scalable="false"&gt; width：控制 viewport 的大小，可以指定的一个值，如 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。height：和 width 相对应，指定高度。initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。maximum-scale：允许用户缩放到的最大比例。minimum-scale：允许用户缩放到的最小比例。user-scalable：用户是否可以手动缩放。 媒体查询
@media only screen and (min-width: 375px) and (max-width: 413px) { html{ font-size: 100px; } } 媒体类型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72e0bbce35ea4044ba39338c0a0cb83f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f0d09d14f953183240c5ce4ceb004e9/" rel="bookmark">
			mysql查询数据库报错sql_mode_MySQL的sql_mode解析与设置，sql文件导入报错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在往MySQL数据库中插入一组数据时，出错了！数据库无情了给我报了个错误：ERROR 1365(22012)：Division by 0；意思是说：你不可以往数据库中插入一个 除数为0的运算的结果。于是乎去谷歌了一番，总算是明白了其中的原因：是因为MySQL的sql_mode 模式限制着一些所谓的‘不合法’的操作。
解析
这个sql_mode,简而言之就是：它定义了你MySQL应该支持的sql语法，对数据的校验等等。。
一、如何查看当前数据库使用的sql_mode：
mysql&gt; select @@sql_mode;
如下是我的数据库当前的模式：
二、sql_mode值的含义：
ONLY_FULL_GROUP_BY：
对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么将认为这个SQL是不合法的，因为列不在GROUP BY从句中
STRICT_TRANS_TABLES：
在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做任何限制
NO_ZERO_IN_DATE：
在严格模式，不接受月或日部分为0的日期。如果使用IGNORE选项，我们为类似的日期插入'0000-00-00'。在非严格模式，可以接受该日期，但会生成警告。
NO_ZERO_DATE：
在严格模式，不要将 '0000-00-00'做为合法日期。你仍然可以用IGNORE选项插入零日期。在非严格模式，可以接受该日期，但会生成警告
ERROR_FOR_DIVISION_BY_ZERO：
在严格模式，在INSERT或UPDATE过程中，如果被零除(或MOD(X，0))，则产生错误(否则为警告)。如果未给出该模式，被零除时MySQL返回NULL。如果用到INSERT IGNORE或UPDATE IGNORE中，MySQL生成被零除警告，但操作结果为NULL。
NO_AUTO_CREATE_USER
防止GRANT自动创建新用户，除非还指定了密码。
NO_ENGINE_SUBSTITUTION：
如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常
另外还有一些，这里仅对我本地当前值做解释分析。。。。。
三、据说是MySQL5.0以上版本支持三种sql_mode模式：ANSI、TRADITIONAL和STRICT_TRANS_TABLES。
1、ANSI模式：宽松模式，更改语法和行为，使其更符合标准SQL。对插入数据进行校验，如果不符合定义类型或长度，对数据类型调整或截断保存，报warning警告。对于本文开头中提到的错误，可以先把sql_mode设置为ANSI模式，这样便可以插入数据，而对于除数为0的结果的字段值，数据库将会用NULL值代替。
将当前数据库模式设置为ANSI模式：
mysql&gt; set @@sql_mode=ANSI;
2、TRADITIONAL模式：严格模式，当向mysql数据库插入数据时，进行数据的严格校验，保证错误数据不能插入，报error错误，而不仅仅是警告。用于事物时，会进行事物的回滚。 注释：一旦发现错误立即放弃INSERT/UPDATE。如果你使用非事务存储引擎，这种方式不是你想要的，因为出现错误前进行的数据更改不会“滚动”，结果是更新“只进行了一部分”。
将当前数据库模式设置为TRADITIONAL模式：
mysql&gt; set @@sql_mode=TRADITIONAL;
3、STRICT_TRANS_TABLES模式：严格模式，进行数据的严格校验，错误数据不能插入，报error错误。如果不能将给定的值插入到事务表中，则放弃该语句。对于非事务表，如果值出现在单行语句或多行语句的第1行，则放弃该语句。
将当前数据库模式设置为STRICT_TRANS_TABLES模式：
mysql&gt; set @@sql_mode=STRICT_TRANS_TABLES;
没有最好与最坏的模式，只有最合适的模式。需要根据自己的实际情况去选择那个最适合的模式！！！
另外说一点，这里的更改数据库模式都是session级别的，一次性，关了再开就不算数了！！！
也可以通过配置文件设置:vim /etc/my.cnf
在my.cnf(my.ini)添加如下配置:
[mysqld]
sql_mode='你想要的模式'
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/076c194077dacc393f2c93f50caf7d2d/" rel="bookmark">
			QComboBox样式表qss设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//未下拉时，QComboBox 样式 背景黑色
QComboBox {border:none;background:#000000;color:#ffffff;
padding-left:30px;font-size:16px “SimHei”;}
//下拉后的整个下拉窗体样式 背景红色
QComboBox QAbstractItemView {background:#ff0000;color:#ffffff;padding-left:30px;}
//下拉箭头区域样式
QComboBox::drop-down{
width: 40px;
border-left: 1px solid #ffffff;
}
//下拉箭头样式
QComboBox::down-arrow {image: url(:/xiala.png);height:30px;width:20px;}
//以下三个需要在代码中设置 ui-&gt;comboBox-&gt;setView(new QListView());
//下拉项样式 背景蓝色
QListView::item{padding-left:30px;background:0000ff;color:#ffffff;}
//下拉项选中样式（效果不明显）背景绿色
QListView::item:selected{
color:#DCDCDC;
background:#00ff00;
}
//下拉项鼠标悬浮样式 背景灰绿色
QListView::item:hover{
color:#DCDCDC;
background:#3da79d;
}
绿色为下拉项选中样式，灰绿色为下拉项鼠标悬浮样式
QComboBox::drop-down {
subcontrol-origin: padding;
subcontrol-position: top right;
width: 30px;
border-left-width: 0px;
border-left-color: gray;
border-left-style: solid;
border-top-right-radius: 3px;
border-bottom-right-radius: 3px;
}
//下面是下拉按钮正常的背景图片。
QComboBox::down-arrow {
image: url(:/images/Login_Ui/drop_down.png);
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/076c194077dacc393f2c93f50caf7d2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90d8f596e1a7f0f04165dda09ff00347/" rel="bookmark">
			解决pycharm中pyspark无法智能提示自动补全问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在pycharm进行编程的时候，我们可以通过代码动态配置环境使pyspark能够正常运行，但是存在以下两个问题： 1.编程的时候会导致导入pyspark包会标红，比如（import pyspark） 2.而且代码的自动补全失效 针对上面两个问题，通过下面的步骤即可解决： 1：找到自己安装的spark路径
2：将pyspark文件夹直接复制到pycharm项目中
3：之后就能愉快的编程了
参考自：https://www.cnblogs.com/hello-yz/p/9306099.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f54f4f0ebf15169e9f4887ddcd5ff8a/" rel="bookmark">
			mysql 输出参数 sql语句_MySQL: 详细的sql语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1添
1.1【插入单行】
insert [into] (列名) values (列值)
例：insert into Strdents (姓名,性别,出生日期) values ('开心朋朋','男','1980/6/15')
1.2【将现有表数据添加到一个已有表】
insert into (列名) select from 例：insert into tongxunlu ('姓名','地址','电子邮件')
select name,address,email
from Strdents
1.3【直接拿现有表数据创建一个新表并填充】
select into from 例：select name,address,email into tongxunlu from strdents
1.4【使用union关键字合并数据进行插入多行】
insert select tnion select 例：insert Students (姓名,性别,出生日期)
select '开心朋朋','男','1980/6/15' union(union表示下一行)
select '蓝色小明','男','19**/**/**'
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2删
2.1【删除行】
delete from [where ]
例：delete from a where name='开心朋朋'(删除表a中列值为开心朋朋的行)
2.2【删除整个表】
truncate table truncate table tongxunlu
注意：删除表的所有行，但表的结构、列、约束、索引等不会被删除；不能用语有外建约束引用的表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f54f4f0ebf15169e9f4887ddcd5ff8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/463972e24ca4af1f55ffbcdc68ac5113/" rel="bookmark">
			【转】集群和分布式部署有什么区别?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.集群和分布式的区别
小饭店原来只有一个厨师，切菜洗菜备料炒菜全干。后来客人多了，厨房一个厨师忙不过来，又请了个厨师，两个厨师都能炒一样的菜，这两个厨师的关系是集群。 为了让厨师专心炒菜，把菜做到极致，又请了个配菜师负责切菜，备菜，备料，厨师和配菜师的关系是分布式，一个配菜师也忙不过来了，又请了个配菜师，两个配 菜师关系是集群
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f15a2bc9f7d9523fb20b822b353f57e/" rel="bookmark">
			vue &#43; ts 项目中ModelSync的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要使vue支持ts写法，我们需要用到vue-property-decorator，这个组件完全依赖于vue-class-componet
首先安装：
npm i -D vue-property-decorator @ModelSync(propName: string, event?: string, options: (PropOptions | Constructor[] | Constructor) = {}) @ModelSync装饰器可接受三个参数:
propName: string类型，表示类型名称；event: string类型，表示事件名；options: PropOptions | Constructor[] | Constructor与@Prop的第一个参数一致； 看下面例子：
import { Vue, Component, ModelSync } from 'vue-property-decorator' @Component export default class YourComponent extends Vue { @ModelSync('checked', 'change', { type: Boolean }) readonly checkedValue!: boolean } 以上代码等同于：
export default { model: { prop: 'checked', event: 'change', }, props: { checked: { type: Boolean, }, }, computed: { checkedValue: { get() { return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f15a2bc9f7d9523fb20b822b353f57e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/195563b5dc640ec9f707c8ec87b93070/" rel="bookmark">
			详述Java中自定义注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自定义注解语法结构：
[public] @interface 注解名 { [属性1;] [属性2;] ... [属性n;] } 注解属性语法结构：
数据类型 属性名() [default 默认值] 注意：
1、注解属性默认没有默认值，如果注解中定义了无默认值的注解属性，则使用该注解时必须指定值。
2、如果注解属性名为value，使用该注解时可以直接赋值。
3、如果注解属性的数据类型为数组类型，赋多个值时必须使用{}括起来；但若只赋一个值，则无需使用{}。
实例：
public @interface Autowired { String value() default ""; String[] names() default {}; } //1、自定义注解中没有属性时： //@Autowired //@Autowired() //2、自定义注解中有属性String value()时： //@Autowired("lyy") //@Autowired(value="lyy") //若属性名为value，则单独赋值时可以省略value //3、自定义注解中有属性String value() default ""时： //@Autowired //@Autowired("lyy") //@Autowired(value="lyy") //4、自定义注解中有属性String value() default ""和String[] names()时： //@Autowired(names="") //@Autowired(names={""}) //对于数组类型的属性，数组中只有一个元素时，可以省略大括号 //@Autowired(names={"l","y","y"}) //对于数组类型的属性，数组中元素大于一时，必须添加大括号 //@Autowired(value="lyy",names="") //当同时为value属性和其他属性赋值时，value不能省略 //5、自定义注解中有属性String value() default ""和String[] names() default {}时： //@Autowired //@Autowired() //@Autowired("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/195563b5dc640ec9f707c8ec87b93070/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc956420d0fb6a5f2a2795b72ea260e5/" rel="bookmark">
			XML外部实体注入漏洞——XXE简单分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
XXE漏洞经常出现在CTF中，一直也没有系统的学习过，今天就来总结一波。
文章目录 一、XXE 漏洞是什么：二、XML基础知识：1、XML是什么？2、XML文档结构：DTD声明方式：1、内部DTD声明：2、外部DTD声明： 实体的声明：实体的分类：1、按声明位置分（和上面的内外部引入 DTD声明不同，别弄混了）：2、按类型分： 三、如何利用XXE：四、XXE漏洞常见的危害：1、任意文件读取：2、命令执行：3、内网探测：4、攻击内网网站：5、发起Dos攻击： 五、XXE 如何防御：方式一、使用开发语言提供的禁用外部实体的方法：方式二、过滤用户输入： 最后 一、XXE 漏洞是什么： XXE 漏洞全称：XML External Entity Injection，即 XML 外部实体 注入漏洞。XXE 漏洞发生在应用程序解析 XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起 Dos攻击等危害。
二、XML基础知识： 想要了解 XXE漏洞，需要先了解一下关于 XML的基础知识。
1、XML是什么？ XML全称：可扩展标记语言（Extensible Markup Language）。
XML是独立于软件和硬件的信息传输工具，它把数据从HTML中分离。 XML语言没有预定义的标签，需要作者定义自己的标签和自己的文档结构。
XML 被设计用来传输和存储数据，HTML 被设计用来显示数据。
2、XML文档结构： XML文档结构包括：
XML声明
DTD 文档类型定义（可选）
文档元素。
示例代码：
其中 DTD (Document Type Definition）即 文档类型定义 部分 定义了XML文档的标签以及元素属性。
如上图中的DTD 就定义了XML的根元素为 note，然后根元素下面有一些子元素 (to,from,heading,body)，那么下面的文档元素就可以使用这些元素：
&lt;!--文档元素--&gt; &lt;note&gt; &lt;to&gt;Dave&lt;/to&gt; &lt;from&gt;Tom&lt;/from&gt; &lt;head&gt;Reminder&lt;/head&gt; &lt;body&gt;You are a good man&lt;/body&gt; &lt;/note&gt; 注：
PCDATA：可被解析的字符数据。PCDATA 数据类型是会被解析器解析的文本。这些文本将被解析器检查 实体 以及 标记。文本中的标签会被当作标记来处理，而实体会被展开。与之对应的是CDATA
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc956420d0fb6a5f2a2795b72ea260e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71f3e9a1b25591b0d575930f62c6c37e/" rel="bookmark">
			php composer require alibabacloud/client 阿里云国际短信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国际版短信发送
服务器是国际版，短信发送也是国际版的
1、按照官方文档去安装一下，
composer require alibabacloud/client 结果出现下面报错提示： Could not find package alibabacloud/sdk.
2.解决方案：官方文档
composer config repo.packagist composer https://mirrors.aliyun.com/composer/ 如果此种方式不可以用，使用其他阿里云 Composer 全量镜像
//文件头部引入一下哦 require_once(dirname(dirname(__FILE__))."/Alibabacloud/vendor/autoload.php");//要换成你的路径哦！ use AlibabaCloud\Client\AlibabaCloud; /** * 发送验证码 * * @param int $mobile 手机号 * @param int $code 验证码,为空时将自动生成4位数字 * @param string $event 事件 * @return boolean */ public static function send($mobile, $code = null, $event = 'default') { $time = time() + 10*60; //10分钟之后过期 $ip = request()-&gt;ip(); // $result = Hook::listen('sms_send', $sms, null, true); //执行发送操作 AlibabaCloud::accessKeyClient(self::$accessKeyId, self::$accessSecret) -&gt;regionId('ap-southeast-1') -&gt;asGlobalClient(); Db::startTrans(); try { if ($event == 'pass'){ $msg = 'Your authentication information has passed, please log in to the APP to view'; }else if($event == 'refuse'){ $msg = 'Your authentication information has been rejected, please log in to the APP to view'; }else{ //验证码类 $msg = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71f3e9a1b25591b0d575930f62c6c37e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cea77a3c2db674c3bc200a2a4e8ed6d/" rel="bookmark">
			KEIL5软件遇到错误信息：stm32f0xx.h contains an incorrect path.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**问题：**keil5软件报错 stm32f0xx.h contains an incorrect path.
解决方法：关闭项目文件，重新打开项目文件，报错消失
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9965ab8b0c4676d30937baccc119a842/" rel="bookmark">
			算术移位和逻辑移位的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 算术移位与逻辑移位 ：
算术移位指令对带符号数进行移位。
逻辑移位指令对无符号数进行移位。算术左移、右移，逻辑左移、右移 的图示如下 ：
这里有一个进位位C，它就是标志寄存器 （即状态寄存器，亦称程序状态字寄存器PSW）中的那个进位位，指 示是否有进位或者借位，若有则该位为1，否则为0。逻辑左移跟算术左移完全一样。而逻辑右移跟算术右移则 不一样，逻辑右移的最高位在移出后补0，而在算术右移中，最高位（这里的最高位指整个编码的最高位，即有 符号数的符号位）不变，其他跟逻辑右移一样。 2. 循环移位 另外还有循环移位，分为带进位位C 和不带进位位C 两种 注意，在循环移位中没有算术、逻辑之分，只有是否带进位位之分，不要搞混淆 。在循环移位中，只有“带进位的循环右移”这种方式中，进位位C 才对移位后的结果产生影响，其他的进位位都是受影响（被 新移入的二进制位覆盖），这需要特别注意。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/562289aa92b4b6ecefdbf659187108fd/" rel="bookmark">
			C/C&#43;&#43;定义全局变量/常量的几种方法的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：https://www.cnblogs.com/catkins/p/5270388.html
摘要：
1.全局变量不要定义在头文件，只能声明在头文件，定义一定要在源文件中
2.如果想使用其他文件中的全局变量，最稳妥的方法，就是在common.h中声明，在common.cpp中定义，其他文件include "common.h"来使用全局变量
3.static、const修饰的全局变量的作用域只能是本身的编译单元，所以只想在本文件中全局变量，就在源文件中使用const或static来修饰
4.全局域中只能声明、初始化变量，不能运算
在讨论全局变量之前我们先要明白几个基本概念：
1. 编译单元(模块)：
在IDE开发工具大行其道的今天，对于编译的一些概念很多人已经不再清楚了，很多程序员最怕的就是处理连接错误(LINK ERROR), 因为它不像编译错误那样可以给出你程序错误的具体位置，你常常对这种错误感到懊恼，但是如果你经常使用gcc，makefile等工具在linux或者嵌入式下做开发工作的话，那么你可能非常的理解编译与连接的区别！当在VC这样的开发工具上编写完代码，点击编译按钮准备生成exe文件时，VC其实做了两步工作，第一步，将每个.cpp(.c)和相应.h文件编译成obj文件；第二步，将工程中所有的obj文件进行LINK生成最终的.exe文件，那么错误就有可能在两个地方产生，一个是编译时的错误，这个主要是语法错误，另一个是连接错误，主要是重复定义变量等。我们所说的编译单元就是指在编译阶段生成的每个obj文件，一个obj文件就是一个编译单元，也就是说一个cpp(.c)和它相应的.h文件共同组成了一个编译单元，一个工程由很多个编译单元组成，每个obj文件里包含了变量存储的相对地址等 。
2. 声明与定义的区别
函数或变量在声明时，并没有给它实际的物理内存空间，它有时候可以保证你的程序编译通过， 但是当函数或变量定义的时候，它就在内存中有了实际的物理空间，如果你在编译模块中引用的外部变量没有在整个工程中任何一个地方定义的话， 那么即使它在编译时可以通过，在连接时也会报错，因为程序在内存中找不到这个变量！你也可以这样理解， 对同一个变量或函数的声明可以有多次，而定义只能有一次!
3. extern的作用
extern有两个作用，第一个,当它与"C"一起连用时，如: extern "C" void fun(int a, int b); 则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的， C++的规则在翻译这个函数名时会把fun这个名字变得面目全非，可能是fun@aBc_int_int#%$也可能是别的，这要看编译器的"脾气"了(不同的编译器采用的方法不一样)，为什么这么做呢，因为C++支持函数的重载啊，在这里不去过多的论述这个问题，如果你有兴趣可以去网上搜索，相信你可以得到满意的解释!
当extern不与"C"在一起修饰变量或函数时，如在头文件中: extern int g_Int; 它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块活其他模块中使用，记住它是一个声明不是定义!也就是说B模块(编译单元)要是引用模块(编译单元)A中定义的全局变量或函数时，它只要包含A模块的头文件即可, 在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。
如果你对以上几个概念已经非常明白的话，那么让我们一起来看以下几种全局变量/常量的使用区别：
1.用extern修饰的全局变量：
以上已经说了extern的作用，下面我们来举个例子,如在test1.h中有下列声明:
#ifndef TEST1H #define TEST1H extern char g_str[]; // 声明全局变量g_str void fun1(); #endif 在test1.cpp中
#include "test1.h" char g_str[] = "123456"; // 定义全局变量g_str void fun1() { cout &lt;&lt; g_str &lt;&lt; endl; } 以上是test1模块， 它的编译和连接都可以通过,如果我们还有test2模块也想使用g_str,只需要在原文件中引用就可以了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/562289aa92b4b6ecefdbf659187108fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a2fc0aa09b13ae3253e18fbc9013569/" rel="bookmark">
			mysql all和distinct_急~关键字ALL和DISTINCT有什么不同的含义？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
ALL表示所有的抄字段袭，有重复的2条，2条都显示。
DISTINCT表示如2113果有重复的5261，只取一条。4102
All关键字是可以省略1653，但是省略all关键字在select子句和union子句会产生很不一样的效果。
distinct语句中select显示的字段只能是distinct指定的字段，其他字段是不可能出现的。
扩展资料
只有在 SELECT 语句还包括 WHERE 子句时，ALL 关键字才有意义。
不应该将 GROUP BY ALL 和访问远程表的查询一起使用。如果查询中也存在 WHERE 子句，则此类查询不支持 GROUP BY ALL；如果查询中不存在 WHERE 子句，GROUP BY ALL 就不会添加值。
如果使用 ALL 关键字，则即使某些组不包含符合搜索条件的行，查询结果也将包括 GROUP BY 子句生成的所有组。如果不使用 ALL 关键字，则包含 GROUP BY 子句的 SELECT 语句仅显示包含符合搜索条件的行的组。
第一个示例仅对数量 &gt; 10 的订单分组。
第二个示例对所有订单分组。
对于没有符合条件的行的组，包含聚合值(平均价格)的列为 NULL。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e40ab0b78a0507de411bbf900d822677/" rel="bookmark">
			python编译后的pyd爆破
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近接触一个国外某app的协议软件，是python3.8写的，它把关键模块都编译成了pyd，然后使用pyinstaller打包发布给用户。软件启动后检查机器码，然后就需要输入授权码才可使用，看着很是恼火，所以想尝试破解。其中关键应该是需要爆破pyd里的逻辑，修改汇编代码来实现绕过授权。
1. py、pyc、pyo、pyd
py: python 脚本文件(source code)
pyc:脚本文件编译得到的字节码，二进制文件，python文件经过编译器编译之后的文件。可以提高文件加载速度。
pyo:脚本文件开启优化编译选项(-O)编译得到的字节码，二进制文件，优化编译后的文件。可以通过python -O file.py生成。
pyd:基本的Windows DLL文件，python的动态链接库。
2. 编译pyd
要编译的脚本：util1.py
def func_hello(s): if s == 1: return 'hello world' elif s == 2: return '222222222' 提供编译脚本: setup.py
from setuptools import setup from Cython.Build import cythonize setup( name='test', ext_modules=cythonize('util1.py') ) 在setup.py文件所在目录下进行如下命令:
python setup.py build_ext --inplace
这样就能看到同级目录下生成pyd文件了。
32位的python生成pyd文件是32位的，64位的python生成的是64位的。
3. 使用pyd test.py
import util1 if __name__ == '__main__': print(util1.fun_hello(2)) 4. pyinstaller打包py到exe
pip install pyinstaller pyinstaller test.py 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e40ab0b78a0507de411bbf900d822677/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2415609b9ab646d1beca0fe48031f51/" rel="bookmark">
			FPGA学习.6——通用频率计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		频率测量在诸多领域都有广泛的应用，常用的频率测量方法有两种，分别是频率测量法和周期测量法。
频率测量法：在时间t内对被测时钟信号的时钟周期N进行计数，然后求出单位时间内的时钟周期数，即为被测时钟信号的时钟频率。
周期测量法：先测量出被测时钟信号的时钟周期T，然后根据频率f = 1／T求出被测时钟信号的频率。
但是上述两种方法都会产生±1个被测时钟周期的误差，在实际应用中有一定的局限性；而且根据两种方式的测量原理，很容易发现频率测量法适合于测量高频时钟信号，而周期测量法适合于低频时钟信号的测量，但二者都不能兼顾高低频率同样精度的测量要求。
等精度测量法与前两种方式不同，其最大的特点是，测量的实际门控时间不是一个固定值，它与被测时钟信号相关，是被测时钟信号周期的整数倍。在实际门控信号下，同时对标准时钟和被测时钟信号的时钟周期进行计数，再通过公式计算得到被测信号的时钟频率。
由于实际门控信号是被测时钟周期的整数倍，就消除了被测信号产生的±1时钟周期的误差，但是会产生对标准时钟信号±1时钟周期的误差。等精度测量原理示意图如图1所示。
图1等精度测量原理示意图
结合等精度测量原理和原理示意图可得：被测时钟信号的时钟频率fx的相对误差与被测时钟信号无关；增大“软件闸门”的有效范围或者提高“标准时钟信号”的时钟频率fs，可以减小误差，提高测量精度。
了解了等精度测量原理之后，我们来说明一下被测时钟信号的计算方法。
首先我们先分别对实际闸门下被测时钟信号和标准时钟信号的时钟周期进行计数。
实际闸门下被测时钟信号周期数为X，设被测信号时钟周期为Tfx，它的时钟频率fx = 1/Tfx，由此可得等式：X * Tfx = X / fx = Tx(实际闸门)。
实际闸门下标准时钟信号周期数为Y，设被测信号时钟周期为Tfs，它的时钟频率fs = 1/Tfs，由此可得等式：Y * Tfs = Y / fs = Tx(实际闸门)。
其次，将两等式结合得到只包含各自时钟周期计数和时钟频率的等式：X / fx = Y / fs = Tx(实际闸门)，等式变换，得到被测时钟信号时钟频率计算公式：fx = X * fs / Y。
最后，将已知量标准时钟信号时钟频率fs和测量量X、Y带入计算公式，得到被测时钟信号时钟频率fx。
第一部分：软件闸门gate_s及相关信号的设计与实现
由等精度测量原理可知，实现等精度测量必不可少的是实际闸门，而实际闸门是由软件闸门得来，所以我们先来生成一下软件闸门。我们计划一个完整周期的软件闸门为1.5s，前0.25s保持低电平，中间1s保持高电平，最后0.25s保持低电平。低电平部分是为了将各计数器清0，并计算待测时钟信号时钟频率；高电平部分就是软件闸门有效部分，高电平保持1s是为了提高测试精度
软件闸门的生成我们需要声明计数器进行时间计数，计数时钟使用系统时钟sys_clk。声明软件闸门计数器cnt_gate_s，计数时钟为50MHz系统时钟，时钟周期为20ns，计数器cnt_gate_s初值为0，在(0 – CNT_GATE_S_MAX)范围内循环计数。
声明软件闸门gate_s，只有计数器cnt_gate_s计数在((CNT_RISE_MAX+1)-(CNT_GATE_S_MAX-CNT_RISE_MAX))范围内保持有效高电平，高电平保持时间为1s，其他时刻均为低电平。两信号波形图如下。
第二部分：实际闸门gate_a的设计与实现
生成软件闸门后，使用被测时钟对软件闸门进行同步生成实际闸门gate_a，实际闸门波形图如下。
第三部分：实际闸门下，标准信号和被测信号时钟计数相关信号的波形设计与实现
在实际闸门下，分别对标准信号和被测信号的时钟周期进行计数。声明计数器cnt_clk_stand，在实际闸门下对标准时钟信号clk_stand进行时钟周期计数；声明计数器cnt_clk_test，在实际闸门下对被测时钟信号clk_test进行时钟周期计数，两计数器波形如下。
计数器cnt_clk_stand、cnt_clk_test在实际闸门下计数完成后，需要进行数据清零，方便下次计数。但是被测时钟频率的计算需要计数器的数据，所以在计数器数据清零之前我们需要将计数器数据做一下寄存，对于数据寄存的时刻，我们选择实际闸门的下降沿。
声明寄存器cnt_clk_stand_reg；在标准时钟信号clk_stand同步下对实际闸门打一拍得到gate_a_s；使用实际闸门gate_a和gate_a_s得到标准时钟下的实际闸门下降沿标志信号gate_a_fall_stand。当gate_afall_stand信号为高电平时，将计数器cnt_clk_stand数值赋值给寄存器cnt_clk_stand_reg。
对于计数器cnt_clk_test的数值寄存，我们使用相同的方法，声明寄存器cnt_clk_test_reg；在被检测时钟信号clk_test同步下对实际闸门打一拍得到gate_a_t；使用实际闸门gate_a和gate_a_t得到被检测时钟下的实际闸门下降沿标志信号gate_a_fall_test。当gate_a_fall_test信号为高电平时，将计数器cnt_clk_test数值赋值给cnt_clk_test_reg。
上述各信号的信号波形如下
第四部分：频率计算结果freq等相关信号波形的设计与实现
实际闸门下的标准时钟和被测时钟的周期个数已经完成计数，且对结果进行了寄存，标准时钟信号的时钟频率为已知量，得到这些参数，结合公式可以进行频率的求解。同时，新的问题出现，在哪一时刻进行数据求解。
我们可以利用最初声明的软件闸门计数器cnt_gate_s，声明计算标志信号calc_flag，在计数器cnt_gate_s计数到最大值，将calc_flag拉高一个时钟周期的高电平作为计算标志，计算被检测时钟信号时钟频率freq_reg(注意变量位宽是否满足要求)；然后在系统时钟下将计算标志信号calc_flag打一拍，得到时钟频率输出标志信号calc_flag_reg，当时钟频率输出标志信号calc_flag_reg为高电平时，将时钟频率计算结果freq_reg赋值给输出信号freq。各信号波形图如下。
到了这里，频率计算模块涉及的各信号波形均已设计并实现，经过整合后就得到频率计算模块整体波形图。
下面贴出代码仅供参考：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2415609b9ab646d1beca0fe48031f51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d51b94fea814d067dace5420c874b1b2/" rel="bookmark">
			vector扩容时以2倍或1.5倍扩容的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vector扩容原理 Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素；对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了 ；不同的编译器实现的扩容方式不一样，VS2019中以1.5倍扩容，GCC以2倍扩容。 vector扩容代码示例：
#include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; cap; cout &lt;&lt; cap.capacity() &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) { cap.push_back(i); cout &lt;&lt; "size: " &lt;&lt; cap.size() &lt;&lt; endl; cout &lt;&lt; "capacity: " &lt;&lt; cap.capacity() &lt;&lt; endl; } return 0; } VS2019执行代码结果：1.5倍扩容机制
GCC执行代码结果：2倍扩容机制
根据上述代码在不同编译器中的执行结果得出两个问题：
为什么要成倍的扩容而不是一次增加一个固定大小的容量呢？为什么是以2倍或1.5倍的方式扩容而不是其他倍数呢？ 第一个问题：以成倍方式增长
3. 假定有 n 个元素,倍增因子为 m
4. 完成这 n 个元素往一个 vector 中的 push_back​操作，需要重新分配内存的次数大约为 logm(n)
5. 第 i 次重新分配将会导致复制 m^(i) (也就是当前的vector.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d51b94fea814d067dace5420c874b1b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/728a2bc52535bf469fabfa19076ef4fb/" rel="bookmark">
			jdbc mysql 函数_Java JDBC基本使用方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文实例讲述了Java JDBC基本使用方法。分享给大家供大家参考，具体如下：
本文内容：
什么是JDBC
JDBC的使用
事务
连接池
DbUtils
首发日期：2018-05-27
修改：
2018-07-19：增加了事务、连接池、DBUtils
2018-07-27：对特别情况下的事务进行了描述。对DBUtils增加了关闭资源、关闭流。连接池发现漏了释放连接。
什么是JDBC:
JDBC全称Java Database Connectivity
JDBC可以通过载入不同的数据库的“驱动程序”而与不同的数据库进行连接。
JDBC的优点：
使用的驱动不同，即可连接不同的数据库。
使用同一套操作来操作不同的数据库
如果每一个数据库java都制订一套连接方式，那么当不同的数据库更新的时候，java也需要更新自己的代码，而使用jdbc，使用同一套代码来操作，使用不同的驱动程序(驱动程序由数据库厂商提供)来连接，这使得可以连接不同的数据库。
JDBC的使用：
导入对应数据库的驱动类：
1.在对应的数据库厂商网站获取对应的jar包
2.将对应的jar包添加到引用。
在eclipse中可以将jar包导入一个文件夹后，右键Build Path -&gt; add to path就可以将jar包添加到当前项目引用的库里面。
加载驱动：
PS:
在上面的forName中，执行了注册驱动，注册驱动这个代码被定义在驱动类的静态代码块中。
对于一些新手，使用的方法可能是
，对于这种情况，那么他可以使用driver或DriverManager.getConnection来获取数据库连接对象；而对于另外一些新手，他们可能会使用
，然后再通过DriverManager.getConnection来获取数据库连接对象。但本质上，这是一种浪费，因为静态代码块中已经静态生成了一个驱动对象并使用DriverManager.registerDriver注册了，所以上面两种都是浪费。使用forName后，可以使用DriverManager.getConnection来获取数据库连接对象。
获取连接：
在考虑使用forName节省资源后，下面介绍的获取连接的方法使用的是DriverManager.getConnection
getConnection需要参数
url:定义了连接的数据库的路径
jdbc协议:数据库子协议:主机[:端口][/连接的数据库] 【[]代表可选的】
例如：jdbc:mysql://localhost:3306/test
配置流Properties：定义了连接数据库的方式，一般至少包含user和password
不使用配置流时，传入user和password
如果使用匿名登录，则只传入url
执行SQL语句：
JDBC执行SQL语句的方式主要有三种：
1.使用Statement执行sql语句
2.使用PreparedStatement执行sql语句
3.使用CallableStatement执行sql语句
上面的Statement、PerPareStatement、Callalestatement都可以使用连接对象来获取。
使用Statement执行语句
Statement对象的获取可以使用createStatement()来获取
获取Statement对象后，对于查询类的sql语句使用：executeQuery(sql)，sql是一个字符串sql语句，返回结果是一个结果集【如果获取结果看下面的结果部分】
对于更新类(插入、修改、删除、更新)的语句使用：executeUpdate(sql)，sql是一个字符串sql语句，返回结果是一个整数(受影响的行数)
使用PreparedStatement执行语句
PreparedStatement对象的获取可以使用prepareStatement(sql)来获取，注意的是需要传入一条sql语句
PreparedStatement的功能类似Statement，但不同的是PreparedStatement可以使用占位符,它是由占位符标识需要输入数据的位置，然后再逐一填入数据。当然，PreparedStatement也可以执行没有占位符的sql语句
使用占位符后，使用setString或setInt等方法来设置每一位的数据。【有各种对应数据类型的设置方法，比如还有setFloat】
setXXX方法中，第一个参数是位置，第二个是数据
获取Statement对象后，对于查询类的sql语句使用：executeQuery()，返回结果是一个结果集【如果获取结果看下面的结果部分】
对于更新类(插入、修改、删除、更新)的语句使用：executeUpdate()，返回结果是一个整数(受影响的行数)
补充：
对于有sql缓存池的数据库，PreparedStatement的效率要高于Statement【有兴趣的自查】
使用CallableStatement执行语句
CallableStatement主要用来调用存储过程
对于输出参数，需要使用registerOutParameter注册，第一个参数是位置，第二个参数是参数类型(使用Types.xxx)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/728a2bc52535bf469fabfa19076ef4fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed638bb5ddda38c0862384f4c5fe4ea8/" rel="bookmark">
			intro是啥意思_Intro是什么意思?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
Intro是名词，意思是介绍。
例句：I'd like an intro to that girl you were talking to!
翻译：我32313133353236313431303231363533e4b893e5b19e31333431343737想请你把我介绍给刚才你和她说话的那姑娘！
当Intro作为作为它的名词复数形式时是Intros，意思也是介绍。
例句：Avoid "intros": do not force the user to watch or read something before he can access to the real content.
翻译：避免内容介绍。别强迫用户在访问到真正内容之前看某些东西。
intro也是歌曲正歌开始前的一段过门，也称前奏，间奏，围奏等。Intro： 开场；序曲；引子；开场曲；T Intro： 前卫摇滚；乡土摇滚；摇滚；噪音摇滚；Show intro： 开场。
目前很多歌手的专辑都会有类似的intro，可以理解为前奏曲目。像蔡依林《野蛮游戏》专辑，张靓颖《我相信》专辑，曾轶可《一只猫的旅行》专辑。BIGBANG，GD&amp;TOP， 王力宏，潘玮柏，吴建豪，林宥嘉等人的一些专辑都有。
在广告行业多指在loading之前的一段过渡动画，简单的体现一下网站或者产品的内容，主要是为了当前用户进入网站时能够留住用户继续浏览网站，减少网站流失。
扩展资料
双语例句:
Tell Anderson to give the intro. I'll be down there as soon as I can.
告诉安德森做个介绍，我会尽快下去的。
Here, two Meshes are created for some sort of intro movie.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed638bb5ddda38c0862384f4c5fe4ea8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dc898937bd215941bb8134d2cd79184/" rel="bookmark">
			css字体倾斜角度_css如何设置字体倾斜样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		css如何设置字体倾斜样式
发布时间：2020-11-18 10:17:45
来源：亿速云
阅读：97
作者：小新
这篇文章主要介绍css如何设置字体倾斜样式，文中介绍的非常详细，具有一定的参考价值，感兴趣的小伙伴们一定要看完！css设置字体倾斜样式的方法，可以利用font-style属性来进行设置，如【font-style:oblique;】。font-style属性指定文本的字体样式，属性值oblique指定倾斜样式。
相关属性介绍：
font-style属性指定文本的字体样式。
属性值：normal 默认值。浏览器显示一个标准的字体样式。
italic 浏览器会显示一个斜体的字体样式。
oblique 浏览器会显示一个倾斜的字体样式。
inherit 规定应该从父元素继承字体样式。
代码示例：
p.normal {font-style:normal;}
p.italic {font-style:italic;}
p.oblique {font-style:oblique;}
这是一个段落,正常。
这是一个段落,斜体。
这是一个段落,斜体。
效果：
以上是css如何设置字体倾斜样式的所有内容，感谢各位的阅读！希望分享的内容对大家有帮助，更多相关知识，欢迎关注亿速云行业资讯频道！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/943b3961184a1b4a9ed96967d343fa5f/" rel="bookmark">
			css div里引用em字体会变斜体_css常用样式font设置字体的多种变换(实例详解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS 字体属性定义文本的字体系列、大小、加粗、风格(如斜体)和变形(如小型大写字母)font-family控制字体，由于各个电脑系统安装的字体不尽相同，但是基本装有黑体、宋体与微软雅黑这三款字体，通常这样写font-family:"黑体", "宋体","Microsoft YaHei"
font-size控制字体大小，我们设置字体大小是设置它的宽度，它的高度一般电脑系统默认字体大小是16px，所以字体大小尽量不要低于16px，1em=16px； font-weight: bold;/*控制字重 一般是100-900 常用lighter(细体) normal(正常)bold加粗 */至于这个font-style，一般默认是normal，也就是正常的，如果说你设置 font-style: italic;斜体话，其实和这个的效果是差不多的;文字间的间距用的line-height如果和高度相等话，就是垂直居中了。
通常font字体的简写:font:style weight size/line-heigt font-family /*要求必须出现的2个是 size与font-family*/
css常用样式font字体的多种变换 div{
font-family: 'Microsoft YaHei';/*微软雅黑*/
/* font-family: 'Lucida Sans','Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif; */
/*字体加上双引号或者单引号，当有多个字体的时候，中间逗号分开*/
color:#f90;
font-size: 24px;/*控制字体大小*/
font-weight: bold;/*控制字重 常用lighter(细体) normal(正常)bold加粗 */
font-style: italic;/*等同于em*/
line-height: 30px;
}
/*font字体的简写:font:style weight size/line-heigt font-family*/
/*要求必须出现的2个是 size font-family*/
p{
font: 24px/1.5em 'Lucida Sans','Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/943b3961184a1b4a9ed96967d343fa5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e986e9b84ec6829af629f1eda9bcbdcc/" rel="bookmark">
			C&#43;&#43; vector用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.vector介绍 头文件：#include &lt; vector &gt;
向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。
跟任意其它类型容器一样，它能够存放各种类型的对象。
可以简单的认为，向量是一个能够存放任意类型的动态数组。
2.存储类型： vector&lt;类型&gt;标识符 vector&lt;类型&gt;标识符(最大容量) vector&lt;类型&gt;标识符(最大容量,初始所有值) int i[5]={1,2,3,4,5} vector&lt;类型&gt;vi(i,i+2);//得到i索引值为3以后的值 vector&lt;vector&lt;int&gt;&gt;v; 二维向量//这里最外的&lt;&gt;要有空格。否则在比较旧的编译器下无法通过 3.常用函数： push_back() //在数组的最后添加一个数据 pop_back() //去掉数组的最后一个数据 at() //得到编号位置的数据 begin() //得到数组头的指针 end() //得到数组的最后一个单元+1的指针 find() //判断元素是否存在 front() //得到数组头的引用 back() //得到数组的最后一个单元的引用 max_size() //得到vector最大可以是多大 capacity() //当前vector分配的大小 size() //当前使用数据的大小 capacity(); //返回a在内存中总共可以容纳的元素个数 a.reserve(100); //改变当前vecotr所分配空间的大小将a的容量（capacity）扩充至100，也就是说现在测试a.capacity();的时候返回值是100 a.resize(10); //将a的现有元素个数调至10个，多则删，少则补，增加的元素其值默认为0 a.resize(10,2); //将a的现有元素个数调至10个，多则删，少则补，增加的元素其值为2 erase() //删除指针指向的数据项 clear() //清空当前的vector rbegin() //将vector反转后的开始指针返回(其实就是原来的end-1) rend() //将vector反转构的结束指针返回(其实就是原来的begin-1) empty() //判断vector是否为空 swap() //与另一个vector交换数据 a.swap(b); //b为向量，将a中的元素和b中的元素进行整体性交换 reverse(obj.begin(),obj.end());反向迭代器,实现元素对调 注意：vector中也有insert()函数往任意位置插入元素。（详解往下翻）
3. vector二维数组两种定义方法（结果一样） 方法一： #include &lt;bits/stdc++.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e986e9b84ec6829af629f1eda9bcbdcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/150f682bef62d6e49deb1c32fbb0ac9e/" rel="bookmark">
			GO中的Channel以及死锁的造成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 这篇文章的诞生要感谢MIT 6.284课程。在其中一节课中，谈到了多线程的协同的一些问题，其中就涉及到了channel这个概念，并由一段代码引发思考并逐渐深入得到了这篇文章。
引子 课程中有一段代码如下：
其大致含义是：代码背景是在进行多线程网络爬虫页面url，master线程启动后，从channel通道中读取当前页面的所有url即urls，接着再对这个urls中的每一个url进行爬虫读取新页面中的urls（即执行go worker(u, ch ,fetcher)），每启动一个worker线程便开始向channel中写入该url指向页面中所有包含的urls，以供master线程读取。
问题抛出 那么问题来了，为什么第一层for循环不会range完ch之后便直接结束循环，还需要利用局部变量n来根据特定情况跳出循环？
问题解释 课程上的解释是，这个range会一直阻塞，但并未提出解释。其实，这里很容易分析，因为当前的channel是一个无缓冲通道。所谓无缓冲通道，简单的讲就是两个线程对channel进行操作，一个读，一个写，永远都只能是写一个，读一个按照这样的顺序进行。更详细一些的话，读的那个线程会一直阻塞，直到写的线程向channel中写入一个数据。反之亦然，写的线程在完成一次写操作之后，也会一直阻塞直到另外一个线程完成对该channel的读取操作。上述情况只有一种例外状况，那就是该channel通道被某个线程close掉了：close(channel)。
而这里的range其实不太等同于对数组的range，这里的range实质上为对channel通道的读取。所以，在并未有认为close通道的前提下，该for循环会一直阻塞，不会退出，于是需要设定一个局部状态量n让其退出循环，保证程序的正常运行。当然我们也可以通过close其channel来实现，不过我认为close的时机可能不是非常容易把握。
继续深入 完成上述思考之后，对channel进行了较为的深入的分析，当然分析是以具体的实验展开的。给出下述实验代码：
func main() { test() } func test() { ch := make(chan int,4) go func() { ch &lt;- 1 ch &lt;- 2 ch &lt;- 3 ch &lt;- 4 }() //go func() { for a := range ch { fmt.Print(a) } //}() fmt.Print("test is over") } 执行结果直接报错，显示：fatal error: all goroutines are asleep - deadlock!
即：出现死锁。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/150f682bef62d6e49deb1c32fbb0ac9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10208d1a2e4f28473348a339550b9a63/" rel="bookmark">
			【数学建模】线性规划模型基本原理与案例分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1、线性规划问题 在人们的生产实践中，经常会遇到如何利用现有资源来安排生产，以取得最大经济效益的问题。此类问题构成了运筹学的一个重要分支—数学规划，而线性规划(Linear Programming 简记LP)则是数学规划的一个重要分支。自从1947年G.B.Dantzig提出求解线性规划的单纯形方法以来，线性规划在理论上趋向成熟，在实用中日益广泛与深入。特别是在计算机能处理成千上万个约束条件和决策变量的线性规划问题之后，线性规划的适用领域更为广泛了，已成为现代管理中经常采用的基本方法之一。
1.1.1 线性规划的实例与定义 例1.1 某机床厂生产甲、乙两种机床，每台销售后的利润分别为4千元与3千元。生产甲机床需用A、B机器加工，加工时间分别为每台2小时和1小时;生产乙机床需用A、B、C三种机器加工,加工时间为每台各一小时。若每天
可用于加工的机器时数分别为A机器10小时、B机器8小时和C机器7小时，问该厂应生产甲、乙机床各几台，才能使总利润最大?
上述问题的数学模型:设该厂生产x1台甲机床和x2台乙机床时总利润z最大，则x1 ,x2应满足：
变量x1,x2称之为决策变量，(1.1) 式被称为问题的目标函数，(1.2)中的几个不等式是问题的约束条件,记为s.t.(即subject to)。
目标函数及约束条件均为线性函数，故被称为线性规划问题。线性规划问题是在-一组线性约束条件的限制下,求一线性目标函数最大或最小的问题。在解决实际问题时，把问题归结成-一个线性规划数学模型是很重要的一步,往往也是很困难的一步，模型建立得是否恰当，直接影响到求解。而选适当的决策变量,是我们建立有效模型的关键之一。
1.1.2 线性规划问题的解的概念 其中c和x为n维列向量，A、Aeq为适当维数的矩阵，b、beq为适当维数的列向量。【注意：matlab是求的min】
可行解满足约束条件(1.4) 的解x= [x,L,x,I,称为线性规划问题的可行解，而使目标函数(1.3) 达到最大值的可行解叫最优解。
可行域所有可行解构成的集合称为问题的可行域,记为R。
1.1.3 线性规划的Matlab标准形式及软件求解 其中c和x为n维列向量，A、Aeq 为适当维数的矩阵，b、beq 为适当维数的列向量。
Matlab中求解线性规划的命令为
[x,fval] = linprog(c,A,b) [x,fval] = linprog(c,A,b,Aeq,beq) [x,fval] = linprog(c,A,b,Aeq,beq,lb,ub) 【注意：这是三种不同的写法，对于标准形式，有哪个参数，就写哪个】
其中x返回的是决策向量的取值,fval返回的是目标函数的最优值，c为价值向量,A,b对应的是线性不等式约束，Aeq,beq对应的是线性等式约束，lb和ub分别对应的是决策向量的下界向量和上界向量。
例1.2 求解下列线性规划问题
求解的matlab程序如下。
f=[-2;-3;5]; a=[-2,5,-1;1,3,1]; b=[-10;12]; . aeq=[1,1,1]; beq=7; [x,yl=linprog(f,a,b,aeq,beq,zeros(3,1)); x, y=-y 1.1.4 可以转化为线性规划的问题 1.2 投资的收益和风险 1.2.1 问题提出 1.2.2 符号规定和基本假设 符号规定
si表示第i种投资项目，如股票,债券等，i= 0,1,L ,n,其中s0指存入银行;
ri,Pi,qi分别表示si的平均收益率，交易费率，风险损失率,i= 0,L ,n,其中p0= 0, q0= 0;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10208d1a2e4f28473348a339550b9a63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/309736461b6e642dd2a0a2e71458f78c/" rel="bookmark">
			【C&#43;&#43;】STL学习小总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经过自学以及查找资料汇总的一些记录。
STL概述 长久以来，软件界一直希望建立一种可重复利用的东西，以及一种得以制造出”可重复运用的东西”的方法，从函数(functions)，类别(classes),函数库(function libraries),类别库(class libraries)、各种组件，从模块化设计，到面向对象(object oriented )，为的就是复用性的提升。
复用性必须建立在某种标准之上。但是在许多环境下，就连软件开发最基本的数据结构(data structures) 和算法(algorithm)都未能有一套标准。大量程序员被迫从事大量重复的工作，竟然是为了完成前人已经完成而自己手上并未拥有的程序代码，这不仅是人力资源的浪费，也是挫折与痛苦的来源。
为了建立数据结构和算法的一套标准，并且降低他们之间的耦合关系，以提升各自的独立性、弹性、交互操作性(相互合作性,interoperability),诞生了STL。
STL(Standard Template Library,标准模板库)，是惠普实验室开发的一系列软件的统称。现在主要出现在 c++中，但是在引入 c++之前该技术已经存在很长时间了。
STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator)。
容器和算法之间通过迭代器进行无缝连接。STL 几乎所有的代码都采用了模板类或者模板函数，这相比传统的由函数和类组成的库来说提供了更好的代码重用机会。
STL(Standard Template Library)标准模板库,在我们 c++标准程序库中隶属于 STL 的占到了 80%以上。
STL六大组件简介 STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。
容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据，从实现角度来看，STL容器是一种class template。
算法：各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte.
迭代器：扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-&gt; , operator++,operator–等指针相关操作予以重载的class template. 所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。
仿函数：行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template
适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。
空间配置器：负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte.
STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数。
STL的优点很明显了：
STL 是 C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。
STL 的一个重要特性是将数据和操作分离。数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”,以使算法可以和容器交互运作
程序员可以不用思考 STL 具体的实现过程，只要能够熟练使用 STL 就 OK 了。这样他们就可以把精力放在程序开发的别的方面。
STL 具有高可重用性，高性能，高移植性，跨平台的优点。
高可重用性：STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。高性能：如 map 可以高效地从十万条记录里面查找出指定的记录，因为 map 是采用红黑树的变体实现的。高移植性：如在项目 A 上用 STL 编写的模块，可以直接移植到项目 B 上。 标题三大组件介绍 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/309736461b6e642dd2a0a2e71458f78c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ef27a35e009ddb6d7f9114253cc3d60/" rel="bookmark">
			C&#43;&#43; map的常见用法（详细）、map中insert用法、pair用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 map的特性 所有元素都会根据元素的减值自动被排序。 map的所有元素都是pair，同时拥有实值(value)和键值(key)。 pair的第一个元素会被视为键值，第二个元素会被视为实值。 map不允许两个元素拥有相同的键值。 头文件：#include&lt; map &gt; 二、map的基本构造函数类型 map&lt;string , int &gt;strMap; map&lt;int ,string &gt;intMap; map&lt;sring, char&gt;strMap; map&lt; char ,string&gt;charMap; map&lt;char ,int&gt;charMap; map&lt;int ,char &gt;intMap； 三、map的基本操作函数： begin() //返回指向map头部的迭代器 clear() //删除所有元素 count() //返回指定元素出现的次数 empty() //如果map为空则返回true end() //返回指向map末尾的迭代器 equal_range() //返回特殊条目的迭代器对 erase() //删除一个元素 find() //查找一个元素。查的是 健 //当所查找的关键key出现时，它返回数据所在对象的位置，如果沒有，返回iter与end()函数的值相同。 get_allocator() //返回map的配置器 insert() //插入元素 key_comp() //返回比较元素key的函数 lower_bound() //返回键值&gt;=给定元素的第一个位置 max_size() //返回可以容纳的最大元素个数 rbegin() //返回一个指向map尾部的逆向迭代器 rend() //返回一个指向map头部的逆向迭代器 size() //返回map中元素的个数 swap() //交换两个map upper_bound() //返回键值&gt;给定元素的第一个位置 value_comp() //返回比较元素value的函数 四、 二、map添加数据 map&lt;int ,string&gt; maplive; pair&lt;int,string&gt; value(1,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ef27a35e009ddb6d7f9114253cc3d60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1f6de01d5144e186e1390fd90f3ed99/" rel="bookmark">
			Ultra-Fast-Lane-Detection方法测试自己的视频基于culane模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ultra-Fast-Lane-Detection方法测试自己的视频基于culane模型 1.修改demo.py #-*-coding:GBK -*- import torch, os, cv2 from model.model import parsingNet from utils.common import merge_config from utils.dist_utils import dist_print import torch import scipy.special, tqdm import numpy as np import torchvision.transforms as transforms from data.dataset import LaneTestDataset if __name__ == "__main__": torch.backends.cudnn.benchmark = True args, cfg = merge_config() dist_print('start testing...') assert cfg.backbone in ['18','34','50','101','152','50next','101next','50wide','101wide'] if cfg.dataset == 'CULane': cls_num_per_lane = 18 elif cfg.dataset == 'Tusimple': cls_num_per_lane = 56 else: raise NotImplementedError net = parsingNet(pretrained = False, backbone=cfg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1f6de01d5144e186e1390fd90f3ed99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e491615b5f435b3b25a1b72b59707c4a/" rel="bookmark">
			算法笔记之2-路归并排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2-路归并排序 2-路归并排序算法简介：2-路归并排序算法图解：2-路归并排序代码实现(递归)：2-路归并排序代码实现(非递归)：2-路归并排序应用举栗🌰： 2-路归并排序算法简介： 归并排序是一种基于“归并”思想的排序方法，最基本的是2-路归并排序。2-路归并排序的原理：将序列两两分组，将序列归并为[n/2]个组，组内单独排序，然后将这些组再两两归并，生成[n/4]个组，组内再单独排序，以此类推，直到只剩下一个组为止。归并排序的时间复杂度为O(nlogn)。
2-路归并排序算法图解： 将序列{66, 12, 33, 57, 64, 27, 18}进行2-路归并排序。
①第一趟。两两分组，得到四组: {66, 12}、 {33,57}、 {64,27}、 {18},组内单独排序,得到新序列{{12, 66}, {33, 57}, {27, 64}, {18}}。
②第二趟。将四个组继续两两分组，得到两组: {12, 66, 33, 57}、{27, 64, 18}，组内单独排序，得到新序列{{12, 33, 57, 66}, {18, 27, 64}}。
③第三趟。将两个组继续两两分组，得到一组: {12, 33, 57, 66, 18, 27, 64}，组内单独排序，得到新序列{12, 18, 27, 33, 57, 64, 66}。排序结束。
2-路归并排序代码实现(递归)： 2-路归并排序的递归写法：反复将当前区间[left, right]分为两部分，对两个子区间[left, mid]和[mid + 1, right]分别递归进行归并排序，最后将两个已有序的子区间合并为有序序列。
#define maxn 105 //将数组A的[L1,R1]与[L2,R2]区间合并为有序区间(此处L2=R1+1) void merge(int A[],int L1,int R1,int L2,int R2){ int i = L1; //i指向A[L1] int j = L2; //j指向A[L2] int t[maxn],index = 0; //t临时存放合并后的数组，index为下标 while(i &lt;= R1 &amp;&amp; j &lt;= R2){ if(A[i] &lt;= A[j]){ t[index++] = A[i++]; //将A[i]加入序列t }else{ t[index++] = A[j++]; //将A[j]加入序列t } } while(i &lt;= R1) t[index++] = A[i++]; //将[L1,R1]剩余元素加入序列t while(j &lt;= R2) t[index++] = A[j++]; //将[L2,R2]剩余元素加入序列t for(int i = 0; i &lt; index; i++){ A[L1+i] = t[i]; //将合并后序列赋值回数组A } } //将当前区间[left, right]进行归并排序 void mergeSort(int A[],int left,int right){ if(left &lt; right){ int mid = (left + right) / 2; //中点 mergeSort(A, left, mid); //递归，左子区间[left, mid]进行归并排序 mergeSort(A, mid+1, right); //递归，右子区间[mid+1, right]进行归并排序 merge(A, left, mid, mid+1, right); //左右子区间合并 } } 2-路归并排序代码实现(非递归)： 2-路归并排序的非递归写法：令step 的初值为2,将数组中每step个元素作为一组，将其内部进行排序(把左step/2个元素与右step/2个元素合并，若元素个数不超过step/2，则不操作)；再令step乘以2，重复以上操作，直到step/2超过元素个数n。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e491615b5f435b3b25a1b72b59707c4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e81d9297873d0ca384547698ed7e12fb/" rel="bookmark">
			剑指 Offer 20. 表示数值的字符串 C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解题思路——有限状态自动机 本题使用有限状态自动机。根据字符类型和合法数值的特点，先定义状态，再画出状态转移图，最后编写代码即可。
字符类型 空格 「 」、数字「 0—9 」 、正负号 「 +− 」 、小数点 「 . 」 、幂符号 「 eE 」
状态定义 按照字符串从左到右的顺序，定义以下 9 种状态。
开始的空格幂符号前的正负号小数点前的数字小数点、小数点后的数字当小数点前为空格时，小数点、小数点后的数字幂符号幂符号后的正负号幂符号后的数字结尾的空格 结束状态 合法的结束状态又2、3、7、8
算法流程 初始化： 1. 状态转移表 states ： 设 states[i]，其中 i 为所处状态， states[i] 使用哈希表存储可转移至的状态。键值对 (key, value) 含义：若输入 key ，则可从状态 i 转移至状态 value 。
2. 当前状态 p ： 起始状态初始化为 p=0 。
状态转移循环： 遍历字符串 s 的每个字符 c 。 1. 记录字符类型 t ： 分为四种情况。
当 c 为正负号时，执行 t = 's' ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e81d9297873d0ca384547698ed7e12fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04837a56953e465bdb7a6c167a1ad7cb/" rel="bookmark">
			逻辑回归模型：信用卡欺诈分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		逻辑回归案例分析——信用卡欺诈 本次案例为信用卡欺诈数据，一共包含31个自变量，其中因变量Class表示用户在交易中是否发生欺诈行为（1表示欺诈交易，0表示正常交易）。由于数据涉及敏感信息，其中V1~V28自变量做了标准化处理。本次案例涉及到分类问题中类别比例严重失调的情况下应该如何应对，当然主要任务是对0-1样本即正常与异常样本的区分。
类别比例失调如何处理正负样本的划分 首先是库的导入操作：
import numpy as np import matplotlib.pyplot as plt import pandas as pd %matplotlib inline data = pd.read_csv("creditcard.csv") data.head(5) TimeV1V2V3V4V5V6V7V8V9...V21V22V23V24V25V26V27V28AmountClass00.0-1.359807-0.0727812.5363471.378155-0.3383210.4623880.2395990.0986980.363787...-0.0183070.277838-0.1104740.0669280.128539-0.1891150.133558-0.021053149.62010.01.1918570.2661510.1664800.4481540.060018-0.082361-0.0788030.085102-0.255425...-0.225775-0.6386720.101288-0.3398460.1671700.125895-0.0089830.0147242.69021.0-1.358354-1.3401631.7732090.379780-0.5031981.8004990.7914610.247676-1.514654...0.2479980.7716790.909412-0.689281-0.327642-0.139097-0.055353-0.059752378.66031.0-0.966272-0.1852261.792993-0.863291-0.0103091.2472030.2376090.377436-1.387024...-0.1083000.005274-0.190321-1.1755750.647376-0.2219290.0627230.061458123.50042.0-1.1582330.8777371.5487180.403034-0.4071930.0959210.592941-0.2705330.817739...-0.0094310.798278-0.1374580.141267-0.2060100.5022920.2194220.21515369.990 5 rows × 31 columns
数据集检测 在本案例中是的数据集是是否有信用卡欺诈的数据集，结合实际情况，应该是正常类占绝大多数，出现信用卡欺诈的类别占少数的，首先我们需要对我们的数据进行检验，看是否满足这样的特征
pd.value_counts()对DataFrame的某一列中具有多少重复的值进行统计，并对不同的值进行计数。使用的时候需要对特定的列进行指定，比如下面的使用中指定了Class列，并且进行排序。
#使用注释掉的代码可以直接输出列的情况： # print(data["Class"].value_counts()) count_classes = pd.value_counts(data["Class"], sort = True).sort_index() count_classes.plot(kind = "bar") plt.title("Fruad class histogram") plt.xlabel("Class") plt.ylabel("Frequancy") Text(0, 0.5, 'Frequancy') 样本数量均衡化处理 可以看出正常样本的数量时明显多于异常样本的，即样本的数据是极度不均衡的，需要进行处理。
面对数据不均衡时我们往往采取两种解决方法：
过采样：对少数样本进行数据生成，使少数的样本变得与多数样本数量相当下采样：在多数的样本中取出和少数样本规模相同的子样本作为分类的数据对象，这样使得两个样本同样的少 后面会针对两种不同的方法分别进行分析
样本特征的归一化处理 此外，在上面的数据中我们也可以发现Amount列的数据的大小浮动是比较大的，有的是几百，有的数据是个位数，amount和前面的V1-V28这些特征在未说明的情况下对结果产生的影响是相当的，如果不进行处理，机器学习算法的结果可能对较大的数予以较大的权重赋值，进入误区。所以在机器学习中我们要保证特征之间的分布差异处于一个相当的范围内。
比如我们可以看到前面的V1-V28这些特征，他们大概分布在-1-1这样的区间内，所以我们最好也要对amount的数值进行归一化处理。
from sklearn.preprocessing import StandardScaler #生成新的特征 data['normAmount'] = StandardScaler().fit_transform(data['Amount'].values.reshape(-1, 1)) #去除不需要的特征 data = data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04837a56953e465bdb7a6c167a1ad7cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15c96eacf338efa74864e7b4159432b0/" rel="bookmark">
			那些年踩过的坑: endl耗时比‘\n‘多
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		牛客打比赛做一道题，一直超时，加了c++加速的。结果把endl改成’\n’，就过了，以后打比赛还是用’\n’吧，wa哭了
题目链接 ac代码 #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int N = 100010; struct St { string name; int G,id,se; }st[N]; struct node { int G,id,se; }; string str; unordered_map&lt;string,struct node&gt; mp1; unordered_map&lt;int ,vector&lt;string&gt; &gt; v;	int main() { int n; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin&gt;&gt;n; for(int i=0; i&lt;n; i++) { string str; int G,se,id; cin&gt;&gt;str&gt;&gt;G&gt;&gt;se&gt;&gt;id; mp1[str]={G,id,se}; v[G].push_back(str); } int t; cin&gt;&gt;t; while(t--) { int q; cin&gt;&gt;q; if(q==1) { string nm; cin&gt;&gt;nm; cout&lt;&lt;mp1[nm].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15c96eacf338efa74864e7b4159432b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/343ef363ddec4ff634e3537b87300e8b/" rel="bookmark">
			JavaSE超级作业:在线考试系统【代码基本完善（未实现导入考题、代码规范混乱。）】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章内容输出来源：拉勾教育JAVA就业训练营
总目录跳转链接：总目录
设计模式总目录:【设计模式】设计模式(目录)
如有侵权请联系本人
邮箱:xiaogueika@tom.com
功能图
需要掌握的知识点:
JavaSE所有、对C/S架构有一定了解、有脑子。
文档要求：https://download.csdn.net/download/Guai_Ka/14965083
Git链接:https://gitee.com/akiaug/homework5.git
PS：代码应该比较赶，很多功能还未实现，很是遗憾。后期如果有空，会回来更新(那时候可能已经学完Java就业班了)
代码讲解
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5433451822dba004bce45f67f826a957/" rel="bookmark">
			下取整函数的含义_向上取整⌈⌉和向下取整⌊⌋符号含义及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		向上取整, 运算称为 Ceiling，用数学符号 ⌈⌉ (上有起止，开口向下)表示,。
向下取整,运算称为 Floor，用数学符号⌊⌋(下有起止，开口向上)表示。
注意，向上取整和向下取整是针对有浮点数而言的; 若整数向上取整和向下取整， 都是整数本身。
四舍五入：更接近自己的整数； 把小数点后面的数字四舍五入
即：如被舍去部分的头一位数字小于五，则舍去; 如大于等于五，则被保留部分的最后一位数字加1
向上取整：比自己大的最小整数；
向下取整：比自己小的最大整数；
例如：(此处己修正，@2018-04-49)
1.向上取整 (上有起止，开口向下):
⌈59/60⌉ = 1
⌈-59/60⌉ = 0
请看以下测试
2.向下取整(下有起止，开口向上):
⌊59/60⌋ = 0
⌊-59/60⌋ = -1
请看以下测试
提示:
向上向下取整函数数只会对小数点后面的数字不为零的数进行操作,
要是给它一个整数, 它就返回整数本身。
对小数部分不为零的数操作:
给定一个数： 4.9
调用用向下取整函数 得到的是 4
调用用向上取整函数 得到的是 5
之所以在向上取整时，分子部分要减去1，是为了避免出现，a 能被 b 整除的情况。
向上取整 ：12 / 3 == 4， (12+3)/3==5， 3 向上取整仍为 3
向下取整： 1/2 ⇒ 0 -3/2 ⇒ -2
整数 6 ， 向上向下取整都是 6本身。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5433451822dba004bce45f67f826a957/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b60b1b07bd07a48324e2556e4f4ebcc/" rel="bookmark">
			writeline是什么意思_c语言console.WriteLine什么意思？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		console.WriteLine是指输出到屏幕，常用于控制台程序中，输出内容为是一行。Console.WriteLine()方法是将要输出的字符串与换行控制字符一起输出，当次语句执行完毕时，光标会移到目前输出字符串的下一行。
Console.Write()和Console.WriteLine()都是System.Console提供的方法,两着主要用来将输出流由指定的输出装置(默认为屏幕)显示出来.
两着间的差异在Console.WriteLine()方法是将要输出的字符串与换行控制字符一起输出,当次语句执行完毕时,光标会移到目前输出字符串的下一行.
至于Console.Write()方法,光标会停在输出字符串的最后一个字符后,不会移动到下一行。
比如说Console.WriteLine("a");Console.WriteLine("b")
就会输出在2行的a
b
而Console.Write("a");Console.Write("b")
就在同一行输出a b
换行输出用：Console.WriteLine
不换行输出用：Console.Write
代码如下// 在控制台上打印 Hello World!
Console.WriteLine("Hello World !"); //换行打印
Console.Write("hello"); //不换行打印
Console.Write("--");
Console.Write("world");
Console.ReadKey();//ReadKey()运行完结果不退出控制台
C#控制台输入/输出语句
Console.Read()方法： 从控制台窗口读取一个字符，返回int值
Console.ReadLine()方法： 从控制台窗口读取一行文本，返回string值
Console.ReadKey()方法： 监听键盘事件，可以理解为按任意键执行
Console.Write()方法： 将制定的值写入控制台窗口
Console.WriteLine()方法： 将制定的值写入控制台窗口，但在输出结果的最后添加一个换行符
再要换行的地方 +“\r\n”+
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c9984059c51e6ae94c4bb0033da8901/" rel="bookmark">
			w10恢复出厂设置_win10系统恢复出厂设置失败如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当电脑遇到一些故障无法解决的时候，很多用户都会想恢复出厂设置来解决，然而有不少win10系统用户在恢复出厂设置的时候却遇到了失败的情况，该怎么办呢，接下来给大家讲解一下win10系统恢复出厂设置失败的具体解决方法。
1、打开Win10左下角的“开始菜单”然后选择进入【电脑设置】；
2、进入电脑设置之后，我们再点击进入左侧底部的【更新和恢复】设置；
3、然后在Win10更新和恢复设置中，再选择【恢复】；
4、接下来我们再点击“删除所有内容并重新安装Windows”下方的【开始】；
5、到这里需要注意的是，这里需要用到此前安装Win10的镜像文件。由于小编电脑此前是使用U盘安装的，镜像文件都在U盘中，而Win10恢复出厂设置需要用到拷贝镜像中的文件，因此会提示：“缺少一些文件”；
6、之后，将此前安装Win10的U盘插入电脑。再次进行恢复操作，接下来就可以看到如下“初始化”设置了，然后我们点击【下一步】即可；
Ps.如果电脑中有此前的Win10系统镜像文件，就无需插入安装Win10的U盘。
7、接下来会进入“你的电脑有多个驱动器”设置选项，这里有【仅限安装Window驱动器】和【所有驱动器】两个选项，大家可以根据自己情况选择。一般我们选择第一项的【仅限安装Window驱动器】即可；
8、再下来还有其他一些选择项目，我们按照提示选择即可。最后会进入【准备就绪，可以初始化电脑】提示，我们点击【初始化】就可以了；
9、最后电脑会自动重启，重启电脑后会进入“正在重置电脑(进度百分比提示)”界面，这过程需要较长一段时间，期间还会自动重启2次。如果是笔记本用户，最好是确保电池电量充足或者连接电源适配器进行。等待较长一段时间后，Win10就可以成功恢复到出厂设置了。最终进入系统设置界面，这里就和新安装的Win01初始设置是一样的，设置完成就可以进入新的Win10界面了。
上述给大家介绍的便是win10系统恢复出厂设置失败的详细解决方法，有遇到一样情况的用户们可以参照上面的方法步骤来进行操作吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4dd19281fb713446bd5637300d382bf/" rel="bookmark">
			复杂的数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、列表1.列表介绍2.列表读取读取单个元素读取列表的一部分 3.列表的修改4.其他常用操作列表的函数 二、字典1.字典的介绍2.字典的读取3.字典的元素增减 一、列表 1.列表介绍 列表，数据类型为list，可以存储多个不同种类的元素，其中，字符串元素需要加引号，且元素间要用逗号隔开。
在Python中，可以直接使用方括号创建，例如：
list_mix=['a',2,'c',4.5,'end'] #也可以是双引号 2.列表读取 在列表出生的时候，里面的每个元素就有都了对应的编号：
a2c4.5endlist_mix[0]list_mix[1]list_mix[2]list_mix[3]list_mix[4]list_mix[-5]list_mix[-4]list_mix[-3]list_mix[-2]list_name[-1] 后文中将这个编号称为“下标”
读取单个元素 如果需要打印单一元素，例如c，就可以通过
list_mix=['a',2,'c',4.5,'end'] print(list_mix[2]) 或者
list_mix=['a',2,'c',4.5,'end'] print(list_mix[-3]) 的方式来实现。
读取列表的一部分 切片
切片相当于把列表中的一部分元素切出来，格式为list_mix[n: m :k]，n为起始位置，m为结束位置，k为步长值。这种表达中，n默认为0，m默认为列表元素的个数，k默认为1。n、m、k想要保持默认时可以省略。
list_mix=['a',2,'c',4.5,'end'] print(list_mix[0:]) print(list_mix[:]) print(list_mix[::]) print(list_mix) #这四中表达的输出结果是相同的 #结果均为['a', 2, 'c', 4.5, 'end'] print(list_mix[0::2]) print(list_mix[0:5:2]) #输出的结果相同 #结果均为['a', 'c', 'end'] print(list_mix[0:2]) print(list_mix[0:2:1]) #输出结果相同 #结果均为['a', 2] #中括号内不可以为空 #list_mix[m]所代表的元素无法取到 复制列表
①用切片的方法进行列表复制：
list_mix=['a',2,'c',4.5,'end'] b=list_mix[:] 这种方式可以将当前的list_mix列表复制给b，尽管和list_mix有着相同的元素和排列方式，b却是一个单独的列表。此后对list_mix列表进行操作，不会再影响b列表。
②用赋值的方法进行列表复制：
list_mix=['a',2,'c',4.5,'end'] b=list_mix 这种方法是将list_mix的地址传递给b，b并不是新的列表。好比b和list_mix是两把一样的钥匙，计算机可以通过任何一把打开列表，此后再对列表进行操作时，无论通过b还是list_mix打开列表，结果也是一样的。
3.列表的修改 ①增添元素
在末尾增加一个元素：append()
list_mix=['a',2,'c',4.5,'end'] list_mix.append('app') print(list_mix) #结果为：['a', 2, 'c', 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4dd19281fb713446bd5637300d382bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a8d87ffecf1c848caf36c4639d45e69/" rel="bookmark">
			.Net Core上传组件_.Net Core图片上传处理组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、.Net Core上传组件Uploader简介
1.前端jquery框架封装
2.后端，支持Asp.Net 和 Asp.Net Core 矿建
3.数据传输模式支持：WebScoket 、Ajax、Form 模式上传到服务器。
最新版本资料请参考官网：http://www.gongjuji.net/uploader/
二、Asp.Net Core 使用步骤 （此案例这对WebScoket方式讲解）
注意：跟多上传方式接收，请去官网了解。
第一步：安装组件 ，根据.net Core框架，选择对应的版本
Install-Package UploadHandleCore 第二步：配置后端文件接收，从straup 文件中 的Configure方法
public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { #region 绑定上传 //绑定WebSocket处理，接收成功后，生成缩略图 UploadHandle.ServerInfo.SitePath = env.WebRootPath; //使用wwwroot作为根目录 app.Map("/upload/common", (con) =&gt; { con.UseWebSockets();//启用webscoket con.Use((ctx, n) =&gt; { Receiver _receive = new Receiver(ctx, "upload/logo"); _receive.OnSuccess += (data) =&gt; { }; return _receive.DoWork(); }); }); #endregion } 第三步：前端组件引用，和绑定
前端组件代码下载，请点击：http://www.gongjuji.net/uploader/
引用内容如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a8d87ffecf1c848caf36c4639d45e69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c205bef7a2a70780250e6e0a2bf260c6/" rel="bookmark">
			spark python 上传代码包_spark-submit提交python脚本过程记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近刚学习spark，用spark-submit命令提交一个python脚本，一开始老报错，所以打算好好整理一下用spark-submit命令提交python脚本的过程。先看一下spark-submit的可选参数
1.spark-submit参数
--master MASTER_URL:设置集群的主URL，用于决定任务提交到何处执行。常见的选项有
local:提交到本地服务器执行，并分配单个线程
local[k]:提交到本地服务器执行，并分配k个线程
spark://HOST:PORT:提交到standalone模式部署的spark集群中，并指定主节点的IP与端口
mesos://HOST:PORT：提交到mesos模式部署的集群中，并指定主节点的IP与端口
yarn:提交到yarn模式部署的集群中
--deploy-mode DEPLOY_MODE:设置driver启动的未知，可选项如下，默认为client
client:在客户端上启动driver，这样逻辑运算在client上执行，任务执行在cluster上
cluster：逻辑运算与任务执行均在cluster上，cluster模式暂时不支持于Mesos集群或Python应用程序
--class CLASS_NAME :指定应用程序的类入口，即主类，仅针对java、scala程序，不作用于python程序
--name NAME :应用程序的名称
--jars JARS:用逗号隔开的driver本地jar包列表以及executor类路径,将程序代码及依赖资源打包成jar包
--packages:包含在driver 和executor 的 classpath 中的 jar 的 maven 坐标
--exclude-packages:为了避免冲突 ，指定的参数--package中不包含的jars包
--repository:附加的远程资源库(包含jars包)等，可以通过maven坐标进行搜索
--py-files PY_FILES:逗号隔开的的.zip、.egg、.py文件，这些文件会放置在PYTHONPATH下，该参数仅针对python应用程序
--files FILES:逗号隔开的文件列表，这些文件将存放于每一个工作节点进程目录下
--conf PROP=VALUE:指定spark配置属性的值，格式为PROP=VALUE， 例如 -conf spark.executor.extraJavaOptions="-XX:MaxPermSize=256m"
--properties-file FILE:指定需要额外加载的配置文件，用逗号分隔，如果不指定，默认为 conf/spark-defaults.conf
--driver-memory MEM :配置driver内存，默认为1G
--driver-java-options:传递给driver的额外选项
--driver-library-path:传递给driver的额外的库路径
--driver-class-path:传递给driver 的额外的类路径，用--jars 添加的jar包会自动包含在类路径里
--executor-memory MEM :每个 executor 的内存，默认是1G
当'--master'参数设置为Standalone，‘--deploy-mode’参数设置为cluster时，如下选项可以设置：
--driver-cores NUM：driver使用的内核数，默认为1
当'--master'参数设置为Standalone或者Mesos，‘--deploy-mode’参数设置为cluster时，如下选项可以设置：
--supervise:如果设置了该参数，driver失败是会重启
--kill SUBMISSION_ID:如果设置了该参数，则会杀死指定SUBMISSION_ID的driver进程
--status SUBMISSION_ID：如果设置了该参数，则请求返回指定SUBMISSION_ID的driver的状态
当'--master'参数设置为Standalone或者Mesos时，如下选项可以设置：
--total-executor-cores NUM：设置集群中所有工作节点上executor使用的内核总数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c205bef7a2a70780250e6e0a2bf260c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dd790931f2446fead38a8f55ba6cba3/" rel="bookmark">
			LeetCode 1631 水位上升的泳池中游泳 HERODING的LeetCode之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一个 N x N 的坐标方格 grid 中，每一个方格的值 grid[i][j] 表示在位置 (i,j) 的平台高度。
现在开始下雨了。当时间为 t 时，此时雨水导致水池中任意位置的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。
你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 (N-1, N-1)？
示例 1:
输入: [[0,2],[1,3]]
输出: 3
解释:
时间为0时，你位于坐标方格的位置为 (0, 0)。
此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。
等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置
示例2:
输入: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
输出: 16
解释:
0 1 2 3 4
24 23 22 21 5
12 13 14 15 16
11 17 18 19 20
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dd790931f2446fead38a8f55ba6cba3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d52114454352173046d037c64665413/" rel="bookmark">
			python降版本的影响_python3版本降级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：
MacOS 11.1
说明：
已经安装了python3.9
但是在安装pip 安装python airtest第三方库，报error:No matching distribution found for opencv-contrib-python&lt;=3.4.2.17 (from airtest)
经过排查，发现该库目前不支持python3.8，所以现在将python3.9降级为3.6
目标：mac有自带的python2,在降级python3的同时，不希望系统自带的python2受到影响
1、移除现有Python
bogon:~lz1$ brew unlink python3
Unlinking/usr/local/Cellar/python@3.9/3.9.1_6... 25 symlinks removed
2、安装3.6.5
brew install https://raw.githubusercontent.com/Homebrew/homebrew-core/f2a764ef944b1080be64bd88dca9a1d80130c558/Formula/python.rb
删除非brew安装的python3方法
注意这1步
删除系统环境变量配置文件中python的相关配置：
sudo vi ~/.bash_profile
1
输入系统密码后，光标移动到以下Python配置每行按 i 删除共4行配置，按【ESC】键跳到命令模式，按下冒号按键，然后再按下 wq 回车，即可保存退出vi的编辑状态。
# Setting PATH for Python 3.7
# The original version is saved in .bash_profile.pysave
PATH="/Library/Frameworks/Python.framework/Versions/3.7/bin:${PATH}"
export PATH
这里可以看到python3.6.5的安装目录
删除掉3.6的文件夹
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3d51473dc9379823218392cc573ccee/" rel="bookmark">
			中国电子协会考评中心_中国电子学会考评中心和CPA青少年编程能力等级测评有什么不同？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.考评大纲不同
完整大纲内容如下： 中国电子学会考评中心​www.qceit.org.cn 此图是已考过python一级学生报考界面 CPAT​www.cpatest.cn 电子协会举办的考级科目较多。一级为必考级，而后可跨级考。就目前而言青少年宫只有scartch（一二级）与python（一二级），考时不可跨级。
2.主办单位不同
中国电子学会（The Chinese Institute of Electronics，CIE） ，是5A级全国学术类社会团体。它的主管部门是国家一级协会：中国科学技术协会。
中国电子学会考评中心​www.qceit.org.cn 中国青少年宫协会是由全国各地青年宫、少年宫、青少年宫、青少年活动中心、青少年校外活动中心、儿童活动中心、妇女儿童活动中心、青少年科技馆（站）等青少年活动场所组成的非营利性团体，是国家民政部注册的一级协会。
CPAT​www.cpatest.cn 根据主办方的社会地位大家也可以倾向自己熟悉的，它俩在社会名气都挺大的。
3.考试时间报名费用不同
青少年软件编程等级考试： 中国电子学会考评中心​www.qceit.org.cn 青少年编程能力等级测评： CPAT​www.cpatest.cn 根据2020年考试时间选择自己空的时间和距离近的考点，具体考点可登官网查看。scartch的考级价格一样，少年宫的去考python语言的话贵了一个档。
4.证书不同：
中国青少年宫协会： 中国电子协会： 关于含金量或者说报考哪个地方设立的考级其实问题都不大，个人建议报考时专注一件坚持下去考到它的最高级证书。它是检验孩子学习编程语言达到一个什么样的水平的一个证明。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93b41cab805989fc9a4ee097ae493677/" rel="bookmark">
			python读取matlab矩阵_将Matlab矩阵读入Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我试图将一个Matlab矩阵读入
python时,我得到以下错误
&gt;&gt;&gt; scipy.io.loadmat("Dynamical.mat")
Traceback (most recent call last):
File "", line 1, in File "/usr/lib/python2.7/dist-packages/scipy/io/matlab/mio.py", line 151, in loadmat
MR = mat_reader_factory(file_name, appendmat, **kwargs)
File "/usr/lib/python2.7/dist-packages/scipy/io/matlab/mio.py", line 105, in mat_reader_factory
mjv, mnv = get_matfile_version(byte_stream)
File "/usr/lib/python2.7/dist-packages/scipy/io/matlab/miobase.py", line 221, in get_matfile_version
% ret)
ValueError: Unknown mat file type, version 46, 48
Dynamical.mat是包含矩阵的文件
% Size = 30 30
% Nonzeros = 252
zzz = zeros(252,3);
zzz = [
1 1 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93b41cab805989fc9a4ee097ae493677/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ab73376074e0cb89382b0cfe1e84009/" rel="bookmark">
			python语句块标记_python语言语句块的标记是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python中没有明显的语句块标记，是通过缩进来识别语句块的。Python是一种跨平台的计算机程序设计语言；是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言；多被用于独立的、大型项目的开发。
python没有明显的语句块标记，是通过缩进来识别语句块的。
这里打开编辑器，新建一个py文件作为示范。
def happy():
print("Very Happy!")
happy()
创建函数的时候，冒号以后需要进行缩进，标记语句块。
x = 1
while x &lt; 5:
print(x)
x += 1
在用while的时候，冒号以后需要进行缩进，标记语句块。
x = 1
if x &lt; 10:
print("ok")
else:
print("not ok")
在用if和else语句的时候，冒号以后需要进行缩进，标记语句块。
如果不用标记语句块，是会报错的。
def hey():
x = 1
while x &lt; 3:
print("hey")
x += 1
if x == 3:
print("ok")
hey()
每一次冒号以后都是需要标记语句块，而且要根据格式一层一层标记。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/385/">«</a>
	<span class="pagination__item pagination__item--current">386/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/387/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>