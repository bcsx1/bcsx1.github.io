<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab9632c89ceceb8cafa36a93c5c347f0/" rel="bookmark">
			opencv形状匹配（cv2.matchShape）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		""" 21.4.3-形状匹配.py: 函数 cv2.matchShape() 可以帮我们比 两个形状或 廓的相似度。 如果返回值越小， 匹配越好。它是根据 Hu 矩来计算的。 #Hu 矩是归一化中心矩的线性组合 # 之所以这样做是为了能够获取 代表图像的某个特征的矩函数 # 这些矩函数对某些变化如缩放 ，旋转，镜像映射（ 除了 h1）具有不变形。 """ import cv2 import numpy as np img1 = cv2.imread('hh.png', 0) img=img1.copy() ret, thresh = cv2.threshold(img1, 127, 255, 0) contours, hierarchy = cv2.findContours(thresh, 2, 1) area=[] for k in range(len(contours)): area.append(cv2.contourArea(contours[k])) ##排序后返回原来的位置 area=np.argsort(area) #绘制轮廓 cv2.drawContours(img1,contours[area[-1]],-1,(255,0,0),3) cv2.drawContours(img1,contours[area[-2]],-1,(0,255,0),3) cv2.drawContours(img1,contours[area[-3]],-1,(0,0,255),3) #绘制轮廓的边界矩形 x,y,w,h=cv2.boundingRect(contours[area[-1]]) print('轮廓1',cv2.contourArea(contours[area[-1]])) img1=cv2.rectangle(img1,(x,y),(x+w,y+h),(255,25,99),2) cv2.imshow('img1',img1) x,y,w,h=cv2.boundingRect(contours[area[-2]]) print('轮廓2',cv2.contourArea(contours[area[-2]])) img1=cv2.rectangle(img1,(x,y),(x+w,y+h),(220,255,255),2) cv2.imshow('img2',img1) x,y,w,h=cv2.boundingRect(contours[area[-3]]) print('轮廓3',cv2.contourArea(contours[area[-3]])) img1=cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab9632c89ceceb8cafa36a93c5c347f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71702c95be21c7e004637e4c5bc10a59/" rel="bookmark">
			如何搭建nginx服务器？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍了如何在阿里云服务器上从零开始搭建nginx服务器。阿里云服务器（ECS）相信大家都不陌生，感兴趣的同学可以去购买，或到体验馆去体验（半个月有效期）。至于如何注册、管理ECS这里就不详细介绍了。因为官方文档已经写的很清楚了。如果还不清楚，打咨询电话询问。
一、简介 Nginx是一款轻量级的网页服务器、反向代理服务器。相较于Apache、lighttpd具有占有内存少，稳定性高等优势。它最常的用途是提供反向代理服务。
二 、安装 1、准备工作 Nginx的安装依赖于以下三个包，意思就是在安装Nginx之前首先必须安装一下的三个包，注意安装顺序如下：
1 SSL功能需要openssl库，直接通过yum安装: #yum install openssl
2 gzip模块需要zlib库，直接通过yum安装: #yum install zlib
3 rewrite模块需要pcre库，直接通过yum安装: #yum install pcre
2、安装Nginx依赖项和Nginx 1 使用yum安装nginx需要包括Nginx的库，安装Nginx的库
#rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm
2 使用下面命令安装nginx
#yum install nginx
3 启动Nginx
#service nginx start
3、直接浏览器访问localhost就会出现Nginx的欢迎界面表示你安装成功了，否则就是安装失败了
默认80端口加入防火墙访问白名单中：firewall-cmd --permanent --zone=public --add-port=80/tcp
使用firewall-cmd --reload命令使其生效
4、配置Nginx
CentOS安装Nginx后，安装在了 /etc/nginx/目录下，你可以打开/etc/nginx/conf.d/default/conf查看里面的配置，包括监听端口，域名和nginx访问的根目录
三、配置 以上安装方法nginx的配置文件位于
/usr/local/nginx/conf/nginx.conf Nginx配置文件常见结构的从外到内依次是「http」「server」「location」等等，缺省的继承关系是从外到内，也就是说内层块会自动获取外层块的值作为缺省值。
Server 接收请求的服务器需要将不同的请求按规则转发到不同的后端服务器上，在 nginx 中我们可以通过构建虚拟主机（server）的概念来将这些不同的服务配置隔离。
server { listen 80; server_name localhost; root html; index index.html index.htm; } 例如我们笔戈玩下的两个子项目 passport 和 wan 就可以通过在 nginx 的配置文件中配置两个 server，servername 分别为 passport.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71702c95be21c7e004637e4c5bc10a59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21ca224eb3850c2c16c732f2b6a4e5b9/" rel="bookmark">
			动态场景下的轨迹规划（轨迹生成/代码实现/未来挑战）！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | Young 编辑 | 半杯茶的小酒杯
点击下方卡片，关注“自动驾驶之心”公众号
ADAS巨卷干货，即可获取
点击进入→自动驾驶之心【轨迹预测】技术交流群
后台回复【轨迹预测综述】获取行人、车辆轨迹预测等相关最新论文！
一些场景下的轨迹规划效果：
“ 巡航模式转跟车模式 ” 自动驾驶决策系统 论文【1】中提出的自动驾驶决策系统(Decision-Making System)包含三层Behavior Planner：
High Level Planner: 负责从电子地图生成导航路线；
Middle Level Planner: 负责处理交通规则，如车道限速、路口交通灯等；
Low Level Planner: 负责根据主车周围的动静态障碍物生成运行轨迹。
本文主要讨论Low Level Planner，即轨迹规划(Trajectory Planning)。
1. 轨迹规划的整体流程 轨迹规划的流程，来源【5】 2. 轨迹生成 2.1 横向轨迹生成 2.1.1 High Speed Trajectories 横向规划主要承担车辆的换道、避障等任务，在横向轨迹规划中，主要考虑车辆乘坐的舒适性，车辆到达目标位置的时间，并对偏离车道中心线的行为进行惩罚。
车辆的舒适性：通过Jerk(加速度的变化率)调节，惩罚大的加速度变化率，避免车辆急加速(Acceleration)和急减速(Deceleration)。
车辆到达目标位置的时间：惩罚时间长的轨迹，使得车辆快速到达目标位置。
车辆对中心线的偏离程度：车辆在中心线上时，d = 0；越偏离中心线，d越大，需要施加的惩罚量就越大。
论文【2】中提出的cost函数如下:
其中，、、是各个考量因素的权重，需要根据应用场景自行调整。
在横向规划的目标位置选择上，论文【2】中使用、，即总是假设车辆的目标状态一定是平行于车道中心线的。
灰色是不符合车辆行驶约束的轨迹，黑色是符合车辆行驶约束的轨迹，绿色是cost最小的轨迹 最后，如上图所示，对T和进行采样，利用五次多项式计算出一系列的轨迹集合。再通过车辆的最大加速度、最大速度、最大曲率、障碍物碰撞检测等一系列条件对轨迹进行筛选和过滤，最后选择剩下的cost最小的合法轨迹作为车辆的行驶轨迹。
2.1.2 Low Speed Trajectories 在高速场景下，横向运动和纵向运动可以认为是独立的，但是实际上，车辆是不能直接横向运动的(non-holonomic)，所以在低速场景下，需要同时考虑车辆的横向运动和纵向运动。
此时，不再把横向位置d作为t的函数，而是作为s的函数。
Cost函数也调整为:
其中：
2.2 纵向轨迹生成 论文中将纵向轨迹的优化场景大致分成如下三类：
2.2.1 Following、Merging &amp; Stopping 纵向轨迹考虑车辆乘坐的舒适性，车辆到达目标位置的时间，并对纵向的长距离进行惩罚。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21ca224eb3850c2c16c732f2b6a4e5b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/925be0b0ed08cb7542f0b563e08a65ca/" rel="bookmark">
			[Java] 序列化（Serialization）的本质是什么？在Java中怎么实现？为什么要了解序列化技术？序列化技术选型要点是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言序列化是什么？理解对象在内存中是如何存储的数据在进程内存中的分布图数据被序列化之后在内存中的分布图 序列化/反序列化的本质？序列化在Java中的实现？1. JDK Serialization（不推荐使用）2. 第三方实现：Kryo3. 第三方实现：ProtoStuff 和 Protobuf 为什么要了解序列化技术？序列化技术选型要点补充：byte[] vs byte stream结语 前言 序列化是相对比较重要也比较简单，但也比较容易被忽视的一类基础性知识。序列化在网络应用特别是如今的分布式系统中被大量使用，理解好序列化是理解好网络应用以及分布式系统架构的基础。笔者将通过本文去介绍序列化是什么、以及Java中的实现及选型的技术要点。
序列化是什么？ 序列化，英：Serialization。序列化的定义非常简单，维基百科定义截图如下：
用白话来讲就是：把应用进程中的数据（数据结构或对象） 里的信息给转换成 可以进行IO的格式。
进一步解释的话：
应用进程中的数据（数据结构或对象）：在应用内存中数据通常是以散乱分布加指针的方式组织起来的。可以进行IO的格式：这个一般我们认为是字节数组（byte[]）。 序列化就是把在内存中散乱分布的信息（数据），把它们收集起来转换成一个byte数组来表示，并且这个过程是可逆的。那么这个数据收集和转换的过程就被称为序列化，逆向处理呢，则被称为反序列化（deserialization）
这么说可能依然难以理解，笔者会在接下来的几个章节中提供图例供大家参考。
理解对象在内存中是如何存储的 对于大部分OOP语言来说，其内部的可以说所有 实例都由两部分（对象头和对象体） 组成，它们在内存中是紧密连续排列的。对象体中原生数据类型（primitive data type）不是指针，意味着在对象的内存中能直接看到对应的原生数据类型的数据，引用类型（reference data type）则是表现为一个指针（根据jvm的具体情况可以使4字节或8字节来存储），其包含的信息是另一个对象的内存地址。
也正是因为指针，让我们的数据其实在内存中是分布在多处被存储起来的，所以需要序列化技术把这些分散的数据集中起来，用 连续的字节（byte[]） 表示。
当然笔者上面提到的知识点都是非常常规的理解，在Java里对象存储的时候还会有属性对齐（alignment）这种处理，本文不做详细讨论，如果有兴趣的读者可以去阅读这篇文章：《Memory Layout of Objects in Java》，这篇文章中的jol-core库在笔者验证java内置锁的几种状态时帮了大忙，十分推荐去看其Sample代码。
数据在进程内存中的分布图 在上一节我们解释了Java对象在内存中的构造，本章我们用代码和图文的去理解一下数据究竟是如何在进程内存中分布的。假设我们有这样的一个UserInfo类，包含username和uid两个属性。
然后呢我们有这个类的实例如下：姓名张三，id是1。
UserInfo userInfo = new UserInfo("张三", 1); 那么这个实例在内存中则是长这样：
红框里，第一个Object Header的地方代表着张三这个UserInfo实例，第二个Object Header的地方代表着"张三"这个String实例。不难看出一个对象实例若是有引用类型，其数据通常是分散存储在堆内存的各个地方。物理上就是分散的，不是连续的。
数据被序列化之后在内存中的分布图 上一节我们用图和代码的方式介绍了，对象数据在堆内存中的分布。这一节我们去看一下序列化处理后的数据在内存中长什么样。参考下图：
红框里呢，就是我们序列化处理之后的结果了，简单来说对象序列化后的结果是一个byte[]，也就是字节数组，Java中数组也是一个对象实例。所以你能在上图中看到Object Header，后面紧跟一串byte，代表着序列化后的字节数据。此时，因为我们对象的所有信息都被集中起来了，所以可以把这些数据通过文件IO持久化到本地文件中，也可以通过网路IO发送至远端服务器上的进程里去处理。
相信到这里，基本上我们都能很清晰的认识到序列化到底是在干什么了。那么反序列化其实也同理，只不过这个过程的输出输入和序列化是反着的而已。
序列化/反序列化的本质？ 上一章节我们介绍了数据的序列化反序列化的本质就是一个数据转换（Mapping）的一个过程，那么不计成本地实现起来其实就很简单了。
只要你能有一套方案（算法或处理数据的方式）能够让对象实例和byte[]实现相互转换，那么这其实就是一种序列化的实现方式。只不过和JVM、哈希方法一样，可以有众多不同公司、组织的实现，不同实现的性能和特性也是有区别的，这个我们放到后面章节：《序列化技术选型要点》里讲。
就比如你甚至可以这么实现：
序列化：对象实例 ⇒ JSON对象 ⇒ JSON字符串 ⇒ byte[]反序列化：byte[] ⇒ JSON字符串 ⇒ JSON对象 ⇒ 对象实例 虽然这种实现性能会很低，但是不可否认的是这种做法也是一种序列化和反序列化的实现。笔者仅希望大家理解序列化/反序列化的本质就是数据互相转换的一个过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/925be0b0ed08cb7542f0b563e08a65ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b7d982d13d36d53e3fe8e1046683c74/" rel="bookmark">
			2022_SPIC_FANet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Feature aggregation network for RGBD saliency detection 1. 动机 如何将RGB和Depth充分挖掘和融合仍是一个关键问题。
第一个问题是如何从深度图中充分挖掘几何信息，从而可以可靠地反映场景的空间结构。
第二个问题是如何有效地融合外观信息和几何信息，即有效的RGB和深度特征，其中RGB图像和深度图的内在属性存在很大差异。
2. 方法 提出FANet,主要包括两个部分
1. 特征提取模块（非对称架构）
2. 特征聚合模块（主要特点），由两部分组成：REM（区域增强模块），HFM（分层融合模块）
REM（区域增强模块）：用于区分显著目标和背景
HFM（分层融合模块）：用于逐步整合高级语义信息和低级空间细节，其中K最近邻图神经网络 (KGNNs) 和非局部模块 (NLM) 嵌入HFM中，以分别挖掘几何信息并增强高级外观特征。
3. 网络框架 KGNN（K最近邻图神经网络）：充分挖掘几何信息。
NLM（非局部模块）：获取全局语义特征。
为什么深度分支只有3层？
深度数据包含更丰富的空间位置信息，并且通常被视为RGBD显着性检测的辅助组件。同时，浅层的深层特征通常传达空间信息，而深层特征则呈现丰富的语义信息。因此，我们的模型部署了浅层结构来提取深度特征，这足以使depth branch从深度图中获取空间线索。
3.1 REM（区域增强模块） REM作用：初步融合，大致定位显著目标并融合跨模态特征。
具体过程：针对于提取前三层的RGB和深度特征
1. 元素求和：用于初步融合。
2.sigmoid激活函数：将特征值范围映射为从0-1。
3.做大池化：特征选择。
4.反向最小池化：突出非显著区域。（“-”表示反向操作）
以上操作的作用：能够更加关注显著对象和背景
5. FFG和FBG元素求和：得到关注引导特征 𝐅𝐴，它充当注意力图，分别突出显示显著目标和抑制非显著区域。
6.将特征𝐅𝐼𝐷 𝑖 与 特征 𝐅𝐴 相乘再相加：得到深度特征𝐅𝑅𝐸 𝑖，关注显著对象，同时保留原始信息。
REM使模型能够产生更准确的显着性预测结果，因为它不仅可以增强显着对象，而且可以有效地抑制非显着区域。 3.3 KGNNs (K-最近邻图神经网络) 重点是为了充分挖掘几何信息.。。。。。。。（不太关注省略）
3.4 HFM (分层融合模块) 具体地，图3所示的HFM是基于池化的结构，它引入了多尺度体系结构，并以粗到精的方式集成了多级深度特征。 图2中，HFM 𝑖 (𝑖 = 2, 3，4) 努力对HFM(𝑖 +1)的输出进行据聚合 （意思就是第4层聚合第5层，第3层聚合第4层，第2层聚合第3层），jX 表示上采样与 同样空间大小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b7d982d13d36d53e3fe8e1046683c74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d52595715ccde03d68bac10762b0c1a/" rel="bookmark">
			在Ubuntu终端使用mkdir创建文件夹后Xftp不能上传文件到文件夹中的问题解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 在Ubuntu终端上使用mkdir创建文件夹后使用Xftp上传文件失败
原因分析： 权限问题
解决方案： chmod 777 File
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ddb482c73fa2d269d60c35f3368c37e/" rel="bookmark">
			神经网络与深度学习 作业12：第七章课后题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
习题7-1 在小批量梯度下降中，试分析为什么学习率要和批量大小成正比
习题7-2 在Adam算法中，说明指数加权平均的偏差修正的合理性 习题7-9 证明在标准的随机梯度下降中，权重衰减正则化和​编辑正则化的效果相同.并分析这一结论在动量法和Adam算法中是否依然成立 第七章总结
习题7-1 在小批量梯度下降中，试分析为什么学习率要和批量大小成正比 在小批量梯度下降中：
令,则: 因此为参数最优的时候的常数，学习率和批量大小成正比。
习题7-2 在Adam算法中，说明指数加权平均的偏差修正的合理性 在Adam算法中：
因此当的时候：
由此可以发现此时的梯度消失，因此需要进行偏差修正。
习题7-9 证明在标准的随机梯度下降中，权重衰减正则化和正则化的效果相同.并分析这一结论在动量法和Adam算法中是否依然成立 L2正则化梯度更新的方向取决于最近一段时间内梯度的加权平均值。
当与自适应梯度相结合时（动量法和Adam算法），
L2正则化导致导致具有较大历史参数 (和/或) 梯度振幅的权重被正则化的程度小于使用权值衰减时的情况
第七章总结 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b83d835575ad5d879719003cd611006d/" rel="bookmark">
			DC-UNet: Rethinking the U-Net Architecture with Dual Channel Efficient CNN for Medical Images Segmen
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DC-UNet 1 Main Contribution2 Datasets3 Data Augment4 Initialization5 Comparison Range6 Measurement metric7 Results of Comparison7.1Results of infrared breast images7.2 Results of electron microscopy image7.3 Results of endoscopy image 8 Conclusion9 Core Ways 1 Main Contribution Designed efficient CNN architecture to replace encoder and decoderapplied residual module to replace skip connection between encoder and decoder to improve based on state-of-art U-Net model 2 Datasets In-house IR breast dataset contains 450 infrared images from 14 patients and 16 healthy volunteers； resolution is 256*128EMdataset is 2D EM(电子显微镜图像，公有)：contains 30 images in its training set from a serial section Transmission Electron Microscopy （ssTEM） of the Drosophila(果蝇幼虫EM图像)， resolution is 256*256； Use 5-Fold cross-validationEndoscopy images(内窥镜图像 公有): CVC-ClinicDB dataset extracte from the colonoscopy(结肠镜检查)， contains total 612 images; resolution is 128*96 3 Data Augment convert 16-bit to 8-bit and resize 256*128 for thermography breast databaseresize 256*256 for other databases 4 Initialization All convolutional layers are activated by ReLUEach ReLU later use batch normalizationFinal output layer activated by SigmoidUse binary cross-entropy as loss functionUse Adam optimizer with the parameter 𝛽1 = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b83d835575ad5d879719003cd611006d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36cf91b1388526317f05cc34e463e867/" rel="bookmark">
			使用PostGreSQL数据库进行text录入和text检索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中文分词 ChineseParse.cs using System; using System.Collections; using System.IO; using System.Text.RegularExpressions; namespace FullTextSearch.Common { /// &lt;summary&gt; /// 中文分词器。 /// &lt;/summary&gt; public class ChineseParse { private static readonly ChineseWordsHashCountSet _countTable; static ChineseParse() { _countTable = new ChineseWordsHashCountSet(); InitFromFile("ChineseDictionary.txt"); } /// &lt;summary&gt; /// 从指定的文件中初始化中文词语字典和字符串次数字典。 /// &lt;/summary&gt; /// &lt;param name="fileName"&gt;文件名&lt;/param&gt; private static void InitFromFile(string fileName) { string path = Path.Combine(Directory.GetCurrentDirectory(), @"..\..\Common\", fileName); if (File.Exists(path)) { using (StreamReader sr = File.OpenText(path)) { string s = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36cf91b1388526317f05cc34e463e867/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cdf1d696c3f4945df4c513e708d127e/" rel="bookmark">
			【精选】前端JS面试题35个
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问：什么是匿名函数?作用是什么?
答：没有名字的函数就是匿名函数，作用有三，把函数当作变量赋值，把函数当作参数(回调函数)，把函数当作另一个函数的返回值(闭包)
2.什么是回调函数?为什么需要回调函数?
答：一个被当作函数参数的函数，在不打开第三方函数的情况下实现完整功能，就需要回调函数
3.什么是立即执行函数?为什么需要立即执行函数?
答：此概念只针对匿名函数，即函数在定义阶段就可以直接运行，当我们希望一个函数只执行一次，执行完之后立马销毁，就需要立即执行函数了
4.立即执行函数的写法
(function (){}())
(function (){})()
5.什么是作用域链?
答：父子函数嵌套时，不同变量在不同作用域的使用权限就是作用域链，子函数可以访问父函数的所有变量，父函数无法访问子函数的变量
6.什么是闭包?为什么需要闭包?
答：函数嵌套函数就是闭包，被嵌套的函数叫闭包函数，全局变量会破坏函数的独立性，既要实现功能又不能破坏函数独立性，就需要闭包
7.简述闭包的写法
父函数嵌套子函数，在父函数内部声明局部变量，子函数操作该局部变量并return，将子函数作为父函数的返回值，在全局声明变量接收该返回值，就形成了闭包
8.闭包的作用是什么?
函数外部可以返回函数内部的变量，实现属性私有化和模块化开发
9.闭包的缺陷是什么?
闭包会延长局部变量的生命周期，打破垃圾回收机制，大量使用闭包会导致内存泄漏
10.什么是柯里化函数?柯里化的核心思想是什么?
答：一个函数，只有一个参数，并且返回值是一个函数的函数。对函数参数的自由处理，让函数更加灵活，降低了通用性，提升了特定性
11.什么是this?作用是什么?分几种情况?
答：this是函数对象的内置对象，其作用域在函数内部。
this出现在事件体内，指向触发该事件的元素本身
this出现在普通函数内(除了事件体和构造函数)，代表调用该方法的元素本身
this出现在构造函数内，指向new出来的空间
this出现在箭头函数内，指向其父级的前缀
12.什么是类?什么是对象?
答：类是将具有相同属性和行为的对象归纳为一个类型，是一个模板，抽象不存在的；对象是类的实例化，携带了类的属性和方法，真实存在且唯一
13.什么是原型对象?作用是啥?
答：原型对象prototype是对象的一个属性，可以理解成一个存储空间，类的对象将具有相同内容的属性和方法存储到这个空间里，供其实例化对象访问和使用，大大减少代码量，降低内存消耗
14.什么是arguments?作用是什么?
答：实参列表，是函数对象的内置对象，作用域在函数内部，arguments的返回值是一个伪数组，只能访问元素和长度，其他API无法使用。作用有二，可以设置不定参函数，arguments.callee代表函数本身，常用于递归函数
15.为什么子类的实例对象可以访问到子类的所有属性和方法，以及父类的所有属性和方法?
答：所有实例对象在创建的过程中自带__proto__属性，指向类的原型对象prototype，所以可以访问类的原型上的属性和方法，类在构造对象的时候new出了空间，类的实例对象可以直接访问自己new出空间的属性和方法。
子类的原型对象指向父类的实例对象，子类的实例对象可以访问父类构造对象时new出的属性和方法，子类的实例对象通过父类实例对象的__proto__可以访问父类原型上的的属性和方法
16.apply/call/bind的区别是什么?
答：三者都是函数对象的内置方法，用来修改this指向。apply和call用来修饰有名函数，bind用来修饰匿名函数。apply的第二个参数必须是数组，call和bind的参数用逗号隔开。apply和call都是直接调用方法，bind会产生新的函数对象
17.面向对象的编程思想包括哪些?
答：封装、继承、多态
18.什么是封装的思想?
答：将若干个属性和方法封装成一个整体变成一个对象，通过对象调用这些属性和方法
19.什么是继承?
答：子类吸收父类已有的属性和方法，提升了代码的复用性(ES6类的方法直接绑定在原型对象上)
18.什么是多态?
答：在面向对象的过程中，有一种极致的复用性叫多态，降低了类和函数的耦合性，实现了类和函数的解耦
20.ES5继承都有哪些模式?
答：三种模式，原型继承、借用构造方法继承(apply和call)、混合继承
21.混合继承是怎么实现的?
答：混合继承是原型继承和借用构造方法继承合二为一的继承模式，在混合继承中，原型继承是子类继承父类prototype上的属性和方法，借用构造方法继承是子类继承父类new出空间的属性和方法
22.什么是原型继承?
答：通过原型对象实现继承
23.原型继承的缺陷有哪些?
答：子类对象构造时，无法初始化父类派生给子类的属性，一旦实现继承关系，继承指向就不能修改，必须先实现继承关系才能为子类添加原型属性和方法
24.借用构造方法继承的作用和缺陷是什么?
答：可以实现子类对象构造时，初始化父类派生给子类的属性，缺陷是无法继承父类原型对象上的属性和方法
25.instanceof是什么?和typeof的异同点是什么?
答：instanceof是判断引用类型的关键字，返回值是布尔值，如果A对象是B类型的，返回true，反之返回false。二者都是判断数据类型的关键字，typeof只能判断基本类型，无法判断引用类型，若判断引用类型返回Object，instanceof能够判断引用类型，且满足兼容性规则(高版本兼容低版本，低版本不兼容高版本)
26.内置基本类型和内置引用类型在存储上的区别是什么?
答：内置基本类型只有一块栈空间，里面存储的是数值，内置引用类型有栈和堆，栈里面存的是堆空间的地址，堆空间里存的是真实的内容
27.什么是值传递?什么是引用传递?
答：值传递是将栈里面的数值当作实参传递，单向传递，形参无法改变实参，需要返回值。引用传递是将栈空间里面的地址当作实参传递，形参和实参指向同一地址，形参能够改变实参堆空间的内容，双向传递，无需返回值
28.简述深浅拷贝
答：深浅拷贝是针对引用类型的概念，深浅拷贝本质区别是有没有开辟空间，浅拷贝只拷贝地址，不开辟空间，一改全改，深拷贝是既拷贝地址也开辟空间，各改各的
29.什么是单例类?怎么实现?有什么作用?
答：一个类只能创建一个对象，就是单例类。当这个类没有对象的时候，就创建一个对象，如果这个类已经有了一个对象，则无法继续创建对象，保持该类的对象永远有且只有一个。可以方便在整个项目之间传递共享数据
30.简述观察者模式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cdf1d696c3f4945df4c513e708d127e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6df16298fb51b783cdafc072414da62b/" rel="bookmark">
			docker-compose 配置rocketmq
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker-compose 配置rocketmq 操作步骤 1.拉取rocketmq镜像 dockerhub地址：https://hub.docker.com/u/library
拉取apache/rocketmq和styletang/rocketmq-console-ng两个即可
2.配置docker-compose.yml配置文件 docker-compose.yml文件配置
version: '3' services: rmqnamesrv: image: apache/rocketmq:4.9.4 container_name: rmqnamesrv ports: - 9876:9876 volumes: - F:\docker-install-path\native_volume\rocketmq\server\logs:/opt/rocketmq/logs - F:\docker-install-path\native_volume\rocketmq\server\store:/opt/rocketmq/store command: sh mqnamesrv networks: rmq: aliases: - rmqnamesrv rmqbroker: image: apache/rocketmq:4.9.4 container_name: rmqbroker ports: - 10909:10909 - 10911:10911 volumes: - F:\docker-install-path\native_volume\rocketmq\broker\broker-logs:/opt/rocketmq/logs - F:\docker-install-path\native_volume\rocketmq\broker\broker-store:/opt/rocketmq/store - F:\docker-install-path\native_volume\rocketmq\broker\config\broker.conf:/opt/rocketmq-4.3.2/broker.conf environment: NAMESRV_ADDR: "rmqnamesrv:9876" JAVA_OPTS: "-Duser.home=/opt" JAVA_OPT_EXT: "-server -Xms128m -Xmx128m -Xmn128m" command: sh mqbroker -c /opt/rocketmq-4.3.2/broker.conf depends_on: - rmqnamesrv networks: rmq: aliases: - rmqbroker rmqconsole: image: styletang/rocketmq-console-ng:1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6df16298fb51b783cdafc072414da62b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef8f965208eb79d2355776bcd7a0fa10/" rel="bookmark">
			springboot集成mongodb的基础功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引入依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; 二、自定义配置MongoTemplate
@Configuration public class MongodbConfig { @Value("${spring.data.mongodb.host}") private String host; @Value("${spring.data.mongodb.port}") private int port; @Value("${spring.data.mongodb.database}") private String database; @Bean public MongoTemplate myCongoTemplate() { ServerAddress serverAddress = new ServerAddress(host, port); //用户名、密码 登录验证 // MongoCredential mongoCredential = MongoCredential.createCredential("username", // "databaseName", "password".toCharArray()); // List&lt;MongoCredential&gt; credentials = new ArrayList&lt;&gt;(); // credentials.add(mongoCredential); // MongoClientOptions.Builder builder = new MongoClientOptions.Builder(); // MongoClientOptions mongoClientOptions = builder.build(); MongoClient mongoClient = new MongoClient(serverAddress); SimpleMongoDbFactory mongoDbFactory = new SimpleMongoDbFactory(mongoClient, database); MongoTemplate mongoTemplate = new MongoTemplate(mongoDbFactory); return mongoTemplate; } public String getHost() { return host; } public void setHost(String host) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef8f965208eb79d2355776bcd7a0fa10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74bc847d9050e61710eaf4973f3d5c05/" rel="bookmark">
			液晶LCD1602使用介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		液晶LCD1602简介
LCD1602液晶也叫1602字符型液晶模块，LCD1602液晶是一种专门用来显示字母、数字、符号的点阵型液晶模块。LCD1602液晶是由若干个5x7点阵字符位组成，每个点阵字符位都可以显示一个字符（包括字母、数字、符号），一共可以显示16x2个字符。LCD1602液晶的每位之间都有一个点距的间隔，每行之间也都有间隔，起到字符间距和行间距的作用。LCD1602液晶只能显示字符（包括字母、数字、符号），不能显示图片。
LCD1602液晶模块具有体积小,功耗低等优点。在各种工业设备、家用电子产品、仪器仪表、嵌入式系统等场合都有非常广泛的应用。
液晶LCD1602技术参数
液晶LCD1602管脚说明
LCD1602液晶模块各管脚的功能介绍如下：
1、LCD1602液晶的管脚1：VSS接5V电源负极，即GND。
2、LCD1602液晶的管脚2：VDD接5V电源正极。
3、LCD1602液晶的管脚3：VL为液晶的显示偏压信号，用于对液晶显示对比度调整，接电源正极时对比度最弱，接地时对比度最高。对比度过高时会产生“鬼影”现象，导致液晶显示的字符不清晰。我们可以通过使用一个10kΩ的电位器来调整对比度。
4、LCD1602液晶的管脚4：RS为液晶的寄存器选择脚，该管脚为高电平时选择数据寄存器，该管脚为低电平时选择指令寄存器。
5、LCD1602液晶的管脚5：R/W为读/写选择管脚，当该管脚为高电平时进行读操作，当该管脚为低电平时进行写操作。
a 当RS和R/W管脚都为低电平时可以写入指令或显示地址。
b 当RS管脚为低电平，R/W管脚为高电平时，可以读忙信号。
c 当RS管脚为高电平，R/W管脚为低电平时，可以写入数据。
6、LCD1602液晶的管脚6：E管脚为使能端，当E管脚由高电平跳变为低电平时，液晶模块执行命令。
7、LCD1602液晶的管脚7～14：D0～D7为液晶8位双向数据线。
8、LCD1602液晶的管脚15：液晶模块背光源正极。
9、LCD1602液晶的管脚16：液晶模块背光源负极。
液晶LCD1602指令
​
​液晶LCD1602时序
读操作时序
​
写操作时序
​
时序参数
​
液晶LCD1602初始化过程
1、延时15ms。
2、写指令38H（不检测忙信号）。
3、延时5ms。
4、写指令38H（不检测忙信号）。
5、延时5ms。
6、写指令38H（不检测忙信号）。
（以后每次写指令、读写数据操作之间均需检测忙信号）。
7、写指令38H：显示模式设置。
8、写指令08H：显示关闭。
9、写指令01H：显示清屏。
10、写指令06H：显示光标移动设置。
11、写指令0CH：显示开及光标设置。 液晶LCD1602例程 /****************LCD驱动基本代码***************** *单片机型号：STC89C52RC，晶振频率：11.0592M *开发环境：KEIL *说明：LCD1602显示字母、数字、符号。 ******************************************************/ #include&lt;reg52.h&gt; #include&lt;intrins.h&gt; #define LCD_Data P0 #define Busy 0x80 sbit LCD_RS = P1^0; sbit LCD_RW = P1^1; sbit LCD_E = P2^5; unsigned char code welcome[] = {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74bc847d9050e61710eaf4973f3d5c05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf132d45a1cd6f3f0465684503c2ff87/" rel="bookmark">
			2022-04-06 RK3566 上调试百兆以太网卡YT8512C 调试记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、原理图
二、dts
&amp;gmac1_clkin{ clock-frequency = &lt;50000000&gt;; status = "okay"; }; &amp;gmac1 { phy-mode = "rmii"; clock_in_out = "input"; snps,reset-gpio = &lt;&amp;gpio4 RK_PC2 GPIO_ACTIVE_LOW&gt;; snps,reset-active-low; snps,reset-delays-us = &lt;0 20000 100000&gt;; assigned-clocks = &lt;&amp;cru SCLK_GMAC1_RX_TX&gt;, &lt;&amp;cru SCLK_GMAC1&gt;; assigned-clock-parents = &lt;&amp;cru SCLK_GMAC1_RMII_SPEED&gt;, &lt;&amp;gmac1_clkin&gt;; pinctrl-names = "default"; pinctrl-0 = &lt;&amp;gmac1m0_miim &amp;gmac1m0_clkinout &amp;gmac1m0_rx_bus2 &amp;gmac1m0_tx_bus2 &amp;gmac1m0_rx_er&gt;; phy-handle = &lt;&amp;rmii_phy1&gt;; status = "okay"; }; &amp;mdio1 { rmii_phy1: phy@0 { compatible = "ethernet-phy-ieee802.3-c22"; reg = &lt;0x0&gt;; }; }; 三、dts配置有问题的会有下面的error提示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf132d45a1cd6f3f0465684503c2ff87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d58ba36c0f4d77cde01edb2c61294a40/" rel="bookmark">
			koa项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.koa起步 1.项目初始化 执行 npm init -y ,生成 package.json
npm init -y 2.安装koa 执行命令
npm install koa 3.编写基本app 创建 src/main.js
//1.导入koa包 const Koa = new require("Koa"); //2。实例化app对象 const app = new Koa(); //3.编写中间件 app.use((ctx, next) =&gt; { ctx.body = "hello,koa!" }) //4.启动服务器 app.listen(3000,()=&gt;{ console.log("server is running on http://localhost:3000"); }) 4.测试 在终端使用 node src/main.js
二.项目的基本优化 1.自动重启服务 安装 nodemon
npm install nodemon -D 编写 package.json 修改启动文件
"scripts": { "dev":"nodemon ./src/main.js", "test": "echo \"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d58ba36c0f4d77cde01edb2c61294a40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/774ea8753b78ec839a8a33ab6243c6d1/" rel="bookmark">
			神经网络与深度学习（八）网络优化与正则化（3）不同优化算法比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
7.3 不同优化算法的比较分析
7.3.1 优化算法的实验设定
7.3.1.1 2D可视化实验 7.3.1.2 简单拟合实验 7.3.2 学习率调整
7.3.2.1 AdaGrad算法 7.3.2.2 RMSprop算法 7.3.3 梯度估计修正 7.3.3.1 动量法 7.3.3.2 Adam算法 7.3.4 不同优化器的3D可视化对比 7.3.4.1 构建一个三维空间中的被优化函数 【选做题】
参考资料
7.3 不同优化算法的比较分析 除了批大小对模型收敛速度的影响外，学习率和梯度估计也是影响神经网络优化的重要因素。神经网络优化中常用的优化方法也主要是如下两方面的改进，包括：
学习率调整：主要通过自适应地调整学习率使得优化更稳定。这类算法主要有AdaGrad、RMSprop、AdaDelta算法等。梯度估计修正：主要通过修正每次迭代时估计的梯度方向来加快收敛速度。这类算法主要有动量法、Nesterov加速梯度方法等。 除上述方法外，本节还会介绍综合学习率调整和梯度估计修正的优化算法，如Adam算法。
7.3.1 优化算法的实验设定 为了更好地对比不同的优化算法，我们准备两个实验：第一个是2D可视化实验。第二个是简单拟合实验。首先介绍下这两个实验的任务设定。
7.3.1.1 2D可视化实验 为了更好地展示不同优化算法的能力对比，我们选择一个二维空间中的凸函数，然后用不同的优化算法来寻找最优解，并可视化梯度下降过程的轨迹。被优化函数 选择Sphere函数作为被优化函数，并对比它们的优化效果。Sphere函数的定义为：
其中，表示逐元素平方。Sphere函数有全局的最优点。
这里为了展示方便，我们使用二维的输入并略微修改Sphere函数，定义，并根据梯度下降公式计算对的偏导
其中⊙表示逐元素积。
将被优化函数实现为OptimizedFunction算子，其forward方法是Sphere函数的前向计算，backward方法则计算被优化函数对xx的偏导。代码实现如下：
from nndl.op import Op import torch import numpy as np from matplotlib import pyplot as plt class OptimizedFunction(Op): def __init__(self, w): super(OptimizedFunction, self).__init__() self.w = w self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/774ea8753b78ec839a8a33ab6243c6d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97df0a668ab40ba2545571208524e743/" rel="bookmark">
			⚡文件工具类⚡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🌳.文件工具类的介绍
🌳.文件工具类的功能简介
🌳.stat接口
🍎. 获取文件的大小
🍎.判断文件是否存在
🍎.获取文件最后一次进入时间
🍎.获取文件最后一次修改时间
🌳.获取文件名
🌳.获取文件的内容
🌳.往文件中写入内容
🌳.获取目录下所有文件的相对路径
🌳.压缩文件
🌳.解压文件
🌳.删除文件
🚀.Json工具类
🌳.文件工具类的介绍 文件工具类主要是创建一个文件对象将磁盘上的一个文件关联起来，方便对该文件进行操作和获取文件的信息等操作，包括获取文件的内容，文件的大小，文件的访问时间，往文件中写入内容等操作。
🌳.文件工具类的功能简介 获取文件的大小判断文件是否存在获取文件最后一次进入时间获取文件最后一次修改时间获取文件名获取文件名获取文件的内容往文件中写入内容获取目录下所有文件的相对路径压缩文件解压文件删除文件 文件的 成员变量是filename，它存储程序能够访问到文件的相对路径和绝对路径,通过filename能够对文件进行各种操作。
class FileUtil{ private: std::string filename; public: FileUtil(const char* str){ filename=str; } FileUtil(const std::string s){ filename=s; } size_t GetFileSize(); //获取文件大小 size_t GetFileAccessTime() ;//获取文件最后一次访问时间 size_t GetFileModfityTime();//获取文件最后一次修改时间 std::string GetFilename(); //获取文件名 bool Exist(); //判断文件是否存在 bool SetContent(std::string&amp; body);//往文件中写入body的内容 bool GetContent(std::string&amp; body);//获取文件内容，将文件内容放入body中 //获取文件的部分内容 bool GetPosContent(size_t pos,size_t n,std::string&amp; body); bool Remove();//删除文件 //压缩文件，压缩文件名为packname bool PackFile(const std::string&amp;packname); //解压缩文件，解压缩文件名为packname bool UnpackFile(const std::string&amp; unpackname); //获取目录下的所有文件的相对路径 bool GetPathInDir(std::vector&lt;std::string&gt;&amp; arry); //创建目录 bool CreateDir(std::string&amp; dirname); }; 🌳.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97df0a668ab40ba2545571208524e743/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9e8586ecd97fd8c4f910d00d0a18731/" rel="bookmark">
			CSS 实现居中的五种方法，以及十种现代布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		感谢 chatGPT 的回答：
使用 margin: 0 auto 实现居中：.centered-element { margin: 0 auto; } 使用 text-align: center 实现居中：.centered-element { text-align: center; } 使用 flex 布局实现居中：.centered-element { display: flex; justify-content: center; align-items: center; } 使用 absolute 定位实现居中：.centered-element { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } 使用 grid 布局实现居中：.centered-element { display: grid; justify-content: center; align-items: center; /* place-items: center; /* 上面两句可以用这一句替换 */ } 甜点：如何用一行 CSS 实现 10 种现代布局
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1ba8c1b9cf61fcda281791f0d627f12/" rel="bookmark">
			新项目如何推送Git
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、在git新建一个空的仓库，不用任何模版，直接创建即可
完成后，copy仓库地址
二、本地新建项目，进入到本地项目命令行，也可以打开终端，其实是相通的：执行命令git init，
此时在项目上右击就发想有git选项，点击add添加，接着正常commit，然后push
在push的时候会发现有一个push定义，点击进去，写入刚刚的git仓库地址，提交即可；
原文：idea新项目上传git_weixin_43667193的博客-CSDN博客_idea新项目上传git 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cca574b80ba3225991e9388087a22bb8/" rel="bookmark">
			python.txt文件的写入和追加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python 文件操作经过三个步骤：文件打开、文件读取、文件关闭。文件读取可分为：读取和写入
文件打开：f = open（文件路径，{r（读）、w（写）、a（追加）}，文件类型）
例如：在D盘根目录写入一个名为test的txt文件并把它赋值给 f
f = open("D:/test.txt","w",encoding = "utf - 8") 给文件test写入内容：为Hello World，我是python
f.write("Hello World，我是python") 注意：“w” 写入操作这里，并不是真正的写入文件内存位置，而是先写在文件某处的缓存空间，通过 “flush”或者“close” 刷新或者关闭文件，才会将内容真正的写入。
例如：
第一步： D:\ 盘中没有存在名为 test.txt 文件，我们通过 “w”方法创建一个名为test.txt 文件。
but test.txt 里面却没有内容
这就说明了， 直接调用write，内容并未真正写入硬盘中，而是积攒在程序的内存中， 称之为缓冲区
我们通过给它加上 “flush”或者“close” 刷新或者关闭文件，这样就会真正的写入进去。
为什么 close（）关闭文件的方法也可以实现同样将内容写入真正的位置呢？
close() 是关闭文件的方法内置“flush”刷新功能，flush 刷新的功能是将内存中积攒的文件，写入到文件的硬盘中。
“w” 方法的追加还有另一个功能，如果你的电脑内存中存在一个名为test.txt文件，当你再一次进行调用 open 打开 write写入方法时，它会将你之前写入的全部内容全部清空，重新写入你本次写入的内容。
“a”文件内容追加操作： “a” 模式的追加操作，和 “w” 的写入操作在打开、写入、关闭 方法上是一致的，只是将“w”模式改为了“a”模式
#打开 f = open (r"D:\test1.txt","a",encoding="UTF-8") #写入 f.write("每天学习一点点，坚持取得大胜利") #关闭 f.close() D:\ 盘没有存在一个名为text1.txt 文件，我用“open” 方法进行了创建。
“a”模式的一个特性： 如果内存中不存在名为text1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cca574b80ba3225991e9388087a22bb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/018ebec03e359a5b2cd352bbc59178d7/" rel="bookmark">
			链表的回文结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回文结构相当于对称，所以要找到中间的那个点，这就用到了找链表中间点的方法（利用快慢指针的方法），不知道的可以去看看我之前发的博客。
struct ListNode* fast=head ,*slow=head; while ((fast != NULL) &amp;&amp; (fast-&gt;next != NULL)) { fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; } struct ListNode* mid=slow; 重新创建的变量mid就是链表中间结点
接下来就是要将mid之后的链表翻转过来：注意前面一个3对应的那个结点中next存放的是后一个3的地址，且后面一直没有改变
翻转链表的步骤之前也发过了，这里就不过多赘述了
tail = mid; tail = tail-&gt;next; struct ListNode* head2 = NULL; //head2,mid,tail相当于连续的三个结点 while (mid != NULL) { mid-&gt;next = head2; head2 = mid; mid = tail; if (tail != NULL) tail = tail-&gt;next; } 将链表翻转之后就变成这样了
接下来一一对应head1和head2所对应的值就好了
来看看具体代码：
bool isPalindrome(ListNode* head) { if (head == NULL) return false; struct ListNode* fast = head, * slow = head, * head1 = head, * tail = head; while ((fast !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/018ebec03e359a5b2cd352bbc59178d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7290cb6b53b67fd359781d32761a27de/" rel="bookmark">
			二叉树的前中后序遍历，层序遍历，BFS，DFS的递归和非递归实现(Python)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 二叉树中DFS分为前中后序遍历，DFS如果在图中，就没有前中后序遍历说法，如果在矩阵中，变化顺序就由上下左右随机组合了
二叉树中BFS和层序遍历又有些区别
二叉树定义 class TreeNode: def __init__(self, x, L=None, R=None): self.val = x self.left = L self.right = R 遍历的递归实现 深度遍历的运行过程是先进后出的，自然的方法是栈和递归
广度遍历的运行过程是先进先出的，自然的方法是队列
前序 class Solution(object): def dfs(self,root): """ 根-&gt;左-&gt;右 :type root: TreeNode :rtype: List[int] """ if not root: return print(root.val) dfs(root.left) dfs(root.right) 中序 class Solution(object): def dfs(self,root): """ 根-&gt;左-&gt;右 :type root: TreeNode :rtype: List[int] """ if not root: return dfs(root.left) print(root.val) dfs(root.right) 后序 class Solution(object): def dfs(self,root): """ 根-&gt;左-&gt;右 :type root: TreeNode :rtype: List[int] "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7290cb6b53b67fd359781d32761a27de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85d1a2455ed2c493327bd44e453179da/" rel="bookmark">
			[Spring5.3.2] Servlet[springmvc]的Servlet.init（）引发异常, 解析类文件失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring / Spring MVC遇到问题 找了一本spring相关的教材,书上的代码拿过来就能运行,自己写就总报HTTP 500错误,反复检查没有任何一处写错,同一个错误卡了我三天,非常郁闷,今天终于解决了.特此记录. 问题表现:
图中提到的问题:
例外情况
javax.servlet.ServletException: Servlet[springmvc]的Servlet.init（）引发异常
根本原因
org.springframework.beans.factory.BeanDefinitionStoreException: Failed to read candidate component class: file [D:\apache-tomcat-9.0.69\webapps\ch2_2\WEB-INF\classes\controller\IndexController.class]; nested exception is org.springframework.core.NestedIOException: ASM ClassReader failed to parse class file - probably due to a new Java class file version that isn’t supported yet: file [D:\apache-tomcat-9.0.69\webapps\ch2_2\WEB-INF\classes\controller\IndexController.class]; nested exception is java.lang.IllegalArgumentException: Unsupported class file major version 61
提到了无法解析这个类文件, 我看到这个类文件是存在的,后面提到了不支持类文件的主版本61, 61对应的是jdk17
此工程使用的spring版本是5.3.2, 教材的开发环境是eclipse自带的java 15; 而我此次运行的jdk版本是新版本eclipse自带的java 17, 我把compliance level改成15再次运行也不好使.
那么问题来了: 我用java 17, 运行教材的现有工程代码, 可以正常运行; 而自己创建一个工程, 代码和配置文件都相同,就是会出现http500的错误.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85d1a2455ed2c493327bd44e453179da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f945186669975f98f64eebdb439d851/" rel="bookmark">
			微信小程序第六篇：元素吸顶效果实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章传送门：
微信小程序第一篇：自定义组件详解
微信小程序第二篇：七种主流通信方法详解
微信小程序第三篇：获取页面节点信息
微信小程序第四篇：生成图片并保存到手机相册
微信小程序第五篇：页面弹出效果及共享元素动画
话不多说，先看效果：
这种效果在我们日常开发中是非常常见的，下面让我们结合代码一起来看看是如何实现的吧。
js 部分数据：
data: { content: { value: '啦啦啦', isShow: false }, message: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], mainHeight: app.globalData.wHeight - app.globalData.headerHeight }, wxml部分代码： &lt;template name="scrollData"&gt; &lt;view style="height: 100rpx; width: 90%;margin: 20rpx auto;background-color: rgb(172, 212, 219);"&gt; {{item}} &lt;/view&gt; &lt;/template&gt; &lt;view&gt; &lt;header bg="{{'transparent'}}"&gt;YinJie&lt;/header&gt; &lt;view style="height: 60rpx;width: 100%;background-color: pink;text-align: center;font-size: 22rpx;position: fixed;z-index: 999;" wx:if="{{content.isShow}}" &gt; {{content.value}} &lt;/view&gt; &lt;scroll-view class="" scroll-y="true" bindscroll="scroll" enable-flex="true" style="height: {{mainHeight}}rpx;"&gt; &lt;view style="height: 400rpx; width:90%; margin: 0 auto; background-color: grey"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f945186669975f98f64eebdb439d851/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/469ff597f889b5f31d1b243ed4ea43bb/" rel="bookmark">
			Java中的取整、四舍五入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、直接强制转换--取整
2、Java提供的函数
参考文献
1、直接强制转换--取整 public class temp { public static void main(String[] args) { System.out.println("正数：(int)10.12 = " + (int)10.12); System.out.println("负数：(int)-10.12 = " + (int)-10.12); System.out.println("---------------------------------"); System.out.println("正数：(int)1011111111111111111111.12 = " + (int)1011111111111111111111.12); System.out.println("负数：(int)-1011111111111111111111.12 = " + (int)-1011111111111111111111.12); } } 结果：
直接用强制转换的方式将浮点型数据转换为整型时，直接去掉小数点后部分的精度，取整数部分；直接强制取整有精度风险 一方面是小数位损失另一方面当浮点型数字超过整型数字最大值时，会发生溢出实际工程中，如果这两种因素都不会对工程产生影响，可以使用，否则不建议使用。 2、Java提供的函数 double Math.ceil(double num); Math.ceil(double num);函数是取浮点数的天花板数，即不小于num的最小整数；double Math.floor(double num); Math.floor(double num)函数是取地板数，即不大于num的最大整数。Math.round(double num); 参数的小数点后第一位&lt;5，运算结果为参数整数部分。参数的小数点后第一位&gt;5，运算结果为参数整数部分绝对值+1，符号（即正负）不变。参数的小数点后第一位=5，正数运算结果为整数部分+1，负数运算结果为整数部分。 参考文献 [ 1 ] Java基础知识点笔记（一）：java中的取整与四舍五入
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbdb3ee5abc236c2987becd2c8a1d2e1/" rel="bookmark">
			hive 将多列拼为json串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hive 将多列拼为json串 SELECT to_json(named_struct('a', 'b', 'c', 'd')) 输出结果：
{“a”:“b”,“c”:“d”}
支持null、list、map等多种格式
hive udf
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9484179abfbd326cde5f4d737bf6a1b4/" rel="bookmark">
			echarts地图数据GeoJson压缩、解码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一开始看到库里的json文件都很奇怪，跟加密了似的，后来发现每个都有UTF8Encoding的标识，查找相关资料发现，只有echarts能够解析这个标识，普通的网页并不能加载。最后整理出了加密和解密的算法供大家参考。压缩的能力很强大，基本大小可以缩小为原来的1/10.
压缩算法：
function encodePolygon(coordinate, encodeOffsets) { var result = ''; var prevX = quantize(coordinate[0][0]); var prevY = quantize(coordinate[0][1]); // Store the origin offset encodeOffsets[0] = prevX; encodeOffsets[1] = prevY; for (var i = 0; i &lt; coordinate.length; i++) { var point = coordinate[i]; result += encode(point[0], prevX); result += encode(point[1], prevY); prevX = quantize(point[0]); prevY = quantize(point[1]); } return result; } function encode(val, prev) { // Quantization val = quantize(val); // Delta val = val - prev; if (((val &lt;&lt; 1) ^ (val &gt;&gt; 15)) + 64 === 8232) { // 8232 will get syntax error in js code val--; } // ZigZag val = (val &lt;&lt; 1) ^ (val &gt;&gt; 15); // add offset and get unicode return String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9484179abfbd326cde5f4d737bf6a1b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6f84abdada9b3d8c586dce12859f22b/" rel="bookmark">
			C语言常用库函数总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 C语言常用计算的库函数 下面的所有用例的参数赋值：
int a = 2; int b = 4; int val = 0; 计算类函数声明在头文件#include&lt;math.h&gt;中；
1.1 pow() x的y次幂 函数原型：double pow(double _X,double _Y);
val = pow(a, b); // a的b次幂 printf("pow val = %d\n", val); // 16 1.2 sqrt() 计算平方根 函数原型：double sqrt(double _X);
val = sqrt(b); // 计算平方根 printf("sqrt val = %d\n", val); // 2 1.3 abs() 计算绝对值 函数原型：int abs(int _X);
val = abs(a - b); // 计算绝对值 printf("abs val = %d\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6f84abdada9b3d8c586dce12859f22b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0c1f242a158bdad347b9359605f416a/" rel="bookmark">
			Unity 加载图片的两种方式文件流和UnityWebRequest
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System; using System.IO; using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.Networking; using UnityEngine.UI; public class DemoTest : MonoBehaviour { string url = @"E:/simulator/Assets/Images/details/btn_go.png"; [SerializeField] private Image im; // Start is called before the first frame update void Start() { // Texture2D t = new Texture2D(1,1); // t.LoadImage(ReadTexture(url)); // Sprite spr = Sprite.Create(t, new Rect(0,0,t.width,t.height), new Vector2(10.0f,10.0f)); // im.sprite = spr; StartCoroutine(LoadTexture(url)); } // Update is called once per frame void Update() { } #region 方法一：通过文件流（System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0c1f242a158bdad347b9359605f416a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a6dda42e243890ea2b7ac3a478c8722/" rel="bookmark">
			从源码构建deb包的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接从debian/ubuntu/deepin/uos 这类已有debian化源码构建 开启系统的src源,或者手工浏览系统的源目录,使用apt source xxx 或者dget来获取debian化的源码。 apt source 方式
actionchen@actionchen-PC:~/deb-test$ apt source wget 正在读取软件包列表... 完成 需要下载 4,455 kB 的源代码包。 获取:1 https://professional-packages.chinauos.com/desktop-professional eagle/main wget 1.20.1-1.1 (dsc) [1,054 B] 获取:2 https://professional-packages.chinauos.com/desktop-professional eagle/main wget 1.20.1-1.1 (tar) [4,393 kB] 获取:3 https://professional-packages.chinauos.com/desktop-professional eagle/main wget 1.20.1-1.1 (diff) [60.9 kB] 已下载 4,455 kB，耗时 1秒 (3,430 kB/s) dpkg-source: info: extracting wget in wget-1.20.1 dpkg-source: info: unpacking wget_1.20.1.orig.tar.gz dpkg-source: info: unpacking wget_1.20.1-1.1.debian.tar.xz dpkg-source: info: using patch list from debian/patches/series dpkg-source: info: applying wget-doc-remove-usr-local-in-sample.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a6dda42e243890ea2b7ac3a478c8722/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a704e25268ec22d2289dc91919456ab/" rel="bookmark">
			MATLAB求解分段函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		采用方法 主要采用结构化编程利用if函数来编程。
注意要点 在编程的时候，会遇到很多并列条件，应该用&amp;&amp;字符隔开。
举个例子 clc clear x=input("请输入x的值,可以是单个数也可以是一个向量") n=size(x,2) i=1 while i&lt;=n if x(i)&lt;0&amp;&amp;x(i)~=-3 y(i)=x(i)^2+x(i)-6 elseif 0&lt;=x(i)&amp;&amp;x(i)&lt;5&amp;&amp;x(i)~=2&amp;&amp;x(i)~=3 %这里是有三个并列条件用&amp;&amp;隔开。 y(i)=x(i)^2-5*x(i)+6 else y(i)=x(i)^2-x(i)-1 end i=i+1; end 举个错误例子：
x=input('输入x') if x&lt;-1 y=3*x+2 elseif -1&lt;=x&lt;=1 y=x else y=2*x+3 end 注意：这块第二个条件-1&lt;=x&lt;=1这样是错误的，matlab对于这样的条件只会判断到-1&lt;=x
正确的做法应该是-1&lt;=x&amp;&amp;x&lt;=1。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43fe64cd96f3a5357b76a6b4f7f51b43/" rel="bookmark">
			网络设备驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 概念
2 网络设备驱动框架
2.1 体系结构
2.2 网络协议接口层
2.3 网络设备接口层
2.4 设备驱动功能层
2.4.0 net_device的生成和赋值
2.4.0 net_device的释放
2.4.1 网络驱动设备的注册与注销
2.4.2 网络设备初始化
2.4.3 网络设备的打开与释放
2.4.4 数据发送流程
2.4.5 数据接收流程
中断接收数据
NAPI 接收数据
2.4.6 网络连接状态
定时器初始化
2.4.7 参数设置和统计数据
2.5 网络设备与媒介层
3 套接字缓冲区--sk_buff
3.1 head、end与data、tail指针
3.1.1 数据包在各层之间传输时，data指针的变化
3.2 sk_buff数据区
3.2.1 包的形成和数据区的变化：
3.3 其他相关结构体
3.3.1 sk_buff_head结构体
3.3.2 skb_shared_info分片结构体
​编辑
3.3.3 分片结构体的数据区
3.4 skb操作函数
3.4.1 分配
3.4.2 释放
3.4.3 变更/指针移动
1 概念 网络设备是Linux的第三类标准设备，没有对应的设备文件，使用内部设备名访问。网络设备及其驱动属于整个TCP/IP协议层的一部分，实现遵循TCP/IP协议栈的要求。(网卡驱动属于网络接口层）。
网络设备异步接收外部的数据包，主动请求将硬件收到的数据包交给内核。
2 网络设备驱动框架 Linux网络设备驱动程序的体系结构自上往下分为四层：网络协议接口层、网络设备接口层、设备驱动功能层和网络设备与媒介层。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43fe64cd96f3a5357b76a6b4f7f51b43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19b23c65acfef3fd63f30c2c14d32d58/" rel="bookmark">
			java三年工作经验面试题整理《精华》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDK 和 JRE 有什么区别？
JDK：java 开发工具包，提供了 java 的开发环境和运行环境。
JRE：java 运行环境，为 java 的运行提供了所需环境。
JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具，如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。
== 和 equals 的区别是什么？
对于基本类型和引用类型 == 的作用效果是不同的：
基本类型：比较的是值是否相同； 引用类型：比较的是引用是否相同；
String x = "string";
String y = "string";
String z = new String("string");
System.out.println(x==y); // true
System.out.println(x==z); // false
System.out.println(x.equals(y)); // true
System.out.println(x.equals(z)); // true
两个对象的 hashCode()相同，equals()不一定 true。
在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。
final 在 java 中有什么作用？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19b23c65acfef3fd63f30c2c14d32d58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a697e8f790670c838be43758ca0fc774/" rel="bookmark">
			作为依赖库时，Package.json 重要字段总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为依赖库时，Package.json 重要字段总结 1. main 作为模块被别的程序导入时，模块的主入口，默认为根目录的 index.js 文件。
2. files 用于配置包发布时，所包含的内容，默认为[“*”]
3. type nonde执行时的模块类型，commonjs 或 module 默认为 commonjs
4. exports 在模块引用时，替代 main 入口，mian 入口只能导出单个文件，
1.exports 实现路径导出
// package.json "exports": { ".": "./index.js", "./submodule.js": "./src/submodule.js" } import submodule from 'es-module-package/submodule.js'; // Loads ./node_modules/es-module-package/src/submodule.js import submodule from 'es-module-package/private-module.js'; // Throws ERR_PACKAGE_PATH_NOT_EXPORTED 2.exports 实现条件导出
"exports": { ".": { "import": "./dist/my-lib.js", "require": "./dist/my-lib.umd.cjs" } } 5.module 用于打包工具的 Tree Shaking ，指向ESModule格式的打包文件
参考资料 https://nodejs.org/api/packages.html#type
https://docs.npmjs.com/cli/v9/configuring-npm/package-json#main
https://www.thinbug.com/q/40795836
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a697e8f790670c838be43758ca0fc774/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25dc28d166744824a911cd2e917ef2f3/" rel="bookmark">
			Windows 上安装 GeoScene Enterprise 2.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实操安装多次，总结安装过程中的参考文档如下：
Windows上安装ArcGIS Enterprise（ArcGIS 10.5为例）_豆脑就要吃咸的的博客-CSDN博客Windows上安装ArcGIS Enterprise（ArcGIS 10.5为例）_豆脑就要吃咸的的博客-CSDN博客
Geoscene Enterprise2.0安装步骤——以Win10 Pro为例_AriaGIS的博客-CSDN博客_geoscene enterprises统一证书
Windows单机环境下ArcGIS Enterprise 10.7.1的安装教程-以Windows Server 2012 R2操作系统为例_最后的精灵的博客-CSDN博客
安装过程中需要配置Java环境，参考如下：
Windows server2012配置enterprise10.8.1的Web_Adaptor_Java版安装详细教程_GIS哼哈哈的博客-CSDN博客
【转】Tomcat 9.0安装配置 - CSlunatic - 博客园
安装后在打开GeoScene Pro软件时，会出现弹窗需要点击确认；或者打开Enterprise网页时，需要输入用户名密码，可参考如下：
通过OpenSSL生成证书并让Chrome浏览器识别为安全终极办法_AriaGIS的博客-CSDN博客_openssl生成chrome信任证书
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a9a3931081052785cc6fb33bf70aac7/" rel="bookmark">
			C&#43;&#43;构造函数调构造函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++构造函数调构造函数 定义一个对象时，会按顺序做2件事情：
1）分配好内存（非静态数据成员是未初始化的）
2）调用构造函数（构造函数的本意就是初始化非静态数据成员）
有一个带参数的构造函数，当默认构造去调这个带参数的构造，在Java中直接穿个this(xxx)就可以了，那就在C++中模仿一下
class A { private: string name; int age; public: A(string name, int age) { this-&gt;name = name; this-&gt;age = age; } A() { A("bob", 20); } void print() { cout &lt;&lt; name &lt;&lt; " " &lt;&lt; age &lt;&lt; endl; } // ... // ... }; 1.构造互调两方案 这段代码输出的是一个不确定的值，name与age的值并不是我们期待的，原因在于执行A(“bob”, 20)时，并不是用这一构造函数来初始化当前的内存区，而是初始化了一个临时对象的内存区。
具体阐述：A a；这里已经为a分配了内存，然后调用默认构造函数，但是默认构造函数还未执行完，却调用了另一个构造函数，这样相当于产生了一个匿名的临时A对象，它调用A(“bob”, 20)构造函数，将这个匿名临时对象自己的数据成员name与age初始化后,当执行完这一行，这个匿名临时对象已经被释放掉了,此时a的数据成员并没有得到初始化。于是a的name与age是未初始化的，因此其值也是不确定的。
那么如何在C++中实现构造函数调用构造函数呢？
两种方案，第一种：封装到公共操作到私有函数中；第二种：定点new；
1.1 封装方案
我们将原来的代码改写：
class A { private: string name; int age; void init(string name, int age) { this-&gt;name = name; this-&gt;age = age; } public: A(string name, int age) { init(name, age); } A() { init("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a9a3931081052785cc6fb33bf70aac7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd43671bcd78aae3e0a6df3406dedbf6/" rel="bookmark">
			使用spire.pdf往某个位置处写文本信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用开发工具idea2022，java1.8版本，利用spire.pdf往一个现成的pdf中写入文本信息，经过一番研究，实现了，现在贴出代码分享：
首先导入Spire.Pdf.jar到maven汇总，因为我采用他的官网在pom中加依赖老是失败，所以就直接下载了jar包，然后导入到程序中，jar下载链接如下：
(179条消息) spire.pdf-FE-5.1.0.ZIP-Java文档类资源-CSDN文库https://download.csdn.net/download/qq_34309663/87258972
思路：
找到你需要写入的文本旁边的一个关键信息，然后计算那个关键信息的坐标，稍微加一些偏移，就完成了：你需要先提供好一个需要操作的pdf文档
import java.io.IOException; import java.nio.file.Files; import java.nio.file.Paths; import com.spire.pdf.*; import com.spire.pdf.PdfDocument; import com.spire.pdf.general.find.*; import com.spire.pdf.graphics.*; import java.awt.*; import java.awt.geom.Rectangle2D; /*获取冰蓝spire.pdf某个文字坐标系的方法 txt:某个需要找到的文字坐标 newText:某个需要写入的内容 原理为找到txt所在的坐标，适当做一些偏移，就可以写入新的内容了 */ private static void replaceTxt(String txt,String newText){ //创建 PdfDocument 类的对象 PdfDocument doc = new PdfDocument(); //载入PDF文档 doc.loadFromFile("E:\\check.pdf"); //获取文档的第一页 PdfPageBase page = doc.getPages().get(0); //搜索需要替换的旧文本 PdfTextFindCollection collection = page.findText(txt,false); //创建 PdfTrueTypeFont 类的对象以设置字体 PdfTrueTypeFont font = new PdfTrueTypeFont(new Font("华文中宋", Font.PLAIN, 12)); PdfTextFind findObj=collection.getFinds()[0]; Rectangle2D.Float rec = (Rectangle2D.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd43671bcd78aae3e0a6df3406dedbf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee3b6bc6982e9fca731f37b0fc88f6ef/" rel="bookmark">
			【无标题】13、 简单应用题 输出所有的“水仙花数”。所谓的“水仙花数”是指一个3位数，其各位数字的立方和等于该数本身。例如，153是一个水仙花数，因为153=13&#43;53&#43;33
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		13、 简单应用题 输出所有的“水仙花数”。所谓的“水仙花数”是指一个3位数，其各位数字的立方和等于该数本身。例如，153是一个水仙花数，因为153=13+53+33 #include&lt;stdio.h&gt; int main () { for ( int n = 100 ; n &lt; 1000 ; n ++ ) { int g = n % 10 ; int s = n / 10 % 10 ; int b = n / 100 ; if ( n == g * g * g + s * s * s + b * b * b ) { printf ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee3b6bc6982e9fca731f37b0fc88f6ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47c9ef8d50efe8e291fe9c3708972a33/" rel="bookmark">
			MySQL数据管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
目录
外键管理
数据库数据管理
DML语言
添加数据
修改数据
where条件子句
删除数据 SQL语句归纳：
//连接数据库
//创建数据库
//删除数据库
//显示数据库
//使用数据库
//显示表
//显示表结构
//显示创建表的语句
//创建表
//单行注释:#
//多行注释:/**/
删除表
修改表名称
添加字段
修改字段
删除字段
外键创建
//1.在创建从表的同时创建外键
//2.在表创建完毕之后进行外键的添加
外键删除：删除外键同时还需要删除索引
删除索引
删除主从关系表的时候 先删除从表再删除主表
添加数据
修改数据
删除数据
查询语句
外键管理 数据库数据管理 DML语言 添加数据 修改数据 where条件子句 删除数据 SQL语句归纳： //连接数据库 mysql -h服务器主机地址 -u用户名 -p密码
//创建数据库 create database if not exists 数据库名;
//删除数据库 drop database if exists 数据库名;
//显示数据库 show databases;
//使用数据库 use 数据库名;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47c9ef8d50efe8e291fe9c3708972a33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cfdaac239a5e7dd32c8788364036ebe/" rel="bookmark">
			Cache与MMU的爱恨纠缠
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先声明本文不准备详细地介绍Cache和MMU的概念和用法，主要是为了厘清两者之间的相互关系和依赖。
1. MMU管理cache访问属性 在没有MMU的时候，cache本身的模型比较简单，如下所示，在使用的时候重点关注Cache数据的一致性问题。
但是这样用也有个缺点就是：cache只能整体操作，比如为了使用DMA，要关掉所有的DCache，这就是没有内存管理单元的坏处，MMU所提供的第一个作用就是对内存进行分区的权限管理，比如说外设所用的内存、DMA所用的内存区域可以设置为不允许Cache，其他区域设置为开启。这一步就开始导致了MMU与Cache的绑定，因为MMU管理了内存区域是否可以被缓存，如果不开MMU，只打开DCache或者Unified Cache(dcache和icache不分开)，将会在外设访问上出现bug。
其实icache打开也有一定的数据不一致风险，让我们看下一位博主的文章：
例如你的引导程序在地址0x8000有一些代码，它至少要运行一次，然后你选择把它作为引导程序，引导程序可能在比如地址0x10000000允许你在0x8000加载一个新的程序，这个加载使用数据访问，所以它不通过指令缓存。所以有可能指令缓存中有一些或所有你上次在0x8000区域的代码，当你在0x8000处分支到启动加载的代码时，你会得到缓存中的旧程序或旧程序和新程序的讨厌的混合部分，这些部分被缓存和不被缓存。因此，如果你的引导程序允许i-cache开启，你需要在分支到引导的代码之前使cache失效。说到底就是代码已经变了但是没有通过cache，比如我们反复运行0x8000这个地址，但是第一次运行0x8000的时候代码是从nand加载的，第二次是从emmc加载的，只要没有断电，cahce是感知不到你这样玩的。
上面这段话稍微有点绕，我画了一个图来解释下：
简单来说就是在0x8000这个地址处有了新的代码，但是icache中的代码还是旧的，是跟dcache一样的数据一致性错误。
总而言之，上面就是说明一个问题，现在的CPU，由于MMU管理着cache的访问属性，要开cache就必须开MMU！
裸跑不开MMU行不行
行，但效率很低。
现在的CPU，要想使用Cache，必须使能MMU，MMU页表里有cache访问属性配置。
在ARM里，如果不开MMU，不仅不能开启cache，连内存属性都不是normal，而是device，device属性不允许硬件对AXI总线的信号进行合并、乱序等，效率较低。
参考：MMU开关与CACHE开关的联系——https://blog.csdn.net/u011011827/article/details/125331796
为什么Uboot阶段要关MMU，关DCache、开ICache——https://blog.csdn.net/u013372900/article/details/122454478
A53的mmu配置说明——https://www.cnblogs.com/liuwanpeng/p/14372976.html
2. MMU与Cache配合CPU读写数据 MMU的第二个作用就是将处理器发出的虚拟地址（VA）转换为物理内存中的物理地址（PA），当然这是在跑linux之类的操作系统才有的，跑逻辑代码，VA=PA。
这个时候两者实际上是配合关系，因为两者的功能并不相同，MMU接收虚拟地址并将其转换为物理地址后，这个地址被送到cache或者内存中获取具体的数据。cache中存放的是某些虚拟地址或物理地址对应的实际内容。cache的索引地址可以是虚拟地址可能有点冷门知识，如下图所示，cache的位置可以有两个。
一般来说速度比较快的Level1 cache被用作虚拟寻址cache，如下图。
参考：Computer Organization and Architecture——http://aturing.umcs.maine.edu/~meadow/courses/cos335/COA04.pdf
Cache——https://xerxes.cs.manchester.ac.uk/comp251/kb/Cache
Memory Management Units (MMUs)——https://xerxes.cs.manchester.ac.uk/comp251/kb/MMU
ARMv8 MMU及Linux页表映射——https://blog.csdn.net/weixin_38428439/article/details/122438845
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1ea1170157a158382b17130592a824a/" rel="bookmark">
			电机与运动控制笔记整理（四）——具体异步电机分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两相电动机 1. 两相电动机的分类 两相电机：定子具有两相绕组。
两相电机有驱动和伺服两大类。
两相驱动电动机：大部分家用电器和小型电器中使用的异步电动机。气隙磁场接近圆形旋转磁场，转子电阻小。两相伺服电动机：定子两相绕组，分别称为激磁绕组和控制绕组，在空间相差90°电角。 两相伺服电动机特点：
稳定运行的转速范围大，而驱动电动机稳定运行的速度范围很小。一相绕组电压（流）为零时，伺服电机将产生制动转矩而迅速停转，而驱动用电机在运转后，一相电压（流）为零也可能继续运转（自转）。快速响应，机电时间常数小。两相伺服电机采用细长转子，惯量小，转子电阻大，使堵转转矩高，起动速度快。 不能用驱动电动机代替两相伺服电动机。
2. 圆形旋转磁场的机械特性 机械特性曲线以电压为参变量，电磁转矩T与转差率s（或转速n）之间的关系曲线，又称T-s曲线。
转子电阻增大时，最大转矩 T m T_m Tm​不变，临界转差率 s m s_m sm​增大（与电阻正比）。
驱动电机要求效率高，所以转子电阻小，稳定运行的转速范围小。两相伺服电动机，要求第1象限稳定运行，机械特性下垂的，即要求转子电阻足够大，保证 s m &gt; 1 s_m&gt;1 sm​&gt;1。
特点：转子电阻大，机械特性下垂
𝑠 𝑚 = 𝑟 2 𝑥 2 𝑇 𝑚 = 𝐶 1 𝑈 𝑓 2 2 𝑥 2 𝑠_𝑚=\frac{𝑟_2}{𝑥_2} \quad 𝑇_𝑚=\frac{𝐶_1 𝑈_𝑓^2}{2𝑥_2} sm​=x2​r2​​Tm​=2x2​C1​Uf2​​
异步电机只能工作在稳定区（曲线下降段为稳定区），伺服电机要求第一象限内全部为稳定区，调速范围宽。
在稳定区，电机受到微小干扰时会偏离原工作点，而干扰消逝后能自动回到原工作点。 3. 非圆形旋转磁场的机械特性 两相伺服电动机主要工作在椭圆形旋转磁场
3.1. 正反转磁场法 椭圆形磁场可以分解为两个圆形旋转磁场，它们转向相反，并且正向（与椭圆磁场转向相同）磁场大于反向磁场。
B + = 1 + α 2 B f m B − = 1 − α 2 B f m B_{+}=\frac{1+\alpha}{2} B_{f m} \quad B_{-}=\frac{1-\alpha}{2} B_{f m} B+​=21+α​Bfm​B−​=21−α​Bfm​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1ea1170157a158382b17130592a824a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d55e469e6a1b6d207e5fd553940b962/" rel="bookmark">
			记一次InputStream流读取不完整留下的惨痛教训
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 首先，问问大家下面这段流读取的代码是否存在问题呢？
inputStream = .... try { // 根据inputStream的长度创建字节数组 byte[] arrayOfByte = new byte[inputStream.available()]; // 调用read 读取字节数组 inputStream.read(arrayOfByte, 0, arrayOfByte.length); return new String(arrayOfByte); }catch (Exception e){ e.printStackTrace(); } 实际上的确是有问题的，而且在线上环境结结实实的坑了我们一把。
问题回溯 在xx银行项目上，报了下面的一个错误信息，数组越界，如下图所示： 反编译jar包的代码，在如下位置用到了数组读取，根据=号切割为组数，如下图所示： 而这个切割的字符串，是调用loadResource方法加载ORG_PATH_MAP得到，如下图所示： 我们再来看下loadResource的代码： 这里的是加载ORG_PATH_MAP.class文件的内容，这个文件虽然class，但是里面存储内容的格式如下： zj=浙江分公司,sh=上海分公司，fz=福州分公司 在我们多次确认数据格式也没有问题以后，就陷入了沉思，大家有发现什么问题呢？
原因分析 我们就怀疑读取的时候是不是有问题，是不是读取得不完整导致得。
我们看了下InputStream类的javadoc:
available() 返回可以从此输入流读取(或跳过)的字节数的估计值 ，返回的不是整个数据的长度， 是这次read可读的长度。
InputStream的不同子类对InputStream.available()可能会有不同的实现，一些实现会返回当前可一次无阻塞读入的字节数，另一些实现会返回这个输入流可读入的字节总数, 因此应尽量避免使用该返回值作为开辟能容纳该输入流所有数据的缓冲大小依据。
int read(byte b[], int off, int len) 从输入流中读取最多len字节的数据到字节数组中。尝试读取最多len字节，但可能会读取更小的数字。实际读取的字节数以整数形式返回。
所以做了一个demo试了一下：
有问题的这个项目是用AppClassLoader加载当前路径下的类，可以发现InputStream的实现类是JarURLInputStream 运行结果如下图，可能确实发现读少了。
小结： 在读物流时调用的是available方法，点击进入其源码发现其返回的是当前流可用长度（估计值），不是流的总长度。而在read方法读取流中数据到buffer中，但读取长度为1至buffer.length，若流结束或遇到异常则返回-1。也就是说当实际文件的长度超过此估计可用长度时也不会继续读，而是结束读取。从而导致读取的流并不完整。这很大程度取决于不同的实现。
解决方案 方案一：
public static byte[] streamToByteArray(InputStream in) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream(); byte[] buffer = new byte[4096]; int n; while (-1 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d55e469e6a1b6d207e5fd553940b962/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2312de4bf8e6a8c2f2a0b6da20d780d/" rel="bookmark">
			行话｜入局「软件定义汽车」，你真的准备好了吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是行话？ 「行话」，是极狐 GitLab 推出的全新内容系列，探讨 Git 与 DevOps 在不同行业的实践场景与解决方案，希望能够为不同行业的软件开发者带来一些全新的思考和输入。
说行业，讲行话。
这一期，我们选择了「汽车行业」，讲「汽车行话」。
以下，enjoy。
本文来自：
卢东晓 安波福（中国）科技研发有限公司软件质量高级经理
极狐(GitLab) 市场部内容团队
近年来，「软件定义汽车」兴起，但各方观点众说纷纭，直到最近才有了标准化组织的官方理解，即来自中国汽车工业协会下属的软件定义汽车工作组（以下简称SDV工作组）发布的《软件定义汽车产业生态创新白皮书（V1.0）》（以下简称白皮书）。
白皮书引用了 APTIV（安波福）和 BOSCH（博世）对于「软件定义汽车」的理解：
APTIV（安波福）
「软件定义汽车」是一个术语，描述的是一种主要通过软件实现特性和功能的汽车。这是汽车从主要基于硬件的产品向以软件为中心的车轮上电子设备不断转变的结果。
BOSCH（博世）
许多汽车驾驶员希望他们的汽车能完全融入他们的数字生活。此外，新的互联化、自动化和个性化功能在未来将越来越多地通过软件实现。过去，客户对汽车的体验主要由硬件决定，而现在软件正承担着更重要的角色。软件极大地影响了客户体验，在某些情况下甚至影响了硬件规格的这种趋势，被称为「软件定义汽车」(SWdV)。
头豹研究院《汽车软件行业概览：软件定义汽车》
目前行业普遍认为比较合理的描述是：“软件定义汽车就是软件深度参与到汽车的定义、架构、开发、验证、销售、服务等全生命周期的过程中，并不断改变和优化各环节，实现驾乘体验持续优化、汽车价值持续增值”。
这只是一个阶段性的概念理解，距离形成标准定义仍有一段路要走，但确实标志着，行业已经发展到了新的里程碑。受各种因素影响，汽车市场前景仍不明朗，但软件在汽车行业的重要度不断提升的趋势，已然不可逆转，相应的机会也越来越多。
在这样的背景下，越来越多的企业与个人源源不断地涌入，而市场竞争的大浪淘沙下，并非所有人都能生存下来。
入局「软件定义汽车」，你真的准备好了吗？
过去深耕传统汽车的整车厂，能适应快速迭代的敏捷开发吗？
软件外包团队，能应付数据激增、算法和架构高度复杂的系统吗？
互联网公司、ICT 科技公司，入局汽车能符合汽车行业的各项合规要求吗？
我们正处在汽车行业历史的关键节点 1. 主流汽车软件架构路线图 上述 SDV 工作组引用的两家企业，对「软件定义汽车」这一转变，有各自的行业洞察：
APTIV（安波福）的前身是从通用汽车公司分离出的德尔福，总部曾从美国迁到伦敦，后至爱尔兰，在一定程度上代表了「英美法系」的技术见解。
在《安波福智能汽车架构白皮书》中，可以看到如下「汽车软件架构路线图」：
图 / 逐步全面实现 SVA
来源：《安波福智能汽车架构白皮书》
翻译如下：
简言之，根据安波福发布的这份白皮书，当下的汽车软件架构正处于域（Domain）和区域（Zone）架构的阶段，2025 年将真正进入「软件定义(Software Defined)」元年。
BOSCH（博世）总部位于德国，长期居于 Tier1 榜首的公司，在一定程度上代表了欧洲「大陆法系」的行业洞察。
图源：The Wild West Of Automotive
翻译如下：
该时间表是博世于 2015 年提出，而当下的架构演化进程完全符合预测，正处在所有域控单元向「融合于一个集中式计算单元」发展的进程中。
结合国情理解「软件定义汽车」这一转变给行业带来的影响，我们可以参考头豹研究院《汽车软件行业概览：软件定义汽车》报告：这是覆盖「汽车的定义、架构、开发、验证、销售、服务等全生命周期」的颠覆性变革。
2. 历史 vs 当下 事实上，随着「软件定义汽车」的演进，汽车软件产业链金字塔型结构，即「主机厂 - Tier1 - Tier2 - Tier3」，也已发生改变。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2312de4bf8e6a8c2f2a0b6da20d780d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88bed43f17eebffa869d0e32016cd443/" rel="bookmark">
			mac升级Ventura系统后不能使用ssh
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在/Users/bianxiang/.ssh/config添加config文件，config文件内容为如下：
Host * ServerAliveInterval 10 HostKeyAlgorithms +ssh-rsa PubkeyAcceptedKeyTypes +ssh-rsa 另外sourcetree可能第一次ssh还是拉不了代码，第一次需要使用git命令git clone git@192.168.1.249:fxeye/wikifx2.0-flutter.git
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfd80cb0d80648cbb9be629d16e87e56/" rel="bookmark">
			点金计划商家小票
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意点一 'SHOW_CUSTOM_PAGE'-----商家小票
'SHOW_OFFICIAL_PAGE'----微信官方小票
注意点二（刚开始postData上下不统一，而且这里没有加window.） let postData = JSON.stringify(mchData);
window.parent.postMessage(postData, 'https://payapp.weixin.qq.com');
注意点三（onIframeReady放在mounted里） 以下是静态页面代码： &lt;template&gt; &lt;div class="pay-result"&gt; &lt;div class="text"&gt; &lt;div class="pay-tips"&gt;&lt;van-icon name="checked" class="pay-icon" /&gt;&lt;/div&gt; &lt;div class="pay-tips"&gt;支付成功&lt;/div&gt; &lt;div class="pay-info"&gt; &lt;div class="pay-info-details"&gt; &lt;span&gt;订单编号&lt;/span&gt; &lt;span&gt;1111&lt;/span&gt; &lt;/div&gt; &lt;div class="pay-info-details"&gt; &lt;span&gt;实付金额&lt;/span&gt; &lt;span&gt;￥111&lt;/span&gt; &lt;/div&gt; &lt;div class="pay-info-details"&gt; &lt;span&gt;支付时间&lt;/span&gt; &lt;span&gt;111&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="btns"&gt; &lt;van-button block class="back-btn btn" @click="JumpToHome"&gt; &lt;template #default&gt; &lt;span class="btn-text"&gt;返回&lt;/span&gt; &lt;/template&gt; &lt;/van-button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { out_trade_no: '', }; }, created() { /** 点金小票的js，需要在head中引入 */ let head = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfd80cb0d80648cbb9be629d16e87e56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c47fac9e55c713126380e52647685d3c/" rel="bookmark">
			JAVA线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JAVA线程的基本概念 （并行与并发）
并行：是指两个事件或多个事件在同一时刻发生生（同时发生）称之为并行
并发：是指两个事件或多个事件在同一时间段内发生（可能是几秒内也可能是一分钟内事件间隔不不会太长）称之为并行
多线程的使用场景
1. 后台任务,比如游戏服务器 2.定时向大量用户(100W)用户发邮件 3.异步处理: 发微博/记录日志等 4.分布式计算...
线程与进程的区别
进程：是指一个内存中运行的应用程序，每个进程的都有一个独立的内存空间，一个应用程序可以同时运行多个进程，进程也是程序的一次执行过程，是系统运行程序的基本单位，系统运行一个程序及从一个程序的创建，运行到消亡的过程
线程：进程内部的一个独立执行的单元，一个进程可以同时并发多个线程，可以理解为一个进程相当于一个单cpu操作系统，而线程便是这个系统中运行的多个任务
JAVA线程的实现的三个方法
1.通过使用类继承Thread实现里面的run方法来创建线程
public class Diyi extends Thread {//使用Diyi类继承Thread调用里面的run方法 /* * 第一种线程访问方式 * @see java.lang.diyi */ @Override public void run() {//实现run方法 int a = 10; for (int i = 0; i &lt;a ; i++) { System.out.println("第一种线程访问方式\t"+i); } super.run(); } public static void main(String[] args) { Diyi diyi = new Diyi();//实例化Diyi diyi.start();//开启线程 } } 2.通过使用类接口Runnable实现run方法来创建线程（与第一种方法相差不大）
public class Dier implements Runnable { /* * * 第二种进程实现方法 * @see java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c47fac9e55c713126380e52647685d3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5886d95dd4c371e680d8c72d6ac396cc/" rel="bookmark">
			BootstrapTable 父子表案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图：
案例代码：
&lt;table id="table"&gt;&lt;/table&gt; &lt;script&gt; var $table = $('#table') function buildTable($el, cells, rows) { var i; var j; var row var columns = [] var data = [] for (i = 0; i &lt; cells; i++) { columns.push({ field: 'field' + i, title: 'Cell' + i, sortable: true }) } for (i = 0; i &lt; rows; i++) { row = {} for (j = 0; j &lt; cells; j++) { row['field' + j] = 'Row-' + i + '-' + j } data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5886d95dd4c371e680d8c72d6ac396cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d2924017697f386c03279b26e1c1b3d/" rel="bookmark">
			Redis缓存雪崩、击穿、穿透、双写一致性、并发竞争、热点key重建优化、BigKey的优化 等解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 缓存雪崩 1. 含义 同一时刻，大量的缓存同时过期失效。
2. 产生原因和后果 (1). 原因：由于开发人员经验不足或失误，大量热点缓存设置了统一的过期时间。
(2). 产生后果：恰逢秒杀高峰，缓存过期，瞬间海量的QPS(每秒查询次数)直接打到DB上，如果系统架构没有熔断机制，直接将导致系统全线崩溃。
3. 处理方案 (1). 设置不同的缓存失效时间，比如可以在缓存过期时间后面加个随机数，这样就避免同一时刻缓存大量过期失效。
setRedis（key，value，time + Math.random() * 9999）； (2). 针对系统的一些热点数据， 可以设置缓存永不过期。 （或者定时更新）
(3). 设置二级缓存架构C1、C2，C1在前，C2在后，C1的缓存可以设置不同的过期时间，C2缓存与DB保持强一致性，实现数据同步。
PS：该二级缓存架构，同样也适用于解决下面的缓存击穿。
(4). 从架构层面来说：Redis做集群，将热点数据分配在不同的master上，减轻单点压力，同时master要对应多个slave，保证高可用； 系统架构要有快速熔断策略，减轻系统的压力。
二. 缓存击穿 1. 含义 某热点Key扛着大量的并发请求，当key失效的一瞬间，大量的QPS打到DB上，导致系统瘫痪。
PS：缓存击穿和缓存雪崩类似，击穿是某些热点key失效一瞬间大量请求打到DB上，缓存雪崩是指缓存面积失效导致大量请求打到DB上。所以二者的处理方案类似。
2. 处理方案 (1). 热点key过期时间后加随机数 。
(2). 热点key缓存永不过期（但是value需要开个子线程去更新）
(3). 二级缓存架构策略。（详见上面）
(4). 采用互斥锁更新，保证同一进程针对相同的数据不会并发打到DB上，从而减轻DB的压力。
(5). 缓存失效的时候随机sleep一个很短的时间，再次查询，如果失败则执行更新操作。
三. 缓存穿透 1. 含义 业务请求中数据缓存中没有，DB中也没有，导致类似请求直接跨过缓存，反复在DB中查询，与此同时缓存也不会得到更新。
举个例子：
商品表中的id是自增，并且以id为缓存的key，商品库存为value事先存在redis中。但此时过来的请求id均为负数，-1，-2，-3，缓存没有，DB中也没有，造成类似请求直接跨过缓存，打在DB上。
2.处理方案 (1). cache null策略：DB查询的结果即使为null，也给缓存的value设置为null，同时可以设置一个较短的过期时间，这样就避免不存在的数据跨过缓存直接打到DB上。
伪代码思路分享：
Public String get(String key) { //从缓存中获取数据 String cacheValue = cache.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d2924017697f386c03279b26e1c1b3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9715d1f73324c6eaadd809a20e9445b/" rel="bookmark">
			nessus无法导出报告(nessus转中文报告)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nessus漏扫报告，可是nessus导出的报告全是英文，客户说看不懂(说的好像中文就能看懂似的)。找了很多nessus转中文报告的工具都不是很靠谱，今天突然灵机一动发现了一个解决nessus无法导出报告方法。总的说来就是生产一个html文件转中文。
nessus转中文报告教程开始：
就拿百度网站举例吧，随手扫一下百度，导出来一份报告
因为是英文的，使用谷歌翻译把它翻译一下(主机漏洞被翻译成了主持人执行摘要 = . = )翻译有误的地方稍后人工修改一下吧，毕竟机器翻译的别指望它有多聪明
仔细翻一下，看看是不是全文都被翻译出来了
按F12 进入调试界面，点击箭头所指位置
选择copy，点击Copy outerHTML
新建一个文本文件，然后CTRL+V把代码复制进去
使用替换功能，手动校验一下刚才的错误，把主持人执行摘要改成主机漏洞
把文本文件改个后缀
前面的名字随意，后缀一定要是.html
然后打开这个文件看一下
已经翻译过来了，nessus转中文报告大功告成。
nessus无法导出报告就解决了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a04aacda4bfa08266f2844059fbe88af/" rel="bookmark">
			DS18B20温度传感器使用介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DS18B20温度传感器简介
DS18B20是一种数字温度传感器，应用非常广泛。它输出的是数字信号，同时具有体积小，硬件资源耗费少，抗干扰能力强，精度高等特点。
DS18B20温度传感器特点
1、采用单线接口方式：DS18B20温度传感器仅需要一条线即可实现与微处理器的双向通信。
2、测温范围： DS18B20温度传感器的测温范围可达－55℃～+125℃，在-10℃到+85℃范围内误差为±0.4°。
3、支持多点组网功能：多个DS18B20温度传感器可以并联在一条数据线上，最多可以并联8个，实现多点测温。
4、工作电源: 3.0～5.5V/DC ，DS18B20温度传感器可以采用外部独立电源供电，也可以用数据线寄生电源供电。
5、DS18B20温度传感器在应用过程中不需要任何外围元件。
6、DS18B20温度传感器测量温度的结果以9~12位数字量方式串行传送。
7、掉电保护功能， DS18B20温度传感器内部含有 EEPROM ，通过配置寄存器可以设定数字转换精度和报警温度。在DS18B20温度传感器掉电以后仍可保存分辨率及报警温度的设定值。
8、DS18B20温度传感器返回16位二进制数代表此刻探测的温度值，其高五位代表正负。如果高五位全部为1，则代表返回的温度值为负值。如果高五位全部为0，则代表返回的温度值为正值。后面的11位数据代表温度的绝对值，将其转换为十进制数值之后，再乘以0.0625即可获得此时的温度值。
DS18B20温度传感器引脚说明
DS18B20温度传感器寄生电源供电方式
DS18B20温度传感器寄生电源供电方式如下图所示。在寄生电源供电方式下，DS18B20温度传感器从信号线上汲取电源：在信号线高电平时把电能储存在内部电容里；在信号线低电平时消耗电容上的电能，直到信号线高电平到来再给电容（寄生电源）充电。
寄生电源供电方式的优点：
1、无需本地电源，可以实现远距离测温。
2、可以仅用一根信号线实现测温，电路更加简单。
寄生电源供电方式的缺点：
要想使DS18B20温度传感器进行精确的温度转换，信号线必须保证在温度转换期间提供足够的能量。但当多个DS18B20温度传感器挂在同一根信号线上时，只靠上拉电阻就无法提供足够的电能，这会造成DS18B20温度传感器无法测量温度或误差极大。
因此，寄生电源供电方式只适应于单一DS18B20温度传感器测温情况下使用。
DS18B20温度传感器寄生电源强上拉供电方式
DS18B20温度传感器寄生电源强上拉供电方式如下图所示。为了使DS18B20温度传感器在测温过程中获得足够的电能供应，用MOSFET把信号线直接拉到VCC就可提供足够的电能（在任何涉及到拷贝或启动温度转换指令时，必须在最多10μS内把信号线转换到强上拉状态），解决电能供应不足的问题。DS18B20温度传感器寄生电源强上拉供电方式适合于多点测温应用，但是要多占用一根I/O线进行强上拉切换。
DS18B20温度传感器的外部电源供电方式
在外部电源供电方式下，DS18B20温度传感器工作电源由VDD引脚接入，不存在电源电流不足的问题，可以保证转换精度。同时在总线上可以挂接多个DS18B20温度传感器，组成多点测温系统。外部电源供电方式是DS18B20温度传感器最佳供电方式：工作稳定可靠、抗干扰能力强、电路也比较简单。
DS18B20温度传感器的内部结构
DS18B20温度传感器的内部由64位ROM、高速缓冲存储器、CRC生成器、温度敏感器件、高低温触发器及配置寄存器等部件组成。
1、DS18B20温度传感器的64位ROM
DS18B20温度传感器内部有64位ROM，ROM固化有确定内容。低八位（固定为28H）是产品类型标识号、接着的48位是序列号、高8位是前面56位的循环冗余检验码。
2、DS18B20温度传感器的内存映射
DS18B20温度传感器内有9个字节高速缓冲存储单元,下图所示。
3、DS18B20温度传感器的配置寄存器
DS18B20温度传感器的配置寄存器字节的最高位BIT7为测试模式位，出厂时为0，用户不需要改动。BIT6、BIT5位用于设置DS18B20温度传感器的转换分辨率，分辨率有9、10、11和12位四种选择，对应的转换时间分别为：93.73ms、187.5ms、375ms和750ms。其余的低5位为保留位(均为1)。
DS18B20温度传感器出场设置默认R0、R1为11。也就是12位分辨率，也就是1位代表0.0625摄氏度。
DS18B20温度传感器的读写
指令
DS18B20温度传感器经转换所得的温度值以二字节补码形式存放在高速暂存存储器的第0和第1个字节。所以当我们只想简单的读取温度值的时候，只用读取暂存器中的第0和第1个字节就可以了。
简单的读取温度值的步骤如下：
1、跳过ROM操作。 2、发送温度转换命令。
3、跳过ROM操作。 4、发送读取温度命令。
5、读取温度值。
DS18B20温度传感器的初始化 主器件首先发出一个480－960微秒的低电平脉冲，然后释放总线变为高电平，并在随后的480微秒时间内对总线进行检测，如果有低电平出现说明总线上有DS18B20温度传感器已做出应答。若无低电平出现一直都是高电平说明总线上无DS18B20温度传感器应答。
做为从器件的DS18B20温度传感器在一上电后就一直在检测总线上是否有480－960微秒的低电平出现，如果有，在总线转为高电平后等待15－60微秒后将总线电平拉低60－240微秒做出响应存在脉冲，告诉主机本器件已做好准备。若没有检测到就一直在检测等待。
DS18B20温度传感器的写操作 写周期最少为60微秒，最长不超过120微秒。
写周期一开始主器件先把总线拉低1微秒表示写周期开始。随后若主器件想写0，则将总线置为低电平，若主器件想写1，则将总线置为高电平，持续时间最少60微秒直至写周期结束，然后释放总线为高电平至少1微秒给总线恢复 。而DS18B20温度传感器则在检测到总线被拉底后等待15微秒然后从15us到45us开始对总线采样，在采样期内总线为高电平则为1，若采样期内总线为低电平则为0。
DS18B20温度传感器的读操作 对于读数据操作时序也分为读0时序和读1时序两个过程。
读周期是从主器件把单总线拉低1微秒之后就得释放单总线为高电平，以让DS18B20温度传感器把数据传输到单总线上。作为从机DS18B20温度传感器在检测到总线被拉低1微秒后，便开始送出数据，若是要送出0就把总线拉为低电平直到读周期结束。若要送出1则释放总线为高电平。
主器件在一开始拉低总线1微秒后释放总线，然后在包括前面的拉低总线电平1微秒在内的15微秒时间内完成对总线进行采样检测，采样期内总线为低电平则确认为0。采样期内总线为高电平则确认为1。完成一个读时序过程，至少需要60微秒才能完成。
DS18B20温度传感器应用电路
单个DS18B20接线方式： VDD接到电源，DQ接单片机引脚，同时外加上拉电阻，GND接地。注意这个上拉电阻是必须的，就是DQ引脚必须要一个上拉电阻。
DS18B20温度传感器的一个例程
/*************DS18B20测量温度*************** *单片机型号：STC89C52RC
*开发环境：KEIL *功能: DS18B20测量温度，并在数码管中显示出来 *************************************************/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a04aacda4bfa08266f2844059fbe88af/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/200/">«</a>
	<span class="pagination__item pagination__item--current">201/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/202/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>