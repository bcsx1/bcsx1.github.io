<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75fafd1e8157b7f88916c1f7cb1f6098/" rel="bookmark">
			uniapp日期选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日期 在picker中加fields="month"就只能选择年月了，加fields="year"则只能选择年，默认是年月日格式
直接上代码，可以直接粘贴复制复用
&lt;picker mode="date" :value="date" fields="month" :start="startDate" :end="endDate" @change="bindDateChange"&gt; &lt;view&gt;{{ date }}&lt;/view&gt; &lt;/picker&gt; &lt;script&gt; function getDate(type) { const date = new Date(); let year = date.getFullYear(); let month = date.getMonth() + 1; let day = date.getDate(); if (type === 'start') { year = year - 10; } else if (type === 'end') { year = year + 10; } month = month &gt; 9 ? month : '0' + month; return `${year}-${month}`; } export default { data() { return { date: getDate({ format: true }), startDate: getDate('start'), endDate: getDate('end'), }; }, methods: { bindDateChange(e) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75fafd1e8157b7f88916c1f7cb1f6098/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/accbc377d336b6ca5777ee23f45f68a2/" rel="bookmark">
			【通用】前端处理后台返回的图片控制台输出是乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用接口后发现返回的是乱码 第一步：在请求接口上添加responseType
export function downcode (params) { return request({ url: `/admin/downcode`, method: 'get', responseType: 'arraybuffer', //需要在此处设置请求头 params }) } 之后接口就会返回一个数组
第二步：把这个数组转换成base64即可
async getform () { const res = await downcode(); //下载二维码 console.log(res); this.Form.imageUrl = `data: image/jpeg;base64,${btoa(new Uint8Array(res).reduce((data, byte) =&gt; data + String.fromCharCode(byte), ''))}` }, 注意：new Uint8Array(res)中的res是后端返回的数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f30e72d4cf85a5858fc8a126ab198ba/" rel="bookmark">
			vue2 父子组件使用v-model 控制弹窗model显示隐藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vue官方传送口
父组件
使用v-model绑定变量，控制显示
&lt;Model v-model="dialogVisible"&gt;&lt;/Model&gt; 子组件
和props同层级写model
props里面接受的参数dialogVisible和model里面prop保持一致，默认是value
props: { // 显示隐藏 dialogVisible: { type: Boolean, default: false, }, }, model: { prop: "dialogVisible", event: "hide", }, 更新
computed: { visible: { get() { return this.dialogVisible; }, set(val) { this.$emit("hide", val); } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c361b28a8703b1d037afbc8c34ab4c6/" rel="bookmark">
			Keil5进行STM32F103C8T6的软件仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、软件仿真
Keil有很强大的软件仿真功能，通过软件仿真可以发现很多将要出现的问题，Keil的仿真可以查看很多硬件相关的寄存器，通过观察这些寄存器值的变化可以知道代码有没有正常运行。这样可以避免频繁下载程序，延长单片机Flash寿命。
开始仿真之前，先配置一些选项。
1.在工程设置里设置好芯片型号和晶振频率
2.在“Debug”选项卡中选择“Use Simulator”，表示使用软件仿真；选择“Run to main()”则表示跳过汇编代码，直接跳转到main函数开始仿真。设置下面的“Dialog DLL”项为“DARMSTM.DLL”和“TARMSTM.DLL”；parameter项为“-pSTM32F103C8”，用于设置支持STM32F103C8的软硬件仿真
3.点击开始仿真，这个时候会多出来一个工具条，就是Debug工具条
输入你想要查看的引脚，我这里用的是PB0，所以需要输入PORTB.0(格式为PORTX.X),如果显示没有发现，那么说明是前面的debug配置有错误，需要和你使用的STM32的型号一致。
配置按位输出，颜色选择你所需要的颜色，勾画上Hexadecimal Display.
之后要右击设置为bit位；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db6d04c15f6f79a547f7a424f3db5bfe/" rel="bookmark">
			uniapp 声音提示、震动提示、语音播报插件 Ba-Beep
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介（下载地址） Ba-Beep 是一款uniapp提供声音提示、震动提示的插件，如操作提示音（扫码、读卡、打印、按键等）。也可实现简单的语音播报功能。
支持声音（默认有beep、数字、英文字母、欢迎光临、谢谢等，可自定义）支持震动（可自定义震动效果）支持语音播报（内容可联系作者定制，也可自行添加）支持的音频格式有mp3、wav、ogg、3gp、AAC、AMR、FLAC、MIDI等 使用方法 在 script 中引入组件
const beep = uni.requireNativePlugin('Ba-Beep') 在 script 中调用
methods: { play(name = this.name) { //播放声音 beep.play({ beepName: name,//音频资源名称，参照“音频资源配置” }, (res) =&gt; { console.log(res) uni.showToast({ title: res.msg, icon: "none", duration: 3000 }) }); }, playVibrate() { //震动 //let params = {};//默认 500 let params = { repeat: 0,//重复 -1：表示不重复 0：循环的震动 &gt;1：表示从哪里开始重复 pattern: [500, 200, 500, 100]//震动规则，传递一个整型数组作为关闭和开启震动的持续时间，以毫秒为单位。第一个值表示等待震动开启的毫秒数，下一个值表示保持震动的毫秒数，这个序列值交替表示震动关闭和开启的毫秒数 }; //自定义规则 beep.playVibrate(params, (res) =&gt; { console.log(res) uni.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db6d04c15f6f79a547f7a424f3db5bfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eb0c08c27bfe5d70ac1f37fa4a34c93/" rel="bookmark">
			UE4中Cesium插件使用（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前提条件：
UE4 引擎4.26 及以上，Cesium账号（在官网注册）。
二、添加插件(UE4 4.26自带)/下载插件
1，打开UE4引擎界面在插件设置页面 搜索cesium，点击启用，然后重启UE4。
2，如果在插件列表搜不到cesium插件，需要去UE4商城去获取插件。在商城搜索Cesium for unreal。然后重复上一步添加插件操作操作。
三、创建项目关卡
1 ，打开引擎创建空项目进入引擎界面工具栏会出现Cesium图标：如果没有需要检查插件是否启用。
2 ，创建新的空关卡，并保存。
3 ，首先在场景中添加Cesium照明，以及Pawn（第一人称玩家控制器 Dynamic Pawn为Cesium内置pawn 后续讲解），点击Cesiun图标会出现下图，点击对应Actor 后的+符号 场景中会出现对应的actor。
4 ，刚添加照明后场景可能会惨白（曝光过高）：
曝光过高解决方法有三种：
（1）在项目设置中搜索：“自动曝光设置中扩展默认亮度范围”勾选选项，会恢复曝光如果没有，请重启引擎。
（2）选中照明actor 在细节面板找见 定向光组件，将强度降到10.0（此方法为官方提供，我没找见）
（3）使用平常的天光，天空球 BP_Sky_Sphere（亲测可用）去掉Cesium照明Actor，添加日常的平行光以及天空球（缺点：天空球有范围，有的地方照不到，需要把范围扩大）
5 ，连接Cesium在线资源：
（1）点击Cesium面板 点击Connect to CesiumIon （如果没有 拉伸一下面板）：
（2）在弹出的浏览器窗口，登录你的Cesium账户（建议使用EpicGames 账户 方便后续资源链接）。登录成功后有个 提示XXXX 点允许Allow 就可以。
（3）返回引擎界面，创建访问令牌（建议每个项目都新建一个token，用之前建的没反应。）：
（4）弹出创建令牌界面：
（5）在 新建新的token 那输入本次令牌名字，后点击最下方的新建新的项目默认令牌。（详细令牌可以去Cesuim官网看令牌设置，不注重在线资源所以没了解）。
6，创建地球
（1）点击添加，后Cesium资源添加到场景中，同时会出现地形画面。
（2）在场景中存在Cesium World Terrain 、CesiumCameraManager、CesiumCreditSystemBP、CesiumGeoreference，此四项在添加Cesium资源的时候就会自动生成。
相关理解： Cesium World Terrain 对象是点击添加资源后生成的，这个Actor 是3DTileset 类型。在详细面板可以看见可设置的属性。
相关参数：
Georeference 设置为 在场景中的CesiumGeoreference；
CreditSystem 设置为 在场景中的CesiumCreditSystem；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1eb0c08c27bfe5d70ac1f37fa4a34c93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0822177252fe08056e6c695108c26930/" rel="bookmark">
			十分钟轻松掌握sqlite3轻量级数据库的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 数据库的安装
sudo apt install sqlite3
2. 数据库命令
1）系统命令 ， 都以'.'开头
.exit .quit
.table 查看表
.schema 查看表的结构
2）sql语句， 都以‘;’结尾
1-- 创建一张表
create table stuinfo(id integer, name text, age integer, score float);
2-- 插入一条记录
insert into stuinfo values(1001, 'zhangsan', 18, 80);
insert into stuinfo (id, name, score) values(1002, 'lisi', 90);
3-- 查看数据库记录
select * from stuinfo;
select * from stuinfo where score = 80;
select * from stuinfo where score = 80 and name= 'zhangsan';
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0822177252fe08056e6c695108c26930/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aa82a4c92416496e10bd20f639067db/" rel="bookmark">
			PHP 自定义参数校验工具Validator
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PHP服务端校验客户端请求传递的参数，做参数验证时有许多弊病
不同业务需求而做不同的参数校验写许多判断条件许多重复校验逻辑… 通过归纳整理，自定义了一个参数校验工具类Validator
使用方法：
/** * @var array $params 需要校验参数数组(key=&gt;value) * @var array $rules 校验规则(key=&gt;rules) * @var array $message 错误信息(key.rule=&gt;message) */ $validator = Validator::make($params, $keyRules, $messages) 校验规则：
required：验证参数key的值不能为空。
以下情况参数key的值都为空：
值为null值是空字符串值是空数组 $validator = Validator::make($params, [ 'name' =&gt; 'required' ], [ 'name.required' =&gt; '姓名不能为空' ]); if ($validator-&gt;fail) { throw new Exception($validator-&gt;errors[0]); } required_if:field1,value1,field2,value2,…：如果 field 等于 value （多个field=value的条件只需满足一个），那么验证参数key的值不能为空。
$validator = Validator::make($params, [ 'age' =&gt; 'required_if:type,1|numeric',//当type=1时年龄不能为空 //或者 //'age' =&gt; ['required_if:type,1', 'numeric'], //或者 //'age' =&gt; ['required_if' =&gt; 'type,1', 'numeric'], //或者 //'age' =&gt; ['required_if' =&gt; ['type', 1], 'numeric'], ], [ 'age.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aa82a4c92416496e10bd20f639067db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcb697e78ac65b146423cbcfec78fcd3/" rel="bookmark">
			UE4整体运行流程（转）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 UE4源码解析-整体流程 - 知乎 (zhihu.com)
引擎入口函数：Source-&gt;Runtime-&gt;Launch-&gt;private-&gt;WinMain(Windows)
循环函数：Launch.cpp-&gt;GuardedMain.
实际的游戏循环：封装在GEngineLoop中，有三个重要函数：
FEngineLoop::PreInit() PreInit()存在大量初始化工作，加载各种模块代码，初始化各种底层模块。在渲染的过程中，会初始化TaskGraph，线程池，RHI层以及各种shader资源FEngineLoop::Init() 构建游戏世界，创建GEngine，创建GameInstance，创建WorldContext和UWorld，构建ViewportFEngineLoop::Tick() 更新游戏逻辑在渲染中，通过ENQUEUE_RENDER_COMMAND(UpdateScenePrimitives)函数调用渲染线程更新渲染数据。调用RedrawViewports()函数进行上一帧的场景渲染，生成渲染命令。调用FSlateApplication::Get().Tick()函数更新UI相关内容。最后通过FrameEndSync.Sync函数阻塞逻辑线程直到上一帧的渲染线程执行完毕。也就是说逻辑线程和渲染线程是并行执行的，只不过它们之间相差一帧的内容。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2505bdb8fbd4d2a5d2a0c0d9f7f9ffb8/" rel="bookmark">
			一个查询ip归属地的hive udf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 工作中会用到查询ip归属地的场景，购买了ip库数据，因官方不提供数据遍历方案，所以无法全量导入到hive中，只能使用udf进行查询。
数据源来自https://www.ipip.net/，数据格式为.ipdb，如：ipv4_china_cn.ipdb。
udf编码 maven pom.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.companya.bd&lt;/groupId&gt; &lt;artifactId&gt;companyaudf&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.hive/hive-exec --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hive&lt;/groupId&gt; &lt;artifactId&gt;hive-exec&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;!-- &lt;exclusion&gt;--&gt; &lt;!-- &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;--&gt; &lt;!-- &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt;--&gt; &lt;!-- &lt;/exclusion&gt;--&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpcore&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-1.2-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.ipip&lt;/groupId&gt; &lt;artifactId&gt;ipdb&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.hadoop/hadoop-hdfs &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2505bdb8fbd4d2a5d2a0c0d9f7f9ffb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39bb7cca7502da37b9ab1a704c729f59/" rel="bookmark">
			hive执行insert overwrite失败，报错 could notbe cleaned up错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 用户zhangsan执行insert overwrite： INSERT OVERWRITE table temp.table_1 PARTITION(d_layer='layer_1') SELECT ... 报错目的目录无法清理——could not be cleaned up：
Failed with exception Directory hdfs://cluster_1/user/hive/warehouse/temp.db/table_1/d_layer=layer_1 could not be cleaned up. FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.MoveTask. Directory hdfs://cluster_1/user/hive/warehouse/temp.db/table_1/d_layer=layer_1 could not be cleaned up. 查看hdfs目录权限，发现该目录为所有人可写，目录owner为lisi： drwxrwxrwt - lisi supergroup 0 2021-11-29 15:04 /user/hive/warehouse/temp.db/table_1/d_layer=layer_1 用户lisi执行步骤1.中的sql可以成功执行 问题原因 三个字——粘滞位。
仔细看上面的目录权限，最后一位为“t”，表示该目录开启了粘滞位，即只有该目录的owner才能删除目录下的文件
# 非owner删除粘滞位文件 $ hadoop fs -rm /user/hive/warehouse/temp.db/table_1/d_layer=layer_1/000000_0 21/11/29 16:32:59 INFO fs.TrashPolicyDefault: Namenode trash configuration: Deletion interval = 7320 minutes, Emptier interval = 0 minutes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39bb7cca7502da37b9ab1a704c729f59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e6f737da5d6da9a92f7930b7a896951/" rel="bookmark">
			ROS点云类型sensor_msgs::PointCloud2与PCL的PointCloud＜T＞点云类型转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 由于大多数开源SLAM算法中都基于ROS开发，各传感器采集的数据通常以ROS的消息类型（sensor_msgs）进行发布和订阅。就激光雷达（LiDAR）而言，采集的原始点云数据通常以sensor_msgs::PointCloud2的数据类型进行发布，在算法中对点云进行处理时，调用点云开源算法库（PCL）中的功能可以便捷的实现相应功能。PCL库内部也定义了自己的点云数据结构。因此，在处理前，首先需要将点云由ROS的数据类型转换为PCL的数据类型。
ROS中的点云数据类型
sensor_msgs::PointCloud：该类型属于较早的版本，以逐渐弃用。
sensor_msgs::PointCloud2：目前常用的点云数据类型
PCL 中的点云数据类型
pcl::PointCloud&lt;T&gt;:点云以模板的形式定义，可以用pcl定义好的，也可以自定义
本文旨在分享如何将 sensor_msgs::PointCloud2 转换为 pcl::PointCloud&lt;T&gt;。
二、ROS中点云数据结构： 官方文档说明：ROS sensor_msgs/PointCloud2 std_msgs/Header header：数据头，包含该帧点云的时间戳、坐标系等属性信息
uint32 height：data的高度，一帧点云通常height=1，即表示无序点云；
uint32 width：data的宽度，即每行对应点的数量；
sensor_msgs/PointField[] fields：包含每个点的字段属性信息，详见下文。
bool is_bigendian：点云是否按正序排列
uint32 point_step：每个点占用的比特数，1字节=8比特，与PointField里所有字节数之和相等。
uint32 row_step：每行占用的比特数，=点的数量*Point_step;
uint8[] data：序列化后的点云二进制数据，所有点信息都在一串字符中，无法通过data[i]取值。
bool is_dense：是否存在无效点。
最值得关注的变量是：fields。
官方文档：sensor_msgs/PointField[] fields
string name # 点的字段名
uint32 offset # 相对于结构体起始地址的字节数
uint8 datatype # 该字段所占用的字节数
uint32 count # 该字段的数量，通常为1
datatype 不同值与类型的对应如下：
uint8 INT8 = 1 // 1字节
uint8 UINT8 = 2 // 1字节
uint8 INT16 = 3 // 2字节
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e6f737da5d6da9a92f7930b7a896951/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2114a41dd60117e8cffba472e99cd955/" rel="bookmark">
			关于nginx服务关闭之后端口占用kill不掉的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 首先介绍下当前环境 首先介绍下当前环境 nginx版本：1.21.6
linux版本：CentOS8
使用命令行 ps -ef|grep nginx 查询出当前 nginx进程；
使用kill -9 进程号 来进行强制关闭nginx；
但是使用该命令却神奇的发现nginx 依然在运行；反复试了几次依然不行；
在百度+google后 发现需要使用命令
pkill nginx 来删除；
启动nginx命令
./nginx -c nginx文件配置路径
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac340f045c55df4e71923c9a03fb5366/" rel="bookmark">
			MinIo报错记录及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器数量不够，最少为4； 防火墙问题，需开发端口或者关闭防火墙. Error：Bucket is missing ObjectLockConfiguration
解决：在web控制台中给桶添加配置ObjectLock
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/059592644c99542168f8b80458692e4d/" rel="bookmark">
			CTFSHOW WEB入门——sql注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 web171web172web173web174web175web176web177web178web179web180web181web182web183web184web185web186web187web188判断SQL注入是字符型还是数字型方法一：order by法方法二：逻辑判断法 注释后面语句参考文章/视频 web171 //拼接sql语句查找指定ID用户
$ sql = “select username,password from user where username !=‘flag’ and id = '”.$_GET[‘id’].“’ limit 1;”;
1 order by 9999 --+ #判断为字符型 1'or'1'='1 # 得到flag # 官方视频flag 999' or id='26 web172 //拼接sql语句查找指定ID用户
s q l = " s e l e c t u s e r n a m e , p a s s w o r d f r o m c t f s h o w u s e r 2 w h e r e u s e r n a m e !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/059592644c99542168f8b80458692e4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebaadc7f2d9e4274517e9bc8db074922/" rel="bookmark">
			移动Web：媒体查询及手机端PC端识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		媒体查询 响应式布局的核心，能够检测视口的宽度，然后编写差异化的 css 样式调整网页的布局方式。
响应式布局原理：根据 UI 设计稿需求合理设置响应断点，配合媒体查询书写差异化CSS样式。
响应断点是指媒体查询所采用的视口的宽度。作用：将屏幕尺寸划分成若干的区间。
语法格式 /* 写法一：内嵌式 */ @media 逻辑符 媒体类型 and (媒体特性) { 执行的 css 代码 } /* 写法二：外链式 */ &lt;link rel="stylesheet" media="逻辑符 媒体类型 and (媒体特性)" href="xx.css" &gt; /* 视口宽度最小为320px，最大为640px时，呈现样式 */ @media (min-width: 320px) and (max-width: 640px) { body { background: #f00; } } /* 视口宽度最小为640px，最大为1024px时，呈现样式 */ @media (min-width: 640px) and (max-width: 1024px) { body { background: #00f; } } /* 视口宽度最小为1024px，最大为1600px时，呈现样式 */ @media (min-width: 1024px) and (max-width: 1600px) { body { background: #0f0; } } @media 解析过程 浏览器解读代码时，实时对当前设备进行检测
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebaadc7f2d9e4274517e9bc8db074922/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3e616120bafffed00195a751c824d0a/" rel="bookmark">
			YOLO-V3实时检测实现（opencv&#43;python实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLO-V3实时检测实现（opencv+python实现）_Keep_Trying_Go的博客-CSDN博客_opencv yolov3
import os import cv2 import numpy as np import matplotlib.pyplot as plt import time # 读取网络配置文件和权重文件 net = cv2.dnn.readNet(model='./weights/yolov3-tiny.weights', config='./config/yolov3-tiny.cfg') # 由yolo-v3的结构可知，最终有三个尺度的输出 layerName = net.getLayerNames() # 存储输出的三个尺度名称，用于后面进行前向推断的 ThreeOutput_layers_name = [] for i in net.getUnconnectedOutLayers(): ThreeOutput_layers_name.append(layerName[i - 1]) # 因为yolo-v3中检测包含80个类别，所以首先获取类别 with open('./data/coco.names', 'r') as fp: classes = fp.read().splitlines() # 指定过滤的置信度阈值：confidence Confidence_thresh = 0.2 # 指定非极大值抑制的值：对候选框进行筛选 Nms_thresh = 0.35 # 检测的过程已经图形的绘制 def Forward_Predict(frame): # 参数情况：图像 ，归一化，缩放的大小，是否对RGB减去一个常数，R和B交换（因为R和B是反着的，所以需要交换），是否裁剪 blob = cv2.dnn.blobFromImage(frame, 1 / 255, (64, 64), (0, 0, 0), swapRB=True, crop=False) # 获取图像的高宽 height, width, channel = frame.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3e616120bafffed00195a751c824d0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76956e4210ea409abbb7b9125c54e793/" rel="bookmark">
			Linux ping向网络主机发送ICMP ECHO REQUEST
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ping 命令用来测试主机之间网络的连通性。执行 ping 命令会使用 ICMP 传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。
在网络中 ping 是一个十分强大的 TCP/IP 工具。它的作用主要为：
1、用来检测网络的连通情况和分析网络速度
2、根据域名得到服务器IP
3、根据 ping 返回的 TTL 值来判断对方所使用的操作系统及数据包经过路由器数量
①　ping目标主机的域名和IP（ping会自动将域名转换为IP）
②　不带包头的包大小和带包头的包大小（参考“-s”参数）
③　icmp_seq：ping序列，从1开始；
ttl： 剩余的 TTL；
time: 响应时间,数值越小，连通速度越快；
④　发出去的包数，返回的包数，丢包率，耗费时间；
⑤　最小/平均/最大响应时间和本机硬件耗费时间；
语法格式
ping (选项) (参数) 目标主机 ping [-aAbBdDfhLnOqrRUvV46] [-c count] [-F flowlabel] [-i interval] [-I interface] [-l preload] [-m mark] [-M pmtudisc_option] [-N nodeinfo_option] [-w deadline] [-W timeout] [-p pattern] [-Q tos] [-s packetsize] [-S sndbuf] [-t ttl] [-T timestamp option] [hop .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76956e4210ea409abbb7b9125c54e793/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5abd948178f2ad5f7612ca472abd0380/" rel="bookmark">
			用C语言写阶乘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt;
int main(){
int n,s=0;//定义阶乘的个数，总阶乘的和并初始化 scanf("%d",&amp;n);//在键盘上输出阶乘的个数 int i,x=1;//初始化单个阶乘的值 if(n&gt;0 &amp;&amp; n&lt;=50){//n为正整数并且大于0小于等于50 for(i=1;i&lt;=n;i++){
x=x*i;//单个阶乘的值 s=s+x;//总阶乘的和的值 }
printf("%d %d",x,s);//输出，单个阶乘的值，和总阶乘的和的值 }
return 0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4964d7cb2bc85ea35f7d60586c0ec248/" rel="bookmark">
			输入两个数，输出两个数的和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt;
int main(){
int a,b,c;
scanf("%d %d",&amp;a,&amp;b);
c=a+b;
printf("%d+%d=%2d",a,b,c);
return 0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2626eb7cc54f4cf3c7bd4c74bd47c9a6/" rel="bookmark">
			用C语言写一元二次方程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;Stdio.h&gt;
#include &lt;math.h&gt;
int main(){
double a,b,c,d,e,x1,x2;
scanf("%lf %lf %lf",&amp;a,&amp;b,&amp;c);
d = b*b-4*a*c;
e=sqrt(d);
if(d&lt;0){
printf("此方程无实根!");
}else if(d==0){
printf("此方程有两个相等的实根!\n");
x1=(-b)/(2.0*a);
x2=x1;
}else{
x1=(-b+e)/(2.0*a);
x2=(-b-e)/(2.0*a);
}
printf("x1=%7.2f\nx2=%7.2f\n",x1,x2);
return 0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e31849816bcad6a60348991e5e5a61ac/" rel="bookmark">
			css选择器和css特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		css选择器 1. 核心选择器
id选择器
利用了html元素的id属性，唯一
一个标签上只能有一个id选择器
一个id选择器只能选中一个标签
#one {} 选中id为one的元素 class选择器
利用html元素的class属性，非唯一；
类名可以由数字，字母和下划线，中划线组成，不能以数字或者中划线开头；
一个标签可以同时有多个类名，类名之间以空格隔开；
&lt;div class="red big"&gt;&lt;/div&gt; 一个类选择器可以同时选中多个标签
.box {} 选中class为box的元素 标签选择器
利用标签名进行选择
div {} 选中所有的div元素
通配符选择器
*{ } 选中页面所有标签 ，标签默认样式，一般用于清除标签的默认margin和padding
并且选择器
div.box {} 选中div元素，并且这个div的class为box
和选择器
div,.box{} 选中div元素和class为box的元素
普遍选择器
选中所有元素 *{ }
2. 层次选择器( 两个选择器配合使用)
子选择器
通过父元素选择子元素
&gt;
.menu &gt; li {} 后代选择器
空格
.menu li {} &lt;ul class="menu"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; 兄弟选择器
符号 ~ : 当前元素之后的所有兄弟
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e31849816bcad6a60348991e5e5a61ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/618bde653e16d1c230bcafdeed44210a/" rel="bookmark">
			用H5打开微信小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从浏览器，QQ等场景，用H5链接打开微信小程序！！！
1、首先登录微信小程序后台：
代码生成，通过在服务端调用 urlscheme.generate 接口生成 url sheme。微信小程序后台→工具→微信生成小程序URL Scheme；(不能生成永久URL Scheme，功能废弃) 2、生成后会获得一个链接
weixin://dl/news/?t=xxxxxxx
3、然后创建demo.html文件，建立页面，把weixin链接改成你上面得到的链接
&lt;!DOCTYPE html&gt; &lt;html lang="zh"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;title&gt;H5打开小程序&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p style="text-align: center"&gt;自动跳转小程序&lt;/p&gt; &lt;/body&gt; &lt;script&gt; //点击事件再说 location.href = "weixin://dl/news/?t=xxxxxxx"; &lt;/script&gt; &lt;/html&gt; 4、把demo.html页面上传到你的服务器网站目录中，直接访问你的服务器链接
就会自动弹出是否跳转打开微信，然后会自动打开你的小程序。
5参考
生成Url Schene的方法
https://developers.weixin.qq.com/community/develop/doc/000aeab88a4ea0c5c89d81fde5b801?source=templateb&amp;page=1#comment-list
https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/url-scheme/urlscheme.generate.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a64a3c5c805afac47b9c9dac47a4d29b/" rel="bookmark">
			嵌入式作业RTOS编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.使用CubeMX建立STM32的Hal库
1.创建项目和选择芯片
2.配置RCC和SYS
​编辑
3.设置GPIO端口
4.设置串口USART1 5.设置工程 ​编辑
6.打开工程和修改代码
二.准备移植uCOSIII 源码
1.下载uCOSIII源码，打开目录如下
2.移植前准备
1.为uC-BSP文件夹新建bsp.c和bsp.h文件
2.给文件夹uC-CONFIG添加以下文件 ​编辑3.将uCOS相关文件复制到HAL工程的MDK-AMR文件夹下
三.开始移植
1.将uCOS文件添加到项目 2.为bsp.c和bsp.h添加代码
3.修改main函数 4.修改其余文件部分代码
5.参数配置
四.实现三个任务
五.总结 六.参考资料
前言
软件版本: STM32CubeMX:6.61
KEIl:5.61
mcusip
FireTools
uCOSIII源码
硬件: STM32F103C8T6
一.使用CubeMX建立STM32的Hal库 1.创建项目和选择芯片 2.配置RCC和SYS 3.设置GPIO端口 设置PC13为GPIO_Output用于点亮LED灯
4.设置串口USART1 5.设置工程 6.打开工程和修改代码 点击生成代码，并在Keil中打开该工程。
在main函数中的while循环里添加语句
while (1) { /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET); HAL_Delay(500); HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET); HAL_Delay(500); } /* USER CODE END 3 */ 二.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a64a3c5c805afac47b9c9dac47a4d29b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f034ceb31b44e2c4ef5347b333ae0f75/" rel="bookmark">
			Makefile中调试打印方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用info/warning/error增加调试信息 # 1、info 是不带行号的 $(info “here is debug") # 2、warning 是带行号的 $(warning “here is debug") # 2、error 停止当前makefile的编译 $(error “here is debug") 使用echo输出变量：
ARCH ?= arm mytest: @echo 'ARCH='$(ARCH) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdfc7e3a66c5aaeda8a51f558b3a15ee/" rel="bookmark">
			网络基础之ARP协议工作原理与功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、ARP协议工作原理
二、ARP协议功能
一、ARP协议工作原理 地址转换协议ADDRESS Resolution Protocol（ARP）工作在osi七层参考模型的第三层网络层，常用命令为ARP -a显示mac缓存表以及ARP -d 清除mac缓存表内容。
工作原理：
①在同一局域网内主机A要和主机B通信，首先会查询自己的ARP缓存表中有没有主机B的信息，若有则直接通信。ARP缓存表中初始状态为空。
②若没有则主机A进行广播寻找主机B。
③主机B收到广播后通过单播方式回复主机A，我是主机B并把mac地址xx-xx-xx-xx-xx-xx返回给主机A，其余非主机B主机收到广播则丢弃包。
④主机A得到主机B回复后将主机B的mac地址记录在缓存表中，下次可直接通信。
二、ARP协议功能 ①地址转换功能将IP地址转换为mac地址。
②检测地址冲突
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc522fa7e9b82f83976bf0b86fb3d0f9/" rel="bookmark">
			虚拟机字节码执行引擎——动态类型语言支持
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
动态类型语言
Java与动态类型
java.lang.invoke包
invokedynamic指令
实战：掌控方法分派规则
随着JDK 7的发布的字节码首位新成员——invokedynamic指令。这条新增加的指 令是JDK 7的项目目标：实现动态类型语言（Dynamically Typed Language）支持而进行的改进之一， 也是为JDK 8里可以顺利实现Lambda表达式而做的技术储备。
动态类型语言 动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编 译期进行的，满足这个特征的语言有很多，常用的包括：APL、Clojure、Erlang、Groovy、 JavaScript、Lisp、Lua、PHP、Prolog、Python、Ruby、Smalltalk、Tcl。
如C++和Java等就是最常用的静态类型语言。
Java与动态类型 Java虚拟机层面对动态类型语言的支持一直都还有所欠缺，主要表现在方法调用方 面：JDK 7以前的字节码指令集中，4条方法调用指令（invokevirtual、invokespecial、invokestatic、 invokeinterface）的第一个参数都是被调用的方法的符号引用（CONSTANT_Methodref_info或者 CONSTANT_InterfaceMethodref_info常量）。
方法的符号引用在编译时产生，而动态类型语言只有在运行期才能确定方法的接收者。这样，在Java虚拟机上实现的动态类型语言就不得不使用“曲线救国”的方式（如编译时留个占位符类型，运行时动态生成字节码实现具体类型到占位符类型的适配）来实现，但这样势必会让动态类型语言实现的复杂度增加，也会带来额外的性能和内存开销。因此，在Java虚拟机层面上提供动态类型的直接支持就成为Java平台发展必须解决的问题
java.lang.invoke包 Java语言没有办法单独把一个函数作为参数进行传递。普遍的做法是设计 一个带有compare()方法的Comparator接口，以实现这个接口的对象作为参数，例如Java类库中的 Collections::sort()方法就是这样定义的： void sort(List list, Comparator c)
一种新的动态确定目标方法的机制，称为“方法句柄”（Method Handle）。
在拥有方法句柄之后，Java语言也可以拥有类似于函数指针或者委托的方法别名这样的工 具了。代码清单8-12演示了方法句柄的基本用法，无论obj是何种类型（临时定义的ClassA抑或是实现 PrintStream接口的实现类System.out），都可以正确调用到println()方法。
import static java.lang.invoke.MethodHandles.lookup; import java.lang.invoke.MethodHandle; import java.lang.invoke.MethodType; /** * JSR 292 MethodHandle基础用法演示 * @author zzm */ public class MethodHandleTest { static class ClassA { public void println(String s) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc522fa7e9b82f83976bf0b86fb3d0f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02d9d018c9264078b62294a20b75c5fc/" rel="bookmark">
			面试金典15（Python）—— 回文链表（简单）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回文链表 概述：编写一个函数，检查输入的链表是否是回文的。 输入： 1-&gt;2 输出： false 输入： 1-&gt;2-&gt;2-&gt;1 输出： true 方法一：列表+翻转 思路：建立一个空列表，遍历链表所有节点。最后对列表翻转判断即可。 # 列表+翻转 # 建立一个空列表，遍历链表所有节点。 # 最后对列表翻转判断即可。 class Solution: def isPalindrome(self, head: ListNode) -&gt; bool: stack = [] while head != None: stack.append(head.val) head = head.next return stack == stack[::-1] 方法二：双指针 思路：该算法是经典的回文数算法。首先遍历链表，添加所有节点。然后定义左右（头尾）两个指针，对列表进行判断。若相等，范围缩小，若不等，返回即可。 # 双指针 # 该算法是经典的回文数算法。首先遍历链表，添加所有节点。 # 然后定义左右（头尾）两个指针，对列表进行判断。 # 若相等，范围缩小，若不等，返回即可。 class Solution: def isPalindrome(self, head: ListNode) -&gt; bool: stack = [] while head != None: stack.append(head.val) head = head.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02d9d018c9264078b62294a20b75c5fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/089615be4a5669f885f284839996165f/" rel="bookmark">
			python数据结构——二叉树（一）遍历方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树是一种最简单的树形结构，二叉树的定义是用递归的方式
二叉树具有五种基本形态:
1．空二叉树。
2．只有一个根结点。
3．根结点只有左子树。
4．根结点只有右子树。
5．根结点既有左子树又有右子树。
特点：
树中每个结点至多关联到两个后继结点，一个结点的关联结点数可以为0、1或2一个结点关联的后继结点明确地分左右,或为其左关联结点,或为其右关联结点。 在一棵二叉树中,如果所有分支节点都有左孩子节点和右孩子节点，并且叶节点都集中在二叉树的最下一层，这样的二叉树称为满二叉树。一棵高为h，且有2^h-1个节点的二叉树称为满二叉树。
满二叉树图
若二叉树中最多只有最下面两层的节点的度数可以小于2，并且最下面一层的叶节点都依次排列在该层最左边的位置上，则这样的二叉树称为完全二叉树.
尽管它不是满二叉树，但是编号是连续的,所以它是完全二叉树。
完全二叉树图
二叉树的系统化遍历有多种可能的方式。遍历二叉树的状态搜索，以根为起始点，存在两种基本方式:
深度优先遍历，顺着一条路径尽可能向前探索，必要时回溯。对于二叉树，最基本的回溯情况是检查完一个叶结点。由于无路可走，只能回头。宽度优先遍历，在所有路径上齐头并进。 按深度优先方式遍历一棵二叉树，需要做三件事：遍历左子树、遍历右子树和访问根结点
遍历顺序(这里假定了总是先处理左子树，否则就是6种):
按先根序遍历二叉树得到的结点序列称为其先根序列。
按后根序遍历二叉树得到的结点序列称为其后根序列。
按对称序遍历二叉树得到的结点序列称为其对称序列（中根序列)。
先根序遍历(按照 DLR顺序)。 中根序遍历(按LDR)，也称对称序。 后根序遍历(按LRD)。 宽度优先遍历
宽度优先是按路径长度由近到远地访问结点。对二叉树做这种遍历，也就是按二叉树的层次逐层访问树中各结点，这样遍历产生的结点序列称为二叉树的层次序列。与状态空间搜索的情况一样，这种遍历不能写成一个递归过程。
class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # 用列表递归创建二叉树 def createTree(root, list_n, i): if i &lt; len(list_n): if list_n[i] == 'null': return None else: root = TreeNode(val=list_n[i]) root.left = createTree(root.left, list_n, 2 * i + 1) root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/089615be4a5669f885f284839996165f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/989d874e9a8aad026d3cd08ceba699bf/" rel="bookmark">
			面试金典14（Python）—— 链表求和（中等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链表求和 概述：给定两个用链表表示的整数，每个节点包含一个数位。这些数位是反向存放的，也就是个位排在链表首部。编写函数对这两个整数求和，并用链表形式返回结果。 输入：(7 -&gt; 1 -&gt; 6) + (5 -&gt; 9 -&gt; 2)，即617 + 295 输出：2 -&gt; 1 -&gt; 9，即912 输入：(6 -&gt; 1 -&gt; 7) + (2 -&gt; 9 -&gt; 5)，即617 + 295 输出：9 -&gt; 1 -&gt; 2，即912 方法一：字符串+新链表 思路：该思路非常简单，首先对两个链表单独求和。然后建立一个新的链表，逆序循环，依次存储即可。 # 字符串+新链表 # 该思路非常简单，首先对两个链表单独求和。 # 然后建立一个新的链表，逆序循环，依次存储即可。 class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: num_l1, num_l2 = 0, 0 i, j = 0, 0 while l1 != None: num_l1 += (l1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/989d874e9a8aad026d3cd08ceba699bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a4cb0e0251c4e68fb0514b5c53de909/" rel="bookmark">
			【UV打印机】RYPC打印软件配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 00. 目录 文章目录 00. 目录01. 概述02. PCS配置文件03. 系统参数配置文件04. 波形文件05. 附录 01. 概述 我们经常遇到这样一个问题，当我们装一台新机器的时候，需要重新设置机器的参数。其实为了提高工作效率我们可以直接将相同机型的配置参数文件覆盖即可。下面我们来讲解哪些文件是配置文件。
02. PCS配置文件 在PCS中主要是喷头物理位置、通道设置、专色和供墨的设置等等相关信息。
其配置文件如下图所示：
03. 系统参数配置文件 系统参数配置文件就是打印控制软件中所有的参数保存的二进制文件。重新启动软件的时候会读取该文件的数据。
04. 波形文件 波形文件就是驱动喷头的电压文件。
05. 附录 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d17ba583458a1af086197cd43c49d5d3/" rel="bookmark">
			组件-ulog
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、ulog 简介
1.1、特性
1.2、架构
1.3、配置选项
1.3.1、配置项
1.3.2、宏
1.4、日志级别
1.4.1、不使用ULOG_USING_SYSLOG
1.4.2、使用ULOG_USING_SYSLOG
1.4.3、静态级别与动态级别
1.4.4、全局级别与模块级别
1.4.5、设定日志的输出级别
1.5、日志标签
2、日志输出
2.1、宏 LOG_X(...)
2.2、ulog_x(LOG_TAG, __VA_ARGS__)
2.3、LOG_RAW()和ulog_raw()
2.4、LOG_HEX()和ulog_hex()
2.5、接口函数
2.5.1、ulog_raw()函数
2.5.2、ulog_hexdump()函数
2.5.3、ulog_output()函数
2.6、内部函数
2.6.1、output_lock()函数
2.6.2、output_unlock()函数
2.6.3、get_log_buf()函数
2.6.4、do_output()函数
2.6.5、ulog_output_to_all_backend()函数
2.6.6、ulog_voutput()函数
2.6.7、ulog_flush()函数
3、设置日志格式
3.1、函数
3.1.1、ulog_head_formater()函数
3.1.2、ulog_tail_formater()函数
3.1.3、ulog_hex_formater()函数
3.1.4、ulog_formater()函数
4、动态过滤器
4.1、接口函数
4.1.1、ulog_tag_lvl_list_get()函数
4.1.2、ulog_global_filter_lvl_set()函数
4.1.3、ulog_global_filter_lvl_get()函数
4.1.4、ulog_global_filter_tag_set()函数
4.1.5、ulog_global_filter_tag_get()函数
4.1.6、ulog_global_filter_kw_set()函数
4.1.7、ulog_global_filter_kw_get()函数
4.1.8、ulog_tag_lvl_filter_set()函数
4.1.9、ulog_tag_lvl_filter_get()函数
5、异步输出
5.1、异步模式的优缺点
5.1.1、优点
5.1.2、缺点
5.2、结构体
5.2.1、rt_ulog结构体
5.2.2、ulog_frame结构体
5.3、函数
5.3.1、ulog_async_output_enabled()函数
5.3.2、ulog_async_output()函数
5.3.3、ulog_async_waiting_log()函数
5.3.4、async_output_thread_entry()函数
5.3.5、ulog_async_init()函数
6、中断输出
7、后端
7.1、ulog_backend结构体
7.2、接口
7.2.1、ulog_backend_register()函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d17ba583458a1af086197cd43c49d5d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76c2ad95bc6deea353a505588efe795c/" rel="bookmark">
			python自带的idle以及pycharm使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者介绍：
♥️作者：小刘在C站
♥️每天分享课堂笔记，一起努力，共赴美好生活！
♥️夕阳下，是最美的绽放。 目录
一.python自带的idle
二.ipython
ipython介绍
ipython安装步骤
ipython使用
三.pycharm介绍
四.pycharm安装
步骤2
​编辑
步骤3
五.pycharm汉化教程
步骤1
​编辑
步骤2
步骤3
步骤4
步骤5
​编辑
步骤6
六.为pycharm安装解释器
步骤1
步骤二
步骤3
步骤4
步骤5
一.python自带的idle python有一个自带的简化是编辑器，就是IDLE可以在开始位置搜索IDEL即可，
以下便是python自带的IDEL
二.ipython ipython介绍 IPython是一个交互式计算系统。主要包含三个组件：增加的交互式 “Python shell”，解耦的双过程通信模型，交互式并行计算的架构。支持变量自动补全，需要在pip安装
ipython安装步骤 win+R打开运行框输入cmd，进入命令行，输入命令，pip install ipython即可安装
ipython使用 如果需要使用，在命令行输入ipython就即可使用
三.pycharm介绍 PyCharm是一种Python IDE（Integrated Development Environment，集成开发环境），带有一整套可以帮助用户在使用Python语言开发时提高其效率的工具，比如调试、语法高亮、项目管理、代码跳转、智能提示、自动完成、单元测试、版本控制。此外，该IDE提供了一些高级功能，以用于支持Django框架下的专业Web开发。
四.pycharm安装 可以在Download PyCharm: Python IDE for Professional Developers by JetBrains官网下载
步骤1
进入官网以后选择右边的Download社区版本安装（不收费）点击即可安装。
步骤2 下载完毕点击运行即可，安装没有过多的教程，一直点击下一步就可以，
步骤3 等待进度条加载完毕
五.pycharm汉化教程 步骤1 打开PyCharm软件，默认显示英文界面。
步骤2 点击“file”选项，然后点击“setting”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76c2ad95bc6deea353a505588efe795c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a47192c5910f0779f8c3ba118d6948d8/" rel="bookmark">
			C&#43;&#43;设计实现日志系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.为什么需要日志 为什么需要日志？其实在引言中已经提到了，实际的软件项目的几乎每个过程，都离不开日志。初学代码时，Jungle的第一行代码是实现打印“hello world”，打印到控制台。在后来的学习中，Jungle又学会了设断点调试代码，在适当的地方通过断点来观察变量的值。但在实际的软件项目中，试想一下，通过输出到控制台或者通过设断点来调试代码，可能吗？
客户现场，会让你现场打印到控制台上调试吗？报了error的软件项目，你能够明确知道软件crash的位置吗？你能保证设断点可以还原error时候的现场吗？概率性的error事件，设断点还奏效吗？如果是时效性的代码（比如USB连接） ，设断点调试还合理吗？…… 日志，可以记录每一时刻软件的运行情况，记录error或者crash时的信息（时间、关键变量的值、出错位置、线程等）；另一方面，对于概率性error事件，可以在重复测试时通过日志来查询错误复现时候的情况。简言之，日志是跟踪和回忆某个时刻或者时间段内的程序行为进而定位问题的一种重要手段。
2.日志系统设计 软件运行过程中，需要记录的有什么呢？前述已经提到，关键变量的值、运行的位置（哪个文件、哪个函数、哪一行）、时间、线程号、进程号。本文Jungle采用C++设计了LOG类，介绍LOG类的设计之前，需要提及的是log的级别和log位置。
2.1.1.log级别
Log级别是什么意思呢？在开发阶段，Jungle可能想尽可能详细地跟踪代码运行过程，所以可以打印尽可能多的信息到日志文件中；测试过程中，测试部可能不需要这么详细的信息，所以这时候有的信息可能不必输出到Log文件；产品交付客户使用时，为了软件运行更快、客户体验更好，这时候就只需打印关键信息到日志文件了，因为过多的写文件会耗费大量时间，影响软件运行速度。所以Jungle为LOG类定义了如下级别：
enum LOGLEVEL { LOG_LEVEL_NONE, LOG_LEVEL_ERROR, // error LOG_LEVEL_WARNING, // warning LOG_LEVEL_DEBUG, // debug LOG_LEVEL_INFO, // info	}; 在软件设计中，可以通过某些方法或者预留一些开关来设置Log级别，方便在开发、调试、测试和客户现场灵活地调整日志级别，以获取到有用的日志信息。
2.1.2.log输出位置
Log文件可以输出到控制台（其实也是不错的方法），也可以输出到指定路径下的某个文件里，也可能有别的需求。比如，开发或调试时，简单的信息直接就打印到软件某个界面上；测试或者交付客户时，最好将日志保存到文件里，这样可以保存尽可能多的信息。因此，Jungle进行了如下设计：
enum LOGTARGET { LOG_TARGET_NONE = 0x00, LOG_TARGET_CONSOLE = 0x01, LOG_TARGET_FILE = 0x10 }; 2.1.3.log的作用域
一个软件系统，要在哪儿输出日志呢？Everywhere！只要是你想打印日志的地方，任何一个函数、任何一个文件，都应该而且必须可以打印。也就是说这个log类的对象（不妨叫做日志记录器），日志记录器必须是全局的！
光是全局的就够了吗？你这个文件里有一个全局的日志记录器，输出日志到file.log文件里；另一个文件里也有一个日志记录器，也输出到file.log文件里……多个日志记录器同时往一个文件里写日志，这显然不合理。所以还必须保证日志记录器全局且唯一！
怎么保证日志记录器唯一呢？即Log类在具体的软件系统中有且仅有一个实例化对象。答案是采用单例模式！（设计模式（九）——单例模式）
2.2.日志类的设计 综上所述，Jungle设计的日志类LOG如下：
class LOG { public: // 初始化 void init(LOGLEVEL loglevel, LOGTARGET logtarget); // void uninit(); // file int createFile(); static LOG* getInstance(); // Log级别 LOGLEVEL getLogLevel(); void setLogLevel(LOGLEVEL loglevel); // Log输出位置 LOGTARGET getLogTarget(); void setLogTarget(LOGTARGET logtarget); // 打log static int writeLog( LOGLEVEL loglevel, // Log级别 unsigned char* fileName, // 函数所在文件名 unsigned char* function, // 函数名 int lineNumber, // 行号 char* format, // 格式化 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a47192c5910f0779f8c3ba118d6948d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24abd4210773fbea54ea5900226c5bc7/" rel="bookmark">
			MATLAB textscan之模式匹配用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB textscan之模式匹配用法详解 笔者在实际使用MATLAB的textscan函数去读取txt文档时，会需要跳过文档中某些字符串。使用模式匹配方法可以跳过或者寻找特定字符串。
给出一段字符串数组，例如：
test01 = '[Hello World!]'; 首先进行读取匹配(%[…])。
读取’Hello’部分:
ans01 = textscan(test01,'%[Helo]'); ans02 = textscan(test01,'[%[loHe]'); ans03 = textscan(test01,'%[]Helo]'); ans04 = textscan(test01,'[%[**Helo**]'); 得到
ans01{1,1} = {'[Hello'}; ans02{1,1} = {'Hello'}; ans03{1,1} = {'['}; ans04{1,1} = {'Hello'}; 可以看到，在实际读取时，只有ans02和ans04达成目的。因此，在读取匹配时，%[***]中的星号无论个数，顺序，是否重复。只要包含需要读取的字符，即可读取到目标。
在有[]包括的内容时，需要将中括号左半边写在%前即可。
下面是排除匹配部分(%[^])
读取’Hello’部分:
ans01 = textscan(test01,'%[^World! ]'); ans02 = textscan(test01,'%[^ ]'); ans03 = textscan(test01,'[%[^ W]'); ans04 = textscan(test01,'[%[^*** W]'); 得到
ans01{1,1} = {'[He'}; ans02{1,1} = {'Hello'} {'World!]}; ans03{1,1} = {'Hello'}; ans04{1,1} = {'Hello'}; ans03和ans04成功了。在排除匹配时，中括号中的字符串开始均会被排除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb8b576082f066d0a52f7a83ccce9078/" rel="bookmark">
			IP地址和子网掩码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
IP地址
什么是IP地址
IP地址分类（有类编制）
私网地址
特殊地址
子网掩码
计算出子网掩码
判断对方主机是否在同一网段
IP地址 什么是IP地址 IP地址分为网络位和主机位
网络位：类似于区号，用来区分你所在的网络地址（区号 区分你所在的城市）
主机位：一台主机的所在位置
网络位一定在高位，主机位一定在低位
（网络位比如是小区名，主机位就是住户 例如5栋1单元502）
IP地址分类（有类编制） A类 固定前8位为网络位，后24位主机位
B类 固定前16位为网络位，后16位主机位
C类 固定前24位为网络位，后8位主机位
私网地址 10.0.0.0~10.255.255.255
172.16.0.0~172.31.255.255
192.168.0.0~192.168.255.255
特殊地址 0.0.0.0
0.0.0.0不是一个真正意义上的IP地址，它表示所有不清楚的主机和目的网络（代表热任意地址）
255.255.255.255
广播地址。对本机来说，这个地址指本网段内（同一广播域）的所有主机
127.0.0.0~127.255.255.255 保留地址
本机回环地址，主要用于测试。在传输介质上永远不应该出现目的地址为“127.0.0.0”的数据包（自己）
224.0.0.0~239.255.255.255
组播地址，224.0.0.1特指所有主机，224.0.0.2特指所有路由器，224.0.0.5指OSPF路由器，地址多用于一些特定的程序以及多媒体程序
169.254.x.x
如果Windows主机使用了DHCP自动分配IP地址，而又无法从DHCP服务器获取地址，系统会为主机分配这样的地（微软保留地址）
（1）人为的去IP地址
（2）通过技术手段自动让电脑自己获取IP地址（DHCP），出错会出现169.254.x.x（没有服务器）
子网掩码 计算出子网掩码 CIDR：无类域间路由，目前的网络已不再按A、B、C类划分网段，可以任意指定网段范围
CIDR无类域间路由表示法：IP/网络ID位数，如：172.16.0.100/16
netmask子网掩码：32位或128位（IPv6）的数字，和IP成对使用，用来确认IP地址中的网络ID和主机ID，对应网络ID的位为1，对应主机ID的位为0，例：255.255.255.0，表现为连续的高位为1，连续的低位为0
IP地址 分为两段，网络位和主机位，子网掩码，用来识别你的网络位，IP地址一共32位。
C类
192.168.1.0/4
11111111.11111111.11111111.0000 0000
网段位写1 主机位写0
255.255.255 0
A类
10.0.0.0/8
1111 1111.0000 0000.0000 0000.0000 0000
255.0.0.0
B类
172.0.0.0/16
1111 1111.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb8b576082f066d0a52f7a83ccce9078/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad130c8b17e0c0c67defde7560afebca/" rel="bookmark">
			python简单应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python简单应用
1、提高图片亮度
（可提高png、jpg、tif图片亮度。）
参考文章：python调节图像明暗亮度
import cv2 import numpy as np import matplotlib.pyplot as plt def imgBrightness(img1, c, b): rows, cols, channels = img1.shape blank = np.zeros([rows, cols, channels], img1.dtype) rst = cv2.addWeighted(img1, c, blank, 1-c, b) return rst img = cv2.imread('001.tif') dst = imgBrightness(img, 0.5, 0) dst2 = imgBrightness(img, 1.5, 0) 将cv2的图片下载到本地
参考文章：.tofile保存
cv2.imencode('.tif', dst2)[1].tofile(r'D:\dev\python\work\001_result.tif') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41c0b7ceddbd6c579a0401ef20cee90a/" rel="bookmark">
			onnxruntime android版build &amp; 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		onnx模型用在android平台上时，需要build onnxruntime for android
onnxruntime github
官方build for android文档
参考项目中有build好的libonnxruntime.so,
但是你可能需要自己编译，因为build的平台环境是不一样的。
你可以编译成静态库libonnxruntime.a 或者 动态库libonnxruntime.so
静态库可能有一个缺点就是里面会有method和其他库的method冲突，在项目build的时候就会check，然后报错。
然而动态库不会出现这种情况。
1.动态库编译： ./build.sh --android --android_sdk_path /home/user/Android/Sdk --android_ndk_path /home/user/Android/Sdk/ndk/21.4.XXXX --android_abi arm64-v8a --android_api 28 --use_nnapi --parallel --build_shared_lib --config MinSizeRel 解释一下参数：
–android表示build android版
android_sdk_path： 你的Sdk文件夹
android_ndk_path：Sdk下面的ndk文件夹(到版本文件夹下)，但是具体要看你的项目用的是哪个版本
android_api：看你的项目是哪个版本，具体在哪里可以查看参考官方build for android文档
parallel: 并行编译
build_shared_lib: 使用就是编译动态库，不使用就是静态库
config: 有4种选项[“Debug”, “MinSizeRel”, “Release”, “RelWithDebInfo”]，参考
build出来的.so文件会在onnxruntime/build/Android/MinSizeRel里，
把它copy到项目放动态库的文件夹里，
修改相关设置，CMakeLists.txt.
同时把onnxruntime/include整个文件夹放进项目里，
比如说需要用到
#include "onnxruntime/core/session/experimental_onnxruntime_cxx_api.h" 那么你的CMakeLists.txt和设置里需要include两个文件夹：onnxruntime/include 和 onnxruntime/include/onnxruntime/core/session
2. 静态库编译： 和动态库类似，只是不需要--build_shared_lib
./build.sh --android --android_sdk_path /home/user/Android/Sdk --android_ndk_path /home/user/Android/Sdk/ndk/21.4.XXXX --android_abi arm64-v8a --android_api 28 --use_nnapi --parallel --config MinSizeRel 但是这时MinSizeRel文件夹下并没有libonnxruntime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41c0b7ceddbd6c579a0401ef20cee90a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7876550889e5cda4d58f09493fdbff5d/" rel="bookmark">
			VMware vSphere8部署-尚文网络xUP楠哥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#安装ESXi8 安装所使用的ISO文件，UP楠哥已经提前准备好。
接下来，将已经下载好的ESXi 8.0的ISO加载到虚拟机环境里，资源配置参考如下。
需要注意的是，ESXi 8 引导的最低内存要求已从 4 GB增加到8GB。
引导ISO。
来到引导界面。
按F11键，同意接受并继续。
选择好本地盘进行安装。
选择语言，默认即可。
为root用户配置复杂性较高的口令。
按F11键继续安装ESXi8。
ESXi8安装ing…
ESXi8安装完成，重启。
重启后，从ESXi8开始引导。
万事俱备，只等登录。
根据IP或者FQDN进行登录ESXi Host Client。
ESXi Host Client登录界面，和之前的7版本界面体验上几乎无差别，还是较为熟悉的操作界面。
至此，ESXi8已经安装完成，可以重复以上步骤，安装另外一个节点的ESXi8。
#部署VCSA 将VCSA的ISO挂载到虚拟光驱中，找到vcsa-ui-installer目录中的win32目录，通过安装installer的形式部署VCSA。
可以切换语言，选择第一个安装。
点击下一步继续安装。
勾选接受，点击下一步继续安装。
这里vCenter server managing target appliance 填写的是把vcsa放在哪个esxi主机上的IP和用户名及密码。
所选的Esxi的SSL。
设置VCSA在Esxi的虚拟机名称和root用户口令。
根据实际需求选择部署大小。
选择所选Esxi的datastore数据存储，建议启用精简模式。
根据自己的实际环境配置网络环境。
注意：这里由于需要设置的细节较多，关系到VCSA部署搭建的成功，由于配置太多，这里先不附配置说明。
完成第1阶段配置。
部署第1阶段。
部署第1阶段完成。
紧接着，部署第2阶段。
做一些时间同步和ssh访问的配置。
配置SSO。
配置CEIP客户体验计划。
完成第2阶段配置。
部署第2阶段。
部署第2阶段完成。
至此，VCSA已经部署完成。通过浏览器打开https://VCSAIP或FQDN方式，以SSO进行登录。
登录后，创建数据中心、创建集群、将ESXi8加入到集群中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d00b6dff993b67d4d0718658cdec68e1/" rel="bookmark">
			C&#43;&#43;学习笔记(七)——学生信息管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
大致功能概况
具体代码实现
登录学生系统模块
创建学生信息模块
显示学生信息模块
保存学生信息模块
读取学生信息模块
增添学生信息模块
删除学生信息模块
查找学生信息模块
修改学生信息模块
插入学生信息模块
学生成绩排序模块
前言 前面已经学了C++的类和对象，对C++已经有了初步了解，为了加深对其应用，下面和大家一起学习编写学生信息管理系统。
大致功能概况 学生信息管理系统功能函数:
void menu();//主菜单void CreatStuInfo();//创建学生信息void GetStuFile();//将学生信息写入文件void ShowStu();//显示全部学生信息void PutStuFile();//将学生信息显示在终端上void AddStu();//增加学生信息void DeleteStu();//删除学生信息void FindStu();//查找学生信息void ModifyStu();//修改学生信息void InsertStu();//插入学生信息//void CountStu();//统计学生信息void SortStu();//按照学生成绩排序 单链表结点定义 struct Student_Node { int num; //学号 int age; //年龄 char name[20];//姓名 char sex[10]; //性别 char major[10];//专业 char born[10]; //出生日期 char address[20];//家庭住址 int Math; //数学成绩 struct Student_Node* next;//指针域 }; 学生类
class Student { public: Student() { head = new Student_Node; head-&gt;next = NULL; } void menu();//主菜单 void CreatStuInfo();//创建学生信息 void GetStuFile();//将学生信息写入文件 void ShowStu();//显示全部学生信息 void PutStuFile();//将学生信息显示在终端上 void AddStu();//增加学生信息 void DeleteStu();//删除学生信息 void FindStu();//查找学生信息 void ModifyStu();//修改学生信息 void InsertStu();//插入学生信息 //void CountStu();//统计学生信息 void SortStu();//按照学生成绩排序 private: struct Student_Node* head; }; 具体代码实现 登录学生系统模块 首先看运行结果:这里登录系统做的有点草率，大家可以限制登录次数或者已经有的账号，不允许再次注册等约束条件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d00b6dff993b67d4d0718658cdec68e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69bd633c1482078251a05173bb97ebad/" rel="bookmark">
			腾讯云控制台没有“应用管理”选项问题解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、检查镜像 首先：确定自己选择的是否为系统镜像
选择个人镜像则会导致控制台没有应用管理选项
目前应用管理选项只有选择应用镜像的服务器才有应用管理选项
还需注意的是某些镜像版本无应用镜像如基于centos7.6的应用镜像部分应用有提供windows系统版本 二、重置服务器 若登录轻量应用服务器控制台后没有应用管理页面。可以尝试在应用信息处重置为WordPress或者Discuz的应用。
三、终极大招 直接问客服吧，专业问题让专业人士来解决
（就是排队有点久，偶尔还有人“插队”，前面看着正在排队有13人后面正在排队人数变为14人，这不是插队是什么）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8daa69f3391e3ea8a2150139adbc9351/" rel="bookmark">
			02-Nginx安装与常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Nginx 的下载与安装
Nginx 的下载
安装 Nginx
A、 上传 Nginx
B、 安装 gcc
C、 安装依赖库
D、创建解压目录在/usr 下创建 apps 目录，用于存放解压后的安装包程序。
E、 解压 Nginx
F、 生成 makefile
使 nginx 命令随处可用
​​​​​​​Nginx 命令
查看命令选项nginx -h
查看 Nginx 版本信息 nginx –v 或-V
测试配置文件命令nginx -tq
停止命令nginx –s stop/quit
平滑重启命令nginx –s reload
nginx –s reopen
nginx –p
启动命令nginx –c file
nginx –g
页面访问测试
关闭防火墙
浏览器访问
Nginx 的下载与安装 Nginx 的下载 nginx 的官网为： http://nginx.org。
Nginx 的源码安装
安装 Nginx A、 上传 Nginx 将下载好的 Nginx 上传到新复制的主机的/usr/tools 目录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8daa69f3391e3ea8a2150139adbc9351/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c4b66a944f2bc3f80846047be7cc5a3/" rel="bookmark">
			双系统安装ubuntu 22.04 LTS(一步到位)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一个拥有两次都是一次成功安装好双系统的经验的人，我觉得我可以借这个文章仔细讲述一下，让大家都可以双系统安装都是一次成功。为什么有着两次安装经验呢，第一次安装完成后由于电脑的内存不太够了，然后重新装了一个固态和机械硬盘，再次安装了双系统。由于我本人是没有截图的，所以借用了一些其他作者的图片。
双系统安装ubuntu,可以将步骤大致分为以下：
步骤：
一、制作启动硬盘
二、为Ubuntu分配磁盘空间
三、安装Ubuntu
在安装双系统之前，我十分建议大家先把这三个步骤先理清楚分别要干什么，然后再进行安装双系统。下面我将详细介绍这三个主要步骤：
制作启动硬盘：
1.下载ubuntu 22.04 LTS
首先在官网上下载ubuntu 22.04 LTS，Ubuntu下载官网
2.下载 UltraISO并制作启动U盘 UltraISO官网入口点免费下载试用，安装好后打开点击免费试用。
准备一个4G以上大小的U盘，制作过程中会格式化U盘，记得备份文件
选择好下载的UbuntuISO文件打开，点击【启动】→【写入硬盘映像】如图：
写入方式选择【USB-HDD+】
点击【写入】会弹出格式化U盘提示点击确定等待写入完成即可。
为Ubuntu分配内存：
在这个步骤，主要为ubuntu的四个部分分配内存，这四个部分在进行ubuntu安装的时候需要占用存储空间，所有此时分配出来的内存只是为了安装的时候有存储空间给这四个部分。
这四个部分分别是/boot、/swap、/、/home这四个部分，在这里我都用了、来分隔，这四个部分就是在最后ubuntu分配空间时候的命名。
分配步骤
/boot和、/swap可以分配一个空间，也可以单独分配，不知道我说清楚了没有，分配在一个空间的时候就分配一个大的空间，假设电脑内存是8G，那么分配8G+500M大小的一个整体空间就可以了，单独分配就是单独分配一个500M的空间，一个8G的空间，两个空间。需要在固态硬盘（也就是系统盘），这里指明一下，我是在C盘里面分配出来了一个整体的空间，当也可以试试装在D盘或者其他固态硬盘里边。
补充说明一下：/boot分区一般只需分出300M-500M的空间来作为启动引导文件（否则无法启动Ubuntu，具体原因百度），对于/swap分区的空间，电脑内存8G大小就分配内存两倍的空间,8G以上跟内存一样大或者稍大1、2个G。当然内存很大，分配更大的空间也没有问题。
然后是分配/和/home空间,这个就是越大越好了，也可以分配一个整体的空间，这里我给他们一块在机械硬盘里面分配了500G
总结：右键点击【此电脑】，选择【管理】→【磁盘管理】，选择想压缩的盘右键单击可以看到压缩卷，点进去就能看到可压缩大小，单位是MB，我在机械硬盘分了500G（400G用于/home,100G用于/）（这个根据你电脑拥有的内存来定，你内存分配的越大，那么后面使用系统的时候，能够存储的文件也就可以越多），固态硬盘分了34G大小（500M用于/boot,剩下的用于/swap）（这个根据你电脑内存实际大小来定）。分配好了内存下面就进行ubuntu 22.04LTS安装。
补充说明一下压缩硬盘的步骤:
鼠标选中需要进行压缩的卷（比如我的磁盘1中的autumn卷），右键 单击，然后选中 压缩卷，计算一段时间后，会弹出一个新的窗口，如下图所示：
前面说到，需要在 Windows10 系统盘上分出一块空间，大家根据自己的情况计算，然后在输入压缩空间量输入需要压缩的大小，然后单击压缩，如下图所示。提示：1G = 1024M
三、安装Ubuntu
这里需要做的是，在Bios系统里边，将U盘启动项设置为第一位就可以了。因为每一个电脑主板类型不一样，进入系统的方式也不一样吗，像我的是微星主板，进入bios方式是开机的时候，疯狂摁del键。也可以用另外一种方式进入BIOS，请自行百度，这里就不详细介绍了。
进入BIOS之后呢，将U盘设置为第一启动项就可以了。因为每个电脑的操作方式不太一样，只要你把它设置成功就可以，借用一下其他作者的图。大致上是跟下方一样的。
保存退出Bios系统之后就进入了Ubuntu安装，选择Try or Install ubuntu 接下来，正式进入系统安装阶段
选择语言及操作（根据个人需求选择）,选择中文简体就可以，喜欢英文也可以用英文，然后点击安装Ubuntu, 中文的就直显示中文了，界面如下：
键盘布局选择【Chinese】，然后点击继续。
由于我准备的硬盘大小充足，所以我选择【正常安装】，也可以选择【最小安装】不影响使用。其他的在图中，其他选项根据喜好选择就可以。
然后安装类型选择其他选择其他选项，这样才能给/home,/,/swap,/boot手动分配存储空间。 然后就需要，创建分区，这是最重要的一步，我的分区如下：
- 注意：先分逻辑区，再分主分区
1. /swap交换分区（虚拟内存），逻辑分区，我分了16GB（8G及以下RAM选择两倍大小，以上跟RAM大小一样就行）
2. /boot分区 ，逻辑分区，默认ext4。 我分了将近300M，放置Ubuntu的启动引导文件，
3. / 根分区（root分区），逻辑分区，我选择100G就可以，默认ext4，
4. /home分区，主分区，默认ext4，我选择400G，用户的所有文件都在这里。
分区这里没有什么太多技巧，按照上面说所说的，把四个区都分好就行了，记住输入的时候没有.,也就是输入从/开始，根分区只需输入/就好了。下面图中的空闲，你可以大致算一下，之前在Window分别分配了多少内存空间，然后跟这个上面的存储大小对应起来，可能与在Windows分配的差个10M，也可能相等，都是正常的
分配好了之后，直接点击现在安装，蹦出来是这样子的就安装对啦，选择了中文语言就显示中文，然后点击继续。
接下来，选择地点，这里随便设置，默认就可，然后单击继续
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c4b66a944f2bc3f80846047be7cc5a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bb3f10eed786a55915e199b76c72972/" rel="bookmark">
			uni.getLocation触发，打印不到东西
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		检查微信开发者工具版本号
微信小程序版本号2.17.0以下版本可实现打印功能
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca5fb97614b96e614d639b2cb6c99e6b/" rel="bookmark">
			栈的知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：栈是一个“先进后出”的一个数据结构
目录
一、基本概念：
1.定义：
2.基本操作：
3.栈的表示与实现
4.栈的应用
二、易错及重要的知识点:
一、基本概念： 1.定义： ·栈(stack)是一个特殊的线性表，是限定仅在一端（通常是表尾)，进行插入和删除操作的线性表。
·又称为后进先出(Last In First Out)的线性表，简称LIFO结构。 ·栈的逻辑结构与线性表相同，仍为一对一的关系。
2.基本操作： 对栈的基本操作有Push（进栈）和Pop（出栈），前者相当于插入元素，后者则是删除最后插入的元素。
3.栈的表示与实现 由于栈本身就是线性表，于是栈也有顺序存储和链式存储两种实现方式。
·栈的顺序存储--顺序栈（数组）
·栈的链式存储--链表
有关顺序栈的详情可点击上方链接
而链栈的出栈几乎等同于链表的插入，链栈出栈几乎等同于链表的删除（所以这里就不在赘述了，如有问题可在评论区留言）
4.栈的应用 括号匹配实验 表达式求值 注：以后会补这两个应用的博客。到时候会附上相应链接，请尽情期待！ 二、易错及重要的知识点: 栈为一种特殊的线性表。顺序栈中，判断是否为空栈 &lt;=&gt; S-&gt;top==-1。顺序栈中，判断是否栈满 &lt;=&gt; S-&gt;top==S-&gt;MAXSIZE-1。顺序栈中，栈的长度 &lt;=&gt; S-&gt;top+1。顺序栈的入栈以及出栈的时间复杂度都为O(1)。 大家记得点赞评论加收藏哦！！！
希望大家能多关注一下我哦！！！
我会不定期的更新关于数据结构的内容，或者大家有什么想让博主更新的知识点也可以在评论区留言哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6b3f16bfb61629314269b3f9f9ff39c/" rel="bookmark">
			VMware安装Centos7及静态IP网络配置详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载VMware及Centos7镜像 (1)、centos7镜像建议去国内各大镜像网站下载，centos官网下载可能很慢
国内常用镜像网站：
华为源：https://mirrors.huaweicloud.com
阿里源：https://developer.aliyun.com/mirror/
搜狐源：http://mirrors.sohu.com/
网易源：http://mirrors.163.com/
清华源：https://mirrors.tuna.tsinghua.edu.cn/
(2)、VMware版本：我这里下载的是15.0.2，下载完百度随便找一个激活码激活即可永久使用
下载地址：https://customerconnect.vmware.com/en/downloads/info/slug/desktop_end_user_computing/vmware_workstation_pro/15_0
二、VMware部署centos7流程 (1)、创建新的虚拟机，选择自定义创建，如果想省事就选择典型(典型其实就是有些配置VMware默认配置好了，不需要再配置了，而自定义则是所有的配置都需要自己去配置)
(2)、虚拟机兼容性配置，高版本虚拟机不可以向下兼容低版本的VMware，低版本的虚拟机可以向上兼容高版本的VMware。
(3)、选择部署的centos7的镜像文件，这边先选择稍后导入镜像
(4)、选择需要安装的操作系统版本
(5)、配置虚拟机名称和存储位置，虚拟机名称就是一个名字，在虚拟机多的时候方便自己找到。
(6)、配置虚拟机的CPU数量和内核数量，处理器分配要根据自己的实际需求来分配。在使用过程中CPU不够的话是可以再增加的
(7)、配置虚拟机的内存大小，一般不要超过宿主机的一半，分配过高会影响宿主机的性能
(8)、配置虚拟机的网络配置
虚拟机网络分四类：
1.桥接网络：
宿主机和虚拟机处于平级状态，自身可以通过路由器访问到互联网，虚拟机所有网络功能几乎与网络中的真实机器完全相同。
2.NAT模式
NAT模式下，虚拟机需要通过宿主机才能连接到互联网，在NAT模式下，虚拟机的网卡连接到主机的VMnet8，然后通过VMnet8来回发送数据。
3.Host-only（仅主机）
在Host-only模式下，虚拟机的网卡会连接到主机VMnet1，但主机系统不为虚拟机提供任何路由服务，因此虚拟机只能与主机通信，不能连接到实际网络，即不能访问互联网。
NAT模式是一种比较简单的实现虚拟机上网的方式，所以我们将网络模式设置成NAT模式。
(9)、配置I/O控制器类型和磁盘类型，此处均以默认配置即可
(10)、配置虚拟机磁盘，包括虚拟机磁盘大小及存储模式。
磁盘容量暂时分配100G即可后期可以随时增加，不要勾选立即分配所有磁盘，否则虚拟机会将100G直接分配给CentOS，会导致宿主机所剩硬盘容量减少。 勾选将虚拟磁盘拆分成多个文件，这样可以使虚拟机方便用储存设备拷贝复制。
(11)、磁盘文件命名，自定义设置即可
(12)、至此虚拟机部署前期配置已完成。
(13)、设置centos镜像文件
选中刚刚创建的虚拟机，点击编辑虚拟机设置，进入后选择CD/DVD(IDE)，然后选择"使用ISO映像文件"，设置镜像文件的路径，保存即可。
三、启动虚拟机 选择install centos7，然后回车确定
设置时间：亚洲时间Asia，时区选择上海shanghai
安装方式：选择mini install
硬盘设置：进去之后点两下done，一定要点两下
网络设置，打开两个网卡的开关
然后点击安装
设置root用户密码：左边一个
设置完成就等他安装完成就好了
四、虚拟机静态IP网络配置 一、VMware及本地网络设置 首先，打开VMware主界面，点击上方工具栏 编辑-虚拟网络编辑器，查看当前VMnet信息
在这里可以看到有三种类型，分别是桥接模式，仅主机模式和NAT模式。和上面讲的一样：
桥接模式：在当前网络分配一个独立的IP给虚拟机，可与其他终端直接通信
仅主机模式：虚拟机仅可与主机通信
NAT模式：由VMware创建一个虚拟的NAT网关，虚拟机与外网通信时会将IP地址转换为主机IP，其 他终端无法直接与虚拟机通信
1、由于此处我们设置的是NAT的网络类型，所以我们选择VMnet8网卡，点击更改设置。
2、 进入更改界面后再次选择VMnet8网卡，去掉"使用本地DHCP服务将IP地址分配给虚拟机"前面的勾，这个是动态分配IP的，子网IP和子网掩码保持不变，点击NAT设置
3、在这里我们可以看到三个重要的网络信息，分别是子网IP，子网掩码和网关IP：
子网IP：标识NAT模式下的所有子网，该模式下的所有子网地址需在此网段下
子网掩码：划分网络号与主机号
网关：虚拟NAT设备地址
我们需要记住这些信息！！！不需要改变！！！
4、打开本地电脑的网络设置，选择VMnet8网卡，右键属性，配置IPV4的的属性
选择使用下面的IP地址，IP地址填写和第三步中的子网IP同一网关的任意IP即可，子网掩码和默认网关为第三步中的子网掩码和网关IP，再配置静态的DNS，国内公网的都行
2、centos7中的网络设置 #虚拟机网络配置文件 vi /etc/sysconfig/network-scripts/ifcfg-ens33 修改完成后重启虚拟机网络
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6b3f16bfb61629314269b3f9f9ff39c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fc7caf98d7951819c5fce85acd27de8/" rel="bookmark">
			apt-get install 连同诸多依赖包一并安装的指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 apt-get install 连同诸多依赖包一并安装 如题，apt-get安装某个包的时候，经常会碰到很多依赖包，需要一一安装了才行，非常麻烦。当然，可以使用以下指令一步到位
apt-get install --install-suggests package 如果遇到个别包的版本兼容问题，具体如下：
Depends: XXX（=YYY） but ZZZ is to be installed
例如：
zlib1g (= 1:1.2.8.dfsg-2ubuntu4.3) but 1:1.2.11.dfsg-0ubuntu2 is to be installed 解决方法：
apt-get install --reinstall zlib1g=1:1.2.8.dfsg-2ubuntu4.3 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6930ab5811abc99f0a48cb85decb930/" rel="bookmark">
			牛顿迭代法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、牛顿迭代公式
二、利用牛顿迭代公式求平方根
C 语言实现
Python 语言实现 三、利用牛顿迭代公式求立方根
C 语言实现
Python 语言实现
一、牛顿迭代公式 多数方程不存在求根公式，因此求精确根非常困难，甚至不可解，从而寻求方程的近似根就显得尤为重要。牛顿就提出了一种用迭代求方程近似根的方法，思路是不断取切线，用线性方程的根逼近非线性方程 f(x) = 0 的根。
具体过程：
设 x* 是 f(x) = 0 的根，选取 x0 作为 x* 的初始近似值，过点 (x0，f(x0)) 作曲线 y = f(x) 的切线 L，L：y = f(x0) + f'(x0)(x - x0)，则 L 与 x 轴交点的横坐标为：，称 x1 为 x* 的一次近似值。过点 (x1, f(x1)) 作曲线 y = f(x) 的切线，切线与 x 轴的交点横坐标为：，称 x2 为 x* 的二次近似值。重复上述过程，得 x* 的近似值序列，其中： 称为 x* 的 n + 1 次近似值，上式称为牛顿迭代公式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6930ab5811abc99f0a48cb85decb930/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/830ac0b9b80e05f01d72dd9359e68644/" rel="bookmark">
			我是这样学统计学的，标准差和标准误关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标准差 标准差是方差的平方根。标准差能反映一个数据集的离散程度，标准偏差越小，这些值偏离平均值就越少，反之亦然。标准偏差的大小可通过标准偏差与平均值的倍率关系来衡量。平均数相同的两个数据集，标准差未必相同。
例如，A、B两组各有6位学生参加同一次语文测验，A组的分数为95、85、75、65、55、45，B组的分数为73、72、71、69、68、67。这两组的平均数都是70，但A组的标准差应该是17.078分,B组的标准差应该是2.160分，说明A组学生之间的差距要比B组学生之间的差距大得多。
总体标准差 已知随机变量 X 的数学期望为μ缪，标准差为σ西格玛，则其方差为：
此处σ即为随机变量X的总体标准差。
样本标准差 上面的式子中，我们需要准确的了解随机变量 X的总体分布，从而可以计算出其总体的期望和标准差。
但在一般情况下，对总体的每一个个体都进行观察或试验是不可能的。因此，必须对总体进行抽样观察（采样）。由于我们是利用抽样来对总体的分布进行推断，所以抽样必须是随机的，抽样值
应视为一组随机变量。由于抽样的目的是为了对总体的分布进行统计推断，为了使抽取的样本能很好地反映总体信息，必须考虑抽样方法。最常用的一种抽样方法叫作 “简单随机抽样”，得到的样本称为简单随机样本，它要求抽取的样本满足以下两点：
代表性：抽样值中每一个与所考察的总体有相同的分布。
独立性：抽样值是相互独立的随机变量。
满足以上两点要求的样本一般被称为独立同分布independent and identically distributed (i.i.d.)样本。
在概率统计理论中，如果变量序列或者其他随机变量有相同的概率分布，并且互相独立，那么这些随机变量是独立同分布。 在西瓜书中的解释是：输入空间中的所有样本服从一个隐含未知的分布，训练数据所有样本都是独立地从这个分布上采样而得。
所以在实践中采样得到i.i.d.样本之后，可以用样本方差S平方来近似总体方差σ平方。
疑问？？？为什么样本方差的分母是n-1？为什么它又叫做无偏估计？
答案在这里：为什么样本方差的分母是n-1？为什么它又叫做无偏估计？_图灵的猫i的博客-CSDN博客_样本方差为什么是n-1
标准误 例如：已知某学校有初三学生共200名，这200名学生的平均身高为160cm.我们以这200名初三学生作为总体，欲通过抽样调查来了解所有初三学生的平均身高。现在假定我们共做了10次抽样，每次抽样量都是100人。此时我们可以分别计算出每次抽样样本的身高均数和标准差，可以得到10个均数和标准差。这里10个均数和标准差都是样本统计量，如果我们把10个样本的均数作为原始数据，然后计算这10个值的标准差，那么我们得到的指标就是标准误。
它们针对计算的对象不同。标准差是根据某次抽样的原始数据计算的；而标准误是根据多次抽样的样本统计量（如均数、率等）计算的。理论上，计算标准差只需要一个样本，而计算标准误需要多个样本。
尽管从理论上来讲，标准误的计算是通过多次抽样的多个样本统计量而获得的，但在实际中仅依靠一次抽样来计算标准误也是可行的。事实上，在绝大多数情况下，我们也别无选择，只能利用一次抽样数据来计算标准误。此时标准误的计算公式为：
其中，s表示样本标准差，n为样本的例数。不难看出，样本例数越大，标准误越小，即抽样误差越小。
标准差与标准误 联系：
二者都是标准差。
标准误=标准差 / N的根号。标准误差定义为各测量值误差的平方和的平均值的平方根，故又称为均方根误差。
区别：
标准误是一种误差。
标准差是对均数的偏离。
偏离和误差根本不是一个概念。
随机变量的标准差衡量的是该随机变量的离散度。例如：一个样本或者一个population里的个体之间区别有多大。
标准误即样本均数的标准差，是描述均数抽样分布的离散程度及衡量均数抽样误差大小的尺度，反映的是样本均数之间的变异。标准误不是标准差，是多个样本平均数的标准差。标准误用来衡量抽样误差。
标准误是样本统计量的标准差，衡量的是抽样分布的离散度，对应的随机变量是样本统计量。比如样本均值的标准误，衡量的就是样本均值的离散度。例如：从一个population 里取样本，样本之间的区别有多大。
标准误越小，表明样本统计量与总体参数的值越接近，样本对总体越有代表性，用样本统计量推断总体参数的可靠度越大。因此，标准误是统计推断可靠性的指标。
标准差：一次抽样中个体分数间的离散程度，反映了个体分数对样本均值的代表性，用于描述统计。
标准误： 多次抽样中样本均值间的离散程度，反映了样本均值对总体均值的代表性，用于推论统计。
标准差是一个描述性指标，只是描述原始数据的波动情况。而标准误是跟统计推断有关的指标。描述性指标和推论性指标不是一个概念。
标准差标准误区别 1.意义：描述个人观察值变异程度的大小。标准差小， 公卫百科
均数对一组观察值的代表性好。
2.应用：与均数结合，用以描述个人观察值的范围，常
用于医学参考范围的估计。 公卫论坛
3.与n的关系：n越大，标准差越趋于稳定。
描述样本均数的变异程度及抽样误差的大小，其实质是 公卫家园
样本均数的标准差。标准误小，用样本均数推断总体均
数的可能性大 。
与均数结合，用以估计总体均数可能出现的范围以及对 公卫人
总体均数作假设检验。
n越大，标准误下降。
联系 1. 都是描述变异程度的指标
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/830ac0b9b80e05f01d72dd9359e68644/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce08600069c66818a5e7f753ce903947/" rel="bookmark">
			动态生成验证码&#43;验证码的校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		页面s &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt; &lt;!DOCTYPE html&gt; &lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="utf-8"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"/&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"/&gt; &lt;title&gt;首页&lt;/title&gt; &lt;!-- 1. 导入CSS的全局样式 --&gt; &lt;link href="css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- 2. jQuery导入，建议使用1.9以上的版本 --&gt; &lt;script src="js/jquery-2.1.0.min.js"&gt;&lt;/script&gt; &lt;!-- 3. 导入bootstrap的js文件 --&gt; &lt;script src="js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;style&gt; span{ color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;%--&lt;div align="center"&gt; &lt;a href="${pageContext.request.contextPath}/fingPage" style="text-decoration:none;font-size:33px"&gt;查询所有用户信息 &lt;/a&gt; &lt;/div&gt;--%&gt; &lt;div class="container" style="width: 400px;"&gt; &lt;h3 style="text-align: center;"&gt;管理员登录&lt;/h3&gt; &lt;form action="${pageContext.request.contextPath}/login" method="post"&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce08600069c66818a5e7f753ce903947/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/214/">«</a>
	<span class="pagination__item pagination__item--current">215/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/216/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>