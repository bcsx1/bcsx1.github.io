<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa0cc0f139bd883602530fc73d12c589/" rel="bookmark">
			【图像处理】 -039 OpenCV深度人脸检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【图像处理】 -039 OpenCV深度人脸检测 文章目录 【图像处理】 -039 OpenCV深度人脸检测1 简介2 使用OpenCV DNN模块人脸检测3 检测效果4 分析 1 简介 深度学习是当前的大热门啊，OpenCV在3.3版本之后就有了DNN模块，可以用这个模块来运行训练好的深度学习模型，进行相关网络的使用。
对于人脸检测，OpenCV的DNN模块，提供一种基于SSD的检测方案，使用ResNet-10作为后端。模型中自带了两种，一种是基于Caffe的float 16模型5.4MB，这一种是基于Tensorflow的int8模型2.7MB。
2 使用OpenCV DNN模块人脸检测 // Dlib_HOG.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。 // #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;fstream&gt; #include "opencv2/opencv.hpp" #include "../OpenCV_Harr/OpenCV_Harr/HighPerformanceTimer.hpp" //读取待检测文件列表 std::vector&lt;std::string&gt; ReadImgList(std::string&amp; imglistfilename) { std::vector&lt;std::string&gt; imgs; std::ifstream imglistfile(imglistfilename, std::ifstream::in); std::string line; while (getline(imglistfile, line))//按行读取 { imgs.push_back(line); } return imgs; } int main(int argc,char** argv) { if (argc &lt; 3) { std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa0cc0f139bd883602530fc73d12c589/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c25e2e09c062a145e0f30ac98c6be9ab/" rel="bookmark">
			vue中常用的过滤器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、货币过滤器(返回带￥，保留两位小数，每三位加，号格式数据) let currency = value =&gt;{ if(value != "0"){ if(value == "" || value == undefined || value == null ){ return "--"; } } return value.toLocaleString('zh',{style: "currency", currency: "CNY"}) } 主要用到toLocaleString的知识，不懂的可以 查看Number.prototype.toLocaleString()的应用
举例：
2、时间过滤器（根据传入的type 匹配出对应的时间格式） let formateDate = (date,type) =&gt; { if(date != '0'){ if(date == "" || date == undefined || date == null){ return "--" } } let dateTime = '', getDate = new Date(date), year = getDate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c25e2e09c062a145e0f30ac98c6be9ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4eff714aa7f24a6be2ee3032dfba387a/" rel="bookmark">
			win10下配置Ubuntu子系统（用于将python打包为Android）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用于android打包
1.安装Ubuntu子系统 在 设置 =》更新和安全 =》开发者选项 中启用 开发人员模式。在[控制面板&gt;]程序和功能 &gt;启用或关闭Windows功能：勾选适用于Linux的Windows子系统，确定，重启电脑。在应用商店安装ubuntu 2.初始化 2.1 设置用户名和密码 安装好之后打开，会提示Installing, this may take a few minutes…。一会之后会提示输入用户名：
设置好用户名之后，提示输入密码，输入密码时屏幕上没有任何动静，但是已经输入了，不用管。输入一次之后会提示再输入一次。输入完之后即可使用。
2.2 换源 2.2.1修改sources.list文件 文件为：C:\Users\【用户】\AppData\ Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs\etc\apt\ sources.list
在文件中将国内的源添加上去，可以直接用 notepad++ 修改，记事本应该也可以。
2.2.2 查看Ubuntu版本，选择合适的源。 下面3个命令前两个任选一个就可以
# 简单 cat /etc/issue # 具体 cat /etc/lsb-release # 内核 uname -a 2.2.3 选择源 清华源地址https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/
选择合适的版本将sources.list内容替换掉
我适用的：
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4eff714aa7f24a6be2ee3032dfba387a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91c1da9a966fc1a1fc770202341eb132/" rel="bookmark">
			C语言fgets()与fputs()详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 fgets()与fputs()1⃣️fgets()优缺点：2⃣️fgets()返回值：3⃣️fgets()操作实例：3⃣️fgets()操作进阶： fgets()与fputs() fgets()函数的第二个参数指明了读入字符的最大数量。如果该参数为n，那么fgets函数将读入n-1个字符。如果fgets()函数读到一个换行符，会把它储存在字符串中。这点与gets不同，gets会丢弃换行符。fgets()函数的第三个参数指明要读入的文件。如果读入从键盘输入的数据，则以stdin作为参数。fputs()函数的第二个参数指明他要写入的文件。如果要在计算机显示器上打印，则使用stdout作为参数。与puts()函数不同，fputs()函数不会在待输出字符串末尾添加一个换行符。 例：
#include &lt;stdio.h&gt; #define LEN 14 int main(void){ char words[LEN]; puts("Enter a String"); fgets(words,LEN, stdin); puts(words); //puts()函数会添加换行符\n fputs(words, stdout); return 0; } 输入apple后，apple\n\0 被存储在数组中。
我们看到控制台输出的内容发现输出的两个apple之间有一行空白，因为puts()函数会添加换行符\n。
1⃣️fgets()优缺点： fgets()储存换行符有好有坏
缺点是你可能并不想把换行符储存在字符串中，这样的换行符会带来一些麻烦。优点是对于储存的字符串而言，检查末尾是否有换行符可以判读是否读取了一整行。如果不是一整行，要处理好一行中剩下的字符。 2⃣️fgets()返回值： 读取成功，返回读取到的字符串，即string；失败或读到文件结尾返回NULL。
下面的程序验证读到文件结尾返回NULL。读入并显示用户输入的内容，直到fgets()读到文件结尾或空行（即，首字符为换行符）。
3⃣️fgets()操作实例： #include &lt;stdio.h&gt; #define LEN 10 int main(void){ char words[LEN]; puts("Enter Strings (empty line to quit): "); while(fgets(words, LEN, stdin) != NULL &amp;&amp; words[0] != '\n'){ fputs(words, stdout); } puts("Done!"); return 0; } LEN设置的为10，所以fgets()一次读取9个字符（剩余一个字符留给’\0’)，第一次读取到" I’m Kevin "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91c1da9a966fc1a1fc770202341eb132/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f78c4dcab06039643e07a6b04d9d53c3/" rel="bookmark">
			【数据结构】-java实现-先序创建普通二叉树（即递归创建一棵普通二叉树）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎么按照要求创建一棵二叉树 怎么创建下图的二叉树？
我写过完全二叉树的创建【数据结构】-java 完全二叉树的创建以及递归遍历算法实现
参考完全二叉树的结点的创建。
对于这种普通的二叉树我们也可以用递归的方式去创建。
先上代码，朋友们应该就明白个大概了，文本末附总结
树节点的创建 //全部是私有属性，这里用set、get方法返回所需要的属性。
public class BTNode { //定义一个二叉树的结点 private int data; private BTNode lchild; private BTNode rchild; //构造函数 public BTNode(){ } //新的构造函数，其实也可以简写 public BTNode(int data ,BTNode lchild ,BTNode rchild){ this.data=data; this.lchild=lchild; this.rchild=rchild; } //以下就是data lchild rchild的set，get函数 public void setdata(int data){ this.data=data;	} public int getdata(){ return data; } public void setlchild(BTNode lchild ){ this.lchild=lchild; } public BTNode getlchild(){ return this.lchild; } public void setrchild(BTNode rchild ){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f78c4dcab06039643e07a6b04d9d53c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04291f59928364f40f1a159fbcb74394/" rel="bookmark">
			【毫米波雷达】接收机中为什么要把信号分成IQ两路？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在许多雷达、声纳和通信系统中,一般都需要将接收器的中频输出信号变换为正交的两路基带信号，即采用I、Q两种通道来检波，这到底是什么原因呢？我一直有这个疑问，下面是我对一些网友回答的总结，仅供学习参考！！！
原因一：具有更大的动态范围和更高的精度 由于保留了信号的相位信息,意味着如果信号相干的话，两个基带信号可以用来进行相干积累，因此，使用正交探测技术的IQ接收器比不使用正交探测技术的接收器,具有更大的动态范围和更高的精度。
原因二：I/Q两路采样可以降低采样率 把要传输的数据分成并行的两路（I和Q路）分别进行扩频/加扰。分成两路并行处理的目的是充分利用图座图进行调制，图座图有X和Y轴，正好对应I和Q路，I/Q两路采样可以降低采样率，可以获取信号的相位信息。
原因三：方便将信号采用复信号的方法表示 硬件电路一般都不支持复数运算，一般的方法是把实部，虚部分别方在不同的存储区域，运算的时候分别按照实虚部运算！对此，我这样理解，复数只是在学习过程中的一个概念，我们可以在做理论推导时使用，到了实际的应用（在硬件电路里编程实现我们前面推导的理论）必须把一个复数换成两个实数，分别按照实数的运算法则运算，只是要时刻记住那个结果是实部，那个是虚部？不知道这样理解对吗？
还有一个网友的回复如下：
在通信系统中, 信号就是调制和解调所要传送的信息。
而在数字通信系统中,传送的信息是数据。数字调制是将数据数据载在射频载波的过程,而解调则是将数据数据从射频信号中取出的过程。
射频载波信号A cos（2πfct+θ）可供改变的参数只有振幅、频率和相位三种。
改变载波振幅的调变方式称为调幅（AM）;
改变载波频率方式称为调频（FM）;
改变载波相位的调变方式称为相位调变（PM）。
由于相位的微分即是频率,所以载波信号的振幅和相位可以说是两个主要的调制变量。如果把调制中载波振幅和相位的信息记录下来，即A与θ,并以二维空间的两个变量分别代表振幅和相位,那么极坐标上任意点到原点的距离和相角,正好可以代表载波的振幅和相位,也可以说是代表载波的被调制情况。
极坐标方式的调制表示方法可转化为直角坐标方式,也就是I-Q图。载波振幅和相位可记录为二维空间上的一点,而这一点所代表的向量,在横轴和纵轴上的投影分别为I值和Q值。I为同相位（In-phase）分量,代表向量在横轴上的投影;Q为90度相移（Quadrate）分量,代表向量在纵轴上的投影。这样调制后的数据就分成了两路，同相（I）和正交（Q）分量，这两个分量是正交的，相位相差90度，并且互不相干。调制后我们再分开处理IQ两路，进行中频和射频处理，最后再DAC前合成一路（相加），然后天线发射。在接收端用正交调制相反算法分出IQ两路，分别处理，然后又变成一路供CPU处理。其实这里的调制方式属于通信技术中常用的相干调制的范畴，当然相干调制不一定是正交的，正交适应于BPSK、QPSK中，8PSK等八相以上调制。
特点：1.从传输线角度来看，I/Q信号是一种双线传输模式，能量主要集中在两线之间。与外界关系不大。以此可以抗击共模干扰。当然，双线间回路面积要小些是前提。
2.IQ信号本身和抗干扰没多大关系，现代通信系统为了使频谱利用率更高，所以用了许多种矢量调制，如BPSK、QPSK、QAM等等。作为复信号，可以应用单边带形式，节省了信道资源。
3.可以作为复信号使用，这样在解决很多问题时，会非常方便，比如，我们在仿真中通常可以使用复信号来所运算，这里的I路就是复信号的实部信号，Q路就是复信号的虚部信号。同时对于数字信号而言是不会区分一个信号是不是矢量的，所以采用IQ调制这种方式，应很好地使数字和模拟之间塔起了矢量的桥梁。 4.将数据分为I、Q正交的两路来传输，可以降低每路的传输速率为一半，这样可以在低速率信道上传输。
还有一篇写得很好的IQ信号调制的文章：http://www.ni.com/tutorial/4805/en/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7503fe9a30aca2e1bbb4510ee50e9fb2/" rel="bookmark">
			数据结构与算法（四）—— 栈与队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、栈的定义
二、栈的抽象数据类型
三、栈的顺序存储结构及实现
1、栈的顺序存储结构
2、进栈操作
3、出栈操作
四、两栈共享空间
五、栈的链式存储结构及实现
1、栈的链式存储结构
2、栈的链式存储结构——进栈操作
3、栈的链式存储结构——出栈操作
六、栈的应用——递归
七、栈的应用——四则运算表达式求值
1、后缀（逆波兰）表示法定义
2、后缀表达式计算结果
3、中缀表达式转后缀表达式
八、队列
1、队列的定义
2、队列的抽象数据类型
3、循环队列
1) 什么是循环队列?
2) 循环队列的代码实现
4、队列的链式存储结构及实现
栈与队列：
栈是限定仅在表尾进行插入和删除操作的线性表。
队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。
一、栈的定义 栈是限定仅在表尾进行插入和删除操作的线性表。
我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈。栈又称为后进先出的线性表，简称LIFO结构。
定义中说是在线性表的表尾进行插入和删除操作，这里表尾是指栈顶，而不是栈底。栈底是固定的，最先进栈的只能在栈底。栈的插入操作，叫作压栈，也称压栈、入栈。栈的删除操作，叫作出栈，也称作弹栈。
二、栈的抽象数据类型 ADT 栈 Data 同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。 Operation InitStack(*S)：初始化操作，建立一个空栈S。 DestroyStack(*S)：若栈存在，则销毁它。 ClearStack(*S)：将栈清空。 StackEmpty(S)：若栈为空，则返回true，否则返回false。 GetTop(S,*e)：若栈存在且非空，用e返回S的栈顶元素。 Push(*S,e)：若栈S存在，插入新元素e到栈S中并成为栈顶元素。 Pop(*S,*e)：删除栈S中栈顶元素，并用e返回其值。 StackLength(S)：返回栈S的元素个数。 endADT 三、栈的顺序存储结构及实现 1、栈的顺序存储结构 由于栈是线性表的特例，所以栈的顺序存储其实也是线性表顺序存储的简化，我们简称为顺序栈。线性表是用数组来实现的，下标为0的一端可以作为顺序栈的栈底，另一端则作为顺序栈的栈顶。我们可以定义一个top变量来指示栈顶元素在数组中的位置，这top就如同游标卡尺的游标，它可以来回移动，意味着栈顶的top可以变大变小，但无论如何游标不能超出尺的长度。因此，top必须小于StackSize，当栈中存在一个元素时，top为0；如果为空栈，则top为-1。
栈的结构定义如下：
#include &lt;iostream&gt; using namespace std; #define MAXSIZE 20 #define OK 1 #define ERROR 0 typedef int Status; //函数结果状态码，如OK等 typedef int ElemType; typedef struct{ ElemType data[MAXSIZE]; int top; //栈顶指针 }Stack; 2、进栈操作 进入操作代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7503fe9a30aca2e1bbb4510ee50e9fb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5ccb43a492e4a13111c262dc1e2012c/" rel="bookmark">
			使用 UmiJs 中的  ant-design-pro 开发系统，配置自己的接口 和 路由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文档地址参考，以下信息都是项目模板已初始化完毕，项目启动如下
1. 关闭 国际化 开发
1. 执行 npm run i18n-remove
2. 删除 src 下的 locales 包
2. 配置接口环境，不说了，只不过，这个define 需要添加到 config 文件夹下， 配置方法同上篇文章
3. 配置自己的开发接口地址
在config 文件夹下，修改 config.js 中的 proxy代理，换成你的接口地址
4. 测试以下
在services 文件夹下 添加 test.js 测试
import request from '@/utils/request'; export async function test() { return request('/api/links'); } 在 pages 文件夹下 的 Welcome 组件中使用，刷新页面可以看到下边的打印
import React from 'react'; import { PageHeaderWrapper } from '@ant-design/pro-layout'; import { test } from '@/services/test'; test().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5ccb43a492e4a13111c262dc1e2012c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c44ff4ad70fb7288e70a2cbdfe71917/" rel="bookmark">
			使用 umi &#43; dva 开发配置接口环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		乌米文档，创建项目模板啥的就不说了
关于选择project， 自定义开发的话， 选择 app 选项，其它不多说了
之后会问你选择 ts 吗？ ，是否使用antd， dva， code spliting ，dll，可选的，自己决定
最后，启动项目，打开控制台，一堆警告，和错误提示，关于警告，就是react 钩子在新版本已经换名字了，现在的这些以后会过时了，都是 .umi 文件报的，并不是实例代码错误，你可以选择不展示在控制台
在控制台把这个关闭就不会展示了
目录结构呢，就不说了，文档上有的
接着，通过环境变量 UMI_ENV 区分不同环境来指定配置。配置开发环境，测试环境，和生产接口环境
1. 安装 cross-env
yarn add cross-env
2. 修改 .umirc.js 文件，添加一个 define属性（这个是测试及开发）
3. 配置生产环境，赋值一份这个文件 改名为 .umirc.prod.js ，把接口换成你的正式服务器接口
4. 修改打包指令， 在package.json 中 "scripts": { "start": "umi dev", "test": "umi test", "devbuild": "cross-env UMI_ENV=dev umi build", "build": "cross-env UMI_ENV=prod umi build", "lint": "eslint --ext .js src mock tests", "precommit": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c44ff4ad70fb7288e70a2cbdfe71917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b32821e4f5e745346e75dfd98720266/" rel="bookmark">
			自增自减运算符重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		递增运算符（++）和递减运算符（--）是C++语言中两个重要的一元运算符。
/*** addMyself.cpp ***/ #include&lt;iostream&gt; using namespace std; class Time { private: int hours; int minutes; public: Time() { hours = 0; minutes = 0; } Time(int h,int m) { hours = h; minutes = m; } void displayTime() { cout &lt;&lt; "H: " &lt;&lt; hours &lt;&lt; " M" &lt;&lt; minutes &lt;&lt; endl; } //重载前缀递增运算符 Time operator++() { ++minutes; if(minutes &gt;= 60) { ++hours; minutes -= 60; } return Time(hours,minutes); } //重载后缀递增运算符 Time operator++(int) { Time T(hours,minutes); ++minutes; if(minutes &gt;= 60) { ++hours; minutes -= 60; } return T; } }; int main() { Time T1(11,59),T2(10,40); ++T1; T1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b32821e4f5e745346e75dfd98720266/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f6619ef7940bde921ac7f523a1e3376/" rel="bookmark">
			Qt调用谷歌地图，百度在线地图，离线地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt调用地图是通过调用html文件来实现，可以是离线地图，也可以是在线地图。
最近一个同学让我写一个qt地图，他在网上下载了很多地图都是不可用的要么收费都很奇葩，还有的是qt4版本的，现在都这个时代了，qt4很多插件是Qt5没有的，这也就造成编译不了。下面我们来做一个qt5的地图
先来看看简单的界面把
可以调用谷歌地图，百度在线地图，离线地图
加载一个离线地图看看
来个谷歌地图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e41bb32b6ac9e0121e441da15f144849/" rel="bookmark">
			【DSP】CCS编译警告warning: creating output section &#34;.cio&#34; without a SECTIONS specification
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我使用CCS 4.2.3和微型TMS320F28335，编译时出现警告
warning: creating output section ".cio" without a SECTIONS specification
最终在如下链接中找到解决方案：https://e2e.ti.com/support/microcontrollers/c2000/f/171/t/92716
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddae4f462cfc913ca0a3f3f5d83eafd9/" rel="bookmark">
			c&#43;&#43; bitset
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		头文件：#include&lt; bitset &gt;
bitset&lt; 5 &gt; a; // 定义一个长度为5的a ,即二进制表示： “00000”
a.reset() ==》全部置零
a._Find_first() // 查找从右往左数（也就是从低位向高位数，之前的写大数，以及书写十进制时，经常把这个搞混）第一个出现1 的位置
下面用代码讲讲它与数组不同的地方：
#include &lt;bits/stdc++.h&gt; using namespace std; int main() { string s="1011000"; bitset&lt;7&gt; B1(s); bitset&lt;8&gt; B2(s); cout&lt;&lt;"字符串为："&lt;&lt;s&lt;&lt;endl; cout&lt;&lt;"bitset B1为："&lt;&lt;B1&lt;&lt;endl; cout&lt;&lt;"bitset B2为："&lt;&lt;B2&lt;&lt;endl; B1.set(0);//将下标为0的位置置为1 cout&lt;&lt;B1&lt;&lt;endl; return 0; } 输出结果为：（下面为了好对比，对其了结果） 字符串为： 1011000 bitset B1为： 1011000
bitset B2为：01011000
1011001
可以发现，
1）将字符串s初始化B1时，bitset中的下标为0的位置是最右边（类似于平时写的二进制 10，表示的是十进制2），而数组的是最左边，bitset的从右往左表示从低位向高位
2）B2的大小为8,s为7位，不够的前面补零
链接：https://www.cnblogs.com/magisk/p/8809922.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc7a545404a6237be061e2cf143453cc/" rel="bookmark">
			MyBatis的DML操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		映射文件：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;!--namespace="com.bjsxt.mapper.UserMapper":命名空间，权限定路径 --&gt; &lt;mapper namespace="com.bjsxt.mapper.UserMapper"&gt; &lt;!--新增 --&gt; &lt;insert id="insertUser" parameterType="user"&gt; insert into t_user values(default,#{username},#{password}) &lt;/insert&gt; &lt;!--修改 --&gt; &lt;insert id="updatetUser" parameterType="user"&gt; update t_user set username=#{username},password=#{password} where id=#{id} &lt;/insert&gt; &lt;!--删除 --&gt; &lt;insert id="deleteUser" parameterType="int"&gt; delete from t_user where id=#{0} &lt;/insert&gt; &lt;/mapper&gt; 核心配置文件：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;!--加载外部properties文件 --&gt; &lt;properties resource="db.properties" /&gt; &lt;settings&gt; &lt;!-- 设置mybatis使用log4j支持 --&gt; &lt;setting name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc7a545404a6237be061e2cf143453cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1886d73ec8802a7133f8c055c95445ab/" rel="bookmark">
			celery异步任务处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、异步任务 异步任务是web开发中一个很常见的方法。对于一些耗时耗资源的操作，往往从主应用中隔离，通过异步的方式执行。
运用场景：注册的功能，在用户使用邮箱注册成功之后，需要给该邮箱发送一封激活邮件。如果直接放在应用中，则调用发邮件的过程会遇到网络IO的阻塞，比较好的处理方式则是使用异步任务，将发邮件从主业务中解耦出来，应用在业务逻辑中触发一个异步任务。
二、生产者消费者模式 生产者生成消息，缓存到消息队列中，消费者读取消息队列中的消息并执行。
生产者消费者模式面向过程的一种编程模式。在实际的软件开发过程中，经常会碰到如下场景：某个模块负责产生数据，这些数据由另一个模块来负责处理（此处的模块是广义的，可以是类、函数、线程、进程等）。产生数据的模块，就形象地称为生产者；而处理数据的模块，就称为消费者。
三、celery celery是基于python实现的一个异步任务的调度工具，同时还是一个任务队列，主要用于处理耗时的任务。
celery本身不含消息服务，需要依赖一个消息队列MQ来来传递任务，客户端代码只需要向MQ中派发任务，Celery进程就可以从MQ中读取消息并派发给worker，从而达到了客户端程序与Celery进程解耦的效果。而且Celery进程并不需要监听任何端口，减少了配置的复杂性。目前，Celery支持的消息服务有RabbitMQ、Redis甚至是数据库，当然Redis应该是最佳选择。
（1）celery架构 celery架构由三个模块组成：消息中间件（message broker），任务执行单元（worker）和任务执行结果存储（task result store）组成。
消息中间件（Broker）: 消息中间人，是任务调度队列，是一个独立的服务，是一个生产者消费者模式，生产者把任务放入队列中，消费者（worker）从任务队列中取出任务执行，任务的执行可以按照顺序依次执行也可以按照计划时间进行。但是Broker本身不提供队列服务，所以要集成第三方队列，推荐使用RatbbitMQ或Redis.
任务执行单元（worker）：即执行任务的程序，可以有多个并发。它实时监控消息队列，获取队列中调度的任务，并执行它。
任务执行结果存储（task result store）：由于任务的执行同主程序分开，如果主程序想获取任务执行的结果，就必须通过中间件存储。同消息中间人一样，存储也可以使用RabbitMQ、Redis；另外，假如不需要保存执行的结果也可以不配置这个模块。
（2）celery特点 简单：Celery 易于使用和维护，并且它不需要配置文件高可用性：倘若连接丢失或失败，进程和客户端会自动重试，并且通过主/主或主/从方式复制来提高可用性快速：单个 Celery 进程每分钟可处理数以百万计的任务，而保持往返延迟在亚毫秒级灵活：Celery 几乎所有部分都可以扩展或单独使用。可以自制连接池、序列化、压缩模式、日志、调度器、消费者、生产者、自动扩展、中间人传输或更多。 （3）工作原理 它的基本工作就是管理分配任务到不同的服务器，并且取得结果。至于说服务器之间是如何进行通信的？这个Celery本身不能解决。所以，RabbitMQ作为一个消息队列管理工具被引入到和Celery集成，负责处理服务器之间的通信任务。和rabbitmq的关系只是在于，celery没有消息存储功能，他需要介质，比如rabbitmq、redis、mysql、mongodb 都是可以的。
（4）celery应用 安装：
用pip安装：$ pip install -U Celery用easy_install 安装：$ easy_install -U Celery捆绑式安装：$ pip install celery[librabbitmq] 或者 $ pip install
celery[librabbitmq,redis,auth,msgpack]。
步骤：
①执行任务单元 task.py task.py中 from celery import Celery import time # broker和backend都设置为redis my_task = Celery('task',broker='redis://127.0.0.1:6379/1', backend='redis://127.0.0.1:6379/2') # 任务执行单元 @my_task.task def func1(x,y): time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1886d73ec8802a7133f8c055c95445ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db7be2fb499286c92da104567d81b1c0/" rel="bookmark">
			11.5 impala3的jdbc的连接cdh版补充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.版本impala3.1.0-cdh6.1.1
2.impala的HiveServer2 端口:21050
先抛出一个兼容性的问题,impala jdbc不兼容,当前选择的 ClouderaImpalaJDBC41-2.6.11.1012
impala jdbc选择兼容版 下载地址 http://www.cloudera.com/downloads/connectors/impala/jdbc/2-5-28.html 展示
import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; public class Impala_NoneKBSimple { private static String JDBC_DRIVER = "com.cloudera.impala.jdbc41.Driver"; private static String CONNECTION_URL ="jdbc:impala://master:21050/"; static { try { Class.forName(JDBC_DRIVER); } catch (Exception e) { System.out.println("找不到驱动程序类 ，加载驱动失败！"); e.printStackTrace(); } } public static void main(String[] args) { System.out.println("通过JDBC连接非Kerberos环境下的Impala"); Connection connection = null; ResultSet rs = null; PreparedStatement ps = null; try { connection = DriverManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db7be2fb499286c92da104567d81b1c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ebf54aaae240fc5bc5a4fda99d6af6a/" rel="bookmark">
			微信小程序 -- 获取页面URL或参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 获取当前页url
/** * 获取当前页url */ const $getCurrentPageUrl = () =&gt; { let pages = getCurrentPages() // 获取加载的页面 let currentPage = pages[pages.length - 1] // 获取当前页面的对象 let url = currentPage.route // 当前页面url return url } 2. 获取当前页带参数的url
/** * 获取当前页带参数的url */ const $getCurrentPageUrlWithArgs = () =&gt; { let pages = getCurrentPages() // 获取加载的页面 let currentPage = pages[pages.length - 1] // 获取当前页面的对象 let url = currentPage.route // 当前页面url let options = currentPage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ebf54aaae240fc5bc5a4fda99d6af6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26f0003fed3d27e38153c986130e5cfd/" rel="bookmark">
			mysql连接不上，连接错误，报出Lost connection to MySQL server at &#39;waiting for initial communication packet&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
mysql连接不上，连接错误，报出Lost connection to MySQL server at ‘waiting for initial communication packet’,system error:0 **
今天重装系统，重新安装mysql ，结果在连接服务器的时候出错，我估计也只有少部分人出现吧，但还是想写出来，说不定能帮到谁呢！
出现这样的错误，首先看一下你的hosts,在C:\Windows\System32\drivers\etc，点开hosts，如果你看到里面已经有了127.0.0.1的话就关了吧，没有的话就加上这句话。
一定要启动mysql，在服务启动。
接着创建连接
连接名自己输入，密码自己当时装mysql的密码
注意注意注意重点来了！！！！！
如果你这样创建报出错的话，你不妨试试讲localhost换成127.0.0.1试试，我就是这么解决的！
还有一种方法，你可以试试SSH连接
希望能帮到有需要的人！！！谢谢阅读！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3761c73357956f5cac43cbbf68b9454e/" rel="bookmark">
			全概率公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		条件概率公式： 当给定条件发生变化后，会导致发生事件的可能性变化。（possiblity）
p(a|b) b存在的情况下，a出现的概率
p(b|a) a 存在的情况下，b出现的概率
相互独立：表示两个事件发生互不影响。而互斥：表示两个事件不能同时发生，互斥事件一定不独立.独立事件一定不互斥
全概率公式： 对一复杂事件A的概率求解问题转化为了在不同情况下发生的简单事件的概率的求和问题。
下面做个题目吧：
解答：
1. p（a） ： 第一次抽出黑球的概率
2. p（b）： 第二次抽出黑球的概率
p(b) = p(b|a1).p(a1) + p(b|a2) .p(a2) 这里a1是第一次抽到黑球。 a2第一次抽到红球
p（a1）= b/ a+b
p(a2)= a/a+b
p(b|a1)= b+c/a+b+c
p(b|a2)= b/a+b+c
那么得到p（b）= b/a+b
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6ad89c737ee980b74237c8ba02fcc32/" rel="bookmark">
			ssh-copy-id node6  ERROR: No identities found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ssh-copy-id node6 ERROR: No identities found
原因：缺少公钥路径
ssh-copy-id -i ~/.ssh/id_dsa.pub user@ip 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72d6a7a361f896449ef5e08265daed3d/" rel="bookmark">
			RabbitMQ - Spring配置 - topic《通配符模式》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringMain_Topic.java
package com.xzp.rabbitmq.spring.topic; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.context.support.AbstractApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; /** * main程序 * 交换机为- 》topic: 代表 "通配符模式"《可选择性接收消息, 采用通配符模式 * 符号代表1个, # 符号代表一个或多个》 */ public class SpringMain_Topic { public static void main(final String... args) throws Exception { AbstractApplicationContext ctx = new ClassPathXmlApplicationContext("classpath:spring/rabbitmq-context-fanout.xml"); //RabbitMQ模板 //RabbitTemplate template = ctx.getBean(RabbitTemplate.class); RabbitTemplate amqpTemplate01 = (RabbitTemplate) ctx.getBean("amqpTemplate_fanout"); RabbitTemplate amqpTemplate02 = (RabbitTemplate) ctx.getBean("amqpTemplate_direct"); RabbitTemplate amqpTemplate03 = (RabbitTemplate) ctx.getBean("amqpTemplate_topic"); //发送消息 String str01 = "Hello, world!, This exchange is fanout !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72d6a7a361f896449ef5e08265daed3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/726a284e6b728169d695af6829b372e6/" rel="bookmark">
			解决Flutter不能下载jar包问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为不可访问Google，所以直接下载Jar存在问题。
解决办法：
更改Gradle仓库地址，使用阿里云加速：修改Flutter SDK安装目录下的\packages\flutter_tools\gradle\flutter.gradle文件
buildscript { repositories { //google() // jcenter() maven{ url 'https://maven.aliyun.com/repository/google' } maven{ url 'https://maven.aliyun.com/repository/jcenter' } maven{url 'http://maven.aliyun.com/nexus/content/groups/public'} } dependencies { classpath 'com.android.tools.build:gradle:3.2.1' } } 配置项目内的build.gradle文件
buildscript { repositories { // google() // jcenter() maven{ url 'https://maven.aliyun.com/repository/google' } maven{ url 'https://maven.aliyun.com/repository/jcenter' } maven{url 'http://maven.aliyun.com/nexus/content/groups/public'} } dependencies { classpath 'com.android.tools.build:gradle:3.2.1' } } allprojects { repositories { // google() // jcenter() maven{ url 'https://maven.aliyun.com/repository/google' } maven{ url 'https://maven.aliyun.com/repository/jcenter' } maven{url 'http://maven.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/726a284e6b728169d695af6829b372e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d676b4ba580ab1d579654fb1ba5db8bd/" rel="bookmark">
			关于原码与IEEE754的阶码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于原码与IEEE754的阶码
首先要明确IEEE754中的阶码是移码，这个移码不是加128，而是127(FLOAT)，顺带一提此时移码与补码只差符号位的定理不符合
移码是在原码的基础上加的，原码的范围是-127到+127（有+0与-0）
阶码的范围是1到254，就是说阶码没有0与255的说法（无全0与全1）
IEEE754规定，全1是无穷大，而全1减127就是10000000也就是负0，原码的负0加127后表示的阶码是无穷大
IEEE754规定，全0是非规范数，那么全0是怎么加出来的呢，就是原码的10000001
-127·-1~-0·+0·+127
（-1变全0非规范数）·（-2变1）·（-127变126）·（+0变127）·（+127变254）·（-0变255无穷大）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/801e7065a6702a28d8e525723966bd84/" rel="bookmark">
			Cannot inline bytecode built with JVM target 1.8 into bytecode that is being built with JVM target
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于某个操作我使用里Java 8 的版本,但是出现以下报错:
Cannot inline bytecode built with JVM target 1.8 into bytecode that is being built with JVM target
按照在网上的搜索结果,我进入
android studio Setting-&gt;Kotlin Compiler设置了Target JVM versiono 1.8之后,还是报同样的错,
也就是提示我用的1.6 编译的项目,导致不兼容.
我注意到 在这个Kotlin Compiler 界面还提示 Fllowing modeules override project settings,我检查自己所有Model 的build.gradle 没有发现设置 jvm 为1.6的代码,最后进入到Project Structure 之后,检查了JDK location,我发现我用的JDK location 在D盘,我注意到我有很多版本jdk,并且我再JDK location 这一栏下方看到提示:
“To use the same Gradle daemon between Android Studio and the command line,select JAVA_HOME from the drop-down” ,意思是让我使用JAVA_HOME指定的jdk作为项目的jdk路径,好让Android Studio 和命令行使用同样的构建工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/801e7065a6702a28d8e525723966bd84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/242154d2cd7584e66b4c005be5c1e610/" rel="bookmark">
			echarts中的series数据如何循环显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 循环压入一个数组中，在给series赋值给这个数组变量名称：
var series=[]; for(var i = 0;i&lt;json.data.length;i++){ series.push({ name: arr_name[i], type: 'line', stack: '总量', // data:[120, 132, 101, 134, 90, 230, 210] data: arr_sum_long_new[i] }); } //...echarts配置 series: series 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6871d3c6c0e5c3aedabf63b646bc487b/" rel="bookmark">
			wgan---w距离-----如何修改代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/Charles-Wan/p/6501945.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b650eb8e883f895acff4fda0ece9e062/" rel="bookmark">
			PowerDesigner导入现有表结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 File-&gt;Reverse Engineer-&gt;Database
弹出弹窗设置模型名称（Model Name），同时在DBMS下拉选择框中选择数据库的类型及版本，点击确定
Using script files：根据sql文件导入Using a data source：直接连接数据库导入
点击确定等待导入。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/290e33b52a015753f8ac56ee5fd54c9b/" rel="bookmark">
			Qt中qrc文件编译后缺少预编译头文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述 在新电脑上编译之前可用的工程，报C1010错误。原因是xxx.qrc文件经过编译后，qrc_xxx.cpp文件中缺少#include "stdafx.h" 临时解决方案 在工程下找到对应的qrc_xxx.cpp，在开头处手动添加#include "stdafx.h"该方案在xxx.qrc重新编译后又得手动添加。 解决方案 重新安装一下qt vs addin插件。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9171c4519a72d9a0e04f73b6b5fc4f43/" rel="bookmark">
			VS2017&#43;Qt5.9.0 调试时Qt类不显示值，只显示地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述 vs在调试时，鼠标放在变量上，C++基础类的变量能显示值，但是Qt类（QString、QMap）不现实值，只显示该变量的地址。一般装了qt-vsaddin 插件，就不会有这种情况，但有时候还是会失效。 解决办法 参考一下连接: https://blog.csdn.net/loveyou388i/article/details/88415649从qt-vsaddin-msvc2017-2.3.1.vsix插件安装目录下获取的qt5.natvis.xml文件,去掉xml后缀。复制到VS2017安装目录下(Microsoft Visual Studio\2017\Enterprise\Common7\Packages\Debugger\Visualizers)若任然报错"##NAMESPACE##::QPoint"无效,删除qt5.natvis内的所有"##NAMESPACE##::"字符 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fca11046df52f7bfb9382187339fc18/" rel="bookmark">
			眼镜反光检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章：https://blog.csdn.net/weiwei9363/article/details/85046877#_45
首先我们可以手机一批数据使用数据训练一哥网络模型，
测试代码（.h5模型在CSDN里可以下载）
import tensorflow as tf import os import glob from skimage import io import matplotlib.pyplot as plt os.environ['CUDA_VISIBLE_DEVICES'] = '1' import numpy as np from keras.layers import Input,Conv2D,BatchNormalization,Activation,Subtract from keras.models import Model, load_model from keras.callbacks import CSVLogger, ModelCheckpoint, LearningRateScheduler from keras.optimizers import Adam import keras.backend as K model = load_model('FCN_baseline.h5') img = io.imread('./CVC-612/bbdd_png/7.jpg') img = img.astype('float') / 255.0 img = np.expand_dims(img, axis=0) specular_mask = model.predict(img) th = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fca11046df52f7bfb9382187339fc18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86c2684a4a2d71423f549b971a08aa2c/" rel="bookmark">
			HIVE 计算指定日期本周的第一天和最后一天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 select day ,(day,1) -- 时间 ,date_add(day,1 - dayofweek(day)) as week_first_day -- 本周第一天_周日 ,date_add(day,7 - dayofweek(day)) as week_last_day -- 本周最后一天_周六 ,date_add(day,1 - case when dayofweek(day) = 1 then 7 else dayofweek(day) - 1 end) as week_first_day -- 本周第一天_周一 ,date_add(day,7 - case when dayofweek(day) = 1 then 7 else dayofweek(day) - 1 end) as week_last_day -- 本周最后一天_周日 -- dayofweek在hive2.2.0开始支持，低版本的hive原生未提供dayofweek函数(获取一个日期是星期几的方法)， -- 所以只有我们自己编写udf函数提供，udf就不说了，在这里给出了一个使用hive原生函数获取星期几的技巧。 ,date_format(from_unixtime(unix_timestamp('20190808','yyyyMMdd'),'yyyy-MM-dd'),'u') as dayofweek1 --本周第几天 u必须小写 ,date_format('2019-08-08','u') --本周第几天 u必须小写 ,7- datediff(next_day('2019-08-07',"Sunday"),'2019-08-07') --另外一种方式实现本周几 ,dayofmonth(day,1) --本月本月第几天 ,next_day(day,'TU') as next_tuesday -- 当前日期的下一个周二 有可能还是本周的 ,next_day('2019-08-07','Mon') as next_Monday -- 当前日期的下一个星期一 有可能还是本周的 ,next_day('2019-08-07','Tue') as next_Tuesday -- 当前日期的下一个星期二 有可能还是本周的 ,next_day('2019-08-07','Wed') as next_Wednesday -- 当前日期的下一个星期三 有可能还是本周的 ,next_day('2019-08-07','Thu') as next_Thursday -- 当前日期的下一个星期四 有可能还是本周的 ,next_day('2019-08-07','Fri') as next_Friday -- 当前日期的下一个星期五 有可能还是本周的 ,next_day('2019-08-07','Sat') as next_Saturday -- 当前日期的下一个星期六 有可能还是本周的 ,next_day('2019-08-07','Sun') as next_Sunday -- 当前日期的下一个星期日 有可能还是本周的	,to_date(concat(year(day),'-',lpad(ceil(month(day)/3) * 3 -2,2,0),'-01')) as season_first_day -- 当季第一天 ,trunc(day,'MM') as month_first_day -- 当月第一天 ,trunc(day,'YY') as year_first_day -- 当年第一天 ,last_day(add_months(trunc(day,'YY'),12)) as year_last_day -- 当年最后一天 ,last_day(day) as month_last_day -- 当月最后一天 ,last_day(to_date(concat(year(day),'-',lpad(ceil(month(day)/3) * 3,2,0),'-01'))) as season_last_day -- 当季最后一天 ,weekofyear(day) as weekofyear1 -- 当年第几周 ,weekofyear('2019-08-07') - weekofyear(trunc('2019-08-07','MM')) +1 as weekofmonth1 --当月第几周 ,second(day) as second -- 秒钟 ,minute(day) as minute -- 分钟 ,hour(day) as hour -- 小时 ,day(day) as day -- 日期 ,month(day) as month -- 月份 ,lpad(ceil(month(day)/3),2,0) as season -- 季度 ,year(day) as year -- 年份 from ( select '2019-01-02 01:01:01' as day union all select '2019-02-02 02:03:04' as day union all select '2019-03-02 03:05:07' as day union all select '2019-04-02 04:07:10' as day union all select '2019-05-02 05:09:13' as day union all select '2019-06-02 06:11:16' as day union all select '2019-07-02 07:13:19' as day union all select '2019-08-02 08:15:22' as day union all select '2019-09-02 09:17:25' as day union all select '2019-10-02 10:19:28' as day union all select '2019-11-02 11:21:31' as day union all select '2019-12-02 12:23:34' as day ) t1 ; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13ff2ca59edfd76f9a6e39d0e3b25d22/" rel="bookmark">
			ERR this instance has cluster support disabled
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在本机启动服务测试的时候redis配置突然报错，ERR this instance has cluster support disabled，之前一直没有问题，百度了很多都说是把redis配置文件中的cluster-enabled 注释取消掉，但是发现配置文件没问题的。
那为什么还会报错呢？
我的单机多实例部署的redis集群配置，6379、6380、6381、6382，又仔细观察了一下项目中的redis.xml配置文件，多添加了这个6379的配置，他没有在集群配置中，去掉6379这个配置就不报错了；
附加windows环境单机redis集群架设
https://www.cnblogs.com/tommy-huang/p/6240083.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7d43515457431a6c797a5c4486f3cb1/" rel="bookmark">
			关于Echartsjs引用（echarts is not defined）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候引用下载的echarts会报错，其实直接引用以下的js就可以了：
&lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/echarts-all-3.js"&gt;&lt;/script&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cd5e47001c918b001043eea554dc05f/" rel="bookmark">
			【编程题】求数组的所有子集（java实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【编程题】求数组的所有子集（java实现） 题目描述 求不含重复元素的数组的所有子集
样例
输入
{1,8,5,4,6,7}
输出
[]
[1]
[1, 4]
[1, 4, 5]
[1, 4, 5, 6]
[1, 4, 5, 6, 7]
[1, 4, 5, 6, 7, 8]
[1, 4, 5, 6, 8]
[1, 4, 5, 7]
[1, 4, 5, 7, 8]
[1, 4, 5, 8]
[1, 4, 6]
[1, 4, 6, 7]
[1, 4, 6, 7, 8]
[1, 4, 6, 8]
[1, 4, 7]
[1, 4, 7, 8]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cd5e47001c918b001043eea554dc05f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/164bc37699cd2d00d516b129c6165f9f/" rel="bookmark">
			信息学奥赛一本通C&#43;&#43;语言——1080：余数相同问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【题目描述】
已知三个正整数a，b，c。现有一个大于1的整数x，将其作为除数，用a，b，c分别除以x，得到的余数相同。
请问满足上述条件的x的最小值是多少？数据保证x有解。
【输入】
一行，三个不大于1000000的正整数a，b，c，两个整数之间用一个空格隔开。
【输出】
一个整数，即满足条件的x的最小值。
【输入样例】
300 262 205
【输出样例】
19
代码
#include&lt;cstdio&gt; using namespace std; int main() { int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); for(int i=2;i&lt;=a;i++) if((a%i==b%i)&amp;&amp;(b%i==c%i)) { printf("%d",i); return 0; } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e48257e2b3cdef16103467454cf5803e/" rel="bookmark">
			StringUtils.equals() , StringUtils.equalsIgnoreCase()用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 注意：比较两个字符串是否相等,如果两个均为null，则也认为相等
StringUtils.equals("", ""); //true StringUtils.equals(null, null); //true StringUtils.equals(null, ""); //false StringUtils.equals("",null); //false StringUtils.equals(null,""); //false StringUtils.equalsIgnoreCase("ss", "Ss"); //不区分大小写--true 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c04c7f1d25ff50700dc618dc8f63334c/" rel="bookmark">
			python-使用JtessBoxEditor训练tesseract字库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用JtessBoxEditor训练tesseract字库，加上调用总共分12步
一、将图片格式转换为tif格式
tif文件命名的格式为[语言].[字体].exp[数字].tif
其中语言和字体、数字均为自己设置，可随意，但格式必须是以上格式。后面调用会需要用到字体名称
假设语言为liang，字体为mx
1、打开JtessBoxEditor
2、点击Tools
3、点击Merge TIFF，然后在文件类型选择bmp（可一次性选择多个bmp，最终会合并成一个tif）
4、点击打开图片后，然后保存为liang.mx.exp0.tif
二、在cmd命令行输入命令，生成box文件
1、先cd进入到tesseract的目录下，输入：
tesseract.exe liang.mx.exp0.tif liang.mx.exp0 -l chi_sim batch.nochop makebox
其中第1个liang.mx.exp0.tif为合并的tif文件（这里也可以直接使用bmp文件，但只能识别一个），第2个liang.mx.exp0为生成box文件的文件名，第三个-l（L）指language，使用指定的语言库打开，chi_sim就是中文库，其他的是命令
当前文件下显示 liang.mx.exp0.box（新增），liang.mx.exp0.tif
三、校正图片
1、打开JtessBoxEditor
2、点击Box Editor
3、点击open
4、打开合并的tif图（工具会自动加载对应的box文件，所以tif和box文件必须在同一文件夹下）
5、在左边修改识别文字（尽可能一个框一个字），在右上角的地方可以修改框的大小和位置
Insert：新增框。Delete：删除框。Merge：合并框。Split：拆分框。
6、如果是多个bmp合并的tif，在下方有翻页，翻页处理其他错别字
7、校正完一定要点击save保存
四、生成字体特征文件font_properties
1、打开记事本在里面输入以下内容：
mx 0 0 0 0 0
2、保存后，重命名把名称里的后缀删掉，即把“.txt”删掉，文件名称必须是font_properties。其中mx指自己命名的字体名。0的属性是指字体的属性，比如字体为斜体、粗体等，0代表没有额外属性
当前文件夹下显示：font_properties(新增)，liang.mx.exp0.box，liang.mx.exp0.tif
五、在cmd命令行输入命令，生成训练文件
1、先cd进入到tesseract的目录下，输入：
tesseract liang.mx.exp0.tif liang.mx.exp0 nobath box.train
执行完会生成liang.mx.exp0.tr
其中第一个liang.mx.exp0.tif为上述保存的tif文件，第二个liang.mx.exp0为生成tr文件的文件名（文件名尽可能保持一致）
其他的是命令
当前文件夹下显示：liang.mx.exp0.tr（新增），font_properties，liang.mx.exp0.box，liang.mx.exp0.tif
六、在cmd命令行输入命令，生成字符集文件
1、先cd进入到tesseract的目录下，输入：
unicharset_extractor liang.mx.exp0.box
执行完会生成unicharset
注意：unicharset必须和box文件同步更新，即后面生成新文件时，unicharset也必须重新生成
当前文件夹下显示：unicharset（新增），liang.mx.exp0.tr，font_properties，liang.mx.exp0.box，liang.mx.exp0.tif
七、在cmd命令行输入命令，生成shape文件
1、先cd进入到tesseract的目录下，输入：
shapeclustering -F font_properties -U unicharset -O unicharset liang.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c04c7f1d25ff50700dc618dc8f63334c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cf098c8fce6ce04f2c6e4fde603b706/" rel="bookmark">
			Flink连接Zookeeper消费Kafka数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 废话不多说，直接上代码片段，示例代码（scala版本）：
val env = StreamExecutionEnvironment.getExecutionEnvironment // kafka 配置 val ZOOKEEPER_HOST = "host:prot" val KAFKA_BROKERS = "host:port" val TRANSACTION_GROUP = "group_id" val TOPIC_NAME = "topic" val kafkaProps = new Properties() kafkaProps.setProperty("zookeeper.connect", ZOOKEEPER_HOST) kafkaProps.setProperty("bootstrap.servers", KAFKA_BROKERS) kafkaProps.setProperty("group.id", TRANSACTION_GROUP) val streamData: DataStream[String] = env.addSource(new FlinkKafkaConsumer011[String](TOPIC_NAME, new SimpleStringSchema(), kafkaProps)) pom文件：
&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-connector-kafka-0.11_2.11&lt;/artifactId&gt; &lt;version&gt;${flink.kafka.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dae36a0b097048b4117bc740211787a/" rel="bookmark">
			OSG场景管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2018-09-01
场景管理是渲染引擎的核心功能，我们希望能够把所有的渲染物体合理的组织在一起，而且能够方便的查找、管理。本质上就是设计一个或者多个数据结构。这个目标很容易实现，放在一个数组里就可以了，各种操作的代价也不是很大。但是，这是不行的。
首先，我们需要把显示物体分组，一堆对象可能是属于一起的，在逻辑上在一个集合，虽然我们可以用额外的数据结构来进行分组管理，那很容出错。所以，我们这个数据结构具有递归保存自身节点类型的功能，其实就是一棵树了。
其次，有的节点是逻辑上的，它只是起保存分组信息的功能（Group），还需要让有些节点保存 渲染物体信息的功能（Geode）。那么，这就需要使用C++ 的继承机制，Geode继承于 Group，另外添加一些保存渲染信息的接口即可。有些引擎不是这么设计的，可参与渲染的节点只能是叶子节点。我倒是觉得OSG的设计更方便一些。目前，osg::Geode 默认它的children都是可绘制对象，因为有碰撞检测的需求，可绘制对象必然会碰撞，所以会强制转换为osg::Drawable类型，这样会导致一个问题：osg::Geode不能把组织节点作为 子节点。这个问题一般不大。
第三，当我们想要重用一个节点时该如何呢？总不能把节点的渲染数据复制一份吧。所以，需要场景管理的数据结构支持一个子节点有多个父节点。那么，这棵树现在已经变成一个有向无环图 (Directed Acyclic Graph)了。节点需要增加一个指向多个父节点指针的数组。
第四，OpenGL是状态机机制，但是，场景管理不需要管理渲染API 究竟是如何渲染的，它的职责只是管理了静态的组织结构。如，我们想给一组节点设置属性，如透明与否、缩放程度、是否隐藏、线条粗细、颜色等，所以，节点需要一个保存这些信息的对象（StateSet）。
第五，因为我们想要自动管理场景内存的功能，如删掉一个子节点，且没有其他对象再引用它，那么就可以把它析构掉，而且需要给子节点对象提供保存用户填入的任何类型信息功能，这就需要提供智能指针的支持，所以提供Object和Reference类支持。我对于智能指针的看法是：这不是解决内存泄漏的终极办法，用的不小心，还是一样要内存泄漏。我们在模块设计时，对象的生命周期就应该被充分考虑，不能说有了智能指针，这部分工作就可以不用做了。
第六，因为渲染引擎需要支持各种剔除，那么节点需要支持碰撞检测加速，所以节点需要有包围盒，采用最简单的AABB即可，OSG每个节点都保存一个AABB。要是上层有更严苛的需求，再自己使用强大的包围盒算法。这也一般不是渲染引擎的职责。
第七，简单的3D应用，可能只有一个Camera，但是，复杂的需求一般都会需要使用多个Camera。两个Camera可能只是在不同的角度看向相同的场景，也可能看向完全不同的场景。如一个主Camera，负责看到主场景，一个隐藏Camera，负责设备坐标系的绘制，另一个隐藏Camera，负责绘制需要defer shading的场景， 它们看到的场景时完全不同的。所以，渲染主循环中，遍历Camera以完成渲染，最终按照既定次序把结果组合起来。所以，我们需要把多个场景根节点和多个Camera一一关联起来。OSG的做法是：把Camera作为一个普通的Node，场景根节点root作为Camera的子节点。不得不说这其实挺巧妙的。
第八，最重要的一个需求就是遍历场景。我们有多种遍历场景的需求，一种方式是建立一个通用的遍历函数，它分析遍历到的节点的类型，调用不同类型的回调函数来处理，这样的话回调函数的管理是一个困难的问题；另一种方式就是采用经典的visitor模式。针对不同类型的需求创建不同类型的visitor，而把子节点遍历与类型判断工作放到Node，这样的话就能很好的递归调用了，缺点是看调用栈会有点懵，可能会产生无限循环递归的错误。把visitor对象交给节点，在节点中把节点的指针再交还给visitor，控制权翻转，在Visitor中重载的不同节点类型处理函数中做你想要的逻辑操作。
至于osg::Node，官方文档上说：以组合模式，提供了节点基础的操作接口。它把渲染节点、组织节点都做了一个抽象。
组织管理场景的最重要的几点需求列在上面了，可以看到我们需要的功能点还是比较清晰简单的，也比较容易实现出来。但是，能够做到通用性强，并通过工业强度的检验，还是有难度的。我们做一个模块设计，很多时候，困难的并不是解决常见问题的部分，而是那些比较小但却很不得不解决的问题，导致设计上做了妥协与让步。但是，一步步来，从核心问题开始一个一个解决。
http://public.vrac.iastate.edu/vancegroup/docs/OpenSceneGraphReferenceDocs-3.0/a01814.pnghttps://blog.csdn.net/csxiaoshui/article/details/74859066http://www.bricoworks.com/articles/stateset/stateset.htmlhttp://www.bricoworks.com/articles/stategraph/stategraph.html 如果有任何意见，欢迎留言讨论。 [ 主页 ]
COMMENTS
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82b863508a95002d157160bec154f179/" rel="bookmark">
			C# 设计模式之 -- 状态模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计模式之 – 状态模式 面向对象的设计，其实就是希望做到代码的责任分解， 实现‘单一职责原则’。
状态模式： 主要解决的是，当控制一个对象状态转换的条件表达式过于复杂的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。如果这个状态判断很简单，那就没有必要用“状态模式”。
设计说明：
State --&gt;抽想状态，包含抽象方法。子类必须实现抽象方法。 抽象方法中必须传入状态判断上下文类（Work）Work --&gt;判断状态类，包含 状态判断的属性，完工标识属性 ，设置当前状态方法，和状态对应执行的方法。必须包含状态父类，并执行状态父类的方法。（并且构造函数要赋值初始状态）。VariousStates 文件加下：包含各种状态的逻辑判断和每种状态需要实现的方法。 各个状态类必须继承 State 并且实现 状态父类的抽象方法（抽象方法中需要传入状态判断上下文类 Work）。 结构图 状态模式的好处与用处： 状态模式的好处就是将特定的状态相关行局部化，并将不同的状态行为分割开来。
将特定的状态相关的行为都放入一个对象中，由于 所有与状态相关的代码都存在于某个状态子类中，所以通过定义新的子类可以很容易的增加新的状态和转换。
这样做的目的就算是为了消除庞大的条件分支语句，大的分支判断使得他们难以修改和扩展。状态模式通过把各个状态转移逻辑分布到 State 的子类中，来减少相互间的依赖。
当一个对象的行为取决于它的状态，并且必须在运行时刻根据状态改变它的行为时，可以考虑使用状态模式。
可以把状态定义为一些枚举常量。
代码： 抽象状态
using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace 状态模式 { /// &lt;summary&gt; /// 抽象状态类(工作状态) /// &lt;/summary&gt; public abstract class State { public abstract void WriteProgram(Work work); } } 维护一个抽象状态类的子类，这个实例定义当前状态
using System; using System.Collections.Generic; using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82b863508a95002d157160bec154f179/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eae86d517e201fb369466e8b49ca446/" rel="bookmark">
			去除TextView自带的内边距
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		includeFontPadding = false;去除TextView自带的内边距
includeFontPadding = true;保留TextView自带的内边距
虽然效果不是很明显但还是能够看出效果的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6a8231862f39cda678f965d3eb6f638/" rel="bookmark">
			计算机视觉算法岗面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大佬的面试经验：https://www.nowcoder.com/discuss/128148
以及大佬的博客：https://blog.csdn.net/liuxiao214/article/details/83043170
根据大佬的面试经验一点一点填坑吧。
常见概念 最大似然估计：最大似然估计是一种统计方法，最大似然估计函数在采样样本总数趋于无穷的时候达到最小方差。步骤：1.写出似然函数 2.取对数 3.求导数并令其为0。
最小二乘法：通过最小化误差的平方和寻找数据的最佳函数匹配。
梯度下降法：
梯度下降法的基本思想可以类比为一个下山的过程。假设这样一个场景：一个人被困在山上，需要从山上下来(i.e. 找到山的最低点，也就是山谷)。但此时山上的浓雾很大，导致可视度很低。因此，下山的路径就无法确定，他必须利用自己周围的信息去找到下山的路径。这个时候，他就可以利用梯度下降算法来帮助自己下山。具体来说就是，以他当前的所处的位置为基准，寻找这个位置最陡峭的地方，然后朝着山的高度下降的地方走，同理，如果我们的目标是上山，也就是爬到山顶，那么此时应该是朝着最陡峭的方向往上走。然后每走一段距离，都反复采用同一个方法，最后就能成功的抵达山谷。
模型融合方法：
目前的集成学习方法大致可以分为两大类，即个体学习器间存在强依赖关系、必须串行生成的序列化方法，以及个体学习器间不存在强依赖关系、可同时生成的并行化方法；前者的代表是Boosting，后者的代表是Bagging和随机森林。
1.投票：
假设对于一个二分类问题，有3个基础模型，那么就采取投票制的方法，投票多者确定为最终的分类。
2.平均：
对于回归问题，一个简单直接的思路是取平均。稍稍改进的方法是进行加权平均。权值可以用排序的方法确定，举个例子，比如A、B、C三种基本模型，模型效果进行排名，假设排名分别是1，2，3，那么给这三个模型赋予的权值分别是3/6、2/6、1/6。这两种方法看似简单，其实后面的高级算法也可以说是基于此而产生的，Bagging或者Boosting都是一种把许多弱分类器这样融合成强分类器的思想。
3.Bagging：
就是采用有放回的方式进行抽样，用抽样的样本建立子模型,对子模型进行训练，这个过程重复多次，最后进行融合。大概分为这样两步：
① 重复K次，有放回地重复抽样建模，训练子模型
② 模型融合，分类问题：voting，回归问题：average
随机森林就是基于Bagging算法的一个典型例子，采用的基分类器是决策树。
4.Boosting：
Bagging算法可以并行处理，而Boosting的思想是一种迭代的方法。
AdaBoost 是Boosting 算法家族中代表算法，AdaBoost 每一次训练的时候都更加关心分类错误的样例，给这些分类错误的样例增加更大的权重，下一次迭代的目标就是能够更容易辨别出上一轮分类错误的样例，最终将这些弱分类器进行加权相加。AdaBoost模型是弱分类器的线性组合，AdaBoost算法的一个解释是该算法实际上是前向分步算法的一个实现，在这个方法里，模型是加法模型，损失函数是指数损失，算法是前向分步算法。
xgboost相对AdaBoost区别，对损失函数做了二阶的泰勒展开，并在目标函数之外加入了正则项对整体求最优解，用以权衡目标函数的下降和模型的复杂程度，避免过拟合。所以不考虑细节方面，两者最大的不同就是目标函数的定义
L1L2正则：
判别式模型与生成式模型：：
判别式模型（Discriminative Model）是直接对条件概率p(y|x;θ)建模。常见的判别式模型有 线性回归模型、线性判别分析、支持向量机SVM、神经网络等。
生成式模型（Generative Model）则会对x和y的联合分布p(x,y)建模，然后通过贝叶斯公式来求得p(yi|x)，然后选取使得p(yi|x)最大的yi，
常见的生成式模型有 隐马尔可夫模型HMM、朴素贝叶斯模型、高斯混合模型GMM、LDA等。https://blog.csdn.net/huangfei711/article/details/79834780
熵-交叉熵-KL散度：
熵：信息熵是度量随机变量不确定度的指标，信息熵越大意味着随机变量不确定度越高，意味着系统的有序程度越低。
交叉熵：主要用于度量两个概率分布间的差异性信息。
KL散度/相对熵：是描述两个概率分布P和Q差异的一种方法。
三者间关系：
最优化方法（梯度下降，牛顿法，共轭梯度法）：
牛顿法：
交叉验证：
第一种是简单交叉验证，所谓的简单，是和其他交叉验证方法相对而言的。首先，我们随机的将样本数据分为两部分（比如： 70%的训练集，30%的测试集），然后用训练集来训练模型，在测试集上验证模型及参数。接着，我们再把样本打乱，重新选择训练集和测试集，继续训练数据和检验模型。最后我们选择损失函数评估最优的模型和参数。
第二种是S折交叉验证（S-Folder Cross Validation）。和第一种方法不同，S折交叉验证会把样本数据随机的分成S份，每次随机的选择S-1份作为训练集，剩下的1份做测试集。当这一轮完成后，重新随机选择S-1份来训练数据。若干轮（小于S）之后，选择损失函数评估最优的模型和参数。
第三种是留一交叉验证（Leave-one-out Cross Validation），它是第二种情况的特例，此时S等于样本数N，这样对于N个样本，每次选择N-1个样本来训练数据，留一个样本来验证模型预测的好坏。此方法主要用于样本量非常少的情况，比如对于普通适中问题，N小于50时，我一般采用留一交叉验证。
此外还有一种比较特殊的交叉验证方式，也是用于样本量少的时候。叫做自助法(bootstrapping)。比如我们有m个样本（m较小），每次在这m个样本中随机采集一个样本，放入训练集，采样完后把样本放回。这样重复采集m次，我们得到m个样本组成的训练集。当然，这m个样本中很有可能有重复的样本数据。同时，用没有被采样到的样本做测试集。这样接着进行交叉验证。由于我们的训练集有重复数据，这会改变数据的分布，因而训练结果会有估计偏差，因此，此种方法不是很常用，除非数据量真的很少，比如小于20个。
皮尔逊系数：
皮尔逊相关系数广泛用于度量两个变量之间的相关程度，其值介于-1与1之间。两个变量之间的皮尔逊相关系数定义为两个变量之间的协方差和标准差的商：
bias-variance-tradeoff：偏差方差权衡
1、Bias and Variance tradeoff的最简单方法
当Bias很高的时候，就增加模型的复杂度（比如增加神经网络的神经元个数，神经网络的层数）
当Variance很高的时候，就增加训练的样本量。
然而以上的原则只是一个大的指导方向，因为在实际操作中增加模型的复杂程度将会大大增加计算机的计算量，而且还容易造成Overfitting。 下面详细介绍在实际操作中处理Bias 和 Variance 的具体方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6a8231862f39cda678f965d3eb6f638/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c12e8e55046f19419afe1bef3b38c5b/" rel="bookmark">
			c#毫秒计时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c#毫秒计时器
using System; using System.Diagnostics; using System.Windows.Forms; private TimeSpan ts; private Stopwatch sw; private Timer timer; private void CreatTimer() { timer = new Timer(); timer.Interval = 1; timer.Tick += Timer_Tick; } private void Timer_Tick(object sender, EventArgs e) { ts = sw.Elapsed; //输出 this.toolStripStatusLabel1.Text = this.ts.ToString(@"hh\:mm\:ss\:") + int.Parse(this.ts.ToString(@"fff")) / 10; //其他格式化 //this.toolStripStatusLabel1.Text = string.Format("{0:D2}:{1:D2}:{2:D2}:{3:D2}:{4:D2}", this.ts.Days, this.ts.Hours, this.ts.Minutes, this.ts.Seconds, this.ts.Milliseconds / 10); //this.toolStripStatusLabel1.Text = string.Format("{0:00}:{1:00}:{2:00}:{3:00}:{4:00}", this.ts.Days, this.ts.Hours, this.ts.Minutes, this.ts.Seconds, this.ts.Milliseconds / 10); } /// &lt;summary&gt; /// 开始计时 /// &lt;/summary&gt; private void StopwatchStart() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c12e8e55046f19419afe1bef3b38c5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4646fe5d86e592791c932f2e18614361/" rel="bookmark">
			ARM汇编详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本指令学习
在博文：keil下ARM汇编程序建立与调试简介中学习建立ARM汇编程序工程。
本博文开始学习一步一步写ARM汇编程序。
一、重要概念理解
1. 立即数
1）把数据转换成二进制形式，从低到高写成 4位1组的形式，最高位一组不够4位的前面补0
2）数1的个数，如果大于8个【可能也是立即数，取反】不是立即数，如果小于等于8个 进行下面步骤
3）如果数据中间有连续的大于等于24个0，循环左移2的倍数，使高位全为0
4）找到最高位的1，去掉前面的最大偶数个0
5）找到最低位的1，去掉后面偶数个0
6）数剩下的位数，如果小于等于8位，那么这个数就是个立即数，反之就不是立即数
举例：判断0x80000001是不是立即数
1）二进制形式：1000 0000 00000000 0000 0000 0000 0001
2）1的个数小于8个，进入第三步
3）循环左移2位，这步结果为：00 0000 0000 0000 0000 0000 0000 000110
4）这步结果为：0110
5）这步结果为：0110
6）满足条件，所以0x80000001是立即数
判断一个数是否是立即数的目的是：在汇编操作中，有些指令操作的数只能是立即数，比如movr0,#0xnum ; num就必须是立即数。
2. 条件码，
条件码：本条指令的执行，依赖于上一个指令的执行结果举例理解，
比如寄存器中r0和r1分别保存两个数，如果r0小于r1，将r1值传给r0： cmp r0,r1 ；比较r0和r1，会有某个标志位记下它们比较的结果movlt r0,r1 ；movlt = mov + lt ,查上表知为lt为带符号数小于，也就是说mov在r0&lt; r1时，才执行mov操作。如何查看条件是否成立呢？cmpr0,r1执行后，cpu就查看cpsr中N是否等于V, 不等于是说明r0&lt; r1成立，执行mov操作。 3. cpsr中各个标志位具体含义 标志位 含 义 N 当用两个补码表示的带符号数进行运算时，N=1表示运算的结果为负数；N=0表示运算的结果为正数或零 Z Z=1表示运算的结果为零，Z=0表示运算的结果非零。 C 可以有4种方法设置C的值： -加法运算（包括CMP）：当运算结果产生了进位时（无符号数溢出），C=1，否则C=0。 -减法运算（包括CMP）：当运算时产生了借位时（无符号数溢出），C=0，否则C=1。 -对于包含移位操作的非加/减运算指令，C为移出值的最后一位。 -对于其它的非加/减运算指令，C的值通常不会改变。 V 可以有2种方法设置V的值： -对于加减法运算指令，当操作数和运算结果为二进制的补码表示的带符号数时，V=1表示符号位溢出 -对于其它的非加/减运算指令，V的值通常不会改变。 Q 在ARM V5及以上版本的E系列处理器中，用Q标志位指示增强的DSP运算指令是否发生了溢出。在其它版本的处理器中，Q标志位无定义 二、基本指令练习
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4646fe5d86e592791c932f2e18614361/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd33e9ef3cf23d454cb4ce6956479637/" rel="bookmark">
			dwa_local_planner_params.yaml解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dwa_local_planner_params.yaml调用源:
&lt;rosparam file="$(find turtlebot_navigation)/param/dwa_local_planner_params.yaml" command="load" /&gt; 由于参数较多，注释直接写在源文件里
DWAPlannerROS: # Robot Configuration Parameters - Kobuki 机器人配置参数，这里为Kobuki底座 max_vel_x: 0.5 # 0.55 #x方向最大线速度绝对值，单位:米/秒 min_vel_x: 0.0 #x方向最小线速度绝对值，单位:米/秒。如果为负值表示可以后退. max_vel_y: 0.0 # diff drive robot #y方向最大线速度绝对值，单位:米/秒。turtlebot为差分驱动机器人，所以为0 min_vel_y: 0.0 # diff drive robot #y方向最小线速度绝对值，单位:米/秒。turtlebot为差分驱动机器人，所以为0 max_trans_vel: 0.5 # choose slightly less than the base's capability #机器人最大平移速度的绝对值，单位为 m/s min_trans_vel: 0.1 # this is the min trans velocity when there is negligible rotational velocity #机器人最小平移速度的绝对值，单位为 m/s trans_stopped_vel: 0.1 #机器人被认属于“停止”状态时的平移速度。如果机器人的速度低于该值，则认为机器人已停止。单位为 m/s # Warning!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd33e9ef3cf23d454cb4ce6956479637/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de542eab9c4c98644c0ff15a1193e439/" rel="bookmark">
			ArcEngine实现各个图层面积\长度\个数的实时统计（20190804）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1需求 在空间规划作业中，编辑要素时，我们需要同时知道编辑要素的面积或长度，以保证工程在预算范围之内，所以，我们需要有一个工具对编辑过程进行实时的检测。
2设计思路 （1）首先需要编辑Map中的所有图层，把符合统计条件的图层找出来，在这里符合条件的是shp数据，如果是shp数据则进行统计；
（2）对符合条件的图层的各个要素（Feature）进行遍历，以求得每个要素(Feature)的长度\面积，求和即得到总长度/面积，对于点要素那当然更简单，直接返回其Count属性即可。
（3）统计的结果在GridView中显示，GridView绑定一个数据表(DataTable)，数据表的每一行表示一个图层的面积\长度\个数统计；
（4）换算单位。
3界面设计 （1）主界面，设计的比较简单，仅作为示范：
（2）统计功能的界面设计：
4代码实现 主窗体的代码很简单，加载数据，弹出窗体网上的示例很多，这里主要说说统计功能界面的代码。
按照第二部分的思路，写出各个步骤的代码。
（1）遍历Map中的所有shp图层：
//返回Map中所有的ShapeFile图层 private List&lt;IFeatureLayer&gt; getAllShp(IMap map) { IFeatureLayer pFeatureLayer; List&lt;IFeatureLayer&gt; shpLayreList = new List&lt;IFeatureLayer&gt;(); for(int i = 0; i &lt; map.LayerCount; i++) { if (map.Layer[i] is GroupLayer) { ICompositeLayer pComLayer = map.Layer[i] as ICompositeLayer; for (int j = 0; j &lt; pComLayer.Count; j++) { pFeatureLayer = pComLayer.Layer[j] as IFeatureLayer; if (pFeatureLayer.DataSourceType.Contains("Shapefile")) shpLayreList.Add(pFeatureLayer); } } else if (map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de542eab9c4c98644c0ff15a1193e439/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2abb02e197feea48e54acac4ad9f77a6/" rel="bookmark">
			普里姆（Prim）算法和克鲁斯卡尔（KrusKal）算法构造最小生成树有什么区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Prim算法和KrusKal算法构造最小生成树 前言 先说好，大家一定要耐心看下去，看完了就知道有什么区别了！
首先，大家回忆一下什么是最小生成树？
最小生成树：就是一个图的生成树集合当中权值之和最小的生成树，可以有一种，也可以有多种，这与图本身结构有关（等会会说到这一点）。
有的同学就问道，那么什么是生成树？
生成树：就是一个连通图的极小连通子图（它包含图中的所有顶点，并且只含有尽可能少的边。），这意味着对于生成树来说，若看去他的一条边，则会使该生成树（极小连通子图）变为非连通图；同样，你多添加一条边，则图中肯定会形成一条回路。
说到这里，应该都明白什么是生成树了。
回到最小生成树：为什么一个图的最小生成树可能不唯一？
1. 首先说一下最小生成树唯一的情况！！！
道理很简单，你要去好几家亲戚家拜年 通过选择最短的路程，之前你已经走过了上图中箭头所示的路径到达了爷爷家；
现在从爷爷家去哥哥家有很多种选择，可以走7公里的，走10公里的，甚至还可以绕回来到弟弟家，然后走6公里的（当然“一般人”不会这么选择吧），因此根据最小生成树的选法，选择权值最小的边（这里是路程最短的路——7公里），这样一来，整个图的最小生成树就如下图所示。
2. 再说一下最小生成树不唯一的情况！！！
还是刚才的例子，这回路径变了，如下图：
情况和上面的一直，但是这次爷爷去哥哥家的路变成了两条都是10公里的路，那么问题来了选择谁呢？
当然还是根据最小生成树的概念选择一条权值最小的边（这里两条都是10，既然最终路程都是一致，那么就是可以两条任意选择一条即可），得到的最小生成树自然就有两种不同的啦。如下图：
？？？说好的讨论普里姆（Prim）算法和克鲁斯卡尔（KrusKal）算法构造最小生成树有什么区别的呢？
哈哈，其实我说这么多就是为了证明一件事。（下面可能说的比较粗鲁）
普里姆（Prim）算法和克鲁斯卡尔（KrusKal）算法构造最小生成树相不相同，和这两种算法有设么必然的联系吗
我（一个连通图），能生成最小生成树的个数，不是看我本身有多大能耐吗？管这两位算法小兄弟啥事啊！
连通图才是主角。
说正经的！
一个图的最小生成树是不是唯一的，还得看连通图中的各边权值是不是互不相等；
如果互不相等，那么连通图G的生成树肯定是唯一的；而且如果无向连通图的边数比顶点数少1（此时G本身是一棵树），此时G的最小生成树就是它本身。最小生成树的边的权值之和总是唯一的，虽然最小生成树可能不唯一（就是图形不一致），但其对应的变得权值之和总是唯一的，而且是最小的。另外，有个很重要的结论：最小生成树的边数为顶点数减1。 我可能有些地方说的不是特别清楚，萌新总结一下自己的想法。
如果有什么不妥的地方，还希望大家指点，谢谢各位了。
日常鸡汤：今天不努力，明天不努力，那么你的人生永远只是在重复。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d86ceb52061a3d483edd955aad879192/" rel="bookmark">
			MVCS框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 MVC消息通信，依赖注入MVCS目录结构ContextCommandViewModelsServicesAwayBuilder架构awaybuilder-destop awaybuilder-core参考 记一下自己对以前做的东西的理解。 AwayBuilder是一个游戏场景编辑器。采用了robotlegs以依赖倒置原则写的MVSC框架（这是我第一个接触的框架）。 MVC 一开始只有View
但是数据显示，我们需要调用接口，获取数据，存在视图的某个属性中，更新视图。如果其他模块想使用这个数据，需要知道这个视图，或者重写计算一遍。
把数据保存到别处，和视图不共享一个生命周期，分离出来的数据规定为（模型，提供数据只是模型的一个功能，具体内容按需求来）。
现在分离了表现。但是控制加载数据这部分代码，需要获取数据，更新视图。二种，放在视图上，放在模型上。把这部分代码剔除来，就是Controller（控制器）
分离出控制器后，就解耦了模型和视图关于控制部分的联系，模型和视图它们只关心控制器，不关心对方。
消息通信，依赖注入 视图和模型对控制器的调用是一句话，但是还是要依赖于控制器（导入控制器的代码）。同样控制器只关心视图和模型对外的接口，不关心视图和模型的环境。
为了能够彻底分离和结构，通过调用代码使用发送消息或其他动态形式，这样就能做到独立编译（也方便测试）。
自动依赖注入是MVC框架的一个功能。
RobotLegs则是基于消息以及消息携带的数据等来实现解耦。
依赖注入和控制反转其实就是同一个事情。
控制反转是一个对象如何获取他所依赖的对象的引用。
注入图
MVCS 分离：MVCS 提供一种将你的应用程序分离到提供特定功能的无关联的层的很自然的方法。 view 层处理用户交互。 model 层处理用户创建的或从外部获取的数据。 controller 提供一种封装各层之间复杂交互的机制。 最后， service 层提供一种和外界(比如远程服务 API 或文件系统)交互的独立机制。
组织：通过这种分离我们自然获得一个组织水平。 每个项目都需要某个组织水平。 是的，有人可以把他们所有的类都扔到顶级包下完事，但即使是最小的项目这也是不可接受的。 当一个项目有了一定的规模就需要开始组织类文件的结构了。 当向同一个应用程序开发中增加团队成员的时候问题就更加严重了。 RobotLegs 的 MVCS 实现为项目描绘出一个分为四层的优雅的组织结构。
解耦：Robotlegs 的MVCS实现将应用程序解耦为4层。 每层都与其它层隔离， 使分离类和组件分别测试变得非常容易。除了简化测试进程， 通常也使类更具便携性以在其它项目中使用。 比如， 一个连接到远程 API 的 Service 类可能在多个项目中都很有用。 通过解耦这个类， 它可以不需重构便从一个项目转移到另一个中使用。
Context：所谓Context（上下文），实际上是一套自展机制，用来初始化Robotlegs所使用的依赖注入以及各种核心工具。
Commands：所谓Commands（命令），代表的是应用程序所能执行的独立操作。通常，Commands（命令）会作为对用户操作的反应，但命令的作用并不仅限于此。
Mediators：所谓Mediators（中介），是用来管理应用程序中的视图组件与应用程序中的其它对象之间的信息交流。
Model：Models（模型）中保存着数据信息，并且表现出应用程序当前的状态。
Service：Services（服务），是应用程序与外界的接口。
目录结构 [domain.lib] various utilities [domain.project] [projectmodule] [model] [events] [vo] ProjectModuleStateModel [view] [events] [renderers] [skins] MyProjectModuleView MyProjectModuleViewMediator [controller] [startup] MyProjectModuleActionCommand [service] [helpers] MyProjectModuleService IProjectModuleService [signals] [projectmodule] [model] [events] [vo] ProjectModuleStateModel [view] [events] [renderers] [skins] MyProjectModuleView MyProjectModuleViewMediator [controller] [startup] MyProjectModuleActionCommand [service] [helpers] MyProjectModuleService IProjectModuleService [signals] … Context Command Controller 层由 Command 类体现（一个Command是一个简明、单一目的的控制器controller对象）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d86ceb52061a3d483edd955aad879192/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c90e420920146cc3e0385e16160fa508/" rel="bookmark">
			锁存器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 RS锁存器的电路结构及工作原理
RS锁存器是一两输入、两输出的电路，其电路如下图a，其有两个互相交叉反馈相连的两个与非门构成，其两个输出为两个相反的输出（或称为互补输出），图b给出了其逻辑符号。
图中/RD,/SD为RS锁存器的两个输入端，Q和/Q为两个互补的输出，从图上不难看出，当/RD、/SD为高 电平时输出状态不发生变化，而仅当其一个输入为低电平时，输出才发生变化，故/RD、/SD为低电平有效。
下面我们来看一下RS锁存器的工作过程，我们可分四种情况加以讨论：
1. /RD=0,/SD=0
从电路上可以看出，当/RD=0,/SD=0时，Q=/Q=1，而锁存的Q、/Q是两个互补的输出，而现在两个输出相等，这是不允许的，故这种情况对于锁存器来讲是不允许的，故通常称其为不允许的状态；
2./RD=0,/SD=1
由于/SD=1，故Q的状态取决于/Q的状态，而由于/RD=0,/Q=1,故Q=0，所以说当/RD=0,/SD=1时触发器被置0,故称为置0状态；
3./RD=1,/SD=0
这跟上一种情况正好相反，其Q=1,/Q=0,即触发器被置1,故称为置数状态；
4./RD=1,/SD=1
由于RS的输入为低电平有效，而现在两个输入皆为高电平，故其输出状态保持不变，称为保持状态。
上面的RS锁存器是一个由与非构成的，用或非门同样也可以构成RS锁存器，同样实现RS锁存器的功能。
● RS锁存器时序图
RS锁存器的状态真值表及特征方程
由上面的原理分析和时序图不难用真值表的形式将其表示出现，其就是状态真值表，其由输入/RD,/SD及输出的现态Qn、次态Qn+1几项构成，如下表：
/RD
/SD
Qn
Qn+1
功能
0
0
0
不允许状态
0
0
1
0
1
0
0
置0
0
1
1
0
1
0
0
1
置1
1
0
1
1
1
1
0
0
保持
1
1
1
1
在描述组合逻辑电路时通常使用逻辑函数来描述，在这时RS锁存器也可以用特征方程(Characteristic Equation)来描述其逻辑功能，下式就是其特征方程：
Qn+1=/(/SD)+/RDQn
/SD+/RD=1
其中：/SD+/RD=1为约束条件，即正常使用时/SD，/RD不能同时为0。
RS锁存器的应用举例
基本RS锁存器虽然电路相当简单，但有很广泛的使用，下图是在时序电路是广泛使用的消除抖动开关电路的使用的例子。
我们通常使用的开关一般是机械触点实现开关的合上和断开的，由于机械触点存在弹性，这就决定了当它们合上的时候，其合产生反弹的问题，反映在电信号上将不规则的脉冲信号，当我们希望合上输出就为低电平时，就须通过电路加以改进，下图就实现变个功能。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e5ff8abdd328424aabf9e4e85b78b03/" rel="bookmark">
			Java异常的详细概述及处理方式（敲详细！！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java异常的详细概述 一、异常的概念及体系结构 异常： 就是程序出现了不正常的情况。 体系结构： Throwable 是Java语言中所有错误或异常的父类 1 Error：严重问题，不需要处理 2 Exception RuntimeException： 在编译期是不处理的，在程序运行时候出现了问题，需要我们回来修改代码。 非RuntimeException： 在编译期就必须处理，否则程序不能通过编译，就更不能正常的执行了。 二、JVM针对异常的默认处理方式 JVM默认异常处理方式：
1让程序停止执行
2把异常的名称，异常的原因，异常出现的位置等信息在控制台输出
代码： public class ExceptionDemo2 { public static void main(String[] args) { System.out.println("程序开始执行"); method(); System.out.println("程序结束执行"); } public static void method() { int a = 10; int b = 0; System.out.println(a/b); } } 上面的代码报的异常是ArithmeticException，如下图：
异常信息分为三部分：
1、
异常处理类：包名+类名，java.lang是包名，ArithmeticException是类名
2、
打印异常原因：不能被0整除
3、
异常出现的位置
三、异常处理方案try_catch 格式： try { 可能出现异常的代码; }catch(异常类名 变量名) { 异常的处理代码; } 执行流程：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e5ff8abdd328424aabf9e4e85b78b03/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/466/">«</a>
	<span class="pagination__item pagination__item--current">467/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/468/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>