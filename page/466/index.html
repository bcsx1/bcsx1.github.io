<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ab22d0e14b08454c69f15d16e0d5e84/" rel="bookmark">
			2.3 浮点数的表示与运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浮点数表示法是指以适当的形式将比例因子表示在数据中，让小数点的位置根据需要而浮动。所以，在位数有限的情况下，既扩大了数的表示范围，又保持了数的有效精度。
浮点数表示为 （可以想象下科学计数法）
r是浮点数阶码的底（隐含），与尾数的基数相同，通常r=2。E和M都是有符号的定点数，E称为阶码，M称为尾数。
阶码是整数，阶符Jf和阶码的位数m共同反映浮点数的表示范围及小数点的实际位置；数符Sf代表浮点数的符号；尾数的位数n反映浮点数的精度。
规格化浮点数，为了提高运算的精度，需要充分地利用尾数的有效数位，通常采用浮点数规格化形式，即规定尾数的最高数位必须是一个有效值。
左规：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数算数左移一位，阶码减1（基数为2时）的方法称为左规，左规可能要进行多次。
右规：当浮点数运算的结果尾数出现溢出，将尾数算术右移一位，阶码加1（基数为2时）的方法称为右规。当需要右规时，只需要进行一次。
下面是基数不同时候的规格化标准
IEEE754标准
IEEE754标准规定常用的浮点数格式有短浮点数（单精度，float型） ,长浮点数（双精度，double型），临时浮点数
短浮点数与长浮点数都采用隐含尾数最高数位的方法，故可多表示一位尾数。临时浮点数又称扩展精度浮点数，无隐含位。
阶码以移码存储，尾码以原码存储。
规格化的短浮点数的真值为 其中，s=0表示正数，s=1表示负数；短浮点数E的取值1~254（8位表示），M为23位，共32位。（偏执值为127而非128，空出8位全1来表示无穷大，阶码值E的范围为1~254，空出全0表示非规格化数）
浮点数的加减运算
浮点数运算时阶码运算和尾数运算分开进行。浮点数的加减法采用补码。
1&gt; 对阶 对阶的目的是使两个操作数的小数点位置对齐，即使得两个数的阶码相等。为此，先求阶差，然后小阶向大阶看齐的原则，将阶码小的尾数右移一位（基数为2）,阶码加1，直到两个数的阶码相等为止。
2&gt; 尾数求和
将对阶后的尾数按定点数加（减）运算规则运算。
3&gt; 规格化
以双符号为例，当尾数的最高数值位与符号位不同时，即为规格化形式。规格化分为左规与右规。
左规：当尾数出现00.0xxx..x或11.1xxx...x时，需左规，即尾数左移1位，和的阶码减1，直到尾数为00.1xxx...x或11.0xxx...x
右规：当尾数求和结果溢出，需要右规，即尾数右移一位，和的阶码加1。
4&gt; 舍入
在对阶和右规的过程中，可能会将尾数低位丢失，引起误差，影响精度。常见的舍入方法有：“0”舍“1”入法和恒置“1”法。
“0”舍“1”入法：类似于十进制数运算中的“四舍五入”法，即在尾数右移时，被移去的最高数值位为0，则舍去；被移去的最高数值位为1，则在尾数的末位加1。这样做可能会使尾数又溢出，此时需再做一次右规。
恒置“1”法：尾数右移时，无论丢掉的最高数值位是“1”还是“0”，都使右移后的尾数末位恒置为“1”。这种方法同样有使尾数变大和变小两种可能。
5&gt; 溢出判断
尾数之和（差）出现01.xxx或10.xxxx时，并不表示溢出，只能将此数右规后，再根据阶码来判断浮点数运算结果是否溢出。
浮点数的溢出与否是由阶码的符号决定的。比如双符号位“01”，“10”表示上溢和下溢。所以阶码符号位不同表示溢出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aa031d8e8acc41c133f3564e2c83c18/" rel="bookmark">
			深度模型（八）：Wide And Deep
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 广义线性模型和非线性特征变换的组合广泛用于输入稀疏的大规模回归和分类问题。特征的交叉非常有效并且可解释性也很好，但是为了提高模型泛化能力，需要大量的特征工程工作。深度神经网络可以更好的通过稀疏特征的低纬稠密向量泛化到非显性的特征组合。但是当用户物品的交互数据比较稀疏的时候，深度神经网络可能会过拟合。本文我们提出wide &amp; deep 学习，同时训练线性模型和深度模型，结合了记忆与泛化的优点。我们在Google Play商店内的10亿用户和百万App上评测了我们的模型，结果显示相比纯wide和纯deep模型，wide &amp; deep模型显著提升了app的下载数。我们也开源了模型的tensorflow实现。
1 简介 推荐系统可以看做一个搜索排序系统，搜索的输入是用户和上下文信息，输出是一个有序的物品列表。给定一个输入，推荐任务首先就是在数据库中找到相关的物品，然后基于特定的目标比如点击和购买，将相关物品进行排序。
类似与通用的搜索排序问题，推荐系统的挑战之一是实现记忆与泛化。记忆可以简单定义为学习并利用物品或特征在历史数据中的的共现关系。泛化则是基于相关性的传递性，探索历史数据中未出现或很少出现的组合。基于记忆的推荐系统通常更加主题化，推荐的物品跟用户历史物品比较直接相关。而基于泛化的推荐，倾向于提升推荐物品的多样性。本文中我们主要关注Google Play的App推荐，但是方式同样适合与通用的推荐系统。
对于大规模的在线推荐和排序系统，广义的线性模型的使用非常广泛，因为它们简单、易扩展、解释性良好。模型的特征经常采用二值的稀疏特征，经过one-hot编码。二值特征例如"user_installed_app=netflix", 值为1表示用户安装了Netflix。 通过特征的交叉操作，比如特征AND(user_installed_category=netflix,impression_app=pandora),值为1表示用户安装了netflix，喜欢的app为Pandora. 此特征可以解释这一对原始特征与目标标签的相关性。如果需要加入泛化，则可以选择具有泛化性的特征，比如AND(user_installed_category=video,impression_category=music)。这样做的缺点是通常需要大量特征工程，来筛选出有用的特征组合。特征交叉的另一个局限是没法学习到历史数据中未曾出现的特征组合。
基于Embedding的模型，比如FM和深度神经网络，通过为每个特征学习一个低纬稠密的Embeddding向量，可以泛化到历史数据中未出现的特征组合。但是，如果历史数据稀疏并且高秩(high-rank),则很难学习到有效的embedding表示。
本文我们提出Wide&amp;Deep学习框架，实现记忆与泛化的结合。本文的主要贡献有：
Wide &amp; Deep框架,同时训练前向反馈神经网络与线性模型模型在Google Play商店的10亿用户和一百万的app上部署和评测开源了模型的Tensorflow实现 推荐系统概要 系统的结构图如下所示。当用户访问商店的时候，包含用户和上下文信息的多种特征作为推荐系统的输入，推荐系统返回一个app列表。用户可能会点击或购买这些app。用户的这些行为会被记录，作为模型的训练数据。
由于物品数量达到百万量级，每次请求为每个物品打分不可行。因此推荐的第一步是召回，从数据库中获取最匹配的若干个候选物品。第二步是排序，对候选物品进行打分。得分通常是记为 P ( y ∣ x ) P(y|x) P(y∣x),表示给定特征 x x x，标签 y y y出现的概率。本文中我们主要关注排序模型。
3. Wide &amp; Deep learning 3.1 wide部分 wide部分是广义线性模型: y = W T x + b y=W^Tx+b y=WTx+b，其中 y y y表示预测值， x = [ x 1 , x 2 , .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9aa031d8e8acc41c133f3564e2c83c18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4da46d1328d9ae101539b3f4fd3bfe3/" rel="bookmark">
			Argument list too long终极解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文针对linux下某个目录下文件巨多无法打包备份及删除而提供的解决方案，有需要的朋友可以了解下~~ 1、第一步进入到需要打包的文件目录下，将所有后缀为.txt或者你想要打包的文件的路径及名称输入到test.maniftest中，也可以是.jpg等等 find . -name '*.txt' -print &gt;/tmp/test.manifest 2、第二步，使用tar打包，textfiles.tar.gz是你想要打包的文件名 tar -cvzf textfiles.tar.gz --files-from /tmp/test.manifest 3、第三步备份到本地，因为文件巨大无法使用sz命令保存到本地，可以使用xftp保存到本地 4、删除该目录下的所有文件，若是提示没有删除权限，可以先给该目录授权 chomd 777 目录名称 这里千万注意的是一定要进入到该目录里面，不然会删除这一层所有目录，刚开始就是因为没有进入到想删除的目录，导致在上一层目录所有的文件全部删除了，后悔莫及，在此记录一下 ls | xargs -n 10 rm -rf （注意：一定要进入到你要删除的目录中，不然会删除该层所有目录的所有文件） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4a7f5ddd8ab19652ffab1579e12b565/" rel="bookmark">
			java  wsdl  直接生成java类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C:\Users\My-Think&gt;wsimport -d D:\project\countriyEhci\bak\test\src -s D:\projec
t\countriyEhci\bak\test\class http://10.235.64.1/services/synERhcInfo?wsdl
parsing WSDL...
参数：
-d class类存放目录
-s 源代码存放目录
wsdl文档存放目录
目录文件夹需提前建立
生成之后 可以直接调用java 类访问webservice 接口
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1109c069ac15c5c8a29ff864ec07c517/" rel="bookmark">
			windows 原生端口映射端口转发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加端口映射
netsh interface portproxy add v4tov4 listenport=14941 connectaddress=pay.swiftpass.cn connectport=80
查看端口映射
netsh interface portproxy show v4tov4
删除端口映射
netsh interface portproxy delete v4tov4 listenport=14941
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eee023e842353aab4850e5a4bcfe6657/" rel="bookmark">
			PyQt5 QTableView 全部item居中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 核心思路是重写QSqlTableModel的data函数
class MyModel(QSqlTableModel): def __init__(self): QSqlTableModel.__init__(self) def data(self, index, role=None): if role == Qt.TextAlignmentRole: return Qt.AlignCenter return QSqlTableModel.data(self, index, role) 在主函数中setModel
# 视图加载模型 self.myTableView.setModel(self.model) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b74f62208186408b3192a9974ce86a5/" rel="bookmark">
			关于keil 中出现“give arg types”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		检查在申明没有参数的函数，是不是写掉了void，加上就可以去掉这个warning了。
如：
void Delay_ms_init(void);
规范编程，就没有问题了！
转载于:https://www.cnblogs.com/Hocker/p/5391097.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba098d64ab389fabd4c84711a2079e34/" rel="bookmark">
			【Unity 22】 Unity 力，扭矩，刚体，触发器的简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PS:本系列笔记将会记录我此次在北京学习Unity开发的总体过程，方便后期写总结，笔记为日更。
笔记内容均为 自己理解，不保证每个都对。
Part 1 力 刚体.AddForce()； 常用的四种力模式：
ForceMode意义ForceMode.Force（默认）添加一个可持续的力，使用其质量ForceMode.Acceleration添加一个可持续的力，忽略其质量，无论设置多少都为1ForceMode.Impulse添加一个瞬间爆发力，使用其质量ForceMode.VelocityChange添加一个瞬间爆发力，忽略其质量，无论设置多少都为1 添加力的注意事项：
1、添加在刚体上
2、写在FixedUpdate()中
例如：
tmpRig.AddForce(new Vector3(10, 0, 0), ForceMode.Force); //添加一个可持续力，使用其重量 tmpRig.AddForce(new Vector3(10, 0, 0), ForceMode.Acceleration); //添加一个可持续力，忽视其重量,无论设置多少都默认为1 tmpRig.AddForce(new Vector3(10, 0, 0), ForceMode.Impulse); //添加一个瞬间爆发力，使用其重量 tmpRig.AddForce(new Vector3(10, 0, 0), ForceMode.VelocityChange); //添加一个瞬间爆发力，忽视其重量，无论设置多少都默认为1 爆发力：
AddExplosionForce(float explosionForce, Vector3 explosionPosition, float explosionRadius, float upwardsModifier);
explosionForce 爆炸力的大小
explosionPosition 爆炸力的点位
explosionRadius 爆炸半径
upwardsModifier 爆炸衰减值，值越大衰减越大
Part 2 扭矩： 四种扭矩模式 与 四种力模式相同
ForceMode意义ForceMode.Force（默认）添加一个可持续的力，使用其质量ForceMode.Acceleration添加一个可持续的力，忽略其质量，无论设置多少都为1ForceMode.Impulse添加一个瞬间爆发力，使用其质量ForceMode.VelocityChange添加一个瞬间爆发力，忽略其质量，无论设置多少都为1 eg:
tmpRig.AddTorque(new Vector3(0, 4, 0), ForceMode.Force); //添加一个持续扭力，使用其重量 tmpRig.AddTorque(new Vector3(0, 4, 0), ForceMode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba098d64ab389fabd4c84711a2079e34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f9760bdaa70307a3a3783c679652349/" rel="bookmark">
			SNMP服务的利用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Snmp弱口令探测和利用：
探测Community字符串的方法：
工具：MSF
use auxiliary/scanner/snmp/snmp_login set pass_file 文件名 set rhosts set stop_on_success true set blank_passwords false set threads 5 run 进行字符串的爆破
默认的字符串是“public”和“private”的，带有“ro”(只读)和“rw”(读和写)。
其他工具也可以 我这里比较推荐MSF 因为速度快 并且是一个集成的框架
其他工具：Medusa、onesixtyone
利用snmp的字符串的方法：
工具：snmputil，然后执行命令：
Snmputil.exe walk IP public .1.3.6.1.2.1.1 进一步的利用：
snmputil.exe walk 对方IP public .1.3.6.1.2.1.25.4.2.1.2 //**进程列表 snmputil.exe walk 对方IP public .1.3.6.1.4.77.1.2.25.1.1 //**用户列表 snmputil.exe get 对方IP public .1.3.6.1.4.77.1.4.1.0 //**域名 snmputil.exe walk 对方IP public .1.3.6.1.2.1.25.6.3.1.2 //**安装的软件 snmputil.exe walk 对方IP public .1.3.6.1.2.1.1	//**系统信息 其他工具有MSF中的auxiliary/scanner/snmp/snmp_enum模块、snmpwalk工具等等
更多的利用方法大家可以参考
https://blog.csdn.net/archersaber39/article/details/78932252 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f0801bf51226ceb469de78eb73b959e/" rel="bookmark">
			洛谷 P2663 (二维费用背包)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 班级要组织一场综合能力竞赛，全班同学（N（100以内）个，N是偶数）分成两队互相竞争。老师找到了越越并给了越越一张全班同学综合能力测试的成绩，要求他从全班同学中选出一半（他自己也可能被选），并要求这些同学综合能力测试的成绩之和在不超过班级总分一半的前提下尽量达到最高。这样分成的两队实力是最平均的。越越堆着满脸的笑容找到了你，你就帮他写一个程序吧。
输入格式 第一行：学生个数N；第二行开始的N行每行一个同学的综合能力测试的成绩。
输出格式 输出一个数：N/2个同学的综合能力测试的成绩之和在不超过班级总分一半的前提下尽量达到的最高值。
输入输出样例 输入 #1复制
8 77 77 56 77 84 77 56 46 输出 #1复制
273 说明/提示 样例解释：总分550；总分的一半275；选择4名同学56 77 84 56 77 达到总分273；273是不超过275的最大值。（另一队的和是277）两队实力最接近。
二维费用背包：多开一维表示另一维费用，在一维费用背包的基础上 二重for是时候同时考虑两个费用即可
Code：
#include&lt;bits/stdc++.h&gt; #define debug(x) cout &lt;&lt; "[" &lt;&lt; #x &lt;&lt;": " &lt;&lt; (x) &lt;&lt;"]"&lt;&lt; endl #define pii pair&lt;int,int&gt; #define clr(a,b) memset((a),b,sizeof(a)) #define rep(i,a,b) for(int i = a;i &lt; b;i ++) #define pb push_back #define MP make_pair #define LL long long #define ull unsigned LL #define ls i &lt;&lt; 1 #define rs (i &lt;&lt; 1) + 1 #define fi first #define se second #define CLR(a) while(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f0801bf51226ceb469de78eb73b959e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a59cac8405186724543c94778d48d70d/" rel="bookmark">
			RobotFramework常见内置测试库--Collections
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Collections翻译为“库”的意思，list、dictionary是collection的关键字
list的相关操作
1.append to list：在list后面新增一个元素
2.insert into list：插入一个元素到list
3.get from list：通过index获取list的一个元素
4.get index from list： 获取list元素的坐标
相关使用：可通过ctrl+M查看关键字的使用方法
备注：
1.列表的创建形式，可以通过set variable或者create list创建
2.字典类型的变量可以有两种写法：${list}、@{dic}
Dictionary相关操作
set to dictionary：与create dictionary作用一样，都是创建字典
log dictionary：打印字典内容
remove from dictionary：从字典内移除
注意：字典类型的变量可以有两种写法：${dic}、&amp;{dic}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bef71f191d432852292f67b0a66045b/" rel="bookmark">
			如何保证RabbitMQ消息队列的高可用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么需要保证消息队列的高可用? 虽然消息队列有着异步,解耦,削峰的优点,但是消息队列实际却是一种非常复杂的架构,它在解决一些技术方案难题的同时,也给系统的复杂度提升了一个数量级。
引入消息队列不仅提升了系统的复杂度,还大大降低了系统的可靠性,因为消息队列是外部中间件,系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，人 ABCD 四个系统好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整，MQ 一挂，整套系统崩溃的，你不就完了？
怎么保证消息队列的高可用 RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。
单机模式
单机模式，就是 Demo 级别的，就是平时自己安装在自己电脑上熟悉用的,生产环境不会用
普通集群模式
普通集群模式，就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。
缺点就是集群内部可能产生大量数据传输,可用性无保障,如果queue所在节点宕机,数据则丢失了
镜像集群模式
跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。
实现镜像集群模式,可以在RabbitMQ后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。
这样的话，好处在于，你任何一个机器宕机了，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销很大，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！第二，不是分布式的，就没有扩展性可言了，如果某个 queue 负载很重，你加机器，新增的机器也包含了这个 queue 的所有数据，并没有办法线性扩展你的 queue。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c302419f0d207432b9991f45b920376/" rel="bookmark">
			98: Address already in use
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		llinux环境下，启动nginx报错，系统提示 nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)
一般原因是因为端口被占用了，解决方法是查看被占用的端口，然后用kill命令杀死被占用的端口，重启Nginx即可
第一步：查看Nginx端口
[root@localhost server]# netstat -tnulp | grep nginx 第二步：杀死被占用的端口
第三步：再次查看Nginx端口
第四步：重启Nginx
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9850799f0d8d4e09031a2995e58d8d5/" rel="bookmark">
			jsAPI概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 API的概念 API（Application Programming Interface,应用程序编程接口）
任何开发语言都有自己的API API的特征输入和输出(I/O) API的使用方法(console.log()) ECMAScript - JavaScript的核心
BOM - 浏览器对象模型
DOM - 文档对象模型
BOM的概念 BOM(Browser Object Model) 是指浏览器对象模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象。
BOM的顶级对象window
DOM的概念 文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标志语言的标准编程接口。
文档：一个网页可以称为文档节点：网页中的所有内容都是节点（标签、属性、文本、注释等）元素：网页中的标签属性：标签的属性 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95975073a4dddfea17d3ed9d0c4a2dc9/" rel="bookmark">
			ClassCastException: class com.alibaba.fastjson.JSONObject cannot be cast to class
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FastJsonConfig fastJsonConfig = new FastJsonConfig(); fastJsonConfig.setFeatures(Feature.SupportAutoType); fastJsonConfig.setSerializerFeatures(SerializerFeature.WriteClassName); 修改fastjson配置，启动自动类型转换
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/130b1ed6c45c0b0ef506dc063eeb3be1/" rel="bookmark">
			ZooKeeper系列（三）—— Zookeeper 常用 Shell 命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、节点增删改查 1.1 启动服务和连接服务 # 启动服务 bin/zkServer.sh start #连接服务 不指定服务地址则默认连接到localhost:2181 zkCli.sh -server hadoop001:2181 1.2 help命令 使用 help 可以查看所有命令及格式。
1.3 查看节点列表 查看节点列表有 ls path 和 ls2 path 两个命令，后者是前者的增强，不仅可以查看指定路径下的所有节点，还可以查看当前节点的信息。
[zk: localhost:2181(CONNECTED) 0] ls / [cluster, controller_epoch, brokers, storm, zookeeper, admin, ...] [zk: localhost:2181(CONNECTED) 1] ls2 / [cluster, controller_epoch, brokers, storm, zookeeper, admin, ....] cZxid = 0x0 ctime = Thu Jan 01 08:00:00 CST 1970 mZxid = 0x0 mtime = Thu Jan 01 08:00:00 CST 1970 pZxid = 0x130 cversion = 19 dataVersion = 0 aclVersion = 0 ephemeralOwner = 0x0 dataLength = 0 numChildren = 11 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/130b1ed6c45c0b0ef506dc063eeb3be1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89a44d741a09825b738d34cc1f7762b0/" rel="bookmark">
			GRBL一：概括及其名词(转载)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因初学GRBL，网上搜集了一些GRBL的资料，怕遗忘，所以转载过来，如有侵权请联系，立即删除。
原文地址：https://blog.csdn.net/zhangjikuan/article/details/45396371
Grbl是一款针对Arduino/AVR328芯片的嵌入式G代码编译和运动控制器。
所以说GRBL分为两部分：上位机部分和下位机部分
1.上位机部分：GRBL Controler 用QT编译的，作用是：GCODE编译器，类似于串口提示助手的功能，通过串口传递G指令给下位机
很多DIY做雕刻机或者打印机的都需要用到此款软件，可以将图片之类的转换为G指令
2.下位机部分：可运行在ATMEGA168/328P单片机上，winavr编译的，串口接收到上位机的GCODE指令转换为运动数据控制电机运动的
我们只是需要其中的直线差补类的算法，所以本博客不考虑上位机，只是对下位机GRBL进行分析提取
名词解释：
1.CNC：computor numerical control 数控机床 雕刻机
2.GCODE：数控机床上经常使用的一种控制命令,叫G代码
3.artcam：一款软件，能够生成GCODE
4.Arduino：开源电子平台，包括Arduino硬件板和Arduino IDE 还有Arduino 语言，很全面，大多使用的是AVR CPU
———————————————— 版权声明：本文为CSDN博主「zhangjikuan」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zhangjikuan/article/details/45396371
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b0530260711d56c273be1f545db7c56/" rel="bookmark">
			VMware启动虚拟机一直处于黑屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：在VMware中装了虚拟机，但是在启动后一直处于黑屏而无法进入系统，也没有报错提示，出现这种问题的主要原因是VMware软件跟本地网路规范有所冲突，解决办法也简单，重置一下网络规范就好了，具体的操作方法如下：
方法1：以管理员身份运行命令行窗口----&gt;输入 netsh winsock reset，然后重启计算机。
方法2：VM-&gt;Settings-&gt;Hardware-&gt;Display在右面的内容栏中将Accelerate 3D graphics 取消打勾，然后重启即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6733e6af6c0d91088ea12a33c1e6e0e/" rel="bookmark">
			for(;;)和while(1)的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结 for(;? 比 while(1) 好
为啥:如下（底层完全不同）
“死循环”有两种写法：for(;;)和while(true)，
两者有啥区别，为啥源码中多数是for( ; ; )这种形式的，
编译前 编译后
while (1)； mov eax,1
test eax,eax
je foo+23h
jmp foo+18h
编译前 编译后
for (；；)； jmp foo+23h 对比之下，for (；；)指令少，不占用寄存器，而且没有判断跳转，比while (1)好。
也就是说两者在在宏观上完全一样的逻辑，但是底层完全不一样，for相对于来说更加简洁明了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc5ef5343224e6032d429a59f161e502/" rel="bookmark">
			高通平台power_supply 框架下添加第三方充电IC的驱动方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.power_supply电源框架介绍：
power supply framework在kernel/drivers/power/下。内核抽象出来power supply子系统为驱动提供了统一的框架。
功能包括：
1.抽象PSY设备的共性，向用户空间提供统一的API；
2.为底层PSY驱动的编写，提供简单、统一的方式，同时封装并实现公共逻辑。
power supply class位于drivers/power/目录中，主要由3部分组成（可参考下图的软件架构）：
1）power_supply_core，用于抽象核心数据结构、实现公共逻辑。位于drivers/power/power_supply_core.c中。
2）power_supply_sysfs，实现sysfs以及uevent功能。位于drivers/power/power_supply_sysfs.c中。
3）power_supply_leds，基于Linux led class，提供PSY设备状态指示的通用实现。位于drivers/power/power_suppply_leds.c中。
最后，驱动工程师可以基于power supply class，实现具体的PSY drivers，主要处理平台相关、硬件相关的逻辑。这些drivers都位于drivers/power/power_supply目录下。
power_supply的软件架构：
在具体设备文件中在/sys/class/power_supply,具体如下：
power_supply 框架工作流程
Linux的设备文件目录中可以在sys/class/下看到power_supply目录；这个power_supply的类是通过power_supply_core.c文件中的power_supply_class_init()中的class_create()函数来进行power_supply类的创建，如下：
进入power_supply的目录下：
我们可以看到出现了battery与usb两个目录，这两个目录就是充电IC(battery)与USB(usb)电源管理部分的注册的设备节点内容的集合。
进入battery目录下：
可以看到很多设备节点，这些节点就是通过power_supply的电源框架提供的方法进行注册并实现其内容的。
对于上述的节点内容，是怎么实现的，其实power_supply都提供了相应的节点名称，在文件/kernel/include/linux/power_supply.h中提供了相关的属性枚举定义。如下：
这里提供了大部分的设备节点属性。作为驱动工程师，只需要选取芯片存在的并且自己需要的属性并实现其内容即可。
在power_supply的结构体中：
在这个结构体中，可以看到有set_property与get_property两个属性的函数指针，这两个函数指针就是用来具体实现相关属性功能的。
power_supply_sysfy文件系统
power_supply_sysfs.c文件中，具体进行的是设备节点的注册过程，以及相关功能的实现：
从上面可以看出，在power_supply_sysfs文件中主要是实现power_supply_attrs数组中的成员的show与store。
先看power_supply_attrs数组：
从上述内容看，power_supply_attrs数组其实就是实现之前power_supply.h文件中的枚举power_supply_property。而POWER_SUPPLY_ATTR(online)中括号内容即是具体设备节点。
在POWER_SUPPLY_ATTR结构体中，有show与store两个指针。
show的内容就是使用cat xxxx节点的操作显示出来的内容的：
从上面可以看到有些节点显示的内容并不是数字，而是在show函数中被转换成了相关的字符串。如:
而store函数是echo xx &gt; xxx节点的操作写入的内容。
在上述节点中，存在uevent这个节点，可以看看uevent节点的内容：
这个节点由power_supply_sysfs文件中的power_supply_uevent函数实现的。
这个函数的作用就是将该设备节点下所有节点的内容组合成字符串发送到uevent中，在通过内核的uevent框架发送到用户空间。
当设备节点内容发生变化时，会调用power_supply_changed函数：
可以看到该函数是将psy-&gt;changed_work加入到工作队列中，具体的调用设备的changed_work的工作队列，看看具体做什么：
可以看到，对该类中查询每个设备的更新操作，再更新led灯的操作，还有就是发送新的事件通知应用层。
至此power_supply就介绍结束了。
2. I2C驱动设备的添加与驱动的编写：
首先在具体平台的dtsi设备树文件中添加相应的I2C设备:
这里需要通过硬件电路图，了解设备所挂载的I2C总线，以及通过芯片手册获取设备地址。
芯片的驱动文件的具体编写如下：
第一．在具体设备驱动文件中可以按照其他的I2C设备驱动进行相关的驱动文件进行基本框架结构的编写。
第二.在具体的芯片驱动文件中probe函数的实现
首先设计驱动的参数结构体数据：
在结构体的最后，定义一个该结构体的全局结构体指针。
再回到probe函数中：
由于充电IC驱动的结构体中，存在usb_psy的成员指针变量，所以，在probe中，需要将usb_psy进行实例化，通过power_supply_get_by_name获取usb的电源相关的驱动文件，并将地址赋给power_supply类型的usb_psy指针。给驱动文件开辟内存空间，在这里使用devm_kzalloc而不用kzalloc，好处在于devm_kzalloc自带内存释放和回收机制。给充电驱动的结构体的一些成员变量进行赋初值。其中将usb_psy赋给充电IC的成员变量usb_psy。这里是为了获取USB的相关状态，以便对充电IC的状态进行相应的操作。获取PMIC端对电池的电压采集的节点，使用qpnp-get-vadc将pmic的电压采集pin脚的地址传递给充电IC的vadc_dev的成员变量。 5.给充电IC的驱动文件中填充power_supply的相关内容，用于sys/class/power_supply/目录下生成battery的目录内容；最后通过 power_supply_register进行power_supply类型的设备文件进行设备驱动的注册。
6.进行充电前芯片的硬件初始化工作，主要是对一些寄存器进行设置，如充电安全寄存器的设置。
7.注册一个延时工作队列，进行循环处理充电过程的相关操作。
第三.填充实现power_supply的相关属性：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc5ef5343224e6032d429a59f161e502/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bad970754e42df44485d644075e085d3/" rel="bookmark">
			java 获取字符串unicode编码的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public static void main(String[] args) throws UnsupportedEncodingException { // 获取unicode码的几种方式 // 第一种 System.err.println("第一种-----toCodePoints"); String test = "a汉字"; int[] asds = StringUtils.toCodePoints(test); for (int asd : asds) { System.err.println("int整型:"+asd); String x = Integer.toHexString(asd); if (x.length() &lt;= 2) { x = "\\u00" + x; } else { x = "\\u" + x; } System.err.println("unicode码" + x); } //第二种 System.err.println("第二种-----getBytes"); byte[] bytes = test.getBytes("unicode"); List&lt;Object&gt; list = new ArrayList&lt;&gt;(); for (byte aByte : bytes) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bad970754e42df44485d644075e085d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba7b9fe974ffc98661cc7a71087d61b1/" rel="bookmark">
			StringUtils.toCodePoint(str)方法分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		StringUtils.toCodePoint(str)方法分析 根据我自己的实际操作分析该方法是将str中各个字符的十进制unicode码 并放在int[]数组中.下面是实际代码操作:
public static void main(String[] args) { int[] asds = StringUtils.toCodePoints("a汉字"); for (int asd : asds) { System.err.println("10进制字符" + asd); String x = Integer.toHexString(asd); System.err.println("16进制字符" + x); if (x.length() &lt;= 2) { x = "\\u00" + x; } else { x = "\\u" + x; } System.err.println("unicode码" + x); System.err.println("==="); } System.err.println("unicode转汉字:" + new String(asds, 0, 3)); } 输出结果:
10进制字符97
16进制字符61
unicode码\u0061
===
10进制字符27721
16进制字符6c49
unicode码\u6c49
===
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba7b9fe974ffc98661cc7a71087d61b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5624443a8562761e56e935b9422d645a/" rel="bookmark">
			Ubuntu上开发python的十大IDE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python是最广泛使用的通用编程语言之一。您每天使用的许多流行网站或应用程序软件都是由Python提供支持的。这种编程语言流行的原因是它简单易懂。就像新程序员一样，我开始使用Python进行编程，但它仍然是我首选和最喜欢的编程语言。有许多集成开发环境（IDE）可用于Python编辑和编程。我个人更喜欢Ubuntu终端上的Vim，但是有许多像PyCharm，GNU Emacs和PyZo这样的IDE可用于Ubuntu。所以今天我们将逐一讨论这些IDE。
1. vim Vim是我在大学项目中的首选IDE，即使是今天，因为它使得编程等繁琐的任务非常简单和愉快。它不仅仅是我，但Vim被许多开发人员和Linux用户使用，因为它是非常快速且高度可定制的IDE。更重要的是，Vim使调试任务更容易，并且支持许多工具和插件。
Vim既可以用作独立应用程序，也可以用作命令行界面。许多新用户可能会发现最初很难使用，但是一旦你习惯了它，你会喜欢在Vim上编程。
$ sudo apt-get install vim 2.PyCharm PyCharm是非常受欢迎的跨平台Python IDE，它有两个编辑，即社区和专业版。社区版是免费和开源的，而专业版是付费的。它是高度可定制且功能丰富的IDE，具有集成单元测试和Python调试器，错误突出显示，代码分析等功能，您可以在IDE中获得这些功能。
与其他Python IDE相比，Pycharm拥有最好的GUI之一，可能是专业开发人员的不错选择。它可以在Snap包下用于最新版本的Ubuntu，可以直接从Ubuntu软件中心下载。
$ sudo snap install pycharm-community --classic 3. Eric Eric是一个用Python编写和开发的开源集成开发环境。它是一个跨平台的IDE，支持许多编程语言，包括Python。 Eric IDE捆绑了许多功能，包括代码自动完成，错误突出显示，集成的Python调试器，高级搜索，语法高亮等。
Eric拥有简单但高度可定制的GUI，支持插件和扩展。它还运行你将找不到任何IDE集成的类浏览器。
$ sudo apt-get install eric 4. Pyzo Pyzo是一个基于Python的开源编程环境。它使用conda来管理Python包。它是简单的交互式IDE，但它的功能并没有妥协。一些功能包括语法高亮，缩进指南，类似UI的Matlab，拖放文件和目录等。
Pyzo还提供交互式帮助，文件浏览器以及对所有主要编程语言的支持。 Pyzo可以从Software Center或terminal命令下载和安装。
$ sudo apt-get update $ sudo apt-get install python3-pip python3-pyqt4 $ sudo python –m pip install pyzo –upgrade 安装完成后，运行以下命令启动Pyzo IDE。
$ pyzo 5. Spyder Spyder是一个跨平台的集成开发环境，专为Python中的科学编程而设计。它是多语言IDE，具有代码自动完成，语法高亮，代码分析，水平和垂直分割等功能。
Spyder具有基于布局的UI，使其易于导航并易于为新用户使用。它还支持IPython，NumPy，SciPy和许多其他开源软件。
$ sudo apt-get install spyder 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5624443a8562761e56e935b9422d645a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b60050f9c2dcfebd03171bc2aab7cef2/" rel="bookmark">
			java获取指定范围内的随机小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 package test1; import java.util.Random; public class Test { public static void main(String[] args) { //	注意nextDouble() 方法无参 nextInt()可以传参 Random r = new Random(); //	获取一个小数 区间为 (0,1) System.out.println(r.nextDouble()); //	获取一个小数 区间为 (0,5) System.out.println(r.nextDouble()*5); //	获取一个小数 区间为 (5,10) System.out.println(r.nextDouble()*5+5);	} } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ae88775cd829115d31895e51b7cf334/" rel="bookmark">
			各种排序算法实现原理和代码及适用范围总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排序算法可以分为内部排序和外部排序，内部排序又可以分为插入类、交换类、选择类、归并类排序，归并排序通常也应用于外部排序，但采用的是多路归并排序。
内部排序有：
插入类排序：直接插入、折半插入、希尔排序；
交换类排序：冒泡排序、快速排序；
选择类排序：简单（直接）选择排序、堆排序；
归并类排序：归并排序；
外部排序：需要在内外存之间多次交换数据才能进行；
1、直接插入排序
基本思路：L(i)为待排序表中一个元素，前一子序列L[1...i-1]为有序子序列，后一子序列L[i+1...n]为无序子序列，为了实现将元素L(i)插入到已有序的子序列L[1...i-1]中，需进行以下操作：
1）查找出L(i)在L[1...i-1]中的插入位置k；
2）将L[k...i-1]中所有元素全部后移一个位置；
3）将L(i)复制到L(k)。
过程：就是将后面无序子序列中的每一个元素依次往前面有序子序列中插入到相应的位置，初始时将待排序列的第一个元素作为有序子序列的一个元素。
插入图为：
Java代码实现：
import java.util.Scanner;
//用Java实现直接插入排序
public class DirectInsertSort {
public static void InsertSort(int A[],int n){
int k,j;
for(int i=1;i&lt;n;i++){
if(A[i]&lt;A[i-1]){
k = A[i];
for(j=i-1;j&gt;=0 &amp;&amp; k&lt;A[j];j--){
A[j+1]=A[j];
}
A[j+1]=k;
}
}
}
public static void main(String [] args){
int A[] = new int[10];
System.out.println("请输入数值插入到已声明的数组中：");
Scanner reader = new Scanner(System.in);
for(int i = 0;i&lt;A.length;i++)
{
//System.out.println("请输入第"+(i+1)+"个数字：");
int In = reader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ae88775cd829115d31895e51b7cf334/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d560780822794765ec449808b01eb8cc/" rel="bookmark">
			Vue组件中，data为什么必须是个函数，而不是对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天学习vue组件的时候，发现组件里面的东西，其实和定义的root实例里面的东西时一样的，除了data。这个data必须是function类型，而且必须返回一个实例对象的值，里面的值就是定义的data。这是为什么呢下面举一个小例子来类比一下
正确的定义一个组件： //定义组件 &lt;template id="cpn"&gt; &lt;div&gt; &lt;h2&gt;我是{{name}}&lt;/h2&gt; &lt;/div&gt; &lt;/template&gt; //使用组件 &lt;div class="app"&gt; &lt;cpn-text&gt;&lt;/cpn-text&gt; &lt;/div&gt; //注册组件 const appbox = new Vue({ el:".app", data:{ msg:'haha' }, components:{ cpnText:{ template:'#cpn', data(){ return { name:'小小的一个组件' } } } } }) 效果：
但是如果将组件的data写成：
data:{ name:'小小的一个组件' } 会报这样的错误：
分析 如果data允许这么写，那么就像所有复用这个组件的地方，都在使用这个组件里面的唯一一个data，所有使用组件的地方的data都会指向栈内这一个data的地址，那么会造成一个改data的值，所有的data都会改，因为vue中如果直接写成像root实例当中data那样会直接报错，那么可以转换一下思路，重新将组件中的这一情况类比成一下这种情况:
&lt;template id="cpn"&gt; &lt;div&gt; &lt;h2&gt;我是{{name}}&lt;/h2&gt; &lt;button @click="change()"&gt;改变&lt;/button&gt;	&lt;!-- 多增加一个按钮用于改变data的值 --&gt; &lt;/div&gt; &lt;/template&gt; //使用组件 &lt;div class="app"&gt; &lt;!-- 复用多次组件 --&gt; &lt;cpn-text&gt;&lt;/cpn-text&gt; &lt;cpn-text&gt;&lt;/cpn-text&gt; &lt;cpn-text&gt;&lt;/cpn-text&gt; &lt;/div&gt; //注册组件 const obj = { name:'我是一个小小的组件' }//定义一个存放数据的对象，假设这里就是data:{} const appbox = new Vue({ el:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d560780822794765ec449808b01eb8cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a096f710847c233118aa912dc69a69a1/" rel="bookmark">
			Springboo引入Activity 和mybatis-plus 报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误信息如下：
Caused by: java.lang.NoSuchMethodError: com.baomidou.mybatisplus.core.MybatisConfiguration.getLanguageDriver(Ljava/lang/Class;)Lorg/apache/ibatis/scripting/LanguageDriver; at com.baomidou.mybatisplus.core.MybatisMapperAnnotationBuilder.getLanguageDriver(MybatisMapperAnnotationBuilder.java:369) at com.baomidou.mybatisplus.core.MybatisMapperAnnotationBuilder.parseStatement(MybatisMapperAnnotationBuilder.java:280) at com.baomidou.mybatisplus.core.MybatisMapperAnnotationBuilder.parse(MybatisMapperAnnotationBuilder.java:112) at com.baomidou.mybatisplus.core.MybatisMapperRegistry.addMapper(MybatisMapperRegistry.java:82) at com.baomidou.mybatisplus.core.MybatisConfiguration.addMapper(MybatisConfiguration.java:104) at org.mybatis.spring.mapper.MapperFactoryBean.checkDaoConfig(MapperFactoryBean.java:80) at org.springframework.dao.support.DaoSupport.afterPropertiesSet(DaoSupport.java:44) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1837) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1774) ... 65 more 解决方法: 在activity 中排除mybatis
&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring-boot-starter-basic&lt;/artifactId&gt; &lt;version&gt;${activiti.spring.boot.starter.basic.version}&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f471f7e407b03d6b6fe0a172ab51a51/" rel="bookmark">
			服务器报400错误，java.lang.IllegalArgumentException: Invalid character found in the request target.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本地打开页面正常，部署到服务器上报错400；
原因：tomcat高版本拦截了特殊符号；
解决方案：conf/catalina.properties 中添加 tomcat.util.http.parser.HttpParser.requestTargetAllow=|{} 参考链接：https://www.cnblogs.com/dygrkf/p/9088370.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/413472d7410264631fda8faf0b2a33e9/" rel="bookmark">
			把两个已按升序排列的数组合并成一个升序数组，要求用函数实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt;
void show(int* p, int len)
{
for (int i = 0; i &lt; len; ++i)
{
printf("%d,", p[i]);
}
puts("\b");
}
void arrayMerge(int* p1, int len1, int* p2, int len2, int* p3)
{
int i ,j ,k ;
i = j = k = 0;
while (i &lt; len1&amp;&amp;j &lt; len2)
{
if (p1[i] &gt; p2[j])
p3[k++] = p2[j++];
else
p3[k++] = p1[i++];
}
while (i &lt; len1)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/413472d7410264631fda8faf0b2a33e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9856a441aefde4c183972ef2b8fce370/" rel="bookmark">
			Visual Stdio中使用strcpy()、scanf()等报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不知道用Visual Stdio的小伙伴们有没有这种经历，明明有这个函数，但VS就是会报错 ，于是就开始疯狂找错。就拿之前我遇到的问题strcpy()函数来说，我这么写这个函数：
strcpy(m_p, p); //m_p和p均为指向字符串的指针，将p中内容复制进m_p中 这么写没有问题对吧，然鹅在Visual Stdio中呢？欸，它报错了，为什么呢？因为它是有风险的，万一复制的内容超过了m_p的容量呢？它可不会好心到吃饱了就不吃了，多出来的部分会占用计算机中的其他内存，覆盖掉一些很重要的内容也是完全有可能的，所以贴心的Visual Stdio为了保护我们的电脑，将strcpy()视为错误给报出来了。那我实在要用怎么办？难道就没有办法用来吗？冷静，要知道之前还是允许的，要是完全被禁用了以前的程序岂不是不能跑了？所以我们可以用以下代码包含进我们的代码：
#pragma warning(disable:4996) //C++的格式 #pragma warning disable 4996 //C#的格式 不清楚#pragma的小伙伴可以看我的上一篇博客比较靠后的部分：浅谈C语言预处理指令。 简单来讲#pragma就是一个修改属性的命令，这行代码的意思就是和编译器说：我就要strcpy()不可 ，你把警报给我关一关。disable后面的数字4996是错误代码（错误列表的标号,可以看到），简单来讲所有错误就是一个班级，这个编号就是你的学号，加入这行就将编译器对strcpy()函数的警报给关了。
另外，在用scanf()时也是会报错的，还会有个警报，别怕，只要你的程序没问题，函数用的没问题，定义的也没问题，对电脑而言是安全的，都可以加以下代码继续使用，有警告关警告，有错误管错误：
#pragma warning(diasble:xxxx) //xxxx处填写对应的错误代码 C++版 #pragma warning disable xxxx //xxxx处填写对应的错误代码 C#版 但是大家最好使用其他的函数来代替，因为既然报错了就会有一定的道理，可能是真的很危险，编译器也是为了你的电脑着想，实在想用，也请反复检查，确认自己写的是对的，并且对自己的电脑没有危险再这么改，切记。
其他语言还没有试过，但先写上，然后根据错误列表里的提醒自己修改修改格式就可以了
要是不这么干还有种法子比较麻烦，就是到属性里修改，在错误列表里找到一堆英文，然后找下划线大写单词交叉出现的那一段添加进属性，我觉得这么搞就很方便了，所以就不展开讲了，祝大家以后遇到这种错误后都会改
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7a85e290930a5b548c7532e7c9d68b0/" rel="bookmark">
			maven运行tomcat7:run时报: Unable to process Jar entry [module-info.class] from Jar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eclipse中maven项目运行tomcat7:run时报错: 严重: Unable to process Jar entry [module-info.class] from Jar [jar:file:/F:/apache-maven-3.6.1/repository/org/apache/logging/log4j/log4j-api/2.10.0/log4j-api-2.10.0.jar!/] for annotations
复制图中F:\apache-maven-3.6.1\repository\org\apache\logging\log4j\log4j-api\2.10.0路径打开,可以找到log4j-2.10.0.jar
使用解压工具打开该jar包,注意是打开而不是解压,然后删除如下标注的文件
此时由于刚才在eclipse中启动了maven进程,所以该文件不能被删除
Ctrl+Alt+delete打开资源管理器,结束eclipse中maven进程
再次删除,即可成功
然后关闭解压工具,在eclipse中重新用Maven启动该工程.
启动成功
然后复制访问路径在浏览器中打开,就可以访问到你自己的项目了
此方法仅作为参考,并非最完美的解决方案
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1d836194066767baf810748c602f357/" rel="bookmark">
			python库之turtle库官方文档入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、turtle库1.基本介绍2.turtle绘图原理3.官方文档 二、turtle构建体系1.turtle绘图窗体布局2.绝对坐标3.海龟坐标4.turtle角度坐标体系 三、函数纵览1.海龟方法（1）海龟动作（2）画笔控制（3）海龟状态（4）使用事件（5）特殊的海龟方法 2.TurtleScreen / Screen的方法 四、海龟方法详解1.海龟动作（1）移动和绘制（2）获取海龟状态（3）度量单位设置 2.画笔控制（1）绘图状态（2）颜色控制（3）填充（4）更多绘图控制 3.海龟状态（1）可见性（2）外观 4.使用事件5.特殊海龟方法 五、TurtleScreen/Screen 方法详解1.窗口控制2.动画控制3.使用屏幕事件4.设置与特殊方法5.输入方法6.Screen 专有方法 八、总结1.最快的画笔速度2.类的使用 九、例子 一、turtle库 1.基本介绍 turtle库：
（1）1969年诞生
（2）Python语言的标准库之一
（3）入门级的图形绘制函数库
2.turtle绘图原理 turtle海龟走过的轨迹绘制成了图形
3.官方文档 https://docs.python.org/3/library/turtle.html
二、turtle构建体系 1.turtle绘图窗体布局 （1）最小单位是像素，左上角是（0，0）
（2）startx与starty：绘图窗体出现在屏幕的哪里，后两个参数可选，默认正中心
2.绝对坐标 绝对坐标：就是标准的xOy坐标系，上y右x，中央点是（0，0）
3.海龟坐标 standard模式下（默认）：头朝的方向就是前方：如当龟头朝右时，右侧就为前方。开始默认头朝右.
4.turtle角度坐标体系 角度坐标体系：就是数学上的坐标轴角度，绕x轴逆时针角度从0°到360°
​​​
（1）turtle.setheading(angle) 别名turtle.seth(angle)：只改变方向不行进。如turtle.seth(90)：海龟的朝向为90度
注意：与当前海龟头的朝向没有关系，90度就一定向上
（2）turtle.left(angle)与turtle.right(angle):在海龟当前头的方向上再向左/右转多少度
三、函数纵览 1.海龟方法 （1）海龟动作 （2）画笔控制 （3）海龟状态 （4）使用事件 （5）特殊的海龟方法 2.TurtleScreen / Screen的方法 四、海龟方法详解 1.海龟动作 （1）移动和绘制 turtle.forward(distance) turtle.fd(distance) 参数：
distance – 一个数值 (整型或浮点型)
作用：
海龟前进 distance 指定的距离，方向为海龟的朝向
turtle.back(distance) turtle.bk(distance) turtle.backward(distance) 参数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1d836194066767baf810748c602f357/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d68c5869a2ea66a51533c50ccb2fada/" rel="bookmark">
			C#日常使用笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. C#中DateTime对象去掉毫秒部分的方法1.1 给DateTime补毫秒数凑成整秒1.2 DateTime先转字符串再用字符串转为DateTime去掉毫秒数 2. 条件编译的使用2.1 DEBUG条件编译 3.List泛型的排序3.1 使用OrderBy方法3.2 使用Sort方法3.3 执行排序所使用的规则 4 WPF使用4.1如何写绑定对象本身 正文
1. C#中DateTime对象去掉毫秒部分的方法 1.1 给DateTime补毫秒数凑成整秒 dt = dt.AddMilliseconds( -dt.Millisecond );//直接移除毫秒部分的数值 dt = dt.AddMilliseconds( 1000 - dt.Millisecond );//秒数部分+1 1.2 DateTime先转字符串再用字符串转为DateTime去掉毫秒数 var dtStr = dt.ToString( "yyyy-MM-dd HH:mm:ss" ); //转为字符串 dt = Conver.ToDateTime( dtStr ); //毫秒部分为0 2. 条件编译的使用 2.1 DEBUG条件编译 VisualStudio中，如果解决方案配置是“Debug”，则项目-生成-常规中，会默认勾选定义DEBUG常量，此时在源码中不用手动“#define DEBUG”，也可以使用“#if DEBUG”使用条件编译。
3.List泛型的排序 3.1 使用OrderBy方法 var res = list.OrderBy( item =&gt; item.Property1 ).ToList();//排序执行，但list内容不变、未排序，返回结果才是排序后的集合 3.2 使用Sort方法 //排序执行，list内容更新为排序后的结果 var res=list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d68c5869a2ea66a51533c50ccb2fada/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5077341e1b75b0de7c96114f3f2e1f4/" rel="bookmark">
			NGINX输出问题解决过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现在编译了新写的ngx_http_nc_module时，以前的nginx_hello_module失效了，甚至连nginx的欢迎页面也进不去，打开浏览器的调试工具发现一直处于pending状态，真是让人费解。
经过导师的帮助，通过gdb调试时发现，在nginx的ngx_http_core_module中的ngx_http_core_run_phases函数，调用了如下方法，
这样看起来，就是通过浏览器连接nginx时，会把所有的第三方模块都跑一遍，想想之前nginx调试hello_module时，也是经过了很多个filter函数甩锅最后传给了write_filter，这里应该也差不多，访问特定的url时，nginx也不知道要交给哪个模块处理，所以只能一个个看。
这时就想到了在编写ngx_http_nc_module的handler函数时，并没有按照handler应该的方式要首先获取location配置，而且结尾直接返回NGX_OK，就导致return；返回空，当然出现pending应该还是nc module写的有问题，还需要进一步研究。
知道了这些继续查看gdb调试信息，在ngx_http_core_content_phase函数中，如果不是返回NGX_DECLINED，会直接继续
差不多就是结束请求的意思了，而碰到不符合的module返回NGX_DECLINED才会继续交个下一个handler函数处理
所以在handler函数中获取location配置真的是至关重要，于是在ngx_http_nc_handler中加入获取location配置的部分
因为nc module中只有nc这一条指令，对应的就是enable变量，mycf就是自己在nginx中的相关location配置，通过ngx_http_get_module_loc_conf可以获取到，所以在访问特定的url时，比如localhost/hello,因为在 location /hello中并没有配置nc指令，所以这时mycf-&gt;enable就不会等于1了，所以就会返回NGX_DECLINED交给下一个handler函数处理，当然这时访问localhost/hello 或者localhost时都没有问题了。
这些解决了之后，pending的原因到底是什么
使用了一下tcpdump，是一种Linux上的抓包软件，类似wireshark。用tcpdump监视指定主机的端口的数据包，可以使用tcpdump tcp port *** and host ***.
这里直接使用tcpdump tcp port 80（nginx监听的80端口）
然后分别访问100.100.60.199/hello和100.100.60.199/nc
发现了问题 下面两图是两者分别的截图
可以看到，访问100.100.60.199/nc时并没有返回 200 OK，当然也没有返回其他错误码，所以一直是阻塞着。回想nginx handler模块开发中要在获取location配置后生成合适的响应并发送响应头和响应体，大概问题就是出在了这里。
那就先构造一下响应头，参考hello module的相关部分，加上了下面几句
ngx_str_set(&amp;r-&gt;headers_out.content_type, "text/html");
r-&gt;headers_out.status = NGX_HTTP_OK;
r-&gt;headers_out.content_length_n = strlen(part1) + strlen(part);
rc = ngx_http_send_header(r);
就是让http响应为NGX_HTTP_OK也就是200，按理说应该是可以了，因为在nc模块中并没有响应体而是直接用的write函数。
然而再次抓包之后还是么有返回200 OK。
于是，就要回到之前hello module的调试，要看看在hello module中nginx到底是怎么输出的，以及头部的处理到底是怎么样。
定位到hello module中同样的ngx_http_send_header(r);函数 先给ngx_http_hello_handler打断点，再给ngx_http_send_header打断点b ngx_http_hello_handler, b ngx_http_send_header
然后输入c让nginx一直运行，再用浏览器访问100.100.60.199/hello，然后再c一次，就直接进入了ngx_http_send_header
接下来步骤和上次差不多不断的用n命令和s命令查看调用的函数，大致如下
可以看到，ngx_http_send_header最后主要是交给了ngx_http_header_filter和ngx_http_write_filter处理
ngx_http_header_filter负责计算响应头的总大小，并分配内存，组装响应头，并调用ngx_http_write_filter发送。Nginx中，header filter只会被调用一次，ngx_http_header_filter函数中首先会检查r-&gt;header_sent标识是否已经被设置，如果是的话，则直接返回；否则设置该标识，并发送响应头。另外如果是子请求的话，也会直接退出函数。
ngx_http_header_filter这个函数很长，主要就是做了上面这些事情
比如
因为我们在r-&gt;headers_out.status设置了NGX_HTTP_OK，所以会进入这个分支，可以看到，在这个分支中构造了status_line,而这里就是让其等于ngx_http_status_lines[0]，而这个就是200 OK
下面还构造了很多，最后构造出来的头部大概就是这样
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5077341e1b75b0de7c96114f3f2e1f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4377193b7a6d61013065276d88ee6a70/" rel="bookmark">
			python 面试宝典
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自我介绍说什么？ 个人信息
你好，我叫xxx，毕业于 xxx，所学专业是xxx
掌握的技术，参与过的项目
之前就职于xxx公司，担任后端工程师，负责xxx项目，对xxx技术比较熟悉
应聘的岗位，表达对该岗位的看法和兴趣
我的工作经验和目前这个岗位较为匹配，希望能够应聘到这个岗位…
STAR模型 情景 什么情况下发生
任务 你是如何明确你的任务的
行动 采取了什么样的行动
结果 结果怎么样？学到了什么
你还有什么要问我的吗？ 表现出兴趣：问问工作内容（业务），技术栈，团队，项目
如果入职的话，做哪些业务，公司用到哪些技术栈，用的是java web 还是python web，用的什么缓存，用的什么消息队列
目前团队的成员有多少人，有多少产品、开发和测试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/998f153c61bc98a20646dcb811f2807e/" rel="bookmark">
			【Cocos Creator实战教程(7)】——UI组件（1）ScrollView 组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 知识点讲解
ScrollView 是一种带滚动功能的容器，它提供一种方式可以在有限的显示区域内浏览更多的内容。通常 ScrollView 会与Mask组件配合使用，同时也可以添加ScrollBar组件来显示浏览内容的位置。
1.1 ScrollView 属性
属性 功能说明
content 它是一个节点引用，用来创建 ScrollView 的可滚动内容，通常这可能是一个包含一张巨大图片的节点。
Horizontal 布尔值，是否允许横向滚动。
Vertical 布尔值，是否允许纵向滚动。
Inertia 滚动的时候是否有加速度。
Brake 浮点数，滚动之后的减速系数。取值范围是 0-1，如果是 1 则立马停止滚动，如果是 0，则会一直滚动到 content 的边界。
Elastic 布尔值，是否回弹。
Bounce Duration 浮点数，回弹所需要的时间。取值范围是 0-10。
Horizontal ScrollBar 它是一个节点引用，用来创建一个滚动条来显示 content 在水平方向上的位置。
Vertical ScrollBar 它是一个节点引用，用来创建一个滚动条来显示 content 在垂直方向上的位置
ScrollView Events 列表类型，默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成。详情见 ‘Scrollview 事件’ 章节
CancelInnerEvents 如果这个属性被设置为 true，那么滚动行为会取消子节点上注册的触摸事件，默认被设置为 true。
参考文档和完整的文档和源码下载地址：
https://www.write-bug.com/article/1823.html
转载于:https://my.oschina.net/u/4188102/blog/3091675
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be5bac214fce9f8457a5865070f80c88/" rel="bookmark">
			Spring Boot利用RabbitMQ的死信队列实现定时任务,如超时未支付,自动取消订单等等......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ死信队列 本文不介绍如何整合消息队列,有需要请参考我之前发布:https://blog.csdn.net/a870368162/article/details/99566685
git链接：https://github.com/a870368162/SpringBoot-RabbitMQ
RabbitMQ要实现延时任务，需要使用RabbitMQ的死信交换机（Exchange）和消息的存活时间TTL（Time To Live）来实现
死信交换机 死信交换机跟普通交换机一样,只是这个交换机用来存放过期的消息
当一个消息没有相对应的消费者对其进行消费, 并且消息设置了TTL,消息过期后会进入死信交换机。队列的长度限制满了。排在前面的消息会被丢弃或者扔到死信路由上。当消息进入死信交换机后,死信交换机在把消息转发给专门处理死信消息的消费者,及可实现定时任务 设置消息TTL（消息存活时间） 消息的TTL就是消息的存活时间。RabbitMQ可以对队列和消息分别设置TTL。对队列设置就是队列没有消费者连着的保留时间，也可以对每一个单独的消息做单独的设置。超过了这个时间，我们认为这个消息就死了，称之为死信。如果队列设置了，消息也设置了，那么会取小的。所以一个消息如果被路由到不同的队列中，这个消息死亡的时间有可能不一样（不同的队列设置）。这里单讲单个消息的TTL，因为它才是实现延迟任务的关键。可以通过设置消息的expiration字段属性来设置时间,代码如下: MessageProperties messageProperties = new MessageProperties(); //这里设置消息过期的时间 messageProperties.setExpiration(60+ "000"); messageProperties.setCorrelationIdString(serialClient.getGlobalSerial().toString()); Message message = new Message(JSONObject.toJSONString(这里写你要发送给队列的消息).getBytes(), messageProperties); // 消息持久化 message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT); //发送消息给死信队列 this.send.beadSend(RabbitMQConstant.TOPIC_ROUTINGKEY1, message); 当上面的消息扔到队列中后，过了60秒，如果没有被消费，它就会发送到死信交换机。
创建死信交换机, 死信队列以及处理死信消息的消费者 实现代码如下:
import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.amqp.core.*; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.util.HashMap; import java.util.Map; import java.util.concurrent.DelayQueue; /** * @消息队列配置 * @Autor zxf * @Date 2019/8/15 */ @Configuration public class QueueConfig { private static final Logger logger = LoggerFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be5bac214fce9f8457a5865070f80c88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12b14681c0601ec5705fafcde2828fdf/" rel="bookmark">
			Socket编程实现简单的C/S交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习了一下socket编程的基本知识。主要看了下《UNIX网络编程卷1：套接字联网API（第3版）》里面对socket、bind、listen、accept、connect等函数的介绍。然后参考了http://chinaunix.net/uid-28541347-id-4700074.html
原文确实挺不错，对我启发很大，这里直接贴个简单的代码，是通过客户端连接服务器，在服务器中通过fork了一个进程执行了一个简单的test.c的程序，该程序可以将输入的字符串输出，如图所示
在服务器代码中将输出重定向到了连接的connfd中（一个socket fd），并且也对输入进行了重定向，这样就可以将客户端的输入作为test.c的输入，并把返回的结果重定向给客户端输出，具体见代码
客户端代码
#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;stdlib.h&gt; #include &lt;memory.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;netinet/in.h&gt; #define PORT 9999 #define Buflen 4096 int main(int argc,char *argv[]) { struct sockaddr_in server_addr; int n,err; int sockfd; char recvline[Buflen]; //char* cmd="a\n"; char* cmd=(char*) malloc(Buflen); setbuf(stdout,NULL); /********************socket()*********************/ sockfd= socket(AF_INET,SOCK_STREAM,0); /*******************connect()*********************/ //设置服务器地址结构，准备连接到服务器 memset(&amp;server_addr,0,sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(PORT); server_addr.sin_addr.s_addr = htonl(INADDR_ANY); // server_addr.sin_addr.s_addr = inet_addr(argv[1]); err = connect(sockfd,(struct sockaddr *)&amp;server_addr,sizeof(server_addr)); if(err == 0) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12b14681c0601ec5705fafcde2828fdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e680688a19c1393221e1e9644ab62e2f/" rel="bookmark">
			非负函数无穷积分的收敛判别法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 定理11.2(比较原则)推论1推论2推论3 提问！ 以下都源于周老师的博客，明目张胆的copyヽ(ﾟ∀ﾟ)ﾒ(ﾟ∀ﾟ)ﾉ 定理11.2(比较原则) 设 f , g f,g f,g定义在 [ a , + ∞ ) [a,+\infty) [a,+∞)，且都非负函数，且满足
f ( x ) ≤ g ( x ) ， x ∈ [ a , + ∞ ) f(x) \le g(x)，\qquad x \in [a,+\infty) f(x)≤g(x)，x∈[a,+∞)
则 右 边 收 敛 ， 则 左 边 也 收 敛 右边收敛，则左边也收敛 右边收敛，则左边也收敛
左 边 发 散 ， 则 右 边 也 发 散 左边发散，则右边也发散 左边发散，则右边也发散
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e680688a19c1393221e1e9644ab62e2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbc9a32668b61935256fd490f1b0c7aa/" rel="bookmark">
			Nginx &#43; fastcgi 简单实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考https://blog.csdn.net/allenlinrui/article/details/19419721
一、介绍
通用网关接口（Common Gateway Interface/CGI）描述了客户端和服务器程序之间传输数据的一种标准，可以让一个客户端，从网页浏览器向执行在网络服务器上的程序请求数据。CGI 独立于任何语言的，CGI 程序可以用任何脚本语言或者是完全独立编程语言实现，只要这个语言可以在这个系统上运行。Unix shell script, Python, Ruby, PHP, perl, Tcl, C/C++, 和 Visual Basic 都可以用来编写 CGI 程序。
快速通用网关接口（Fast Common Gateway Interface／FastCGI）是通用网关接口（CGI）的改进，描述了客户端和服务器程序之间传输数据的一种标准。FastCGI致力于减少Web服务器与CGI程式之间互动的开销，从而使服务器可以同时处理更多的Web请求。与为每个请求创建一个新的进程不同，FastCGI使用持续的进程来处理一连串的请求。这些进程由FastCGI进程管理器管理，而不是web服务器。
由于 FastCGI 程序并不需要不断的产生新进程，可以大大降低服务器的压力并且产生较高的应用效率。它的速度效率最少要比CGI 技术提高 5 倍以上。它还支持分布式的部署， 即 FastCGI 程序可以在web 服务器以外的主机上执行。
总结：CGI 就是所谓的短生存期应用程序，FastCGI 就是所谓的长生存期应用程序。FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，不会每次都要花费时间去fork一次(这是CGI最为人诟病的fork-and-execute 模式)。
二、配置（待补充）
三、简单的hello实例
安装完成后，可以在任意文件夹中编写一个简单的cpp程序，比如cgi.cpp
编译g++ cgi.cpp -o cgidemo -lfcgi
将CGI可执行程序移动到nginx目录下cp cgidemo /usr/local/nginx/fastcgi_temp/cgidemo（没有fastcgi_temp文件夹的话自己创建）
启动spawn-fcgi管理进程，并绑定server IP和端口（不要跟nginx的监听端口重合）
/usr/local/bin/spawn-fcgi -a 127.0.0.1 -p 12345 -f /usr/local/nginx/fastcgi_temp/cgidemo
成功会显示
注：如果出现spawn-fcgi: child exited with: 0，是缺少while循环。
fastcgi代码要有应答循环过程，典型格式如下：
while (FCGI_Accept() &gt;= 0) {//循环条件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbc9a32668b61935256fd490f1b0c7aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cb63a254bd597d18229cea033d1623e/" rel="bookmark">
			记一次tls客户端配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参照https://github.com/alfredh/retls
https://github.com/creytiv/re/tree/sip_tls_verify
首先安装需要的libre库
https://github.com/creytiv/re/tree/sip_tls_verify
进去下载之后
Make
Make install
Ldconfig
然后安装retls
https://github.com/alfredh/retls
下载解压之后进入文件夹make即可，make成功的标志
可以在make前执行ldconfig
使用：
注：可能不会一帆风顺，记录遇到的问题，不过运气好的话就如上面那么简单
1.make时出现warning 说libssl.1.0.so和libssl.1.1.so冲突，此时也可以运行retls，但是会出现segmentation fault（core dump），主要问题在于冲突，要重装libssl（可能重装openssl也行吧，没试过） libcrypto冲突采用同样方式解决
2.make时出现如下错误：
参见https://stackoverflow.com/questions/45324091/openssl-link-libcrypto-a-in-a-static-way
修改Makefile文件
在-lm后面加上-ldl即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25bf9efc243818b756abc663f5d1ce1f/" rel="bookmark">
			svn服务器和客户端 的安装与操作方法详解（windows版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		svn服务器和客户端 的安装与操作方法详解（windows版本） svn简介 ​ Subversion(SVN) 是一个开源的版本控制系統, 也就是说 Subversion 管理着随时间改变的数据。 这些数据放置在一个中央资料档案库(repository) 中。 这个档案库很像一个普通的文件服务器, 不过它会记住每一次文件的变动。 这样你就可以把档案恢复到旧的版本, 或是浏览文件的变动历史。
什么是svn SVN全名Subversion，即版本控制系统。SVN与CVS一样，是一个跨平台的软件，支持大多数常见的操作系统。
作为一个开源的版本控制系统,Subversion管理着随时间改变的数据。这些数据放置在一个中央资料档案库 (repository)中。这个档案库很像一个普通的文件服务器,不过它会记住每一次文件的变动。 这样你就可以把档案恢复到旧的版本,或是浏览文件的变动历史。Subversion是一个通用的系统,可用来管理任何类 型的文件,其中包括了程序源码。
SVN是集中式，Git是分布式。
大概理解就是svn也是类似于git一样的东西,SVN断网之后历史版本丢失,但Git不会丢失
地址 链接：https://pan.baidu.com/s/1VViINwGasnYfgD46ABmmlw
提取码：d2ga
安装总结 1,安装svn服务器(用于自己测试项目以及熟悉流程)
2.安装svn客户端(之后会常用到)
3.安装svn语言包(svn汉化)
svn服务器安装(本文为标准版) 默认即可
在这里插入图片描述
选择标准版/企业版.本文为标准版所以选择标准版
地址自定即可,这里端口默认为443,因为443基本都被占用,使用8443即可
之后继续即可
界面如下:
svn客户端安装 在云盘链接找到客户端.(之后在点击语言包)
next
这里需要注意,需要将他点击一下,否则之后使用pycharm选择svn.exe操作会出现问题,但如果没有点击也别怕,我这里有教程如何再次更改https://blog.csdn.net/qq_39702079/article/details/83539523
之后就next即可,语言包无需任何配置直接next即可,这里就不做展示.安装好之后点击设置:
选择语言即可
操作 需要注意:SVN客户端不是指一个桌面应用程序，而是集成到系统的右键菜单中的插件。
svn服务器创建资源库 1.点击创建
2.选择创建类型(这里默认)
3.输入资源库名称
4.选择初始化
5.选择权限,因为我们要之后用户提交,写,读所以选择第二个
成功!
svn创建用户 1.点击创建
2.创建用户
3.创建之后查看
使用vsn客户端连接服务器(局域网内用户) ​ 使用客户端访问(这里你们会显示的没我这么多,因为你们并没有登录用户,之后就会有了)
之后会需要url我们只需要将服务器的url输入即可
在输入我们创建的用户就可以进入编辑界面
也可以使用浏览器进入服务器
已进入!
pycharm使用svn进行添加,获取,更新 1.首先我们要确保我们pycharm右上角有这个标志:
如果没有怎么办?查看教程https://blog.csdn.net/qq_39702079/article/details/83539523
获取:
点击进行获取
这里选择要获取的地址也可以自添加
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25bf9efc243818b756abc663f5d1ce1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28bab6e840e93f90861f11d2b2cc2d38/" rel="bookmark">
			cf#579 E
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://codeforces.com/contest/1203/problem/E
E. Boxers
time limit per test2 seconds
memory limit per test256 megabytes
inputstandard input
outputstandard output
There are n boxers, the weight of the i-th boxer is ai. Each of them can change the weight by no more than 1 before the competition (the weight cannot become equal to zero, that is, it must remain positive). Weight is always an integer number.
It is necessary to choose the largest boxing team in terms of the number of people, that all the boxers’ weights in the team are different (i.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28bab6e840e93f90861f11d2b2cc2d38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28cd11a37488e84215c12884849e4209/" rel="bookmark">
			RecyclerView 调用notifyDataSetChanged()刷新 平滑加载更多数据的方法解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于项目需要用到显示历史聊天记录，要求用户下拉时自动在RecyclerView顶部加载以前的聊天记录，并且尽可能的平滑加载数据。
常规做法是调用RecyclerView 的notifyDataSetChanged()方法，再调用scrollToPosition滚动到最后一条记录的底部，也就是停留在新加载的数据最后一条记录所在位置。
实际测试发现，这样无法做到平滑连续加载，因为在加载新数据后，RecyclerView总是需要滚动到最新数据的底部，此时用户可能正在看着某条记录，如果我们突然滚动到最新加载的数据底部，那就相当于用户还没看完你就给他翻页了，体验就会变差~
经过一番尝试，发现RecycleView还有个方法：findLastCompletelyVisibleItemPosition()，可以获取到RecycleView最后一个可见item的位置，这个方法很有用，因为只要记录下加载数据前的最后一个可见item位置，notifyDataSetChanged()后再滚动到这个item的位置，看起来页面数据加载就是连贯的，基本不会感觉界面抖动，从而提升用户体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/635bf3cf14307f01cfe4701108afdfcd/" rel="bookmark">
			UVA - 11426 欧拉函数（欧拉函数表）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题意：
给一个数 N ，求 N 范围内所有任意两个数的最大公约数的和。
思路：
f 数组存的是第 n 项的 1~n-1 与 n 的gcd的和，sum数组存的是 f 数组的前缀和。
sum[n]=f[1]+f[2]+f[3]+…+f[n]
sum[n-1]=f[1]+f[2]+…+f[n-1]
sum[n]=sum[n-1]+f[n]
所以我们求出f[n]的值即可
1~n-1与 n 的最大公约数暴力来求肯定超时；
设gcd(x,n)=i 表示 n 和 x 的最大公约数为i，那么gcd( x/i , n/i )=1
即转化为 求n/i 的欧拉函数值。a[ n / i ]
比如:
a [ 6 / 1 ] = a[ 6 ] = 2
a[ 6 / 2 ] = a[ 3 ] = 2
a[ 6 / 3 ] = a[ 2 ] = 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/635bf3cf14307f01cfe4701108afdfcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6309c9a03002775e39a5efebfc8ac29/" rel="bookmark">
			华为C&#43;&#43;开发工程师面试总结整理，面试问题你能答上几个？含答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
虽然全世界每个月都可能会出现新的语言，但从TIOBE世界编程语言排行榜的数据来看，从2009年到现在，C/C++一直都在前3甲中。不论历史的车轮如何滚滚向前，学好C/C++永远不会落后。
面试官问的面试题： 一面：
1.先自我介绍；
2.把自己简历上的项目描述一下，然后选一个你认为最主要的项目来说，以及项目遇到什么问题，用什么方法解决的；
3.Nagle算法和tcp的拥塞控制。
4.项目用过哪些数据库吗？（没用过，别问）。
二面：
1.过一下简历项目。
2.如何理解软件的健壮性和高可靠性。
3.了解哪些linux内核的模块。
华为C++开发工程面试总结：
c/c++ 面试题库 v1.0 1. 基础部分
1.1 语言
一、 C和C++的特点与区别？
二、 阐述C++的多态。
三、 阐释c++虚函数的实现。
四、 C和C++内存分配问题。
五、 数据模型（LP32 ILP32 LP64 LLP64 ILP64 ）。
2.高级部分
2.1 网络
一、 画出三次握手和四次挥手流程图。
二、请阐释https建立连接过程。
三、画出OSI和TCP/IP协议栈的对应关系。
四、请阐释ARQ协议的原理和过程。
五、请阐释滑动窗口协议原理和过程。
2.2 操作系统
一、进程通信方式有哪些？哪种效率最高？
二、线程间的通信方式。
三、请分别阐释进程和线程的概念，并分析异同？
2.3 数据库
四、MySQL中myisam与innodb的区别。
五、innodb引擎的 4大特性。
六、MyISAM和InnoDB selectcount(*)哪个更快，为什么？
七、Redis支持的数据类型？
八、什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什
么？
九、redis通讯协议(RESP )，能解释下什么是RESP？有什么特点？
十、Redis 有哪些架构模式？讲讲各自的特点。
2.4 数据结构
一、 线性表。
二、 二叉树。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6309c9a03002775e39a5efebfc8ac29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad446ea6e2611f84e1b333b32df23018/" rel="bookmark">
			QML Charts 往图表上添加 文字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容： 给所有点都加上标签（XYseries 自带)给指定的个别点添加任何需要显示的内容 1、给所有点都添加标签 效果如下图
ChartView { anchor.fill: parent ValueAxis { id:axisX max:10 min:0 tickCount: 10 } ValueAxis { id: axisY max: 10 min: 0 tickCount: 10 } LineSeries { id: series0 axisX: axisX axisY: axisY } ScatterSeries { id: series1 axisX: axisX axisY: axisY markerSize: 10 pointLabelFormat: "(@xPoint Hz, @yPoint dB)" pointLabelVisible: true } } @xPoint The x value of the data point
@yPoint The y value of the data point
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad446ea6e2611f84e1b333b32df23018/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/747cae3c2584b76ce75561e54d3268b6/" rel="bookmark">
			【图像处理】 -041 MTCNN&#43;DCNN人脸检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【图像处理】 -041 MTCNN+DCNN人脸检测 文章目录 【图像处理】 -041 MTCNN+DCNN人脸检测1 简介2 C++实现3 检测效果4 分析 1 简介 相比于R-CNN系列通用检测方法，本文更加针对人脸检测这一专门的任务，速度和精度都有足够的提升。R-CNN，Fast R-CNN，FasterR-CNN这一系列的方法不是一篇博客能讲清楚的，有兴趣可以找相关论文阅读。类似于TCDCN，本文提出了一种Multi-task的人脸检测框架，将人脸检测和人脸特征点检测同时进行。论文使用3个CNN级联的方式，和Viola-Jones类似，实现了coarse-to-fine的算法结构。
当给定一张照片的时候，将其缩放到不同尺度形成图像金字塔，以达到尺度不变。
Stage 1：使用P-Net是一个全卷积网络，用来生成候选窗和边框回归向量(bounding box regression vectors)。使用Bounding box regression的方法来校正这些候选窗，使用非极大值抑制（NMS）合并重叠的候选框。全卷积网络和Faster R-CNN中的RPN一脉相承。
Stage 2：使用N-Net改善候选窗。将通过P-Net的候选窗输入R-Net中，拒绝掉大部分false的窗口，继续使用Bounding box regression和NMS合并。
Stage 3：最后使用O-Net输出最终的人脸框和特征点位置。和第二步类似，但是不同的是生成5个特征点位置。
2 C++实现 #include &lt;opencv2/opencv.hpp&gt; #include "mtcnn.h" #include "HighPerformanceTimer.hpp" #include &lt;fstream&gt; using namespace cv; #define MAXFACEOPEN 0 //设置是否开关最大人脸调试，1为开，其它为关 //读取待检测文件列表 std::vector&lt;std::string&gt; ReadImgList(std::string&amp; imglistfilename) { std::vector&lt;std::string&gt; imgs; std::ifstream imglistfile(imglistfilename, std::ifstream::in); std::string line; while (getline(imglistfile, line))//按行读取 { imgs.push_back(line); } return imgs; } int main(int argc, char** argv) { if (argc &lt; 3) { std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/747cae3c2584b76ce75561e54d3268b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30737a7e5c9e022107ea9abcd1b249de/" rel="bookmark">
			shell反引号`与$()的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		反引号`` 与 $() 都是命令替换 举例1： root@localhost software]# cat 3.sh #!/bin/bash echo `echo $HOSTNAME` echo $(echo $HOSTNAME) [root@localhost software]# sh 3.sh localhost.localdomain localhost.localdomain 区别： 反引号中：若要使用转义字符需要两个反斜杠\\ $()中： 若要使用转义字符只需用单反斜杠\ 举例2： [root@localhost software]# cat 3.sh #!/bin/bash echo `echo \$HOSTNAME` 反引号使用单反斜杠，$没有被转义成普通字符，所以还是执行了命令 echo $(echo \$HOSTNAME) 这里使用单反斜杠，$被转义成普通字符，所以被当成普通字符串 [root@localhost software]# sh 3.sh localhost.localdomain $HOSTNAME 举例3： [root@localhost software]# cat 3.sh #!/bin/bash echo `echo \\$HOSTNAME` echo $(echo \$HOSTNAME) [root@localhost software]# sh 3.sh $HOSTNAME $HOSTNAME 总结：反引号与$()都是命令替换即： $(cmd)&lt;=&gt;`cmd` 唯一的区别就是转义字符的使用不一样。 $(command1;command2) 当小括号里有多个命令表达式时，使用分号 ; 分隔 单引号&amp;双引号 1、单引号：里面的变量不会执行，即变量不会被替换 2、双引号：里面的变量会被执行，即变量会被替换 小礼物走一走，来简书关注我
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30737a7e5c9e022107ea9abcd1b249de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86b05dbdf6c23442f7d535b66611e1e8/" rel="bookmark">
			【图像处理】 -040 Dlib 深度人脸检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【图像处理】 -040 Dlib 深度人脸检测 文章目录 【图像处理】 -040 Dlib 深度人脸检测1 简介2 使用dlib实现深度人脸检测3 检测效果4 分析 1 简介 Dlib中实现的深度人脸检测是基于MMOD（Maximum-Margin Object Detector(MMOD))，CNN结构。
2 使用dlib实现深度人脸检测 // Dlib_HOG.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。 // #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;fstream&gt; #include "opencv2/opencv.hpp" #include "../OpenCV_Harr/OpenCV_Harr/HighPerformanceTimer.hpp" #include &lt;dlib/opencv.h&gt; #include &lt;dlib/image_processing.h&gt; #include &lt;dlib/image_processing/frontal_face_detector.h&gt; #include &lt;dlib/image_processing.h&gt; #include &lt;dlib/dnn.h&gt; #include &lt;dlib/data_io.h&gt; // Network Definition / template &lt;long num_filters, typename SUBNET&gt; using con5d = dlib::con&lt;num_filters, 5, 5, 2, 2, SUBNET&gt;; template &lt;long num_filters, typename SUBNET&gt; using con5 = dlib::con&lt;num_filters, 5, 5, 1, 1, SUBNET&gt;; template &lt;typename SUBNET&gt; using downsampler = dlib::relu&lt;dlib::affine&lt;con5d&lt;32, dlib::relu&lt;dlib::affine&lt;con5d&lt;32, dlib::relu&lt;dlib::affine&lt;con5d&lt;16, SUBNET&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; template &lt;typename SUBNET&gt; using rcon5 = dlib::relu&lt;dlib::affine&lt;con5&lt;45, SUBNET&gt;&gt;&gt;; using net_type = dlib::loss_mmod&lt;dlib::con&lt;1, 9, 9, 1, 1, rcon5&lt;rcon5&lt;rcon5&lt;downsampler&lt;dlib::input_rgb_image_pyramid&lt;dlib::pyramid_down&lt;6&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; //读取待检测文件列表 std::vector&lt;std::string&gt; ReadImgList(std::string&amp; imglistfilename) { std::vector&lt;std::string&gt; imgs; std::ifstream imglistfile(imglistfilename, std::ifstream::in); std::string line; while (getline(imglistfile, line))//按行读取 { imgs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86b05dbdf6c23442f7d535b66611e1e8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/465/">«</a>
	<span class="pagination__item pagination__item--current">466/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/467/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>