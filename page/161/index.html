<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cef38c6ca50dbba8968fdaab5dbc208a/" rel="bookmark">
			Ubuntu20.04中安装QGIS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu2004中安装QGIS 1 检查并安装依赖包2 安装签名密钥3 安装QGIS：4 更新资源库，确认QGIS添加成功5 安装QGIS和插件grass Ubuntu版本：20.04
在Debian/Ubuntu中安装QGIS一般只能Sudo aptinstall gis 1 检查并安装依赖包 在terminal中输入
sudo apt install gnupg software-properties-common 2 安装签名密钥 sudo mkdir -m755 -p /etc/apt/keyrings # not needed since apt version 2.4.0 like Debian 12 and Ubuntu 22 or newer sudo wget -O /etc/apt/keyrings/qgis-archive-keyring.gpg https://download.qgis.org/downloads/qgis-archive-keyring.gpg 3 安装QGIS： sudo gedit /etc/apt/sources.list.d/qgis.sources
Types: deb deb-src URIs: https://qgis.org/debian % 这个也行https://download.qgis.org/ubuntugis-ltr Suites: focal % 这个就是发行代号 Architectures: amd64 Components: main Signed-By: /etc/apt/keyrings/qgis-archive-keyring.gpg 4 更新资源库，确认QGIS添加成功 sudo apt update 5 安装QGIS和插件grass sudo apt install qgis qgis-plugin-grass 这一步比较耗时
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cef38c6ca50dbba8968fdaab5dbc208a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7981bced32aa6c4274005ee0ca5e11ba/" rel="bookmark">
			企业数字化中，BI 有何价值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在近些年的时间里，相关的数字化技术、理念、应用扩散到各行各业，让整个社会开始进行深层次的改变，也让城市建设这种传统的基础建设开始融合数字化，并利用数据结合数据中心、城市大脑等构建新型基础建设模式。
数据在这些年的时间中，也逐渐成长为了个人、机构、企业乃至国家的战略资源，被很多人放到“新时代的石油”这一位置上。虽然这个说法也引起了一些争议，但更多只是讨论数据和石油的差异性，却并没有多少人否认数据的价值，这也足以说明数据伴随着数字化的成长，已经发展到了一个新的程度。
一、什么是商业智能BI？
商业智能BI - 派可数据商业智能BI可视化分析平台
数字化的普及应用以及数据资产价值化的实现，使得各行各业的企业都开始了数字化转型的路径，而商业智能BI则是在这种浪潮中发挥巨大作用的数据类技术解决方案。
很多人之前不了解商业智能BI，看到最近比较火热就觉得商业智能BI发展时间不长，其实不是这样。商业智能BI能够成为当前商业世界中备受企业欢迎的数据类技术解决方案其实是有原因的，早在1958年，IBM研究员就将商业智能BI的早期形态定义为：“对事物相互关系的一种理解能力，并依靠这种能力去指导决策，以达到预期的目标。”
在此之后，商业智能BI的概念并没有停滞不前，而是随着时间、技术的发展等不断更新着自身定义和产品形态。直到2013年，在信息化和数字化的影响下，商业智能BI形成了一套现代化的概念，围绕企业发展进行扩展，重新确定了商业智能BI的定义：“商业智能BI是一个概括性术语。它包含了应用、基础结构、工具，以及提供信息访问和分析加以改进、优化决策表现的最佳实践”
经过数十年商业智能BI的发展，我们对当前环境下主流的商业智能BI产品有了一个明确的定义，一种有三条，分别是：
第一，商业智能BI是一套完整的由数据仓库、查询报表、数据分析等组成的数据类技术解决方案。
第二，商业智能BI可以将企业不同业务信息系统（ERP、CRM、OA）中的数据打通并进行有效的整合。
第三，商业智能BI可以借助合适的查询和分析工具快速准确的提供可视化分析或报表，为企业提供决策支持。
商业智能BI - 派可数据商业智能BI可视化分析平台
商业智能BI一套完整的解决方案，其中有很多不同的功能模块，能够让企业实现多种多样的效果，例如商业智能BI可以根据企业业务数据的不同流程划分为三个层次：
第一层，可视化分析展现层 - 可视化分析展现层也就是商业智能BI的需求层，一方面代表了用户的需求，用户想看什么、要看什么、另一方面也代表了用户要分析什么，这些就在这一层进行展现。
第二层，数据模型层 - 数据模型层也就是常说的商业智能BI数据仓库，主要负责企业数据的分析模型，完成从业务计算规则向数据计算规则的转变。
第三层，数据源层 - 数据源层也就是商业智能BI的数据层，不同部门、业务线的业务信息系统，其底层数据库的数据通过ETL抽取到商业智能BI的数据仓库中，建模分析等等，最终支撑到前端的可视化分析展现。
二、商业智能BI在企业IT信息化中的位置
商业智能BI在企业中主要承担承上启下的责任，围绕数据形成了一整套数据战略体系，同时也是企业信息化建设中重要的一部分，可以说是企业进行信息化建设或者数字化转型前必须进行布署规划的一环。
一般来说，企业的信息化建设具有通用性，所以可以把大部分的企业的 IT 信息化分为两个阶段：一个是业务信息化，一个是数据信息化。这样对比讲，一般的用户更容易理解一些。
企业信息化 - 派可数据商业智能BI可视化分析平台
业务信息化 - 企业使用的ERP、CRM、OA、自建的业务系统等，业务系统的建设都统称为业务信息化。业务信息化的主要作用是管理企业的业务流程，通过规范化、标准化、线上化，来提高业务运转效率、降低企业人力、时间、精力等成本，为商业智能BI的建设打下数据基础，是业务管理思路的体现，也是现代的企业管理方式。
数据信息化 - 像我们经常所听到的大数据、商业智能BI、数据分析、数据挖掘等我们都统称为数据信息化。数据信息化可以帮助企业全面的了解企业的经营管理，从经验驱动到数据驱动，降低情绪、心理等主观影响，形成以数据为基础的业务决策支撑，提高决策的准确性，这是企业更高层次的企业管理方式。
企业信息化 - 派可数据商业智能BI可视化分析平台
信息化建设具有连贯性，没有业务系统的建设，就不会有数据的沉淀，而没有数据的沉淀，就没有建设商业智能 BI 的基础。同时，商业智能 BI 的建设能够反向推动业务信息化的建设，提高数据的质量。
业务信息化的主要使用形式 - 表单式的、以业务用户录入为主、数据的增删改操作居多，是对业务过程数据、业务流程进行管理的软件系统，可以对业务流程进行规范化、标准化处理。
数据信息化的主要使用形式 - 例如商业智能BI主要是对业务结果数据进行整体信息呈现和局部深度分析，旨在打通ERP、OA、CRM等业务系统的数据，跨业务、跨系统整合数据。
三、谁是商业智能BI的主要用户？
商业智能BI - 派可数据商业智能BI可视化分析平台
业务信息化的主要使用对象 - 一线业务执行层，更多是从业务视角出发，录入数据、记录流程、查看业务信息。
数据信息化的主要使用对象 - 管理决策层，更多的是从管理视角通过商业智能BI可视化分析去定位问题、分析问题，最终形成业务决策。
两个细节要点：
第一，没有任何一个管理决策层、领导会没事打开财务系统看财务数据，打开 OA 系统看看合同信息，高层领导不会看这些明细数据细节，也不会进到各个系统里面去看。也就是说，业务信息化不是给这一层领导来使用的。
第二，管理决策层是不是一定是指的企业最高层的领导，不见得，可以是企业各个组织层次中带有管理决策属性的人员，这些管理决策人员都可以通过商业智能BI提供决策支持。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7981bced32aa6c4274005ee0ca5e11ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9260d317a80db9647e13672d2cedf77/" rel="bookmark">
			pycharm连接spark
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.解压Hadoop，解压到任意盘，路径不要带中文路径 进入保存后的bin目录，查看，是否解压成功 2.解压spark，到任意位置，路径不要带有中文 3. 打开pycharm，把Hadoop，spark环境变量配置到pycharm中。 3.1新建项目 3.2在项目中创建一个python文件 3.3把Hadoop_home，python_home,pythonpath添加到Pycharm中. 1.HADOOP_HOME 2.SPARK_HOME 3.PYTHONPATH 4.注意！！！ PYTHONPATH路径要添加到D:\spark\spark-2.4.6-bin-hadoop2.7\python\lib\py4j-0.10.7-src.zip下
3.4 检查是否有以下软件包 3.4.1 如果没有请按照以下教程下载，后期需要 3.4.2安装py4j 3.4.3安装pyspark推荐2.4.6版本 3.4.4安装pip 3.5安装findspark 4.把winutils.exe插件放到Hadoop解压后的/bin目录下面 5.把以下代码，复制到4.2步骤中，新建的python文件中 #添加此代码 import findspark findspark.init() #在spark前，添加此代码 from pyspark.sql import SparkSession spark = SparkSession.builder.appName("WordCount").getOrCreate() spark.sparkContext.textFile("file:///D:/Hadoop/hadoop-2.7.7/README.txt")\ .flatMap(lambda x: x.split(' '))\ .map(lambda x: (x, 1))\ .reduceByKey(lambda x, y: x + y)\ .foreach(print) 5.1必须要有这句话在spark前面！！！ 6.测试 出现以上内容，表示pycharm连接spark成功。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9922e48cacc4ff8135839f9aff192177/" rel="bookmark">
			7 FFmpeg从入门到精通-FFmpeg中Linux设备操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 FFmpeg从入门到精通-FFmpeg简介
2 FFmpeg从入门到精通-FFmpeg工具使用基础
3 FFmpeg从入门到精通-FFmpeg转封装
4 FFmpeg从入门到精通-FFmpeg转码
5 FFmpeg从入门到精通-FFmpeg流媒体
6 FFmpeg从入门到精通-FFmpeg滤镜使用
7 FFmpeg从入门到精通-FFmpeg中Linux设备操作
8 FFmpeg从入门到精通-FFmpeg接口libavformat的使用
9 FFmpeg从入门到精通-FFmpeg接口libavcodec的使用
10 FFmpeg从入门到精通-FFmpeg接口libavfilter的使用
文章目录 7.FFmpeg流媒体 7.1 FFmpeg中Linux设备操作 7.1.1 Linux下查看设备列表 7.1.2 Linux采集设备fbdev参数说明 7.1.3 Linux采集设备fbdev使用举例 7.1.4 Linux采集设备v4l2参数说明 7.1.5 Linux采集设备v4l2使用举例 7.1.6 Linux采集设备x11grab参数说明 7.1.7 Linux采集设备x11grab使用举例 7.2 FFmpeg中OS X设备操作 7.3 FFmpeg中Windows设备操作 7.3.1 FFmpeg使用dshow采集音视频设备 7.3.2 FFmpeg使用vfwcap采集视频设备 7.3.3 FFmpeg使用gdigrab采集窗口 7.4 小结 7.FFmpeg流媒体 在使用FFmpeg作为编码器时，可以使用FFmpeg采集本地的音视频采集设备的数据，然后进行编码、封装、传输等操作。例如我们可以采集摄像头的图像作为视频，采集麦克风的数据作为音频，然后对采集的音视频数据进行编码，最后将编码后的数据封装成多媒体文件或者作为音视频流发送到服务器上（流媒体）。
7.1 FFmpeg中Linux设备操作 FFmpeg在Linux下支持的采集设备多种多样，包含FrameBuffer（fbdev）设备操作、v4l2设备操作、DV1394设备操作、OSS设备操作、x11grab设备操作等。
7.1.1 Linux下查看设备列表 首先需要查看系统当前支持的设备，将设备列出来，并根据前面章节中介绍的FFmpeg帮助信息查看方式，通过如下命令查看系统当前支持的设备。
ffmpeg -hide_banner -devices 输出如下：
Devices: D. = Demuxing supported .E = Muxing supported -- DE fbdev Linux framebuffer D lavfi Libavfilter virtual input device DE oss OSS (Open Sound System) playback DE video4linux2,v4l2 Video4Linux2 output device 从以上输出的内容中可以看到，系统当前可以支持的设备具体如下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9922e48cacc4ff8135839f9aff192177/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/815b560c1a4ba8687b4677985be378ca/" rel="bookmark">
			计算机网络误区——二层网络中不同VLAN不通的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你真的了解VLAN吗？很多学过计算机网络的同学都对VLAN的知识学习过，也做过相应的实验，简单的实现了不同VLAN隔离、相同VLAN互通的要求，自认为对VLAN了解的同学可以先看一下下面这个拓扑，本文会让你对VLAN有更加深入的了解。
PC终端和交换机端口配置如上图所示。请问，在该拓扑中，两个PC是否可以通信呢？
如果您认为可以通信，那么恭喜您，您对VLAN的了解已经比较深入了，可以跳过本文；如果您认为不能通信，那么还请您耐心的看完本文
首先，上述的配置是可以让两个PC之间相互通信的。当然实际的网络环境中一般也没有人会这样配置。但是了解这个反应了我们对VLAN配置中Access和Trunk的掌握程度。
我们都知道，在网路配置中，与PC直接相连的端口一般用Access，表示把该PC加入端口对应的VLAN，而交换机之间互联的端口一般用Trunk，并且配置允许交换机互联的VLAN ID通过，这是我们常见的经典配置，但是不知道大家有没有想过为什么这样配置呢？
这涉及到VLAN中Access端口和Trunk端口对数据包的具体处理问题。我们先来了解一下VLAN是功能了，VLAN的功能是隔离广播域，那么他为什么能隔离广播域呢，原来，为了能够实现隔离广播域的效果，交换机在接受到的每个数据包上打上了一个特殊的“标签”，该”标签“标识了数据包属于哪个VLAN。不同的Access、Trunk端口对VLAN标签的处理是不同的，下面我们来看一下Access和Trunk对不同数据包VLAN标签处理情况。
Access数据包处理情况：
Trunk数据包处理情况:
我们总结一下，交换机在转发数据时遵守的原则是进入打标签，出去剥标签，剥标签是掉和PVID相同的标签，PVID就是上面我们提到的特殊“标识”，如果和PVID不同，看是否允许通过，允许则放行，反之丢弃。我们可以简单记忆“进打出剥”。
接下来回到我们一开始的问题，为什么两个PC之间可以相互通信的？我们来分析一下：
PC1开始发出的数据包是裸标签，到达LSW1的g0/0/1口时，因为该接口是Access且PVID为10，会被打上VLAN10的标签，到达LSW1的g0/0/2口时，因为该接口是Trunk且PVID为10,会被剥掉VLAN10的标签，这时数据包在两台交换机是裸标签传输，到达LSW1的g0/0/2会被打上VLAN20的标签，到达LSW2的g0/0/1时会剥掉VLAN20的标签，最后PC2收到的数据包就是没有打标签的数据了，反过来回包也是如此，这样就实现了PC1与PC2的互相通信了。
我们来看一下简易图，有助于理解：
这就是为什么不同VLAN也可以通信的全过程了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd81a858ae3d7527429118e61c867de0/" rel="bookmark">
			Android JNI(三)：Java与Native相互调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、注册native函数2、JNI中的签名3、native代码反调用Java层代码 下面我们就进一步了解下一下JNI的调用原则，要想了解JNI的调用原则， 前面我们说了JNI中的JNIEnv以及Java类型和native中的类型映射关系。下面我们先来看注册native函数
一、注册native函数 当Java代码中执行Native的代码的时候，首先是通过一定的方法来找到这些native方法。而注册native函数的具体方法不同，会导致系统在运行时采用不同的方式来寻找这些native方法。
JNI有如下两种注册native方法的途径：
静态注册：
先由Java得到本地方法的声明，然后再通过JNI实现该声明方法动态注册：
先通过JNI重载JNI_OnLoad()实现本地方法，然后直接在Java中调用本地方法。 (一)、静态注册native函数
根据函数名找到对应的JNI函数；Java层调用某个函数时，会从对应的JNI中寻找该函数，如果没有就会报错，如果存在就会建立一个关联关系，以后再调用时会直接使用这个函数，这部分的操作由虚拟机完成。
静态注册就是根据函数名来遍历Java和JNI函数之间的关联，而且要求JNI层函数的名字必须遵循特定的格式。具体的实现很简单，首先在Java代码中声明native函数，然后通过javah来生成native函数的具体形式，接下来在JNI代码中实现这些函数即可。
举例如下：
public class JniDemo1{ static { System.loadLibrary("samplelib_jni"); } private native void nativeMethod(); } 接来下通过javah来产生jni代码，假设你的包名为com.gebilaolitou.jnidemo
javah -d ./jni/ -classpath /Users/YOUR_NAME/Library/Android/sdk/platforms/android-21/android.jar:../../build/intermediates/classes/debug/ com.gebilaolitou.jnidemo.JniDemo1 然后就会得到一个JNI的.h文件，里面包含这几个native函数的声明，观察一下文件名以及函数名。其实JNI方法名的规范就出来了：
返回值 + Java前缀+全路径类名+方法名+参数1JNIEnv+参数2jobject+其他参数
:注意事项：
注意分隔符：
Java前缀与类名以及类名之间的包名和方法名之间使用"_"进行分割；注意静态：
如果在Java中声明的方法是"静态的"，则native方法也是static。否则不是如果你的JNI的native方法不是通过静态注册方式来实现的，则不需要符合上面的这些规范，可以格局自己习惯随意命名 (二)、动态注册native函数
上面我们介绍了静态注册native方法的过程，就是Java层声明的nativ方法和JNI函数一一对应。以我来说，刚开始做JNI的前期，可能会遵守静态注册的流程：1、编写带有native方法的Java类，2、使用Javah命令生成.h头文件；3、编写代码实现头文件中的方法，这样的单调的标准流程，而且还要忍受这么"长"的函数名。那有没有更简单的方式呢？比如让Java层的native方法和任意JNI函数连接起来？答案是有的——动态注册，也就是通过RegisterNatives方法把C/C++中的方法映射到Java中的native方法，而无需遵循特定的方法命名格式。
当我们使用System.loadLibarary()方法加载so库的时候，Java虚拟机就会找到这个JNI_OnLoad函数兵调用该函数，这个函数的作用是告诉Dalvik虚拟机此C库使用的是哪一个JNI版本，如果你的库里面没有写明JNI_OnLoad()函数，VM会默认该库使用最老的JNI 1.1版本。由于最新版本的JNI做了很多扩充，也优化了一些内容，如果需要使用JNI新版本的功能，就必须在JNI_OnLoad()函数声明JNI的版本。同时也可以在该函数中做一些初始化的动作，其实这个函数有点类似于Android中的Activity中的onCreate()方法。该函数前面也有三个关键字分别是JNIEXPORT，JNICALL ，jint。其中JNIEXPORT和JNICALL是两个宏定义，用于指定该函数时JNI函数。jint是JNI定义的数据类型，因为Java层和C/C++的数据类型或者对象不能直接相互的引用或者使用，JNI层定义了自己的数据类型，用于衔接Java层和JNI层，这块前面已经介绍过了，我这里就不唠叨了。
PS：与JNI_OnLoad()函数相对应的有JNI_OnUnload()函数，当虚拟机释放的该C库的时候，则会调用JNI_OnUnload()函数来进行善后清除工作。
该函数会有两个参数，其中*jvm为Java虚拟机实例，JavaVM结构体定义一下函数：
DestroyJavaVM AttachCurrentThread DetachCurrentThread GetEnv 下面我们就举例说明
举例说明，首先是加载so库
public class JniDemo1{ static { System.loadLibrary("samplelib_jni"); } } 在jni中的实现
jint JNI_OnLoad(JavaVM* vm, void* reserved) 并且在这个函数里面去动态的注册native方法，完整的参考代码如下：
#include &lt;jni.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd81a858ae3d7527429118e61c867de0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1105acfa50abac7039f806dcc30b24c9/" rel="bookmark">
			Linux、CentOS超详细修改ip方法，手把手步骤教学，小白也能学会
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.切换root用户
1.1输入命令
1.2输入密码
1.2成功登录
1.3登录失败
2.使用root修改配置文件
2.1输入命令
2.2进入编辑模式
2.2.1修改BOOTPROTO
2.2.2修改ONBOOT
2.2.3修改ip和掩码等
2.2.4结果
2.3退出保存
2.4查看修改是否成功
​3.重启网络服务
4.查看ip是否修改成功
1.切换root用户 1.1输入命令 su //切换root用户 1.2输入密码 输入密码时，不会显示字符。
1.2成功登录 @前显示为root，即登录成功。
1.3登录失败 若密码输入不正确则会提示密码不正确，未成功登录，重新执行1.1操作步骤输入正确密码。
2.使用root修改配置文件 2.1输入命令 vi /etc/sysconfig/network-scripts/ifcfg-eth0 //修改网卡配置文件 具体以ifcfg后面跟的为准并进行修改，我这里虚拟机的网卡配置文件是ifcfg-ens192，所以最后面文件名是ifcfg-ens192。
2.2进入编辑模式 按键盘i键进入编辑模式，上下左右方向键进行移动。
配置文件中如果没有的字段，则自行输入进去。
下面//后内容不需要输入，是注释内容。
2.2.1修改BOOTPROTO BOOTPROTO=static //地址分配为静态 2.2.2修改ONBOOT ONBOOT=yes /开启自启动 2.2.3修改ip和掩码等 若只需要配置IP和掩码则其他不填写。
IPADDR=192.168.1.1 //IP地址 NETMASK=255.255.255.0 //子网掩码 GATEWAY=192.168.1.254 //网关 DNS1=1.1.1.1 //DNS1 DNS2=8.8.8.8 //DNS2 2.2.4结果 这个是我输入的，没有输入DNS，仅输入了IP、子网掩码、网关。
2.3退出保存 ①按键盘上的ESC
②同时按照键盘上的shift和；
③输入wq!
④回车
2.4查看修改是否成功 cat /etc/sysconfig/network-scripts/ifcfg-eth0 输入命令后，如果刚刚输入的内容全部显示，则说明保存成功。未显示从编辑文件开始从新修改。 3.重启网络服务 因为修改完配置文件有缓存数据，需要重启一下网络服务才可以生效。
systemctl restart network \\重启网络服务 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1105acfa50abac7039f806dcc30b24c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e414f2bfb265241647ee07be2e119a9a/" rel="bookmark">
			问题解决：pycharm debug断点调试时遇到Pycharm会卡死
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述： pycharm远程ssh连接服务器进行调试代码时，debug点击代码后pycharm卡死。
问题所在： train_data_loader = DataLoader(train_data, batch_size=self.config.train_batch_size, sampler=RandomSampler(train_data), num_workers=1) DataLoader中num_workers不能设置成多个。
解决方案： 把num_workers设置成0或删除即可！
train_data_loader = DataLoader(train_data, batch_size=self.config.train_batch_size, sampler=RandomSampler(train_data)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1d4028d22508245f38271ec67e5f946/" rel="bookmark">
			docker部署Elasticsearch7.17集群和kibana
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境准备：
3台centos7.9的服务器
vim /etc/sysctl.conf添加：vm.max_map_count=262144
sysctl -w vm.max_map_count=262144 即时生效
cat /proc/sys/vm/max_map_count 查看
#创建es配置目录
mkdir /home/es/config -p
#创建es数据目录
mkdir /home/es/data #创建es插件目录
mkdir /home/es/plugins
#授权目录
chmod -R 777 /home/es
在/home/es/config创建elasticsearch.yml的配置文件
# ======================== Elasticsearch Configuration =========================
# 配置es的集群名称，es会自动发现在同一网段下的es,如果在同一网段下有多个集群，就可以用这个属性来区分不同的集群
cluster.name: es-cluster
# 节点名称
node.name: es-node-1
# 指定该节点是否有资格被选举成为node
node.master: true
# 指定初始主节点
cluster.initial_master_nodes: ["10.161.3.12:9300"]
# 指定该节点是否存储索引数据，默认为true
node.data: true
# 设置绑定的ip地址还有其他节点和该节点交换的ip地址，本机ip
network.host: 0.0.0.0
network.publish_host: 10.161.3.12
# 指定http端口
http.port: 9200
# 设置节点间交互的tcp端口，默认是9300
transport.tcp.port: 9300
# 设置集群中master节点的初始列表，可以通过这些节点来自动发现新加入集群的节点
discovery.zen.ping.unicast.hosts: ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1d4028d22508245f38271ec67e5f946/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b927c94484fe2b2ae1e83eae2d2b2d6/" rel="bookmark">
			6 FFmpeg从入门到精通-FFmpeg滤镜使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 FFmpeg从入门到精通-FFmpeg简介
2 FFmpeg从入门到精通-FFmpeg工具使用基础
3 FFmpeg从入门到精通-FFmpeg转封装
4 FFmpeg从入门到精通-FFmpeg转码
5 FFmpeg从入门到精通-FFmpeg流媒体
6 FFmpeg从入门到精通-FFmpeg滤镜使用
7 FFmpeg从入门到精通-FFmpeg中Linux设备操作
8 FFmpeg从入门到精通-FFmpeg接口libavformat的使用
9 FFmpeg从入门到精通-FFmpeg接口libavcodec的使用
10 FFmpeg从入门到精通-FFmpeg接口libavfilter的使用
文章目录 6.FFmpeg滤镜使用 6.1 FFmpeg滤镜Filter描述格式 6.1.1 FFmpeg滤镜Filter的参数排列方式 6.1.2 FFmpeg滤镜Filter时间内置变量 6.2 FFmpeg为视频加水印 6.2.1 文字水印 6.2.2 图片水印 6.3 FFmpeg生成画中画 6.4 FFmpeg视频多宫格处理 6.5 FFmpeg音频流滤镜操作 6.5.1 双声道合并单声道 6.5.2 双声道提取 6.5.3 双声道转双音频流 6.5.4 单声道转双声道 6.5.5 两个音频源合并双声道 6.5.6 多个音频合并为多声道 6.6 FFmpeg音频音量探测 6.6.1 音频音量获得 6.6.2 绘制音频波形 6.7 FFmpeg为视频加字幕 6.7.1 ASS字幕流写入视频流 6.7.2 ASS字幕流写入封装容器 6.8 FFmpeg视频抠图合并 6.9 FFmpeg3D视频处理 6.9.1 stereo3d处理3D视频 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b927c94484fe2b2ae1e83eae2d2b2d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66c1dffd31d3903fbceda04dfa5839c3/" rel="bookmark">
			fastadmin隐藏table操作栏拖动排序按钮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 记录：fastadmin隐藏table操作栏拖动排序按钮
在 js 文件中的 Table.api.init 中添加一下代码：
dragsort_url:'', 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f58dd94c1bf7405d46775279b37058f/" rel="bookmark">
			ubuntu 安装QGIS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：官方文档
1.安装相关依赖
sudo apt install gnupg software-properties-common 2.安装QGIS签名密钥，以便信任并安装QGIS资源库中的软件
sudo mkdir -m755 -p /etc/apt/keyrings # not needed since apt version 2.4.0 like Debian 12 and Ubuntu 22 or newer sudo wget -O /etc/apt/keyrings/qgis-archive-keyring.gpg https://download.qgis.org/downloads/qgis-archive-keyring.gpg 3.创建qgis.sources
cd /etc/apt/sources.list.d/
cat &gt; qgis.sources
将下面的文本复制到终端后，Enter后再ctrl+c
Types: deb deb-src URIs: https://qgis.org/debian Suites: your-distributions-codename Architectures: amd64 Components: main Signed-By: /etc/apt/keyrings/qgis-archive-keyring.gpg 注意：your-distributions-codename应该改为自己电脑的系统对应的名字，使用lsb_release -cs查看。
4.更新资源库信息，映出刚刚添加的QGIS信息:
sudo apt update 5.开始安装QGIS
sudo apt install qgis qgis-plugin-grass 6.设置中文
设置-选项-通用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d83ea7af6f14b57164766770127661bf/" rel="bookmark">
			JEECG环境搭建及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1.JEECG项目介绍：
2.GIT地址：
3.后端的启动：
3.1初始化数据库 (要求 mysql5.7以上)
3.2修改项目配置（数据库、redis等）
3.3启动项目
4.前端的安装与使用
4.1环境要求:
4.2下载依赖并启动项目：
5.用户页面展示​
1.JEECG项目介绍： JeecgBoot 是一款基于代码生成器的低代码开发平台！前后端分离架构 SpringBoot2.x，SpringCloud，Ant Design&amp;Vue，Mybatis-plus，Shiro，JWT，支持微服务。强大的代码生成器让前后端代码一键生成，实现低代码开发! JeecgBoot 引领新的低代码开发模式(OnlineCoding-&gt; 代码生成器-&gt; 手工MERGE)， 帮助解决Java项目70%的重复工作，让开发更多关注业务。既能快速提高效率，节省研发成本，同时又不失灵活性！
JeecgBoot 提供了一系列低代码模块，实现在线开发真正的零代码：Online表单开发、Online报表、报表配置能力、在线图表设计、大屏设计、移动配置能力、表单设计器、在线设计流程、流程自动化配置、插件能力（可插拔）等等！
JEECG宗旨是: 简单功能由OnlineCoding配置实现，做到零代码开发；复杂功能由代码生成器生成进行手工Merge 实现低代码开发，既保证了智能又兼顾灵活；实现了低代码开发的同时又支持灵活编码，解决了当前低代码产品普遍不灵活的弊端！
JEECG业务流程: 采用工作流来实现、扩展出任务接口，供开发编写业务逻辑，表单提供多种解决方案： 表单设计器、online配置表单、编码表单。同时实现了流程与表单的分离设计（松耦合）、并支持任务节点灵活配置，既保证了公司流程的保密性，又减少了开发人员的工作量。
2.GIT地址： 后端：https://github.com/jeecgboot/jeecg-boot.git
前端：https://github.com/jeecgboot/jeecgboot-vue3.git
注意：拉取前后端代码时，若失败，可尝试修改项目名字
3.后端的启动： 3.1初始化数据库 (要求 mysql5.7以上) 脚本工作：创建数据库jeecg-boot, 执行Sql脚本 ： jeecg-boot/db/jeecgboot-mysql-5.7.sql
3.2修改项目配置（数据库、redis等） 3.3启动项目 4.前端的安装与使用 4.1环境要求: 版本要求Node 14.18+ / 16+ 版本以上，不再支持 Node 12 / 13 / 15。 建议使用pnpm，如果使用yarn,请用Yarn1.x版本，否则依赖可能安装不上。
注意事项：环境变量应配置到有pnpm的文件，如图所示：
4.2下载依赖并启动项目： 5.用户页面展示 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce877482788b3bccb54b2fe4f2bc70e1/" rel="bookmark">
			C语言编程题|统计字符串中字母和数字的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码：
#include&lt;stdio.h&gt; main() { char ch; int n = 0, m = 0; printf("Input 字符串:"); while ((ch = getchar()) != '\n')//依次判断输入字符的类型 { if (ch &lt;= '9' &amp;&amp; ch &gt;= '0') n++; else if ((ch &lt;= 'Z' &amp;&amp; ch &gt;= 'A')||(ch &lt;= 'z' &amp;&amp; ch &gt;= 'a')) m++; } printf("数字%d 字母%d \n", n, m); } 运行效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65fdda0d466d895c504822802ef7d224/" rel="bookmark">
			CSDN 社区内容创作规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSDN 长久以来秉持初心，致力于为广大 IT 用户提供良好的创作环境，打造健康有序的技术生态！但良好的社区环境，需各位创作者与 CSDN 共同维护建立！【CSDN 社区内容创作规范】请在发文前认真阅读：如你发布的内容存在以下问题，文章将无法通过审核，违规情节严重的，将对帐号进行封号处理。请各位创作者严格遵守社区的内容创作规范，共同守护我们的社区环境！
目录
一、在平台发布以下相关内容 审核将不予通过
1、违反法律法规和相关政策
2、无资质发布专业领域内容
3、流量作弊
4、营销/推广引流
5、不文明用语
6、封面/内容 配图违规
7、标题/内容违规
8、文章评论违规
9、版权风险
10、风险投资
二、涉及以下严重违规行为，一经发现，即刻封禁帐号
三、荣誉恢复说明
一、在平台发布以下相关内容 审核将不予通过 1、违反法律法规和相关政策 违反宪法确定的基本原则，煽动抗拒或者破坏宪法、法律、行政法规实施；危害国家统一、主权和领土完整，泄露国家秘密，危害国家安全，损害国家尊严、荣誉和利益，宣扬恐怖主义、极端主义；诋毁民族优秀文化传统，煽动民族仇恨、民族歧视，侵害民族风俗习惯、歪曲民族历史和民族历史人物，损害革命领袖、英雄烈士形象，伤害民族感情，破坏民族团结；煽动破坏国家宗教政策，宣扬宗教狂热，危害宗教和睦，伤害信教公民宗教感情，破坏信教公民和不信教公民团结，宣扬邪教、封建迷信；危害社会公德，扰乱社会秩序，破坏社会稳定，宣扬淫秽色情、赌博、吸毒，渲染暴力、恐怖，教唆犯罪或者传授犯罪方法；教唆、教授、组织他人进行违法乱纪活动，以非法民间组织名义活动的，宣传违法违规物品；侵害未成年人合法权益或者损害未成年人身心健康；侵犯他人隐私，侮辱或者诽谤他人，侵害他人合法权益；侵害他人名誉权、肖像权、知识产权、商业秘密等合法权利；含有法律、行政法规、规章、条例以及任何具有法律效力之规范所限制或禁止的其它内容。 2、无资质发布专业领域内容 未取得互联网新闻信息服务许可，不得发布新闻信息，新闻信息指：时政类新闻信息，包括有关政治、经济、军事、外交等社会公共事务的报道、评论，以及有关社会突发事件的报道、评论；未申请健康类专业资质认证的个人和机构，不得发布疾病治疗、用药指导等健康领域专业性强的内容；未申请财经类专业资质认证的个人和机构，不得发布股票买卖指导、投资指南等财经领域专业性强的内容；我国法律法规要求必须取得特定资质方可从事特定行为的其他情形，依该等法律法规要求处理。 3、流量作弊 滥用功能产品进行流量作弊，批量发布重复、无意义的低质内容，恶意刷粉刷赞，影响用户体验、破坏平台规则且损害他人权益的行为。包含但不限于以下场景：
违规刷流量： 利用工具批量刷流量：一段时间内的文章，用非正常手段连续使文章流量异常增高；违规批量重复发文： 批量发无意义/低质内容：连续或大量发布无意义元素，包括但不限于无意义图片、符号、表情、乱码、无序文字等；违规刷粉点赞：通过非正常手段进行作弊，获取虚假粉丝、虚假点赞数据的行为。 4、营销/推广引流 为提高 CSDN 内容生态质量，同时赋能博主实现知识变现，我们对合规、优质、具备正向影响力的博主开放「推广管理」功能，包括微信公众号、微信号、官方网站、QQ 号、QQ 群五种推广方式；当然，如果您有多场景的交流及外链推广需求，建议您申请创建「个人社区」。
另外，为维护社区良好生态，CSDN 会不断治理恶意营销等黑产行为，即以营利、获益、引流为目的，博客内容附带 CSDN 未接入的第三方平台联系方式、售卖链接，或诱导私信联系转线下交易，引导用户消费但可能存在风险的行为。包含但不限于以下场景：
营销链接：带有明显营销意图的第三方网址，或诱导用户在第三方电商平台领取红包、购买交易的口令和店铺号等；引导交易：推广虚拟货币、虚拟商品、虚拟服务类交易，如游戏点卡、游戏在线服务、网游装备、Q 币、软件序列号、电子书等；纯广告：以推广产品、盈利为目的作品，包括产品宣传、商业服务宣传、商业赞助宣传、商业展销宣传等。 5、不文明用语 包含但不限于以下场景：
骚扰辱骂：使用污言秽语、蔑称、外号、同音近音词等直接辱骂或言语骚扰他人；歧视恶搞：恶搞、歧视特定群体，或言论带有明显的性别歧视、种族歧视、地域歧视等；情绪宣泄：通过粗俗不堪的口头禅、网络用语等发泄情绪，表达不满的。 6、封面/内容 配图违规 配图内容侵权，与技术文章主体无关且涉及敏感信息。包含但不限于以下场景：
图片涉及低俗；图文涉及政治；图片涉及版权，未经个人/机构授权。 7、标题/内容违规 标题、文章内容 ，包含但不限于以下场景：
标题低质：出现夸张、故留悬念、强迫类等标题与正文不符等；低俗内容：标题/内容 含有色情等低俗诱导性内容；翻墙内容：标题/内容 含有讲解技术手段或使用第三方工具，访问被屏蔽的网站；网络用语：违反广告法用语，标题/内容 含有领导人名讳/恶搞等内容；排版混乱：文章乱码、无段落或无标点，语义不通等； 以下为详细的不符合平台规范的标题情况（还请认真研读）：
7.1、标题夸张 7.1.1 夸张式标题
标题使用「震惊」、「惊爆」、「传疯」、「吓掉半条命」等，言过其实地表达情绪/状态/感受；
标题使用「全世界网友」、「所有男人都」、「某国人」、「99%」等，进行无依据的范围夸大；
标题使用「XX天见效」、「根治」、「立竿见影」等，对效果或结果做不符合常识的断言或保证；
标题使用「重磅」、「要命」、「就在刚刚」等，对事件的严重和紧急程度夸张形容，引起过度警觉和关注；
标题使用「世界之最」、「最高级」、「最佳」、「最烂」等，形容人事物在某些程度上达到极致，但违背事实和大众认知。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65fdda0d466d895c504822802ef7d224/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d299fb76aa3d661669db510675bfdce8/" rel="bookmark">
			ipmitool 修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、BMC打印基本信息 ipmitool lan print 1 2、BMC设置子网掩码 ipmitool lan set 1 netmask 255.255.255.0 3、BMC设置网关IP ipmitool lan set 1 defgw ipaddr 172.17.10.254 172.17.10.X
必须对应
255.255.255.0
正好是255转化二进制是8个位，3个255.正好24
172.17.10.X/24
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1df1ef06f13b001c9cb452cadbbdb072/" rel="bookmark">
			pycharm连接虚拟机中的spark
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.打开pycharm 2.解压hadoop，解压到windows下面，切记不要有中文路径 3.解压spark，解压到windows下面，切记不要有中文路径 4. 把haoop，sprk对应的环境变量配置到pycharm中 4.1新建一个项目 4.2在项目中新建一个python文件 4.3把hadoop添加到pycharm中 HADOOP_HOME 4.4winutils.exe 插件放到hadoop/bin下面 4.5把spark添加到pycharm中 SPARK_HOME、PYTHONPATH 5.安装插件 6.测试 6.1把以下代码放到我们4.2步哪里新建的testspark.py文件中 import findspark findspark.init() from pyspark.sql import SparkSession spark = SparkSession.builder.appName("WordCount").getOrCreate() spark.sparkContext.textFile("file:///D:/ruanjian/spark/spark-2.4.6-bin-hadoop2.7/README.md")\ .flatMap(lambda x: x.split(' '))\ .map(lambda x: (x, 1))\ .reduceByKey(lambda x, y: x + y)\ .foreach(print) 注意注意注意
6.2 安装pyspark和findspark 6.3测试 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd3bc0bf348927cbe673d886285eb5e1/" rel="bookmark">
			Linux和Unix的系统下的依赖文件rpm包下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、访问地址
二、搜索需要的文件
三、找到对应的操作系统的rpm包
​四、复制下载链接进行下载 在Linux和Unix的系统下安装应用时，会存在的依赖文件rpm包需要进行安装下载。
如下图：
可以看到安装时，系统提示我们依赖检测失败。
需要dejavu-fonts-common-2.33和libpng-1.5，这2个依赖文件。
下面就给大家讲如何下载依赖文件rpm包，即如何安装。
一、访问地址 首先访问Linux和Unix的系统下的rpm包下载地址：
https://pkgs.org/
二、搜索需要的文件 在右上角搜索框输入我们要下载的rpm软件包名字，点击搜索。
这里是提示我们验证，让选择3个关于鸟的图片。（验证这一步有时候跳过）
三、找到对应的操作系统的rpm包 根据操作系统进行选择rpm包，如我的操作系统是CentOS 7.4,则选择CentOS 7目录下的x86架构即：CentOS x86_64下的文件。
点击进入我们需要下载依赖文件rpm包。
四、复制下载链接进行下载 下滑，找到Download，根据我们的服务器进行选择，我们这里选择x86安装包，复制后面得URL，在网页中打开，即成功完成下载。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76c67a39b364aab0c89f6826dc03392a/" rel="bookmark">
			如何使用PyCharm里面的库Flask，以及怎么去安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flask是一个轻量级的Python Web框架，它可以让我们快速地开发Web应用程序。在本文中，我将介绍如何在PyCharm这个强大的IDE中使用Flask库，以及怎么去安装它。
首先，我们需要安装Flask库。有两种方法可以做到这一点：
方法一：使用pip命令
pip是Python的包管理工具，它可以帮助我们下载和安装各种Python库。要使用pip安装Flask，我们只需要在命令行中输入：
pip install flask
这个命令会自动下载和安装Flask以及它的依赖库，如Jinja2和Werkzeug。如果你的电脑上有多个Python版本，你可能需要指定使用哪个版本的pip，例如：
pip3 install flask
或者
python -m pip install flask
方法二：使用PyCharm的包管理功能
PyCharm是一个专业的Python开发工具，它提供了很多便利的功能，其中之一就是包管理。要使用PyCharm安装Flask，我们可以按照以下步骤操作：
1. 打开PyCharm，创建一个新的项目或者打开一个已有的项目。
2. 点击File菜单，选择Settings选项。
3. 在弹出的窗口中，选择Project:项目名字，然后选择Python Interpreter选项。
4. 在右侧的列表中，点击+号按钮，搜索flask，并点击Install Package按钮。
5. 等待安装完成后，点击OK按钮关闭窗口。
这样，我们就成功地在PyCharm中安装了Flask库。
接下来，我们可以在PyCharm中使用Flask库来创建一个简单的Web应用程序。我们可以按照以下步骤操作：
1. 在PyCharm中，创建一个新的Python文件，命名为app.py。
2. 在app.py文件中，导入Flask类，并创建一个Flask对象，命名为app。
3. 使用@app.route()装饰器来定义路由规则，即指定哪个URL对应哪个函数。
4. 在函数中，返回一个字符串作为响应内容。
5. 使用app.run()方法来启动服务器，并指定主机地址和端口号。
例如，我们可以编写如下代码：
from flask import Flask
app = Flask(__name__)
@app.route('/')
def index():
return 'Hello, Flask!'
@app.route('/hello/&lt;name&gt;')
def hello(name):
return 'Hello, {}!'.format(name)
if __name__ == '__main__':
app.run(host='0.0.0.0', port=5000)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76c67a39b364aab0c89f6826dc03392a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c517a2ac3f3fd6d511b2d4a40011a6fe/" rel="bookmark">
			STM32基础---GPIO介绍及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、GPIO简介 GPIO是通用输入输出端口（General-purpose input/output）的英文简写。STM32的GPIO端口有四种输入模式和四种输出模式。输出模式下可控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等；输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等。
I/O 端口的每个位均可自由编程，但必须按照 32 位，即以字为单位访问（不允许半字或字节访问） I/O 端口寄存器。 每个 GPIO 引脚都可以由软件配置成输出（推挽或开漏）、输入（浮空输入、上拉输入或下拉输入）或其它的外设功能端口。多数 GPIO 引脚都与数字或模拟的外设共用。 I/O 引脚的外设功能可以按需锁定，以避免意外的写入 I/O 寄存器。 所有的 GPIO 引脚都有大电流通过能力。
2、GPIO基本结构 这是GPIO的硬件结构框图，可以从这个框图中清晰的了解GPIO外设极其各种应用模式，最右端的I/O引脚就是STM32芯片引出的GPIO引脚，其它的部件都位于芯片内部。
关键器件解析：
1、保护二极管：防止I/O引脚外部过高、过低的电压输入，当引脚电压高于VDD时，上方的二极管导通；当引脚电压低于VSS时，下方的二极管导通，防止不正常电压引入芯片导致芯片烧毁。
2、TTL肖特基触发器：将模拟信号转化为0和1的数字信号，但当GPIO作为ADC采集电压通道时，此时信号不再经过触发器进行TTL电平转换。
3、P-MOS、N-MOS：单元电路使得GPIO具有“推挽输出”和“开漏输出”的功能。
3、GPIO工作模式 GPIO一共有8中工作模式。分别是浮空输入、上拉输入、下拉输入、模拟输入、开漏输出、推挽输出、开漏复用输出、推挽复用输出。
3.1 浮空输入模式 在浮空输入模式下，I/O端口的电平信号有外部输入决定，当I/O端口悬空（在无信号输入）的情况下，引脚的电平状态不确定。浮空输入模式通常用于配置USART的RX引脚。
3.2 上拉输入模式 在上拉输入模式下，I/O端口悬空（在无信号输入）的情况下，电平状态保持在高电平，当输入低电平时，电平状态是低电平。
3.3 下拉输入模式 在下拉输入模式下，I/O端口悬空（在无信号输入）的情况下，电平状态保持在低电平，当输入高电平时，电平状态是高电平。
3.4 模拟输入模式 在模拟输入模式下，I/O端口的模拟信号（电压信号，而非电平信号）直接模拟输入到片上外设模块，比如ADC模块等。模拟输入通常应用于ADC模拟输入，或者低功耗下省电等情景。
3.5 开漏输出模式 在开漏输出模式下，位设置/清除寄存器写入的值会被映射到输出数据寄存器，到输出控制电路，途径N-MOS管，最终输出到I/O引脚。开漏输出只可以输出强低电平，高电平得靠外部电阻拉高，输出端相当于三极管的集电极，适合于做电流型的驱动，其吸收电流的能力相对强(一般20ma以内)。
需要注意N-MOS管的特性，当设置输出的电平状态为高电平时，N-MOS管处于关闭状态，此时I/O端口的电平就不会由输出的高低电平决定，而是由I/O端口内部或者外部的上拉或者下拉决定；当设置输出的电平状态为低电平时，则N-MOS管处于开启状态，此时I/O端口的电平就是低电平。输出的电平信号可以被输入数据寄存器读取。
3.6 推挽输出模式 推挽输出模式和开漏输出模式有一定的区别，其控制输出的寄存器是一样的。输出控制电路输出1的时候，P-MOS管导通，N-MOS管截止，这样I/O口电平就会被P-MOS管拉高，输出强高电平；相反，当输出控制电路输出0时，P-MOS管截止，N-MOS管导通，I/O端口电平被N-MOS管拉低，输出强低电平。同样，输出的电平信号可以被输入数据寄存器读取。
需要注意P-MOS管和N-MOS管的特性，当设置输出的电平状态为高电平时，P-MOS管处于开启状态，N-MOS管处于关闭状态，此时I/O端口的电平就由P-MOS管决定：高电平；当设置输出的电平状态为低电平时，P-MOS管处于关闭状态，N-MOS管处于开启状态，此时I/O端口的电平就由N-MOS管决定：低电平。
3.7 开漏复用输出模式 开漏复用输出模式的原理和开漏输出模式的原理基本一致，只不过输出的高低电平不是由MCU配置位设置/清除寄存器或者输出数据寄存器的值决定，而是利用片上外设模块的复用功能输出来决定的（通信接口（SPI，UART，I 2 C，USB，CAN，LCD等）、定时器、调试接口等复用）。开漏复用输出模式通常用于TX1、MOSI、MISO等引脚的配置。
3.8 推挽复用输出模式 推挽复用输出模式的原理和推挽输出模式的原理基本一致，只不过输出的高低电平不是由MCU配置位设置/清除寄存器或者输出数据寄存器的值决定，而是利用片上外设模块的复用功能输出来决定的（通信接口（SPI，UART，I2 C，USB，CAN，LCD等）、定时器、调试接口等复用）。推挽复用输出模式通常用于I2C的SCL、SDA引脚的配置。
3.9 注意事项 推挽输出可以输出强高低电平（高电平为3.3V），一般用来连接数字器件。在STM32的应用中，除了必须用开漏模式的场合，我们都习惯使用推挽输出模式。
开漏输出只可输出强低电平，高电平需要靠外部电阻拉高。输出端相当于三极管的集电极；要得到高电平状态需要上拉电阻才行。适合于做电流型的驱动，其吸收电流的能力相对强（一般20ma以内）。开漏输出一般应用在I2C、SMBUS通讯等需要“线与”功能的总线电路中。除此之外，还用在电平不匹配的场合，如需要输出5伏的高电平，就可以在外部接一个上拉电阻，上拉电源为5伏，并且把GPIO设置为开漏模式，当输出高阻态时，由上拉电阻和电源向外输出5伏电平。
4、GPIO相关寄存器 每个 GPIO 端口有两个 32 位配置寄存器（ GPIOx_CRL， GPIOx_CRH）、两个 32 位数据寄存器（GPIOx_IDR 和 GPIOx_ODR）、一个 32 位置位/复位寄存器（GPIOx_BSRR）、一个 16 位复位寄存器（GPIOx_BRR） 、 一 个 32 位 锁 定 寄 存 器 （ GPIOx_LCKR）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c517a2ac3f3fd6d511b2d4a40011a6fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52fa6149ca7c2747e84264b6db816c2c/" rel="bookmark">
			js 数组中将某一对象元素进行替换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我从未打过折扣 var asd = {name: ‘李四’, age: 12};
let list = [
{name: ‘张三’},
{name: ‘李四’}
]
list = list.map(t =&gt; {
return t.name === asd.name ? asd: t;
});
console.log(list)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c4a087236b20f202e65727ff783a85c/" rel="bookmark">
			基于ChatGPT制作的一款英语口语练习应用SpokenAi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍了一款基于ChatGPT的英语口语练习应用SpokenAi，包括PortAudio的安装流程和核心代码，以及语音合成TextToSpeech的实现。同时提供了配置文件和部署运行示例。 --由ChatGPT总结生成
一.前言 Hi，大家好，我是Baird。最近几个月大火大热的ChatGPT已经发布到ChatGPT4版本了，我也一直在关注ChatGPT的发展，一直在思考能基于ChatGPT或着说openai的能力能做出点什么应用，解决一些问题。
💥在仔细看过openai的API文档后，发现openai不止提供了Chat的能力，还提供了如语音转文字，图片生成等能力。虽然没有ChatGPT那么火，但经过一番试用后，发现和ChatGPT效果一样让人惊艳。索性就直接来一个openai全家桶，通过openai的能力开发一款应用试试。
开发什么呢？ 🤔
ChatGPT对英语的语言能力自然不必说，而我们国人当下英语学习面临的一大问题就是哑巴英语，市面上的提供的英语对话机器人和ChatGPT比起来差得不是一星半点。只能请老师一对一真人教学？ 🤨 拜托，现在都2023年了，还需要花钱请口语老师么？
来造一款Ai口语练习应用解决这个问题 💯
ChatGPT4是由OpenAI开发的自然语言处理模型，采用了大规模无监督学习的方式进行训练，可用于生成文本、回答问题和聊天等任务。OpenAI是人工智能领域的一家公司，其API文档提供了多种功能，包括语音转文字、图片生成等。
二.需求清单 首选先列出我们需求清单，这个是一个简单版本的英语口语练习功能，先不打算造一个大app，我们只需要解决如下问题
读取语音输入语音转文字通过ChatGPT沟通交流文字转音频音频播放持续进行上述1～5步骤 基于上述功能，第一期我打算先做一个终端版本的应用-SpokenAi，看看后续发展再考虑做一个Web或APP版本的程序 （实际上是缺人手缺时间 🤧）
三.系统架构 来，先设计一下我们SpokenAi的系统架构
portaudio: PortAudio是一个跨平台的音频I/O库，提供了简单的API，使得开发人员可以在不同的平台上以相似的方式访问音频硬件。它支持Windows、Mac OS X、Linux和其他主要的操作系统。PortAudio支持多种音频API，包括ASIO、Core Audio、DirectSound、MME / WDM、ALSA和OSS。PortAudio还包括一个流接口，允许开发人员以相同的方式使用不同的音频API和硬件。openai-api: 提供了多种API服务，包括但不限于自然语言处理、语音转文字、文字转语音、图像生成等。在OpenAI的API文档中，用户可以申请API密钥，并使用API进行开发和测试。tensorflowtts: TensorflowTTS 是一个基于 TensorFlow 的语音合成工具包，它包含了多种语音合成模型和前处理工具，并且支持多种语音合成任务，例如有人声合成（Vocoder）、语音转换、语音增强等。它可以帮助开发者快速搭建语音合成模型，定制自己的语音合成系统。Docker: Docker是一种容器化技术，可以将应用程序及其依赖项打包在一个容器中，以便在任何地方运行。容器是一种轻量级的虚拟化技术，可以提供与传统虚拟机相似的隔离性和安全性，但占用的资源更少。Docker还提供了一套工具和平台，使得容器的构建、部署和管理变得更加容易。SpokenAi:整体应用层，其中有三个库分别是praudio、rocket、ttsclient，对应如下作用 praudio: 封装portaudio，对外提供音频录制和音频播放等接口rocket: 封装openai-api, 对外提供Chat接口、音频转文字等接口ttsclient: 提供调用容器化运行的tensorflowtts的接口 Console: 终端交互层，用户按提示进行操作，输入信息和进行相关操作 Tips:tensorflowtts 依赖较多，为方便完整，这里采用Docker部署
四.流程设计 接下来，我们设计一下交互流程
简单概括总体流程有三个步骤，一是输入个人信息 二是录音转文字，三是发送消息，进行对话交互
由于是通过终端访问，主要监听键盘事件，进行不同操作
如 按W键会开始录音，录音过程中按Q停止录音，待录音翻译完成后，按Ctrl+shift+enter发送消息
五.开发细节 编程语言: Go 1.6+
SpokenAi使用依赖于portaudio，需要提前安装好portaudio否则编译无法通过
PortAudio 一.PortAudio下载地址:
Windows: http://www.portaudio.com/download.htmlMacOS: brew install portaudioLinux: apt-get install portaudio19-dev Mac和Linux比较好安装，Windows只能源码编译安装，具体流程如下：
PortAudio Window 安装流程 下载PortAudio源码：http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c4a087236b20f202e65727ff783a85c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37fd0b1ad8463eed1f58494c8e00bb65/" rel="bookmark">
			Java Object类详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Object 是 Java 类库中的一个特殊类，也是所有类的父类。也就是说，Java 允许把任何类型的对象赋给 Object 类型的变量。当一个类被定义后，如果没有指定继承的父类，那么默认父类就是 Object 类。因此，以下两个类表示的含义是一样的。
public class MyClass{…} 等价于
public class MyClass extends Object {…} 由于 Java 所有的类都是 Object 类的子类，所以任何 Java 对象都可以调用 Object 类的方法。常见的方法如表 1 所示。
表 1 Object 类的常用方法 方法说明Object clone()创建与该对象的类相同的新对象boolean equals(Object)比较两对象是否相等void finalize()当垃圾回收器确定不存在对该对象的更多引用时，对象垃圾回收器调用该方法Class getClass()返回一个对象运行时的实例类int hashCode()返回该对象的散列码值void notify()激活等待在该对象的监视器上的一个线程void notifyAll()激活等待在该对象的监视器上的全部线程String toString()返回该对象的字符串表示void wait()在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待 其中，toString()、equals() 方法和 getClass() 方法在 Java 程序中比较常用。
toString() 方法 toString() 方法返回该对象的字符串，当程序输出一个对象或者把某个对象和字符串进行连接运算时，系统会自动调用该对象的 toString() 方法返回该对象的字符串表示。
Object 类的 toString() 方法返回“运行时类名@十六进制哈希码”格式的字符串，但很多类都重写了 Object 类的 toString() 方法，用于返回可以表述该对象信息的字符串。
哈希码（hashCode），每个 Java 对象都有哈希码属性，哈希码可以用来标识对象，提高对象在集合操作中的执行效率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37fd0b1ad8463eed1f58494c8e00bb65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abcd727bf2d4df0a271e6bafb6abcdac/" rel="bookmark">
			Idea常用快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		”Alt +“系列
Alt + / 快速补全代码 Alt + Enter 快速提示完成，在代码可能存在语法问题时，IDEA 会提示使用该快捷键可以快速自动修正 许愿法自动创建方法
Alt + insert 快速生成含有任意形参的构造器，和私有属性的 Getter / Setter 方法等（最常使用）
Alt+Q 显示当前方法的声明
Alt + 7 快速显示类结构，可以显示类中包含的所有属性和方法
Alt + left / right 快速切换代码视图
Alt + Up / Down 在方法间快速移动定位（即光标以方法为单位移动）
”Ctrl + “系列
Ctrl + W 选中文本，连续按可以扩大选中范围（以单词为单位）
Ctrl + Y 删除当前行
Ctrl + D 复制当前行，直接在下一行复制出当前行 （Duplicate复制）
Ctrl + / 添加注释和取消注释，【第一次是添加注释，第二次是取消注释】
Ctrl + F 在当前文件中查找文本 （Find 查找）
Ctrl + R 查找并替换文本（基本可以完成Ctrl + F的功能），支持多行查找，或者只在代码中查找，或者只在注释中查找，或者使用正则表达式查找（Replace 替换）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abcd727bf2d4df0a271e6bafb6abcdac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce646df3e1886e5eaf924b840c9daac0/" rel="bookmark">
			Stream流中，根据对象去重&#43;指定对象中的属性去重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先定义一个学生类：
@Data @AllArgsConstructor public class Student { private Long id; private String name; private Integer age; private Double high; } 在main方法中构造四个对象，其中第四个对象为重复对象，现在进行对象的去重、以及对象中某一属性的去重操作
public class ListStreamDistinctTest { public static void main(String[] args) { // 一个集合中放入4个学生对象 List&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(new Student(10002L, "ZhangSan", 18, 175.2)); list.add(new Student(10001L, "LiSi", 19, 175.2)); list.add(new Student(10004L, "Peter", 19, 170.8)); list.add(new Student(10004L, "Peter", 19, 170.8)); } } 一、根据对象去重：
以下代码写于main函数中：
System.out.println("整个对象去重："); list.stream().distinct() .forEach(System.out::println); 运行结果如下，可以看到，stream流的distinct只是将对象去重，将相同的第三个和第四个对象去重了
二、根据对象中某一属性（年龄）去重：
方法一、自定义其他方法：
以下代码写于main函数中：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce646df3e1886e5eaf924b840c9daac0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aecaa0f8abd5e5dbe0f33009f1ac773/" rel="bookmark">
			微信小程序导航头部吸顶效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		功能描述：当页面滚动到该元素的时候，变成固定的导航头部，也就是固定在最上面，当往回滑动时又变成原来的样子。
基本原理是：
1.获取要吸顶元素到页面顶部的高度
2.监听页面已经滚动的高度
3.将要吸顶元素到页面顶部的高低和页面已经滚动的高度进行对比。当滚动距离大于等于要吸顶元素的高度时，变成吸顶状态；当滚动距离小于要吸顶元素的高度时，取消吸顶状态；
一、首先解决第一点：在页面加载出来时，onload事件中，拿到要吸顶元素到页面顶部的高度
data: { scrollTop: 0, // 页面滚动距离 stickyHeight: 0, // 吸顶元素的高度 isSticky: false // 是否吸顶 }, onLoad: function (options) { // 获取需要吸顶元素的高度 wx.createSelectorQuery().select('.recommend').boundingClientRect((rect) =&gt; { this.setData({ // 这个top是节点的上边界坐标 stickyHeight: rect.top }) console.log(rect.top) console.log(this.data.stickyHeight) }).exec() }, 二、监听页面已经滚动的高度
onPageScroll: function (e) { console.log(e) // 监听页面滚动事件 this.setData({ scrollTop: e.scrollTop }) if (this.data.scrollTop &gt;= this.data.stickyHeight) { // 当滚动距离大于等于吸顶元素的高度时，设置为吸顶状态 this.setData({ isSticky: true }) } else { // 当滚动距离小于吸顶元素的高度时，取消吸顶状态 this.setData({ isSticky: false }) } }, 三、对比俩个高度，更改是否吸顶的值（isSticky）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1aecaa0f8abd5e5dbe0f33009f1ac773/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/274d16e287452c634546342dbe0a08e5/" rel="bookmark">
			DDR4 timing 参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ACTIVATE Timing ParameterFunctiontRRD_SWhen issuing consecutive ACTIVATE commands to banks of different bank groups, the ACTIVATE commands have to be separated by tRRD_S (row-to-row delay–short)tRRD_LIf the banks belong to the same bank group, their ACTIVATEs have to be separated by tRRD_L (row-to-row delay–long)tFAWFour Activate Window or sometimes also called Fifth Activate Window is a timing restriction. tFAW specifies a window within which only four activate commands can be issued. So, you can issue ACTIVATE commands back-to-back with tRRD_S between them, but once you have completed 4 activates you cannot issue another one until the tFAW window expires.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/274d16e287452c634546342dbe0a08e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75fb52a0a803759022fa25bdfdbeb431/" rel="bookmark">
			安装 kafka 配置 sasl 认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装kafka 1、安装jdk
yum search jdk # 查找jdk
yum install java-latest-openjdk.x86_64 # 选择jdk安装，这里选择最新的版本
下载 http://archive.apache.org/dist/kafka/
wget http://archive.apache.org/dist/kafka/2.6.0/kafka_2.12-2.6.0.tgz
2、下载kafka
去 https://mirrors.tuna.tsinghua.edu.cn/apache/kafka 找到对应版本下载
cd /usr/local
wget https://mirrors.tuna.tsinghua.edu.cn/apache/kafka/2.6.0/kafka_2.12-2.6.0.tgz
tar zxf kafka_2.12-2.6.0.tgz
mv kafka_2.12-2.6.0 kafka
3、启动kafka
cd kafka
./bin/zookeeper-server-start.sh ./config/zookeeper.properties # 先启动zookeeper
./bin/kafka-server-start.sh ./config/server.properties # 再启动kafka
二、配置 sasl 认证 1、添加/修改配置文件
vim ./config/kafka_zoo_jaas.conf
ZKServer{
org.apache.kafka.common.security.plain.PlainLoginModule required
username="admin"
password="admin-kafka"
user_admin="admin-kafka";
};
vim ./config/kafka_server_jaas.conf
KafkaServer {
org.apache.kafka.common.security.plain.PlainLoginModule required
username="admin"
password="admin-kafka"
user_admin="admin-kafka"
user_test="test123";
};
vim ./bin/zookeeper-server-start.sh 在最前面加入
export KAFKA_OPTS="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75fb52a0a803759022fa25bdfdbeb431/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa9c8fe0337fdaa645429382eabb68a9/" rel="bookmark">
			什么是虚拟化？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是虚拟化？ “虚拟化“这个词只要是接触过计算机和网络的，或多或少都有听过。什么虚拟机、存储虚拟化、网络虚拟化、网络功能虚拟化（NFV）、虚拟资源池……今天从什么是虚拟化讲起。
什么是虚拟化 由于虚拟化在各种企业的技术宣传中都被使用过，虚拟化（Virtualization）这个词比较难界定，按照虚拟的对象、抽象程度等也可以分成多种虚拟化，用维基百科中提到的不严格的定义来讲：
在计算机技术中，虚拟化（技术）或虚拟技术（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源（CPU、内存、磁盘空间、网络适配器等），予以抽象、转换后呈现出来并可供分割、组合为一个或多个电脑配置环境。由此，打破实体结构间的不可切割的障碍，使用户可以比原本的配置更好的方式来应用这些电脑硬件资源。这些资源的新虚拟部分是不受现有资源的架设方式，地域或物理配置所限制。一般所指的虚拟化资源包括计算能力和资料存储。
Red Hat在官网也对虚拟化作出了通俗的描述。
以我的理解，虚拟化技术就是把真实存在的XXX以软件等形式，在原有XXX的基础上，实现多个虚拟XXX，或者把真实存在的多个XXX以某种方式使其透明地成为整个虚拟的XXX。比如你可以在你的主机上开多个虚拟机；又如把存储设备统一管理，对外是一整个存储设备。
看看各大企业是怎么解释的 IBM 维基百科上说IBM是虚拟化的鼻祖，看看它是咋说的：
虚拟化是让物理主机硬件资源得到更充分应用的过程，也是云计算的基础。
虚拟化通过软件在计算机硬件之上构建一层抽象层，允许硬件的处理器、内存、存储硬盘等被划分成多个虚拟计算机，也就是俗称的Virtual Machine（VM），每个VM运行各自的操作系统，即便他们实际都是运行在底层计算机硬件上的一部分，各个VM也表现为互相独立的计算机。
由此可见，虚拟化能够更有效地利用计算机物理硬件资源，能够为一个机构在硬件上的投资带来更大的回报。
如今，虚拟化是企业在IT架构上的标准做法，同时也是云计算的主要驱动技术。虚拟化使得云提供商能够基于他们现有的计算机物理硬件，为用户提供更好的服务；云用户也能够按需购买所需的计算资源，并在工作负载增加时经济而高效的拓展计算资源。
Red Hat 红帽的图让人很喜欢。
虚拟化是一种技术，可以利用以往局限于硬件的资源来创建有用的 IT 服务。它让您能够将物理计算机的工作能力分配给多个用户或环境，从而充分利用计算机的所有能力。
举一个实际例子，假设您有 3 台物理服务器，分别用于不同的特定用途。 其中一台是邮件服务器，一台是 Web 服务器，最后一台则用于运行企业内部的传统应用。 每台服务器只使用了大约 30% 的计算容量，这仅是运行潜能的一小部分。但是，由于传统应用对内部运营非常重要，您必须将其连同所运行的第三台服务器予以保留，对吗？
过去确实如此。相对简单和可靠的做法是在单独的服务器上运行单独的任务：1 台服务器， 1 个运行操作系统，1 个处理任务。我们很难让 1 台服务器有多个大脑。但是，借助虚拟化技术，您可以将邮件服务器分为 2 个能够处理独立任务的特殊服务器，从而实现传统应用的迁移。您仍然使用相同的硬件，但可以更加高效地利用这些资源。
考虑到安全问题，您可以再次划分第一台服务器，从而可以处理另一项任务，将其使用率从 30% 提高到 60%，甚至提高到 90%。这样，现在空闲的服务器可以用于其他任务或停用，以降低散热和维护成本。
VMware 像大多数组织一样，随着业务的发展和增长，你可能正面临新的IT挑战。在一个动态的环境中，你需要提高敏捷性以跟上快速变化的业务需求。你的员工、客户和业务伙伴都要求更多的响应服务和更复杂的应用程序。当你试图跟上新的要求和不断增长的需求时，你的IT基础设施正变得越来越大，越来越复杂，给你的IT设施带来了更大的压力。
虚拟化有助于解决你最紧迫的技术挑战：基础设施的无序扩张迫使IT部门将70%的预算用在维护上，并消耗了用于业务建设创新的资源。困难源于当今X86计算机的架构：它们被设计为一次只运行一个操作系统和应用程序。这意味着，即使是小型的数据中心也必须部署许多服务器–每台服务器只能以12%的容量运行。虚拟化软件通过使多个操作系统和应用程序在一台物理服务器(host)上运行来解决这个问题。
回到原本想回答的问题： 请介绍目前通用的虚拟化方案有哪些，其对应的优劣及应用场景分别是什么？
从两个角度来答：架构角度和企业侧角度。
架构角度 从实现架构上将虚拟化方案分类，也就是从虚拟化技术本身出发。现在网上资料众说纷纭，我在这里加上自己的理解做一个整合，起一个通识的作用：
全虚拟化（Full Virtualization）
全虚拟化是最早出现的虚拟化技术。顾名思义，全虚拟化中VM从头到脚都是虚拟化的，VM操作系统所发出的一切可能指令都由虚拟化层（即VM Manager, VMM或者Hyperviser）处理。
全虚拟化最先完全由软件实现，典型的实现是将客户VM的二进制代码进行翻译。后来出现了硬件辅助的全虚拟化，典型的如Intel-VT和AMD-V。
相对来说更加简单和易于实现，但由于有两层OS，管理开销更大，性能损耗大。
很多个人或者小型的组织使用的VMware Workstation和VirtualBox就属于这种软件辅助的全虚拟化，还有KVM等
半虚拟化（Para Virtualization）
半虚拟化中客户VM知道其运行在虚拟平台上，并需要主动适应，这样的虚拟平台需要对所运行的客户机操作系统进行或多或少的修改使之适应虚拟环境。虚拟化层是直接安装在硬件设备上的，会接管虚机的指令。
这种技术不依赖于操作系统，但需要对虚拟层的内核进行开发，开发难度更大。
VMware ESX、Xen、华为的FusionSphere都是这种模式。
混合虚拟化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa9c8fe0337fdaa645429382eabb68a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a434b4ebd559f4613370364ada30110f/" rel="bookmark">
			2023Tensorflow机器学习（Tensorflow-gpu安装版）纯window 不需要配置WSL，极简安装，AI必备工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 在大数据集情况下，CPU 版本无法进行加速运算，计算速度对比GPU版本相对缓慢。但在小数据集的情况下CPU和GPU的性能差别不大。CPU 版本暂可用作学习，如为了学习模型算法，数据集不大，使用 CPU 版本也能勉强应付。待日后对深度学习有了一定了解再升级 GPU 也未尝不可。
1、了解自己的机器配置
2、找到适合自己的Tensorflow版本
3、搭建Tensorflow环境
二、了解自己的机器配置 1.查看自己电脑是否支持使用GPU 请在命令提示行(cmd)输入以下命令查询：
nvidia-smi 请确认一下您的英伟达显卡是否支持CUDA 11.2版本。（只要您的显卡不是太老，应该是支持的。）
请注意本教程必须是11.2版本，因为PyPI和构建版本都是基于它的。
我的是RTX3050Ti，因为看到了最高支持版本可以达到CUDA 12.0就进行安装了CUDA 12.0，导致Tensorflow无法调用GPU。（如果你已经安装了CUDA 12.0或者其他不适配的版本，也不要着急搜一份如何卸载干净CUDA的教程，让CUDA可以再次安装）
至于CUDA 12.0能不能用，答案是可以的，只不过相对应的环境配置就较为麻烦，Windows10和11的用户如果安装了CUDA 12.0并且想使用Tensorflow，那必须要在WSL2的基础上进行环境搭建。（ Tensorflow不同版本和相应的构建所需要的python，Compiler，Build tools，cuDNN，CUDA版本都是要对应的上的）
如图所示，Tensorflow在2.10版本之后就不再支持，本教程只负责不需要WSL功能的Tensorflow2.10版本。
2.检查 如果你已经安装好了，可以看一下是不是支持GPU的版本（既然都看教程了，那大概率不是）
# 我们使用tf.test.is_built_with_cuda()查一下是不是支持cuda，因为一般就是用英伟达的显卡所以查一下cuda就可以 # Returns whether TensorFlow was built with CUDA (GPU) support. tf.test.is_built_with_cuda() # 如果是其他的可能的GPU支持，用一下命令？但是不在我们讨论范围内。 # Returns whether TensorFlow was built with GPU (CUDA or ROCm) support. tf.test.is_built_with_gpu_support() # 如果tf.test.is_built_with_cuda()返回True # 测试一下是否有显卡 # 如果tf.config.list_physical_devices()会返回可用的CPU和GPU tf.config.list_physical_devices('GPU') # 如果有返回应该就是已经再用GPU训练了。 # 部分教程使用的是tf.test.is_gpu_available()，目前还可以使用，但是未来回移除 tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a434b4ebd559f4613370364ada30110f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a45510c4b31e9a8b59f68069c977a4c5/" rel="bookmark">
			OpenHarmony关系型数据库查询结果呈现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 ResultSet(结果集) ResultSet(结果集)是OpenHarmony关系型数据库提供查询数据表返回结果的方法，提供了多种灵活的数据访问方式，以便于开发者获取各项数据，ResultSet属性如表1-1所示，ResultSet方法如表1-2所示。
表1-1 ResultSet属性
名称类型必填说明columnNamesArray&lt;string&gt;是结果集中所有列的名称columnCountnumber是结果集中的列数rowCountnumber是结果集中的行数rowIndexnumber是结果集当前行的索引isAtFirstRowboolean是结果集是否位于第一行isAtLastRowboolean是结果集是否位于最后一行isEndedboolean是结果集是否位于最后一行之后isStartedboolean是指针是否移动过isClosedboolean是当前结果集是否关闭 表1-2 ResultSet方法
名称描述getColumnIndex(columnName: string): number根据指定的列名获取列索引
columnName: 结果集中指定列的名称
number: 返回指定列的索引getColumnName(columnIndex: number): string根据指定的列索引获取列名
columnIndex: 结果集中指定列的索引
string: 返回指定列的名称goTo(offset: number): boolean向前或向后转至结果集的指定行，相对于当前行位置偏移
offset: 表示相对于当前行位置偏移量
boolean：操作成功，则为true，否则为falsegoToRow(position: number): boolean转到结果集的指定行
position: 表示要移动到的指定位置
boolean: 操作成功，则为true，否则为falsegoToFirstRow(): boolean转到结果集的第一行
boolean: 操作成功，则为true，否则为falsegoToLastRow(): boolean转到结果集的最后一行
boolean: 操作成功，则为true，否则为falsegoToNextRow(): boolean转到结果集的下一行
boolean: 操作成功，则为true，否则为falsegoToPreviousRow(): boolean转到结果集上一行
boolean: 操作成功，则为true，否则为falsegetBlob(columnIndex: number): Uint8Array以字节数组的形式获取当前行中指定列的值
指定的列索引，从0开始
Uint8Array: 以字节数组的形式返回指定列的值getString(columnIndex: number): string以字符串形式获取当前行中指定列的值
columnIndex: 指定的列索引，从0开始
string: 以字符串形式返回指定列的值getLong(columnIndex: number): number以Long形式获取当前行中指定列的值
columnIndex: 指定的列索引，从0开始
number: 以Long形式返回指定列的值。该接口支持的数据范围是：Number.MIN_SAFE_INTEGER~Number.MAX_SAFE_INTEGER，若超出该范围，则建议使用getDoublegetDouble(columnIndex: number): number以double形式获取当前行中指定列的值
columnIndex: 指定的列索引，从0开始
number: 以double形式返回指定列的值isColumnNull(columnIndex: number): boolean检查当前行中指定列的值是否为null
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a45510c4b31e9a8b59f68069c977a4c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64a3732aed670ef6748f6e70532e9ce9/" rel="bookmark">
			松灵学院 | 在松灵 LIMO 上使用 Docker 进行 ROS2 开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		截至目前，Jetson Nano 平台官方仍不提供 Ubuntu 20.04 固件，所以使用 Jetson Nano 平台开发 ROS2 存在巨大的困难，但是好在 Docker 提供的容器技术，让我们能非常方便的虚拟出一个 Ubuntu 20.04 环境进行 ROS2 开发并通过云端快速分享自己的开发环境，本文我将以松灵 LIMO 为例向大家演示如何使用 Docker 进行 ROS2 开发以及这种开发模式的优越性。
此外，在 ROS 开发过程中（尤其是在多人团队协同中）你一定遇到过这样的问题：需要快速（在不同架构机器上）部署相同开发环境、别人电脑上可以编译但到了自己这里就会报错、无法复现别人的 Bug、经常会出现缺少支持库或者支持库冲突的情况，尤其是一台电脑上需要做多种任务的情况（比如 深度学习、QT 开发、ROS1、ROS2）则会更糟糕…… 这个时候我们就有必要使用 Docker 进行开发
本文分为两部分，1-6节讲解 使用 Docker+VSCode 开发方式，7 节将带领大家在 LIMO 平台进行实战
无论您之前使用什么样的方式进行开发，笔者在这里都推荐您尝试 Docker + VSCode，虽然这可能需要两三个下午的时间进行学习，但请相信这一切都是值得的！
如果您不会使用 docker 或者没有尝试过类似的操作，请您先阅读 《Docker 配合 VSC 开发最佳实践》(https://anthonysun256.github.io/docker-with-vsc_best-practice/)
1. 镜像选取
Docker 官方镜像服务器上有很多的 ROS 开发镜像，这里我们可以有如下选择（这几个镜像也是笔者常用的）：
• ROS 官方镜像：https://hub.docker.com/_/ros 内含所有 ROS 发行版的基础开发镜像，而且支持多种架构，非常适合在多种架构的机器上进行部署。
• althack 的开发镜像 https://hub.docker.com/u/althack
althack 提供了 VSCode 的开发工作环境模板：https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64a3732aed670ef6748f6e70532e9ce9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f62ff2bbb76d118859ace793460e981/" rel="bookmark">
			Android Studio报错：Error:Could not find com.android.tools.build:gradle:4.1 记一次不长记性的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文地址：https://blog.csdn.net/zengsidou/article/details/79797417
看字面意思，这个问题是Gradle没有对应版本。在搜索引擎没有找到方法之后，尝试自己解决。
有一点很重要，先保证自己的Android Studio是最新的稳定版本！ 因为版本更新会修复很多bug，说不定遇到报错就是某个bug引起的。
Could not find com.android.tools.build:gradle:3.0.0.
首先，看报错，大概是长这样的：
Error:Could not find com.android.tools.build:gradle:4.1. Searched in
the following locations:
file:/C:/Program Files/Android/Android Studio/gradle/m2repository/com/android/tools/build/gradle/4.1/gradle-4.1.pom
file:/C:/Program Files/Android/Android Studio/gradle/m2repository/com/android/tools/build/gradle/4.1/gradle-4.1.jar
https://repo1.maven.org/maven2/com/android/tools/build/gradle/4.1/gradle-4.1.pom
https://repo1.maven.org/maven2/com/android/tools/build/gradle/4.1/gradle-4.1.jar
https://littlefogcat.top/example/com/android/tools/build/gradle/4.1
看看C:\Program Files\Android\Android Studio\gradle\m2repository\com\android\tools\build\gradle这个文件夹里面有没有4.1这玩意儿呢？果然没有。
再看看https://repo1.maven.org/maven2/com/android/tools/build/gradle/这个网址里面有没有4.1这玩意儿呢？果然也没有。
这下就知道了，报错里写的没有，这是真没有。可是我明明记得gradle已经更新到4.x了啊？怎么可能没有呢？这不是坑爹吗？先不管原因了，目前重要的是找到解决方案。
首先看gradle-wrapper.properties这个文件里面的内容。
最后一行：distributionUrl=https\://services.gradle.org/distributions/gradle-4.4-all.zip
进入https://services.gradle.org/distributions/这个网址，最新的已经到了4.6了，这里写的4.4应该没什么问题嗯。
再看一下C:\Program Files\Android\Android Studio\gradle\m2repository\com\android\tools\build\gradle这个目录，下面有什么呢？
可以看到，有2.2.0、2.3.2、3.0.1三个子文件夹。既然报错说没有4.1，那就先用已经有的吧！
打开项目build.gradle，将其中的classpath 'com.android.tools.build:gradle:4.1'改为classpath 'com.android.tools.build:gradle:3.0.1'，然后重新同步。 好了，经过或长或短的一段时间，现在Android Studio已经恢复正常了！可喜可贺。但是，作为一个不折腾不舒服的人，怎么能满足只使用3.0.1呢？最新的不都是4.6了吗？
这时候，灵光一现，仿佛是被一道闪电劈中，忽而间想起曾经明明就搜索过类似的问题啊！
build.gradle里的版本和gradle-wrapper.properties里面的版本根本就不是一个玩意儿！
结论 build.gralde里的classpath 'com.android.tools.build:gradle:3.0.1'指的是Android Studio的gradle插件版本，而gradle-wrapper.properties里的distributionUrl=https\://services.gradle.org/distributions/gradle-4.4-all.zip才是指定的gradle版本！
Gradle是开源的自动化构建工具，而Gradle插件是google开发的在Android Studio中使用Gradle的插件。
所以现在Gradle插件最新的版本只到3.1.0，并没有4.1！所以他是真的没有！真的没有！
谨以此文献给我走丢多年的记性。（手动微笑）
PS：如果更改了gradle版本之后，很可能遇到一直停留在refreshing gradle project上面，这有可能是正在下载distributionUrl=https\://services.gradle.org/distributions/gradle-4.4-all.zip这里定义的压缩包。如果很久都没有下完，可以到C:\Users\xxx\.gradle\wrapper\dists这个文件夹下面看对应版本的gradle文件是否在下载。一般来讲，下载是以龟速前行，慢慢等就行了。如果发现文件夹下面的文件一直是0kb，可以到https://services.gradle.org/distributions手动下载文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6815bcc03aa5212ad56d274628b2116e/" rel="bookmark">
			5 FFmpeg从入门到精通-FFmpeg流媒体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 FFmpeg从入门到精通-FFmpeg简介
2 FFmpeg从入门到精通-FFmpeg工具使用基础
3 FFmpeg从入门到精通-FFmpeg转封装
4 FFmpeg从入门到精通-FFmpeg转码
5 FFmpeg从入门到精通-FFmpeg流媒体
6 FFmpeg从入门到精通-FFmpeg滤镜使用
7 FFmpeg从入门到精通-FFmpeg中Linux设备操作
8 FFmpeg从入门到精通-FFmpeg接口libavformat的使用
9 FFmpeg从入门到精通-FFmpeg接口libavcodec的使用
10 FFmpeg从入门到精通-FFmpeg接口libavfilter的使用
文章目录 5.FFmpeg流媒体 5.1 FFmpeg发布与录制RTMP流 5.1.1 RTMP参数说明 5.1.2 RTMP参数举例 1.rtmp_app参数 2.rtmp_playpath参数 3.rtmp_pageurl、rtmp_swfurl、rtmp_tcurl参数 5.2 FFmpeg录制RTSP流 5.2.1 RTSP参数说明 5.2.2 RTSP参数使用举例 1.TCP方式录制RTSP直播流 2.User-Agent设置参数 5.3 FFmpeg录制HTTP流 5.3.1 HTTP参数说明 5.3.2 HTTP参数使用举例 1.seekable参数举例 2.headers参数举例 3.user_agent参数设置 5.3.3 HTTP拉流录制 5.3.4 拉取HTTP中的流录制FLV 5.4 FFmpeg录制和发布UDP/TCP流 5.4.1 TCP与UDP参数说明 5.4.2 TCP参数使用举例 1.TCP监听接收流 2.TCP请求发布流 3.监听端口超时listen_timeout 4.TCP拉流超时参数timeout 5.TCP传输buffer大小设置send_buffer_size/recv_buffer_size 6.绑定本地UDP端口localport 5.4.3 TCP/UDP使用小结 5.5 FFmpeg推多路流 5.5.1 管道方式输出多路流 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6815bcc03aa5212ad56d274628b2116e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaa2abd794b2622aa48643588dd9a53d/" rel="bookmark">
			visual studio native c&#43;&#43;单元测试及输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单元测试项目，可通过引导对话框创建，在创建常规项目的对话框中，搜索Test，一分钟后，会出现搜索结果，选中其中的 native test，创建单元测试项目。
创建完成后，自动生成模板代码，照着写即可。
默认的代码生成方式为动态生成，可切换。可以像常规项目那样引入各种静态库、设置临时文件目录以及输出目录等，最终生成的是一个dll文件，不能直接运行，需要在单元测试列表中运行，或者可以右击代码-&gt;run tests。
不要在链接器的设置页面修改输出目录，否则，如果link输出目录与项目输出目录不匹配，运行单元测试会找不到生成的dll，而且没有错误信息。
单元测试输出信息：
Logger::WriteMessage(L"123"); 打印到输出窗口。快捷键alt+2。不过，每次运行，输出窗口都会自动切换至build信息，每次都需要手动切换回Tests信息，很麻烦。
至于测试列表窗口，每次都会自动弹出，遮挡界面。建议这样摆放，列表窗口会调整布局为上下布局，看来这个2B界面也不是太蠢：
更新一下，之前升级过visual studio 2020，然后又降回2019，结果测试不跑了，发现是宏出现错误。把项目属性，c++额外包含目录、link包含目录中的宏$(VSInstallDir)UnitTest
替换为：
C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Auxiliary\VS\UnitTest\include;即可。
UnitTest\include 这个目录还是我用 everything 搜索出来的，这……
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb07b25273ebb00227a367fde2ae7e30/" rel="bookmark">
			flink 修改total task slot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 conf/flink-conf.yaml
taskmanager.numberOfTaskSlots: 3 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87f9ac234d87b1700eca7abed274726f/" rel="bookmark">
			Didn‘t find class “androidx.core.app.CoreComponentFactory“核心库中类加载失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发过程中遇到一个问题，是Bugly上报的崩溃，应用首次安装第一次打开时出现崩溃，日志大致信息报错如下：
03-24 14:20:58.443 13845 13845 E LoadedApk: Unable to instantiate appComponentFactory 03-24 14:20:58.443 13845 13845 E LoadedApk: java.lang.ClassNotFoundException: Didn't find class "androidx.core.app.CoreComponentFactory" on path: DexPathList[[zip file "/data/app/*******-9uPTAyghm4ueO6sJsBeCgA==/base.apk"],nativeLibraryDirectories=[/data/app/*******-9uPTAyghm4ueO6sJsBeCgA==/lib/arm64, /data/app/*******-9uPTAyghm4ueO6sJsBeCgA==/base.apk!/lib/arm64-v8a, /system/lib64]] 03-24 14:20:58.443 13845 13845 E LoadedApk: at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:134) 03-24 14:20:58.443 13845 13845 E LoadedApk: at java.lang.ClassLoader.loadClass(ClassLoader.java:379) 03-24 14:20:58.443 13845 13845 E LoadedApk: at java.lang.ClassLoader.loadClass(ClassLoader.java:312) 03-24 14:20:58.443 13845 13845 E LoadedApk: at android.app.LoadedApk.createAppFactory(LoadedApk.java:226) 分析报错日志，我们可以看到是核心库加载失败，由BaseDexClassLoader抛出异常,这里我贴出BaseDexClassLoader#findClass(String name)方法的源码，感兴趣的可以看看。
@Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { // First, check whether the class is present in our shared libraries.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87f9ac234d87b1700eca7abed274726f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3d66b43d4a7ed626d59d7aaae82094b/" rel="bookmark">
			C语言编程题|求一组数正负数或奇偶数的个数和平均值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		求一组数正负数或奇偶数的个数和平均值
对于该题，明确要输入的东西和输出的东西
输入：一组数（可用循环来输入数字，存储在一维数组中），所以要创建一维数组a[10]
输出：正数的个数（变量z)，负数的个数（变量f）,奇数的个数（变量j），偶数的个数（变量o），正负数的平均值（变量s1），奇偶数的平均值（变量s）
代码：
#include &lt;stdio.h&gt; //求一组数正负数或奇偶数的个数和平均值 int fun(int a[], int n) { int i, z = 0, f = 0, j = 0, o = 0; float s1 = 0, s = 0; for (i = 0; i &lt; n; i++) { if (a[i] &gt; 0) { z++; s1 += a[i]; } else if (a[i] &lt; 0) { f++; s1 += a[i]; } if (a[i] % 2 == 0) { o++; s += a[i]; } else { j++; s += a[i]; } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3d66b43d4a7ed626d59d7aaae82094b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b160ef4396acb35e214947025672f74c/" rel="bookmark">
			Mybatis&#43;Mysql 实现向下递归查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 说到递归查询，大家可以想到的技术实现方式主要如下几种：
1、各种主流应用开发语言本身通过算法实现
2、各种数据库引擎自身提供的算法实现
本文提到主要是针对第二种和第一种的结合
主要技术栈 1、ORM：Mybatis
2、DB：MySQL
3、开发语言：Java
代码实现示例 方式一、Mybatis Mapper类实现代码示例如下 // dept_employee 员工和部门的关系表 // dept 部门信息表 // 根据员工编号查询其直属部门的所有下级部门节点 @Select({"&lt;script&gt;", "with recursive child_dept as\n" + "(\n" + "select id, code,name,name as dept_structure\n" + "from dept\n" + "where id in (\n" + "select DISTINCT dept_id from dept_employee\n" + "where employee_id= #{employeeId} " + "&lt;when test='type!=null'&gt;", "and type=#{type}\n" + "&lt;/when&gt;"+ ")\n" + "union\n" + "select a.id,a.code ,a.name, concat(b.dept_structure, ' &gt; ', a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b160ef4396acb35e214947025672f74c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba43b44554e8f15eef76efb88f7bd9b4/" rel="bookmark">
			初识C&#43;&#43;（C&#43;&#43;入门）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 命名空间流插入与流提取缺省参数函数重载C++是怎样做到函数重载的？ 引用引用特性1.一个变量可以有多个引用2.引用变量在定义时必须初始化3.引用变量一旦引用了一个实体，便不能再引用其他实体4.引用权限只能缩小不能放大 引用使用场景作为函数参数作为函数返回值传值与传引用效率对比 重点+细节点：引用产生的临时变量 内联函数内联特性 auto关键字auto的细节点auto与指针和引用一起使用在同一行声明多个变量auto不能使用的场景auto的使用：范围for nullptr关键字为何在C++中使用nullptr而非NULL 命名空间 写C++的程序时，通常在程序的开头会写上这两行代码
#include &lt;iostream&gt; using namesapce std; 而为什么要写using namespace std;这行代码？namespace是c++的命名空间，std是命名空间的名字，是库中的一个标准命名空间，里面包含了iostream头文件中的所有函数定义。
c程序中，定义函数基本都是定义全局函数，这样做会存在命名重复，导致命名冲突和名字污染。c++为解决这个问题引入了命名空间的概念，命名空间能改变变量和函数的作用域，这样即使名称相同，作用域不一样，调用的对象便是不一样的。
而命名空间能自己定义
这样就创建一个N1的命名空间。
1.命名空间可以定义变量，能对变量赋值，也能定义函数
2.命名空间可以嵌套
3.两个命名空间名称相同时，最后会合并成一个命名空间
如何使用命名空间？
一种是：可以像经常写的using namesapce std;一样，using namespace + 命名空间的名称，这样就能使用这个空间里的所有变量与函数，使用方便了，但同时也会有命名冲突的问题。
不用using namespace + 命名空间的名称的话：可以在变量前加上::作用域限定符，例如要使用N1命名空间中的b变量，就写N1::b，使用不方便了，但这样写使得命名冲突的概率减小
using namespace N1;// 将N1命名空间的所有变量和函数全放出来 using N1::b; // 只放N1命名空间中的b，减小命名冲突的概率 流插入与流提取 c++使用cout流插入运算符，cin流提取运算符，输入与输出变量时不用加上像c语言一样的格式限定符%d,%s…但在使用时要加上iostream这个头文件，因为cin和cout是定义在这个头文件中的
缺省参数 调用函数时，若不给定函数参数，函数会使用默认的参数。默认参数是在定义时就指定的，下面的代码是定义一个有缺省参数的函数
void Func(int a = 10) { cout &lt;&lt; a &lt;&lt; endl; } 调用该函数时，不给变量a时，函数默认打印10，若给了a打印的是a的值。
应用场景
void StackInit(Stack* st, int n = 4) { st-&gt;data = (int*)malloc(sizeof(int) * n); st-&gt;size = 0; st-&gt;capacity = n; } int main() { Stack st; StackInit(&amp;st, 10); return 0; } 之前写的栈有一个栈初始化的函数，可以给该函数两个参数，一个是栈的地址，一个是要初始化的空间大小n，若初始化时不给n的值，函数默认开辟4个int大小空间给栈空间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba43b44554e8f15eef76efb88f7bd9b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dbdbc3f6a8578625172b98e46e655c4/" rel="bookmark">
			Windows Jar包开机自启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows Jar包开机自启动 原文地址: https://blog.csdn.net/weixin_46724181/article/details/122598733
一.实现方式 bat脚本来实现批处理，放到windows开机目录下,就可以实现jar包开机自启动。 二.实践 a.单个Jar包服务 1.在jar包目录新建一个start.bat 文件，然后写入启动命令
jar -jar XXXX.jar 2.仍然在此目录，新建start.vbs 文件，然后写入一下命令，命令最后一个0是隐藏窗口运行
createobject("wscript.shell").run"D:\start.bat",0 3.创建run.vbs的快捷方式，移动到开机自启动目录下：
C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup 重启就好了~
b.多个Jar包服务（比如SpringCloud） 只需要更改.bat文件里面的命令即可~
列如：
@echo off start java -jar C:\Users\Lenovo\Desktop\fsdownload\registry.jar TIMEOUT /T 40 start java -jar C:\Users\Lenovo\Desktop\fsdownload\auth.jar TIMEOUT /T 40 start java -jar C:\Users\Lenovo\Desktop\fsdownload\gate-way.jar TIMEOUT /T 40 start java -jar C:\Users\Lenovo\Desktop\fsdownload\chart-visual.jar pause 命令解释：
TIMEOUT /T 40 等待40秒 start java -jar C:\Users\Lenovo\Desktop\fsdownload\registry.jar 启动指定jar包 pause 拦截窗口自动关闭 JAR包CMD窗口后台运行和打印日志： start javaw -Xms512m -Xmx1024m -XX:PermSize=256m -XX:MaxPermSize=512m -XX:MaxNewSize=512m -jar C:\Users\Lenovo\Desktop\fsdownload\registry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dbdbc3f6a8578625172b98e46e655c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8b72f43a0bee59a7329631450429496/" rel="bookmark">
			Android 11 定制系统全局监听触摸事件接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.定义创建aidl接口（由于需要回调这里优先需要增加一个回调接口 ）
frameworks\base\core\java\android\app\IOnTouchListener.aidl
package android.app;
oneway interface IOnTouchListener {
void onTouchEvent( int action);
} 2.新增调用接口 在 base/core/java/android/view/IWindowManager.aidl
修改如下：
import android.app.IOnTouchListener;
...
void registerIOnTouchListener(IOnTouchListener touchListener);
void unregisterIOnTouchListener();
3.剩下就是在frameworks\base\services\core\java\com\android\server\wm\WindowManagerService.java
中修改 也是最重要的一步 新增两个实现方法 ：
@Override
public void registerIOnTouchListener(IOnTouchListener touchListener ){
this.touchListener = touchListener ;
pointerEventListener = new PointerEventListener() {
@Override
public void onPointerEvent(MotionEvent motionEvent) {
if (ydTouchListener != null){
try{
touchListener .onTouchEvent(motionEvent.getAction());
}catch(RemoteException e){
Slog.e(TAG, "RemoteException: onTouchEvent " );
}
} }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8b72f43a0bee59a7329631450429496/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b48cc821dffc3515724e9da8c566ba4d/" rel="bookmark">
			Javascript如何实现对象扁平化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组扁平化相信大家已经耳熟能详了，在被面试官问到如何实现数组扁平化你就偷着乐吧，但是相信有不少大佬在面试一些国内顶尖的大厂时，被面试官问到如何实现对象扁平化，笔者在学习过程中对此也感兴趣，让我们一起看看如何实现对象扁平化吧
例题详情 // 实现一个 flatten 函数，实现如下的转换功能 const obj = { a: 1, b: [1, 2, { c: true }], c: { e: 2, f: 3 }, g: null, }; // 转化为扁平化之后的对象 let objRes = { a: 1, "b[0]": 1, "b[1]": 2, "b[2].c": true, "c.e": 2, "c.f": 3, g: null, }; 复制代码 扁平化 扁平化概念的核心意义是：去除冗余、厚重和繁杂的装饰效果。而具体表现在去掉了多余的透视、纹理、渐变以及能做出3D效果的元素，这样可以让“信息”本身重新作为核心被凸显出来。同时在设计元素上，则强调了抽象、极简和符号化。
对象实现扁平化，从需要转化的结果可以看出，我们需要对整个对象进行遍历，对象里面嵌套对象或者数组都需要扁平化，将嵌套的内层对象的属性值依次输出。
我认为本题的核心就在于传入对象的 key 和 value，对value进行递归遍历，找到所有嵌套的属性值。
代码实现 function flattenObj(obj) { let res = {} for (let key in obj) { if (typeof obj[key] === 'object' &amp;&amp; obj[key] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b48cc821dffc3515724e9da8c566ba4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e01811f04d39773b9f63ae3e83aea53/" rel="bookmark">
			【Linux】gdb常用基础命令入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装gdb：yum install gdb
2、检查是否安装成功：gdb --version
示例：vi book.cpp
g++ -g -o book book.cpp //添加-g才能gdb调试
./book //执行book可执行文件
//book.cpp
#include &lt;stdio.h&gt;
int main()
{
int arr[4]={1,2,3,4};
for(int i=0;i&lt;4;i++)
{
printf("%d\n",arr[i]);
}
printf("\n");
return 0;
}
3、gdb ./book进入gdb调试
4、r（run）命令运行程序
5、quit命令退出gdb调试
6、再次进入gdb调试、list命令查看源代码(一次显示10行，enter继续查看)
7、b（break）命令打断点
7.1、b 函数名（b main：在main函数处打断点）
7.2、b 数字（b 9：在第九行打了一个断点），可配合list命令
7.3、info b：查看打断点位置信息（下图在5，9行打了断点）
7.4、r开始运行程序，停止在第一个断点（第5行）处。n（next）命令继续运行到下一位置
8、p（print）打印变量的值或者地址
9、示例2：cp book.cpp book1.cpp
//book1.cpp
10、s（step）命令进去某一个具体的函数，如下在hlleo函数处打断点，s命令进入hello函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48334b2436f3ad29c824dc63fb59f92d/" rel="bookmark">
			Ubuntu开启SSH免密登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu开启SSH免密登录
要实现SSH免密登录，首先需要准备一组公钥和私钥。将公钥放到服务器上，将私钥放到客户机上。当客户机连接服务器时，服务器会根据自身的公钥校验客户机的私钥，如果校验通过则允许连接。
一、创建密钥 在客户机上输入以下命令创建一组公钥和私钥
ssh-keygen 密钥生成位置：默认会将密钥生成到当前登录用户的主目录下的.ssh文件夹中，如：/home/master/.ssh，建议使用默认位置，以便后续操作私钥密码：默认无密码，如果设置了私钥密码，在进行免密登录时需要输入私钥密码确认私钥密码：默认无密码 命令执行成功后将会在指定位置生成密钥
左边的id_rsa为私钥，需要留在客户机。建议保持其默认存放位置和默认文件名，在SSH连接时会自动使用，如果存放到其他位置或修改为其他文件名，在SSH连接时需要手动指定私钥位置。右边的的id_rsa.pub为公钥，需要上传到服务器。上传到需要进行免密登录的用户的主目录下的.ssh文件夹中，并且重命名为authorized_keys，如：/master/.ssh/authorized_keys。 二、上传公钥 在客户机上输入以下命令将公钥上传到服务器
ssh-copy-id master@ubuntu ssh-copy-id - 将公钥发送到远程主机指定账户下master - 要进行免密登录的远程主机账户，默认为本地主机当前登录账户ubuntu - 远程主机地址 如果修改了密钥的默认存放位置或默认文件名，需要使用-i参数手动指定密钥位置。
上传公钥时公钥与私钥必须位于同一目录下，并且公钥与私钥的文件名必须对应，如：私钥文件名为x，则公钥文件名为x.pub。
输入远程账户密码完成公钥上传
三、登录测试 在客户机上输入以下命令登录远程服务器
ssh master@ubuntu ssh - 远程登录master - 进行免密登录的远程主机账户，默认为本地主机当前登录账户ubuntu - 远程主机地址 连接服务器时，会发现在没有输入密码的情况下成功连接
私钥需要存放到当前登录用户的主目录下的.ssh文件夹中，并且设置文件名为id_rsa，如果私钥存放到其他位置或使用其他文件名，远程登陆时需要使用-i参数指定私钥位置。
如果为私钥设置了密码，远程登陆时需要输入私钥密码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cc3e10c40d69a3c569e7264cbe69150/" rel="bookmark">
			Java日期查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本实例使用有关日期处理和日期格式化的类实现一个日期查询的功能，即查询指定日期所在周的周一日期、两个指定日期间相差的天数和指定日期为所在周的星期几的日期 3 个功能。
从功能上来看，本实例至少需要定义 3 个方法，分别完成：获取指定日期所在周的周一日期、获取两个指定日期的相差天数以及获取指定日期为所在周的星期几的日期这 3 个功能，同时需要定义 Date 类型的日期与 String 类型之间的转换方法。
(1) 新建 Exercise 类，在该类中导入需要的包。代码如下：
import java.text.Parse Exception; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; public class Exercise { // 在该类中有5个方法，在下面的步骤中将会讲解，这里省略 } (2) 在 Exercise 类中定义获取指定日期所在周的周一日期的方法——getMonday()，该方法是一个静态方法，返回值为 String 类型，并且需要传递一个 Date 类型的参数，然后将该日期参数作为 Calendar 对象的日期，并调用 Calendar 类的 set(int field,int value)方法改变 Calendar 对象中的日期，再将使用 SimpleDateFormat 类格式化后的日期返回。
getMonday() 方法的代码实现如下：
// 获取指定日期所在周的周一日期 public static String getMonday(Date date) { Calendar c = Calendar.getInstance(); c.setTime(date); c.set(Calendar.DAY_OF_WEEK,Calendar.MONDAY); return new SimpleDateFormat("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cc3e10c40d69a3c569e7264cbe69150/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7a5cf50ddd9f435fe21f2202760724f/" rel="bookmark">
			（八）简单数论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.模运算
模运算是大数运算中的常用操作，如果一个数太大无法直接输出，或者不需要直接输出，就可以取模后再输出。
刷题统计
2.快速幂
幂运算a^n，当n很大时一个个乘很慢，复杂度O(n)，可以用快速幂在O(logn)时间内算出来。
基于位运算的快速幂，原理是倍增。
例题：
RSA解密
3.GCD最大公约数
手写gcd（辗转相除法）
4.LCM最小公倍数
手写lcm()
核桃的数量
Hankson的趣味题 最大比例
复习完贪心做 寻找整数
方法一：模拟
由a=11和a=17可知，该数是11和17的公倍数，但题目给定范围是10^17，步长为11*17去递增模拟还是太慢，需要找到一个较大的步长K，满足后面5个数（a=45,46,47,48,49）的n，从小到大的n1,n2,n3,…，它们是一个新的等差数列，可以令k=n3-n2=n2-n1，作为for循环的步长
注意：long的范围最大包含10的18次方
方法二：lcm
从表格的第一个条件开始，除以2余1的数有3，5，7，9…，步长k=2，
继续满足第二个条件，除以3余2的数只能从上一步的3,5,7,9…中找，有5，11，17…，此时步长k=6，实际6=lcm(2,3)。
同理，继续满足第三个条件，从上一步的5，11，17…找，此时步长k=lcm(2，3，4)，
继续满足第四个条件……
因此需要对表格中的2~49做48次LCM。
写的时候犯了个错，22行代码放在了17行，这样做会少判断每行数列的第一个，需要注意。
5.素数的判断
选数
最大最小公倍数
看完贪心后回来看
6.素数筛
素数的筛选：给定n，求2~n内梭有的素数。
常用两种方法：埃氏筛，欧拉筛。
埃氏筛：
质数
7.分解质因子
很多题目建模需要和整数的因子有关，需要求整数因子。
分解质因数
思路：用素数筛把素数筛出来，然后再分解质因子。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab3f8427edc29e9d9a202f43337900cd/" rel="bookmark">
			微信小程序实现 swiper 滑块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		swiper：滑块视图容器。其中只可放置 swiper-item 组件，否则会导致未定义的行为。
swiper 的默认高度是 height：150px，无法由内容自动撑开。
swiper-item：仅可放置在swiper组件中，宽高自动设置为100%。
基础用法： &lt;!-- index.wxml --&gt; &lt;swiper indicator-dots indicator-active-color="#FFFFFF"&gt; &lt;swiper-item wx:for="{{swiperList}}" wx:key="index" class="swiper-item"&gt; {{item}} &lt;/swiper-item&gt; &lt;/swiper&gt; // index.js Page({ data : { swiperList: ['1', '2', '3', '4'], }, }) /* index.wxss */ .swiper-item { background-color: #FF4A2F; color: #FFFFFF; font-size: 48rpx; display: flex; align-items: center; justify-content: center; } 滑块项之间存在间距，且露出前后项的一部分： &lt;!-- index.wxml --&gt; // circular：采用衔接滑动；previous-margin：露出前一项的一小部分；next-margin：露出后一项的一小部分 &lt;swiper indicator-dots indicator-active-color="#FFFFFF" circular previous-margin="100rpx" next-margin="120rpx"&gt; &lt;swiper-item wx:for="{{swiperList}}" wx:key="index" class="swiper-item"&gt; &lt;view class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab3f8427edc29e9d9a202f43337900cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50ba7d7d354af432c7c70980de7d9775/" rel="bookmark">
			VUE中 [{…}, {…}, __ob__: Observer]的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在vue中当你往数组里push对象时，得到的那个数组(this.arr)就会变成这种形式 一开始你有点不解，为什么变成了这个样子 ，于是你尝试拿到对象里面的值，然后就成了这样
console.log(this.arr[0]) //undefined 此时网上有人说只需要用JSON.parse(JSON.stringify(this.arr)) 转一下就可以了，于是你兴致勃勃的去尝试了，但是得到的确是
竟然变成了空数组，你这时需要的不是数组里有值，而是人工呼吸，血压飙升，于是你又在想，这情况是不是和异步同步有关，之前的代码都是在异步代码里写的。所以你又尝试写在同步代码块里
function() { let arr=JSON.parse(JSON.stringify(this.StoreArr)) console.log(arr) }, 此时你发现数组是正常的了，即使你把数组赋值给data，也能正常拿到值了。
总结，遇到上面这种情况的数组时，需要用JSON.parse(JSON.stringify(this.arr))转译，并且一定要在同步的代码块中执行（重要），很多人都没说清楚，导致我不断试错了一上午，血压飙升！！！！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/498c7bd8939fa44311983b710d168efc/" rel="bookmark">
			vite&#43;ts&#43;vue3 知识点（vite-plugin-components插件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vite-plugin-components可以实现组件库或内部组件的自动按需引入组件,而不需要手动的进行 import ,可以帮我们省去不少 import的代码 安装 npm add unplugin-vue-components -D 配置 import { defineConfig } from "vite"; import { fileURLToPath, URL } from "url"; import vue from "@vitejs/plugin-vue"; import Components from "unplugin-vue-components/vite"; // AntDesignVue 库 import { AntDesignVueResolver } from "unplugin-vue-components/resolvers"; // https://vitejs.dev/config/ export default defineConfig({ plugins: [ vue(), Components({ resolvers: [AntDesignVueResolver()], }), ], }); 此时使用组件就不需要在 import 引入了 &lt;template&gt; &lt;div&gt; &lt;A&gt;&lt;/A&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup lang="ts"&gt; &lt;/script&gt; &lt;style scoped lang="less"&gt; &lt;/style&gt; 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/160/">«</a>
	<span class="pagination__item pagination__item--current">161/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/162/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>