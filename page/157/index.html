<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8cd6ff70075a0dc36abe9cfad713072/" rel="bookmark">
			PyPI--python软件仓储库安装Doris
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The Python Package Index (PyPI) is a repository of software for the Python programming language.
1、PyPI官网：https://pypi.org/
直接可搜到doris5.0.3，也可下载源码
2、pip用户手册：https://pip.pypa.io/en/stable/user_guide/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b051a019670df94df3b91adae247bdc6/" rel="bookmark">
			C语言__attribute__的运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在阅读内核源码时，常常可以看到类似于这样子的写法：
static char envval[256] __attribute__((aligned(8))); 即，在某一个结构体完成定义后，跟上一个__attribute__(xxx)，这是GNU C的一个特色机制，使用__attribute__可以用来设置函数属性、变量属性和类型属性。
__attribute__的书写特征是在attribute前后都有两个下划线且后面紧跟一对括弧，括弧中包含对应的参数：
__attribute__((attribute-list)) 关键字__attribute__可以对函数、变量、类型（包括结构体struct和共用体union）进行属性设置，在使用__attribute__参数时，可以在参数前后也加上双下划线__，效果是会在相应头文件里使用它而不用关心头文件里是否存在重名宏定义。
常见的attribute参数介绍
aligned
指定对象的对齐格式（字节单位），如：
struct S { short b[3]; } __attribute__ ((aligned (8))); typedef int int32_t __attribute__ ((aligned (8))); 该声明将强制编译器确保变量类型为Struct S或者int32_t的变量（成员）在分配空间时采用8字节对齐方式。
采用上述格式可以手动指定对齐格式，同样可以采用默认的对齐方式，不指定数字时，编译器将依据目标机器情况使用最大最有益的对齐方式：
struct S { short b[3]; } __attribute__ ((aligned)); 在上面的例子中，如果一个short大小为2字节，那么S的大小为6字节。取一个大于等于6的2次方值，则该值为8，编译器会将S类型设置为对齐方式8字节，可以看出aligned属性使被设置的对象占用更多空间。
attribute属性效力也受到连接器限制，如果机器最大只支持16字节对齐，设置32并不会有什么用。
下面继续使用一些小例子来观察__attribute__的作用：
struct p { int a; // 4字节 char b; // 1字节 short c; // 2字节 }__attribute__((aligned(4))) pp; // 按4对齐，|a |bc |，pp大小8字节 struct m { char a; // 1字节 int b; // 4字节 short c; // 2字节 }__attribute__((aligned(4))) mm; // 按4对齐，|a|b|c|，mm大小12字节 struct x { int a; // 4字节 char b; // 1字节 struct p px; // 8字节 short c; // 2字节 }__attribute__((aligned(8))) xx; // 按8对齐，|ab|px|c|， 24字节 对齐在N上的概念是指，某一变量的存放起始地址%N=0，编译器对齐原则：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b051a019670df94df3b91adae247bdc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/769060501a4848bbbd525c8f2f8dc8dd/" rel="bookmark">
			2015蓝桥杯省赛——垒骰子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		赌圣atm晚年迷恋上了垒骰子，就是把骰子一个垒在另一个上边，不能歪歪扭扭，要垒成方柱体。 经过长期观察，atm 发现了稳定骰子的奥秘：有些数字的面贴着会互相排斥！ 我们先来规范一下骰子：1 的对面是 4，2 的对面是 5，3 的对面是 6。 假设有 m 组互斥现象，每组中的那两个数字的面紧贴在一起，骰子就不能稳定的垒起来。 atm想计算一下有多少种不同的可能的垒骰子方式。 两种垒骰子方式相同，当且仅当这两种方式中对应高度的骰子的对应数字的朝向都相同。 由于方案数可能过多，请输出模 10^9 + 7 的结果。
不要小看了 atm 的骰子数量哦～
输入格式: 第一行两个整数 n m
n表示骰子数目 接下来 m 行，每行两个整数 a b ，表示 a 和 b 数字不能紧贴在一起。
输出格式: 一行一个数，表示答案模 10^9 + 7 的结果。
输入样例: 在这里给出一组输入。例如：
2 1 1 2 输出样例: 在这里给出相应的输出。例如：
544 解题思路：
我做这道题用的是DFS，由于运用不熟练，写代码的时候参考了一下 Lake Counting(POJ No.2386) 的代码。后来由于不会将HashMap作为全局变量来用（运行时抛出 java.lang.NullPointerException错误），我又改用C语言来写......一遍遍的改正后，最终还是写出来了！下面奉上代码：
Java
#include&lt;stdio.h&gt; #include&lt;math.h&gt; int n,m; int map1[7]={0,4,5,6,1,2,3},map2[7][7]={0}; static long long res=0; int mod=pow(10,9)+7; void dfs(int down,int level){//down为当前骰子的底面数字，level代表当前是第几层，范围是1~n if(level==n) res=(res+1)%mod;//之所以是+1而不是+4，是因为当前层上的骰子的朝向在上一层递归中已完全确定下来 else{ int up=map1[down]; for(int i=1;i&lt;=6;i++){//上方骰子底面 for(int j=1;j&lt;=6;j++){//上方骰子前面 if(j==i||j==map1[i])//前面不可能等于顶面或底面 continue; else{ if(map2[up][i]==0){//如果下方骰子顶面与上方骰子底面的数字不相克 dfs(i,level+1); } } } } } } int main(){ scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/769060501a4848bbbd525c8f2f8dc8dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97a86ed5bfb3785728133791da16e914/" rel="bookmark">
			一文理清---TSN时间敏感网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 时间敏感网络 什么是时间敏感网络TSN? 时间敏感网络（TSN，Time Sensitive Network）是指能够保证时延敏感流的服务质量，实现低时延、低抖动、和零丢包率的网络。
时间敏感网络演进 TSN是从传统以太网的基础上演变而来，实现可靠的数据传输，因此也是确定性网络的一种。
以太网技术诞生于 20 世纪 70 年代，从串行通信时代、传统以太网时代、实时以太网时代逐步进入确定网络时代，从同轴电缆慢慢发展成为千兆以太网。以太网是目前应用最普遍的局域网技术。
2005年，IEEE 802.1工作组创立了音视频桥接技术（Audio-Video Bridge,AVB）,为包括音视频行业在内的所有具有实时传输需要的应用指明了方向。该技术通过精确时钟同步、带宽预留、流量整形等措施，提升时间敏感业务流的服务质量。
为了将AVB应用于更多的领域，在2012年，IEEE 802.1工作组正式将AVB更名为TSN。此后TSN进行了一系列协议的扩展和标准化工作。TSN通过高精度时钟同步、带宽预留、流量整形、逐流过滤和帧抢占、时间感知调度、无缝冗余等技术，为时间敏感数据流的传输提供了超低的端到端时延和传输的确定性，成为未来实时通信的发展趋势。TSN对实时系统的广泛应用及发展提供重要的技术支持和驱动力，具有广阔的发展前景。TSN和AVB都是由一系列的协议标准组成的协议簇，每个协议实现不同的功能。
其中AVB标准包括：
IEEE 802.1AS：精准时钟同步协议（general Precision Time Protocol,gPTP）IEEE 802.1Qat：流预留协议（Stream Reservation Protocol，SRP）IEEE 802.1Qav：时间敏感流的转发和排队（Forwarding and Queuing Enhancements for Time Sensitive Streams,FQTSS）IEEE 802.1BA：音频视频桥接系统，定义AVB配置文件（AUdio Video Bridging Systems）
更名为TSN后，AVB对部分原标准进行了修订，同时新增了几个性能改进标准：IEEE 802.1ASbt：增强功能和性能改进，基于IEEE 802.1AS-2011修订定时和同步IEEE 802.1Qbu：新增协议，定义了帧抢占机制IEEE 802.1Qbv：新增协议，增强了计划流量的调度
TSN协议主要工作在数据链路层，他通过精确时钟同步、带宽预留、流量整形、帧抢占、门控制机制、循环队列转发、逐流过滤、无缝冗余等措施，为数据的传输提供确定性或者有界的端到端时延，强化了以太网的实时性能。
时间敏感网络关键技术 TSN 核心机制主要包括时钟同步、数据调度、网络配置和帧复制与消除：
TSN 中的所有设备首先要具有共同的时间参考模型，网络设备才能够一致操作，并在所需的时间点执行所需的操作，因此需要时钟同步机制保障所有网络设备的时钟保持同步。数据调度是保证时间敏感的基础，它的核心思想是基于不同的整形器进行不同应用场景的流控制，主要的整形器包括基于信用的整形器、时间感知的整形器、周期性排队与转发机制整形器和异步数据流整形器。网络配置是面向时间敏感网络应用，给出三种用户/网络配置模型，用户可根据实际应用需要选择不同的网络配置模型。帧复制和帧消除是为以太网提供无缝冗余特性，提高可靠性。
什么是调度整形机制？ 调度整形机制是交换机中的两种服务质量保障机制，调度是指队列调度，一般实现在交换机的出端口，包含进入队列、根据调度算法选择发送队列、出队传输三个部分；整形是指流量整形，通过限制端口的转发速率从而防止交换机内部或出现下一跳出现拥塞。
TSN怎样实现低时延？ 时延怎样产生的？ 链路传输时延交换机处理时延出端口排队时延 TSN怎样保证？ 链路时延和处理时延基本为固定值，所以减少时延必须要减少排队时延，即时延敏感网络的本质就是不排队：先通过优先级队列将时延敏感流和尽力而为流隔开，再从时间上（划分时隙）或空间上（规划路由）将同样的时延敏感流隔开。
实现低时延后，包在交换机里的停留时间很短，包的累积不会超过队列缓冲区大小，从而实现零丢包率；同时，抖动是指时延的变化差值，低时延降低了最坏时延，让时延上界靠近时延下界，减小了时延的变化区间，从而也实现了低抖动。
什么是配置时隙？ 传统的以太网采用“尽力而为”的转发，无法保证包的端到端最坏时延，时延敏感网络采用类似时分复用的方式，为每一个包配置时隙，保证其有足够的时间进行转发。
下面是三种基于时间的调度整形机制：
时间触发以太网（TTE）：把时间戳打在包上，通过时间表控制包的发送，让每个包自己知道自己的发送时间，在发包侧就将各个包的发送时间隔开，严格保证时延抖动满足要求。时间感知整形（TAS）：利用优先级门控队列，即在优先级队列后加上门控开关，通过门控时间表控制门控开关的打开闭合来保证时延抖动要求。其可以阻断尽力而为流的持续转发，让高优先级的包得到稳定的间隔转发时间，同时PTS流之间依然要将发包时间隔开，时延抖动保证效果才最好。比如每跳时延为T，共有n跳，则可保证端到端时延最大为nT。和TTE相比，让优先级队列决定包何时被转发，降低了对发端的要求，同时时延抖动保证粒度也会弱一些。循环排队转发（CQF）：把TAS里只用一个最高优先级队列来接收时延敏感流，变为用奇偶两个队列循环接收，即所谓的乒乓队列。其可以用于解决流聚合问题，如果两个PTS流同时到达了，必有一个PTS要等待转发，循环排队转发可以保证等待的流只等待前一个PTS流转发，即一个周期T，自己再转发一个周期T，假设共有n跳，则端到端时延可保证最大为2nT。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/403bdc2e1efe026bffb33b412a773b8b/" rel="bookmark">
			手把手教你使用 Python 制作贪吃蛇游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		贪吃蛇游戏是有史以来最受欢迎的街机游戏之一。在这个游戏中，玩家的主要目标是在不撞墙或不撞墙的情况下抓住最大数量的水果。在学习 Python 或 Pygame 时，可以将创建蛇游戏视为一项挑战。这是每个新手程序员都应该接受的最好的初学者友好项目之一。学习构建视频游戏是一种有趣而有趣的学习。
我们将使用Pygame来创建这个蛇游戏。Pygame是一个开源库，专为制作视频游戏而设计。它具有内置的图形和声音库。它也是初学者友好的和跨平台的。
🛬 安装 要安装 Pygame，您需要打开终端或命令提示符并输入以下命令：
pip install pygame 安装 Pygame 后，我们就可以创建我们很酷的蛇游戏了。
🛰 使用 Pygame 创建贪吃蛇游戏的分步方法： 💌 第 1 步：首先，我们正在导入必要的库。 之后，我们将定义游戏将在其中运行的窗口的宽度和高度。并以 RGB 格式定义我们将在游戏中用于显示文本的颜色。 # 导入库 import pygame import time import random snake_speed = 15 # 窗口大小 window_x = 720 window_y = 480 # 定义颜色 black = pygame.Color(0, 0, 0) white = pygame.Color(255, 255, 255) red = pygame.Color(255, 0, 0) green = pygame.Color(0, 255, 0) blue = pygame.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/403bdc2e1efe026bffb33b412a773b8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2001b0bc644cbfa92cfea33edf259e0b/" rel="bookmark">
			一篇文章解释各种Java工程的包名含义(持续更新)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在工作的时候经常遇到很多无法理解的包名，虽然看了源码知道要往里面放什么类型的代码，但还是不喜欢这样不清不楚的写代码，所以想整理出一些列包名解释，如有不正确的地方欢迎指正。
其实这些包名一般都跟相关概念挂钩，例如，Bean是Spring ioc容器管理的类，Servlet是Java web的组件等等..
所以下面在解释包名的时候也会附上相关的概念，也可以把该文章作为一个类似基础概念大纲的文章进行阅读。
Pojo : 普通的java类
Bean : Spring容器管理的类
Entity : 业务逻辑相关的类
Servlet : JavaWeb的组件，接收请求并响应，找到合适的Controller去处理
Controller : 解析字段，选择合适的Service去处理
Service : 纯业务处理逻辑
Filter : JavaWeb的组件，过滤器，对客户端过滤请求
Listener : JavaWeb的组件，监听器，负责对域对象的创建和属性变化进行监听
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f150c2aa997222d0feebc828572cfc3b/" rel="bookmark">
			实战脚本|批量检测域名是否能ping通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		免责声明：该公众号里面提供的所有攻防知识只用于授权目标攻击，如非法攻击，后果自负。
（脚本源码在文末）实战中常常遇到众多的子域名需要测试是否可用，此时如果是小白，不会子域名爆破，需要手动一个一个测试，但这样也太过于繁琐了。此时，一个批量ping 域名的脚本诞生了。
脚本原理：将收集到的域名保存在1.txt中，打开终端，进入到保存1.txt和脚本的路径，输入
python domain.py脚本跑起来，脚本自动会将ping通的域名保存在2.txt，ping不通的域名保存在3.txt。
1.txt域名格式如下图所示： ping通的域名保存在2.txt，如下图所示：
ping不通的域名保存在3.txt，如下图所示：
脚本源码：
import os # 定义文件名input_file = "1.txt"output_file1 = "2.txt"output_file2 = "3.txt" # 打开输入文件，读取域名列表with open(input_file, "r") as f: domains = [line.strip() for line in f] # 循环测试每个域名是否可达reachable_domains = []unreachable_domains = []for domain in domains: response = os.system("ping -c 1 " + domain) if response == 0: reachable_domains.append(domain) else: unreachable_domains.append(domain) # 将可达的域名写入输出文件1中with open(output_file1, "w") as f: f.write("\n".join(reachable_domains)) # 将不可达的域名写入输出文件2中with open(output_file2, "w") as f: f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f150c2aa997222d0feebc828572cfc3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d3d66020b1443cf4fc7889a974d0124/" rel="bookmark">
			nginx配置文件下载并且目录展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.windows
2.路径如D:/im-az/server/download
下面有各种文件
3.配置
location /download { root D:/im-az/server; autoindex on; # 开启目录浏览功能 autoindex_format html; #以html风格将目录展示在浏览器中 autoindex_exact_size off; #切换为 off 后，以可读的方式显示文件大小，单位为 KB、MB 或者 GB autoindex_localtime on; #以服务器的文件时间作为显示的时间 #符合条件，直接下载 if ($request_filename ~* ^.*?\.(txt|doc|pdf|rar|gz|zip|docx|exe|xlsx|ppt|pptx)$){ add_header Content-Disposition attachment; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3aee72485aee9ce4be345c9dba153be/" rel="bookmark">
			mysql双游标嵌套循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统要上线新功能，引入了BPMN流程引擎，引入该引擎后就会涉及到历史数据处理问题，因为系统已经生成了上千条业务数据，由于不是靠BPMN引擎流转的，所以需要将业务数据和流程引擎关联起来，有多少条在执行的业务数据，就生成多少条流程实例，我们的流程引擎使用的是activiti流程引擎框架；
其中一块的历史数据处理是要查询出符合条件的历史数据，然后遍历循环业务，业务数据中有个处理人的字段是多人的，要把这个多人的以逗号分隔开，有几人再次循环几次；
废话不多说，直接上代码：
delimiter // drop procedure if exists procedure_test; create procedure procedure_test() begin declare count_ int default 0; declare requirementCount_ int default 1; declare assigineeCount_ int default 1; declare result_ int default 0; declare startUserId_ int ; declare runTaskAssignee int ; declare businessMainDataId int; declare businessCode varchar(10); declare users varchar(250); declare process_serial_number int default 0; -- 创建游标1 declare cursor_test1 cursor for select o.commituserId,o.id,o.code from rp_original_requirement o where o.status = 1 and o.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3aee72485aee9ce4be345c9dba153be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9993b97dbdc443a890382167cfc72f77/" rel="bookmark">
			Vue导出当前页面为PDF文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载插件 npm install html2canvas --save npm install jspdf --save 创建导出函数文件htmlToPdf.js // 导出页面为PDF格式 import html2Canvas from 'html2canvas' import JsPDF from 'jspdf' export default { install(Vue, options) { Vue.prototype.getPdf = function (name, id) { let title = name || 'index' html2Canvas(document.querySelector(`#${id}`), { allowTaint: true, taintTest: false, useCORS: true, dpi: window.devicePixelRatio * 4, // 将分辨率提高到特定的DPI 提高四倍 scale: 4, // 按比例增加分辨率 logging: true // 可以长屏分页导出 }).then(function (canvas) { let contentWidth = canvas.width let contentHeight = canvas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9993b97dbdc443a890382167cfc72f77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3aa8dcaedcbaf4cd2a4dbb4be657887/" rel="bookmark">
			编译失败的原因是缺少javafx.util
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用javafx.util.Pair本地jdk1.8中存在
而
OpenJDK8中没有javafx.util
import javafx.util.Pair; ... Pair&lt;?, ?&gt; 所以编译时会报错
package javafx.util does not exist
解决方案：
不使用javafx.util中的Pair 换个包
比如：（其他包不列举）
import cn.hutool.core.lang.Pair;
其他解决方案不做阐述
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17d795057f0abd22f9dc3cb11b8c22dc/" rel="bookmark">
			FPGA基础学习——Verilog实现的边沿检测（上升沿下降沿检测）及Modelsim仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//学习笔记//
文章目录 1、什么是边沿检测 ？2、边沿检测的方法3、Verilog实现边沿检测4、上升沿、下降沿和数据沿是如何写出来的？5、亚稳态问题（多加一级寄存器来解决） 1、什么是边沿检测 ？ 检测输入信号或FPGA内部逻辑信号的跳变，即上升沿或者下降沿的检测。
2、边沿检测的方法 设置两个寄存器，对前一状态和后一状态进行寄存，若前后两个状态不同，则检测到了边沿。对于上升沿和下降沿的确定可以用组合逻辑比较来确定。若前一状态D[1]为高电平，后一状态D[0]为低电平，则为下降沿，反之为上升沿。
3、Verilog实现边沿检测 用Verilog实现的1bit信号边沿检测功能，输出一个周期宽度的脉冲信号。
module test( input clk, input rst_n, input data, output pos_edge, //上升沿 output neg_edge, //下降沿 output data_edge, //数据边沿 output reg [1:0] D ); //设置两个寄存器，实现前后电平状态的寄存 //相当于对dat_i 打两拍 always @(posedge clk or negedge rst_n)begin if(rst_n == 1'b0)begin D &lt;= 2'b00; end else begin D &lt;= {D[0], data}; //D[1]表示前一状态，D[0]表示后一状态（新数据） end end //组合逻辑进行边沿检测 assign pos_edge = ~D[1] &amp; D[0]; assign neg_edge = D[1] &amp; ~D[0]; assign data_edge = pos_edge | neg_edge; endmodule RTL图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17d795057f0abd22f9dc3cb11b8c22dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93a0fc2319285cc4e97330f2562dd476/" rel="bookmark">
			vscode ssh远程连接失败问题及解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 问题2. 解决更新vscode及插件版本更新服务器端版本插件放到服务器 修改.vscode-server默认目录参考链接 1. 问题 在用 VSCode 通过 Remote 插件，远程连接到开发服务器时，报错（无法连接）的处理过程。
一般是更新了vscode版本之后出现的，报错的种类有很多，但是只要是你之前能连接上，而最近连接不上了，那基本就是更新了vscode客户端版本，，而服务器没有对应更新版本导致。因为一般服务器都是内部的无法连外网。
2. 解决 更新vscode及插件版本 首先要更新vscode客户端到最新版。
然后对应的remote ssh插件，也要更新到最新版，不然可能不兼容，也会连接不上。
更新服务器端版本 当我们使用 Remote 连接到远程服务器时，在服务器会有一个 .vscode-server 的隐藏目录，该目录的作用，就是存放不同 VSCode 版本的远程连接信息。
找到这个目录
删掉整个.vscodeserver目录，然后重新生成（重新连接，失败后就重新生成了）
这时里面就只有一个bin文件
如果 VSCode 软件有更新，则会自动去下载对应版本的 vscode-server 软件，此时如果我们的 VSCode 有更新多个版本的话，就会在上述目录看到不同的 HASH 版本。
所以需要下载对应版本的vscode server插件
我们查看客户端版本
https://update.code.visualstudio.com/commit:$COMMIT_ID/server-linux-x64/stable
把上面连接的&lt;COMMIT_ID&gt;替换成 提交的最长的一串号，比如这个版本就得到下面的连接
https://update.code.visualstudio.com/commit:379476f0e13988d90fab105c5c19e7abc8b1dea8/server-linux-x64/stable
直接拷贝到浏览器就自动下载了。
插件放到服务器 下载完毕后，放到服务器对应的版本路径下，应该是如下路径
.vscode-server/bin/379476f0e13988d90fab105c5c19e7abc8b1dea8
解压文件到当前目录下
tar -xvzf vscode-server-linux-x64.tar.gz --strip-components 1
解压完毕后，就可以删除多余的压缩包文件
rm vscode-server-linux-x64.tar.gz
重启客户端再次尝试连接就可以了
修改.vscode-server默认目录 vscode打开工作区之后，默认会在home目录下面产生一个.vscode-server文件夹，存放vscode的所有安装文件（插件）。
一般来讲，这个文件夹也就几个G的大小，但是如果是某些home目录space受限的设备（公用服务器），则需要将其更改。
假设你要把.vscode-server安装到一个指定目录/local/my。先进入home目录，先把.vscode-server整体拷贝到/local/my下面，然后删除home已有的.vscode-server文件夹。
然后在vscode上指定路径ip和路径
settings-&gt;Extensions-&gt;Remote-SSH -&gt; Server Install Path
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93a0fc2319285cc4e97330f2562dd476/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12b5208e3ce492dfc9c459ac2e43ecde/" rel="bookmark">
			C&#43;&#43; const、volatile和mutable关键字详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于cv（const 与 volatile）类型限定符和关键字mutable在《cppreference》中的定义为：
cv可出现于任何类型说明符中，以指定被声明对象或被命名类型的常量性（constness）或易变性（volatility）。
const----------定义类型为常量类型。
volatile--------定义类型为易变类型。
mutable用于指定不影响类的外部可观察状态的成员（通常用于互斥体、记忆缓存、惰性求值和访问指令等）。
mutable------容许常量类类型对象修改相应类成员。 const const实际上是一个类型说明，告诉编译器const修饰的目标是不变的，允许编译器对其进行额外的优化，如果后面代码不小心修改它了，就编译失败，告诉用户该目标被意外修改了，提高程序的安全性和可控性。
const修饰普通变量 被const修饰过的变量，编译器往往将其作为一个常量进行处理，同时，const修饰的变量在编译阶段会被编译器替换为相应的值，来提高程序的执行效率。
#include &lt;iostream&gt; using namespace std; int main() { const int i = 50; // 普通常量 const static int si = 50; // 静态常量 int* p_int = (int*)&amp;i; // 强制类型转换为int* int* p_sint = (int*)&amp;si; *p_int = 100; // 通过非常常量指针修改常量i的值，该行为是C++为未定义行为 //*p_sint = 100;//编译不会报错，程序运行时崩溃，且该行为也是C++为未定义行为 cout &lt;&lt; "i:" &lt;&lt; i &lt;&lt; ", i的地址: " &lt;&lt; &amp;i &lt;&lt; endl;//编译器阶段会将常量i替换为50 cout &lt;&lt; "*p_int:" &lt;&lt; *p_int &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12b5208e3ce492dfc9c459ac2e43ecde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ecd7bdf9ba91d5f126c068db53be51d/" rel="bookmark">
			什么是开发环境、测试环境、UAT环境、仿真环境、生产环境？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文为joshua317原创文章,转载请注明：转载自joshua317博客 https://www.joshua317.com/article/75
软件开发环境(Software Development Environment，SDE)是指在基本硬件和宿主软件的基础上，为支持系统软件和应用软件的工程化开发和维护而使用的一组软件，简称SDE。它由软件工具和环境集成机制构成，前者用以支持软件开发的相关过程、活动和任务，后者为工具集成和软件的开发、维护及管理提供统一的支持。
常见的专有名词：
DEV development 开发 SIT System Integrate Test 系统整合测试（内测） UAT User Acceptance Test 用户验收测试 PET Performance Evaluation Test 性能评估测试（压测） SIM simulation 仿真 PRD/PROD production 产品/正式/生产
我们开发过程中一般经常会遇到以下环境： pro、uat环境、pre、test、dev环境，中文名字：生产环境、用户验收环境、灰度环境、测试环境、开发环境
简单的来说就是： pro环境：生产环境，面向外部用户的环境，连接上互联网即可访问的正式环境。
uat环境：验收测试环境，主要面向要交付的人员进行验证测试。
pre环境：灰度环境，外部用户可以访问，但是服务器配置相对低，其它和生产一样。
test环境：测试环境，外部用户无法访问，专门给测试人员使用的，版本相对稳定。
dev环境：开发环境，外部用户无法访问，开发人员使用，版本变动很大
具体说明：
开发环境：顾名思义，是指程序开发时所用的环境。程序员在编写代码时所使用的环境，一般来讲，开发环境中的服务器配置比较随意主要是用来测试的，无用户交互，并且要打开错误报告，方便程序员调试。
测试环境：公司内部研发人员使用的环境，开发人员调试代码，测试人员进行功能测试和集成测试等等使用的环境。
UAT环境：要理解UAT环境，首先要明白UAT的概念，UAT，(User Acceptance Test),用户接受度测试 即验收测试，所以UAT环境主要是用来作为客户体验的环境。
仿真环境：顾名思义是和真正使用的环境一样的环境（即已经出售给客户的系统所在环境，也成为商用环境），所有的配置，页面展示等都应该和商家正在使用的一样。
生产环境：生产环境是指正式提供对外服务的环境
一般情况下，我们系统开发必须要经历的三个阶段：开发-&gt;测试-&gt;上线。
本文为joshua317原创文章,转载请注明：转载自joshua317博客 https://www.joshua317.com/article/75
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02cc86db1b46475c6bdf2e01ed9a08bf/" rel="bookmark">
			react18 学习（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言1：适用会用Vue或React的人，手撸源码。
前言2：作者也是一步步学习，把自己学习的过程记录下来复习用，可能有没弄明白的地方在文档上写的不清楚，另外我每个写的文档都会自己重新看几遍去做些优化，所以如果有问题和建议欢迎大家在评论区留言，一起进步。
react18 学习（一） 开始创建入口文件实现jsx怎么编译jsx创建虚拟DOM 根节点和根fiber创建根节点fiber为什么需要有fiber？什么是fiber？ 创建根fiber创建队列 捋一下过程 开始 npm init -y 初始化一个项目
npm i vite @vitejs/plugin-react --save 下载 vite 和 编译 加载react语法的插件
新建 vite.config.js 文件，初始化配置，引用react插件。
// 当以命令方式运行 vite 时，vite 会自动解析项目根目录下 vite.config.js 的文件。 import { defineConfig } from "vite"; import react from "@vitejs/plugin-react"; export default defineConfig({ plugins: [react()], // 配置需要使用的插件列表 }); 创建入口文件 index.html
&lt;div id="root"&gt;&lt;/div&gt; &lt;script type="module" src="./src/main.jsx"&gt;&lt;/script&gt; src/main.jsx
console.log("main"); pakeage.json
{ "scripts": { "dev": "vite" } } npm run dev 运行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02cc86db1b46475c6bdf2e01ed9a08bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6557ef1b5f2ca5b23df06a986b9d2b87/" rel="bookmark">
			编译正点原子STM32MP157开发板uboot源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取uboot源码 路径为
F:\【正点原子】STM32MP157开发板（A盘）-基础资料\01、程序源码\01、正点原子Linux出厂系统源码 将这个压缩包发送到虚拟机中
解压，删除压缩包
mkdir uboot tar -vxf u-boot-stm32mp-2020.01-gdb2b13ef-v1.6.tar.bz2 -C ./uboot/ 结果如下
安装工具 编译前需要先安装一些东西
sudo apt-get install libncurses5-dev bison flex 开始编译 执行命令
make distclean make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabihf- stm32mp157d_atk_defconfig make V=1 ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabihf- DEVICE_TREE=stm32mp157d-atk all 然后报错了
关键是
/usr/bin/ld: scripts/dtc/dtc-parser.tab.o:(.bss+0x10): multiple definition of `yylloc'; scripts/dtc/dtc-lexer.lex.o: (.bss+0x0): first defined here 一个.o文件有多重定义的变量。.o文件会多重定义一般是.c文件引起的，所以，我们把后缀换成.c，编辑一下这个文件。
vim scripts/dtc/dtc-lexer.lex.c 使用搜索找到yylloc
将它改为声明，即
extern YYLTYPE yylloc; 结果如下
保存退出。
重新执行编译
编译结果如下
这次编译成功了
修改Makefile使编译更方便 编译的时候每次都输入 ARCH 和 CROSS_COMPILE 比较麻烦，为了方便起见，我们可以直接修改 uboot 的 Makefile 文件，在里面直接对 ARCH 和CROSS_COMPILE 进行赋值，也就是直接将 ARCH 设置为 arm，CROSS_COMPILE 设置为 arm-none-linux-gnueabihf-
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6557ef1b5f2ca5b23df06a986b9d2b87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a701b39430e85467b52c15b9d8dab38c/" rel="bookmark">
			C&#43;&#43;多线程实战： 实现简单的生产者-消费者模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 生产者/消费者模式介绍2. 生产者/消费者模式实现总结 前言 最近在复习C++多线程方面的知识，借此机会实现了生产者-消费者模式。
1. 生产者/消费者模式介绍 本次实现的生产者消费模式，读者可以类比馒头生产和销售。馒头生产最多存储10个大馒头，再多就不新鲜了，哈哈。这里以c++ 容器 deque来保存生产的馒头，详细的过程参考代码实现中的注释即可。
2. 生产者/消费者模式实现 std::deque&lt;int&gt; deqProducts;//保存生产的商品 static int PRODUCT_MAX_NUM = 10;//deqProducts中最大商品数量 bool bTerminate = false;//消费者是否停止买商品， false-可以继续买，true - 停止买商品 std::mutex mProducer, mConsumer, mPrint;//互斥信号量：生产者，消费者，客户端打印 std::condition_variable cvProducer, cvConsumer;//条件变量：生产者、消费者 //生产者生产过程 auto producer = [&amp;](int i) { std::unique_lock&lt;std::mutex&gt; uLock(mProducer); while (deqProducts.size() &gt; PRODUCT_MAX_NUM) { cvProducer.wait(uLock);//队列已满，等待消费者消费后才能继续生产商品； } //为客户端打印添加临界区，避免打印乱行 mPrint.lock(); std::cout &lt;&lt; "Producer will produce product: " &lt;&lt; i &lt;&lt; std::endl; mPrint.unlock(); deqProducts.push_back(i);//生产产品并保存到列表 cvConsumer.notify_all();//产品列表不为空，通知消费者可以购买商品了 }; //消费者购买商品过程 auto consumer = [&amp;]() { while (true) {//第一层无限循环，无数消费者排队买商品 std::unique_lock&lt;std::mutex&gt; uLock(mConsumer); while (deqProducts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a701b39430e85467b52c15b9d8dab38c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1299e3dd7609d1190d34f998a4654ccb/" rel="bookmark">
			Spark 优化方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spark 优化方案 Apache Spark 是一个快速、通用、可扩展的分布式计算引擎，Spark 的使用在大规模数据处理中变得越来越普遍。然而，在处理大数据集时，Spark 的性能可能受到影响。本文将探讨一些 Spark 优化方案，以提高 Spark 在处理大数据集时的性能。
1. 数据分区 在 Spark 中，数据被分为多个分区进行并行处理。分区的大小直接影响 Spark 的性能。如果每个分区的大小太小，那么 Spark 的任务调度开销就会变得很大，导致性能下降。相反，如果每个分区的大小太大，那么就会导致数据不平衡，使得一些节点的负载过重，而其他节点处于空闲状态。
解决方案：根据数据集的大小和计算资源的可用性，调整数据分区的大小，以实现最佳的性能和负载均衡。
优化操作：
使用 repartition 或 coalesce 方法手动设置分区数。根据数据集的特点，使用自定义的分区器。 在 Spark 3.0 之后，对于数据分区的优化方案有如下改进
（1）. 自适应分区 Spark 3.0 引入了自适应分区功能。自适应分区可以自动地调整分区数，使得每个分区的大小都尽量相等，并且可以根据当前任务的数据量和集群的资源情况来调整分区数。
自适应分区默认开启，可以通过设置 spark.sql.adaptive.enabled 参数来关闭或打开。
（2）. 动态分区 Spark 3.0 引入了动态分区功能。动态分区可以根据数据分布情况来动态调整分区数，从而使得每个分区的大小都尽量相等，并且可以根据数据的大小和集群的资源情况来动态调整分区数。
动态分区需要在读取数据时指定 maxRecordsPerPartition 参数，以便 Spark 根据数据分布情况来动态调整分区数。
（3）. 分区优化 Spark 3.0 提供了一些分区优化功能，可以进一步提高任务的性能。分区优化可以通过调整分区大小和分区策略来提高任务的性能。
分区优化包括以下方面：
增加分区数：可以通过增加分区数来提高任务的并行度和性能。减少分区数：可以通过减少分区数来减少 shuffle 的数据量和网络传输的负载。自定义分区策略：可以根据数据特征和任务需求来自定义分区策略，以提高任务的性能。 2. 内存管理 Spark 中的内存管理对性能也有很大的影响。Spark 默认情况下将内存分为堆内存和堆外内存。堆外内存主要用于缓存数据和执行计算任务。如果堆内存使用过度，会导致内存溢出和性能下降。
解决方案：调整内存配置参数，包括调整堆内存和堆外内存的大小、启用内存压缩等，以获得最佳的性能。
优化操作：
调整存储内存和执行内存的大小。启用内存压缩以减少内存使用量。使用内存序列化来减少序列化和反序列化的开销。使用堆外内存（Off-heap Memory）来缓存数据。 3. 数据序列化 在 Spark 中，数据序列化可以提高性能。数据序列化指的是将数据从一种形式转换为另一种形式，以便更快地传输和处理数据。Spark 支持多种序列化格式，包括 Java 序列化、Kryo 等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1299e3dd7609d1190d34f998a4654ccb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6a9aac21967ec643dd04d4fce445a61/" rel="bookmark">
			在windows 11上编译open jdk1.8及遇到问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基本环境准备openjdk源码下载安装GYGWIN下载FreeType下载visual Studio 2010BOOT JDK下载 开始编译通过Visual Studio x64命令提示(2010) 进入编译环境:执行base.exe进入linux模拟器cd到待编译jdk下执行 make all 命令，等待成功 遇到的错误信息和解决方法安装软件版本过高，不配置导致报错如下报错原因和解决方案 visual studio 2010安装中文导致脚本乱码报错如下报错原因和解决方案 cl编译环境不正确导致错误报错如下报错原因和解决方式 打开bash环境方式不正确错误报错如下报错原因和解决方式 使用make all命令后报错报错如下解决方式 freetype路径错误报错如下解决方式 基本环境准备 安装对应软件时，条件允许最好选择官网推荐版本，或在小版本内变化。版本变化太大，编译也能通过，但是执行configure时版本校验可能会报错，需要改动脚本。
openjdk源码下载 下载地址 open jdk下载地址
我拉取得分支是tag: jdk8-b120，可能不同分支编译脚本不同，会遇到不同得错误，遇到错误取看下脚本怎们写得，针对脚本改改环境，或者改改脚本。
拉取到源码后，看下源码下得 README-builds.html 文件。
安装GYGWIN cygwin是一个在windows上模拟linux环境的软件。
官网链接 官网推荐版本： 1.7.16 or newer
你需要在cygwin安装下面的软件（来自官网文档）。在安装的时候用Package进行搜索，用Binary Name一般搜索不到
下载FreeType 官网地址
github下载地址 来自官网底部
下载完成后，需要重新移动下文件的位置：
base_dir/include/
base_dir/lib/ 目录下
上面按照这样操作来自于官网，脚本就是按照这样写的，读取这些目录下内容。后面分析脚本内容会写到。
下载visual Studio 2010 官网推荐安装 Microsoft Visual Studio C++ 2010 (VS2010) Professional Edition or Express compiler
官网下载地址
下载2010年，需要你加入免费 Dev Essentials 计划。可以按照官网操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6a9aac21967ec643dd04d4fce445a61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b760b72c69c2ba4048f8c408eec63af/" rel="bookmark">
			USB HID键盘实现全键无冲解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
设备描述符
配置描述符
配置描述符
接口描述符
HID描述符
端点描述符
HID类报表描述符
输入输出数据解析
其他
前言 看了稚辉君的瀚文键盘的源码之后对于键盘全键无冲的实现还是存在很多疑问。1、HID报表描述符的内容到底什么意思？2、瀚文源码里的键值映射函数最终生成的报表不理解。然后就从头开始研究了一下USB。对着描述符里的每一个参数找资料，把所有描述符都对一遍。现在已经大概理解了全键无冲键盘的配置方式和报表含义。
实践选用的是沁恒的CH573F，这颗芯片支持USB 2.0 Host和Device,支持最大64字节数据包。在官网下载他们的官方Demo，并在USB Device里面找到CompoundDev这个工程来修改我的全键无冲键盘。
设备描述符 const uint8_t MyDevDescr[0x12] = { 0x12, //bLenght 0x01, //bDescriptorType 0x00,0x02, //bcdUSB 0x00, //bDeviceClass 0x00, //bDeviceSubClass 0x00, //bDeviceProtocol 0x40, //bMaxPacketSize0 0x3d,0x41, //idVendor 0x07,0x21, //idProduct 0x00,0x01, //bcdDevice 0x01, //iManufacturer 0x02, //iProduct 0x03, //iSerialNumber 0x01 //bNumConfigurations }; bLenght--固定长度18
bDescriptorType--01：代表这段数据属于设备描述符
bcdUSB--USB2.0版本 这里是bcd编码 00 02代表2.0版本
bDeviceClass--类型代码（由USB指定）。当它的值是0时，表示所有接口在配置描述符里，并且所有接口是独立的。当它的值是1到FEH时，表示不同的接口关联的。当它的值是FFH时，它是厂商自己定义的
bDeviceSubClass--子类型代码（由USB分配）．如果bDeviceClass值是0，一定要设置为0．其它情况就跟据USB-IF组织定义的编码
bDeviceProtocol-- 协议代码（由USB分配）．如果使用USB-IF组织定义的协议，就需要设置这里的值，否则直接设置为0。如果厂商自己定义的可以设置为FFH
bMaxPacketSize0--最大包长,芯片所支持的最大长度
idVendor--厂商ID
idProduct--产品ID
bcdDevice--版本号，自己定义 这里是bcd编码 00 01代表1.0版本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b760b72c69c2ba4048f8c408eec63af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ec5965f94d66bd5855d2ab13a2aacfb/" rel="bookmark">
			Flink CDC 最佳实践（以 MySQL 为例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 准备工作 1.1 确认 MySQL binlog 模式 确认 MySQL 数据库的 binlog 模式是否为 ROW。可以在 MySQL 命令行中执行以下语句确认：
SHOW GLOBAL VARIABLES LIKE 'binlog_format'; 如果返回结果中的 Value 字段为 ROW，则说明 binlog 模式为 ROW。
1.2 下载并安装 Flink 下载并安装 Flink，可以参考官方文档进行安装。
2. 配置 Flink CDC 2.1 配置 MySQL 数据库连接信息 在 Flink 的配置文件 flink-conf.yaml 中添加 MySQL 数据库连接信息，例如：
# MySQL connection configuration mysql.server-id: 12345 mysql.hostname: localhost mysql.port: 3306 mysql.username: root mysql.password: 123456 mysql.database-name: test 2.2 配置 CDC Job 在 Flink 的 CDC Job 配置文件 mysql-cdc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ec5965f94d66bd5855d2ab13a2aacfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d479f7c47c414e8ca5a43fcbfc31a1c8/" rel="bookmark">
			含内环图形在OpenLayers中展示时空洞被填充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题产生背景 在一次arcgis中图形转到OpenLayers中展示时，发先含有空洞的一个面在展示时，有部分空洞被自动填充了。展示状况如下：
arcgis中显示：
OpenLayers中展示：
可见右侧空洞被填充了，明显不太合理。于是去百度了下，得知Geojson格式要求：对于Polygon有一个以上的环，第一个必须是外环，其他的必须是内环。 外环与表面形成边界，内环(如果存在)与表面形成边界孔。
此时产看了下本地Arcgis中的面环，确实第一个环是内环：
可见就是环顺序导致的前端展示错误，于是就想着调整环顺序解决。
解决方式如下 第一种方式：
用AE接口将Geometry中的环顺序调整后在展示：
public static string ChangeRingsOrder(IGeometry pGeometry) { ITopologicalOperator topo = pGeometry as ITopologicalOperator; topo.Simplify(); IPolygon4 pGeoPolygon = pGeometry as IPolygon4; GeometryBag geoBag = pGeoPolygon.ExteriorRingBag as GeometryBag; IGeometryCollection geoCollection2 = new PolygonClass(); IGeometryCollection geoCollection = geoBag as IGeometryCollection; List&lt;IGeometry&gt; rings1 = new List&lt;IGeometry&gt;(); for (int j = 0; j &lt; geoCollection.GeometryCount; j++) { IGeometry geo = geoCollection.get_Geometry(j); geoCollection2.AddGeometry(geo); IGeometryBag InteriorBag = (pGeometry as ESRI.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d479f7c47c414e8ca5a43fcbfc31a1c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adf041daeb36f08a5ffeef975a022dc0/" rel="bookmark">
			React导出excel的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先下这个依赖 xlsx
可以通过JSON数据转成Exel导出
第一步，获取JSON步骤
…
第二步，JSON转Exel数据
const fileName = `历史告警_${moment().format("YYYY-MM-DD-HH:mm:ss")}`; // 文件名 const data = jsonData.map((v) =&gt; { const tabData = {}; tabData["设备名称"] = v.equipment?.name; // ... return tabData; }); 第三步，导出
const wopts = { bookType: "xlsx", bookSST: false, type: "binary" }; const wb= { SheetNames: ["历史告警"], Sheets: {}, Props: {} }; wb.Sheets["历史告警"] = XLSX.utils.json_to_sheet(data, { origin: "A2", }); wb.Sheets["历史告警"].A1 = { t: "s", v: fileName };// 表格第一行写文件名 saveAs( new Blob([s2ab(XLSX.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adf041daeb36f08a5ffeef975a022dc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e43881c54d4d85e720a86bc16837e6a8/" rel="bookmark">
			Nginx 介绍、部署及性能优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要内容:
1、Nginx 简介
2、Nginx 搭建及生产环境配置
3、Nginx 性能调优
一、Nginx 简介 正向代理和反向代理 正向代理： 客户端非常明确要访问的服务器地址，它代理客户 端，替客户端发出请求。比如：FQ （警告⚠️：FQ操作违反相关法律规定，本篇文章仅供 学习参考，切勿盲目FQ）。
反向代理： 均衡分工，控制流量，避免出现局部节点负载过大。 反向代理隐藏了服务器的信息，它代理的是服务器端， 代其接收请求。 换句话说，反向代理的过程中，客户端并不知道具体是 哪台服务器处理了自己的请求。如此一来，既提高了访 问速度，又为安全性提供了保证。
什么是 Nginx ? Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好。
注：Nginx 实际代表的是 engine-x，其音标为：/'endʒɪneks/ Nginx 与Apache性能对比 160 million 个站点在 NGINX 上运行
51% 前 10,000 个访问量最大的网站Nginx 占比
36% 的亚马逊网络服务运行着Nginx
二、Nginx 搭建及生产环境配置 Nginx 编译安装 $ yum -y install gcc gcc-c++ # 下载gcc编译器 $ yum -y install pcre-devel openssl-devel # 下载PCRE $ wget http://nginx.org/download/nginx-1.21.1.zip # 下载nginx，官方网站是 http://nginx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e43881c54d4d85e720a86bc16837e6a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6efcd2d51b545a8d1b5b29ea6c6ab6d6/" rel="bookmark">
			UE5 actor foliage 找不到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我发现actor foliage没法拖动到foliage库里，也没法搜索识别到，感觉是bug。
解决方法是先找一个静态网格体的foliage加上，然后右键替换就可以找到actor foliage了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f16c0bacbbb2a6a9d40da71b66b88cb2/" rel="bookmark">
			jackson、fastjson、kryo、protobuf等序列化效率对比【全】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、综合性能（序列化+反序列化+大小） 综合排名序列化方式1kryo-manual2protostuff-manual3protostuff4protobuf/protostuff5java-manual6wobly7fst-flat-pre8protostuff-runtime9protobuf/protostuff-runtime10wobly-compact11protostuff-graph12kryo-flat-pre13protostuff-graph-runtime14kryo-flat15fst-flat16protobuf17kryo-opt18json/fastjson/databind19smile/jackson/manual20scala/sbinary21thrift-compact22json/jackson/manual23jboss-marshalling-river-ct-manual24fst25kryo-serializer26msgpack-manual27thrift28cbor/jackson/manual29msgpack-databind30cbor/jackson/databind 二、序列化效率 序列化效率排名序列化方式1protostuff2protostuff-manual3protobuf/protostuff4kryo-manual5protostuff-runtime6kryo-flat-pre7fst-flat-pre8protobuf/protostuff-runtime9kryo-flat10java-manual11wobly12protostuff-graph13msgpack-manual14protostuff-graph-runtime15smile/jackson/manual16wobly-compact17fst-flat18kryo-opt19json/jackson/manual20json/fastjson/databind21msgpack-databind22protobuf23json/protostuff-manual24cbor/jackson/databind25cbor/jackson/manual26smile/jackson/databind27fst28avro-specific29json/jackson/databind30scala/sbinary 三、反序列化效率 反序列化效率排名序列化方式1java-manual2wobly3kryo-manual4fst-flat-pre5protostuff-manual6wobly-compact7protobuf/protostuff8protostuff9protobuf/protostuff-runtime10protostuff-runtime11protostuff-graph12protobuf13protostuff-graph-runtime14thrift-compact15kryo-flat-pre16kryo-flat17fst-flat18kryo-opt19scala/sbinary20json/fastjson/databind21thrift22jboss-marshalling-river-ct-manual23kryo-serializer24fst25smile/jackson/manual26json/jackson/manual27msgpack-manual28cbor/jackson/manual29smile/jackson+afterburner/afterburner30msgpack-databind 四、对象大小 对象Size排名序列化方式1kryo-opt2kryo-manual3kryo-flat-pre4avro-generic5avro-specific6wobly-compact7msgpack-databind8msgpack-manual9protobuf/protostuff10protobuf11protostuff-graph12protostuff-manual13protostuff14thrift-compact15protobuf/protostuff-runtime16protostuff-graph-runtime17protostuff-runtime18fst-flat-pre19wobly20java-manual21scala/sbinary22kryo-flat23kryo-serializer24jboss-marshalling-river-ct-manual25jboss-marshalling-river-ct26fst-flat27fst28xml/exi-manual29smile/jackson/databind30smile/jackson/manual 五、总结 Kryo——速度快，序列化后体积小；缺点是跨语言支持较复杂
Protostuff——速度快，基于protobuf；缺点是需静态编译
Protostuff-Runtime,无需静态编译，但序列化前需预先传入schema;缺点是不支持无默认构造函数的类，反序列化时需用户自己初始化序列化后的对象，其只负责将该对象进行赋值
Java——使用方便，可序列化所有类；缺点是速度慢，占空间
具体的对比可以参考这个基线图：
Results - JVM Serializer Benchmarks
效率对比直观图：
An Introduction and Comparison of Several Common Java Serialization Frameworks - Alibaba Cloud Community
首选序列化：Kryo、Protostuff
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6829e40ea42330bcad2ee6d96502a08/" rel="bookmark">
			BFS算法（蓝桥杯大胖子走迷宫为例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、BFS算法思想 BFS算法，也称广度优先搜索算法，是一种经典的图搜索算法，其基本思想是从起点开始，逐层扩展搜索范围，直到找到目标节点或者整个图都被遍历过。
在BFS算法中，使用队列来存储待处理的节点，首先将起点加入队列中。然后，从队列中取出一个节点并遍历其所有邻居节点，将尚未访问的邻居节点加入队列中，直到队列为空或者找到目标节点。由于BFS算法采用逐层扩展的方式进行搜索，因此找到目标节点时，其与起点之间的路径一定是最短路径。
下面我们来看一下BFS算法的原理：
首先定义一个Queue类型的队列，将起点P入队。
取出队首节点，搜索该节点的所有邻居节点，并将尚未访问过的邻居节点都加入队列中。
判断目标节点是否在队列中，如果不在，则返回第2步。
如果目标节点已经在队列中，搜索结束。
BFS算法的时间复杂度通常为O(|V|+|E|)，其中|V|和|E|分别表示图的节点数和边数。在实际使用中，BFS算法常常用于求解最短路径问题，如迷宫游戏、路线规划等。
在实现BFS算法中，我们需要进行以下几个步骤：
定义一个队列Queue，用于存储待处理的节点。
定义一个数组visit，用于记录每个节点是否已经被访问过。
设定起点P为已访问，并将其加入队列中。
当队列非空时，取出队首节点，遍历其所有邻居节点，如果邻居节点尚未访问，则将其标记已访问，并加入队列中。
重复第4步，直到队列为空或者找到目标节点。
BFS模板 BFS算法： 通常用队列（先进先出，FIFO）实现 初始化队列Q； Q = {起点s}; 标记s为已访问； while（Q非空） { 取Q队首元素u； u出队； if（u==目标状态） { …… } else { 所有与u相邻且未被访问的点进入队列； 标记u为已访问； } } #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;vector&gt; using namespace std; const int MAXN = 1005; // maximum number of nodes vector&lt;int&gt; adj[MAXN]; // adjacency list bool vis[MAXN]; // visited array void bfs(int start) { queue&lt;int&gt; q; q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6829e40ea42330bcad2ee6d96502a08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d2f2d522ce66413996e257fb0515088/" rel="bookmark">
			实现yolov3网络调用含有驱动程序的双目相机,实现实时目标检测和距离输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最终目标:实现百米内的目标检测和深度测量(计划使用在道路的目标检测) 前段时间一直在调试yolov3和相机接口问题.如果使用普通的相机,yolov3可以直接调用,实现物体识别的功能.这个我也写了一篇文章. 但是不能实现测距的功能, 我购买的这个双目相机,公司声称可以测100m以内的物体,所以买来打算调试一番.对于一个车辆工程的算法小白,这两个代码中既有c语言,又有c++,调试过程是痛苦的,结果是满意的,最后经过自己将近一个月的努力,最终实现了所有预想的功能,但是,效果目前还需验证.
目前还没有去道路上测试,只是在实验室试了一下,下面是效果图,视频回头补上.
目前还存在的两个问题:
1)相机快速抖动时,无法识别出物体.（后来通过代码优化基本解决了）
2)距离精度有时候不太好.
下面这一个效果就是不太好,明显有一些错误.
相机实例代码功能:通过鼠标框出想要测距的物体,然后返回物体对应的距离
yolov3功能:识别出预训练包含类别的物体,并框选出来.
调试整体思路
1）找到双目相机基础代码中的数据输出代码段，主要包括深度信息和RGB信息。
2）找到目标识别源代码中接收RGB图像的代码段，我使用的目标识别代码是yolov3，可以直接搜索Darknet官网下载目标识别代码，现在出来yolov5了，可以试一试。
3）将1中找到的双目相机RGB数据输入到2中找到的目标识别代码中接收RGB的代码，两者结合。
4）找到目标识别源代码中输出障碍物坐标框的代码段。
5）找到双目测距代码中计算障碍物深度的代码段。
6）将4中得到的障碍物框依次输入到5中的代码段中，得到目标框中障碍物的深度。
7）找到目标识别网络中显示障碍物种类的额代码段，将深度值添加到里面，一起显示出来。
注释：最近需要代码的人有点多，其实这个代码是我当时哪里有问题就改哪里，所以里面会有很多地方很乱，有些地方也比较多余，今天大致将修改思路整理一下，后续有时间会一点一点将过程写出来。
有需要代码的留下邮箱，我看到的话会给你们发过去。
附件1.代码中双目测距代码的流程图，有问题的地方欢迎大家交流学习。
附件2（整个过程的流程图）
代码链接自取：
链接: https://pan.baidu.com/s/1h15pL0-xn__L8pnJYrlbEQ
密码: 9b8l
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0923825a9445cec904b54ada89b80931/" rel="bookmark">
			vscode报错 Error: EACCES: permission denied, open...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
问题描述
解决方法：修改文件权限
问题描述 用vscode远程连接Linux服务器，把本地文件夹拖到服务器目录下时出现报错：
Error: EACCES: permission denied, open ... 通过翻译可知，这里是由于没有权限而报错
解决方法：修改文件权限 退到上一层，在linux中输入chmod 777 文件/目标名，修改文件的使用权限以达到拥有权限修改
比如，我创建的一个user叫avic，直接退回到 /home 中输入
chmod 777 avic 此时，在这个用户下，可以把本地文件夹拖进任意地方了。
搞定！
谢谢实验室大佬同门的帮助！~
参考：
vscode使用remote连接linux保存文件时报错“没有权限”_vscode远程控制linux没权限改文件_Wh0taku的博客-CSDN博客
Linux chmod命令：修改文件或目录的权限 (biancheng.net)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31bb985c2ce6353795c00769948f8e2d/" rel="bookmark">
			MyBatis中如何获取自动生成的(主)键值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Mybatis中insert 方法总是返回一个int值 ，这个值代表的是插入所影响的行数。 如果id采用自增长策略，自动生成的键值在 insert 方法执行完后可以被设置到传入的参数对象中。那么我们可以在service中通过传入的对象来获得插入的id值。
mapper.xml文件
&lt;insert id="insert" keyColumn="id" keyProperty="id" parameterType="com.woniuxy.springbootmybatis.entity.User" useGeneratedKeys="true"&gt; insert into user ( id,user_name,tel ,password,age,create_date ,head_img,dept_id) values (#{id,jdbcType=INTEGER},#{userName,jdbcType=VARCHAR},#{tel,jdbcType=VARCHAR} ,#{password,jdbcType=VARCHAR},#{age,jdbcType=INTEGER},#{createDate,jdbcType=TIMESTAMP} ,#{headImg,jdbcType=VARCHAR},#{deptId,jdbcType=INTEGER}) &lt;/insert&gt; service代码
@Override public int insertSelective(User record) { int result = userMapper.insertSelective(record); log.info("当前行数据的ID为{}",record.getId()); return result; } 日志文件为：
2023-04-06 15:45:09.813 INFO 15952 --- [nio-8080-exec-1] c.w.s.service.impl.UserServiceImpl : 当前行数据的ID为107 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efe2b5b7bbcb1de8b36f77170aa909cb/" rel="bookmark">
			枚举、模拟法（蓝桥杯卡片、数的分解为例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		枚举和模拟算法是计算机领域常用的两种基本算法。枚举算法是一种通过列举所有可能的情况来解决问题的方法。模拟算法则是通过模拟真实场景来解决问题。
枚举、模拟法 枚举算法是指将问题分解为一系列离散的情况，通过枚举所有可能的情况，逐一检查每种情况来解决问题。这种算法适合解决一些问题的最优解问题，但是当数据规模较大时会因为枚举的数量过多而导致运行时间增长。
模拟算法是指将一个问题的真实情况模拟出来，并对问题进行推演，以便得到问题的解决方案。
例如，蓝桥杯 卡片 - 蓝桥云课 (lanqiao.cn)
题目描述 用卡片拼数字，拼过的卡片不能再用，有 0 到 9 的卡片各 2021 张，共 20210 张，请问小蓝可以从 1拼到多少 ？
解题思路 比较容易的模拟，我们从1开始枚举，每次检查剩下的卡片能不能拼出这个数字就好。
把一个数在10进制下每个位置的数字求出来——先对10取模，个位上的数字就求出来了，再除以10，原本十位上的数字就变到了个位上，再对10取模...依次进行下去就求出来了。把当前拼的这个数每一位都拆出来，看看那个数字的卡片还够不够，不够的话就说明拼不了，这时候退出循环，所以最多拼到上一个数。
我的代码 #include &lt;iostream&gt; using namespace std; int main() { // 请在此输入您的代码 int a[10]={2021,2021,2021,2021,2021,2021,2021,2021,2021,2021}; for(int i=0;i&lt;20210;i++){ int n = i; while(n) { int d = n % 10; if(a[d] == 0) { cout &lt;&lt; i - 1 &lt;&lt; endl; return 0; } a[d]--; n /= 10; } } return 0; } 例如，蓝桥杯 数的分解 - 蓝桥云课 (lanqiao.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efe2b5b7bbcb1de8b36f77170aa909cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e77372ab8f0d15b562eec6b5c4e82ec8/" rel="bookmark">
			常用的加密方式有哪些
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据加密方式有：1、单向加密；2、对称加密；3、非对称加密；4、加密盐；5、散列函数；6、数字签名。其中，单向加密通过对数据进行摘要计算生成密文，密文不可逆推还原。只能加密，不能解密，常用于提取数据的指纹信息以此来验证数据的完整性。
1、单向加密 单向加密通过对数据进行摘要计算生成密文，密文不可逆推还原。只能加密，不能解密，常用于提取数据的指纹信息以此来验证数据的完整性。但是会引发雪崩效应（雪崩效应就是一种不稳定的平衡状态也是加密算法的一种特征，它指明文或密钥的少量变化会引起密文的很大变化，就像雪崩前，山上看上去很平静，但是只要有一点问题，就会造成一片大崩溃。 可以用在很多场合对于Hash码，雪崩效应是指少量消息位的变化会引起信息摘要的许多位变化。）
算法代表：Base64，MD5，SHA。
2、对称加密 对称加密的加密和解密是使用同一个密钥；加密和解密的速度比较快，效率比较高;但是密钥传输过程不安全，容易破解，而且密钥管理也比较麻烦。
算法代表：DES，3DES，AES，IDEA，RC4，RC5。
对称加密可以分为两类，序列密码和分组密码
序列密码 从概念上讲，序列密码（stream cipher）的操作过程与我们想象中加密的过程一致。将1字节的明文输入加密算法，就得到1字节的密文输出。在对端则进行相反的过程。整个过程持续重复，直到所有数据处理完成。因为这种思路比较简单，序列密码绝不能第二次使用相同的密钥。这是因为在实际使用中，攻击者知道或者可以预测特定区域的明文（请思考加密HTTP请求的情景；许多请求的请求方法、协议版本、请求头名称都是一样的）当你知道明文，又观察到密文时，就可以解析一部分密钥序列。如果使用了相同的密钥，那么就可以解密后续的部分密文。为了解这个问题，序列密码都与从长期密钥中提取出来的一次性密钥一同使用。
分组密码 分组密码（block cipher）每次加密一整块数据，并且现代的分组密码倾向于使用128位（16字节）大小的块。一种分组密码就是一个变换函数：接受输入并生成看似杂乱无章的输出。只要使用相同的密钥，每一个可能的输入组合都有唯一的输出。
我们可以理解为更高级的对称加密算法。这种加密算法也是非常常见，例如AES加密，有128位、192位和256位的加密强度。在现在的系统对接时，AES加密非常常见。
3、非对称加密 相对对称加密而言，无需拥有同一组密钥，非对称加密是一种“信息公开的密钥交换协议”。非对称加密需要公开密钥和私有密钥两组密钥，公开密钥和私有密钥是配对起来的，也就是说使用公开密钥进行数据加密，只有对应的私有密钥才能解密。这两个密钥是数学相关，用某用户密钥加密后的密文，只能使用该用户的加密密钥才能解密。如果知道了其中一个，并不能计算出另外一个。因此如果公开了一对密钥中的一个，并不会危害到另外一个密钥性质。这里把公开的密钥为公钥，不公开的密钥为私钥。
算法代表：RSA，DSA。
4、加密盐 加密盐也是比较常听到的一个概念，盐就是一个随机字符串用来和我们的加密串拼接后进行加密。加盐主要是为了提供加密字符串的安全性。假如有一个加盐后的加密串，黑客通过一定手段这个加密串，他拿到的明文，并不是我们加密前的字符串，而是加密前的字符串和盐组合的字符串，这样相对来说又增加了字符串的安全性。
5、散列函数 散列函数在密码学中也是不可缺少的一部分。散列函数（hash function）是将任意长度的输入转化为定长输出的算法。谈到散列函数，肯定会想到MD5加密，这种就是一种最为常见的散列函数。散列函数的特点：
. 抗原像性（单向性）给定一个散列，计算上无法找到或者构造出生成它的消息。即不能还原，MD5即是一种单项加密，因此，经常用于密码加密，实现即使管理员也无法知道用户的密码的功能。抗第二原像性（弱抗碰撞性）给定一条消息和它的散列，计算上无法找到一条不同的消息具有相同的散列。强抗碰撞性 计算上无法找到两条散列相同的消息。 6、数字签名 在通过散列函数来验证消息完整性的时候，仅仅在信息和数据的散列分开传输的时候才可以，否则中间人可以修改数据的同时修改散列，从而避开检测。数字签名主要是验证数据的真伪。微信通过对称加密生成的签名，支付宝通过非对称加密生成签名。效果差别不大。只要足够证明自己的身份即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82a831ddcd93eb6eadfa34d8b8addf5c/" rel="bookmark">
			Doris入门篇-分区分桶实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 测试分区分桶效果。
分区的基本操作 添加分区
ALTER TABLE v2x_olap_database.government_car ADD PARTITION p20221203 VALUES LESS THAN ("2022-12-04"); 动态分区表不能添加分区，需要转为手动分区表。
查看分区 show partitions from &lt;表名&gt; 删除分区 alter table &lt;表名&gt; drop partition &lt;分区名&gt; 手动分区表与动态分区表切换
手动转自动
alter table &lt;表名&gt; set ("dynamic_partition.enable" = "true") 注意： 如果设置了 dynamic_partition.start ，则分区范围在偏移量之前的历史分区将被删除
自动转手动
alter table &lt;表名&gt; set ("dynamic_partition.enable" = "false") 分区和分桶 Doris 支持两层的数据划分。第一层是 Partition，支持 Range 和 List 的划分方式。第二层是 Bucket（Tablet），仅支持 Hash 的划分方式。
也可以仅使用一层分区。使用一层分区时，只支持 Bucket 划分。下面我们来分别介绍下分区以及分桶：
Partition
Partition 列可以指定一列或多列，分区列必须为 KEY 列。多列分区的使用方式在后面 多列分区 小结介绍。不论分区列是什么类型，在写分区值时，都需要加双引号。分区数量理论上没有上限。当不使用 Partition 建表时，系统会自动生成一个和表名同名的，全值范围的 Partition。该 Partition 对用户不可见，并且不可删改。创建分区时不可添加范围重叠的分区。Range 分区
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82a831ddcd93eb6eadfa34d8b8addf5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f40c0d10edb2165200b12724c08fb19/" rel="bookmark">
			Hadoop集群配置免密SSH登录方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 免密登录原理 生成密钥对：用户使用ssh-keygen工具在本地计算机上生成一对公钥和私钥。私钥通常存储在用户的~/.ssh目录下（在本地计算机）需妥善保管，而公钥可以通过ssh-copy-id或手动将其复制到远程主机上，是公开使用的，在将来的登录过程中，公钥用于对会话进行加密，并验证是否与存储在远程主机上的公钥匹配。
id_rsa是私钥，而id_rsa.pub是公钥
发送公钥：用户将公钥复制到需要访问的远程主机上。在将来的登录过程中，用户将使用私钥对登录请求进行加密，并发送给远程主机
验证公钥：远程主机在收到用户的登录请求后，会使用预先存储的公钥对请求进行解密，并验证其是否与已存储的公钥匹配。如果匹配成功，远程主机会允许用户登录。
加密会话：如果公钥验证成功，远程主机将使用用户的公钥对会话进行加密，并将加密后的数据发送给用户。用户使用私钥对加密数据进行解密，并继续执行登录过程。
每台主机authorized_keys（可以自己创建一个）文件里面包含的主机（ssh密钥），该主机都能无密码登录，所以只要每台主机的authorized_keys文件里面都放入其他主机（需要无密码登录的主机）的ssh密钥就行了。比如想在slave2 上免密登录slave3，只需要将slave2的公钥添加到 slave3的authorized_keys就可以了
实现方法 hosts 文件映射 每个节点生成 ssh 密钥 这里先假设在matser节点上
ssh-keygen -t rsa 执行上述命令后会看到有生成文件夹.ssh,这个文件夹下面有id_rsa和id_rsa.pub两个文件，我们可以创建一个文件夹authorized_keys，用于存放公钥
cp id_rsa.pub authorized_keys 将authorized_keys文件拷到下一个节点，并将该节点的ssh密钥id_rsa.pub加入该文件中（这里将authorized_keys拷贝到slave1节点上）
scp -r authorized_keys root@slave1:/root/.ssh/ ,然后将slave1的公钥也追加到authorized_keys（这里需要登录slave1 节点，并且以及执行生成密钥命令，也就是上述的ssh-keygen -t rsa
）
cat id_rsa.pub &gt;&gt; authorized_keys 到这一步slave1的authorized_keys中有 master的公钥文件，就可以在master上免密登录slave1了。按上述规律实现其他节点之间的免密登录即可。
发送公钥命令 比如，我想在slave2上免密登录slave3，只需将slave2的公钥添加到slave3的authorized_keys文件中
ssh-copy-id -i ~/.ssh/id_rsa.pub [root]@[slave3] 若要访问 slave1节点，我们就把slave1节点对应的公钥指纹放到当前节点的known_hosts文件中 ssh-keyscan slave1 &gt;&gt;~/.ssh/known_hosts 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6420ce94299ba35e29f33e0fdc01a7f2/" rel="bookmark">
			Windows、Linux常见的渗透测试命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		免责声明：该公众号提供的知识仅用于授权渗透测试，如用于非法攻击，后果自负
以下是100条Windows常见的渗透测试命令
netstat：显示网络状态和 TCP/IP 连接。常用参数包括 -a（显示所有连接和侦听端口）、-n（以数字形式显示地址和端口号）和 -o（显示与每个连接相关联的进程 ID）。
tracert：跟踪数据包从本地计算机到指定目的地的路径。常用参数包括 -d（不解析 IP 地址到主机名）和 -h（指定 TTL（Time-To-Live）生存时间，即数据包可以经过的最大路由器跃点数）。
nslookup：查询 DNS 服务器以查找主机名的 IP 地址，或者查找 IP 地址的主机名。常用参数包括 （指定要查找的主机名）和 （指定要查找的 IP 地址）。
ipconfig：显示当前网络配置信息，例如 IP 地址、子网掩码和默认网关。常用参数包括 /all（显示完整配置信息）和 /release（释放当前分配的 DHCP 配置）。
arp：显示和修改本地 ARP（Address Resolution Protocol）缓存表。常用参数包括 -a（显示缓存表中的所有条目）和 -d（删除缓存表中指定的条目）。
route：显示和修改本地 IP 路由表。常用参数包括 -p（将静态路由添加到永久路由表中）和 -f（清除所有路由表中的记录，然后重新启动路由发现协议）。
netsh：允许管理员通过命令行或批处理脚本管理网络配置。常用参数包括 interface（设置和管理接口）、firewall（配置防火墙）和 wlan（管理 WLAN（无线局域网）配置）。
wmic：提供对本地或远程计算机上的 Windows 管理信息的访问。常用参数包括 process（管理进程）和 startup（管理启动项）。
reg：允许管理员从命令行管理 Windows 注册表。常用参数包括 query（查询注册表值）和 export（导出注册表键值）。
schtasks：允许管理员创建、修改、删除和查询计划任务。常用参数包括 /create（创建计划任务）和 /delete（删除计划任务）。
tasklist：显示正在运行的进程的列表。常用参数包括 /svc（显示每个进程所拥有的服务）和 /m（显示每个进程所加载的模块）。
net：管理本地和远程计算机上的网络资源。常用参数包括 use（连接共享文件夹或打印机）和 user（管理用户帐户）。
ftp：连接到远程 FTP 服务器并传输文件。常用参数包括 open（连接到 FTP 服务器）和 get（下载文件）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6420ce94299ba35e29f33e0fdc01a7f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5482933200491fbd1ffea8129f750f2/" rel="bookmark">
			jieba库中自定义词典的词频含义，便于分出想要的词（自留笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写论文的时候，数据处理用jieba分词，建立了自定义词典但怎么也分不出想要的词，搜了半天发现国内基本上没人写这个，所以写下来自用，也分享给做数据处理的小伙伴们。因为是自留，所以会写的比较细一点，看起来会有点啰嗦，如果想节约时间可以只看解决方法部分
参考帖子 https://github.com/fxsjy/jieba/issues/967
问题：
1.这是要处理的文本(举例) ：【我在人民路上人民路小学】
想要的语句分段应该是：【我 \在 \人民路 \上 \人民路小学 】
但如果不加自定义词典，只用官方自带的词典会得到：
2.此时为了分出想要的词，采用自定义词典，在自定义词典中增加 【人民路、人民路小学】两个词
保存文档后，分词结果如下（其中【在】字因为我用了停用词，所以这里并没有显示）：
可见，我们想要的【人民路小学】这个词分出来了，但 【人民路\上】 却被分成了【人民\路上】
3.为什么会出现这样的情况呢？其实是因为jieba这个库里面原本就有一个内置分词词典，而你增加的自定义词典，只是相当于扩充了这个内置分词词典词库中的词语量，分词的时候并不会优先考虑自定义词典中的词（个人理解，可能有点点偏差）
通过：print(jieba.__file__) 我们可以找到jieba库所在的路径，里面有个dict.txt 这就是jieba的内置词典库
继续回到上述【我在人民路上人民路小学】这个例子，通过ctrl+F查找dict.txt中的文本内容，会发现dict.txt中自带有【人民、路上】这两个词（此处只显示人民）
网上最简单的解决办法就是删除dict.txt中的【人民、路上】这两个词，这样就可以分出【我 \在 \人民路 \上 \人民路小学 】但是我不建议这样！！！因为这样改来改去会让jieba内置词典分词效果变得不好，如果你后面的文本想分出【路上】这个词怎么办呢？
所以这里提供一个本人以为较好的解决办法
解决方法：
根据本人最开始放在开头的链接中所述
jieba中的内置词典的词语格式其实要有三种属性（如下红黄蓝）
其中：
【人民】就是词语嘛这很好理解
【43719】这种数字代表的是这个词语的词频
【n】代表的词语的词性（个人认为这个不是很重要，毕竟中文的词性，感觉不太好分）
上述问题的原因就在【43719】这个数字词频上
根据链接的帖子中所述：结巴分词中词语的词频并不完全是我们所理解的：词频越大，权重越大！！！即分词会先按照词频大的词语来分！！！
其实并不是这样的！！！非也非也！！！！切记切记！！！！！
仍然用上面那个【人民路\上】来举例jieba真正的分词原理：
现在给出一些数据：
内置词典和自定义词典中词语和的总数为：all
在dict.txt中：【人民】这个词的词频是43719 【路上】这个词的词频是2706
【上】这个词的词频是258101
在自定义词典中我们设置：【人民路】这个词的词频是 2706
jieba分词的分词方式是(字丑见谅): 人民、路上这些都指的是对应的词频！！！
jieba分词时会比较上面两个公式，显然②大，就会按照②的方式来分词
所以我们可以调节自定义词典中词语的词频数，使得词频数更大，分出想要的词语。
但具体词频的大小，可按照上述那个公式，稍稍计算一下就行。
同时如果你观察dict.txt词典，你就会发现通常：单个字的词频会更大，词语字数长的词频会更小，这是因为结巴分词，更倾向于分长词！！！
简单举个例子就是【人民路小学】
词典中：【人民路、人民路小学、小学】都有，但是为什么却恰恰可以把词语分成【人民路小学】，而不是【人民路】和【小学】呢？
仍然用上面的公式：
显然，就算【人民路小学】的词频设为1，但由于②中分母是总词语数的平方，如果不把【人民路】和【小学】的词频设的比词语总数还大，都会按照【人民路小学】来分词
所以设定词语的词频时，如果想要得到的词语本就是长词，词频不用设置的特别大1-50基本上就行了，如果是短词得提高一下词语的频次
写的比较啰嗦，见谅！
祝万事胜意：）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a1595cd5e524c112823e377bc45634c/" rel="bookmark">
			hadoop集群配置--免密登录配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.主节点免密登陆 主节点免密登陆有有两个步骤：① 产生密钥和公钥，② 将公钥的内容添加进当前节点的SSH认证文件。 产生密钥和公钥，在主节点上执行如下命令：
cd ~/.ssh # 如果没有该目录，先执行一次：ssh 主机名 rm ./id_rsa* # 删除之前生成的公匙（如果之前没创建过公钥可忽略） ssh-keygen -t rsa # 一直按回车就可以 ~/.ssh目录默认是没有的，用户使用ssh 主机名后会自动创建，同时在该目录下生成known_hosts文件，用来存储使用ssh命令进行过通行的节点的信息。
将公钥的内容添加进当前节点的SSH认证文件，命令如下：
cat ./id_rsa.pub &gt;&gt; ./authorized_keys #将公钥内容加入SSH认证文件 执行完上述命令后，即可执行ssh 主机名进行免密登陆，此次登陆不需要输入密码则证明免密登陆配置成功，否则配置失败。
cat命令使用方法
2.将公钥发送給指定的机器 2.1每个节点都传一次公钥（相对繁琐） ssh-copy-id -i ~/.ssh/id_rsa.pub westgisB065 2.2执行以下命令直接传送到指定机器（比较快捷） for host in westgisB0{65..69} do ssh-copy-id WBQ@$host done 3.测试是否可以免密登录 注意问题：产生的公钥必须只有一个，否则容易出问题，导致个别节点不能实现免密登录，这时需要我们查看之前是否产生过公钥。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53c730b33421d7e49867256bb3aed32b/" rel="bookmark">
			windows系统，设备和驱动器中的wps云盘，如何删除？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：windows系统，设备和驱动器中的wps云盘，如何删除？
第一步：电脑右下角，鼠标右键点击wps图标
第二步：点击关闭wps云盘。
第三步：回到设备和驱动器，查看wps云盘图标已关闭。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aa0f5063faf41ae814ac5dd5ee95be5/" rel="bookmark">
			关于Linux下分区扩大(基于CentOS 7)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步: 首先先通过df命令查看当前分区状况，确定要扩大容量的目标
第二步: 通过gdisk或者fdisk命令创建新的分区(注意gdisk和fdisk的区别,选错命令可能会导致开机出现错误, gdisk用于创建GPT分区, fdisk用于创建MBR分区)
如果对gdisk的选项不熟悉，可以输入?进行查询，具体选项请自行查看，我们这里输入n开始创建分区, 接下来两个选项保持默认.
注意到第三个选项需要选择创建的分区大小, 可以通过直接输入+ num[K/M/G]
选择分区大小，或者自行计算扇区大小，这里选择创建1GB的分区
接下来选择输入分区的GUID, 这里我们需要扩大分区，所以选择LVM的GUID(通过L可以查看GUID列表)
创建分区完成，将创建的分区写入磁盘，通过选择w选项完成此操作
使用partprobe命令使更改立即生效
以上创建新分区完成，接下来开始扩大对应LV(逻辑卷轴)的容量, 这里涉及到PV,VG,LV的知识，感兴趣的同学自行百度。
第三步: 查看当前PV，并把新创建的分区建立成PV
pvscan命令可以显示当前系统中的PV，pvcreate命令创建一个新的PV
第四步: 查看待扩大容量的LV所在的VG，并使用新创建的PV扩大该VG的容量，以便后续扩大LV的容量.
首先使用lvscan命令查看当前系统中的LV，并找到root对应的VG(此处为centos)
使用vgdisplay查看centos VG的相关信息
开始扩大VG容量
使用vgextend命令(vgextend centos /dev/sda4)扩大分区
vgextend命令格式: vgextend VG名 分区名
含义: 将某分区加入到某VG中，扩大该VG的容量.
将上图中的VG Size与前一张图进行比对，发现VG容量扩大了1GB, 这正好是分区/dev/sda4的容量
VG的容量扩大完毕，接下来开始扩大LV的容量
第五步: 扩大LV的容量，并将其立刻改变
使用lvextend命令对LV的容量进行扩大
lvextend命令选项: -L 输入+ num(K/M/G)进行扩大，系统对自动计算需要的PE块
-l 输入+ num, 系统会根据你输入的PE块数量进行扩大
此时虽然你对LV的容量进行了扩大，但是文件系统的容量并没有扩大,需要使用xfs_growfs对文件系统的容量进行操作.
此时我们输入df -h命令进行查看时，发现root的空间终于扩大了
以上为扩大某某分区的全部操作, 注意仅仅针对使用LVM的分区哟！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f912e37cd2b6f9631a1c1ee67b2c3076/" rel="bookmark">
			uni-app H5编译 出现npx browserslist --update-db 解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在终端，切换到HBuilderX安装目录
再次运行：npx browserslist --update-db 即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31d293403778e8b65308999f1b68ac7e/" rel="bookmark">
			web期末作业设计网页：动漫网站设计——海绵宝宝(6页) HTML&#43;CSS&#43;JavaScript 学生DW网页设计作业成品 动漫网页设计作业 web网页设计与开发 html实训大作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见网页设计作业题材有 个人、 美食、 公司、 学校、 旅游、 电商、 宠物、 电器、 茶叶、 家居、 酒店、 舞蹈、 动漫、 明星、 服装、 体育、 化妆品、 物流、 环保、 书籍、 婚纱、 游戏、 节日、 戒烟、 电影、 摄影、 文化、 家乡、 鲜花、 礼品、 汽车、 其他 等网页设计题目, A+水平作业, 可满足大学生网页大作业网页设计需求, 喜欢的可以下载! 嗨，欢迎来到深巷积木青春的小店。这篇文章主要讲解HTML5＋CSS3制作海绵宝宝网站，请一起学习吧。 作品目录 一、📚网站介绍
二、🔗网站效果
🧩1.图片演示
三、💒网站代码
二、📚网站介绍 📔网站布局方面：计划采用目前主流的、能兼容各大主流浏览器、显示效果稳定的浮动网页布局结构。
📓网站程序方面：计划采用最新的网页编程语言HTML5+CSS3+JS程序语言完成网站的功能设计。并确保网站代码兼容目前市面上所有的主流浏览器，已达到打开后就能即时看到网站的效果。
📘网站素材方面：计划收集各大平台好看的图片素材，并精挑细选适合网页风格的图片，然后使用PS做出适合网页尺寸的图片。
📒网站文件方面：网站系统文件种类包含：html网页结构文件、css网页样式文件、js网页特效文件、images网页图片文件；
📙网页编辑方面：网页作品代码简单，可使用任意HTML编辑软件(如：​​Dreamweaver、HBuilder、Vscode 、Sublime 、Webstorm、Text 、Notepad++​​​ 等任意html编辑软件进行运行及修改编辑等操作)。
其中：
(1)📜html文件包含：其中index.html是首页、其他html为二级页面；
(2)📑 css文件包含：css全部页面样式,文字滚动, 图片放大等；
(3)📄 js文件包含：js实现动态轮播特效, 表单提交, 点击事件等等(个别网页中运用到js代码)。
三、🔗网站效果 四、💒代码展示 代码说明：以下仅展示部分代码供参考~
🧱HTML结构代码 &lt;!DOCTYPE html&gt; &lt;html lang="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31d293403778e8b65308999f1b68ac7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/890679433e11aa0fe3dc2ccd5fca82a9/" rel="bookmark">
			docker报错：You have to remove (or rename) that container to be able to reuse that name
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 You have to remove (or rename) that container to be able to reuse that name
错误原因：您必须删除（或重命名）该容器才能重用该名称。
解决：
查看docker 启动进程
docker ps -a 杀死指定进程：
docker rm -f CONTAINER ID 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20ec60f8ebfdb6e996932b8d5a3322e7/" rel="bookmark">
			Kali Linux 学习日记1 - Nmap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Nmap简介Nmap功能Nmap扫描命令1、sP/sn PING扫描2、sS SYN半开放扫描3、sT TCP扫描4、sU UDP扫描5、sF FIN扫描6、sV 端口版本服务检测扫描7、O 操作系统类型探测8、T 设置时间模板9、网段扫描格式10、从文件中读取需要扫描的IP列表11、A 综合扫描 Python实现Nmap功能 Nmap简介 Nmap是一个综合性的、特性丰富的端口扫描工具，用来探测计算机网络上的主机和服务。Nmap发送特定数据包到目标主机，然后对返回的数据包进行分析。
Nmap功能 主机发现 端口扫描 服务 / 版本检测 支持探测脚本的编写 Nmap扫描命令 1、sP/sn PING扫描 下面展示一些 内联代码片。
nmap -sP &lt;target ip&gt; 一般利用sP命令扫描内网的一个ip范围，用于内网主机发现。
nmap -sP 192.168.124.1-255 PING扫描只用于查看主机是否存在于网络中，并不能看到是否开放端口。PING扫描需要ROOT权限。
几种指定目标的方法：
1|nmap -sP 192.168.124.10 192.168.124.20 2|nmap -sP 192.168.124.1-255 3|nmap -sP -iL Ahost	//扫描名为Ahost文件所包含的主机ip 4|nmap -sP 192.168.124.0/24 -exclude 192.168.124.91	//	除了.91的主机 5|nmap -sP 192.168.124.0/24 -excludefile Ahost//	除了Ahost文件包含的主机 2、sS SYN半开放扫描 nmap -sS &lt;target ip&gt; sS扫描不需要完整的握手就能获得远程主机的信息。Nmap发送SYN包到远程主机，但是它不会产生任何会话，因此不会在目标主机上产生任何日志记录。若Nmap命令没有指出扫描类型，默认为TCP SYN描扫。需要ROOT权限。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20ec60f8ebfdb6e996932b8d5a3322e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c12165080b00812fab3665737b5a5cf/" rel="bookmark">
			使用 T5 模型来做文本分类任务的一些总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 T5text2text 模型如何做 text classification？优化器和调度器(optimizer and scheduler)学习率设置完整训练代码Reference T5 paper：Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer
T5 本身是一个 Text-to-Text 模型，但其不仅仅能做传统的 text2text 任务 (如对话、QA、文本摘要等等)，也能做文本分类这种任务，T5 基本可以用于所有的 NLP 任务，并且拥有很好的性能。
text2text 模型如何做 text classification？ 简单来说输入就是文本句子，输出就是类别词（如 positive, negative ），当然，这可能有一个问题：模型生成的输出的单词如果不是类别词呢？但作者也在论文中说了，一个在相应数据集上训练过的 T5 模型如果在做文本分类时，模型的输出肯定是类别词，不会出现非类别词，如果模型输出是非类别词，那么很有可能就是模型训练不充分。
在训练时，以下代码即可，其中 labels 就是类别词的编码结果
outputs = model(input_ids=input_ids, attention_mask=attention_mask, labels=labels) 推理的代码如下：
out = model.generate(input_ids=input_ids, attention_mask=attention_mask, max_length=2) 具体如何做推理的代码可以参考：T5: classification using text2text?
优化器和调度器(optimizer and scheduler) 作者在论文中写了在训练时使用的优化器是 Adafactor，Adafactor 是专门为 Transformer 类模型所设计的，相比于 Adam 占用更少的显存，能够有效减少训练时所需的显存。
paper: Adafactor: Adaptive Learning Rates with Sublinear Memory Cost
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c12165080b00812fab3665737b5a5cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/709862c698f4a5f6603629b895b99691/" rel="bookmark">
			AI编程助手 Kodezi ： 记录、分享一个 VS code 插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 0. 概述1. 安装 / 功能介绍1.1 安装1.2 功能介绍1.2.1 Debug1.2.2 代码优化1.2.3 代码转换1.2.4 逐行注释1.2.5 多行注释1.2.6 生成文档1.2.7 生成代码 2. KodeziChat 聊天机器人2.1 聊天机器人功能介绍2.2 如何使用 KodeziChat ？ 3. Kodezi 版本介绍3.1 免费版3.2 专业版3.3 团队版 4. 结语5. 附：注册方式 0. 概述 了解 Kodezi！
Kodezi 是一个 AI 开发平台，它提供的功能可以最大限度地提高编程效率。
Kodezi 使用大参数语言模型，这些模型是在来自各种开源场所的自然语言和编程语言集合上训练的；
使用详细信息自动调试代码；根据上下文优化您的代码；将代码从一种编程语言转换为另一种编程语言；为您的代码生成文档；从自然语言指令生成代码；Kodezi Chatbot 程序员的首选聊天机器人。 1. 安装 / 功能介绍 1.1 安装 Kodezi 可以在VScode 商店中找到并安装，安装完后，可在 vscode 侧边栏中找到，如图： 并进行登录
注册登录后，即为免费版用户，默认 50学分/月 供功能使用扣除，每使用一次扣 2 分。
官方推荐用谷歌邮箱登录（不需额外注册和验证，直接登录）
Kodezi 插件支持在 Windows、Linux、以及macOS. 系统上的安装&gt;
1.2 功能介绍 Kodezi 有7 种具有特殊特性的不同功能，包括调试/自我纠正、优化、转换等等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/709862c698f4a5f6603629b895b99691/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aab11d8c24592fcdf1b66dd8bb5da205/" rel="bookmark">
			Springboot 返回文件给前端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先导入数据到excel中 package com.ds.crawler.search.service.thirdParty; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.util.Date; import java.util.List; import com.ds.model.CrawlerModel; import com.ds.model.CrawlerResultModel; import org.apache.poi.ss.usermodel.Cell; import org.apache.poi.ss.usermodel.Row; import org.apache.poi.ss.usermodel.Sheet; import org.apache.poi.xssf.usermodel.XSSFWorkbook; public class ExportToExcel { public static Boolean exportToExcel(List&lt;CrawlerModel&gt; products){ // 创建工作簿对象 XSSFWorkbook workbook = new XSSFWorkbook(); // 创建工作表对象 Sheet sheet = workbook.createSheet("products"); // 创建表头行 Row header = sheet.createRow(0); header.createCell(0).setCellValue("ID"); header.createCell(1).setCellValue("site"); header.createCell(2).setCellValue("name"); header.createCell(3).setCellValue("price"); header.createCell(4).setCellValue("unit"); header.createCell(5).setCellValue("time"); header.createCell(6).setCellValue("source"); header.createCell(7).setCellValue("type"); header.createCell(8).setCellValue("size"); header.createCell(9).setCellValue("color"); header.createCell(10).setCellValue("img"); header.createCell(11).setCellValue("material"); header.createCell(12).setCellValue("rank"); // 填充数据 int rowNum = 1; for (CrawlerModel product : products) { Row row = sheet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aab11d8c24592fcdf1b66dd8bb5da205/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f22b50dfe1f2306361d7f899e2aac88e/" rel="bookmark">
			【FPGA实验0】Quartus建立工程文件以及仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 FPGA的第一课，学习Quartus编程运行仿真烧录的这一个流程，以一个十位的计数器为例。
芯片商家：ALTERA
编程软件：Quartus II
试验箱上的芯片型号：EP4CE6E22C8N
目录 一、新建一个工程二、编写程序三、编译1、可以查看所用到的资源：2、如何看生成的电路3、打开文件夹，可以看到需要烧录的文件 一、新建一个工程 打开软件后会会弹出一个窗口，点击【创建向导】
第一步：设置工程名和顶层硬件模块名
第二步：加入原先写好的文件，如若没有就直接点击下面的【next】即可
若要添加文件，则点击这个按钮
然后要记得点击【Add】不然添加进去的是一个只有文件名的空文件
第三步：根据试验箱上芯片的型号我选择【Cydone IV E】系列，设备型号【EP4CE6E22C8】。
第四步：选择仿真模式为【ModelSim】
第五步：列出来刚刚的选择，确认无误后，点击【Finish】
到此，就完成了工程的新建。
二、编写程序 1、新建一个【Verilog HDL File】文件
然后就开始码代码，以一个十位的计数器为例
三、编译 点击菜单栏中的三角形进行编译
若编译无误则会弹出如下提示：
1、可以查看所用到的资源： 2、如何看生成的电路 可以看到新建的电路如下：
3、打开文件夹，可以看到需要烧录的文件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c6485a6ff2a01c96f3d4ea599ce5add/" rel="bookmark">
			使用原生JS实现QQ好友、QQ空间、新浪微博、腾讯微博分享功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用原生JS实现QQ好友、QQ空间、新浪微博、腾讯微博分享功能 点这里查看demo效果
在分享功能中我们通常用的最多的几个配置参数：分享的标题、分享的内容链接地址、分享描述信息以及分享的缩略图地址，具体实现代码如下：
function (window, document) {
var shareMethodObj = {
//分享到腾讯微博
sharetotencentweibo: function (title, url, picurl) {
// 分享的标题
title = encodeURIComponent(title || document.title);
// 分享内容链接
url = encodeURIComponent(url || window.location.href);
// 分享图片的路径，多张图片以＂|＂隔开，可选参数
picurl = encodeURIComponent(picurl || '');
var shareqqstring = 'http://v.t.qq.com/share/share.php?title=' + title + '&amp;url=' + url + '&amp;pic=' + picurl;
// 在新窗口中打开
window.open(shareqqstring, '_blank');
},
//分享到新浪微博
sharetosina: function (title, url, picurl) {
// 分享的标题
title = encodeURIComponent(title || document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c6485a6ff2a01c96f3d4ea599ce5add/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0014efdf8304f4cea5f32d98d399e96c/" rel="bookmark">
			ubantu python完整安装示例（ubantu16.04 python3.7.1演示）、包含cmake完整安装流程（主要适用于arm linux机器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 零、前言一、准备工作（重要）1.下载并安装cmake1.0准备1.1预编译包安装1.2源码编译安装1.3配置环境变量 2.下载必要的依赖 二、获取Python源码包三、Python编译安装四、Python链接并验证更新pip下载源删除pip下载源查看当前使用的下载源 五、Python配置环境变量 零、前言 为什么需要使用源码编译安装？
使用apt-get下载验证python3安装时，（sudo apt-get install python3) 你可能会看到python3 is already the newest version (3.5.1-3)。即你提供的仓库中不存在更高版本或者通过apt-get暂时只能安装这么高的版本。
如果你没看到这个提示，那么就可能单纯是你的仓库中没有这个版本的python,可以如下操作：
apt-get install -y software-properties-common add-apt-repository ppa:deadsnakes/ppa 或者add-apt-repository ppa:jonathonf/python-3.7 apt-get update apt-get install python3.7 或者尝试添加软件源：
vi /etc/apt/sources.list
# 阿里云的软件源 deb http://mirrors.aliyun.com/ubuntu/ vivid main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ vivid-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ vivid-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ vivid-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ vivid-backports main restricted universe multiverse #ubuntu 有科学上网可以加上，否则太慢，没用 # deb http://archive.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0014efdf8304f4cea5f32d98d399e96c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/156/">«</a>
	<span class="pagination__item pagination__item--current">157/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/158/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>