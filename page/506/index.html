<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c701b819f0ec0a05fa56a79c39284f6/" rel="bookmark">
			二分查找伪码描述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 int binary_search(vector&lt;int&gt;v,int key) { int left=1,right=v.size()-1,mid; while(left&lt;=right) { mid=(left+right)/2; if(v[mid]&lt;key) left=mid+1; else if(v[mid]&gt;key) right=mid-1; else if(v[mid]==key) return mid; } return -1; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5690ee4470b9aa64d9a2102dbb64e01/" rel="bookmark">
			Springboot整合security与jwt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍springboot2.0.4整合security,jwt,redis,mybatis,druid,swagger-ui 先上github:https://github.com/Acumes/spring-security-jwt 备用下载地址：https://download.csdn.net/download/a295277302/10584376
下面介绍项目中的内容
部分pom.xml
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;dependencies&gt;.....&lt;/dependencies&gt; 先整合数据源与mybatis application.properties
server.port=8082 #htf datasource spring.datasource.htf.type=com.alibaba.druid.pool.DruidDataSource spring.datasource.htf.url=jdbc:mysql://localhost:3306/platform?characterEncoding=utf8&amp;allowMultiQueries=true spring.datasource.htf.username=root spring.datasource.htf.password=123456 spring.datasource.htf.driverClassName=com.mysql.jdbc.Driver spring.datasource.htf.filters=stat,config spring.datasource.htf.maxActive=20 spring.datasource.htf.initialSize=1 spring.datasource.htf.maxWait=6000 spring.datasource.htf.minIdle=1 spring.datasource.htf.timeBetweenEvictionRunsMillis=60000 spring.datasource.htf.minEvictableIdleTimeMillis=300000 spring.datasource.htf.validationQuery=select 'x' spring.datasource.htf.testWhileIdle=true spring.datasource.htf.testOnBorrow=true spring.datasource.htf.testOnReturn=true spring.datasource.htf.poolPreparedStatements=true spring.datasource.htf.maxOpenPreparedStatements=20 spring.datasource.htf.maxPoolPreparedStatementPerConnectionSize=20 spring.redis.database=2 spring.redis.host=192.168.1.105 spring.redis.port=6379 spring.redis.timeout=5000 spring.redis.jedis.pool.max-active=300 spring.redis.jedis.pool.max-idle=100 spring.redis.jedis.pool.min-idle=0 spring.redis.jedis.pool.max-wait=-1 logging.level.logging.com.htf.dao=debug security.jwt.secret=k09BQnaF #20Days security.jwt.expiration=1728000 DataSourceConfig
@Configuration public class DataSourceConfig { @Primary @Bean(name = "htfDataSource") @ConfigurationProperties("spring.datasource.htf") public DruidDataSource htfDataSource() { return new DruidDataSource(); } } 添加mybatis配置 MybatisDataSourceConfig
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5690ee4470b9aa64d9a2102dbb64e01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3175de2099bca083881cb7fd785f2220/" rel="bookmark">
			HashMap优化的几种简单方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		画重点，面试加分
先贴出HashMap源码普及一下几个概念：
public class HashMap&lt;K,V&gt;extends AbstractMap&lt;K,V&gt;implements Map&lt;K,V&gt;, Cloneable, Serializable { // 默认的初始容量（容量为HashMap中桶的数目）是16，且实际容量必须是2的整数次幂。 static final int DEFAULT_INITIAL_CAPACITY = 16; // 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换） static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认加载因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 存储数据的Entry数组，长度是2的幂。 // HashMap是采用拉链法实现的，每一个Entry本质上是一个单向链表 transient Entry[] table; // HashMap的大小，它是HashMap保存的键值对的数量 transient int size; // HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子） int threshold; // 加载因子实际大小 final float loadFactor; // HashMap被改变的次数 transient volatile int modCount; 通过以上源码可以看到在源码中定义了一下几个常量：
默认加载因子：这东西说白了就是用来划分整个HashMap容量的百分比，这里默认0.75就是说占用总容量的75%默认初始容量：如果你不在构造函数中传值，new一个HashMap,他的容量就是2的4次方（16），并且增长也得是2的整数次方（幂）阀值：首先这个值等于默认加载因子和初始容量的乘机；他的作用是用来预警的，如果HashMap中的容量超过这个阀值了，那就会执行扩容操作，低于则没事 很多人忽视的加载因子Load Factor 加载因子存在的原因，还是因为减缓哈希冲突，如果初始桶为16，等到满16个元素才扩容，某些桶里可能就有不止一个元素了。所以加载因子默认为0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3175de2099bca083881cb7fd785f2220/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ea90a9d20a3e92f639791e1844b5eb2/" rel="bookmark">
			iphone日历上的红色加号变灰色了,事件写入不显示，如何更改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iphone 5s日历上的红色加号变灰色的原因可能是icloud设置里面打开了【日历】的应用，具体关闭步骤如下：
1、打开手机页面，点击【设置】
2、找到【icloud】设置点击进去
3、找到icloud里面的【日历】
4、点击有右边的绿色按钮关闭日历的icloud功能
5、关闭后再打开日历，右上角就会有红色的加号【+】了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8800daea2fabbd88605d7089d252009/" rel="bookmark">
			zookeeper单机部署分布式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		zookeeper下载地址http://apache.org/dist/zookeeper/
上传到服务器 或者使用wget下载
wget http://apache.org/dist/zookeeper/zookeeper-3.4.13/zookeeper-3.4.13.tar.gz 解压
tar zxvf zookeeper-3.4.13.tar.gz 进入到conf目录
cd zookeeper-3.4.13/conf/ 复制配置文件cfg
cp zoo_sample.cfg zoo-slave1.cfg 修改配置文件
dataDir=/opt/zookeeper_1/data dataLogDir=/opt/zookeeper_1/log # the port at which the clients will connect clientPort=2181 #分布式配置 server.1=192.168.1.105:2888:3888 server.2=192.168.1.105:2889:3889 server.3=192.168.1.105:2890:3890 复制多两份配置文件，因为zookeeper配置分布式要奇数
cp zoo-slave1.cfg zoo-slave2.cfg cp zoo-slave1.cfg zoo-slave3.cfg 只需要修改配置中的路径即可
# zoo-slave2.cfg dataDir=/opt/zookeeper_2/data dataLogDir=/opt/zookeeper_2/log # zoo-slave3.cfg dataDir=/opt/zookeeper_3/data dataLogDir=/opt/zookeeper_3/log 之后添加文件夹
mkdir -p /opt/zookeeper_1/data mkdir -p /opt/zookeeper_2/data mkdir -p /opt/zookeeper_3/data 生成myid文件
echo "1" &gt;&gt; /opt/zookeeper_1/data/myid echo "2" &gt;&gt; /opt/zookeeper_2/data/myid echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8800daea2fabbd88605d7089d252009/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbaf67dd51ec805ed4593d36c2908243/" rel="bookmark">
			堆排序算法（图解详细流程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		堆排序的时间复杂度O(N*logN),额外空间复杂度O(1)，是一个不稳定性的排序
目录
一 准备知识
1.1 大根堆和小根堆
二 堆排序基本步骤
2.1 构造堆
2.2 固定最大值再构造堆
三 总结
四 代码
一 准备知识 堆的结构可以分为大根堆和小根堆，是一个完全二叉树，而堆排序是根据堆的这种数据结构设计的一种排序，下面先来看看什么是大根堆和小根堆
1.1 大根堆和小根堆 性质：每个结点的值都大于其左孩子和右孩子结点的值，称之为大根堆；每个结点的值都小于其左孩子和右孩子结点的值，称之为小根堆。如下图
我们对上面的图中每个数都进行了标记，上面的结构映射成数组就变成了下面这个样子
还有一个基本概念：查找数组中某个数的父结点和左右孩子结点，比如已知索引为i的数，那么
1.父结点索引：(i-1)/2（这里计算机中的除以2，省略掉小数）
2.左孩子索引：2*i+1
3.右孩子索引：2*i+2
所以上面两个数组可以脑补成堆结构，因为他们满足堆的定义性质：
大根堆：arr(i)&gt;arr(2*i+1) &amp;&amp; arr(i)&gt;arr(2*i+2)
小根堆：arr(i)&lt;arr(2*i+1) &amp;&amp; arr(i)&lt;arr(2*i+2)
二 堆排序基本步骤 基本思想：
1.首先将待排序的数组构造成一个大根堆，此时，整个数组的最大值就是堆结构的顶端
2.将顶端的数与末尾的数交换，此时，末尾的数为最大值，剩余待排序数组个数为n-1
3.将剩余的n-1个数再构造成大根堆，再将顶端数与n-1位置的数交换，如此反复执行，便能得到有序数组
2.1 构造堆 将无序数组构造成一个大根堆（升序用大根堆，降序就用小根堆）
假设存在以下数组
主要思路：第一次保证0~0位置大根堆结构（废话），第二次保证0~1位置大根堆结构，第三次保证0~2位置大根堆结构...直到保证0~n-1位置大根堆结构（每次新插入的数据都与其父结点进行比较，如果插入的数比父结点大，则与父结点交换，否则一直向上交换，直到小于等于父结点，或者来到了顶端）
插入6的时候，6大于他的父结点3，即arr(1)&gt;arr(0)，则交换；此时，保证了0~1位置是大根堆结构，如下图：
(友情提示：待交换的数为蓝色，交换后的数为绿色)
插入8的时候，8大于其父结点6，即arr(2)&gt;arr(0),则交换；此时，保证了0~2位置是大根堆结构，如下图
插入5的时候，5大于其父结点3，则交换，交换之后，5又发现比8小，所以不交换；此时，保证了0~3位置大根堆结构，如下图 插入7的时候，7大于其父结点5，则交换，交换之后，7又发现比8小，所以不交换；此时整个数组已经是大根堆结构 2.2 固定最大值再构造堆 此时，我们已经得到一个大根堆，下面将顶端的数与最后一位数交换，然后将剩余的数再构造成一个大根堆
（友情提示：黑色的为固定好的数字，不再参与排序） 此时最大数8已经来到末尾，则固定不动，后面只需要对顶端的数据进行操作即可，拿顶端的数与其左右孩子较大的数进行比较，如果顶端的数大于其左右孩子较大的数，则停止，如果顶端的数小于其左右孩子较大的数，则交换，然后继续与下面的孩子进行比较
下图中，5的左右孩子中，左孩子7比右孩子6大，则5与7进行比较，发现5&lt;7，则交换；交换后，发现5已经大于他的左孩子，说明剩余的数已经构成大根堆，后面就是重复固定最大值，然后构造大根堆
如下图：顶端数7与末尾数3进行交换，固定好7，
剩余的数开始构造大根堆 ，然后顶端数与末尾数交换，固定最大值再构造大根堆，重复执行上面的操作，最终会得到有序数组
三 总结 到这里，大家应该对堆排序都有了自己的见解，我们对上面的流程总结下：
1、首先将无需数组构造成一个大根堆（新插入的数据与其父结点比较）
2、固定一个最大值，将剩余的数重新构造成一个大根堆，重复这样的过程
四 代码 代码中主要两个方法：
1、将待排序数组构造成一个大根堆（元素上升）
2、固定一个最大值，将剩余的数再构造成一个大根堆（元素下降）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbaf67dd51ec805ed4593d36c2908243/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7edd81233efad230a71fd83b12b37a09/" rel="bookmark">
			粒子群算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、解决最优化问题的方法：
1》传统搜索方法：保证能找到最优解
2》启发式搜索：不能保证找到最优解
二、定义
粒子群优化算法（Particle Swarm Optimization，PSO）是自然计算的一个分支，是一种模拟自然界的生物活动的随机搜索算法。
群体迭代，粒子在解空间追随最优的粒子进行搜索。
三、基本原理：
基础：信息的社会共享
四、算法描述：
1》鸟群：假设一个区域，所有的鸟都不知道食物的位置，但是它们知道当前位置离食物还有多远。
2》算法本质：每个解看作一只鸟，称为“粒子（Particle）”，所有的粒子都有一个适应值，每个粒子都有一个速度决定它们的飞翔方向和距离，粒子们追随当前最优粒子在解空间中搜索。
3》PSO算法：初始化为一群随机粒子，通过迭代找到最优。每次迭代中，粒子通过跟踪“个体极值（pbest）”和“全局极值（gbest）”
来更新自己的速度和位置。
3.1》 pbest：每一个个体在它移动或搜索过程中记录的最优的值。
3.2》gbest：整个群体在所有的搜索过程中，找到的最佳的值。
总结：
口每个寻优的问题解都被想像成一只鸟，称为“粒子”。所有粒子都在一个D维空间进行搜索。
口所有的粒子都由一个fitness function确定适应值以判断目前的位置好坏。
口每一个粒子必须赋予记忆功能，能记住所搜寻到的最佳位置。
口每一个粒子还有一个速度以决定飞行的距离和方向。这个速度根据它本身的飞行经验以及同伴的飞行经验进行动态调整。
4》粒子速度和位置的更新（单位时间）：
口粒子速度更新公式包含三部分：
第一部分为粒子先前的速度
第二部分为“认知”部分，表示粒子本身的思考，可理解为粒子当前位置与自己最好位置之间的距离。
第三部分为“社会”部分，表示粒子间的信息共享与合作，可理解为粒子i当前位置与群体最好位置之间的距离品。
五、参数设置：
1》群体大小-m
m是一个整型参数.
m很小：陷入局优的可能性很大。
m很大：PSO的优化能力很好，当群体数目增长至一定水平时，再增长将不再有显著的作用。
2》权重因子：
惯性因子 ：ω ω=1：基本粒子群算法。
ω=0：失去对粒子本身的速度的记忆。
学习因子：c1、c2
C1 = 0,无私型粒子群算法，“只有社会，没有自我”但是易迅速丧失群体多样性，易陷于局优而无法跳出
C2 = 0,自我认知型粒子群算法，“只有自我，没有社会”，完全没有信息的社会共享导致算法收敛速度缓慢
C1 c2 都不为0 ，称为完全型粒子群算法。完全型粒子群算法更容易保持收敛速度和搜索效果的均衡，是较好的选择。
3》最大速度 Vm：
作用:在于维护算法的探索能力与开发能力的平衡。
Vm较大时，探索能力增强，但粒子容易飞过最优解·。
Vm较小时，开发能力增强，但容易陷入局部最优。
Vm一般设为没维变量变化范围的10%-20%。
4》邻域的拓扑结构·：
粒子群算法的邻域拓扑结构包括两种，一种是将群体内所有个体都作为粒子的邻域。另一种是只将群体中的部分个体作为粒子的邻域。
邻域拓扑结构——&gt;群体历史最优位置，由此将粒子群算法分全局粒子群算法和局部粒子群算法。
全局粒子群算法：（1）粒子自己历史最优值 （2）粒子群体的全局最优值
局部粒子群算法：（1）粒子自己历史最优值 （2）粒子邻域内粒子的最优值
邻域随迭代次数的增加线性增大，最后邻域扩展到整个粒子群。
经过实践证明：全局版本的粒子群算法收敛速度快，但是容易陷入局部最优。局部版本的粒子群算法收敛速度慢，但是很难陷入局部最优。现在的粒子群算法大都在收敛速度与摆脱局部最优这两个方面下功夫。其实这两个方面是矛盾的。看如何更好的折中了。
5》停止准则：
（1）最大迭代次数
（2）可接受的满意解
6》粒子空间的初始化：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7edd81233efad230a71fd83b12b37a09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dcf8d767c507486bdd9f47d56a4407d/" rel="bookmark">
			Docker 学习笔记（四） docker-compose  篇 搭建多容器 ghost博客系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker-compose搭建多容器 ghost博客系统 一.下载安装 docker-compose [root@localhost data]# curl -L https://github.com/docker/compose/releases/download/1.9.0/docker-compose-$(uname -s)-$(uname -m) &gt; /usr/local/bin/docker-compose % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 617 0 617 0 0 121 0 --:--:-- 0:00:05 --:--:-- 195 100 7857k 100 7857k 0 0 148k 0 0:00:52 0:00:52 --:--:-- 209k [root@localhost data]# cd /usr/local/bin/ [root@localhost bin]# ll 总用量 7860 -rw-r--r--. 1 root root 8045957 8月 3 22:13 docker-compose [root@localhost bin]# cd docker-compose -bash: cd: docker-compose: 不是目录 [root@localhost bin]# ls -l /usr/local/bin/docker-compose -rw-r--r--.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dcf8d767c507486bdd9f47d56a4407d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5fbe99eab428965f7dc91e9e216e7fe/" rel="bookmark">
			求职面试准备——自我介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 为充分准备9月份秋招，作为一个小白四处学习如何准备面试的自我介绍，接下来将会以自身经历为例，结合各路大神的方法进行面试相关知识总结和整理。
面试的自我介绍 自我介绍的目的：给面试官一定的时间看一下你的简历，确定简历的重点。（1）获取初步印象，（2）为接下来的问题提供线索。 自我介绍前的准备：【来自知乎ZoranSeven】 梳理自己的经历，挖掘自己的亮点 分析公司的需求，了解公司的文化 做出挑选并重组，完成一份充满策略的自我介绍 面试万能公式： 个人信息+需求分析+匹配岗位的特征+逻辑/事例论证+礼貌自信+反复练习=offer
自我介绍攻略1（墨宝爸爸） 两分钟时间自我介绍，在30秒之内你必须要简明扼要地说完简历上的精华内容，剩下一分半你必须争取用你讲的东西打动面试官，让他们头抬起来看你，一旦抬头，有了目光交流和他们感兴趣的事情，那么成功率就会大很多。问题来了，这一分半的时间你应该讲什么？几个要点把握住，一是要让对方确认你对这个岗位的了解和喜爱，二是说明自身具备从事且能做好的特质，三是要举出简短但能印证前面所说几点的具体事例来。 各位面试官下午好！我是应聘xx岗位的xxx，如您在简历中所见，我的基本情况是……，对于今天要应聘的岗位，我的理解是它主要从事……。这样的岗位对我来说很有挑战性，同时我认为我也具备了胜任这个岗位的自身条件。我在大学期间/实习期间/家庭经历/其他相关经历期间，我做了……，虽然这和我要应聘的岗位不相关，但是它对于个人能力特质的要求是共同的，都需要具备……等能力，而我做的很好，这也是我来到这里的底气所在……。关于我的自我介绍就到这里，接下来我把宝贵的时间交给您，请各位面试官提问，谢谢！ 【为接下来的提问留下伏笔】上面一个针对应届生的模板，重点应该讲你曾做得怎么样，你有什么值得我录用你，而不是去说你入职后会怎么样，比如你会工作敬业，友爱同事，服从指挥云云，未来的事情你还真的说不算啊。另外记得在自我介绍中留下伏笔，对某个面试官可能感兴趣的个人经历举重若轻地一笔带过，很有可能在自我介绍完后面试官就会追着这个话题来问。这样一来，面试的节奏就被你掌握了 自我介绍攻略2（来自知乎Zack） 1. 时长两分钟左右，20句话差不多了。2. 中英文底稿都要准备一份，但是切不可拘泥于底稿。背书的效果很差的，面试官不会喜欢，你可以恰当口语化一点，跟着场子气氛来。3. 介绍顺序：姓名学校专业 -&gt; 校内表现（成绩、各种荣誉……挑闪光点说，因为你说的，待会儿可能就会变成他面的重点） -&gt; 校外表现（实习等） -&gt; 个人兴趣（这个optional看时间） -&gt; 跪舔公司（哈哈这个真的必须有啊，反映出你忠心耿耿~）4. 牢记：自我介绍真的没那么重要，重要的是后面的问题！！！问题答得好才是硬实力，其他都是附加！ 自我介绍攻略3 采用“3个关键词+支撑案例”的方法准备一篇自我介绍适用大多数场合。具体操作为： （1）一句话概括总结总结 我是XX，XX学校XX专业，非常高兴参加XX公司XX岗位的面试。正如在简历中看到的， 我希望通过3个关键词来介绍自己。 （2）3个关键词+支撑案例： 3个关键词要根据不同的场景，不同的行业和所需技能等进行更改。3个词的顺序要与简历的顺序一致。第一个词针对教育背景，可以用“快速学习”，“复合专业”，“数理背景”等，第二个词是针对工作技能和项目经验，这一块可以用“高效负责”，针对不同的岗位，比如研究性强的，算法岗等，可以用“潜心研究”，然后重点列举之前的工作项目中的研究成果和经验，会用什么软件，发表了什么学术论文等，第三个词用来结合课外活动和特长，可以说自己“善于沟通”“逻辑性强”，然后可以说你的学生会，社团等经历，一定要契合要求，不要顾此失彼。 （3）简明扼要的表明谢意和兴趣。对XX行业XX类型的工作很感兴趣，非常感谢有机会参加这次面试
结合攻略的自我介绍 我是XX，XX学校XX专业，非常高兴参加XX公司XX岗位的面试。正如在简历中看到的， 我希望通过3个关键词来介绍自己。这三个词分别是复合专业，潜心研究，善于沟通。 复合专业，我本科主修专业为物联网工程，研究生主修专业为通信与信息系统专业，本科专业让我对于大数据，云计算等知识有了基本的认知，学会了用编程语言进行项目设计，研究生为主攻方向为图像处理算法，同时学习深度学习知识等，这些知识拓宽了我知识的广度。 潜心研究，主要是对我项目经验的描述，从保研后开始进行图像相关研究，目前已完成3篇EI会议，1篇SCI会议，授权专利1篇，通过这些项目的研究与学习，我学会了利用MATLAB进行处理相关图像分类问题，除此之外，对于计算机视觉相关的东西学会使用Tensorflow框架进行深度学习加以实现。善于沟通是第三个词，主要是来源于我大学担任班级团支书，以及本科生实验室管理员的总结，在担任这些的时候需要组织和协调各个学生之间完成任务分配。基于这些我觉得自己对于XX公司XX岗位非常感兴趣，非常感谢有机会参加这次面试
面试中自我介绍和简历是展示自己的重要东西，需要大家好好准备。需要按照这些小套路让自己发挥得更好！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba39aaed655038e4c9caa35504edcfc7/" rel="bookmark">
			phpstorm 操作 git
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		phpStrom这个php的 IDE完美的集合了git，对于有些对命令行不是很熟悉的同学来说，这可以带来很大的帮助，下面我给大家说一下具体的用法。
1.我们提交自己的代码
a：在我们的项目上，右击，如图所示，相当于 git add ，这个大家都懂。
b：下一步操作，相当于 git commit c: 拉取版本库代码，相当于 git pull
d:推送代码 git push
操作完上面4个步骤，我们就把自己的代码提交了，同时也把同事的代码拉取到了本地。
2.上面1的所有操作我们在一个分支，当我们需要建立新的分支，该如何操作呢，请看下面：
我们IDE的右下角，这个表示我们当前所在的分支，当我们在当前分支执行了上面4个步骤后，我们需要切换到主分支，
在编辑区域右击，如图所示，依次选择，就会出现
也就是我们的所有分支，按照需求我们选择即可
我们也就切换到了我们需要的分支，这个相当于 git checkout *****
这时我们处在了主分支，接下来怎么操作：
a:
首先拉取别人代码
b:合并代码
c:推送
完成上面3步，我们就把我们改动的代码提交到了主分支
接下来我们再次切换到我们自己的分支
我们也要把主分支的代码合并到自己的分支
这个就简单了
之后推送，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6719a350d28a94d340013cb7e5ab2958/" rel="bookmark">
			Android更改popupmenu背景并显示图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		似乎popupmenu是无法单独设置style的，好像是由context决定的，前几天需要设置style，找了很久才找一一个办法，似乎是通过 ContextThemeWrapper 包装一个 Context 然后把 Context 作为参数传递给popupmenu的构造函数
java代码如下
/**************************************************************************/ Context wrapper = new ContextThemeWrapper(this, R.style.MyPopupStyle); /**************************************************************************/ PopupMenu popupMenu = new PopupMenu(wrapper, view); popupMenu.getMenuInflater().inflate(R.menu.user_main_toolbar_add_items, popupMenu.getMenu()); popupMenu.show(); style文件如下
&lt;style name="MyPopupStyle" parent="Widget.AppCompat.PopupMenu"&gt; &lt;item name="android:itemBackground"&gt;@drawable/toolbar_item_selector&lt;/item&gt; &lt;item name="android:textColor"&gt;@color/whitesmoke&lt;/item&gt; &lt;/style&gt; 记得当时使用background属性是无效的，改成了itembackground才有了效果
而且为了使popupmenu可以显示icon，找了一种方法，并没有去查原因，仅仅是用了，代码如下
/**************************************************************************/ Context wrapper = new ContextThemeWrapper(this, R.style.MyPopupStyle); /**************************************************************************/ PopupMenu menu = new PopupMenu(wrapper, view); menu.inflate(R.menu.user_main_toolbar_add_items); MenuPopupHelper menuHelper = new MenuPopupHelper(wrapper, (MenuBuilder) menu.getMenu(), view); menuHelper.setForceShowIcon(true); menuHelper.show(); 而且官方文档好像没搜到这个类，谷歌第一条是源代码，里面有各个方法的说明，包括setForceShowIcon，
本文本来只用来自己参考的，不过可能会有人看到，还是贴出链接，可以看下
MenuPopupHelper。java
转载于:https://www.cnblogs.com/liupy/p/9414250.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cd08c08d878cd81cd2aa6ac1bb9a384/" rel="bookmark">
			Redis报错 : (error) NOAUTH Authentication required.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个错误是因为没有用密码登陆认证 , 先输入密码试试 .
127.0.0.1:6379&gt; auth "yourpassword" 例如密码是‘root’,当出现认证问题时候，输入“auth ‘root’”就可以了.
127.0.0.1:6379&gt; set name "hello" (error) NOAUTH Authentication required. 127.0.0.1:6379&gt; (error) NOAUTH Authentication required. (error) ERR unknown command '(error)' 127.0.0.1:6379&gt; auth "root" 如果输入密码后出现以下提示:
(error) ERR invalid password 那么就是你的密码输入错误 , 如果你忘记密码了, 那么这样做来查看自己的密码 :
进入redis的安装目录（是安装目录的），查看redis.config文件 用记事本打开,找到 “requirepass foobared”,就能找到你的密码了. 比如我的密码是这样的: requirepass 123456 也就是123456 接着cmd 重新进入redis的安装目录 : (1) redis-server.exe redis.windows.conf 打开服务器 (2) 在另一个窗口重新进入该目录, 输入 redis-cli.exe 打开客户端. (3) 在客户端 中 输入 auth “123456” 就可以进去了(你输入的是你查到的密码) . 比如(3), 我的是这样的:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cd08c08d878cd81cd2aa6ac1bb9a384/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b71ff0f6fece483d6d43aa07949edeb8/" rel="bookmark">
			中心极限定理-通俗理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中心极限定理-通俗理解：
1、大量相互独立的随机变量，其求和后的平均值服从正态分布，分布是指按照每个平均值的出现频数去判断分布
2、给定一个任意分布的总体。每次从这些总体中随机抽取 n 个抽样，一共抽 m 次。
然后把这 m 组抽样分别求出平均值。 这些平均值的分布接近正态分布。
本文的例子通过扔骰子，模拟实现，思路如下：
1、进行了5000组实验，每个实验，扔100次骰子并求和，
2、然后对这个和进行分布统计，按照这个和值出现的频数进行统计，然后画图出来
3、改变骰子的1-6数字出现的概率，比如骰子6个面是123416，发现和值仍然服从正态分布
import matplotlib.pyplot as plt import numpy as np import matplotlib # 统计次数 def count_times(count,num): if (str(num) in count.keys()): count[str(num)] = count[str(num)] + 1 else: count[str(num)] = 1 # return count # 随机扔n次骰子，并求点数和 def random_and_sum(n): total = 0; count = {} for i in range(n): num = np.random.randint(1,7) # print("第", i, "次", num) # 即使分布不同，定理也成立 # if num == 5: # num = 1 count_times(count,num) total = num + total # print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b71ff0f6fece483d6d43aa07949edeb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cac1bb0e66e6d9b933dc16bc0f6312c/" rel="bookmark">
			Java多线程并发协同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java并发相关技术：线程池、线程安全（锁）、多线程并发协同、并发集合类、原子类。
什么是并发协同？ 多个线程并发，协同来完成一件事情的过程中，因事情处理的需要，需控制某些线程阻塞，等待另一些线程完成某部分事情，再继续执行的过程。
并发协同原理：
分析并发协同问题的常用思路
并发的是什么？
在什么地方需要协同？
该谁等待？谁来通知？
并发协同的实现方式
多线程协同执行都基于条件等待-通知模式。
方式一：基于传统的Synchronized及Object的wait、notify、notifyAll监视器方法的方式。
方式二：基于Lock及Condition的await、singal方法的等待-通知方式。
方式三：用Java并发包中提供的协同API，来非常方便地实现多线程并发协同。
常用API 一、CountDownLatch倒计数锁存器 用途：协同控制一个或多个线程等待在其它线程中执行的一组操作完成，再继续执行。
用法及原理：
构造方法CountDownLatch(int count)：count指定等待的条件数（操作数、任务数），不可再更改。
等待方法await()：阻塞等待线程直到条件都满足（count等待条件计数减少到0）。如果count已是0，则不会阻塞，继续执行。
条件完成减计数方法countDown()：每一条件完成时，都调用countDown()来对count计数减一。
boolean await(long timeout, TimeUnit unit）：阻塞等待最长时间。返回true表示等待条件到达；false表示条件未到达，但时间到了。
long getCount()：获取当前计数值。该方法常用于调试或测试。
注意：
每个CountDownLatch对象，只可使用一次，计数变为0后，就不可再用了。
适用场景：
1、等待N个条件到达（完成）：new CountDownLatch(N)，等待N个线程完成；等待N个操作完成；等待某操作完成N次。
2、用作开关，让多个等待线程开启继续执行，new CountDownLatch(1)，多个线程await()等待，开关线程countDown()开始。
例：
二、CyclicBarrier循环屏障 用途：协同指定数目的线程，让这些线程在这个屏障前等待，直到所有线程都到达了这个屏障，再一起继续执行。线程继续执行后，这个屏障可再次使用，因此称为循环屏障。
用法及原理：
构造方法CyclicBarrier(int parties)：parties指定由多少个部分（线程）参与，称为参与数。
构造方法CyclicBarrier(int parties, Runnable barrierAction)：barrierAction所有参与者都到达屏障时执行一次的命令。在一组线程中的最后一个线程到达之后（但在释放所有线程之前）在该线程中执行该命令，该命令只在每个屏障点运行一次。若要在继续执行所有参与线程之间更新共享状态，此屏障操作很有用。
等待方法int await() throw InterruptedExection, BrokenBarrierExection：线程执行过程中调用await()方法，表明自己已到达屏障，自己阻塞，等待其他线程到达屏障；当所有参与线程都到达屏障，及等待线程释放数=参与数，则释放所有线程，让它们继续执行。返回int值，是到达的当前的线程的索引号，注意索引号是从parties-1开始递减到0。BrokenBarrierExection屏障被破环异常，当调用await时，或等待过程中屏障被破坏，则会抛出该异常。
int await(long timeout, TImeUnit unit) throw InterruptedExection, BrokenBarrierExection, TimeoutExection：等待指定时长，如果到了时间还不能释放，则抛出TimeoutExection。
int getNumberWaiting()：获取当前等在屏障处的线程数。
boolean isBroken()：判断屏障是否被破坏。
void reset()：重置屏障为初始状态。如果当前线程正在等待，则这些线程被释放并抛出BrokenBarrierExection。
注意事项：
一定要确保有足够的参与者线程，否则会一直阻塞在屏障处。
在线程池中使用时一定要小心，确保池的线程数&gt;=要求的参与数。
适用场景：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cac1bb0e66e6d9b933dc16bc0f6312c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/180a481777e03b029cfe7ac8fc3157ab/" rel="bookmark">
			mybatis-三行代码实现分页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于分页这个，基本上在后台查询数据的时候都会用到，这里介绍一个非常简单的插件工具PageHelper，实现三行代码实现分页（其实也不是三行代码，还有一个实体类工具和mybatis的配置文件需要做一个简单的修改，但是在controller里面确是实实在在的三行代码）。
首先贴上插件工具的Gitup地址：https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md
这里只是用来记录一下自己的实例，可以帮助小白快速实现分页的需求。
使用方法： 1.引入分页插件
引入分页插件有下面2种方式，推荐使用 Maven 方式。
1). 引入 Jar 包 你可以从下面的地址中下载最新版本的 jar 包(建议用链接2下载比较快，直接选用最下面的新版本即可) https://oss.sonatype.org/content/repositories/releases/com/github/pagehelper/pagehelper/
http://repo1.maven.org/maven2/com/github/pagehelper/pagehelper/
由于使用了sql 解析工具，你还需要下载 jsqlparser.jar：
http://repo1.maven.org/maven2/com/github/jsqlparser/jsqlparser/0.9.5/
2). 使用 Maven
在 pom.xml 中添加如下依赖：
&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt; &lt;/dependency&gt; 最新版本号可以从首页查看:http://repo1.maven.org/maven2/com/github/pagehelper/pagehelper/
2. 配置拦截器插件
特别注意，新版拦截器是 com.github.pagehelper.PageInterceptor。（PageInterceptor这个工具类是需要加在项目里面的，后面会贴上，com.github.pagehelper是类所在的包名）。
com.github.pagehelper.PageHelper 现在是一个特殊的 dialect 实现类，是分页插件的默认实现类，提供了和以前相同的用法。
1.在 MyBatis 配置 xml 中配置拦截器插件 &lt;!-- plugins在配置文件中的位置必须符合要求，否则会报错，顺序如下: properties?, settings?, typeAliases?, typeHandlers?, objectFactory?,objectWrapperFactory?, plugins?, environments?, databaseIdProvider?, mappers? --&gt; &lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor="com.github.pagehelper.PageInterceptor"&gt; &lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt; &lt;property name="param1" value="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/180a481777e03b029cfe7ac8fc3157ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbfcae24875435e842b703479636c8a9/" rel="bookmark">
			多元（多变量）梯度下降与特征缩放、学习率 Gradient Descent for Multiple Variables （Feature Scaling、Learning Rate）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		与单变量线性回归类似，在多变量线性回归中，我们也构建一个代价函数，则这个代价函数是所有建模误差的平方和。
即：
其中：
我们的目标和单变量线性回归问题中一样，是要找出使得代价函数最小的一系列参数。
多变量线性回归的批量梯度下降算法为：
求导数后得到：
我们开始随机选择一系列的参数值，计算所有的预测结果后， 再给所有的参数一个新的值，如此循环直到收敛。
代码示例:
特征缩放： 在我们面对多维特征问题的时候，我们要保证这些特征都具有相近的尺度，这将帮助梯度下降算法更快地收敛。以房价问题为例，假设我们使用两个特征，房屋的尺寸和房间的数量，尺寸的值为 0-2000 平方英尺，而房间数量的值则是 0-5，以两个参数分别为横纵坐标，绘制代价函数的等高线图能，看出图像会显得很扁，梯度下降算法需要非常多次的迭代才能收敛。
解决的方法是尝试将所有特征的尺度都尽量缩放到-1 到 1 之间。如图：
最简单的方法是令：，其中是平均值，是标准差。
学习率： 梯度下降算法收敛所需要的迭代次数根据模型的不同而不同，我们不能提前预知，我们可以绘制迭代次数和代价函数的图表来观测算法在何时趋于收敛。
也有一些自动测试是否收敛的方法，例如将代价函数的变化值与某个阀值（例如 0.001）进行比较，但通常看上面这样的图表更好。梯度下降算法的每次迭代受到学习率的影响，如果学习率α过小，则达到收敛所需的迭代次数会非常高；如果学习率α过大，每次迭代可能不会减小代价函数，可能会越过局部最小值导致无法收敛。
通常可以考虑尝试些学习率：
α=0.01， 0.03， 0.1， 0.3, 1, 3, 10 （通常是3倍增加）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ab4658374e39d4a17a779f4cbb5340b/" rel="bookmark">
			音乐文件基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见编码音乐文件属性：
1.1 .MP3 文件抽举编码：MPEG 1 Layer 3 声道[声 音 数]：立体声
频率[采样频率]：44100 Hz
比特[量化位数]：16 Bits
码率[比 特 率]：128 Kbps/320 Kbps
1.2 .APE/.cue 文件抽举编码：Monkey's Audio 3.99
声道[声 音 数]：5.1 声道
频率[采样频率]：44100 Hz
比特[量化位数]：16 Bits
码率[比 特 率]：728 Kbps/769 Kbps/789 Kbps/790 Kbps/ 826 Kbps
1.3 .FLAC/.cue 文件抽举编码：FLAC Audio
声道[声 音 数]：立体声
频率[采样频率]：44100 Hz
比特[量化位数]：16 Bits
码率[比 特 率]：872 Kbps/ 920 Kbps/ 936 Kbps/ 1.01 Mbps
1.4 .WAV 文件抽举编码：DVD DTS Audio
声道[声 音 数]：5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ab4658374e39d4a17a779f4cbb5340b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52a99e74707c43b5677d691e3f05c530/" rel="bookmark">
			电池驱动调试总结，电池服务&#43;电量计驱动&#43;调试方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概述： Android电池服务，用来监听内核上报的电池事件，并将最新的电池数据上报给系统，系统收到新数据后会去更新电池显示状态、剩余电量等信息。如果收到过温报警和低电报警，系统会自动触发关机流程，保护电池和机器不受到危害。 Android电池服务的启动和运行流程： Android电池服务的源码结构 Framework\base\services\java\com\android\server ├── SystemServer.java 创建BatteryServices、PowerManagerService、ActivityManagerService ├── BatterySevices.java 监听底层上报的battery事件，广播电池发生改变的消息 Framework\base\services\java\com\android\server\am ├── ActivityManagerService.java 创建BatteryStatsService ├── BatteryStatsService.java 统计和记录电池参数的信息 Framework\base\services\java\com\android\server\power ├── PowerManagerService.java 监听电池发生变化的广播消息，并调节系统的电源状态，例如亮屏 Framework\base\core\java\com\internal\os\ ├── BatteryStatsImpl.java 统计和记录电池参数的信息，并通知其他模块 System\core\healthd ├── healthd.cpp 创建uevent socket，监听内核上报的内核事件 ├── BatteryMonitor.cpp 初始化本地电池数据结构，将power_supply路径下属性节点路径填充进去， ├── BatteryMonitor.h ├── BatteryPropertiesRegistrar.cpp 创建电池属性监听器，并将其注册到Android的系统服务中 ├── BatteryPropertiesRegistrar.h 内核主要通过get_property这个函数指针来获得驱动中的有关电池的信息，而这个函数在内核中只给出了声明，我们在写驱动的时候要自己实现get_property函数，当内核需要驱动中电源信息的时候就回调这个get_property函数。例如当内核需要驱动中的电量值时，会调用get_property，传入获取电量别的标志，我们就把从电量计中读取到的电量值返回给内核。 。另外，我们写驱动程序的时候又要给用户提供接口，内核中提供给用户的接口就是sysfs，通过读取sysfs文件系统中文件内容，就可以得到电源的信息。内核主要通过两个文件power_supply_class.c和power_supply_core.c，我们调用其中的函数就可以把电源（电池，USB或AC）的信息展现给用户，有关电源的属性写在/sys/class/powersupply文件夹下（此文件夹为程序运行后所生成的）。
/sys/class/power_supply文件夹存放的是，电池驱动通过power_supply_register函数注册的各个电源属性名称。 在安卓系统的命令行下输入： cat /sys/class/power_supply/rk-bat/uevent: 电池系统从底层向Framework层上报数据的流程： 2.调试手段： 获取手机电池信息 adb命令:adb shell dumpsys battery 得到信息如下： AC powered: false USB powered: true Wireless powered: false status: 1 #电池状态：2：充电状态 ，其他数字为非充电状态 health: 2 present: true level: 55 #电量: 百分比 scale: 100 voltage: 3977 current now: -335232 temperature: 335 #电池状态 technology: Li-poly
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52a99e74707c43b5677d691e3f05c530/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fd1ae74d77193788b899c4cc4025d53/" rel="bookmark">
			C&#43;&#43;对象的自杀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以在类的函数中调用delete this；
函数可以为非static函数。
要保证该语句后不再使用非static成员变量，否则程序会崩溃。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85fdc5908bd0142afe2845f1a4b27430/" rel="bookmark">
			蚁群算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一种应用于组合优化问题的启发式搜索算法。蚁群算法是一种用来寻找优化路径的概率型算法
组合优化：
组合优化（Combinatorial Optimization）问题的目标是从组合问题的可行解集中求出最优解，通常可描述为：令Ω={s1，s2，…，sn}为所有状态构成的解空间，C(si)为状态si对应的目标函数值，要求寻找最优解s*，使得对于所有的si∈Ω，有C(s*)=minC(si)。组合优化往往涉及排序、分类、筛选等问题，它是运筹学的一个重要分支。
来自 &lt;https://baike.baidu.com/item/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96/3314860&gt; 蚁群算法在解决离散组合优化方面具有良好的性能。
一、基本思想
1、蚂蚁觅食：
信息素跟踪：按照一定的概率沿着信息素较强的路径觅食。
信息素遗留：会在走过的路上会释放信息素，使得在一定的范围内的其他蚂蚁能够觉察到并由比影响它们的行为。
2、归结为几点：
（1）环境：有障碍物、有其他蚂蚁、有信息素
（2）觅食规则：范围内寻找是否有食物，否则看是否有信息素，每只蚂蚁都会以小概率犯错，
（3）移动规则：都朝信息素最多的方向移动，无信息素则继续朝原方向移动，且有随机的小的扰动，有记忆性。
（4）避障规则：移动的方向如有障碍物挡住，蚂蚁会随机选择另一个方向
（5）信息素规则：越靠近食物播撒的信息素越多，越离开食物播撤的信息素越少。
根据以上规则，模拟一个算法，即蚁群算法
二、蚁群算法
1、应用：
旅行商问题 &amp; TSP问题：有n个城市，从起点 0 开始游历每一个城市，只访问每个城市一次，最后回到起点，所需要的最短路径是多少？ （ACM中使用状压DP来解决问题）
这个属于NP完全问题。最直接的方法就是枚举法，解空间为n个元素的所有排列组合，为(n−1)!。n稍微一大就无法在有限的时间内做出。
蚂蚁搜索食物的过程：
通过个体之间的信息交换与相互协作，最终找到从蚁穴到食物源的最短路径。
2.模型
蚂蚁k在运动过程中，根据各条路径上的信息素决定转移方向。
3.蚁群系统的模型：
：表示在t时刻蚂蚁 k 选择从元素(城市) x 转移到元素(城市) y 的概率，也称为随机比例规则。
α值越大，该蚂蚁越倾向于选择其他蚂蚁经过的路径，该状态转移概率越接近于贪婪规则。
α=0 不再考虑信息素水平，算法就成为有多重起点的随机贪婪算法
β=0 算法就成为纯翠的正反馈启发式搜索。
补充（启发式搜索）： 启发式算法（heuristic algorithm)是相对于最优化算法提出的。一个问题的最优算法求得该问题每个实例的最优解。启发式算法可以这样定义：一个基于直观或经验构造的算法，在可接受的花费（指计算时间和空间）下给出待解决组合优化问题每一个实例的一个可行解，该可行解与最优解的偏离程度一般不能被预计。现阶段，启发式算法以仿自然体算法为主，主要有蚁群算法、模拟退火法、神经网络等。
-------------------------------------------------------------------------------第二天接上-------------
用参数1-ρ表示信息素消逝程度，蚂蚁完成一次循环，各路径上信息素浓度消散规则为：
蚁群的信息素浓度更新规则为：
M. Dorigo给出的三种不同模型：
1、蚂蚁圈系统（效果最好，通常作为蚁群优化算法的基本模型）：
利用的是全局信息 ，即蚂蚁完成一个循环后，更新所有路径上的信息。 2、蚂蚁数量系统：利用的是局部信息 ，即蚂蚁每走一步都要更新残留信息素的浓度。
3、蚂蚁密度系统：利用的是局部信息 ，即蚂蚁每走一步都要更新残留信息素的浓度。 三、算法参数选择
1、信息素启发因子（α）
Ø 反映了蚁群在路径搜索中随机性因素作用的强度；
Ø α值越大，蚂蚁选择以前走过的路径的可能性越大，搜索的随机性减弱；
Ø 当α 过大时会使蚁群的搜索过早陷于局部最优。
2、期望值启发式因子（β）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85fdc5908bd0142afe2845f1a4b27430/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fd81a66b1a0b0edbc2fa61786b98fda/" rel="bookmark">
			3. 无重复字符的最长子串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个字符串，找出不含有重复字符的最长子串的长度。
示例：
给定 "abcabcbb" ，没有重复字符的最长子串是 "abc" ，那么长度就是3。
给定 "bbbbb" ，最长的子串就是 "b" ，长度是1。
给定 "pwwkew" ，最长子串是 "wke" ，长度是3。请注意答案必须是一个子串，"pwke" 是 子序列 而不是子串。
public class Solution { public int LengthOfLongestSubstring(string s) { if (s.Length == 0) return 0; int Length = 0; Dictionary&lt;char, int&gt; all = new Dictionary&lt;char, int&gt;(); for (int i = 0, j = 0; j &lt; s.Length; j++) { if (all.ContainsKey(s[j])) { i = Math.Max(all[s[j]], i);//如果只写all[s[j]]则"abba"这种情况会出错 all.Remove(s[j]); } Length = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fd81a66b1a0b0edbc2fa61786b98fda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f41b275ab91260684ffc824cc626c86/" rel="bookmark">
			ijkplayer-android最最简单的使用Demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先引入看jkplayer库，可以直接从gradle引入，也可以从GitHub下载ijkplayer源码，自己编译后再导入项目中。
这里我们使用从gradle中引入。新建工程，在build.gradle(Module:app)文件中添加：
// required, enough for most devices. implementation 'tv.danmaku.ijk.media:ijkplayer-java:0.8.8' implementation 'tv.danmaku.ijk.media:ijkplayer-armv7a:0.8.8' // Other ABIs: optional implementation 'tv.danmaku.ijk.media:ijkplayer-armv5:0.8.8' implementation 'tv.danmaku.ijk.media:ijkplayer-arm64:0.8.8' implementation 'tv.danmaku.ijk.media:ijkplayer-x86:0.8.8' implementation 'tv.danmaku.ijk.media:ijkplayer-x86_64:0.8.8' //ExoPlayer as IMediaPlayer: optional, experimental implementation 'tv.danmaku.ijk.media:ijkplayer-exo:0.8.8' 具体的导入可查看ijk官网的说明：https://github.com/Bilibili/ijkplayer。
接着说一下ijkplayer的实现步骤，这里主要使用IjkMediaPlayer进行实现，实现步骤与MediaPlayer基本类似。
实现步骤如下：
1.创建IjkMediaPlayer对象，并让它加载指定的视频文件。可以是应用的资源文件、本地文件路径、或者URL。
2.在界面布局文件中定义SurfaceView组件，并为SurfaceView的SurfaceHolder添加Callback监听器。
3.调用IjkMediaPlayer对象的setDisplay(SurfaceHolder sh)将所播放的视频图像输出到指定的SurfaceView组件。
4.调用IjkMediaPlayer对象的prepareAsync()或prepare()方法装载流媒体文件
5.调用IjkMediaPlayer对象的start()、stop()和pause()方法来控制视频的播放。
简单实现如下：
布局文件：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;SurfaceView android:id="@+id/surfaceView" android:layout_width="match_parent" android:layout_height="match_parent"/&gt; &lt;/android.support.constraint.ConstraintLayout&gt; 程序代码：
public class ijkPlayerSimpleTest extends AppCompatActivity implements SurfaceHolder.Callback{ private IjkMediaPlayer mPlayer; @Override protected void onCreate(Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f41b275ab91260684ffc824cc626c86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e3bb810b19502cad6578c51bb1e5aeb/" rel="bookmark">
			ubuntu vbox 虚拟机错误解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误信息如下：
Kernel driver not installed (rc=-1908)
The VirtualBox Linux kernel driver (vboxdrv) is either not loaded or there is a permission problem with /dev/vboxdrv. Please reinstall the kernel module by executing
'/sbin/vboxconfig'
as root.
where: suplibOsInit what: 3 VERR_VM_DRIVER_NOT_INSTALLED (-1908) - The support driver is not installed. On linux, open returned ENOENT.
解决方案：
1.卸载原版本 ： sudo apt-get remove virtualbox-5.2
2.安装新版本：sudo dpkg -i virtualbox-5.1_5.1.38-122592~Ubuntu~xenial_amd64.deb
3.安装依赖 sudo apt-get install libqt5x11extras5
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc9cc23cb6453cdd451558b6e8c63c98/" rel="bookmark">
			配置PCL1.8.0库时OpenNI2.dll丢失问题的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装配置PCL库过程参考 windows系统下配置PCL1.8.0和VS2013。
但是在完全按照上述参考安装完成后出现
“无法启动此程序，因为计算机中丢失OpenNI2.dll。尝试重新安装该程序以解决此问题。”的错误。
在多次检查环境变量以及配置没有问题后，多次尝试终于找到解决办法。
解决方法：将安装路径下OpenNI2\Tools目录中的OpenNI2.dll放到自己的exe目录下。
比如我的安装路径是C:\Program Files(x86)\OpenNI2.dll\Tools，
我的VS2013工程路径是D:\VS2013 Project\setting_PLC\setting_PLC。
将安装路径中的OpenNI2.dll放到工程路径下，大功告成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30c5865ea9ecedb1e819f2e459501a56/" rel="bookmark">
			ExtJs selectfield字段样式错乱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ext.field.Select
如果有required:true属性会导致样式错乱，所以一定要设置为false
extjs的bug是很多的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa3412868e0f4a0f760ea07b03d44b48/" rel="bookmark">
			什么是-Xmx和-Xms?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在打开橘色线的 配置文件
中会出现两个配置，如下图
其中，-Xmx用来设置你的应用程序(不是JVM)能够使用的最大内存数，如果你的程序要花很大内存的话，那就需要修改缺省的设置，比如配置tomcat的时候，如果流量啊程序啊都很大的话就需要加大这个值了，BUT不要大得超过你的机器的内存。
另一个-Xms用来设置程序初始化的时候内存栈的大小，增加这个值的话你的程序的启动性能会得到提高。不过同样有前面的限制，以及受到-Xmx的限制。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24219ec11b44098507e21bb35c4b2f89/" rel="bookmark">
			IDEA_maven依赖错误,下面红色波浪线,不能打包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如图，项目能成功运行，但是不能打包
解决方法：先注释pom.xml文件的依赖 然后删除jar路径下的文件：
然后取消注释，就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c663e5e9a2408697a29a1f9bd63e195/" rel="bookmark">
			QT学习 - QTableWidget 的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：QTableWidget的使用方式
//QTableWidget行选中/删除/添加行 //1 均分各列 tableWidget-&gt;horizontalHeader()-&gt;setStretchLastSection(true); //就是这个地方 tableWidget-&gt;horizontalHeader()-&gt;setResizeMode(QHeaderView::Stretch); //2 整行选中：job_20160526213327 tableWidget-&gt;setSelectionBehavior ( QAbstractItemView::SelectRows); //设置选择行为，以行为单位 tableWidget-&gt;setSelectionMode ( QAbstractItemView::SingleSelection); //设置选择模式，选择单行 //3 删除选中的整行 int rowIndex = m_pAttrbuteList-&gt;currentRow(); if (rowIndex != -1) tableWidget-&gt;removeRow(rowIndex); /* 为了将数据能够在界面中显示的更清楚一些，在这里应用到了tableWidget控件，现将该控件中删除指定行的代码介绍如下： QTable里有一个removeRow(int i)函数用来删除当前行，但是如果我们没有对于table进行任何的选中，那么QTable是如何返回的呢？ 用Qt Creator里拖了一个tableWidget,加一个按钮，点击删除后执行*/ int i = ui-&gt;tableWidget-&gt;currentRow(); QMessageBox msg; msg.setText(QString::number(i)); msg.exec(); ui-&gt;tableWidget-&gt;removeRow(i); /*在不选择行的情况下发现每次点击后删除的都是第一行，i的输出都是0，原因其实很简单，就是因为table的当前焦点在第一样的 第一个单元格所导致的，解决的办法就是让table失去焦点，在构造函数里面添加ui-&gt;tableWidget-&gt;setFocusPolicy(Qt::NoFocus); 然后再试，发现点击删除按钮如果不选中行的话是不能删除的，返回的i此时是-1。 控件刚开始的时候左边默认自带序列号，如果想去掉左边的行号，加上下面的代码就可以了。*/ QHeaderView* headerView = table的名字-&gt;verticalHeader(); headerView-&gt;setHidden(true); //4 添加整行 int rowIndex = m_pAttrbuteList-&gt;rowCount(); tableWidget-&gt;setRowCount(rowIndex + 1);//总行数增加1 tableWidget-&gt;setRowHeight(rowIndex, 24);//设置行的高度 -------------------------------------------------------------------------------- QTableWidget *table = new QTableWidget(this); table-&gt;setColumnCount(5); //设置列数 table-&gt;setRowCount(3); //设置行数/ /*设置列名*/ QStringList headers; headers&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c663e5e9a2408697a29a1f9bd63e195/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec3789ed4e139a1439925e53261fc179/" rel="bookmark">
			四旋翼飞行器的原理研究和建模
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		##四旋翼飞行器的原理研究和建模
对四旋翼飞行器的工作原理进行了简单介绍，对其飞行姿态角进行描述，并在此基础上建立数学模型。
四旋翼飞行器的原理 根据四旋翼飞行器的运动方式的特点将其飞行控制划分为四种基本的飞行控制方式。(1)垂直飞行控制;(2)横滚控制;(3)俯仰控制;(4)偏航控制。下面分别对以上四种飞行控制方式进行阐述。垂直飞行控制主要是控制飞机的爬升、下降和悬停,如图1.1图中蓝色弧线箭头方向表示螺旋桨旋转的方向,以下同。当四旋翼处于水平位置时,在垂直方向上,惯性坐标系同机体坐标系重合。同时增加或减小四个旋翼的螺旋桨转速,四个旋翼产生的升力使得机体上升或下降,从而实现爬升和下降。悬停时,保持四个旋翼的螺旋桨转速相等,并且保证产生的合推力与重力相平衡,使四旋翼在某一高度处于相对静止状态,各姿态角为零。垂直飞行控制的关键是要稳定四个旋翼的螺旋桨转速,使其变化一致。
在具体介绍飞行原理之前，首先要介绍一下飞行器的坐标系下的运动。
图1.1 固定翼和四旋翼的运动分析
在笛卡尔直角空间坐标系里共有6种运动，即沿x,y,z轴向的线性运动和围绕轴向的旋转运动。线性运动比较容易描述。旋转运动则可定义为roll,pitch,yaw。roll运动是围绕机身前后轴的旋转运动；pitch运动是围绕与机身垂直方向轴的旋转运动；yaw运动是围绕机身垂直方向的旋转运动。如图2.2，2.3，2.4，2.5,2.6所示。
转动惯量平衡公式如下：
k[(ω_1^2+ω_ 3^ 2)-(ω_2^2+ω_4 ^2)]= 0 （k是一个常数，w是角速度。）
图1.2悬停 （hovering）
悬停运动是最基本的运动，此时仅需由4个rotor提供的升力平衡重力，flyer就可以进行悬 停运动。ω_1=ω_2=ω_3=ω_4
图1.3 升降运动
升降运动和悬停运动类似，4个rotor的转速相同。通过改变他们的转速进而改变他们产生的升力，以此控制运动的升降。
图1.4横滚（Roll）运动
Roll运动是围绕前后方向的旋转运动。此运动中，前后转速不变，左右转速相应变化。粗鲁计算时，左右的转速变量近似相 等。但详细计算时会发现，为使转动惯量平衡，左右转速变量明显不同。
图1.5俯冲（Pitch）运动
Pitch运动是围绕左右方向的旋转运动。此运动中，左右转速不变，前后转速相应变化,转速计算方法与Roll运动相同。
图1.6偏航（Yaw）运动
Yaw运动相对于roll和pitch运动计算上更为简单，只需同时改变前后和左右的转速即可,但要保证升力和重力的动态平衡。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7504a338be312cb95caf9d1c7a972e0/" rel="bookmark">
			Erlang语法知识点学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、退出,输入 haut().
2、-module
3、module_name:function_name( arguments ) 例如调用tut:double(10),说明调用tut模块的double函数。
4、模块名为tut
-module(tut).
-export( [double/1, fact/1] ).
double(X)-&gt;
2 * X.
fact(1) -&gt;
1; fact(N) -&gt;
N*fact(N-1).
分号表示函数还未结束。
点号表示函数已经结束。
变量必须以大写字母开头，小写开头的为字符串。
5、元组
可以返回多个值
-module(tut).
-export( [double/1] ).
double(X) -&gt;
{X*2, X*3, X*4}.
6、
列表赋值
10&gt; [One,Two|Rest]=[1,2,3,4,5,6].
[1,2,3,4,5,6]
11&gt; One.
1
12&gt; Two.
2
13&gt; Rest.
[3,4,5,6]
14&gt;
获取列表的长度
-module(tut).
-export( [get_length/1] ).
get_length([] ) -&gt;
0;
get_length([First|Rest]) -&gt;
1+get_length(Rest).
字符串输出采用ASCII表示
&gt;[97,98,99].
"abc"
7、百分号表示注释
8、格式化输出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7504a338be312cb95caf9d1c7a972e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fffd542ea0d646b6575e0c50e775739/" rel="bookmark">
			快手、抖音、微视类短视频SDK接入教程，7步就能搞定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎大家前往腾讯云+社区，获取更多腾讯海量技术实践干货哦~
本文由视频咖 发表于云+社区专栏
终端部分 按照如下三步操作，可以用 XCode 或者 Android Studio 编译和调试小视频 App 的客户端代码，运行效果如下：
step1. 下载APP源码 点击 小视频源码 可以下载到小视频 App 的源代码。
step2. 准备调试环境 iOS 平台 XCode 9 或更高版本OS X 10.10 或更高版本 Android 平台 Android NDK: android-ndk-r12bAndroid SDK Tools: android-sdk_26.0.2 minSdkVersion: 15targetSdkVersion: 21 step3. 编译运行 点击 XCode 或 Android Studio 的 Build 按钮，即可完成编译和运行工作，源码中默认配置了腾讯云提供的测试服务器地址http://demo.vod2.myqcloud.com/lite/，以便您快速在调试环境中运行起我们的APP。
后台部分 小视频 App 的运行依赖两种后台服务：
点播云服务（VOD） 点播（VOD）服务可以为小视频提供视频的存储和在线分发的能力，您在购买短视频的基础班或者商业版 License 时，会一并购买腾讯云的点播服务套餐包，所以已经有一定量的流量可以使用。业务服务器 小视频 App 需要一台简单的业务服务器，该服务器可以为 App 提供注册、登录、视频列表存储、视频上传签名等能力，您可以将其搭建在腾讯云 CVM 云服务器上，并可以自行修改里面的逻辑。 当您使用小视频源码包内部的默认服务器地址（http://demo.vod2.myqcloud.com/lite/）时，使用的点播服务和列表服务器均由腾讯云提供，但该服务有并发限制，仅适合用于调试和体验目的。
如果您希望自己搭建 App 的后台服务器，可以按照如下步骤自行搭建：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fffd542ea0d646b6575e0c50e775739/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a28764cbc8487593591969a9fde718c/" rel="bookmark">
			Spring Cloud Zuul 整合 swagger
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近我们有一个需求，就是把各个系统的swagger文档集中在一起。有了这么一个需求之后，我去百度了，结合swagger的源码实现了一下
首先我们可以先看看单个系统的swagger页面，
第一部分是一个下拉框，就是一个选择swagger资源的下拉框，默认就是本应用；
第二部分是一个请求，是第一部分数据的请求
第三部分是第二部分请求的一个结果展示，json部分一共有三个key，由图片可知第一个key是name，第二个key是location。也就是这个资源的访问url，第三个key是version，也就是版本号
根据我们自己的需求，怎么将各个系统的api数据集中在一起呢？其实思路可以从我上面的截图得到。
步骤1：
首先要先从swagger源码中找到第二步的请求源码，如下
红线区域是核心，主要就是生成swaggerResource返回给前端，默认是只返回本document的swaggerResource。
步骤2：
理解步骤1之后，其实我们可以大概能想象怎么处理我们之前的需求。处理方式就是自定义resourceProvide类实现SwaggerResourceProvider接口，然后我们只要重写get方法，代码如下：
@Component @Primary class MySwaggerResourcesProvider implements SwaggerResourcesProvider { @Override public List&lt;SwaggerResource&gt; get() { List resources = new ArrayList&lt;&gt;(); resources.add(swaggerResource("service-a", "/swagger-service-a/v2/api-docs", "2.0")); resources.add(swaggerResource("service-b", "/swagger-service-b/v2/api-docs", "2.0")); return resources; } private SwaggerResource swaggerResource(String name, String location, String version) { SwaggerResource swaggerResource = new SwaggerResource(); swaggerResource.setName(name); swaggerResource.setLocation(location); swaggerResource.setSwaggerVersion(version); return swaggerResource; } } 主要是get方法，代码主要把增加了各个系统的swaggerResource（数据访问来源），
SwaggerResource有三个参数，
第一个参数：名称，也就是之前那个下拉框的选择条名称
第二个参数：url，就是访问具体系统swagger的链接
第三个参数：version ，就是swagger的版本
之后就启动网关项目，访问网关项目的swagger地址就可以看到各个系统集中的api数据了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/000988ea26b0816d2c758ee5d807d4c3/" rel="bookmark">
			const 修饰变量及如何修改其值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		const 常用形式 1，const int p；//， 是一个常整型数，只读变量，不能通过p修改对应内存里的值
2，int const p；//同上，int 和 const 相邻时位置可互换 常整型数
3，int const *p；//去掉类型int， const修饰*p， （*p）++不可以，p所指向空间的值不可以改变，p++是对的，p指针可以后移
4，const int *p；// 同上 p是指向常整型数的指针
5，int * const p；//去掉类型 int *，const p；p对应内存值不可改变，但可通过指针修改，p是指向整型数的常指针
6，const int * const p；//综合以上，p值不可改变也不可改变指向 ，p是指向常整型数的常指针
7 const struct devices de[5];//去掉类型 struct devices 剩下const de[5];数组里的元素不可改变
8，struct devices const * de[5];//const *de[5], 每个元素都是指针，指针存放的地址不可以变，但对于的值可以改变
结论： 指针本身是常量不改变
指针所指向的内容是常量也不可改变
如何通过指针修改被const修饰变量的值 #include &lt;stdio.h&gt; int main() { const int a = 10; int *p =(int *) &amp;a; (*p)++; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/000988ea26b0816d2c758ee5d807d4c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcee1c7799618af455d2b3371f68f6cf/" rel="bookmark">
			关于在SQL语句中记录添加时间和修改时间的简单用法：invalid default value for create_time
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近看到别人的项目中，数据库中加入了创建时间和修改时间，感觉这个挺实用，就想创建一个demo试试怎么用，查询之后发现修改时间使用的是timestamp字段格式，数据库会根据当前时间，自动处理，不需要在SQL语句中设置，创建时间为datetime，默认值是CURRENT_TIMESTAMP，使用时直接在SQL语句中使用now()来获取当前的时间，但是动手之后，问题就来了！！！！
首先是在创建数据库字段的时候就报错了，使用的是MySQL，工具用的Navicat，但是，设置create_time字段为datetime，默认值为CURRENT_TIMESTAMP保存时就提示invalid default value for create_time的错误，反复查询之后，无果。。。。。。。。。。。
我按照别人的博客里面的截图直接在Navicat里面手动设置相同的字段和默认类型，还是报这个错误。。。。。。。wtf？？？？？？
这是别人设置的：
这是我的设置：
保存就提示：
折腾了半天，查到说是MySQL 5.6以后timestamp设定默认值规则改变，不能为”0000 00-00 00:00:00”，但是现在我并没有插入值，只是创建数据库字段，这里就通过不了了 还谈什么后期插入新的数据呢。。。。。。。。
在查了将近一个小时的时间里 很多博客都说修改一下数据库默认设置的时间不能为零，我感觉这个根本无关痛痒，我也没有尝试。。。。。。
最后偶然在一个博客下面看到一句总结：
timestamp类型适合用来记录数据的最后修改时间，因为只要你更改了记录中其他字段的值，timestamp字段的值都会被自动更新。（如果需要可以设置timestamp不自动更新）
然后想出来一个笨方法：
设置的字段如下图所示：
因为创建时间是固定的，修改的时间是跟随系统更新的，所以将create_time字段类型设置为varchar，创建新数据时，为这个字段赋值，直接使用now()，取值，插入到create_time 里面即可。将update_time 设置为timestamp，并勾选根据当前时间戳更新，
既然now()，可以获取到当前时间，那么可以尝试将create_time 类型设置为字符串，然后 在执行insert语句的时候，在添加的SQL语句中的字段里面加上create_time,value为now(), 这样就可以在数据库中插入添加的时间了
比如现在往数据库添加一条新的数据：insert into user ( username, password, create_time ) VALUES ('小明22', '12345', now())
这里create_time和update_time都是当前时间，但是不同的是 create_time的时间是使用now()获取到的当前系统时间，然后使用SQL语句，赋值给create_time的，而update_time 是系统自动赋值的，不需要在SQL语句中具体操作的。
执行修改的操作后，update_time 会自动更新为修改的时间
执行语句update user set username = '小明32' where id = 32之后，create_time 仍然为创建时的时间，而update_time自动更新为新的时间
**总结：**由于创建的时间是固定的，可以设置create_time字段的属性为varchar，在创建时，在SQL语句中使用now(),来为create_time字段赋值。
updae_time的属性设置为timestamp，并勾选根据时间戳更新，这样在执行update语句时，会自动更新修改的时间。
两年过去了。。。。。。。。。。
两年之后，再次看这篇文章，发现存在些瑕疵，create_time使用字符串存储明显不太合适，字符串占用的字节，这里补充一下：
借用菜鸟教程里面的图：
关于创建时间和更新时间，这个一般数据库表格里面都会有这两个字段的，目的是为了标识数据的时间，方便后面根据时间排序或者根据时间段进行查询。
但是字段的类型设置可以因人而异，目前我们公司项目中创建时间和更新时间都是使用的是timestamp，对应的Java类型为TimeStamp，赋值时直接使用user.setCreateTime(new Timestamp(System.currentTimeMillis()));，更新时间也可以按照上面的，设置成MySQL自动更新，也可以更新时手动赋值。
但是涉及到时间的字段，不能盲目的全部设置成timestamp，最好是根据需求，此字段是否需要显示时分秒，如果只需要记录日期，则设置成date是最好的，实体类字段映射成LocalDate，这样在业务中处理时可直接使用java8的时间操作，还是很方便的。
其中timestamp和datatime的区别：
timestamp是有时间区间的，有最大值，如果私有业务的时间字段使用了timestamp时，并且有续期业务，就要注意，到2038年的时候，插入数据就会可能报异常。
datatime是时区无关的，存入的时间原来是多少就是多少，而timestamp是可以转换时区的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d91fd94aa9cc872263dd9cb52825a53/" rel="bookmark">
			fastjson队列引起的ref问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题临时解决方案 1）对相关的get方法加如下注解（局部关闭$ref特性） @JSONField(serialzeFeatures = SerializerFeature.DisableCircularReferenceDetect) 2）toSJONString时关闭$ref特性（事务性关闭$ref特性） JSON.toJSONString(需要序列类的实例, SerializerFeature.DisableCircularReferenceDetect); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85a12a069590576c5cf44a8858c63f09/" rel="bookmark">
			JAVA数据结构和算法系列视频教程 20课
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课程介绍:
基于JAVA语言的数据结构算法视频教程，非常经典的java数据结构基础理论课程，是学习java的必备技能。
课程目录:
01.第一讲数组
02.第二讲简单排序
03.第三讲栈和队列
04.第四讲链表
05.第五讲双端链表和双向链表
06.第六讲递归的应用
07.第七讲递归的高级应用
08.第八讲希尔排序
09.第九讲快速排序
10.第十讲二叉树的基本概念
11.第十一讲二叉树的基本操作
12.第十二讲遍历二叉树
13.第十三讲删除二叉树节点
14.第十四讲红黑树
15.第十五讲哈希表
16.第十六讲开放地址法
17.第十七讲链地址法
18.第十八讲图的基本概念
19.第十九讲：图的搜索
20.第二十讲：图的最小生成树
JavaData.rar
下载地址；百度网盘
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b6f23ad3ccbc62f5a9b81de1692ea90/" rel="bookmark">
			Spring Boot配置接口 WebMvcConfigurer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebMvcConfigurer配置类其实是Spring内部的一种配置方式，采用JavaBean的形式来代替传统的xml配置文件形式进行针对框架个性化定制。基于java-based方式的spring mvc配置，需要创建一个配置类并实现WebMvcConfigurer 接口，WebMvcConfigurerAdapter 抽象类是对WebMvcConfigurer接口的简单抽象（增加了一些默认实现），但在在SpringBoot2.0及Spring5.0中WebMvcConfigurerAdapter已被废弃 。官方推荐直接实现WebMvcConfigurer或者直接继承WebMvcConfigurationSupport，方式一实现WebMvcConfigurer接口（推荐），方式二继承WebMvcConfigurationSupport类，具体实现可看这篇文章。https://blog.csdn.net/fmwind/article/details/82832758
// // Source code recreated from a .class file by IntelliJ IDEA // (powered by Fernflower decompiler) // package org.springframework.web.servlet.config.annotation; import java.util.List; import org.springframework.format.FormatterRegistry; import org.springframework.http.converter.HttpMessageConverter; import org.springframework.validation.MessageCodesResolver; import org.springframework.validation.Validator; import org.springframework.web.method.support.HandlerMethodArgumentResolver; import org.springframework.web.method.support.HandlerMethodReturnValueHandler; import org.springframework.web.servlet.HandlerExceptionResolver; public interface WebMvcConfigurer { void configurePathMatch(PathMatchConfigurer var1); void configureContentNegotiation(ContentNegotiationConfigurer var1); void configureAsyncSupport(AsyncSupportConfigurer var1); void configureDefaultServletHandling(DefaultServletHandlerConfigurer var1); void addFormatters(FormatterRegistry var1); void addInterceptors(InterceptorRegistry var1); void addResourceHandlers(ResourceHandlerRegistry var1); void addCorsMappings(CorsRegistry var1); void addViewControllers(ViewControllerRegistry var1); void configureViewResolvers(ViewResolverRegistry var1); void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; var1); void addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler&gt; var1); void configureMessageConverters(List&lt;HttpMessageConverter&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b6f23ad3ccbc62f5a9b81de1692ea90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb4b22c72e457825cb4f912c8c784c11/" rel="bookmark">
			斐波那契数列算法复杂度计算过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 求该方法的时间复杂度
long aFunc(int n) { if (n &lt;= 1) { return 1; } else { return aFunc(n - 1) + aFunc(n - 2); } } 参考答案：
显然运行次数，T(0) = T(1) = 1，同时 T(n) = T(n - 1) + T(n - 2) + 1，这里的 1 是其中的加法算一次执行。
显然 T(n) = T(n - 1) + T(n - 2) 是一个斐波那契数列，通过归纳证明法可以证明，当 n &gt;= 1 时 T(n) &lt; (5/3)^n，同时当 n &gt; 4 时 T(n) &gt;= (3/2)^n。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb4b22c72e457825cb4f912c8c784c11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe9265aedd6622adf886d9df7e35eb4f/" rel="bookmark">
			Download https://downloads.gradle.org/distributions/gradle-4.4-all.zip下载太慢的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于新安装了Android Studio，新建第一个工程时，一直在Build Sync， “Download https://downloads.gradle.org/distributions/gradle-4.4-all.zip”。但是更新了很久还是没有下好。后面通过如下方案快速的解决的这个问题。
首先到官网下载一个对应版本的离线包。官网地址：https://services.gradle.org/distributions/ 。若是嫌弃从官网下载太慢也可以从这里：https://download.csdn.net/download/liuzhi0724/10567038 进行下载。
将下载好的gradle-4.4-all.zip拷贝到C:\Users\你的用户名\.gradle\wrapper\dists\gradle-4.4-all\9br9xq1tocpiv8o6nilyu5op1目录下并解压。Android Studio 在Build sync 时会自动创建这个目录gradle-4.4-all\9br9xq1tocpiv8o6nilyu5op1。其他的设备生成目录可能不是9br9xq1tocpiv8o6nilyu5op1。
解压缩时，采用“解压到当前文件夹”解压出来的是gradle-4.4的目录。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a84698f0081ad0d80b47ed3222ccbc83/" rel="bookmark">
			Android Studio 修改主题样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽然Android Studio自带了三种主题样式，但是如果对这些主题样式都不满意，又不想自己一个一个去设置主题样式。可以去网上下载自己喜欢的主题样式并导入。
首先说一下Android Studio自带主题的切换。打开AS菜单栏File-&gt;Settings-&gt;Appearance&amp;Behavior-&gt;Appearance界面，里面有Theme选项，里面有Darcula、IntelliJ、Windows三种主题，通过这个可以自行切换不同的主题。如下所示：
如果这三种样式都不喜欢，可以去网上下载自己喜欢的主题字体。这里共享几个可用的字体主题： https://download.csdn.net/download/liuzhi0724/10566709 有喜欢的可以自行下载。
下载完主题样式后，在Android Studio的菜单栏中，打开File-&gt;Import Settings-&gt;选择已经下载好的主题样式，一路点击OK，重新启动AS即可改变样式。
然后根据自己喜好设置下字体大小。打开File-&gt;Settings-&gt;Editor-&gt;Color&amp;Fonts-&gt;Font界面，修改Size。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dccab378996673698dd417d973bf804b/" rel="bookmark">
			SQL（四） 数据库 选择指定行数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用SQL SERVER，其他数据库的表达可能略有不同 情况一：
选取前50条记录
SELECT TOP 50 * FROM table_name 选取table中某些列的前50条
SELECT TOP 50 column_name(s) FROM table_name 情况二：
选取第50行
方法1
SELECT no=Identity(int,1,1),* INTO temptable FROM table_name SELECT * FROM temptable WHERE no=15 DROP TABLE temptable 利用identity函数生成记录序号，和原表数据保存到临时表temptable中；
用完删除临时表temptable。
方法2
SELECT TOP 1 * FROM (SELECT TOP 50 * FROM table_name ORDER BY colnum_name DESC) AS f 方法3
SELECT TOP 1 * FROM table_name WHERE column_name NOT IN (SELECT TOP 49 column_name FROM table_name) 情况3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dccab378996673698dd417d973bf804b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26fce2846fb7a134dab51d8b1846c5f5/" rel="bookmark">
			Move和Forward的使用方法:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Forward用来把是一个引用的参数传递出去。这可以是左值引用也可以是右值引用 这个引用如果不是形式上被声明成右值,那多半是用错了，这里是一个使用例子
template&lt;typename T&gt; void CallPrint(T&amp;&amp; x) { Print(std::forward&lt;T&gt;(x)); } forward中接受的参数是通过函数传递进来的右值引用
使用forward的时候,不能忽略它的模板参数。最好的写法是
被forward的参数的类型如果声明为x&amp;&amp;,那么就要写std::forward&lt;x&gt;。
其中:当X是一个非引用类型的时候,forward会把类型为x&amp;&amp;的参数处理成右值引用。如果X是一个左值引用类型的时候,forward会把类型为x&amp;&amp;的参数处理成左值引用
我们来看这么一个例子:
#include &lt;iostream&gt; using namespace std; void Print(int&amp; x) { cout &lt;&lt; "x is int&amp;" &lt;&lt; endl; } void Print(int&amp;&amp; x) { cout &lt;&lt; "x is int&amp;&amp;" &lt;&lt; endl; } template&lt;typename T&gt; void CallPrint(T&amp;&amp; x) { Print(std::forward&lt;T&gt;(x)); } int main() { int x = 0; CallPrint(x); CallPrint(0); system("PAUSE"); return 0; } CallPrint(x)的类型计算过程是,首先x的类型是int&amp;,但是callPrint的参数却是T&amp;&amp;,由于类型折叠的关系,想让T&amp;&amp;变成int&amp;,那么T只能是int&amp;,然后int&amp; &amp;&amp;只能是int&amp; 了所以调用forward的时候其模板参数是T,也就是int&amp;
Print(std::forward&lt;T&gt;(x));也就是一个T了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26fce2846fb7a134dab51d8b1846c5f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9c978feeecc1e0587ca3a319bbf4d9a/" rel="bookmark">
			gpio被其他模块占用 gpio_request
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gpio_request()简单分析 2015年01月28日 10:38:00
阅读数：3950
一、软件环境
Andorid Version：5.0
Cpu &amp; Arch：Intel X86_64
二、File Path
include/linux/gpio.h
include/asm-generic/gpio.h
drivers/gpio/gpiolib.c
三、代码分析
int gpio_request(unsigned gpio, const char *label)
{
&lt;span style="white-space:pre"&gt; &lt;/span&gt;return gpiod_request(gpio_to_desc(gpio), label);
}
EXPORT_SYMBOL_GPL(gpio_request);
（1）根据gpio序号获取相应的描述gpio的结构体desc
static struct gpio_desc *gpio_to_desc(unsigned gpio)
{ //&lt;span style="font-family: Arial, Helvetica, sans-serif;"&gt;条件为真时(&lt;/span&gt;&lt;span style="font-family: Arial, Helvetica, sans-serif;"&gt;0 &lt;= gpio &lt; ARCH_NR_GPIOS)输出Debug信息，且返回NULL&lt;/span&gt;
if (WARN(!gpio_is_valid(gpio), "invalid GPIO %d\n", gpio)) return NULL;
else
return &amp;gpio_desc[gpio];
}
（2）根据desc与label，调用gpiod_request注册gpio口
static int gpiod_request(struct gpio_desc *desc, const char *label)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9c978feeecc1e0587ca3a319bbf4d9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9094329cba23a46cf59a20ef14007f52/" rel="bookmark">
			JVM总结（八）虚拟机类加载机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：
每个开发人员对java.lang.ClassNotFoundExcetpion这个异常肯定都不陌生，这个异常背后涉及到的是Java技术体系中的类加载机制。本文简述了JVM三种预定义类加载器，即启动类加载器、扩展类加载器和系统类加载器，并介绍和分析它们之间的关系和类加载所采用的双亲委派机制，给出并分析了与Java类加载原理相关的若干问题。
版权声明：
本文作者：书呆子Rico 作者博客地址：http://blog.csdn.net/justloveyou_/
一、引子 每个开发人员对java.lang.ClassNotFoundExcetpion这个异常肯定都不陌生，其实，这个异常背后涉及到的是Java技术体系中的类加载。Java类加载机制 是技术体系中比较核心的部分，虽然和大部分开发人员直接打交道不多，但是对其背后的机理有一定理解有助于排查程序中出现的类加载失败等技术问题，对理解Java虚拟机的连接模型和Java语言的动态性都有很大帮助。
二. Java 虚拟机类加载器结构简述 1、JVM三种预定义类型类加载器
我们首先看一下JVM预定义的三种类加载器，当JVM启动的时候，Java缺省开始使用如下三种类型的类加载器：
启动（Bootstrap）类加载器：引导类加载器是用 本地代码实现的类加载器，它负责将 &lt;JAVA_HOME&gt;/lib下面的核心类库 或 -Xbootclasspath选项指定的jar包等 虚拟机识别的类库 加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以 不允许直接通过引用进行操作。
扩展（Extension）类加载器：扩展类加载器是由Sun的ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的，它负责将 &lt;JAVA_HOME &gt;/lib/ext或者由系统变量-Djava.ext.dir指定位置中的类库 加载到内存中。开发者可以直接使用标准扩展类加载器。
系统（System）类加载器：系统类加载器是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的，它负责将 用户类路径(java -classpath或-Djava.class.path变量所指的目录，即当前类所在路径及其引用的第三方类库的路径，如第四节中的问题6所述)下的类库 加载到内存中。开发者可以直接使用系统类加载器。
Ps: 除了以上列举的三种类加载器，还有一种比较特殊的类型就是线程上下文类加载器，这个将在《深入理解Java类加载器(二)：线程上下文类加载器》一文中进行单独介绍。
2、类加载双亲委派机制介绍和分析
在这里，需要着重说明的是，JVM在加载类时默认采用的是双亲委派机制。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归 (本质上就是loadClass函数的递归调用)。因此，所有的加载请求最终都应该传送到顶层的启动类加载器中。如果父类加载器可以完成这个类加载请求，就成功返回；只有当父类加载器无法完成此加载请求时，子加载器才会尝试自己去加载。事实上，大多数情况下，越基础的类由越上层的加载器进行加载，因为这些基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API（当然，也存在基础类回调用户用户代码的情形）。 关于虚拟机默认的双亲委派机制，我们可以从系统类加载器和扩展类加载器为例作简单分析。
上面两张图分别是标准扩展类加载器继承层次图和系统类加载器继承层次图。通过这两张图我们可以看出，扩展类加载器和系统类加载器均是继承自 java.lang.ClassLoader抽象类。我们下面我们就看简要介绍一下 抽象类 java.lang.ClassLoader 中几个最重要的方法：
//加载指定名称（包括包名）的二进制类型，供用户调用的接口 public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException{ … } //加载指定名称（包括包名）的二进制类型，同时指定是否解析（但是这里的resolve参数不一定真正能达到解析的效果），供继承用 protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException{ … } //findClass方法一般被loadClass方法调用去加载指定名称类，供继承用 protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { … } //定义类型，一般在findClass方法中读取到对应字节码后调用，final的，不能被继承 //这也从侧面说明：JVM已经实现了对应的具体功能，解析对应的字节码，产生对应的内部数据结构放置到方法区，所以无需覆写，直接调用就可以了） protected final Class&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9094329cba23a46cf59a20ef14007f52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abb5e5df4253b6d46d060bf014caaf74/" rel="bookmark">
			win10蓝屏-你的电脑遇到问题，需要重新启动，我们只收集某些错误信息，然后为您重新启动-遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10装了一些杂七杂八的软件之后
一直出现这样的蓝屏
百度了好多还是没有解决
大概记录一下这个糟心的过程
因为工作需要所以一直不敢重装
过程1：（有人说重启就可以了，但是我的不行，所以用了点骚操作坚持了一个礼拜）
选7，重启就可以正常进入了，不过下次打开还是要这样手动设置，很伤
过程2：终于挨到周末，可以修理它了，什么更新驱动啊，还原系统啊（可能有用，但对我的问题无效）
跟新了好几个小时的系统，终于正常了，然而美国多久就蓝屏了，这次更糟糕
BIOS都进不去，就是黑屏，只有白色的鼠标可以移动（系统文件损坏）
没救了。。。。。。
最后只能用U盘重装了一波系统，蓝屏事故结束。。。。。。
总结：
大概是某些软件或者系统更新导致，更新出错之后，就只能蓝屏了（手动无奈）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02af893a06724c767ded8eaa5cbdecb4/" rel="bookmark">
			jquery获取img的src值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jquery获取img的src值..
简简单单的一句话，如下：
&lt;img id="img" src="1.jpg" alt="test" /&gt;
引用的jquery如下：
&lt;script type="text/javascript" language="javascript" src="~/Js/jquery-1.2.6.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" language="javascript" src="~/Js/jquery-1.2.6-vsdoc.js"&gt;&lt;/script&gt;
错误的写法：
1、alert($('#img'));
2、alert($('#img').src);
3、alert($('#img')); 提示[object Object]。
4、alert($('#img').src); 提示undefined。
正确的写法：
$('#img')[0].src才能够获取到img的地址。
原因：
&lt;img id="img" src="1.jpg" alt="test" /&gt;
&lt;img id="img" src="2.jpg" alt="test" /&gt;
&lt;img id="img" src="3.jpg" alt="test" /&gt;
如上，如果有很多img。
因为$("#img")获取到的是整个页面所有的img标签，是一个数组，只有明确指定是哪一个的src的时候，才能取到具体的src值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aab7bbefce2abdb2644a7d4b1fd215f/" rel="bookmark">
			VS   error c4996: &#39;fopen&#39;: This function or variable may be unsafe    解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.摘要 在调用图像处理函数，或者文字处理函数的时候，会出现类似下面这种报错。 错误	C4996	'fopen': This function or variable may be unsafe. Consider using fopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.	7.25	f:\opencv\build\include\opencv2\flann\logger.h	66	这是因为许多函数、 成员函数，模板函数和 Visual Studio 中的库中的全局变量标记为弃用。 这些函数被弃用，因为它们可能具有不同的首选的名称，可能不安全或具有更加安全的变体，或可能已过时。 许多弃用消息包括不推荐使用的函数或全局变量的建议的替换。 二.解决方法（很简单粗暴） 按照下面的步骤： 打开项目 &gt;&gt; 属性 &gt;&gt; C/C++ &gt;&gt;预处理器 &gt;&gt; 预处理器定义 然后在“_MBCS;%(PreprocessorDefinitions)”的后面加上 ; _CRT_SECURE_NO_WARNINGS 千万不要忘了分号。。。。 问题解决了。 本文为原创文章，欢迎大家转载，但不可用作商业用途。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3565addfca75abeb30587caa1f19a307/" rel="bookmark">
			微信小程序引入背景图的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.直接在标签里加上style样式，加上背景图：
&lt;view style="background:url('../../img/p.png')"&gt;&lt;/view&gt; 2.如果想使用外部样式表引入的话，直接使用background会报渲染层错误，可以将图片上传到服务器，然后在使用background
3.直接使用image标签引用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01bb26bca9500bdad00f8d0b7f833683/" rel="bookmark">
			多叉树writeToParcel造成死循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多叉树对象，保存了parent，也保存了children集合。 writeToParcel的时候，会导致 子A调父B-》父B child又调子A-》子A调父B-》父B child又调子A 。。。。无限循环， 出现TransactionTooLargeException异常，爆栈。 解决办法： @Override
public void writeToParcel(Parcel dest, int flags) {
if(isWritingParcel) return;
isWritingParcel = true;
dest.writeInt(this.mId);
//.....
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38a4f0b139c01e2fdc7cc6654e117198/" rel="bookmark">
			P问题和NP问题。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在读图解算法，看到P问题和NP问题，分享下书中的知识，加上自己的见解，帮助大家更好的理解P、NP及其他们之间的关系。
首先，我们需要了解概念。
什么是P问题？
P是英文单词多项式(Polynomial)的第一个字母。如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题。例如，常见的排序算法时间复杂度，快速排序(O(log(n)))，冒泡排序(O(n^2)))等。
什么是NP问题？
会不会所有的问题都可以找到复杂度为多项式级的算法呢？很遗憾，答案是否定的。有些问题甚至根本不可能找到一个正确的算法来，这称之为“不可解问题”(Undecidable Decision Problem)。
举出一个不大可能会有多项式级算法的问题来：Hamilton回路。问题是这样的：给你一个图，问你能否找到一条经过每个顶点一次且恰好一次（不遗漏也不重复）最后又走回来的路（满足这个条件的路径叫做Hamilton回路）。
NP问题不是非P类问题。NP问题是指可以在多项式的时间里验证一个解的问题。请注意，他只能验证一个解的问题，还是举例Hamilton回路，也就是说，你告诉他一条线路，他告诉能不能满足这个条件，告诉你YES和NO。对于这种问题，你要算出所有可能的话，只能使用穷举法。但是这种O(a^n)和O(n!)型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。
所以NP问题是时间复杂度一般是O(a^n)和O(n!)型。
P问题和NP问题的关系？
就目前还说，只有一个结论，NP问题是包含P问题的。也就是说，能多项式地解决一个问题，必然能多项式地验证一个问题的解——既然正解都出来了，验证任意给定的解也只需要比较一下就可以了。很显然，所有的P类问题都是NP问题。
剩下的一些没有被解决的问题？
NP比P大吗？
NP看起来比P大，NP包含P。
有没可能NP=P？
不知道，尚未有人证实。
目前还没有人可以证明NP=P或者NP不等于P。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/505/">«</a>
	<span class="pagination__item pagination__item--current">506/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/507/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>