<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee1f171ec55f778a546f110f14b766a2/" rel="bookmark">
			关于微信小程序背景图手机上加载不出来问题的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题:平时在给背景图的时候大家的第一反应一定是在css中直接写background-image,直接就把图片当背景放在了那里，但是这样的方法在pc端还是可以的，在小程序端却存在着加载不出来的问题，现在我来给大家提供一个解决方法（插入图片的方法）
2.原理：一个大的父盒子，同时里面包含（1.要当背景的图片2.要在背景上显示的内容）
给背景图片绝对定位定在父盒子里面
给父盒子相对定位（子绝父相）：让你的背景图可以固定在父盒子里面
给里面要显示的内容相对定位，否则你将会看不到你将要显示的内容。
这样，给小程序加背景图在手机上显示不出来的问题就解决了
3.解决方法：运用绝对定位，相对定位的知识，直接在你想要加背景图的盒子前面插入图片，用&lt;image&gt;标签来实现，话不多说，直接上代码
&lt;template&gt; &lt;view style="position: relative;"&gt; &lt;image src="../../static/photo/bgbalance.png" style="width: 692rpx; height: 276rpx;position: absolute;" mode=""&gt;&lt;/image&gt; &lt;view class="" style="padding: 83rpx 55rpx 0;position:relative;display:flex;flex-direction: column;"&gt;	&lt;view class="" style="color: #fff;font-size:26rpx;"&gt; 总余额(元) &lt;/view&gt; &lt;view class="" style="font-size: 67rpx;color: #fff;"&gt; 5,864.64 &lt;/view&gt;	&lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { } }, methods: { } } &lt;/script&gt; &lt;style&gt; &lt;/style&gt; 运行的结果展示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bc7741bb2595157e5d5949dc77a5ae0/" rel="bookmark">
			更新数据库中的部分字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实习生的数据更新原有FAreport中的数据
Sqlserver：
Excel：
运行结果：
代码：
方法一：在Update方法中写需要更新的字段
方法二：找到该条数据的实体，然后部分数据进行更新，不改变Update方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cef3e6c35c4e3df39ed413c6a0b5ce54/" rel="bookmark">
			openjdk-jdk8-b109 hotspot虚拟机启动过程分析_1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于OpenJdk 标签 jdk8-b109版本分析
HotSpot是由Oracle开发的Java虚拟机（JVM）的一种实现，也是使用最广泛的JVM之一。
找到hotspot虚拟机入口 完成编译配置后，会在根目录生成Makefile文件，如何编译jdk8 Windows平台编译Jdk8
Makefile 中找到了 Main.gmk，构建入口由此开始。
ifeq ($(words $(SPEC)),1) # We are building a single configuration. This is the normal case. Execute the Main.gmk file. include $(root_dir)/make/Main.gmk else 根目录/make/Main.gmk，这里可以看到构建目标 :jdk，具体构建过程在 BuildJdk.gmk文件。
jdk: langtools hotspot corba jaxp jaxws jdk-only jdk-only: start-make @$(call TargetEnter) @($(CD) $(JDK_TOPDIR)/make &amp;&amp; $(BUILD_LOG_WRAPPER) $(MAKE) $(MAKE_ARGS) -f BuildJdk.gmk $(JDK_TARGET)) @$(call TargetExit) 根目录/jdk/make/BuildJdk.gmk，jvm启动器由构建目标 launchers 实现，由 CompileLaunchers.gmk 提供构建过程。
launchers: libs launchers-only launchers-only: # Finally compile the launchers.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cef3e6c35c4e3df39ed413c6a0b5ce54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/060d2e5d546abbe577f40df55a9b1657/" rel="bookmark">
			PTA1-100简单题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
PTA 10-1 查询选修‘C语言’课程的学生
PTA 10-2 查询平均分高于80分的学生
PTA 10-3 查询平均成绩最高的前3名同学
PTA 10-7 spj-查询供应工程 j1 的供应商
PTA 10-9 查询年龄18-20之间的学生信息（MSSQL）
PTA 10-10 查询姓‘李’的学生记录(MSSQL)
PTA 10-11 查询部分专业的学生(MSSQL)
PTA 10-14 查询平均成绩高于75分的学生(MSSQL)
PTA 10-15 查询未登记成绩的学生（MSSQL）
PTA 10-16 查询选修‘C语言’课程的学生（MSSQL）
PTA 10-17 查询没有选修'C语言'课程的学生(MSSQL)
PTA 10-18 查询同专业的学生（MSSQL）
PTA 10-25 查询平均分高于60分的课程（MSSQL）
PTA 10-26 查询成绩最高的前三名同学(MSSQL)
PTA 10-27 查询课程成绩最高二人(MSSQL)
PTA 10-32 查询xsda表中所有女生的记录
PTA 10-33 查询xscj表中的学号，姓名，计算机三项信息，结果按计算机成绩的降序排列。
PTA 10-34 查询xscj表中的计算机成绩在80至90之间（包含80和90分）的同学的学号，姓名，计算机三项信息。
PTA 10-36 计算xscj表中计算机课程的最低分
PTA 10-38 统计xscj表中计算机课程成绩在90至100之间的人数（包含90和100）
PTA 10-39 查询xsda表中的学号、姓名、性别三项信息，结果按照女生优先的顺序显示。
PTA 10-40 统计xsda表中男女生的人数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/060d2e5d546abbe577f40df55a9b1657/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f7da630d442f567c08b0c4fe75cd324/" rel="bookmark">
			在VScode中启动的前端项目关于 Local 和 Network 两个地址的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先这两个地址在你的电脑上都是可以访问的
具体区别：
localhost 是供当前电脑访问的地址，仅供你自己访问，其他人通过localhost 是访问不到你跑的项目的。你把 localhost 换成IP地址 127.0.0.1 也是相同的效果，因为 127.0.0.1 也是表示的当前本机。
---------------------------------------------------------------------------------------------------------------------
network既可以通过你自己电脑访问，也可以供同一局域网内的其他成员访问。比如你和你的同事都是连接的公司的网络，处于同一网段，如果你的同事想访问你跑的项目，那么就可以通过 network 地址进行访问，你同事通过localhost 是访问不到你的项目的。
那么怎样查看自己电脑所处局域网的 ip 地址 步骤：打开cmd ，输入 ipconfig ， IPv4 地址就是你当前电脑所处局域网的 ip 地址。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07710780402b79e383287e6560d5c47f/" rel="bookmark">
			linux篇---更改hostname
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux篇—更改hostname sudo hostnamectl set-hostname aaa 执行以后，关闭终端，重新进入
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8745e3351680b69070348839b6168ad5/" rel="bookmark">
			Java集合，超详细整理，适合新手入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 单列集合Collection1.0 Collection接口实现类的特点1.1 Collection常用方法1.2 继承了Iterable接口1.3 Collection接口遍历元素的方法1.3.1 Iterator迭代器1.3.2 增强for循环 1.4 List接口1.4.1 List常用方法1.4.2 List接口遍历元素的方法1.4.3 ArrayList类1.4.3.1 ArrayList底层源码，1.5倍扩容，Object[]数组 1.4.4 Vector类1.4.4.1 Vector底层源码，2倍扩容1.4.4.2 ArrayList 和Vector比较 1.4.5 LinkedList类1.4.5.1 简单实现双向链表1.4.5.2 LinkedList底层源码，没有扩容，双向链表1.4.5.3 ArrayList和LinkedList比较 1.5 Set接口，不提供索引1.5.1 HashSet1.5.1.1 简单实现数组+链表1.5.1.2 HashSet底层机制，数组+链表+红黑树1.5.1.3 HashSet扩容+红黑树机制 1.5.2 LinkedHashSet1.5.2.1 数组+双向链表 1.5.3 TreeSet 2. 双列集合(Map)：2.1 Map接口实现类的特点2.2 Map常用方法，不支持索引2.3 Map接口三组遍历方法2.3.1 keySet+增强for循环2.3.2 keySet+迭代器2.3.3 values()+增强for循环2.3.4 values()+迭代器2.3.5 EntrySet+增强for循环2.3.6 EntrySet+迭代器 2.4 HashMap扩容机制2.5 Hashtable扩容机制(数组+链表)2.5.1 Hashtable与HashMap比较2.5.2 Properties实现类(继承Hashtable) 2.6 treeMap 3. 小结3.1 Collections集合工具类3.1.1 Collections.reverse()，反转集合3.1.2 Collections.shuffle()，打乱集合顺序3.1.3 Collections.sort(list); 默认按照字符串大小升序排列3.1.4 swap(list, int, int)；将指定集合中的i处元素和j处元素互换3.1.5 Collections.max(collection); 根据元素的自然顺序，返回指定集合中的最大值3.1.6 Collection.frequency(collection，Object); 返回指定集合中指定元素出现的次数3.1.7 Collections.copy(List dest, List src); 把src集合中的数据拷贝到dest中去3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8745e3351680b69070348839b6168ad5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc2e5e59480926b09da951e9492bb8c2/" rel="bookmark">
			SQL如何将正数转为负数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 select -(2-1) ; # 结果为 -1 -- 若原数就为负数，可加abs()先去绝对值，再置负 select -(1-2); # 结果为1 select -abs(1-2); # 结果为-1 -- 格式 select -column from table; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78f3f7b8e9d654abdf6a147f0dcde128/" rel="bookmark">
			struct __FILE 报错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题说明 当编译struct __FILE { int handle; /*Add whatever is needed */};时，
系统的报错问题除了struct __FILE自身以外，问题都出现在core_cm3.c这个文件中
解决方案 报错的原因是core_cm3.c和core_cm3.h文件太老，比较简单的解决方案就是将工程版本降低
修改之后再次编译
还有别的解决方案，想要了解的可以看一下下面的文章
mdk编译器切换为v6.4后报错-CSDN社区
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/327a1bd84f940c6de3957e6289e67912/" rel="bookmark">
			1.Vue-在独立页面实现Vue的增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题记 在独立页面实现Vue的增删改查，以下是具体的代码，和操作流程。
编写index.html页面 index.html文件如下：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Vue CRUD Example&lt;/title&gt; &lt;!--在线导入vue文件--&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;/head&gt; &lt;body&gt; &lt;!--这是一个Vue应用的根元素，id为"app"。 在这个元素中，你可以构建和渲染Vue组件，实现动态的交互和数据绑定。--&gt; &lt;div id="app"&gt; &lt;h1&gt;学生列表&lt;/h1&gt; &lt;!--通过v-model指令与Vue实例中的searchQuery属性进行双向数据绑定。 在输入框中输入内容时，searchQuery属性的值会自动更新，反之亦然--&gt; &lt;input type="text" v-model="searchQuery" placeholder="输入姓名进行查询"&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!--这是一个Vue的循环指令v-for，用于在表格中动态渲染学生列表。 它会遍历filteredStudents数组中的每个元素，并为每个元素创建一个表格行。 在每一行中，通过双花括号语法{{ student.name }}和{{ student.age }}来显示学生的姓名和年龄--&gt; &lt;tr v-for="(student, index) in filteredStudents" :key="index"&gt; &lt;td&gt;{{ student.name }}&lt;/td&gt; &lt;td&gt;{{ student.age }}&lt;/td&gt; &lt;td&gt; &lt;!--这两个按钮都绑定了点击事件， 当点击"编辑"按钮时，会调用editStudent方法，并传递当前学生的索引作为参数--&gt; &lt;button @click="editStudent(index)"&gt;编辑&lt;/button&gt; &lt;button @click="deleteStudent(index)"&gt;删除&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;h2&gt;添加/编辑学生&lt;/h2&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/327a1bd84f940c6de3957e6289e67912/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29bc276c4344fdf3827f0284c175722d/" rel="bookmark">
			5.Vue-在Vue框架中实现Vue的增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题记 在vue框架中实现vue的增删改查，以下是具体操作流程和代码
编写TestView.vue文件 TestView.vue文件如下： &lt;template&gt;
&lt;div id="app"&gt;
&lt;h1&gt;学生列表&lt;/h1&gt;
&lt;input type="text" v-model="searchQuery" placeholder="输入姓名进行查询"&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;姓名&lt;/th&gt;
&lt;th&gt;年龄&lt;/th&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr v-for="(student, index) in filteredStudents" :key="index"&gt;
&lt;td&gt;{{ student.name }}&lt;/td&gt;
&lt;td&gt;{{ student.age }}&lt;/td&gt;
&lt;td&gt;
&lt;button @click="editStudent(index)"&gt;编辑&lt;/button&gt;
&lt;button @click="deleteStudent(index)"&gt;删除&lt;/button&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;添加/编辑学生&lt;/h2&gt;
&lt;form @submit.prevent="saveStudent"&gt;
&lt;label&gt;姓名:&lt;/label&gt;
&lt;input type="text" v-model="newStudent.name" required&gt;
&lt;label&gt;年龄:&lt;/label&gt;
&lt;input type="number" v-model="newStudent.age" required&gt;
&lt;button type="submit"&gt;{{ editingIndex === null ? '添加' : '保存' }}&lt;/button&gt;
&lt;/form&gt;
&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29bc276c4344fdf3827f0284c175722d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0da2511d8cb811d48aef0cc22295e09b/" rel="bookmark">
			[cmake]使用依赖项指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 项目经常依赖于其他项目、资产和工件。 CMake 提供了多种将此类内容合并到构建中的方法。 项目和用户可以灵活地选择最适合其需求的方法。
将依赖项引入构建的主要方法是 find_package() 命令和 FetchContent 模块。 有时也会使用 FindPkgConfig 模块，尽管它缺乏其他两个模块的一些集成，并且本指南中不再进一步讨论。
依赖项也可以通过自定义依赖项提供程序提供。 这可能是第三方包管理器，也可能是开发人员实现的自定义代码。 依赖提供者与上述主要方法合作以扩展其灵活性。
通过 find_package() 使用预构建的包 项目所需的包可能已经构建并可在用户系统上的某个位置使用。 该包也可能是由 CMake 构建的，或者它可能完全使用不同的构建系统。 它甚至可能只是根本不需要构建的文件集合。 CMake 为这些场景提供了 find_package() 命令。 它搜索众所周知的位置，以及项目或用户提供的其他提示和路径。 它还支持包组件和可选包。 提供结果变量以允许项目根据是否找到包或特定组件来自定义其自己的行为。
在大多数情况下，项目通常应该使用基本签名。 大多数时候，这仅涉及包名称，可能是版本约束，以及 REQUIRED 关键字（如果依赖项不是可选的）。 还可以指定一组包组件。
find_package()基本签名的实例find_package(Catch2)find_package(GTest REQUIRED)find_package(Boost 1.79 COMPONENTS date_time) find_package() 命令支持两种主要的搜索方法：
配置模式：
使用此方法，该命令会查找通常由包本身提供的文件。 这是两种方法中更可靠的方法，因为包详细信息应始终与包同步。
模块模式：
并非所有包都支持 CMake。 许多不提供支持配置模式所需的文件。 对于这种情况，可以由项目或 CMake 单独提供查找模块文件。 查找模块通常是一种启发式实现，它知道包通常提供什么以及如何将该包呈现给项目。 由于 Find 模块通常与包分开分发，因此它们不太可靠。 它们通常是单独维护的，并且可能遵循不同的发布时间表，因此它们很容易过时。
根据所使用的参数，find_package() 可以使用上述方法中的一种或两种。 通过将选项限制为仅基本签名，可以使用配置模式和模块模式来满足依赖性。 其他选项的存在可能会限制调用仅使用两种方法之一，从而可能降低命令查找依赖项的能力。 有关这个复杂主题的完整详细信息，请参阅 find_package() 文档。
对于这两种搜索方法，用户还可以在 cmake(1) 命令行或 ccmake(1) 或 cmake-gui(1) UI 工具中设置缓存变量，以影响和覆盖查找包的位置。 有关如何设置缓存变量的更多信息，请参阅用户交互指南。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0da2511d8cb811d48aef0cc22295e09b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc61181d15bf3b6382c427d5d116c539/" rel="bookmark">
			arm64 smmu 驱动笔记 （4.19）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设备StreamID：sid struct iommu_fwspec { const struct iommu_ops	*ops; struct fwnode_handle	*iommu_fwnode; void	*iommu_priv; unsigned int	num_ids; u32	ids[1]; //ids保存的某device使用的streamID }; 通过iommu_fwspec_add_id函数设置：
struct iommu_fwspec { const struct iommu_ops	*ops; struct fwnode_handle	*iommu_fwnode; void	*iommu_priv; unsigned int	num_ids; //和该设备关联的总共ids/streamID u32	ids[1];//sid内容数组 }; int iommu_fwspec_add_ids(struct device *dev, u32 *ids, int num_ids) { struct iommu_fwspec *fwspec = dev-&gt;iommu_fwspec; size_t size; int i; if (!fwspec) return -EINVAL; size = offsetof(struct iommu_fwspec, ids[fwspec-&gt;num_ids + num_ids]); if (size &gt; sizeof(*fwspec)) { fwspec = krealloc(dev-&gt;iommu_fwspec, size, GFP_KERNEL); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc61181d15bf3b6382c427d5d116c539/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df8eda30a75b38a719d44ca86c69f9df/" rel="bookmark">
			Docker部署ActiveMQ,并且挂载存储和日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.拉取镜像 在线拉取镜像命令：
docker pull webcenter/activemq
服务器无网的情况下操作
第一步：找一台有网的并部署了Docker的服务器进行拉取镜像
命令：docker pull webcenter/activemq
第二步：导出镜像到本地
命令：docker save -o /home/activemq.tar webcenter/activemq 导出的镜像在/home目录下 第三步：将镜像包移动到U盘并上传到无网服务器/home目录下，在无网服务器下执行拉取本地镜像命令并修改镜像名称
拉取本地镜像命令：docker load -i /home/activemq.tar
修改镜像名称命令：docker tag activemq webcenter/activemq:latest
2.创建存储，日志目录 第一步：创建存储，日志目录
mkdir -p /home/activemq/{data,log}
第二步：赋予目录权限
chmod 777 /home/activemq/{data,log}
3.启动镜像 启动镜像命令：
docker run --name activemq -itd -p 8161:8161 -p 61616:61616 --restart=always -e ACTIVEMQ_ADMIN_LOGIN=admin -e ACTIVEMQ_ADMIN_PASSWORD=123456 -v /home/activemq/data:/data/activemq -v /home/activemq/log:/var/log/activemq webcenter/activemq:latest 解析：
-p：宿主端口：容器端口
--name:设置容器名称。
--itd:保持标准输入打开，为容器分配一个伪终端，以守护进程模式运行容器。
--restart=always:设置docker启动时，容器跟随自启。
-e ACTIVEMQ_ADMIN_LOGIN=admin：设置ActiveMQ用户名。
-e ACTIVEMQ_ADMIN_PASSWORD=123456：设置ActiveMQ密码。
-v /home/activemq/data:/data/activemq：挂载容器的存储目录。
-v /home/activemq/log:/var/log/activemq：挂载容器的日志，方便查看日志。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df8eda30a75b38a719d44ca86c69f9df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9027c10a326c358b28047447250c3761/" rel="bookmark">
			vscode源代码管理器显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正常源代码管理默认是显示成这样的：
鼠标无意不知道怎么点的突然变成这样：
git插件卸载了又重装，重新加载还是没好。仔细研究后发现，点击如下图框框后即可恢复。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9441f70ca23dec0cbce9f54ef1ac381/" rel="bookmark">
			MySQL常用修改表结构及索引的SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、索引操作
show indexs from '表名'; //查看表的索引 show keys from '表名'; //查看表的索引 show status like '%Handler_read%'; //查看索引的使用情况 handler_read_key:这个值越高越好，越高表示使用索引查询到的次数 handler_read_rnd_next:这个值越高，说明查询低效 alter table 表名 add primary key pk_nm(列名); //增加主键索引 alter table 表名 drop primary key(列名); //删除主键索引 alter table 表名 add unique(列名); //添加唯一索引 alter table 表名 add index 索引名(列1, 列2...); //添加普通索引 create index 索引的名字 on 表名(列名); //添加普通索引 create unique index 索引的名字 on 表名(列名); //创建唯一索引 CREATE [UNIQUE] [CLUSTERED| NONCLUSTERED] INDEX &lt;索引名&gt; ON &lt;表名&gt;(&lt;列名1&gt;[ASC|DESC] [, &lt;列名2&gt;[ASC|DESC].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9441f70ca23dec0cbce9f54ef1ac381/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c63a83f11945ee0faa728ec05c86b133/" rel="bookmark">
			Redis info信息含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Server 有关redis服务器的常规信息 redis_version:6.0.9 Redis服务版本
redis_git_sha1:00000000 Git SHA1
redis_git_dirty:0 Git dirty flag
redis_build_id:d35b7ac7ef0a64a4 Redis构建生成的唯一码
redis_mode:standalone Redis运行模式 单机或者集群
os:Linux 3.10.0-1062.el7.x86_64 x86_64 运行服务器的系统版本号
arch_bits:64 系统位数，32位或64位
multiplexing_api:epoll Redis所使用的事件处理机制
atomicvar_api:atomic-builtin 原子处理API
gcc_version:7.3.1 编译Redis时所使用的gcc版本
process_id:1218 当前服务的进程ID
run_id:4b3ae2c00453fb473206e18f3220444128be1b3c 在哨兵、集群模式中用于标识当前Redis服务器的唯一值
tcp_port:6379 端口号
uptime_in_seconds:13018 服务器运行时长，秒级
uptime_in_days:0 服务器运行时长，天级
hz:10 Redis的频率设置，值越大CPU消耗越高，对应的过期key等清理也会更及时
configured_hz:10 配置中的频率设置
lru_clock:4305101 自增的时钟,用于LRU管理,该时钟100ms(hz=10,因此每1000ms/10=100ms执行一次定时任务)更新一次
executable:/usr/local/bin/redis-server 执行文件路径
config_file:/etc/redis/6379.conf 配置文件路径
io_threads_active:0 io线程活动
Clients 客户端连接部分信息 connected_clients:8 当前连接数（不包含副本的连接数）
client_recent_max_input_buffer:24 最近最大输入流
client_recent_max_output_buffer:0 最近最大输出流
blocked_clients:0 被阻塞的链接，正常情况都是0，出现阻塞就需要查看阻塞原因了
tracking_clients:0 正在等待阻塞命令(BLPOP、BRPOP、BRPOPLPUSH)的客户端的数量
clients_in_timeout_table:0 超时表中的客户端
Memory 内存消耗相关信息 used_memory:2138216 已使用内存，byte级别
used_memory_human:2.04M 已使用内存，byte级别
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c63a83f11945ee0faa728ec05c86b133/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb870f2dea7615c8e2bf8a5a23687629/" rel="bookmark">
			Adobe Premiere Pro 2024 (24.0.0) 特别版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		潮玩星球推荐
「潮玩宇宙」赚钱项目0撸白嫖玩法介绍及赚钱效应分析
正文开始
Adobe Premiere Pro 2024(简称PR)是一款专业的视频编辑软件及后期视频剪辑软件.Adobe Premiere Pro中文破解版可以在RGB和YUV色彩空间以高达32位色彩分辨率对4K超清视频及360/VR视频编辑,支持VST音频插件和5.1环绕声音轨,可以导入和导出QuickTime或DirectShow,支持所有音频及视频编码格式.
Pr2024 加入了AI能，如颜色匹配、自动闪避和增强语音，以及文字剪辑(人工智能自动生成字幕，过宇幕进行剪辑视频了)，感谢2023人工智能元年，真的在一步-步谫辑视频变得简单起来了。
修改说明
by vposy, m0nkrus
pr2024特别版,premiere2024中文特别版
- 官方版改装，免激活处理，多国语言完整版
- 更新软件主屏幕(欢迎使用)UXP组件至 5.5.0.54
- 移除软件主屏幕的已经授权/试用到期的通知提示
- 禁用Adobe产品后台跟踪器和匿名数据日志上报程序
- 安装程序：基于Adobe产品独立安装程序版本 5.7.1.1
- 安装程序：解除 Windows 10 初期版系统上安装限制（by m0nkrus）
- 安装程序：移除原始安装程序的Adobe Desktop Common (公用库) 组件
- 安装程序：移除原始安装程序的Adobe Creative Cloud (创意云程序) 组件
- 安装界面：界面支持选择安装位置和界面语言，以及安装完后立即运行软件
- 安装界面：在安装过程中，安装程序界面加入了“新版特性功能的动态展示”
- Adobe CCX Process (Adobe产品数据辅助) 模块组件版本更新到 最新版
- Adobe CC Library (Adobe产品库) 模块组件版本更新到 最新版
下载链接
https://pan.quark.cn/s/fb19e07b3f65
链接：https://pan.baidu.com/s/1yIoBrRbSKHwlXQJWCjQfTg
提取码：ghxi
历史推荐
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb870f2dea7615c8e2bf8a5a23687629/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39640c8daf2fea8f46bb7ca831db6ffe/" rel="bookmark">
			Linux常见指令和基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Linux下基本指令1、ls2、pwd3、cd4、touch5、mkdir6、rmdir7、 rm8、man9、cp10、mv11、echo12、cat 及 tac13、more14、less15、head16、tail17、find18、grep19、zip/unzip20、tar21、常用热键 二、Linux下拓展指令1、date2、Cal3、bc4、uname5、top6、关机 三、权限1.用户分类2.权限管理1.文件访问者的分类2.文件类型和访问权限（事物属性）1.文件的类型2.文件的权限 3.文件权限值的表示方法1.字符表示法2.8进制数值表示方法 4.文件访问权限的相关设置方法umask 3.目录的权限4.粘滞位 前言 从这一章开始我们就要正式的进入我们的Linux的学习了，在正式学习之前我们要先熟悉一下Linux的操作和一些基础知识吧。
一、Linux下基本指令 1、ls 语法： ls [选项][目录或文件]
功能：对于目录，该命令列出该目录下的所有子目录与文件。对于文件，将列出文件名以及其他信息。
常用选项：
ls -l 列出文件的详细信息 ls -a 列出目录下的所有文件，包括以 . 开头的隐含文件。 ls -i 输出文件的 i 节点的索引信息。 如 ls –ai 指定文件 ls -R 列出所有子目录下的文件。(递归) ls -t 以时间排序。 ls -1 一行只输出一个文件。 操作演示：
ls的选项是可以组合使用的
其他选项：
-d 将目录象文件一样显示，而不是显示其下的文件。 如：ls –d 指定目录 -k 以 k 字节的形式表示文件的大小。ls –alk 指定文件 -n 用数字的 UID,GID 代替名称。 （介绍 UID， GID） -F 在每个文件名后附上一个字符以说明该文件的类型，“*”表示可执行的普通文件；“/”表示目录；“@”表 示符号链接；“|”表示FIFOs；“=”表示套接字(sockets)。（目录类型识别） -r 对目录反向排序。 -s 在l文件名后输出该文件的大小。（大小排序，如何找到目录下最大的文件） 2、pwd 语法：pwd
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39640c8daf2fea8f46bb7ca831db6ffe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0067c56bc95669fc82e66ed2bf4859ef/" rel="bookmark">
			运维 | 如何在 Linux 系统中删除软链接 | Linux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运维 | 如何在 Linux 系统中删除软链接 | Linux 介绍 在 Linux 中，符号链接（symbolic link，或者symlink）也称为软链接，是一种特殊类型的文件，用作指向另一个文件的快捷方式。
使用方法 我们可以使用 ln 命令来创建软连接，那么怎样删除呢？
Linux 中没有用于删除符号链接的特殊命令，不过可以使用 rm 命令，该命令主要用于删除文件和目录，如下：
$ rm [file|dir] 当然也可以使用 unlink 命令，但是不要直接使用软链接的名称，因为它不仅仅用于删除链接，还会删除文件。
$ unlink [file] 注意
unlink 命令只能删除文件，而不能删除目录
下面我们来详细看一下。
使用 ln 命令创建符号链接 ln &lt;-s|-f&gt; [symlink_origin_file|symlink_origin_dir] [symlink_target_file|symlink_target_dir] 使用 rm 命令删除符号链接 在 rm 命令后面提供链接路径的名称：
$ rm [symlink_file|symlink_dir] 我们来看个具体例子，如下命令中列出当前路径中的文件：
$ ls -l 参考示例
上述列表中 my_link.txt 为符号链接，大家可以看到其是以 l （表示链接）开头，名称显示它指向的文件。
我们使用 rm 删除它，并验证：
$ rm my_link.txt $ ls -l 参考示例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0067c56bc95669fc82e66ed2bf4859ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7280dfc5a76af1082f3d47ae4067068/" rel="bookmark">
			【Candence报错】Discrepancy #i in TASK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 Candence LVS仿真提示网络不匹配
问题解决 检查原理图和Layout中的网络是否平匹配。若不匹配建议修改Layout
注意：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/001d02521808bb3b75042f2928d956ad/" rel="bookmark">
			Elasticsearch7.x——Search API详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Search API1、URI模式2、Body模式2.1、Explain参数2.2、折叠结果（collapse）2.2.1、展开折叠结果2.2.2、二级折叠 2.3、对结果分页2.4、高亮结果2.4.1、unified高亮器2.4.2、plain高亮器2.4.3、fvh高亮器2.4.4、为字段设置高亮器2.4.5、highlight_query查询2.4.6、高亮器类型选择2.4.7、配置高亮器标签2.4.8、_source字段高亮显示2.4.9、高亮显示所有字段2.4.10、组合字段高亮显示2.4.11、高亮字段排序2.4.12、高亮片段控制2.4.13、Posting List的应用2.4.14、为Plain高亮器指定片段 2.5、索引加权2.6、命中文档嵌套2.6.1、嵌套的inner_hits2.6.2、嵌套内部名字和_source2.6.3、嵌套对象字段和内部命中的层次级别2.6.4、父子嵌套 2.7、分数值过滤2.8、查询命名2.9、post_filter过滤2.10、分片选择（preference）2.11、重排序2.12、脚本字段2.13、滚动查询2.13.1、保持搜索上下文处于活跃状态2.13.2、清理搜索上下文2.13.3、切片 2.14、search_after参数2.15、搜索类型2.16、排序2.16.1、排序方式2.16.2、多值字段排序模式2.16.3、嵌套对象的排序2.16.4、缺失值的处理2.16.5、地理距离排序2.16.5.1、JSON经纬度格式2.16.5.2、逗号分隔格式2.16.5.3、pin码格式2.16.5.4、数组格式2.16.5.5、两点距离格式 2.16.6、自定义脚本排序 2.17、_source字段过滤2.18、存储字段2.19、total返回值详解（track_total_hits）2.20、版本控制（_version） 3、返回索引分片信息（_search_shards）4、Count API5、Validate API6、调试（_explain） Search API 搜索API(_search)允许用来执行搜索查询并返回匹配的结果。 可以使用简单查询字符串作为参数提供查询(URI形式)，也可以使 用请求正文(body形式)。大多数搜索API都是支持多索引的， Explain API除外(用于调试性能)。
//语法 GET /&lt;index&gt;/_search GET /_search POST /&lt;index&gt;/_search POST /_search 所有搜索API都支持跨索引机制，并支持多索引语法。例如，搜 索twitter索引中的所有文档:
GET /twitter/_search?q=user:kimchy 还可以在多个索引中搜索具有特定标记的所有文档，例如当每个 用户有一个索引时:
GET /kimchy,Elasticsearch/_search?q=tag:now 或者使用_all搜索所有可用索引:
GET /_all/_search?q=tag:now 为了确保快速响应，如果一个或多个分片失败，搜索API将以部 分结果响应。
1、URI模式 通过提供请求参数，可以纯粹使用URI执行搜索请求。在使用此 模式执行搜索时，并非所有搜索选项都可用，但对于快速的“测试” 来说，它非常方便。
GET twitter/_search?1=user:kimchy URI搜索模式支持的参数如下表：
2、Body模式 搜索请求可以在请求正文中使用Query DSL:
GET /twitter/_search { "query" : { "term" : { "user" : "kimchy" } } } Body搜索模式支持的参数如下表：
注 意 : search_type 、 request_cache 和 allow_partial_search_results必须作为查询字符串参数传递(不能放在body里面，要放在URL里面)。搜索请求的其余部分应该在主体内 部传递。正文内容也可以作为名为source的REST参数传递。HTTP GET 和HTTP POST都可以用于执行带Body的搜索。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/001d02521808bb3b75042f2928d956ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39de7c25b5fd7df2528f9447c3b2f844/" rel="bookmark">
			软件工程（小小总结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件工程的概念与发展 软件工程概念的提出与发展 一、软件危机 1、软件开发的速度
2、软件制品的质量
3、软件开发成本
二、软件工程 应用计算机科学理论和技术以及工程原则和方法，按预算和进度实现满足用户要求的软件产品的工程，或以此为研究对象的学科。
三、软件工程的发展 1、20世纪60一80年代初
开发模型、开发方法、支持工具
2、20世纪80年代末一今
软件复用技术、软件生产管理
一、软件开发的本质 1、软件开发的目标 映射将问题域中的概念映射为运营平台层面上的概念 2、软件开发的本质 不同抽象层术语之间的“映射”，以及不同拍象层处理逻辑之间的“映射”。
如何实现这样的映射? 技术问题
如何管理这样的映射? 过程途径
问题建模
3、模型的概念 模型是一个抽象。模型是在特定意图下所确定的角度和抽象层次上对物理系统的描述，通常包含对该系统边界的描述、对系统内各模型元素以及它们之间关系的语义描述
4、模型的类别 概念模型：描述软件是什么软件模型：实现概念模型的软件解决方案包括设计模型、实现模型和部署模型 eg:
在软件开发领域中，“描述了系统是什么”的系统模型被称为：概念模型
本体考查对模型及模型分类的理解和掌握
(1)概念模型：描述软件是什么
2)软件模型：实现概念模型的软件解决方案。包括设计模型、实现模型和部署模型
小结 软件危机的出现，导致了软件工程的引入软件开发的本质，实现问题空间的概念和处理逻辑到解空间的概念和处理逻辑之间的较则。系统建模是指运用所掌握的知识，通过抽象，给出系统的一个结构。模型是一个抽象在软件开发领域，模型有两大类：概念模型 和软件模型。 二、需求获取 温伯格名言:“明白自己在做什么”
杰拉尔德·温伯格Gerald M Weinberg)是著名的软件和系统思想家，美国计算机名人堂代表人物。这个名人堂至今只有20名成员。为中国读者所熟悉的比尔·盖茨和迈克尔·戴尔等也是在他之后方才获得这一计算机界至高无上的殊荣
1、需求与需求获取 1）需求的定义 一个需求是有关一个“要予构造”的陈述，描述了待开发产品 系统功能能力、性能参数或其它性质。
2）需求的基本性质 必要的无歧义的可测的可跟踪的可测量的 3）需求的分类 功能需求，是整个需求的主体非功能需求：性能需求、外部接口需求、设计约束和质量属性需求 !能够区分哪些是功能需求，哪些是性能 需求
功能需求性能需求接口需求设计约束 7类接口: 用户接口，硬件接口，软件接口，通信接口，内存约束，运行，地点需求
质量属性 eg：
分析下列哪些是功能需来?
功能：系统产生月销售报表功能：根据销售金额计算销售税性能：系统应在3秒内计算出销售税设计约束：系统必须使用JAVA语言编写性能：系统至少支持1000个并发访问接口：系统支持TCP IP协议 4）需求发现技术 1、自悟
2、交谈
3、观察
4、小组会
5、提炼
2、需求规约 (SRS) 1）需求规约的定义 *** 是一个软件/产品 /系统所有需求陈述的正式文档，它表达了一个软件/产品 /系统的概念模型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39de7c25b5fd7df2528f9447c3b2f844/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0af5dd3f83658c9f39f7915e4b2dd7b/" rel="bookmark">
			【爬虫】data: image/png； base64图片数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 爬wx小程序时遇到了响应返回下面的信息
{"Image":"data:image/png;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAAeAEADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD3uCNoreON5nmdECtLIFDOQPvHaAMnrwAPQCiGFYEKIXILs/zuznLEseSScZPA6AYAwABXIPruqr411Xw/e6np1pbnTTeWUkEB+0KpJUs252XKEZ+7hs9sEVZ07X9Z0+xjm8WWtrDDL8yXtgkpjjXr+/QgmHC8lizINrbmX5dz1auD0djZ1bWbLSIM3N9YW9xIrfZ0vLpYFlYYAG45OMlQSAcZHB6UWOpWOt288G0eYg8u8sZwvmQkjlJEyRyM4PKsOVLKQTxOix3etfEbxGLm+0rUNJlsrPdH9iLpNbuJWQKTKV75JwwbPAWutvdOlsbh9R0mBXZwBd2IIVbpQAAVzgLKFAAJwGACMQAjRroPZ2NLzI76E/ZbzASUBngZW5VhuQ5BHOCp7gE4IOCLFef6HeajZ+GtTvtHgs0sra8uZVt54njd0DklQPl8ohRgAqeeCFxXYxXi6hof2wWMsqTQl1tW2FpVIOF5bb8w6ZI6845xKd1934mtSlyPfS9i3DMs6F0DgB2T542Q5UlTwQDjI4PQjBGQQakriPDPhvQ72z1dLnSLGQDUrmJSYFyqBsAKcZAHbHSrfhWW8t9b1rRHumns9PkTyWlBaQCRQyrvJ6LgjkE8jkYxQpXt5q450Uuaz+H/AIYu674b03XNT0yeeQQ3trL5ymMgPNEoKtGe5T95z9fet+iiqMHrqchpnhjUtD8T6xr0d5aXEN8uX0+10/ynYrvZdrmbbvZnJYsMMST8ua6+o4zMXlEiIqB8RFXLFlwOSMDac7hgZ4AOecCSnsrB1ucePC2rQ6jqVtb6mn9hanL5s8T586IuHMnlnGAGPljHoWI2sCX6sReVa+TbbI9ibY8rlVwMDjIyPbIqWipsi5VJS3OWt/Des2tpdW8Ot2qC4umuy62Uisrlg3BEw4yBwcgjIOQSK19G0W30WCZYpJZpriUzTzzEF5XPc4AA9AAAK0qKFFLYcqs5Xv1P/9k=","Keyword":"dcc1a5fd373947e4adf7d735f263a6be"} 经过查阅资料发现，data:image/png;base64, 字符串…其实是Data URI scheme，URI表示统一资源标识符uniform resource identifier，字符串表示的是经过base64编码的图片数据
通常遇到的图片是如下形式，称为Http URI scheme
&lt;img src="http://sjolzy.cn/images/A.jpg"/&gt; base64和图片的转化的在线网站
http://www.yzcopen.com/img/imgbase64
Python实现图片的base64转换和解析
import base64 # 图片转base64,返回base64编码结果 def ImageToBase64(img_path): with open(img_path,"rb") as f:#转为二进制形式读取图片 base64_data = base64.b64encode(f.read())#使用base64进行加密 return base64_data # base64转图片并保存，imgStr是base64字符串，imgName文件名 def Base64ToImage(imgStr,imgName): imgdata = base64.b64decode(imgStr) with open(imgName,'wb') as fp: fp.write(imgdata) print(imgName + "保存成功！！！") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/780a5391ecdcf8d36f0548e1e2843670/" rel="bookmark">
			lambda refinement for body RadiationSurface might reach
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HFSS2021R1仿真时遇到此问题，百度时看到如下解答，但是因为内存不够的原因。
经过查阅资料和思考，发现是RadiationSurface的网格分的太大导致的，应该让网格单元的长度必须小于 1/3 个波长。
修改后即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/009198d76b784d033a11c903338af640/" rel="bookmark">
			OpenCV-Python读取视频，识别物体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 打球的时候，我们常常要用眼睛去识别球的位置，确定球的落点和轨迹。用摄像头和视频捕捉物体的位置，确定中心坐标，绘制轮廓边框，就成为了基于Python的OpenCV（Opencv for Python）要处理的重要问题。
思路 1.获取原视频 cap=cv2.VideoCapture('ballsvideo.mp4')#获取原视频 cv2.namedWindow('processed_video', cv2.WINDOW_NORMAL) #创建一个可调整大小的窗口 cv2.resizeWindow('processed_video', 500, 800)#设置窗口宽度为500，高度为800 2.逐帧读取原视频 while True: ret,frame=cap.read()#读取原视频每帧 if not ret:#直到视频没有下一帧了才结束 break processed_frame=process(frame)#处理每帧 cv2.imshow('processed_video',processed_frame)#逐帧播放新视频 if cv2.waitKey(1) &amp; 0xFF == ord('q'):#按q键退出视频播放 break 3.逐帧处理 把RGB图像转变成HSV图像 hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV) 在利用OpenCV进行颜色识别时，通常会将图像从RGB（红绿蓝）颜色空间转换到HSV（色调、饱和度、亮度）颜色空间。
HSV颜色空间能够更好地分离颜色信息（通过色调Hue），而RGB颜色空间中的颜色信息是分散在三个通道中的。在HSV空间中，色调（H）通道表示颜色，而饱和度（S）和亮度（V）通道表示颜色的强度和亮度，这使得颜色分析和识别更为简单直接。而且HSV颜色空间对光照变化具有较好的稳定性。在RGB空间中，光照变化会影响R、G和B三个通道的值，而在HSV空间中，光照变化主要影响V通道的值，而H通道（颜色）的值相对稳定。
颜色掩码区分颜色 #颜色掩码 #绿色掩码 lower_green, upper_green = numpy.array([35, 50, 50]), numpy.array([85, 255, 255]) green_mask = cv2.inRange(hsv, lower_green, upper_green) #红色掩码 #红色在hsv颜色空间有两个范围 lower_red1, upper_red1 = numpy.array([0, 50, 50]), numpy.array([10, 255, 255]) lower_red2, upper_red2 = numpy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/009198d76b784d033a11c903338af640/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1ba0740b782fa04e201372bf68319aa/" rel="bookmark">
			Qt qInstallMessageHandler详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt qInstallMessageHandler详解 引言一、官方例子及参数详解1.1 Qt默认的消息处理1.2 官方qInstallMessageHandler例程1.3 参数详解 二、增加打印信息2.1 效果2.2 代码 三、重定向至文件3.1 效果3.2 代码 引言 qInstallMessageHandler用于安装自定义的消息处理程序，返回指向上一个消息处理程序的指针 (此函数在Qt 5.0中被引入)：
函数原型：QtMessageHandler qInstallMessageHandler(QtMessageHandler handler) 这个函数允许码农完全控制Qt库中产生的警告、错误等消息的输出，改变Qt库的默认行为，对于调试应用程序，或者记录应用程序的运行过程非常有用。调用qInstallMessageHandler(0)，将会恢复Qt默认的消息处理程序。
相比QsLog、Log4Qt等第三方库简单，容易上手，功能复杂建议直接学习第三方日志库，无需重复造轮子。
一、官方例子及参数详解 1.1 Qt默认的消息处理 输出
#include &lt;QCoreApplication&gt; #include &lt;stdio.h&gt; #include &lt;QDebug&gt; int main(int argc, char *argv[]) { QCoreApplication a(argc, argv); qDebug("123"); // 无需#include &lt;QDebug&gt; qDebug() &lt;&lt;"123"; // &lt;&lt;需#include &lt;QDebug&gt; qWarning("123"); return a.exec(); } 1.2 官方qInstallMessageHandler例程 输出：
#include &lt;QCoreApplication&gt; #include &lt;stdio.h&gt; #include &lt;QDebug&gt; void myMessageOutput(QtMsgType type, const QMessageLogContext &amp;context, const QString &amp;msg) { QByteArray localMsg = msg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1ba0740b782fa04e201372bf68319aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5352e23ae8de8c3eb43740f969fadac1/" rel="bookmark">
			uniapp中全局页面挂载组件（H5）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我们已经学习了
uniapp中全局页面挂载组件（小程序）
有些小伙伴问在H5怎么做那让我们试一试
直接上代码
//引用组件 import dialog from './index.vue'; //我这里要把小程序的方法和h5方法写一起所以用了混入 import mixins from './mixins.js' //使用Vue构造器 const DialogConstructor = Vue.extend(dialog) //创建组件的Dom let DialogConstructorDom = { el: document.createElement('div'), ...mixins//将方法放入到dom中 } //生成已经创建的实例 let hsDialogDom = new DialogConstructor(DialogConstructorDom) //利用原生dom方法，将dom插入到body中 document.body.appendChild(hsDialogDom.$el) //调用组件中的方法 hsDialogDom.open()// 这个就是组件里的方法 1.其实就是使用Vue的extend创建一个“子类”
2.然后把相关参数（挂载到哪个元素上、相应的方法、参数等等）、new之后就生成了一个实例
3.将dom插入到页面中某个元素上
4.然后后面可以调用组件的方法
Vue.extend方法官方文档
官方的文档使用的是另一种方法挂载到某个元素上 其实都是可以的
结合这个方法可以同时插入到小程序和H5页面上
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a27fd083d4cddf152fe784c8eb47a5/" rel="bookmark">
			1.Python-用Python做一个Web网页需要学习什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要学习以下几个方面： 1.基本的Python编程知识：了解Python语法和常用的编程概念，包括变量、数据类型、控制流、循环、函数等。
2.网络编程基础知识：了解HTTP协议、URL结构、请求和响应等基本概念。
3.Web框架：选择一种Python的Web框架，如Django、Flask或Bottle等，并学习框架的基本用法和工作原理。
4.HTML和CSS：学习基本的HTML标签和CSS样式，用于构建网页的结构和外观。
5.模板引擎：大多数Web框架都使用模板引擎来将Python代码和HTML模板结合，学习模板引擎的语法和用法。
6.数据库：学习如何使用Python连接和操作数据库，如MySQL、PostgreSQL或MongoDB等。
7.前端技术：学习JavaScript和相关的前端框架，如React或Vue.js，用于增强网页的交互性和用户体验。
8.安全性：了解常见的Web安全问题和漏洞，学习如何保护网站免受攻击。
具体流程 选择一个web框架：Python有很多优秀的web框架可供选择，如Django、Flask、Bottle等。选择一个适合你需求的框架，并按照它的文档进行安装和配置。
创建项目和应用：在框架中创建一个新的项目，并在项目中创建一个或多个应用（也称为模块或组件），应用可以包含不同页面和功能。
定义URL路由：指定URL与对应的视图函数之间的映射关系，可以通过装饰器或配置文件来实现。当用户访问特定的URL时，web框架会调用对应的视图函数来处理请求并生成响应。
定义视图函数：编写视图函数来处理URL请求，可以通过参数获取请求数据、查询数据库等，并生成网页的内容作为响应返回给客户端。视图函数可以返回HTML页面、JSON数据等不同的响应类型。
编写HTML模板：使用HTML和模板引擎来构建网页的结构和样式。在视图函数中，可以使用模板引擎来将Python代码和HTML模板结合，以实现动态内容的生成。
处理表单和用户输入：如果网页需要处理用户输入或表单提交，需要在视图函数中接收并处理这些数据，并返回相应的结果。
静态文件管理：如果网页需要引用静态文件，如CSS、JavaScript、图片等，需要将这些文件放置在指定的静态文件目录，并在HTML中使用相应的URL引用它们。
数据库操作：如果你的网页需要与数据库交互，需要学习如何连接和操作数据库，执行增删改查等相关操作。
部署和调试：最后，在服务器上部署你的网页，并进行调试和测试。这可能涉及到配置服务器环境、安全设置、日志记录等。
后记 觉得有用可以点赞或收藏！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1c0025973dca4d15e24920165918431/" rel="bookmark">
			Verilog语言中如何将memory型变量转换为普通变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Verilog 2001和Verilog2005 能够将memory转换成为vector型变量，综合工具可以选择synplify pro 9.6.2
module memory2vector( mem,vec);
parameter vectorsize = 4;
parameter arraysize = 3;
input [vectorsize-1:0] mem [arraysize-1:0]; // 输入端口input定位为存储器的形式是在Verilog2005标准中实现的 output[vectorsize*arraysize-1:0] vec; // 仅在Verilog2005标准中支持input，output 为memory型数据 genvar i,j; // genvar 和generate功能强大，可以配合for循环作一些规律性的赋值，
generate //而这仅是在Verilog2001标准中能够实现的，Verilog95无法完成
for(i=0;i&lt;=arraysize-1;i= i+1)begin:array
for(j =0; j&lt;= vectorsize-1;j= j+1) begin:vetor
assign vec[i*vectorsize+j] = mem[j];
end end
endgenerate endmodule
总结：写法花哨，synplify pro 、quartus可以综合，但ISE中不支持，具体原因可能是ISE不支持Verilog2005标准吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f47fb80221cd071544a0a0a5fa6c0b9/" rel="bookmark">
			【数据结构】单链表的相关操作（头插和尾插建立）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		建立单链表 头插法建立单链表带头结点的不带头结点的 尾插法建立单链表带头结点的不带头结点的 头插法建立单链表 头插法建立一个单链表：每次都是在单链表的头部插入结点，从而建立一个单链表。 带头结点的：就是每次都插在头结点后面的第一个 不带头结点的：就是每次都插在单链表的第一个实际结点上 注意：是建立，从单链表为空状态开始建立，不是在某个位序或者某个结点的前面插入 思路： 1、无论如何，结构体成员和初始化单链表是必做的事情 2、头插法建立： (1)调用scanf函数输入新结点的数据域的值 (2)要给定一个范围，不然永远无法结束输入 (3)声明一个指针变量s，指向新建的结点，简称s结点 (4)要给新结点分配存储空间，新结点的数据域就等于刚刚输入的值 (5)新结点的next指针指向头结点的下一个结点，再让头结点的next指针指向s结点，这样新结点s才能成为 头结点后面的第一个结点 (6)然后要再调用scanf函数让用户再输入下一个结点的值，依次循环，知道单链表建立完跳出循环体 (7)此时返回单链表，那么调用头插法函数，就可以通过在终端输入而建立一个单链表了 3、在main函数中声明一个指针变量L作为单链表的头指针，头指针指向头结点，调用头插建立函数 带头结点的 // 头插法建立单链表（带头结点单链表） #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; // 声明单链表结构体成员 typedef struct LNode { int data; struct LNode *next;	}LNode, *LinkList; // 初始化单链表 LinkList initList() { LinkList L=(LNode *)malloc(sizeof(LNode)); if(L==NULL) { return NULL; } L-&gt;next=NULL; return L; } // 头插法建立 LinkList head_insert(LinkList &amp;L) { int value; printf("请输入结点值："); scanf("%d", &amp;value); while(value!=-1) { LNode *s=(LNode *)malloc(sizeof(LNode )); s-&gt;data=value; s-&gt;next=L-&gt;next; L-&gt;next=s; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f47fb80221cd071544a0a0a5fa6c0b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a284835f22f705c253c972d157a5adb/" rel="bookmark">
			Goland Cannot use ‘err‘ (type error) as the type any
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
用Goland写代码的时候，使用panic总是报错，官方用法也是报错，最后找到官方回复的链接，https://youtrack.jetbrains.com/issue/GO-12179/Cannot-use-err-type-error-as-the-type-any
问题解决方式：
Update the IDE instance to the latest available version: 2021.3.4.
就是升级你的GoLand升级到2021.3.4，好像要一个一个版本的升级
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/013ce040020dd6adb4dca4c057ec107f/" rel="bookmark">
			将 vue2&#43;ElementU 项目打包成安卓app
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标：将vue项目打包成安卓app
工具：HbuilderX
1.在HbuilderX中创建一个 5+App 项目 创建好的app项目目录 2.将vue项目打包 2.1 在 vue.config.js 中添加公共路径（解决打包后的app图片不显示问题） module.exports = defineConfig({ // 项目打包成app时需要添加公共路径 publicPath: './' }) 2.2 将所有后端接口都设置为绝对地址，不能使用代理。（解决打包后app调用后端接口跨域问题） 2.3 路由模式改为 hash const createRouter = () =&gt; new Router({ mode: 'hash', routes: constantRoutes }) 2.3 如果vue项目中有文件上传、下载功能，打包成安卓app后功能失效。 2.3.1 下载文件问题截图 2.3.2 下载文件解决方法 2.3.2.1 使用H5 Plus（官网）下载文件 安装依赖
npm install vue-awesome-mui main.js 文件添加代码
import Mui from "vue-awesome-mui" Vue.config.productionTip = false Vue.use(Mui); 下载文件方法中判断，如果为 安卓app项目，则使用 plus.downloader.createDownload()来下载文件
// 是否为安卓app isInAndroid(){ var u = navigator.userAgent return u.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/013ce040020dd6adb4dca4c057ec107f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfbae6ace29e8817c42c2cde61734fab/" rel="bookmark">
			python篇---python打印报错行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python打印报错行的实现 步骤1：捕获异常步骤2：输出异常信息步骤3：打印报错行完整代码示例 作为一名开发者，我将教你如何在Python中打印报错行。这个技巧对于定位和解决代码中的错误非常有帮助。下面是详细的步骤和代码说明。
步骤1：捕获异常 首先，我们需要在代码中捕获异常。这样，如果发生错误，我们就可以获取到错误的详细信息。在Python中，我们使用try-except语句来捕获异常。
try: # 你的代码 except Exception as e: pass 在这段代码中，你需要将你的代码放在try块中。如果在这段代码执行时发生了异常，程序将会跳转到except块，并执行其中的代码。Exception as e语句将捕获的异常赋值给变量e，这样我们就可以在后面使用它。
步骤2：输出异常信息 在except块中，我们需要输出异常的详细信息。这些信息包括错误类型和错误消息。我们可以使用type()和str()函数来获取这些信息。
except Exception as e: error_type = type(e).__name__ # 获取错误类型 error_msg = str(e) # 获取错误消息 在这段代码中，type(e).__name__返回异常对象的类型名称，比如NameError、ValueError等。str(e)将异常对象转换为字符串，得到详细的错误消息。
步骤3：打印报错行 最后，我们需要找到报错的行号并打印出来。为了实现这一步骤，我们可以使用traceback模块。这个模块提供了一些用于追踪异常的函数。
import traceback except Exception as e: traceback.print_exc() 在这段代码中，我们使用traceback.print_exc()函数来打印完整的异常追踪信息，包括报错行号。
完整代码示例 下面是一个完整的示例代码，展示了如何在Python中打印报错行。
import traceback try: # 你的代码 except Exception as e: error_type = type(e).__name__ # 获取错误类型 error_msg = str(e) # 获取错误消息 traceback.print_exc() # 打印异常追踪信息 总结
通过以上步骤，我们可以轻松地实现在Python中打印报错行。这个技巧对于开发者来说非常有用，可以帮助我们更快地定位和修复代码中的错误。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfbae6ace29e8817c42c2cde61734fab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48aa414cc35e30b555a2581bfeb3162c/" rel="bookmark">
			BUUCTF学习(10): 文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、介绍
2、解题
?key=123
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21c953c633e091a7ed9d8a5e73f28f1a/" rel="bookmark">
			适配LVGL界面图片和文字显示很虚，色阶明显的解决方法（全志R128适用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LVGL界面图片和文字显示很虚，色阶明显的具体问题情况如下图
初步分析为RGB参数问题，先调出Colorbar检查一下
disp -c 0 8 显示如下，无异常 disp -c 0 1 显示如下，有条纹 此时问题可能出现在两个方向
1、rgb接线不稳定有干扰
2、色彩级数配置问题
1、rgb接线不稳定有干扰
检查杜邦线连接很紧，排除干扰导致的文字显示虚化
2、色彩级数配置问题
查找R128在线文档显示与屏幕驱动相关内容，选择一下参数进行配置，后解决问题
文档链接：https://r128.docs.aw-ol.com/sdk_base/disp/#480x480-rgb-86
修复好之后的显示效果，一切正常了
原贴链接：https://bbs.aw-ol.com/topic/4359/
资源获取、问题讨论可以到全志在线开发者社区进行：https://www.aw-ol.com
全志及开发者最新动态可以关注全志在线微信公众号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0d851427ab9d18813372b74343f0fe5/" rel="bookmark">
			BUUCTF学习(8): 随便注，SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、介绍 2、解题 1;set sql_mode=PIPES_AS_CONCAT;select 1
结束
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e593f2594d1324fb24b74475a9f9643/" rel="bookmark">
			BUUCTF学习(7): 随便注，固网杯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、介绍 2、解题 11';show tables;#
select * from `1919810931114514`
concat(`sel`,`ect from 1919810931114514` ')
PEREPARE y
from
sql;
ECCUTE y;
-1';
sEt @sql = CONCAt('se','lect * from `1919810931114514`;')；
prePare stmt from @sql;
EXECUTE stmt;
#
结束
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cceeb34c685cd88ea9fe5ea5e87ebd2/" rel="bookmark">
			多线程场景应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景一：数据拆分多个subList, 分批多线程导入
// map拆分成多个subList
List&lt;Map&lt;String, List&gt;&gt; userParams= MapUtil.mapChunk(userParam, BATCH_COUNT);
AtomicReference&lt;CompletableFuture&gt; all = new AtomicReference&lt;&gt;();
userParams.stream().forEach(userListMap -&gt; {
// 每一个subList 创建一个线程处理，以下是无参返回
CompletableFuture cf = CompletableFuture.runAsync(() -&gt; {
try {
// 此处要注意父级线程往子线程的参数传递，不然在子线程中会存在取不到值的情况
List threadTemp = new ArrayList&lt;&gt;();
userListMap.entrySet().stream().forEach(s -&gt; {
threadTemp.addAll(s.getValue());
});
// 保存业务数据
saveData(threadTemp);
} finally {
} }); all.set(CompletableFuture.allOf(cf));
});
all.get().join();
场景二：数据列表查询(一个方法多线程处理业务) 拆分多线程处理
List comList = new ArrayList&lt;&gt;();
// 该计数器，是为了等待所有线程都执行完了，在往后执行
CountDownLatch countDownLatch = new CountDownLatch(1); // 1 代表会初始化1个计数，这个是跟随创建线程数量保持一致
CompletableFuture cf = CompletableFuture.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cceeb34c685cd88ea9fe5ea5e87ebd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7733f0f84ec568d984a29668c5c4198/" rel="bookmark">
			入网小助手lsAgent卸载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多互联网公司因为某个项目的内网会要求员工安装入网小助手，那么项目结束后，我们该怎么卸载呢，这里给大家提供一个暴力卸载方式，无需下载任何其他软件来辅助卸载
①打开任务管理器，找到lsHelp（即入网小助手进程），右键选择打开文件所在位置，进入入网小助手所在的下载文件夹
②在入网小助手的文件夹中全选进行删除，注意部分文件会提醒入网小助手正在运行中，这时候打开任务管理器，在进程把lsHelp的相关进程全部选择结束任务。
③删除到只剩几个文件的时候，再对入网小助手进行卸载，这时候会直接卸载，不会弹出验证码框
总结：本文为笔者在查询相关卸载入网小助手文章加上自己摸索来创作，总体思路为将入网小助手与验证码卸载相关的文件删除，这样我们在卸载时就不会出现验证码卸载环节，另外笔者最后是用软件管家和电脑自带的程序管理与删除来进行入网小助手删除的最后一步，因为笔者卸载成功的时候未进行记录，所以未进行步骤的详细记录，如有相关建议和办法，敬请补充！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/982be50bd3dbb7e19248171174c6c47d/" rel="bookmark">
			后缀表达式（是什么，如何转换）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后缀表达式 一、什么是后缀表达式 后缀表达式（也称为逆波兰表达式）是一种数学表达式的表示方法，其中操作符位于操作数的后面。这种表示法消除了括号，并且在计算机科学和计算中非常有用，因为它更容易计算和解析。
与中缀表达式（通常我们使用的数学表达式，例如"a * (b + c)"）不同，后缀表达式的运算符放在操作数之后，例如：“a b c + *”。后缀表达式的计算方法是从左到右遍历表达式，遇到操作数时将其压入栈，遇到操作符时从栈中弹出所需数量的操作数进行计算，然后将结果重新压入栈。这个过程一直持续到整个表达式处理完毕，最终栈中只剩下一个结果，即表达式的计算结果。
后缀表达式具有以下优点：
不需要括号，因此消除了歧义。更容易计算，因为遵循一定的计算顺序。适用于计算机的堆栈操作，因此在编译器和计算器中经常使用。 转换中缀表达式为后缀表达式需要使用算法，通常是栈数据结构。
二、后缀表达式的运算顺序 后缀表达式的运算顺序是从左到右遍历表达式，遇到操作数时将其压入栈，遇到操作符时从栈中弹出所需数量的操作数进行计算，然后将计算结果重新压入栈。这个过程一直持续到整个表达式处理完毕，最终栈中只剩下一个结果，即表达式的计算结果。
后缀表达式的运算顺序是非常直观的，它遵循从左到右的顺序。当计算后缀表达式时，按照以下规则：
从左到右扫描后缀表达式中的每个元素（操作数或操作符）。如果遇到操作数，将其推入栈。如果遇到操作符，从栈中弹出所需数量的操作数进行计算，然后将计算结果推回栈中。重复这个过程，直到遍历完整个后缀表达式。 这个过程确保了正确的操作数和操作符的配对，以及正确的操作顺序。因为操作符位于操作数的后面，所以在后缀表达式中，每当遇到操作符时，前面已经遇到并处理了该操作符所需的操作数。这使得后缀表达式的计算非常直观和有效。
三、中缀表达式 中缀表达式是我们通常使用的数学表达式表示方法，其中操作符位于操作数的中间，例如 “a * (b + c)”。
四、中缀表达式转化为后 缀表达式 将中缀表达式转换为后缀表达式通常需要使用算法，例如栈数据结构。以下是一个简单的示例转化的算法：
创建两个栈，一个用于操作符（操作符栈），另一个用于输出后缀表达式（输出栈）。
从左到右遍历中缀表达式的每个元素。
如果是操作数，将其添加到输出栈。
如果是操作符：
如果操作符栈为空，直接将该操作符推入操作符栈。
否则，比较该操作符与操作符栈栈顶的操作符的优先级。如果当前操作符的优先级较高，将其推入操作符栈。
如果当前操作符的优先级较低或相等，从操作符栈中弹出并添加到输出栈，然后重复比较直到可以推入操作符栈。
如果遇到左括号"(“，直接推入操作符栈。
如果遇到右括号”)“，将操作符栈中的操作符弹出并添加到输出栈，直到遇到匹配的左括号”("。
最后，将操作符栈中的剩余操作符全部弹出并添加到输出栈。
完成遍历后，输出栈中的内容就是中缀表达式转化为后缀表达式的结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70f7c3c0d76e5b4cce307fc35f182c38/" rel="bookmark">
			1. qgis二次开发环境搭建(qgis-3.28.6&#43;qt5.15)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐 推荐开源代码QGis C++ API二次开发示例大全
前言 本文介绍了QGIS二次开发环境的搭建，完成了以下工作
ubuntu22.04下，QGIS3.28.8编译ubuntu22.04下，使用QCreator调试QGIS3.28.8ubuntu22.04下，新建工程，引入编译好的QGIS库，并成功调用Qgis::releaseName()Windows10下，安装QGIS以及Release开发库Windows10下，新建工程，引入QGIS库，并成功调用Qgis::releaseName()
QGIS3.28.8下载地址 ubuntu22.04 ubuntu系统编译参考官网这里要注意ubuntu的版本，之前在ubuntu20.04上尝试编译QGIS3.28.8失败，由于ubuntu20.04默认安装的是Qt5.12，而QGIS3.28是要求Qt&gt;=5.14的，下图是依赖的库，下一章有apt安装命令
QGIS3.28.8编译 以下按照官网编译文档进行操作：
3.2. Prepare apt
3.3. Install build dependencies
sudo apt-get install bison build-essential ca-certificates ccache cmake cmake-curses-gui dh-python doxygen expect flex flip gdal-bin git graphviz grass-dev libdraco-dev libexiv2-dev libexpat1-dev libfcgi-dev libgdal-dev libgeos-dev libgsl-dev libpdal-dev libpq-dev libproj-dev libprotobuf-dev libqca-qt5-2-dev libqca-qt5-2-plugins libqscintilla2-qt5-dev libqt5opengl5-dev libqt5serialport5-dev libqt5sql5-sqlite libqt5svg5-dev libqt5webkit5-dev libqt5xmlpatterns5-dev libqwt-qt5-dev libspatialindex-dev libspatialite-dev libsqlite3-dev libsqlite3-mod-spatialite libyaml-tiny-perl libzip-dev libzstd-dev lighttpd locales ninja-build ocl-icd-opencl-dev opencl-headers pandoc pdal pkg-config poppler-utils protobuf-compiler pyqt5-dev pyqt5-dev-tools pyqt5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70f7c3c0d76e5b4cce307fc35f182c38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a65be5fb2d8a806fba98d0a4f54fe1eb/" rel="bookmark">
			以太网UDP数据回环实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、TCP/IP协议簇 前面说到TCP/IP是一个协议簇，其中包含有IP协议、TCP协议、UDP协议、ARP协议、DNS协议、FTP协议等。设备之间要想完成通信，就必须通过这些网络通信协议。
物理层的主要作用就是传输比特流（将1、0转化为电流强弱来进行传输，到达目的地后在转化为1、0，即数模转换与模数转换）。
数据链路层接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。MAC数据包位于数据链路层，当MAC数据包经过数据链路层到达网络层时，前导码、帧起始界定符、目的 MAC 地址、源 MAC 地址、类型/长度以及校验字节均被去除，只有有效数据传入了网络层。
网路层通过路由选择算法，为报文（该层的数据单位，由上一层数据打包而来）通过通信子网选择最适当的路径。这一层定义的是IP地址，通过IP地址寻址，所以产生了IP协议。传入网络层的数据包并不完全是需要传输的有效数据，他的前面还包含着 20 字节的IP协议首部。网络层在接收到数据包后，取下数据包的IP首部，将剩余有效数据包发送到传输层。
而传输层提供了主机应用程序进程之间的端到端的服务，基本功能是：分割与重组数据、按端口号寻址、连接管理、差错控制和流量控制、纠错功能。若传输层使用UDP协议，那么传入传输层的数据包为UDP数据包。
应用层是计算机用户，以及各种应用程序和网络之间的接口。
以太网数据包就是对各层协议的逐层封装来实现数据传输，MAC帧中的数据段为IP数据报文，IP报文中的数据段位UDP报文，UDP报文中的数据段为传输数据。
1.1 IP IP协议规定了数据传输时的基本单元和格式，位于以太网MAC格式的数据段，由IP首部和数据字段组成。
版本(4bit)：定义IP协议版本，设置为二进制的0100时表示IPv4，设置为二进制的0110时表示IPv6。首部长度 (4bit)：定义数据报协议头长度，表示IP首部一共有多少个32位。协议头最小值为5，最大值为15。服务类型 (8bit)：定义上层协议对处理当前数据报所期望的服务质量，并对数据报按照重要性级别进行分配。前3位成为优先位，后面4位成为服务类型，最后1位没有定义。这些8位字段用于分配优先级、延迟、吞吐量以及可靠性。总长度(16bit)：定义整个IP数据报的字节长度，包括协议头部和数据。其最大值为65535字节。标识 (16bit)：包含一个整数，用于标识主机发送的数据报，通常每发送一份数据包值加一。标记(3bit)：由3位字段构成，其中最低位 (ME控制分段，存在下一个分段置为1，否则置0代表该分段是最后一个分段。中间位(DF) 指出数据报是否可进行分段，如果为1则机器不能将该数据报进行分段。第三位即最高位保留不使用，值为0。分段偏移 (13bit)：在接收方进行数据报重组时用来标识分段的顺序。生存时间 (8bit)：一种计数器，在丢弃数据报的每个点值依次减1直至减少为0。这样确保数据报拥有有限的环路过程(即TTL)，限制了数据报的寿命。协议 (8bit)：该字段指出在IP处理过程完成之后，有哪种上层协议接收导入数据报。首部校验和(16bit)：该字段帮助确保IP协议头的完整性。由于某些协议头字段的改变，这就需要对每个点重新计算和检验。计算过程是先将校验和字段置为0，然后将整个头部每 16 位划分为一部分，将个部分相加，再将计算结果取反码，插入到校验和字段中。源地址 (32bit)：发送端IP地址，该字段在IPV4数据报从源主机到目的主机传输期间必须保持不变。目的地址 (32bit)：接收端IP地址，该字段在IPv4数据报从源主机到目的主机传输期间同样必须保持不变。 1.1.1 IP首部校验和 IP首部校验和计算步骤：
将16位检验和字段置为0，然后将IP首部按照16位分成多个单元；对各个单元采用反码加法运算(即高位溢出位会加到低位，通常的补码运算是直接丢掉溢出的高位)；此时仍然可能出现进位的情况，将得到的和再次分成高16位和低16位进行累加;最后将得到的和的反码填入校验和字段。 IP首部校验和校验
对IP首部中每个16bit进行二进制反码求和，将计算结果再取反码，若结果为0，通过检验，否则不通过检验。
例：验证IP首部 45 00 00 30 80 4c 40 00 80 06 b5 2e d3 43 11 7b cb 51 15 3d
(1)对 IP 首部进行反码求和：4500+0030+804c+4000+8006+b52e+d343+117b+cb51+153d=3fffc
0300+3fffc=ffff
(2)对和结果取反码：~ffff=0，校验正确。
1.2 UDP UDP (User Datagram Protocol)，即用户数据报协议，是一种面向无连接的传输层协议。无连接是指在传输数据时，数据的发送端和接收端不建立逻辑连接。即发送端只管发送，不会管接收端到底有没有接收到数据，而接收端也不会向发送端反馈反馈是否收到数据。
UDP首部共8个字节，同IP首部一样，也是一行以32位(4个字节)为单位。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a65be5fb2d8a806fba98d0a4f54fe1eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1531b777baa78d26f198d92c01608b69/" rel="bookmark">
			在Windows平台编译OpenJdk8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习了一段时间OpenJdk源码后，需要实践来验证自己对jvm各个组件运作机制的理解是否正确，这需要通过调试jvm来实现，而在windows平台编译openjdk是比较繁琐的，这其中遇到了一些坑，记录下build的过程以备不时之需。
前期准备 Cygwin64 安装cygwin后需要安装以下工具(编译jdk时make或jdk boott会调用)
ar 、make、m4、cpio、gawk、file、zip、unzip、free
打开cygwin安装程序 setup-x86_64.exe ，选择以上工具并安装。
Windows编译工具集
可以通过安装vs2010或win SDK实现，我选择的是安装vs2010，编译工具集版本为v100
freetype
它是一个用于渲染文本和字体的开源库，主要功能是将字体文件解析为矢量图形，以便在计算机屏幕上或其他设备上渲染文本。
jdk的部分组件库会使用到它，如 awt、swing、java2d、图形引擎等。
它需要单独编译，这里不要选择太新的版本，因为jdk8比较老了，可能会存在api兼容的问题，我这里选择的是freetype 3.13.2。
这里直接编译如果提示报错 snprintf 符号不存在，这是因为vs2010较老的编译工具集不支持 snprintf 函数，打开 include/freetype/config/ftstdlib.h 文件，找到 #define ft_snprintf snprintf，将其修改为 #define ft_snprintf sprintf_s
使用vs2010打开它的项目，分别编译生成动态库和静态库。
动态库
静态库
这里主要要选择下链接的vc运行库版本
动态库 -选择 多线程调试DLL(/MDd)
静态库-选择 多线程调试（/MTd）
编译完成后将生成的freetype.lib和freetype.dll放到 freetype根目录的lib文件夹中(没有则新建lib)。
配置编译环境
这里建议使用vc环境初始化脚本来初始化(它会配置好各种cl使用的环境变量)。
1.打开 X64工具命令行，cd /d 到 cygwin 的bin目录下并执行 .\bash --login -i 切换到cygwin环境中，然后cd 到 jdk根目录下。
运行configure 配置脚本，它会检查编译选项并生成makefile等编译用到的相关文件。
bash ./configure --with-tools-dir=/cygdrive/e/vs2010/VC/bin/x86_amd64/ --with-target-bits=64 --with-boot-jdk=/cygdrive/e/jdk/jdk7 --with-num-cores=8 --with-freetype=/cygdrive/e/build_jdk8/freetype_2_13_2 --with-debug-level=slowdebug --with-native-debug-symbols=internal
--with-tools-dir windows平台下的编译工具集
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1531b777baa78d26f198d92c01608b69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e6f36384060a0775722a02860a51928/" rel="bookmark">
			人声分离软件：iZotope RX 10 (Win&amp;Mac) 中文汉化版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iZotope RX 10是一款在音频修复和增强领域中非常出色的软件。它提供了一套全面的音频问题解决方案，为后期制作专业人员、音频工程师和视频编辑者解决各种棘手问题。 iZotope RX 10的主要特点包括：
声音修复功能：可以去除不良噪音、杂音、吱吱声等，使音频变得更加清晰干净。
音频增强功能：支持对音频进行音量调节、均衡器、压缩器、限制器等处理，使音频效果更加出色。
批处理功能：可以批量处理多个音频文件，提高工作效率。
时频编辑功能：具备强大的时频编辑功能，用户可以直观地编辑和处理音频信号。
跨平台兼容：支持多种操作系统，包括Windows和Mac OS X。
用户界面友好：界面简单易用，用户可以快速上手并进行音频处理。
高准确性：采用先进的算法和技术，能够精确地识别和修复不同类型的音频问题。
总之，iZotope RX 10是一款功能全面、操作简单的音频修复和增强软件，适用于后期制作专业人员、音频工程师和视频编辑者等需要解决音频问题的用户。
win版：https://soft.macxf.com/soft/3236.html?id=MzE5MTM%3D
mac版：http://mtw.so/5F6ihc
本文由 mdnice 多平台发布
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebe2e1aeb86a1611de6f6ad64d7553c2/" rel="bookmark">
			Android Studio-App门户页面设计与开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设计目标 设计一个app的门户框架，能够实现4个tab页面的切换效果。能够在任一tab页面中实现列表效果。 二、功能说明 设计一个类微信界面，主要分为上中下三个部分，通过下方按钮实现“聊天”、“联系人”、“发现”以及“设置”这四个页面的切换，并在“聊天”页面中实现列表功能。
三、效果展示 四、技术说明 Activity： Activity 是 Android 应用程序中的一个基本组件，它提供了一个用户界面。每个 Activity 都有一个布局文件，用于定义其用户界面。Activity 可以通过 Intent 启动其他 Activity，也可以接收其他 Activity 发送的 Intent。 XML： XML 是一种标记语言，用于描述数据。在 Android 应用程序中，XML 通常用于定义用户界面，用来编写布局文件。 Fragment： Fragment 是 Android 应用程序中的另一个基本组件，它可以嵌入到 Activity 中。Fragment 可以有自己的布局文件和生命周期，可以在运行时添加、删除或替换。 RecyclerView： RecyclerView 是 Android 应用程序中的一个高级控件，用于显示大量数据列表。与 ListView 不同，RecyclerView 允许自定义列表项的布局和交互方式，并提供了更好的性能和灵活性。 五、设计流程 主页面布局activity_main1.xml 主页面布局分为上中下三个部分，顶部由top.xml文件实现，因为需要切换四个页面，所以中间的内容分别包含在fragment1.xml、fragment2.xml、fragment3.xml和fragment4.xml中，底部由buttom.xml文件实现。使用include插入top.xml、中间的fragment.xml以及buttom.xml文件。
具体代码：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;include layout="@layout/top" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;androidx.fragment.app.FragmentContainerView android:id="@+id/content" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_weight="1" /&gt; &lt;include layout="@layout/buttom" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;/LinearLayout&gt; top.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebe2e1aeb86a1611de6f6ad64d7553c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3847d1425a91e5a47242882ad71635f/" rel="bookmark">
			setup.py error: can‘t create or remove files in install directory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python setup.py install -&gt; pip install .
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/789d5333961ad02030fd9f3702ef384b/" rel="bookmark">
			C语言使用函数统计指定的数字个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; int countdigit(int n,int m) { int remainder, discuss, count; count=0; discuss=n; while (discuss!=0) { remainder = discuss % 10; discuss = discuss/ 10; if (remainder == m) { count++; } } return count; } int main(){ int n,m,result,count; printf("输入两个数字n和m:\n"); scanf("%d%d",&amp;n,&amp;m); result= countdigit(n,m); printf("统计结果为%d",result); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d050ca220f98b994fae50dc6edf1f10/" rel="bookmark">
			Anaconda入门（安装及基础命令使用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Conda基础 1.1 conda基础命令（环境创建及激活） 1_查看所有环境 conda info -e 2_创建一个新的虚拟环境 conda create --name my_env_name python=3.8 这样，你就得到了一个名叫my_env_name包含python3.8的conda环境，其中“my_env_name”即为设置的环境名称。
3_激活环境 如果你想要使用你所创建的 python 虚拟环境，首先你就要激活你想用的虚拟环境
激活虚拟环境的命令是：
conda activate my_env_name 4_查看Conda列表 conda list 或者可以通过conda env list命令来查看我们的python虚拟环境，
5_在虚拟环境中安装包 在新建虚拟环境后，一个包都没有。那怎么去安装包呢？
conda install 模块名 比如： conda install scipy
其他说明：
激活了虚拟环境
如果我们激活了虚拟环境，我们使用 pip install some-package 或 conda install some-package
，就可以安装包了。 假如我们想安装 pandas 包，直接输入：conda install pandas 安装完成之后，我们就可以看到
pandas 包以及其他的依赖包了。
未激活虚拟环境
如果未激活虚拟环境，我们就要使用： python conda install -n my_env_name [package]
如果想安装 numpy 库，输入：conda install -n my_env_name numpy
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d050ca220f98b994fae50dc6edf1f10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/206b6c1082713200f68dda2f8fbe126a/" rel="bookmark">
			Linux系统编程笔记   gdb与makefile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gdb调试
makefile: 管理项目
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/75/">«</a>
	<span class="pagination__item pagination__item--current">76/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/77/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>