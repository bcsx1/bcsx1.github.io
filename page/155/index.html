<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2359f4a90088bcaa3f7f004274817e49/" rel="bookmark">
			datasheet中的电路知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 1关于电容 1关于电容 电容没有电、相当于是短路。可以看做是一根导线。电容满电、相当于是断路。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2205a0d8c0871bf1713501e653ec7ba/" rel="bookmark">
			Verilog语法总结--持续更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、整数 integer2、函数：关键字 function-----endfunction3、任务：关键字 task-----endtask4、编译指令--形式：`keyword(1)`timescale(2)`define(3) `include(4) `ifdef--条件编译 5、系统任务--形式：$keyword（1）$display（2）$stop（3）$finish 1、整数 integer 整数（正数 0 负数）是一种通用的寄存器数据类型，用于对数量进行操作，整数的默认位宽为宿主机的字的位数，与具体实现有关，最小为32位。reg和integer：reg的寄存器类型变量为无符号数
integer的寄存器类型变量为有符号数举例： integer counter； //作为计数器定义 initial counter = -1； //将-1存储到计数器中 //说明：counter[8] 和 counter[16:2]是非法的 2、函数：关键字 function-----endfunction 使用函数的前提条件：
子程序内不含有延迟、时序或者控制结构子程序只有一个返回值至少有一个输入变量没有输出或者双向变量不含有非阻塞赋值语句 说明：
举例:
module fun ( input integer i_in, output [8:0] o_out ); //定义一个计算二进制位宽的函数---可以用来计算模块中地址总线的宽度 function [8:0] clogb2; input bit_depth ; integer bit_depth ; begin for(clogb2 = 0; bit_depth &gt; 0; clogb2 = clogb2 + 1) bit_depth = bit_depth &gt;&gt; 1; end endfunction assign o_out = clogb2(i_in); //函数的调用:指明函数名clogb2（）和输入变量 i_in endmodule 3、任务：关键字 task-----endtask 4、编译指令–形式：`keyword (1)`timescale 用法： `timescale &lt;reference_time_unit&gt;/&lt;time_precision&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2205a0d8c0871bf1713501e653ec7ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/627c43eec278c0161a7312040607830a/" rel="bookmark">
			Verilog-实现脉冲边缘检测电路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、摘要二、电路结构三、代码实现 一、摘要 本篇博客主要记录使用Verilog实现对脉冲的上升沿和下降沿检测；
下面的链接是博主所写的“基于basys2的按键消抖”，其中状态机实现按键消抖使用了本篇博客所介绍的边缘检测电路。
https://www.cnblogs.com/zqh1126/p/14406822.html
二、电路结构 主要电路结构：两个寄存器（D触发器），两个反相器，两个与门
电路图如下：
三、代码实现 Verilog实现 `timescale 1ns / 1ps module edge_detection( input clk , input rst_n , input data_in , output nedge , output pedge ); reg tmp0; reg tmp1; //边沿检测，使用D触发器存储两个相邻时钟上升沿时外部输入信号（已经同步到系统时钟域中）的电平状态 always@(posedge clk or negedge rst_n ) begin if(!rst_n) begin tmp0 &lt;= 1'b0; tmp1 &lt;= 1'b0; end else begin tmp0 &lt;= data_in; tmp1 &lt;= tmp0; end end assign nedge = !tmp0 &amp; tmp1 ; //检测到时钟下降沿时产生一个时钟周期的高脉冲 assign pedge = tmp0 &amp; (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/627c43eec278c0161a7312040607830a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47e07ea1711c0833152c08b046b7a602/" rel="bookmark">
			sort排序是不稳定的，不能保证如果长度相同，按照输入的顺序不变。 改用`stable_sort`
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sort排序是不稳定的，不能保证如果长度相同，按照输入的顺序不变。 改用`stable_sort`
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f4c85f3dd1d31814d3bfe61ad95bae6/" rel="bookmark">
			【Obsidian】基础使用手册（包括如何将Obsidian页面设置为中文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💗 未来的游戏开发程序媛，现在的努力学习菜鸡
💦本专栏是我关于工具类软件的笔记
🈶本篇是Obsidian的基础使用
Obsidian的基础使用 将页面设置为中文常用的默认快捷键常用的格式标题代码块表格字体样式列表任务列表 官方下载地址：https://obsidian.md/
官方中文帮助手册：https://publish.obsidian.md/help-zh
将页面设置为中文 常用的默认快捷键 功能快捷键保存当前文件Ctrl + S新建笔记Ctrl + N打开设置Ctr + ,打开命令面板Ctrl + P打开快速切换Ctrl + O在所有文件中搜索Ctrl +Shif + F在当前笔记中查找Ctrl + F后退alt + ←前进alt +→切换编辑/预览模式Ctrl + E插入链接Ctrl + K打开所选链接Alt + Enter缩进Ctrl + ]取消缩进Ctrl + [ 常用的格式 标题 代码块 Obsidian 会将六个反引号括起来的内容识别为代码块，并将其按代码格式显示。代码块支持语法高亮功能，你可以在代码块的第一行（即开头处的反引号后）声明语言来使用特定的语法高亮。
表格 | 标题1 | 标题2 | | -------------- | -------------- | | 单元格11的内容 | 单元格12的内容 | | 单元格21的内容 | 单元格22的内容 | 字体样式 1. 使用两对等号来对文本进行==高亮==。 2. 使用一对星号来对文本进行 *倾斜*。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f4c85f3dd1d31814d3bfe61ad95bae6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0253b3c719ce29aef20a0892497ee2e0/" rel="bookmark">
			JavaSE语法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 JavaSE语法总结1. 前言2.认识JavaJava之父安装JDK 3.数据类型基本数据类型引用数据类型 4.运算符5.程序的逻辑控制判断条件面试题 6.方法的使用如何定义一个方法可变长参数什么是重载什么是重写面试题 7.数组的使用数组的概念如何定义一个数组如何遍历一个数组数组可以当作为返回类型二维数组 8.类和对象什么是类什么是对象构造方法this关键字封装包的概念访问修饰限定符 static关键字代码块内部类继承继承关键字super关键字再谈代码块final关键字的使用 多态多态的实现条件向上转型向下转型 9.抽象类和接口抽象类接口 10.String类的使用11.异常的使用总结致谢 JavaSE语法总结 1. 前言 我们在学完一个东西之后，一定要做总结，因为只有学会总结，你才会发现自己原来已经学了这么多东西，那这些东西你是否都掌握了呢？那就要看你有么有学会总结了。把每一章最重要的点给写下来，方便自己复习，也方便别人来参考，一举多得的事情，所以希望大家都能学会总结。把自己会的东西都给写下来。
2.认识Java Java之父 在前面学习Java的时候，我们认识到詹姆斯·高斯林老爷子，也就是Java之父，真的是非常厉害阿！学习Java的小伙伴来一起认识认识这位老爷子吧！
安装JDK 大家还记得就是在一开始，要写Java代码的时候，是不是要安装一个叫做JDK的东西，这玩意就是我们运行Java的工具，如果不装他，你是运行不了Java代码的。有多少人还记得JDK，JVM，JRE这些东西阿！比如我现在问你这三者有什么关系，你们能一下子回答上来吗？
他们三者的关系：
JDK：Java开发包工具JRE：Java运行环境JVM：Java虚拟机你只要安装了JDK，JDK里面就会有JRE和JVM这两个东西，具体看下面这个图
3.数据类型 还记得我们Java里面有哪些数据类型吗？学到现在不会还有小伙伴们不知道吧！
Java里面分两种类型：一个是基本数据类型，一个是引用数据类型。
基本数据类型 数据类型包装类占字节数byteByte1shortShort2intInteger4longLong8floatFloat4doubleDouble8charCharacter2booleanBooleanJava里面没说 引用数据类型 数据类型数组String枚举自定义类 4.运算符 运算符我们学过很多个阿！在C语言里面已经见得不少了，但是在Java里面，我们又学到了几个新的运算符和一些新的规则：
运算符功能右移运算符(&gt;&gt;)一个数的二进制往右移动n位，移动完成之后，会在左边补0或者是补1，这是要看符号位，如果是正数，则补0，如果是复数，则补1。左移运算符(&lt;&lt;)一个数的二进制往左移动n位，移动完成之后，会在右边补0。(无符号右移)&gt;&gt;&gt;一个数的二进制往右移动n位，移动完成之后，会在左边补0。这个符号，无论你是正数还是负数，通通只会补0。&amp;&amp; ||Java里面没有1是真，0是假的这种概念了，所以你不能在这两个符号左右两边写个0或1，这两个符号，左右两边必须是布尔表达式。 5.程序的逻辑控制 判断条件 在Java里面，只要是涉及到判断条件，括号里面一定是一个布尔表达式，不能跟C语言一样，在括号里面写个1或者写个0，这样代码是编译不通过的。
//这样的代码编译一定会报错，是无法通过的error public static void main(String[]){ /*if(1){ System.out.println(true); }else{ System.out.println(false); }error*/ //正确写法 if(1 == 1){ System.out.println(true); }else{ System.out.println(false); } } 面试题 在Java里面也有if，switch，for，while，do while这些语句，其中最特殊的就是switch语句了，这里面会有一道面试题，他会问你switch的括号里面哪些数据类型能放，哪些不能放。
switch里面可以放的数据类型有：char，byte，short，int，String，enum(枚举)switch里面不可以放的数据类型有：long，float，double，boolean 6.方法的使用 如何定义一个方法 权限访问修饰符 (静态关键字) 返回值类型 方法名(){ 语句; } public static void fun1(){ } 可变长参数 在Java里面引入了一个新的概念叫做可变长参数，比如说我要做很多数的加法，我总不能一个个的去定义变量对吧！这个时候就可以用到可变长参数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0253b3c719ce29aef20a0892497ee2e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/481e4a2c1bd1a695c295941813022140/" rel="bookmark">
			RabbitMQ消息队列实战（4）—— spring-boot-starter-amqp中消息的可靠性传输和确认机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一篇文章中，笔者整理了从消息生产出来到消费结束的整个生命周期过程中，为了确保消息能够可靠到达或者消费，我们需要在哪些环节进行哪些处理，同时也展示了使用Java原生代码怎么样在这些环节进行处理。本文主要介绍使用spring boot集成RabbitMQ的方式时，针对这些环节应该进行怎样的处理。
一、创建Exchange、Queue和Binding 首先，需要创建待测试的交换机、队列和绑定。相对于原生代码，spring boot对ConnectionFactory、Channel这些对象的创建和销毁进行了封装，使得我们不再需要手动创建Connection或者Channel，也不需要手动进行释放。这样做的一个好处就是：我们不必再关心这些系统资源的生命周期，从而简化了开发，而且避免了因忘记释放资源造成的内存泄露。RabbitMQ的Exchange、Queue和Binding这些组件的创建，只需要创建相应的Bean即可，注入到IOC中。
比如，笔者通过一个RabbitConfig的自动配置类，对这些Bean进行了注入：
@Configuration public class RabbitConfig { @Value("${spring.rabbitmq.host}") private String host; @Value("${spring.rabbitmq.port}") private int port; @Value("${spring.rabbitmq.username}") private String username; @Value("${spring.rabbitmq.password}") private String password; @Bean public ConnectionFactory connectionFactory() { CachingConnectionFactory connectionFactory = new CachingConnectionFactory(host, port); connectionFactory.setUsername(username); connectionFactory.setPassword(password); connectionFactory.setVirtualHost("/"); connectionFactory.setPublisherConfirms(true); return connectionFactory; } @Bean public RabbitTemplate rabbitTemplate() { RabbitTemplate template = new RabbitTemplate(connectionFactory()); return template; } @Bean public Queue TestDirectQueue() { return new Queue("TestDirectQueue", true, false, false); } @Bean DirectExchange TestDirectExchange() { return new DirectExchange("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/481e4a2c1bd1a695c295941813022140/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/433274f61422a6ac9963404e6cf83238/" rel="bookmark">
			ZZULIOJ 1027: 判断水仙花数 (C/C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1027: 判断水仙花数 题目描述
春天是鲜花的季节，水仙花就是其中最迷人的代表，数学上有个水仙花数，他是这样定义的：
“水仙花数”是指一个三位数，它的各位数字的立方和等于其本身，比如：153=13+53+33。
现在要求输入一个三位数，判断该数是否是水仙花数，如果是，输出“yes”，否则输出“no”
输入
输入一个三位的正整数。
输出
输出“yes”或“no”。
样例输入 Copy
153
样例输出 Copy
yes
代码
#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main() { int n; int a,b,c; scanf("%d",&amp;n); a=n%10; b=n/10%10; c=n/100; if(n==a*a*a+b*b*b+c*c*c) printf("yes"); else printf("no"); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a44d493ac76143128c9635ae4060602/" rel="bookmark">
			HASHMAP死锁分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大厂面试爱问的HashMap死锁问题，看这一篇就够了 JDK 1.7 HashMap源码分析 put（）方法addEntry（）方法resize（）方法transfer（）方法（重点） 死锁演示如何规避 使用Hashtable 或 ConcurrentHashMapJDK1.8的升级和仍存在的死锁问题 升级内容仍可能存在死锁问题 经历过大厂面试或者有所了解的同学都应该知道，HashMap是面试时面试官特别喜欢的问题，除了HashMap的扩容方式，为什么扩容的2的次幂等以外，还经常会问到HashMap死锁的相关问题。最常出现的死锁问题的是在JDK 1.7版本，为了理解死锁问题产生的原因我们来从源码和一些相关概念开始说起。 JDK 1.7 HashMap源码分析 put（）方法 public V put(K key, V value) { if (table == EMPTY_TABLE) { inflateTable(threshold); } if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a44d493ac76143128c9635ae4060602/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/864151c6d992f38f45c138ab0f6e5a12/" rel="bookmark">
			文件系统 | 以F2FS为具体操作系统的数据写流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前面的学习中，我们已经知道了一个文件的打开和读写时的系统调用过程，但是它们都在VFS层及之前，今天我们尝试以F2FS为具体操作系统，观察它的写入过程并着重观察F2FS冷热分流在其中的作用。这篇文章会比较长。
数据写流程整体概览：
首先我们要明确的是，在调用了write接口后，write的内容并不会一下子啪的一下就到磁盘上，而是通过操作系统中熟悉的脏页回写机制冲刷到磁盘上（见附推分享），所以，在write中的调用过程是不会下发bio的。
write在vfs到具体文件系统是通过write_iter回调函数转接的，这个函数的主要作用是在数据写入之前进行预处理：
static ssize_t f2fs_file_write_iter(struct kiocb *iocb, struct iov_iter *from) { struct inode *inode = file_inode(iocb-&gt;ki_filp); const loff_t orig_pos = iocb-&gt;ki_pos; const size_t orig_count = iov_iter_count(from); loff_t target_size; bool dio; bool may_need_sync = true; int preallocated; ssize_t ret; ...... 对inode加锁 if (iocb-&gt;ki_flags &amp; IOCB_NOWAIT) { if (!inode_trylock(inode)) { ret = -EAGAIN; goto out; } } else { inode_lock(inode); } ret = f2fs_write_checks(iocb, from); // 做一些check if (ret &lt;= 0) goto out_unlock; /*！！dio 决定当前写是直接写到磁盘，还是写到缓存，dio=true将写直达 */ /* Determine whether we will do a direct write or a buffered write.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/864151c6d992f38f45c138ab0f6e5a12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bb61e1ad67a99bc7b279bb76d2a7438/" rel="bookmark">
			java 如何计算两个汉字的相似度？如何获得一个汉字的相似汉字？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算汉字相似度 情景 有时候我们希望计算两个汉字的相似度，比如文本的 OCR 等场景。用于识别纠正。
实现 引入 maven
&lt;dependency&gt; &lt;groupId&gt;com.github.houbb&lt;/groupId&gt; &lt;artifactId&gt;nlp-hanzi-similar&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; java 实现
double rate1 = HanziSimilarHelper.similar('末', '未'); 返回对应的相似度：
0.9629629629629629 返回一个汉字的相似列表 情景 找到相似的汉字，有很多有趣的场景。
实现 List&lt;String&gt; list = HanziSimilarHelper.similarList('爱'); Assert.assertEquals("[爰, 爯, 受, 爭, 妥, 憂, 李, 爳, 叐, 雙]", list.toString()); 开源地址 为了便于大家学习，上述代码已开源
https://github.com/houbb/nlp-hanzi-similar
在线体验 在线体验
拓展阅读 NLP 中文形近字相似度计算思路
中文形近字相似度算法实现，为汉字 NLP 尽一点绵薄之力
当代中国最贵的汉字是什么？
NLP 开源形近字算法补完计划（完结篇）
NLP 开源形近字算法之形近字列表（番外篇）
开源项目在线化 中文繁简体转换/敏感词/拼音/分词/汉字相似度/markdown 目录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c5127b9323be1caea0b418d1e7248cf/" rel="bookmark">
			uniapp 使用uni.uploadFile上传文件后端一直接收不到文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我按着这个文档来 但是后端怎么都接收不到图片。查了好久才解决。
原因是这个name要对应后台的字段名 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be069ec5cf5194eb463d50a2e396386d/" rel="bookmark">
			boost库简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到boost.org Boost 提供免费的经过同行评审的可移植 C++ 源库。
我们强调与 C++ 标准库配合良好的库。 Boost 库旨在广泛使用，并可用于广泛的应用程序。 Boost 许可证鼓励所有用户以最少的限制使用 Boost 库。
我们旨在建立“现有实践”并提供参考实现，以便 Boost 库适用于最终的标准化。 从库技术报告 (TR1) 中包含的十个 Boost 库开始，到 2011 年以来 C++ ISO 标准的每一次发布，C++ 标准委员会一直依赖 Boost 作为标准 C++ 库补充的宝贵来源 .
作为一个组织的boost Boost 组织和更广泛的 Boost 社区支持对 C++ 和为其开发的库的最佳使用的研究和教育，特别是但不限于 Boost 库中包含的那些。
该组织和社区支持邮件列表和聊天室，为一般的 Boost 库和 C++ 用户提供最佳实践和前沿技术（cutting edge techniques) 教育。
自 2006 年以来，每年五月在科罗拉多州的阿斯彭举行为期一周的与 Boost 相关的名为 C++ Now 的亲密年度会议。 该会议是一个专注于尖端 C++ 的教育机会。 自 2007 年以来，Boost 一直是一年一度的 Google 代码之夏的参与者，学生们通过参与 Boost 库开发来发展他们的技能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be069ec5cf5194eb463d50a2e396386d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2918912ea40d70b3afb78499505f9543/" rel="bookmark">
			git撤销某一次commit提交
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用git rebase命令 如果您想彻底删除 Git 中的某次提交的内容，可以使用 git rebase 命令并将该提交删除。
以下是删除 Git 提交内容的步骤：
找到要删除的提交的哈希值。可以使用 git log 命令查看提交历史记录，然后找到要删除的提交的哈希值。
在终端中使用 git rebase -i 命令并指定要删除的提交的哈希值。例如，要删除哈希值为 abc123 的提交，您可以运行以下命令：
1
git rebase -i abc123~1git rebase -i HEAD~1
在这里，abc123~1 表示要删除的提交的前一个提交。
然后 Git 会打开一个交互式编辑器，并显示一个类似于下面的文本： pick abc123 commit message pick def456 another commit message pick ghi789 yet another commit message 将要删除的提交所在的行的单词 pick 替换为单词 drop。例如，如果要删除 abc123，则应将第一行更改为： drop abc123 commit message 保存更改并关闭编辑器。
然后 Git 会自动重播您的提交，并在重播时跳过要删除的提交。如果需要，您可能需要解决任何冲突，并提交最终更改。
注意，使用 git rebase 命令来删除提交可以永久删除提交并更改 Git 历史记录。如果您不确定如何使用 git rebase 命令，建议在使用前备份您的 Git 存储库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2918912ea40d70b3afb78499505f9543/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45d9ad1b4446bc66d2a5b5e00745bda2/" rel="bookmark">
			linux更改文件的读写执行等权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看权限
ls -al
语法如下：
chmod [who] [+ | - | =] [mode] 文件名
命令中各选项的含义为
u 表示“用户（user）”，即文件或目录的所有者。
g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。
o 表示“其他（others）用户”。
a 表示“所有（all）用户”。它是系统默认值。
操作符号可以是：
+ 添加某个权限。
- 取消某个权限。
= 赋予给定权限并取消其他所有权限（如果有的话）。
设置mode所表示的权限可用下述字母的任意组合：
r 可读。
w 可写。
x 可执行。
X 只有目标文件对某些用户是可执行的或该目标文件是目录时才追加x 属性。
s 在文件执行时把进程的属主或组ID置为该文件的文件属主。方式“u＋s”设置文件的用户ID位，“g＋s”设置组ID位。
t 保存程序的文本到交换设备上。
u 与文件属主拥有一样的权限。
g 与和文件属主同组的用户拥有一样的权限。
o 与其他用户拥有一样的权限。
实例
修改文件可读写属性的方法
例如：把index.html 文件修改为可写可读可执行:
chmod 777 index.html
要修改目录下所有文件属性可写可读可执行:
chmod 777 *.*
把文件夹名称与后缀名用*来代替就可以了。
比如：修改所有htm文件的属性:
chmod 777 *.htm
修改文件夹属性的方法
把目录 /images/xiao 修改为可写可读可执行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45d9ad1b4446bc66d2a5b5e00745bda2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6d99f2046540462003c01c4c318e5de/" rel="bookmark">
			微信支付需要验证微信身份部分openid，token
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;?php namespace app\api\controller; use alisms\SendSms; use app\index\controller\Api; use think\Controller; use think\Db; use think\Request; //use wxappletpay\Pay; use think\Exception; use GuzzleHttp\Exception\RequestException; use WechatPay\GuzzleMiddleware\WechatPayMiddleware; use WeChatPay\Util\PemUtil; //use GuzzleHttp\HandlerStack; use GuzzleHttp\HandlerStack; //use WechatPay\GuzzleMiddleware\Util\AesUtil; class WxApplet extends Controller { public function __construct() { // $result=$this-&gt;verifyPermissions(); // if (!$result){ // die(json_encode(['code'=&gt;40010,'errmsg'=&gt;'权限不足'])); // } } private function verifyPermissions() { $token = Request::instance()-&gt;header('token'); return redis()-&gt;exists($token); } public function cardList(){ $cardList=db('cardinfo')-&gt;select(); return jsonSuccess($cardList); } //简单的调用 public function sendSms(Request $request) { //判断是否ajax提交 if($request-&gt;isPost()) { //获取mobile参数 $mobile = $request-&gt;param('phone'); if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6d99f2046540462003c01c4c318e5de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef6c3eb05a2a32a3a6b216f4254022ae/" rel="bookmark">
			【无标题】在el-diaolog中展示echarts时，第一次进入弹框，图表无法占满整个容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在el-diaolog中展示echarts时，第一次进入弹框，图表无法占满整个容器。 2、改变echarts的自适应方法的执行时机。 问题描述：在el-dialog中展示echarts图表时，明明在封装的图表组件的setup中执行了echarts的resize方法，也监听了window的resize事件。但是打开弹框时，图表没有占满整个容器，而改变浏览器视口时，图表开始自适应。
解决方案：就 脑子里突然灵光乍现，给setup中图表的resize事件包了一层定时器，然后问题就解决了。这也是vue2和vue3的不同之处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fc6601fb9bbb829cff49ef6a38783b5/" rel="bookmark">
			k8s部署Dashboard
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		k8s和Dashboard的版本对应关系可以到Dashbord的对应版本里看，比如这里：
https://github.com/kubernetes/dashboard/releases/tag/v2.7.0
以下步骤都是在master上执行的。
1. 部署步骤 1. 获取Dashbord的yaml文件
wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml 如果不能下载下来，则自己手动下载下来拷贝到机器上，这里不要直接apply该文件，需要修改下image的地址为阿里云的地址，不然很可能连不上，无法下载下来。同时，需要修改下服务 kubernetes-dashboard的类型，默认是ClusterIP，不利于通过浏览器来访问，所以这里改为NodePort。这里我们改的内容有：1. image的地址 kubernetesui 改为 registry.aliyuncs.com/google_containers 2. service添加 type: NodePort
修改后完整文件在这里：
# Copyright 2017 The Kubernetes Authors. # # Licensed under the Apache License, Version 2.0 (the "License"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fc6601fb9bbb829cff49ef6a38783b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3e961a92d4be3d4b9c7f03ce96cc932/" rel="bookmark">
			HashMap源码解析超详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HashMap源码详解 1、概述2、源码解析1.HashMap底层存储结构问题一: 为什么直接就用数组呢？问题二：什么是红黑树呢？问题三：为什么不一下子把整个链表变为红黑树呢？ 2.HashMap的重要成员变量3.构造方法解析4.Put方法解析取模运算 (n - 1) &amp; hash 5.Get方法解析6.resize 扩容方法解析7.remove 方法解析 3、Jdk7-扩容死锁分析4、最后总结 1、概述 HashMap是Map中最为常用的一种，在面试和工作中也经常会被问到相关的问题。由于HashMap数据结构较为复杂，回答相关问题的时候往往不尽人意，尤其是在JDK1.8之后，又引入了红黑树结构，其数据结构变的更加复杂，本文就JDK1.8源码为例，对HashMap进行分析；
只要耐心看完本篇HashMap源码解析，我相信你一定可以告诉别人精通HashMap源码。当然了，如果有什么问题也欢迎提出来，一起进步。下面直接上硬核
2、源码解析 1.HashMap底层存储结构 在JDK1.7的时候只有数组加链表的，但是在JDK1.8之后使用了数组加链表加红黑树。也是为了提升性能。看下面的图可能比较直观：
每一个节点就是一个Node，Node有四个属性；
Node(int hash, K key, V value, Node&lt;K,V&gt; next) { this.hash = hash; //hash值 this.key = key; this.value = value; this.next = next; //下一个指针 } 问题一: 为什么直接就用数组呢？ 数组我们都知道，在内存中是一块连续的空间，所以如果数组很大的情况下，会很耗费内存。HashMap是通过hash取值落到数组上的，那么就会有一个问题，没错HASH碰撞，如果两个元素的HASH值一样，那么他们落在同一个槽位上怎么办，所以就有了链表，如果链表足够长，就会变为红黑树，下面会详细剖析这些。 问题二：什么是红黑树呢？ 红黑树是一个自平衡的二叉查找树，也就是说红黑树的查找效率是非常的高，查找效率会从链表的o(n)降低为o(logn)。如果之前没有了解过红黑树的话，也没关系，你就记住红黑树的查找效率很高就OK了。
问题三：为什么不一下子把整个链表变为红黑树呢？ 这个问题的意思是这样的，就是说我们为什么非要等到链表的长度大于等于8的时候，才转变成红黑树？在这里可以从两方面来解释
（1）构造红黑树要比构造链表复杂，在链表的节点不多的时候，从整体的性能看来， 数组+链表+红黑树的结构可能不一定比数组+链表的结构性能高。就好比杀鸡焉用牛刀的意思。
（2）HashMap频繁的扩容，会造成底部红黑树不断的进行拆分和重组，这是非常耗时的。因此，也就是链表长度比较长的时候转变成红黑树才会显著提高效率。
OK，到这里相信我们对hashMap的底层数据结构有了一个认识。下面我们看一下一些重要的成员变量
2.HashMap的重要成员变量 1. DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; Hash表默认初始容量 16 位运算：0000 0001 左移四位后 0001 0000 变成了2的四次方=16 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3e961a92d4be3d4b9c7f03ce96cc932/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb89065a21d7694f5eee28c05bf5e9d9/" rel="bookmark">
			pip版本更新时，出现的问题及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、pip版本更新警告提示：
2、Terminal窗口输入： pip install --upgrade pip 后报错 （未安装pip）
3、输入：python -m ensurepip （安装pip）
4、输入：python -m pip install --upgrade pip （更新pip）
(更新后，当前为pip最新版本23.0.1 )
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c81296a0b383d90189b62dc3d6a6ef07/" rel="bookmark">
			C# WinAPI 遍历方式查找窗口，子窗口的控件句柄
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查找方法： FindWindow find = new FindWindow(winPtr, null, "子窗口或控件名称", 100);
bool isFlag = find.Start();
winPtr为窗体的句柄。可通过FindWindow查找
IntPtr winPtr = FindWindow(null, "窗体名称");
class FindWindow
{
[DllImport("user32")]
[return: MarshalAs(UnmanagedType.Bool)]
//IMPORTANT : LPARAM must be a pointer (InterPtr) in VS2005, otherwise an exception will be thrown
private static extern bool EnumChildWindows(IntPtr window, EnumWindowProc callback, IntPtr i);
//the callback function for the EnumChildWindows
private delegate bool EnumWindowProc(IntPtr hWnd, IntPtr parameter);
//if found return the handle , otherwise return IntPtr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c81296a0b383d90189b62dc3d6a6ef07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87c459d902956699da352eea39c51461/" rel="bookmark">
			int(1) 和 int(10)区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有个表的要加个user_id字段，user_id字段可能很大，
alter table xxx ADD user_id int(1)。
int(1)怕是不够用吧，接下来是一通解释。
我们知道在mysql中 int占4个字节，那么对于无符号的int，最大值是2^32-1 =
4294967295，将近40亿，难道用了int(1)，就不能达到这个最大值吗？
CREATE TABLE `user` ( `id` int(1) unsigned NOT NULL AUTO_INCREMENT, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4; id字段为无符号的int(1)，我来插入一个最大值看看。
mysql&gt; INSERT INTO `user` (`id`) VALUES (4294967295); Query OK, 1 row affected (0.00 sec) 可以看到成功了，说明int后面的数字，不影响int本身支持的大小，int(1)、int(2)…int(10)没什么区别。
零填充 一般int后面的数字，配合zerofill一起使用才有效。先看个例子：
CREATE TABLE `user` ( `id` int(4) unsigned zerofill NOT NULL AUTO_INCREMENT, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4; // An highlighted block var foo = 'bar'; 注意int(4)后面加了个zerofill，我们先来插入4条数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87c459d902956699da352eea39c51461/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2273112b079d6fac4ec86e05780fe716/" rel="bookmark">
			idea中git无法提交到远程仓库,还会出现别人修改的代码在本地显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一部 先备份补丁
在你提交的记录中 创建补丁备份
在git log窗口中选择 被人提交的版本 恢复
恢复后 正常还是有自己修改过的代码 没有的话就执行补丁
然后更新下代码 重新提交 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87a417fef72f683a911d50f8b713974c/" rel="bookmark">
			SQL Server实现group_concat函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、mysql数据库group_concat函数 情景：每个人有多张银行卡，现在需统计出每个人的银行卡并展示成一行，表单如下：
实现sql：
group_concat() 函数将组中的字符串连接成为具有各种选项的单个字符串。
select name,group_concat(bankCard separator ',') as bankCards from uf_yhk group by name separator 指定在组中的值之间插入的文字值，默认 ' , ' 二、SQL Server实现group_concat函数 实现sql： select name, STUFF( (select ',' + a.bankCard from (select id,name,bankCard from uf_yhk) a where a.name = b.name FOR XML PATH('') ) ,1,1,'') as bankCards from (select id,name,bankCard from uf_yhk) b group by name 原理分析： 2.1 FOR XML PATH('')函数,使结果集转为XML文档形式
select id,name,bankCard from uf_yhk FOR XML PATH(''); &lt;id&gt;1&lt;/id&gt;&lt;name&gt;张三&lt;/name&gt;&lt;bankCard&gt;500301&lt;/bankCard&gt; &lt;id&gt;2&lt;/id&gt;&lt;name&gt;李四&lt;/name&gt;&lt;bankCard&gt;500302&lt;/bankCard&gt; &lt;id&gt;3&lt;/id&gt;&lt;name&gt;张三&lt;/name&gt;&lt;bankCard&gt;500303&lt;/bankCard&gt; &lt;id&gt;4&lt;/id&gt;&lt;name&gt;李四&lt;/name&gt;&lt;bankCard&gt;500304&lt;/bankCard&gt; &lt;id&gt;5&lt;/id&gt;&lt;name&gt;王五&lt;/name&gt;&lt;bankCard&gt;500305&lt;/bankCard&gt; &lt;id&gt;6&lt;/id&gt;&lt;name&gt;张三&lt;/name&gt;&lt;bankCard&gt;500306&lt;/bankCard&gt; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87a417fef72f683a911d50f8b713974c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b85fd133f03cf152c0da9c355a9f34f8/" rel="bookmark">
			2023年第五届传智杯前四题题解（后俩没写出来）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比赛链接：第五届“传智杯”全国大学生计算机大赛（决赛B组） - 比赛详情 - 洛谷
时效「月岩笠的诅咒」 题目背景 蓬莱之药，被诅咒的不死之药。
奉命将蓬莱之药投入富士山中销毁的月岩笠，最终打算把蓬莱之药改投入八岳销毁。在下山途中妹红将其踹下山，抢到了蓬莱之药。
那已经是千年前的事情了。
题目描述 时间节点上发生过的两件事情的时间可被看作两实数 a,b。我们称两个事件满足「周年」关系，当且仅当可以通过执行以下两种操作（可以 00 次）使其相等：
将 a 加上 11，即 a←a+1；将 b 加上 11，即 b←b+1。 现在给定实数 a,b，询问它们是否满足「周年」。
输入输出样例 输入 #1 100.000000000000 999999.000000000000
输出 #1 YES
输入 #2 114.123456789000 514.123456789000
输出 #2 YES
输入 #3 0.333333333333 0.333333333334
输出 #3 NO
说明/提示 对于全部数据，保证 0&lt;a,b≤109。
解析：
第一道题目只是告诉了我们这个数字可以进行+1和-1，但是对于小数的部分他完全不操作，对于这道题目的任何两个数字，只要小数相同，那么整数部分一定可以通过操作相同，所以这道题目的本质就是对小数部分进行判重，相同输出YES，不同输出NO即可；
#include&lt;iostream&gt; using namespace std; int work(string arr) { for(int i=0;i&lt;arr.size();i++) { if(arr[i]=='.') return i+1; } } int main() { string a,b; cin&gt;&gt;a&gt;&gt;b; int sa=work(a);//找到小数点的后一位，也就是小数开始的位置； int sb=work(b); int flag=1; for(int i=sa,j=sb;i&lt;a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b85fd133f03cf152c0da9c355a9f34f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72bf731c070a6768d1ab02d07037453a/" rel="bookmark">
			IT大佬推荐！新手学习Python最应安装的9个软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 对于新入门Python的朋友，是否会有疑惑：有这么关于python的软件，应该要安装哪一些最合适？这篇文章会给你答案。
小编 汇总了最有用的9个软件，并列出了各自的优势，以及合适的应用场景。
一起来看看。
1. PyCharm 【----帮助Python学习，以下所有学习资料文末免费领！----】
首先推荐的是pycharm，可以搭配Anaconda3 jupyter。
如果您是学生，有教育邮箱，可以申请教育授权。你可以免费使用jetbrain全家桶，如果你有一个活跃的开源项目，你也可以免费申请。
2. Visual Studio Code VScode相比其它工具的优势在于，当代码量大的时候更易调试，特别适合传统类型的编程工作。
其功能强大，支持各种自定义插件，提供代码自动完成和语法高亮的功能。但对新手有一定门槛。
3. jupyter notebook 如果是需要用Python做数据分析，那jupyter是必须的工具。 jupyter甚至比pycharm还要容易上手，使用体验非常良好，在数据领域，基本没有jupyter不能胜任的场景。
4. IDLE 【----帮助Python学习，以下所有学习资料文末免费领！----】
IDLE是Python自带的IDE套件，最基础的Python标准化图形用户界面，提供了最基本的IDE编译功能，是新手熟悉Python语法的实用工具。
虽然基本没有语法功能，但却是自查python知识的很好实践工具。
5. Anaconda Anaconda其实不是通常意义的IDE，它是Python的一个解释器集成开发环境。
它本身包含jupyterNotebook和Spyder等常用的IDE工具。由于下载安装配置简单，所以成为大多数初学者（尤其是数据研究者）开发Python代码的首选工具软件。
6. Spyder Spyder是一个轻量级的IDE开发工具，可以通过安装Anaconda集成环境完成对Spyder的安装。
它轻便、高效，虽然没有Pycharm智能，但程序员所需要的80-90%的功能它都有，十分适合数据研究方向的小伙伴使用。
7. Vim Vim是从Vi发展出来的一个文本编辑器，它之所以会成为成熟Python工程师所必须掌握技能的原因，是在于它在Linux系统下优异的表现，以及强大的兼容能力。
8. Sublime Sublime是一款轻量级的通用型代码编辑工具，通过插件的配置，可以是Sublime编程一个强大的交互式Python开发工具，提供代码编辑、交互测试、系统调试等功能。
而且这个工具能在Windows、Linux、OSx等系统中通用。
9. Atom Atom是由Github推出的一款跨平台的文本编辑器，秉持了开源的属性，支持包括Python在内的基本所有市面上主流的编程语言。对Python的支持也很友好，通过安装各类插件，就能实现非常优异的操作表现。
以上9个软件/编辑器并不是所有的都需要下载安装，还是根据自己的实际情况和应用场景选择合适的安装。
读者福利：知道你可能对Python感兴趣，便准备了这套python学习资料
对于0基础小白入门：
如果你是零基础小白，想快速入门Python是可以考虑的。
一方面是学习时间相对较短，学习内容更全面更集中。
二方面是可以找到适合自己的学习方案
包括：Python激活码+安装包、Python web开发，Python爬虫，数据分析，人工智能、机器学习等学习教程。带你从零基础系统性的学好Python！
零基础Python学习资源介绍 👉Python学习路线汇总👈 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。（全套教程文末领取哈）
👉Python必备开发工具👈 温馨提示：篇幅有限，已打包文件夹，获取方式在：文末
👉Python学习视频600合集👈 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
👉Python基础👈 👉Python自动化办公教程👈 👉python爬虫 👈 👉python机器学习 👈 👉实战案例👈 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
👉100道Python练习题👈 检查学习结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72bf731c070a6768d1ab02d07037453a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4013f9aaeca95834136028b02f9b485/" rel="bookmark">
			Java中是如何保证多线程间的数据共享的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在讨论这个问题之前，我们可以先瞅瞅Java的内存模型JMM，JMM可不要和JVM混为一谈。我们说的是内存模型JMM（Java Memory Model）。
Java的内存模型 稍微解释一下CPU的缓存，这里CPU的缓存有三级，L1,L2和L3。
L1是访问速度最快的，是线程独享。L2次之，属于内核独享。L3是最慢的，是多核共享。 当CPU执行指令需要数据的时候，会先在L1，L2,L3中依次寻找，若是找不到，则会去JVM中寻找，而JMM则在CPU和主内存之间来保证我们需要的可见性和有序性。
这个JMM就是Java内存模型的核心，可见性有序性都是在这里实现。
而主内存就是JVM，就是我们的堆内存。
保证可见性的方式 可见性是指，当多个线程操作同一个数据的时候，保证一个线程的修改对其他线程是可见的，也就是说不管多个线程如何操作，如何并发，他们在同一时间取到的值是相同的。
为了保证可见性，我们一般有以下几种方案：
volatile 可以用volatile来修饰基本数据类型，可以保证每次CPU操作数据的时候，都直接操作的是主内存的值。
文末我们会说说volatile的原理
synchronized 对于synchronized来说，是谁拿到锁，谁执行操作，对于拿到锁的线程来说，前边线程的操作是可见的。
lock lock是基于CAS和volatile的修改操作，可以保证操作数据时前边操作的可见性。
final final修饰的是常量啊，没法写，只读，当然是全局可见的
这里有一个小点： 我们清楚，volatile修饰基本数据类型的时候是可以保证可见性的，但是若是修饰的是引用数据类型呢？
一般没人这么搞，甚至平时工作中volatile都很少使用，一不留神系统的性能会降低几个维度。但是面试中常被问到，我们可以这样回答：若volatile修饰的是引用数据类型，则只能保证引用数据类型的地址是可见的，里边的值不可见。就这。
volatile的底层实现 稍微看看volatile的底层实现吧，其实
volatile的底层是汇编的lock指令，这个指令会强行要求将值写入主内存，并且忽略Store Buffer这种缓存，从而达到可见性的目的，同时利用MESI协议，让其他缓存行失效。
我们晓得将java文件编译为class文件的时候，会基于JIT做优化，调整指令的顺序，从而提升执行效率，这个过程叫指令重排。
在CPU层面也会调整指令的顺序来提升性能。而这个指令重排会导致一些问题，我们看看volatile是如何解决这个问题的。
原理 被volatile修饰的属性，在编译时会在先后增加内存屏障。这里的提到的内存屏障一般有四种
SS: StoreStore屏障前的读写操作必须全部完成，才会继续屏障之后的操作SL: StoreLoad屏障前的写操作必须全部完成，才会继续屏障之后的读操作LL: LoadLoad屏障前的读操作必须全部完成，才能继续屏障之后的读操作LS: LoadStore屏障前的读操作必须全部完成，才能继续屏障之后的写操作 这里volatile的原理就如下
可以看到对于volatile的写操作
之前添加了StoreStore内存屏障，必须完成之前的读写操作才能继续volatile的写操作。
而后添加了StoreLoad屏障，要求其前边的volatile写操作完成，才能继续之后的读操作。
这样就保证了在对volatile修饰的值执行写操作的时候，之前的读写操作已经全部完成，而其后的读操作在等待写操作完成再去读值。
而对于volatile的读操作，
在其后添加了一个LoadLoad屏障和LoadStore屏障，这里这个LoadLoad屏障不是很理解，查阅了诸多资料也没有眉目，若是有小伙伴知晓的，烦请不吝赐教。
而LoadStore屏障则保证了volatile的读操作全部完成之后，再继续之后的写操作。
这样volatile的读操作完成之后，才会执行其他的写操作。保证了读到的值是确定的不变的。
这样Java的线程间共享值的处理方式就大致讲解完毕了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06e4ed5a4ebb044ec5fdf3a8c24b40b7/" rel="bookmark">
			「 分布式技术 」一致性哈希算法（Hash）详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		「 分布式技术 」一致性哈希算法（Hash）详解 参考&amp;鸣谢
一致性 Hash 算法原理总结 kylinkzhang，腾讯 CSIG 后台开发工程师
什么是一致性哈希？ xiaolinCoding
文章目录 「 分布式技术 」一致性哈希算法（Hash）详解@[toc]一、前言二、产生背景三、什么是一致性哈希算法四、一致性哈希算法原理1. hash 环2. 服务器映射到 hash 环3. 对象 key 映射到服务器 五、服务器扩缩容场景1. 服务器减少2. 服务器增加 六、数据偏斜&amp;服务器性能平衡问题1. 引出问题2. 虚拟节点3. 虚拟节点的计算 七、使用场景八、小结 一、前言 在分布式系统中，数据的存储和访问是很重要的问题。为了提高系统的可用性和扩展性，常常需要将数据分布到不同的节点上，而且这些节点也可能会动态地加入或离开集群。一致性哈希算法就是一种常用的解决方案，它可以解决节点的动态变化和负载均衡的问题。
本文将深入探讨一致性哈希算法的底层原理，包括其基本思想、关键步骤以及优缺点等，同时结合实际场景进行举例说明。
二、产生背景 考虑这么一种场景：
我们有三台缓存服务器编号node0、node1、node2，现在有 3000 万个key，希望可以将这些个 key 均匀的缓存到三台机器上，你会想到什么方案呢？
我们可能首先想到的方案是：取模算法hash（key）% N，即：对 key 进行 hash 运算后取模，N 是机器的数量；
这样，对 key 进行 hash 后的结果对 3 取模，得到的结果一定是 0、1 或者 2，正好对应服务器node0、node1、node2，存取数据直接找对应的服务器即可，简单粗暴，完全可以解决上述的问题；
取模算法虽然使用简单，但对机器数量取模，在集群扩容和收缩时却有一定的局限性：因为在生产环境中根据业务量的大小，调整服务器数量是常有的事；
而服务器数量 N 发生变化后hash（key）% N计算的结果也会随之变化！
比如：一个服务器节点挂了，计算公式从hash（key）% 3变成了hash（key）% 2，结果会发生变化，此时想要访问一个 key，这个 key 的缓存位置大概率会发生改变，那么之前缓存 key 的数据也会失去作用与意义；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06e4ed5a4ebb044ec5fdf3a8c24b40b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b185825af1fe75206ce5c33de8cf485e/" rel="bookmark">
			Python中变量的打印方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中变量打印有如下三种方法：
使用”+”或者“，”串联字符串和变量如 name = "Mike" age = 18 pirnt("My name is " + name + " and i'm " + str(age) + " years old") name = "Mike" age = 18 print("My name is",name,"and i'm",age,"old") 打印结果如下：
My name is Mike and i'm 18 years old 但是使用+来串联字符串和变量有许多的不便，比如数字要用str()方法转化为字符串，需要注意添加空格，一不小心可能会变成My name isMikeand i’m 18years old，显得非常麻烦并且易于出错；而用,分隔的方法，不用特意添加空格（,可理解为一个空格），还能拼接字符串和其它类型的数据，比+好了很多。
2. 占位符模式（%formatting）
print("My name is %s" %name) print("I'm %d years old" %age) 打印内容为：
My name is Mike I'm 18 years old 此处的%s和%d只是占用位置，再把相应的变量值安插进去。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b185825af1fe75206ce5c33de8cf485e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b70045da837c0898f25aeef0bc0685e7/" rel="bookmark">
			RocketMQ_详细配置与使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 MQ介绍 2 为什么要用MQ 消息队列是一种“先进先出”的数据结构
其应用场景主要包含以下3个方面
2.1 应用解耦 系统的耦合性越高，容错性就越低。以电商应用为例，用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障或者因为升级等原因暂时不可用，都会造成下单操作异常，影响用户使用体验。
使用消息队列解耦合，系统的耦合性就会提高了。比如物流系统发生故障，需要几分钟才能来修复，在这段时间内，物流系统要处理的数据被缓存到消息队列中，用户的下单操作正常完成。当物流系统回复后，补充处理存在消息队列中的订单消息即可，终端系统感知不到物流系统发生过几分钟故障。
2.2 流量削峰 应用系统如果遇到系统请求流量的瞬间猛增，有可能会将系统压垮。有了消息队列可以将大量请求缓存起来，分散到很长一段时间处理，这样可以大大提到系统的稳定性和用户体验。
一般情况，为了保证系统的稳定性，如果系统负载超过阈值，就会阻止用户请求，这会影响用户体验，而如果使用消息队列将请求缓存起来，等待系统处理完毕后通知用户下单完毕，这样总不能下单体验要好。
处于经济考量目的：
业务系统正常时段的QPS如果是1000，流量最高峰是10000，为了应对流量高峰配置高性能的服务器显然不划算，这时可以使用消息队列对峰值流量削峰
2.3 数据分发 通过消息队列可以让数据在多个系统更加之间进行流通。数据的产生方不需要关心谁来使用数据，只需要将数据发送到消息队列，数据使用方直接在消息队列中直接获取数据即可
3 MQ的优点和缺点 优点：解耦、削峰、数据分发
缺点包含以下几点：
系统可用性降低
系统引入的外部依赖越多，系统稳定性越差。一旦MQ宕机，就会对业务造成影响。
如何保证MQ的高可用？
系统复杂度提高
MQ的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过MQ进行异步调用。
如何保证消息没有被重复消费？怎么处理消息丢失情况？那么保证消息传递的顺序性？
一致性问题
A系统处理完业务，通过MQ给B、C、D三个系统发消息数据，如果B系统、C系统处理成功，D系统处理失败。
如何保证消息数据处理的一致性？
4 各种MQ产品的比较 常见的MQ产品包括Kafka、ActiveMQ、RabbitMQ、RocketMQ。
5 RocketMQ快速入门 RocketMQ 是阿里巴巴2016年MQ中间件，使用 Java 语言开发，在阿里内部，RocketMQ 承接了例如“双11”等高并发场景的消息流转，能够处理万亿级别的消息。
5.1 准备工作 下载RocketMQ
这里选择的 RocketMQ 的版本：4.6.0
下载地址：下载地址
官方文档：http://rocketmq.apache.org/docs/quick-start/
环境要求
Linux64位系统
JDK1.8(64位)
5.2 安装RocketMQ 安装步骤
我这里是以二进制包方式来安装的：
解压安装包
进入安装目录
目录介绍
bin：启动脚本，包括 shell 脚本和 CMD 脚本
conf：实例配置文件 ，包括 broker 配置文件、logback 配置文件等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b70045da837c0898f25aeef0bc0685e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1e31df3163254bb88374ccafc403594/" rel="bookmark">
			SecureCRT8.5安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SecureCRT8.5安装教程
链接：https://pan.baidu.com/s/1kCZ8Jf4UdOZkYbqSSH_P5w
提取码：t4tt
以下为安装教程-----------------------------------------------------------------------------------------
第一步：
将文件下载解压
第二步：
双击进行安装，或者右键以管理员的方式运行
第三步：
直接点下一步
第四步：
选择接受协议，然后点下一步
第五步：
我这里选择所有用户，然后点下一步（这个选项不太重要）
第六步：
我这里选择完全安装，然后点下一步（如果只需要某个功能，可以选择下面的自定义安装功能）
第七步：
我这里勾选了将图标添加到桌面（快捷方式）
第八步：
检查安装路径和安装了哪些功能
第九步：
安装完成
第十步：
激活软件，找到图中文件夹
第十一步：
将列表内的文件全部拷贝到程序安装目录
第十二步：
右键以管理员身份运行“keygen.exe”，点击patch按钮
第十三步：
在新窗口中选择安装目录下的SecureCRT.exe，点击打开
第十四步：
弹出来的第二个界面选择LicenseHelper.exe，点击打开
第十五步：
提示补丁已成功完成，点击确定
第十六步：
提示补丁以上操作完成后运行软件，第一次运行时需要设置一个存储配置数据的文件夹。设置配置数据文件夹后
第十七步：
点击Enter license Data选项
第十八步：
在注册机中点击generate生成licens信息
第十九步：
将license框中的信息复制到软件窗口中，点击下一步
第二十步：
显示license信息文件已被接受，点击完成激活操作。
第二十一步：
选择安全配置，我选择的第二个，自己的电脑不需要密码，这里就完成了激活
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a80a21d4f1adad8ff393793cba651364/" rel="bookmark">
			idea中SSM框架环境的搭建过程总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ssm框架的介绍
ssm框架是Spring MVC，Spring和Mybatis框架的整合，是标准的MVC（model，view，controller）模式。其将整个系统划分为表示层，控制层，业务层，持久层四个层次，使用Spring MVC负责请求的转发和视图管理 （Spring实现业务对象管理，Mybatis作为数据对象的持久化引擎）,ssm框架是目前比较主流的JavaEE企业级框架，适用于搭建各种大型的企业级应用系统。
ssm框架的各层次的介绍
持久层（Mybatis）：Dao层（mapper）
主要是做数据持久层的工作，负责与数据库进行联络的一些任务都封装在这里。Dao层作为接口层，在Spring的配置文件中定义接口实现类就可以在模块中调用此接口进行数据业务的处理，不需要关系具体的实现类，Dao层数据得到配置以及相关数据库的参数配置都在Spring中进行配置。
业务层（Spring）：Service
主要进行模块的逻辑应用设计。添加其接口和对应的实现类，在Spring配置文件中配置其先关得到关联，则可以在应用中调用Service接口进行业务处理，封装其业务逻辑可独立重复的使用，Service层调用Dao层接口。
控制层（SpringMVC）：Controller层（Hander层）
主要负责业务模块流程的控制。控制层的配置也需要在Spring文件中配置，针对具体的业务流程，会有不同的控制器，Controller层调用Service层的接口实现控制业务管理。
视图层：Viwe层
主要负责调用前台jsp页面的表示。此层与Controller层结合紧密。
ssm环境配置
1，开启idea，创建一个maven项目，将其变成一个web项目，在src包名下创建一个java，resources包（右键将其分别创建为Sources Root；Resources Root包如下：）
2，搭建Controller，service，Dao，Domain层：
3，在添加Spring相关的配置
文件中相关代码如下：
applicationContenxt.xml文件：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!--开启注解的扫描，希望处理service和dao，controller不需要Spring框架去处理--&gt; &lt;context:component-scan base-package="com.sm" &gt; &lt;!--配置哪些注解不扫描--&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt; &lt;/context:component-scan&gt; &lt;!--Spring整合MyBatis框架--&gt; &lt;!--配置连接池--&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt; &lt;!--jdbc的两种url--&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/数据库名?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;userSSL=false&amp;amp;serverTimezone=GMT%2B8"/&gt; &lt;!-- &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/数据库名?characterEncoding=UTF-8"/&gt;--&gt; &lt;property name="user" value="root"/&gt; &lt;property name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a80a21d4f1adad8ff393793cba651364/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e867e9e253a705f97467a62321e55de9/" rel="bookmark">
			Unity --- 物理引擎 --- 触发器 与 碰撞器详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		碰撞器补充讲解 对第一个条件进行补充 --- 不仅要两者都具有碰撞组件，同时还需要两者的碰撞组件中都没有勾选 Is Trigger属性
1.上一篇文章中说了那么多，其实也可以总结为两个碰撞条件 --- a.两个游戏物体都具有碰撞器组件 ，如果没有的话，连碰撞检测都不会发生，也就没有所谓的碰不碰撞一说了
b.运动的物体具有刚体组件 --- 在有刚体组件的前提下，物体只有处于运动状态时才具有
1.第一个阶段会在两个物体接触的第一帧执行 --- 只执行一次
2.第二个阶段会在两个物体保持接触时每帧执行 --- 每帧执行
3.第三个阶段则是在两个物体分离的那一帧执行 --- 只执行一次
4.collision(名词.碰撞) --- 上面那个Collision是一个类 --- 其实就是碰撞器类
1.碰撞阶段的三个方法都有一个参数 --- Collision other --- 这个参数的类型是碰撞器类 --- 当挂载该脚本的游戏物体a与其它具有碰撞器组件的游戏物体b发生碰撞时， 游戏物体b的碰撞器组件对象就会被传给三个方法中的引用参数 Collision other.
（注意！！！ 碰撞器组件对象是被传给了Collision类内部的一个引用 --- 该引用的类型是Collider，引用名就是 collider --- 如果说想访问碰撞器组件对象的话得通过 对应类型的参数名 + 点操作符 + 类中的引用的引用名）
2.注意！只有满足了两个碰撞条件（a.都具有碰撞器组件 b.运动的物体上具有刚体组件 --- 不处于运动状态的话则刚体组件处于休眠状态）之后才能够开始执行碰撞的三个阶段对应的方法 --- 对了写有方法的脚本也得挂载到游戏物体上并启动才行
触发器讲解 碰撞器组件中勾选了Is Trigger属性的游戏物体无论是撞别人还是被别人撞都不会产生碰撞效果而是直接穿过去
1.碰撞器组件中的Is trigger属性被勾选后就转变为了 --- 触发器
触发器与碰撞器的区别就是 --- 触发器不会产生碰撞效果
1.注意！只需要带有刚体组件即可，不需要处于运动状态
1.满足触发条件之后就会开始执行触发三阶段所对应的方法 注意碰撞三阶段与触发三阶段之间的 --- a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e867e9e253a705f97467a62321e55de9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d868c738f0498e9b21ea1bc7c16ae9c/" rel="bookmark">
			前端加密和nodejs加密的总结以及使用哪些加密方式和加密库的推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在前端项目和nodejs项目之间遇到了一个加密相关的问题，查了许多资料后发现心里更加迷糊了产生了不少问题比如：前端到底有哪些加密方式呢？一查各式各样的加密方式md5,rsa,aes,base64编码,sha1…等等，究竟该用哪几种呢？有没有相关的库让我去使用呢？一查各种各样的库，也很多如：crypto-js，bcryptjs，jsencrypt等
知识前提 在了解加密方式和加密库之前首先得了解常用的加密类型。
Hash加密算法：一般翻译做“散列”，也有直接音译为”哈希”的，就是把任意长度的输入(又叫做预映射，pre-image)，通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一地确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。Hash主要用于信息安全领域中加密算法，他把一些不同长度的信息转化成杂乱的128位的编码里,叫做Hash值.也可以说，Hash就是找到一种数据内容和数据存放地址之间的映射关系。了解了Hash基本定义，就不能不提到一些著名的Hash算法，MD5和SHA1可以说是目前应用最广泛的Hash算法，而它们都是以MD4为基础设计的对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信的安全性至关重要。非对称加密算法需要两个密钥：公开密钥(publickey:简称公钥)和私有密钥(privatekey:简称私钥)。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 说结论 1.需要加密防篡改并且不需要解密的情况下用什么方式？
答：md5 、sha256 这类型的加密可以是一种过程不可逆的加密类型，理论上是没办法解开的（实际嘛还是要花功夫，但至少可以挡下99.9%的人嘛）而这两种类型的加密也在前端中使用非常的广泛(大家都在用所以也不用担心什么)。
2.需要加密又需要解密还需要效率高的情况下用什么？
答：AES 加密，这类方式需要后端和前端共用一个私钥，基本上由前端来生成并且给后端
3.需要加密又需要解密还需要安全性高的，但是又不怎么在乎性能的情况下用什么？
答：RSA 加密，这种方式基本上由后端来给公钥，然后我们前端加密一下交给后端即可。如果安全性要更好则可以结合AES一起使用，推荐文章：点击
对于其他类型的加密方式这里就不做总结了，上面这几个无非就是前端最常用也用的最多的加密方式而已，至于其他的比如后端如果提供了其他加密方式，那更好，只需要网上找个对应类型的库引用即可
对于库的推荐：
在使用base64，md5、sha256和 AES 这几种加密方式的情况下完全可以使用 crypto-js 这个库，不用再去考虑其他的了，如果担心库太大了那么可以根据需要使用的加密类型单独引对于的类型的库即可，
如：md5使用md5.js
base64.js使用base64.js
sha256 使用 sha.js
AES 使用 aes-js
在使用rsa加密的时候使用 jsencrypt这个库用的比较舒服，密钥生成
bcryptjs 对于nodejs的开发对密码进行加密保存是比较好用的
最后说个：其实前端加密无论使用哪个加密都一样是有可能性被他人获取到相关的公钥或密钥的(比如拦截请求，查找源代码等)，然后进行加密与后端通讯，所以前端加密所谓的安全性还是有限的，最主要的还是在后端。但又说回来，前端加个密它至少也能防止绝大部分人看到明面上的东西，可以防止绝大部分的意外情况，反正也就按个插件调个方法而已，多简单的事。而且前后端都加密这也更加的提高了项目的安全性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/970cdd0173b8b7c9b642e3e0d7aae869/" rel="bookmark">
			文件解析__JSON解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSON： JSON是一种轻量级的数据交换格式。它基于ECMAScript(European Computer Manufacturers Association,欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得JSON称为理想的数据交换语言。易于人与阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。
JSON作为一种轻量级的数据格式，它主要用途是在计算机系统之间进行数据的传递。JSON作为数据传输的格式，有一下显著优点：
· JSON只允许使用 UTF-8 编码，不存在编码问题
· JSON内容仅包含 key-value 键值对，格式简单，不存在冗余结构，是一种轻量级结构；
· 浏览器内置JSON支持，如果把数据用JSON发送个浏览器，可以用 JavaScript 直接处理；
Java解析JSON
在使用Java进行应用程序的开发中，我们会面临类似“将Java对象转换成JSON格式”或者“将JSON格式的数据转换成Java对象”的需求，所以我们需要掌握如何使用第三方库来进行JSON格式数据的解析。
常用的用于解析JSON的第三方库有：
· Jackson【推荐】 · Gson
· Fastjson
· ...
Fastjson fastjson 是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将JavaBean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。
优点： 速度快：fastjson相对其他JSON库的特点是快，从2011年fastjson发布1.1x版本之后，其性能从未被其他Java实现的JSON库超越
使用广泛：fastjson在阿里巴巴大规模使用，在数万台服务器上部署，fastjson在业界被广泛接受。在2012年被开源中国评选为最受欢迎的国产开源软件之一。
测试完备：fastjson有非常多的testcase，在1.2.11版本中，testcase超过3321个。每次发布都会进行回归测试，保证质量稳定。
使用简单：fastjson的API十分简洁
功能完备：支持泛型，支持流处理超大文本，支持枚举，支持序列化和反序列化扩展。
Fastjson 的主要对象 fastjson 主要使用是 JSON 、JSONObject 、JSONArray 三个类。其中 JSONArray 和 JSONObject 继承 JSON：
JSON类 JSON类的作用主要是用于原始转换，常用方法有：
将Java对象 "序列化"（转换）为JSON字符串：JSON . toJSONString(Object object) 如果需要自定义 json 中的 key ，可以使用 @JSONField 注解在成员变量进行设置。
// 实体数据 Weather weather = new Weather(); weather.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/970cdd0173b8b7c9b642e3e0d7aae869/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e85f5ebe8074faa09bb47fade142dcf6/" rel="bookmark">
			【C&#43;&#43;】结构体数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、缘起
2、结构体数组
3、总结
1、缘起 在 C++ 语言中，结构体是一种非常有用的数据类型，可以将不同类型的数据组合成一个单元，方便程序员管理和处理。而 结构体数组 则可以用于存储 多个结构体对象，以便更好地组织和处理数据。
C++ 中的结构体数组可以看作是 一群小伙伴的集合，每个小伙伴都有 自己独特的特点和属性。通过结构体数组，我们可以方便地管理和处理这些小伙伴们的信息，就像是一个班级里的同学一样。本文将深入探讨结构体数组在C++中的应用和技巧，让你轻松成为小伙伴们的组织者。
2、结构体数组 作用：将自定义的结构体放入到数组中方便维护
语法：struct 结构体名 数组名【元素个数】= {{}，{}，...，{}}
示例：
#include&lt;iostream&gt; #include&lt;string&gt; using namespace std; //结构体数组 //1、定义一个结构体 struct Students { string name; int age; int scores; }; int main() { //2、创建结构体数组 struct Students stu_arr[3] = { {"张三",18,100}, {"李四",20,90}, {"王五",22,80} }; //3、给结构体数组中的元素赋值 stu_arr[2].name = "赵六"; stu_arr[2].age = 80; stu_arr[2].scores = 60; //4、遍历结构体数组 for (int i = 0; i &lt; 3; i++) { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e85f5ebe8074faa09bb47fade142dcf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70f6b1e9059fa3057d4a82a77b8179c0/" rel="bookmark">
			Vivdao FFT IP核调试记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近一时兴起，看了下Vivado版本下的FFT IP核，发现和ISE版本下的FFT IP核有一些差别，貌似还不小。做了个简单的仿真，Vivado仿真结果竟然和Matlab仿真结果对不上，废了九牛二虎之力研究datasheet、做仿真，终于使两个仿真结果对上了！着实花费了我不少脑细胞，也再一次证明了我不适合做算法（虽然总想证明一下自己可以的），还是老老实实做好我的FPGA工程师吧！至于算法的事情还是交给那些脑细胞发达的同仁们。
最开始我也是在网上找了不少例程，自己照着做的仿真，无一例外，Vivado仿真结果和Matlab仿真结果都对不上。然后各种怀疑，各种看时序，翻看信号与系统的书本，都没找到答案。但是我真的很想知道为什么，在求知欲的催促下最后还舔着脸皮问了几个朋友，有的现在不做算法了所以没有时间和精力专门帮我看问题，有的没有做过FFT，有的做过了给我讲了一下，也许问题太简单了，他们说的太过于精简，我也听得马马虎虎，最后还是不知道原因。放了几天之后，我就做了一个最简单的8点[0 1 2 3 4 5 6 7]FFT变换，结果竟然和matlab仿真结果对上了。下面给出FFT IP核配置以及相关代码。
一开始怀疑config接口配置完成后，会不会有个生效时间，所以还特意在代码里做了处理，后来证实根本没有影响，这个问题也在pg109的pg58页找到了答案，只要给好s_axis_data_tlast 信号就OK。
module top(
input I_clk,
input I_rst,
output O_valid,
output [23:0] O_re,
output [23:0] O_im
);
wire [7 : 0] s_axis_config_tdata ;
reg s_axis_config_tvalid ;
wire s_axis_config_tready ;
wire [31 : 0] s_axis_data_tdata ;
reg s_axis_data_tvalid ;
wire s_axis_data_tready ;
wire s_axis_data_tlast ;
wire [47 : 0] m_axis_data_tdata ;
wire [7 : 0] m_axis_data_tuser ;
wire m_axis_data_tvalid ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70f6b1e9059fa3057d4a82a77b8179c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f541442129200fdb9fc858deabc8d8c/" rel="bookmark">
			Python || 计算1到100之间的奇数之和及偶数之和。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 计算1到100之间的奇数之和及偶数之和。
输出格式如下：
1到100间的偶数的和为？
1到100间的奇数之和为？
sum=0 num=0 for i in range(0,101): if i%2==0: sum=sum+i else: num=num+i print('1到100间的偶数的和为%d'%sum) print('1到100间的奇数的和为%d'%num) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee843a5df38ce3495020e8169b3b289d/" rel="bookmark">
			[论文阅读RGBD-SOD][2022_TCSVT_MoADNet][轻量化]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MoADNet: Mobile Asymmetric Dual-Stream Networks for Real-Time and Lightweight RGB-D Salient Object Detection paper：https://ieeexplore.ieee.org/abstract/document/9789193
动机 尽管已有许多优秀的RGB-D SOD技术被提出，但它们大多关注性能增强，而缺乏对移动设备上实际部署的关注。
解决方案 在本文中，我们提出了移动非对称双流网络(MoADNet)，用于实时和轻量级RGB-D SOD。
1.首先，受到RGB和深度模式之间固有差异的启发，我们观察到深度图可以用比RGB图像更少的通道表示。因此，我们设计了基于MobileNetV3的非对称双流编码器。
补充：这句话的意思是，深度图像可以使用比RGB图像更少的通道来表示。这是因为深度图像与RGB图像不同，不需要表示颜色信息，而只需表示距离信息。RGB图像包含红色、绿色和蓝色三个通道，每个通道都包含一个像素点的颜色信息。而在深度图像中，每个像素点代表的是距离摄像头的距离值，因此只需要一个通道就可以表示。这也就意味着，相对于RGB图像，深度图像可以用更少的数据来表示，从而减少计算和存储开销。
疑问？？这种不对称是怎么设计的？动机是什么？
在后文提到：前人使用对称双流网络从RGB图像和深度图中提取特征。然而，这两种模式传达了不同的信息。RGB图像包含丰富的颜色和纹理特征，深度图提供空间位置和粗略形状。这两种模式之间的内在差异启发了我们开发非对称双流网络来进行特征提取。
RGB：MobileNetV3-Large，Depth：MobileNetV3-Small
2.其次，我们开发了一种倒置瓶颈跨模态融合(IBCMF)模块来融合多模态特征，该模块采用倒置瓶颈结构来补偿轻量化主干中的信息丢失。
3.第三，我们提出了自适应atrous空间金字塔(A2SP)模块来加速推理，并通过适当选择解码器中的多尺度特征来保持推理的性能。（这个模块可以理解为上下文提取模块，用于更好的表达特征的表示）
IBCMF 1.为什么设计这个模块？
轻量级主干提取代表性特征的能力低。
2.怎么设计的？
受[47]的启发，采用channel expansion 来补偿轻量级骨干中的信息损失。我们首先在低级阶段扩大融合前的channel数量。随后，减少这些channel，以促进逐元素操作。由于该过程与反向瓶颈结构[47]具有相同的精髓，我们将此组件命名为反向瓶颈跨模态融合（ IBCMF)模块。
1）Channel Alignment: 由于我们的目标是设计非对称双流编码器，不同支路的输出可能有不一致的形状。我们使用Pointwise Convolution Conv1×1(·)使RGB和深度流的输出具有相同的通道尺寸，
补充：Pointwise Convolution也被称为 1×1 卷积，是指卷积核大小为 1×1 的卷积操作。Pointwise Convolution 是一种非常轻量级的卷积操作，其本质上就是一种线性变换，可以有效地将通道之间的信息进行整合和变换。
与传统卷积不同，Pointwise Convolution 在空间上不进行滑动窗口卷积，而是在通道维度上进行乘加运算。因此，它可以非常高效地实现通道数的变换和压缩。同时，由于 Pointwise Convolution 的计算量较小，其计算速度也比较快，因此常常被用于轻量化网络设计中。
Pointwise Convolution 主要应用在两个方面：特征融合和特征变换。
具体来说：
特征融合：在深度学习中，我们经常需要将不同尺度的特征进行融合，这时可以使用 Pointwise Convolution 实现通道数的增加或者减少，从而实现特征融合。
特征变换：有时候我们需要对特征进行维度变换，例如将一个高-dimensional 的特征张量映射到 low-dimensional 的嵌入空间中。此时可以使用 Pointwise Convolution 实现通道数的变换，然后将变换得到的特征进行池化或者全局平均池化，从而得到 low-dimensional 的嵌入特征。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee843a5df38ce3495020e8169b3b289d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35e60bacde07cbdf9f6f90b0761ab00c/" rel="bookmark">
			element el-table多列多字段同时排序后端返回数据（支持多个字段同时进行排序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		element el-table多列多字段同时排序后端返回数据（支持多个字段同时进行排序） 场景 描述 element el-table仅才支持单列（一个字段）进行排序，想要支持多列排序，首先要定义一个数组，用于存放所有排序的字段及其顺序，
设置列sortable=“custom”，结合sort-change事件，在点击排序箭头时进行排序操作
&lt;template&gt; &lt;el-table :data="tableData" style="width: 100%" :default-sort = "{prop: 'date', order: 'descending'}" @sort-change="handleTableSort" @selection-change="selectHandle" @row-click="rowClickHandle" :header-cell-class-name="handleHeaderCellClass" &gt; &lt;el-table-column prop="date" label="日期" sortable="custom" width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="name" label="姓名" sortable="custom" width="180"&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { tableData: [{ date: '2016-05-02', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }], realParams: { ordersList: [], }, } }, methods: { // 设置列的排序为我们自定义的排序 handleHeaderClass({ column }) { column.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35e60bacde07cbdf9f6f90b0761ab00c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abc601a97fc6fce9aa73a4d1d0af2807/" rel="bookmark">
			【模型融合】集成学习（boosting, bagging, stacking）原理介绍、python代码实现（sklearn）、分类回归任务实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概览boostingbaggingStacking投票平均Stack 代码实现1. 分类1.0 数据集介绍1.1 boosting1.2 bagging1.3 stacking 2. 回归2.0 数据集介绍stacking 概览 简单来说，集成学习是一种分类器结合的方法（不是一种分类器）。
宏观上讲集成学习分为3类：
序列集成方法boosting
思路：每个学习器按照串行的方法生成。把几个基本学习器层层叠加，但是每一层的学习器的重要程度不同，越前面的学习的重要程度越高。它聚焦样本的权重。每一层在学习的时候，对前面几层分错的样本“特别关注”，建立了每个机器学习器之间的依赖关系，因此提升了整体模型的准确率。
boost家族还是非常有名的，在sklearn上已经集成了非常多的boost分类器，例子特别多。值得一提的是很多树类的boost还可以作为特征筛选器，有特征重要程度评分的功能。
并行集成方法bagging
跟楼上不一样，这个方法是并行的，每个学习器是独立的存在，所以在训练的时候也将训练集分成互相有交集（训练集庞大的时候也可以没交集）的几组分别给每个学习器学习。因此bagging方法是一个集体决策，这就导致了每个学习器的学习结果存在差异。对于相同部分，直接采取；对于不同部分，采用投票的方式做出集体决策。
模型融合Stacking
这个思路跟上面两种方法又有所区别。之前的方法是对几个基本学习器的结果操作的，而Stacking是针对整个模型操作的，可以将多个已经存在的模型进行组合。跟上面两种方法不一样的是，Stacking强调模型融合，所以里面的模型不一样（异质），而上面两种方法中的模型基本类似（同质）。个人感觉关键点在于组合的模型的选择和组合策略的确定。
南京大学的周志华教授对集成学习有很深入的研究，其在09年发表的一篇概述性论文《Ensemble Learning》对这三种集成学习的框架的介绍非常详细。
模型的特点：
序列集成方法boosting
重点聚焦几个基本学习器分类错的样本，主要目的是减少整体模型的偏差。
并行集成方法bagging
重点聚焦数据集是分布，多次采样分别训练模型，减少分类器的方差。
模型融合Stacking
重点是聚焦模型的顺序和种类，根据模型来构建融合Stack。模型“好而不同”，提升泛化能力。
优点：
通常一个集成分类器的分类性能会好于单个分类器。因为采取了不同的模型，集成学习的泛化能力也有所提升。 boosting 基本过程如下图所示
注意点：
权重初始化：样本权重1初始化的时候直接平分权重。如果有n个样本，那就直接每个样本 1 n \frac{1}{n} n1​的权重。权重更新方法：不同的模型就不一样 AdaBoost 是对错误样本赋更大的权重；GBDT（Gradient Boost Decision Tree) 每一次的计算是为了减少上一次的残差，还有很多其他的模型用了不同的方法。迭代：一直计算每个基本分类器的误差率，并更新，直至误差率达到规定范围。相对来说，boosting模型更关注在上一轮的结果上进行调整，是个串行的策略。所以，作为一个序列化的方法，其基本学习器之间存在强依赖关系，基本学习器可以稍微简单一点（弱分类器）。 bagging 基本过程如下图所示，还是能看出跟 boosting 不一样的。
注意点：
随机采样：又放回地随机采样，所以有的样本被重复抽到有的不会被抽到。好处是能降低数据分布对学习器的影响。结合策略：随机森林就是在样本随机采样时对决策树也随机采样。迭代：一直训练基本学习器，直至基本学习器的数量达到规定数量。相对来说，bagging模型更关注每个模型的表现，因为是个并行的策略，每个模型都很重要。所以，基本学习器可以稍微复杂一点（随机森林的决策树深度深一点）。 Stacking 这个其实跟楼上不太一样，这个不是一个集成学习模型，是一个结合策略。
比较简单的结合策略有：
投票法平均法stack 投票 投票的的基本思路就是少数服从多数。感觉多数用于分类问题中。
最简单的投票就是直接让基本学习器对某一个样本分类，每个分类器根据自己的结果对类别投票。对于最终的分类结果，我们取得票最多的选项，如果出现平票就随机选一个。
稍微有点想法的投票是绝对多数投票：有点像决策树的增益率选取，对于最终的分类结果，它不仅要满足取得票最多这一条件，还要满足被投票过半的条件。如果不满足，那就直接拒绝预测。
另一种投票方法是加权投票法：对于每个学习器赋予权重，再加权求和得到每个类别的票数，这里的权重制定方法就要看你自己了。
平均 很多时候，针对回归问题，投票显然不能解决问题。这个时候就需要平均。
普通的平均就是直接取多个学习器的预测结果直接取平均。
加权平均跟其他的也差不多，主要是怎么个赋权法。
Stack 从初始数据集中训练出初级学习器，然后“生成”一个新数据集用于训练次级学习器。在新数据集中，初级学习器的输出被当做样例输入特征，初始样本的标记仍被当做样例标记。
上面的两种学习器我们称为：
基学习器：即上述所说的一级学习器元学习器：即上述所说的二级学习器。这里的”元“跟元学习、元宇宙等的”元“是一个意思，表示的是更高一层的抽象。元学习器即“学习器的学习器”，有点像基学习器的加权平均和打分器。 还有几个注意点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abc601a97fc6fce9aa73a4d1d0af2807/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfd956e69bc75067587b5455a1d2c9cf/" rel="bookmark">
			虚拟机VMware里面安装Windows sever 2003版本详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列精品文章目录 python当中的第三方wxPython库的安装解答_pip install wx_张小鱼༒的博客-CSDN博客
centos7配置静态网络常见问题归纳_centos7网络问题_张小鱼༒的博客-CSDN博客
spark里面配置jdk后的编程与Hadoop配置_张小鱼༒的博客-CSDN博客
文章目录 系列精品文章目录
文章目录
前言
一、准备工作
下载Windows server 2003 的镜像文件
二、安装过程
1、先建立一个虚拟机
2.打开虚拟机进行安装
总结
前言 本文主要介绍如何在虚拟机里面安装Windows server 2003版本，以下为详细介绍
一、准备工作 下载Windows server 2003 的镜像文件 此处是小编的百度网盘分享文件：【此处是之前小编下载的一个版本】
Windows server2003的链接，有需要自取
链接：https://pan.baidu.com/s/1Pyb1jppuHu8FpYXHD2c6Zw?pwd=086a 提取码：086a
另外一种：
下载地址链接：https://msdn.itellyou.cn/https://msdn.itellyou.cn/
下载完成之后就可以看到我们下载的文件
有需要链接的小伙伴可以使用网盘链接：
链接：https://pan.baidu.com/s/16Iul5hi68JfnTSAZDh8Jgg?pwd=i703 提取码：i703
二、安装过程 1、先建立一个虚拟机 新建虚拟机：
选择自定义安装，因为需要用镜像文件
继续下一步，默认安装即可
选择稍后安装操作系统
此处我们要选择Windows的server2003标准版本，选择好之后继续下一步
创建虚拟机名称，选择安装位置
选择处理器的核数，这个因人而异，你自己设置
默认下一步
继续下一步
默认下一步
继续下一步
磁盘的内存可调节
继续下一步
虚拟机安装完成
2.打开虚拟机进行安装 先将iso文件配置上去
编辑虚拟机设置 ，之后点击确定
此处就可以看到这里与之前不一样了
选择开启虚拟机
按照提示来做，按enter键
这里选择我同意
此处小编的卡在了f8热键不出来【小编的电脑是戴尔版本，看你是因为电脑上将这些热键的功能取消了，所以一直出不来】，无法进行后续安装了，已经跟到这步的小伙伴们也别着急。
下面是小编从2.1里面重新开始的步骤：
和2.1不同的地方是这里，选择直接安装映像文件，
此处输入产品密钥以及用户名和密码【小编设置的就是小编名字与xiaobian英文】
这种方式的安装就比之前的粗暴。
选择位置与名字
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfd956e69bc75067587b5455a1d2c9cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/987e733b953ef1e21febe67229bfa63e/" rel="bookmark">
			pytorch中使用add_module添加网络子模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前有一篇文章介绍了使用Sequential、ModuleList和ModuleDict添加网络，除此之外，我们还可以通过add_module()添加每一层，并且为每一层增加了一个单独的名字。add_module()可以快速地替换特定结构可以不用修改过多的代码。
add_module的功能为Module添加一个子module，对应名字为name。使用方式如下：
add_module(name, module) 其中name为子模块的名字，使用这个名字可以访问特定的子module，module为我们自定义的子module。
一般情况下子module都是在A.init(self)中定义的，比如A中一个卷积子模块self.conv1 = torch.nn.Conv2d(…)。此时，这个卷积模块在A的名字其实是’conv1’。
对比之下，add_module()函数就可以在A.init(self)以外定义A的子模块。如定义同样的卷积子模块，可以通过A.add_module(‘conv1’, torch.nn.Conv2d(…))。
直接看代码会更直观，举例如下：
普通add_module举例 from torch import nn from torchsummary import summary class Net1(nn.Module): def __init__(self): super(Net1,self).__init__() self.conv_1 = nn.Conv2d(3,6,3) self.add_module('conv_2', nn.Conv2d(6,12,3)) self.conv_3 = nn.Conv2d(12,24,3) def forward(self,x): x = self.conv_1(x) x = self.conv_2(x) # 使用name访问 x = self.conv_3(x) return x model = Net1() print(model) model.to('cuda') summary(model,(3,128,128)) 输出：
Net1( (conv_dd): Conv2d(3, 6, kernel_size=(3, 3), stride=(1, 1)) (conv_2): Conv2d(6, 12, kernel_size=(3, 3), stride=(1, 1)) (conv_3): Conv2d(12, 24, kernel_size=(3, 3), stride=(1, 1)) ) ---------------------------------------------------------------- Layer (type) Output Shape Param # ================================================================ Conv2d-1 [-1, 6, 126, 126] 168 Conv2d-2 [-1, 12, 124, 124] 660 Conv2d-3 [-1, 24, 122, 122] 2,616 ================================================================ Total params: 3,444 Trainable params: 3,444 Non-trainable params: 0 ---------------------------------------------------------------- Input size (MB): 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/987e733b953ef1e21febe67229bfa63e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b58fbc07d27e6546b07275dea33349c/" rel="bookmark">
			Ubantu搭建NFS服务器共享文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubantu搭建NFS服务器共享文件 搭建一台NFS服务器为局域网中的用户提供文件共享，NFS服务器要求如下：
1.将本地文件系统的/home/share目录共享，192.168.61.100与192.168.61.200两个客户机对该目录具有读写限权，而192.168.61.0/24网段内的其他客户机对该目录具有只读限权。（IP地址可根据自己虚拟机的地址调整）
2.将本地文件系统的/home/test目录共享，所有的用户对该目录具有读写权限。
请完成NFS服务器的配置并在一台客户端测试。
在搭建NFS服务器之前，需要先安装NFS的软件包。以Ubuntu为例，可以使用以下命令安装：
sudo apt-get install nfs-kernel-server 安装完成后，可以按照以下步骤配置NFS服务器。
创建共享目录 首先需要创建共享目录。以/home/share和/home/test为例，可以使用以下命令创建：
sudo mkdir /home/share sudo mkdir /home/test 配置exports文件 NFS服务器会根据/etc/exports文件来设置共享目录的权限。可以使用以下命令编辑该文件：
sudo vim /etc/exports 在文件末尾添加以下内容：
/home/share 192.168.61.100(rw) 192.168.61.200(rw) 192.168.61.0/24(ro) /home/test *(rw,sync,no_subtree_check) 其中，/home/share目录对192.168.61.100和192.168.61.200客户机具有读写权限，对192.168.61.0/24网段内的其他客户机具有只读权限；/home/test目录对所有客户机具有读写权限。
重启NFS服务 以上配置完成后，需要重启NFS服务以使其生效：
sudo systemctl restart nfs-kernel-server 在客户端测试 在客户端上可以使用以下命令测试NFS服务器是否正常工作：
sudo mount -t nfs &lt;NFS服务器IP地址&gt;:/home/share /xxx 其中，&lt;NFS服务器IP地址&gt;应替换为NFS服务器的实际IP地址。如果提示“mount.nfs: access denied by server while mounting”，可能是由于NFS服务器的防火墙设置导致的。可以通过以下命令打开NFS服务器的2049端口：
sudo ufw allow from &lt;客户端IP地址&gt; to any port nfs 其中，&lt;客户端IP地址&gt;应替换为实际的客户端IP地址。然后再次尝试挂载NFS共享目录即可。
同样，也可以使用以下命令测试/home/test目录是否正常工作：
sudo mount -t nfs &lt;NFS服务器IP地址&gt;:/home/test /xxxx 至此，NFS服务器的配置完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17eaf566efa72a86c91897636b5adf5f/" rel="bookmark">
			【vue】vue中下载文件的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 下载后端返回文件1.1 后端为post请求返回二进制流文件URL.createObjectURLFileReader 1.2 后端直接返回get请求文件 2. 下载本地文件 1. 下载后端返回文件 1.1 后端为post请求返回二进制流文件 Blob
Blob对象标识一个不可变、原始数据的类文件对象。Blob表示的不一定是JavaScript原生格式的数据
responseType
responseType它表示服务器响应的数据类型，由于后台返回来的是二进制数据，所以要把它设为‘blob’
通过设置responseType为blob，可以直接拿到二进制文件转化为Blob，两种使用 Blob 实现文件下载的方式
URL.createObjectURL 在浏览器端，实现直接下载文件，就是使用a标签来只想文件的下载地址。window.location.href的本质也是这样，因此在拿到二进制文件对应的Blob对象后，需要为这个Blob对象创建一个指向它的下载地址的URL
URL.createObjectURL 方法则可以实现接收 File 或 Blob 对象，创建一个 DOMString，包含了对应的 URL，指向 Blob 或 File 对象，它看起来会是这样：
“blob:http://localhost:8080/a48aa254-866e-4c66-ba79-ae71cf5c1cb3”
完整使用：
export const downloadFile = (fileStream, name, extension, type = "") =&gt; { const blob = new Blob([fileStream], {type}); const fileName = `${name}.${extension}`; if ("download" in document.createElement("a")) { const elink = document.createElement("a"); elink.download = fileName; elink.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17eaf566efa72a86c91897636b5adf5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec6b2b865cb04fa07643708849de9a1a/" rel="bookmark">
			Android 实现控件对称布局（约束布局和线性布局）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		画界面时会遇到很多界面上的布局，虽然很简单，但是每次做起来不熟练，总结一下一些日常的
一.实现界面上的两个空间对称布局 方法一、用约束布局的guideLine.适用于两个控件不确定宽高，且约束条件较多
Guideline是只能用在ConstraintLayout布局里面的一个工具类，用于辅助布局，类似为辅助线，可以设置android:orientation属性来确定是横向的还是纵向的。
重要属性：
layout_constraintGuide_begin，指定左侧或顶部的固定距离，如10dp，在距离左侧或者顶部10dp的位置会出现一条辅助线layout_constraintGuide_end，指定右侧或底部的固定距离，如50dp，在距离右侧或底部50dp的位置会出现一条辅助线layout_constraintGuide_percent，指定在父控件中的宽度或高度的百分比，如0.5，表示距离垂直或者水平居中。 &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_marginTop="20dp" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;androidx.appcompat.widget.AppCompatTextView android:layout_width="wrap_content" android:layout_height="wrap_content" app:layout_constraintStart_toStartOf="parent" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintTop_toTopOf="parent" android:textColor="@color/black" android:text="guideline 实现对称布局"/&gt; &lt;androidx.appcompat.widget.AppCompatButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="确定" android:layout_marginTop="30dp" android:layout_marginEnd="20dp" app:layout_constraintTop_toTopOf="parent" app:layout_constraintEnd_toStartOf="@id/guide_line_1" android:textColor="@color/white" android:background="@drawable/rgb1a1c1f_r8" android:textStyle="bold" android:paddingHorizontal="20dp"/&gt; &lt;androidx.constraintlayout.widget.Guideline android:id="@+id/guide_line_1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="vertical" app:layout_constraintGuide_percent="0.5"/&gt; &lt;androidx.appcompat.widget.AppCompatButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="取消" android:layout_marginTop="30dp" android:background="@drawable/rgb1a1c1f_r8" android:layout_marginStart="20dp" app:layout_constraintTop_toTopOf="parent" app:layout_constraintStart_toEndOf="@id/guide_line_1" android:textColor="@color/white" android:textStyle="bold" android:paddingHorizontal="20dp"/&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 方法二：线性布局，都知道线性布局要么水平要么垂直，当要求其子控件均匀排列，或者按一定比例占据父容器的宽高时，可用到其weight属性 这是实现左右对称
&lt;LinearLayout android:paddingHorizontal="20dp" android:layout_marginTop="20dp" android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/ll_1" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@id/cl_1" android:orientation="horizontal"&gt; &lt;androidx.appcompat.widget.AppCompatButton android:background="@drawable/rgb1a1c1f_r8" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginEnd="20dp" android:text="@string/video" android:layout_weight="1"/&gt; &lt;androidx.appcompat.widget.AppCompatButton android:background="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec6b2b865cb04fa07643708849de9a1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccdf3cad607872ec6ca17b010148d7b5/" rel="bookmark">
			直接插入排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt; #include&lt;math.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; int main(){ void InsertSort(int a[],int n); int a[10] = {0,9,8,7,6,5,4,3,2,1}; InsertSort(a, 10); for (int i=1;i&lt;10;i++) printf("%d\t",a[i]); putchar(10); return 0; } void InsertSort(int a[],int n){ int i,j; for(i=1;i&lt;=n;i++) if(a[i]&lt;a[i-1]){ a[0]=a[i]; for(j=i-1;a[0]&lt;a[j];j--) a[j+1]=a[j]; a[j+1]=a[0]; } } 运行结果如下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1abf9158a4be7da50976fe177ae5a296/" rel="bookmark">
			谭浩强C语言第一，二章习题答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是程序？什么是程序设计？
程序是一组计算机能够识别和执行的指令，是若干个指令或命令的集合。
程序设计是给出解决特定问题程序的过程，是软件构造活动中的重要组成部分。程序设计往往以某种 程序设计语言 为工具，给出这种语言下的程序。 程序设计过程应当包括 分析 、 设计 、 编码 、测试、排错等不同阶段。
2.为什么需要计算机语言？高级语言有哪些特点？
人和计算机交流需要解决语言问题，这就需要创造一种计算机和人能够识别的语言。
高级语言的特点1.数据结构更加丰富2.与具体机器关联没有那么密切3.与自然语言更接近4.通过编译和链接计算机才能运行。
3.略
4.略，
5.略
6.
#include &lt;stdio.h&gt; int main() { int a,b,c,max; printf("请分别输入a,b,c的值\n"); scanf("%d, %d, %d",&amp;a,&amp;b,&amp;c); max = a; if (max&lt;b){ max = b; } if(max&lt;c){ max = c; } printf("最大值是%d",max); return 0; } 1.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a4dce0370e5b6daf379029340f234e1/" rel="bookmark">
			paddleocr 的使用要点3 （仪表识别）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要点：
文本识别 1 文本识别算法理论 本章主要介绍文本识别算法的理论知识，包括背景介绍、算法分类和部分经典论文思路。
通过本章的学习，你可以掌握：
文本识别的目标
文本识别算法的分类
各类算法的典型思想
1.1 背景介绍 文本识别是OCR（Optical Character Recognition）的一个子任务，其任务为识别一个固定区域的文本内容。在OCR的两阶段方法里，它接在文本检测后面，将图像信息转换为文字信息。
具体地，模型输入一张定位好的文本行，由模型预测出图片中的文字内容和置信度，可视化结果
文本识别的应用场景很多，有文档识别、路标识别、车牌识别、工业编号识别等等，根据实际场景可以把文本识别任务分为两个大类：规则文本识别和不规则文本识别。
规则文本识别：主要指印刷字体、扫描文本等，认为文本大致处在水平线位置
不规则文本识别： 往往出现在自然场景中，且由于文本曲率、方向、变形等方面差异巨大，文字往往不在水平位置，存在弯曲、遮挡、模糊等问题。
下图展示的是 IC15 和 IC13 的数据样式，它们分别代表了不规则文本和规则文本。可以看出不规则文本往往存在扭曲、模糊、字体差异大等问题，更贴近真实场景，也存在更大的挑战性。
因此目前各大算法都试图在不规则数据集上获得更高的指标。
不同的识别算法在对比能力时，往往也在这两大类公开数据集上比较。对比多个维度上的效果，目前较为通用的英文评估集合分类如下：
1.2 文本识别算法分类 在传统的文本识别方法中，任务分为3个步骤，即图像预处理、字符分割和字符识别。需要对特定场景进行建模，一旦场景变化就会失效。面对复杂的文字背景和场景变动，基于深度学习的方法具有更优的表现。
多数现有的识别算法可用如下统一框架表示，算法流程被划分为4个阶段：
1 文本识别实战 上一章理论部分，介绍了文本识别领域的主要方法，其中CRNN是较早被提出也是目前工业界应用较多的方法。本章将详细介绍如何基于PaddleOCR完成CRNN文本识别模型的搭建、训练、评估和预测。数据集采用 icdar 2015，其中训练集有4468张，测试集有2077张。
通过本章的学习，你可以掌握：
如何使用PaddleOCR whl包快速完成文本识别预测
CRNN的基本原理和网络结构
模型训练的必须步骤和调参方式
使用自定义的数据集训练网络
注：paddleocr指代PaddleOCR whl包
1.1 安装相关的依赖及whl包 首先确认安装了 paddle 以及 paddleocr，如果已经安装过，忽略该步骤。
# 安装 PaddlePaddle GPU 版本 !pip install paddlepaddle-gpu # 安装 PaddleOCR whl包 ! pip install -U pip ! pip install paddleocr 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a4dce0370e5b6daf379029340f234e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/477c995d2780fb4e145c30b45792114f/" rel="bookmark">
			el-select可以输入选择项以及选择某一项后出现输入文本框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 效果：
直接上代码做笔记 通过ref属性获取输入内容，在@blur中进行赋值，很好的实现了可选择，可输入
&lt;el-form-item class="filter-item" label="沟通原因" prop="chatReason"&gt; &lt;el-select v-model="saveChatInfoRuleForm.desc" placeholder="请选择沟通原因" allow-create default-first-option filterable @blur="descOptionsBlurEvent()" ref="descOptionsSelect" @change="descOptionsChange(this)" &gt; &lt;el-option v-for="item in descOptions" :key="item.value" :label="item.label" :value="item.value" &gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;el-input type="textarea" v-model="saveChatInfoRuleForm.desc" v-if="other" placeholder="备注说明"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; //选择框可输入是去焦点获得 descOptionsBlurEvent(){ this.saveChatInfoRuleForm.desc=this.$refs.descOptionsSelect.selectedLabel }, //选择框发生改变时 descOptionsChange(obj){ if (this.saveChatInfoRuleForm.desc==='其他情形'){ this.other=true }else { this.other=false } }, 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/154/">«</a>
	<span class="pagination__item pagination__item--current">155/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/156/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>