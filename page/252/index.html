<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38cb017455d1975e47d8fc1fa4fb7834/" rel="bookmark">
			MyBatis从入门到精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyBatis MyBatis 是一款优秀的半自动的ORM持久层框架，它支持自定义 SQL、存储过程以及高级映射。
MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。
MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。
持久层：可以立即保存在磁盘上，在这里可以理解为与数据库相关操作。
什么是ORM
OBject Relation Mapping 对象关系映射
对象指的是面向面向对象，关系指的是数据库中的表，
例如Java语言中的POJO类与数据库模型之间的对应关系。
为什么MyBatis是半自动ORM框架
public class User(){ private long id; private String realname; } User user = user .getById(3); SELECT `id`,`realname` FROM `user` WHERE `id` = 3; 以上用例为ORM框架部分执行代码，发现在ORM框架中不需要使用SQL语句，
大大减少了程序员学习成本和SQL语句维护成本，
另外当数据库产品更换的之后无需重新编写项目中的SQL语句
-- MySQL SELECT * FROM `user` LIMIT 10; -- SqlServer SELECT * FROM `user` TOP 10; 用MyBatis进行开发的，需要手写SQL语句，而ORM框架例如Hibernate则不需要编写SQL语句。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38cb017455d1975e47d8fc1fa4fb7834/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50ccf503b5025ec4c18c61db6c78a17f/" rel="bookmark">
			a标签 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，来了解下&lt;a&gt;标签的一些样式：
&lt;a&gt;标签的伪类样式
一组专门的预定义的类称为伪类，主要用来处理超链接的状态。超链接文字的状态可以通过伪类选择符＋样式规则来控制。伪类选择符包括： 总: a 表示所有状态下的连接 如 a{color:red} ① a:link： 未访问链接 ,如 a:link {color:blue} ② a:visited： 已访问链接 ,如 a:visited{color:blue} ③ a:active： 激活时（链接获得焦点时）链接的颜色 ,如 a:active{color:blue} ④ a:hover： 鼠标移到链接上时 ,如 a:hover {color:blue} 一般a:hover和a:visited链接的状态（颜色、下划线等）应该是相同的。 前三者分别对应body元素的link、vlink、alink这三个属性。 四个“状态”的先后过程是：a:link -&gt;a:hover -&gt;a:active -&gt;a:visited。
另外，a:active不能设置有无下划线（总是有的）。 举例：伪类的常见状态值 &lt;style type = “text/css”&gt; &lt;!-- a {font-size:16px} a:link {color: blue; text-decoration:none;} //未访问：蓝色、无下划线 a:active:{color: red; } //激活：红色 a:visited {color:purple;text-decoration:none;} //已访问：紫色、无下划线 a:hover {color: red; text-decoration:underline;} //鼠标移近：红色、下划线 --&gt; &lt;/style&gt;
如何去掉&lt;a&gt;的下划线：
对超链接下划线设置 使用代码"text-decoration"
语法： text-decoration : none || underline || blink || overline || line-through text-decoration参数： none : 无装饰
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50ccf503b5025ec4c18c61db6c78a17f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccd05714924ee6d09c7f3d113bb0ea95/" rel="bookmark">
			python随机生成一注双色球
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先我们先要理解双色球的蓝球有多少个、红球有多少个。
2、蓝球6个、红球1个。
3、我们要用到random库、range函数、sample方法（随机不重复）。
4、三行简单的代码、然后打印出来、这是完整的代码。
import random ran=random.sample(range(1,34),6) ran1=random.sample(range(1,17),1) print('生成一注双色球：',ran,'+',ran1) 5、最后我们看一下效果、可能会有些粗糙、不过我们的要求已经达到了。
关注我的公众号：客兴天下
后续还有更多有用、实在的教程。
当然公众号里还有其他吃喝玩乐的、欢迎大家查阅、请多多支持
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32c5b412b4d143fc72f84e63a9f23ddb/" rel="bookmark">
			数据结构——栈、队列、数组、串の选择题整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		栈 1、设链表不带头结点且所有操作均在表头进行，则下列最不适合作为链栈的是（）
A、只有表头结点指针，没有表尾指针的双向循环链表
B、只有表尾结点指针，没有表头指针的双向循环链表
C、只有表头结点指针，没有表尾指针的单向循环链表
D、只有表尾结点指针，没有表头指针的单向循环链表
解析：选C
对于双向循环链表，找头结点和尾结点都很方便
对于单向循环链表，已知头结点，找尾结点需要遍历整个链表，已知尾结点找头结点很方便。在表头插入删除的时候，不仅要找到插入位置的下一个结点，也需要找到前一个结点，而C的情况，寻找前一个结点（即尾结点）需要遍历整个链表，非常耗时。而对于D，已知尾结点，插入位置的下一个结点即是尾结点指向的下一个节点，插入位置的前一个结点就是就是尾结点，因此十分方便。
2、采用共享栈的好处（）
A、减少存取时间，降低发生上溢的可能
B、节省存储空间，降低发生上溢的可能
C、减少存取时间，降低发生下溢的可能
D、节省存储空间，降低发生下溢的可能
解析：选B
栈的存取时间复杂度都是O(1)，因此不存在减少存取时间的问题。
如果栈的长度比较长，而0号栈数据又比较少，如果采用传统的栈，就会有浪费的情况，而如果使用共享栈，就可以再存储一个栈的数据，提高了存储空间的利用率，节省了存储空间。
上溢：栈顶发生溢出。例如：往栈里放入push()数据，栈已经满了，再继续放就会发生上溢。
下溢：栈底发生溢出。例如：从栈里取出pop()数据，栈已经空了，再继续取就会发生下溢。
共享栈只有在整个存储空间全部满了的时候才会发生上溢。一般情况下，如果0号栈数据比较多，那么1号栈就会相应地占用少一点的空间，两个栈会相互调节。因此相对来说，降低了发生上溢的可能。下溢与栈存储的数据数量以及pop()操作有关，和是不是共享栈没有太大关系。
3、下列关于栈的叙述中，错误的是（）
a.采用非递归方式重写递归程序时必须要使用栈
b.函数调用时，系统要用栈保存必要的信息
c.只要确定了入栈次序，即可确定出栈次序
d.栈是一种受限的线性表，允许在其两端进行操作。
A、仅a
B、仅a、b、c
C、仅a、b、d
D、仅b、c、d
解析：选C
对于a，实现斐波拉契数列【F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N*）】迭代只需要一个循环即可，不需要使用栈。
对于b，函数调用的时候，系统需要记录当前执行到了哪一句，将该记录信息入栈，当函数调用结束后，再从上次执行的位置开始继续执行。
对于c，如果是按照1、2、3、4的顺序入栈，可以是1、2、3、4（1进1出，2进2出，3进3出，4进4出）的顺序出栈，也可以是4、3、2、1（1进，2进，3进，4进，4出，3出，2出，1出）的顺序出栈，出栈顺序取决于pop操作和push操作的顺序。
对于d，前半句正确，但是栈只允许在一端进行操作，队列是允许在两端进行操作。
4、若栈S1中保存整数，栈S2中保存运算符，函数F()依次执行下述各步操作：
1）从S1中依次弹出两个操作数a和b。
2）从S2中弹出一个运算符op。
3）执行相应的运算b op a。
4）将运算结果压入S1中。
假定S1中的操作数依次是5，8，3，2（2在栈顶），S2中的运算符依次是*，-，+（+在栈顶）。调用三次F()后，S1栈顶保存的是（）
A、-15
B、15
C、-20
D、20
解析：选B
注意！！！第三步是b op a，所以第二次调用的时候是8-5=3。
队列 1、允许对队列进行的操作有（）
A、对队列中的元素排序
B、取出最近进队的元素
C、在队列元素之间插入元素
D、删除队头元素
解析：选D
队列允许先进先出，因此可以对队头进行删除访问等操作。
2、已知循环队列的存储空间为数组A[21]，front指向队头元素的前一个位置，rear指向队尾元素，假设当前front和rear的值分别为8和3，则该队列的长度为（）
A、5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32c5b412b4d143fc72f84e63a9f23ddb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3edf51796ce231cef5123c63cec6ef4/" rel="bookmark">
			Xception详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Xception 详解 论文《Xception: Deep Learning with Depthwise Separable Convolutions》
1 主要思想 传统的卷积操作同时对输入的feature mapping的跨通道交互性（cross-channel correlations）、**空间交互性（spatial correlations）**进行了映射。
Inception系列结构着力于将上述过程进行分解，在一定程度上实现了跨通道相关性和空间相关性的解耦。
文章在Inception的基础上进行改进，使用深度可分离卷积（depthwise separate convolution）替代传统的Inception块，实现跨通道相关性和空间相关性的完全解耦。此外，文章还引入了残差连接，最终提出了Xception的网络结构。
2 Inception回顾 传统Conv进行操作时，同时在输入的通道维度和空间维度进行了操作，跨通道相关性和空间相关性的耦合性很高。
例如，对于h*h*c的feature mapping，卷积核尺寸为s*s，但实际上卷积核尺寸为s*s*c。在进行一次卷积操作时，实际上对feature mapping中的一个s*s*c进行了信息融合，其中s*s为空间维度，c为通道维度。
Inception结构在一定程度上对跨通道相关性和空间相关性进行了解耦。
可以知道的是，多分支卷积中使用1*1 Conv进行降维等价于先进行1*1 Conv后在进行分组卷积。以简化版的Inception为例，Figure 3 给出了Inception的等价形式。
回到Inception结构，先对feature mapping进行pointwise convolutions（1*1 Conv），以实现跨通道相关性的独立映射；然后进行分组卷积，将映射空间划分为若干个子空间，在子空间内进行卷积操作。
可以发现的是，Inception结构在一定程度上实现了跨通道相关性和空间相关性的解耦，但并未实现完全解耦（子空间的卷积操作）。
3 depthwise separate convolutions 考虑Inception的一种极端情况，在pointwise convolutions后进行分组时，将每个通道化为一组，即对于h*h*c的输入，分c组，每组一个通道。这与MobileNet中的depthwise separate convolutions类似。
depthwise separate convolutions由depthwise convolutions和pointwise convolutions组成。前者为分组数等于通道数的分组卷积，实现了空间相关性的映射；后者与Inception相同，实现了跨通道相关性的映射。这样可以看出，depthwise separate convolutions实现了空间相关性和跨通道相关性的完全解耦。
但不同的是，极端情况下的Inception中pointwise convolutions的位置与depthwise separate convolutions中相反，其次还包含了depthwise separate convolutions中没有的非线性层。
为了简便，文章使用了depthwise separate convolutions。
4 模型结构 基于上述描述，文章提出了Xception的具体结构。其中共包括36层卷积，分为14个stage。
5 模型性能 文章分别在ImageNet和JFT数据集上进行了测试，Xception表现较好。
与Inception V3相比，Xception参数量更少，收敛速度更快，准确度更高。
此外，模型还验证了残差结构的效果，实验表明残差结构提升明显。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8677055328c6f2a04a7efe4eb0723090/" rel="bookmark">
			如何在linux系统中打开巨型帧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用basler相机过程中出现The buffer was incompletely grabbed错误，一般为网络缓冲区不足导致的问题，需要设置巨型帧
sudo ifconfig eth0 mtu 9000
如果需要永久开启：
将"ifconfig eth0 mtu 9000"语句写到配置文件 /etc/profile 中，重启生效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1096a307bae66b1b6dd0f86272a7634d/" rel="bookmark">
			Swagger 的作用与使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Swagger 的作用二、Swagger 的优点三、使用步骤 1.导入 knife4j的maven坐标2.导入knife4j相关配置（WebMvcConfig）3.设置静态资源映射4.在拦截器中设置不需要处理的请求路径四、Swagger 常用注解总结 前言 Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务的接口文档。
目前的项目基本都是前后端分离，后端为前端提供接口的同时，还需同时提供接口的说明文档。但我们的代码总是会根据实际情况来实时更新，这个时候有可能会忘记更新接口的说明文档，造成一些不必要的问题。
一、Swagger 的作用 根据在代码中使用自定义的注解来生成接口文档，这个在前后端分离的项目中很重要。这样做的好处是 在开发接口时可以通过swagger 将接口文档定义好，同时也方便以后的维护。
在没有swagger之前，我们可以使用word，excel等功能来书写接口定义文档，但又有一个弊端，即： 在接口发送改变时需要及时的同步接口文档，否则实际的接口与接口文档不相符，则接口文件就失去了作用，甚至会起到反作用。
二、Swagger 的优点 号称时最流行的 API 框架
接口文档在线生成，避免同步的麻烦
可以支持在线对接口执行测试
支持多语言
三、使用步骤 1.导入 knife4j的maven坐标 &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/dependency&gt; 2.导入knife4j相关配置（WebMvcConfig） 3.设置静态资源映射 设置静态资源映射(WebMvcConfig类中的addResourceHandlers方法) ,否则接口文档页面无法访问
registry.addResourceHandler("doc.html").addResourceLocations("classpath:/META-INF/resources/"); registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/META-INF/resources/webjars/"); 4.在拦截器中设置不需要处理的请求路径 在LoginCheckFilter中设置不需要处理的请求路径
"/doc.html", "/webjars/**", "/swagger-resources", "/v2/api-docs" 四、Swagger 常用注解 总结 使用Swagger你只需要按照它的规范去定义接口及接口相关的信息，再通过Swagger行生出来的一系列项目和工具,就可以做到生成各种格式的接口文档，以及在线接口调试页面等等。
官网: https://swagger.io/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2674b90d54cca244a887ef907c33856b/" rel="bookmark">
			设计模式 - 原型模式 - 浅克隆和深克隆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原型模式使用场景： 在有些系统中，存在大量相同或相似对象的创建问题，如果用传统的构造函数来创建对象，会比较复杂且耗时耗资源，用原型模式生成对象就很高效，就像孙悟空拔下猴毛轻轻一吹就变出很多孙悟空一样简单。
原型模式的定义与特点 原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。例如，Windows 操作系统的安装通常较耗时，如果复制就快了很多。在生活中复制的例子非常多，这里不一一列举了。
原型模式的优点：
Java 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。 原型模式的缺点：
需要为每一个类都配置一个 clone 方法clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。 原型模式的结构与实现 由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。
1. 模式的结构
原型模式包含以下主要角色。
抽象原型类：规定了具体原型对象必须实现的接口（ Cloneable ）。具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。访问类：使用具体原型类中的 clone() 方法来复制新的对象。 用浅克隆和深克隆模拟给学生发奖状 浅克隆 定义一个奖状类实现Cloneable接口 （ 奖状类即为具体原型类 ，Cloneable是抽象原型类 ）
public class Citation implements Cloneable 具体原型类实现 clone 方法
public class Citation implements Cloneable{ String name; public void show() { System.out.println(name+"获得了奖状！"); } @Override protected Citation clone() throws CloneNotSupportedException { return (Citation) super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2674b90d54cca244a887ef907c33856b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/555e33f1672d93cc08c770d0bceb456c/" rel="bookmark">
			富文本，前端如何修改图片样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		富文本返回的图片样式不是前端所需样式str.replace(&lt;img ,&lt;img style=“height:100％；width:690rpx”)
后面图片大小 有不一致我直接用了三方组件库的富文本解析器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/229192a57f09572ea756dd7e84fa5c56/" rel="bookmark">
			python生成器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		理解生成器，最好的方法就是给他取个突出其本质的别名：生成数据的机器代码。
生成器是一种用时间换空间的做法。比如，利用list列表储存全体正整数，无穷个正整数再大的内存也无法装得下，这个时候就可以使用生成器，实现用一段代码来储存全部正整数的作用。如下面代码，每隔0.5秒自动递增生成一个正整数。
import time #生成器实际上就是一个函数，但是这个函数必须使用yield关键字，然后函数返回一个生成器对象generator def inf_N(): num = 1 while True: yield num num += 1 if __name__ == '__main__': #使用变量名inf_N_gennerate绑定这个生成器 inf_N_gennerate = inf_N() while True: time.sleep(0.5) #使用next()方法取生成器里面的数据 print(next(inf_N_gennerate)) 目录
一，生成器的官方定义
二，创建生成器的两种方式
1，生成器表达式
2，生成器函数
三，__next__()&amp;next()和send()方法
1，__next__()&amp;next()的区别
2，next()和send()用以唤醒生成器
3，send()方法的作用
一，生成器的官方定义 在Python中，一边循环一边计算的机制，称为生成器：generator。
二，创建生成器的两种方式 1，生成器表达式 生成器表达式返回一个生成器对象即generator object，需要用一个变量名来接收并绑定。
2，生成器函数 import time def inf_N(): num = 1 while num &lt;= 100: temp = yield num # 执行顺序是：①yield num将num返回出去；②将"yield num"这个个表达式的值交给变量temp，但是num已经被yield返回出去了，所以交给temp的只能是None了 # yield与return一样会将num返回出去，但不是像return一样结束函数。而是会卡在这里不执行，直到下一次使用next()方法唤醒 num += 1 print(temp) print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/229192a57f09572ea756dd7e84fa5c56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98049fd65d27ad6f176c30221b34a5e6/" rel="bookmark">
			xshell连接时显示“服务器发送了一个意外的数据包。received:3,expected:20
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在/etc/ssh/sshd_config最后增加以下一行
KexAlgorithms curve25519-sha256@libssh.org,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group14-sha1
systemctl reload sshd 或 systemctl restart sshd
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7024cdc29b0e3cf227922701a92aa40/" rel="bookmark">
			解决 CentOS 7中同步集群时间报 no server suitable for synchronization found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、CentOS 中同步时间时 如果要同步外部服务器的时间使用【ntpdate cn.ntpdate.org.cn】 命令就可以。
二、当服务器不能访问外网，只能使用内网，需要向A服务器同步时间时，首先需要在A服务器上使用 【service ntpd start】开启ntpd服务，然后B服务器使用【ntpdate A服务器ip】命令去同步时间时发现报no server suitable for synchronization found错误。原因是因为A服务器并没有开启123端口，此时需要在A服务器中执行
firewall-cmd --permanent --zone=public --add-port=123/udpfirewall-cmd --permanent --zone=public --add-port=123/tcpsystemctl restart firewalldsystemctl restart ntpd
此时再在B服务器中使用【ntpdate A服务器ip】就可以同步成功时间。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cc8df8e88b13f1ca5d5bc66cca14926/" rel="bookmark">
			[Shell] 常用写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iF9PzeAQm9);H7oi%r6YdLk6;lxJ=d$c 常识 ls ls -lh --time-style="+%Y-%m-%d %H:%M:%S"
awk 'condition{move1;move2}' 文件名1 文件名2 NR 行数，索引
NF 列数，一般写在{}内部
-F"dfd" 重新确认分隔符
A~B 是否包含 - 也可以
-gt 大于等于
// 正则
去重 | awk '!a[$0]++' | sort -u | uniq 大写字母 [root@localhost ~]# test='ab' [root@localhost ~]# echo $test ab [root@localhost ~]# echo ${test^} Ab [root@localhost ~]# echo ${test^^} AB 取字符串某部分
STR=123456abc FINAL=${STR: -1} sed 变量使用双引号 "s/$TERM1/$TERM2/g"
处理 / 字符，替换成任意字符 s???g
去除首尾
# 删除每行第一个字符 $ sed 's/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cc8df8e88b13f1ca5d5bc66cca14926/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb96dd5e848a826415f3e9aab34f0ded/" rel="bookmark">
			windows11安装MySQL5.7.X保姆级图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面：目前为止，MySQL最新版本为8.0.29，但是我们仍然推荐使用5.7版本。
一、下载MySQL MySQL历史版本下载地址点我
二、解压MySQL到安装目录 三、配置环境变量 四、在MySQL安装目录下 新建my.ini配置文件并编辑内容。 [mysqld] # 设置3306端口 port=3306 # 设置mysql的安装目录 basedir=D:\\Software\\Programs\\mysql-5.7.35-winx64 # 设置mysql数据库的数据的存放目录 datadir=D:\\Software\\Programs\\mysql-5.7.35-winx64\\data # 允许最大连接数 max_connections=200 # 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统 max_connect_errors=10 # 服务端使用的字符集默认为UTF8 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB # 默认使用“mysql_native_password”插件认证 default_authentication_plugin=mysql_native_password [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [client] # 设置mysql客户端连接服务端时默认使用的端口 port=3306 default-character-set=utf8 # 忽略密码 skip-grant-tables 五、启动管理员模式下的cmd，并将路径切换至mysql下的bin目录，然后输入mysqld --install 注意：如果在命令行输入mysqld --install 时出现类似错误:msvcr120.dll文件丢失
下载对应的库：https://download.microsoft.com/download/F/3/5/F3500770-8A08-488E-94B6-17A1E1DD526F/vcredist_x64.exe 然后默认安装完成即可。
六、 再输入 mysqld --initialize-insecure --user=mysql; 初始化数据文件 七、net start mysql 启动mysql服务 八、用命令 mysql –u root –p 进入mysql管理界面（密码可为空，直接按回车键） 九、更改root密码 update mysql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb96dd5e848a826415f3e9aab34f0ded/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a2ab351cf613fb1260efb958fac68f4/" rel="bookmark">
			C#实现汉字转拼音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#实现汉字转拼音 由于汉字字库大，且多音字较多，因此实现的拼音转换不一定和词语中的字的正确读音完全吻合。但绝大部分是正确的。如有遗漏可以在开发中加入。首先，我将汉字按拼音分组后建立一个字符串数组，然后使用程序将每一个汉字通过其编码值使用散列函数。其中，pos(x)为字符x所属字符串所在的PyCode.codes的数组下标，然后散列到同PyCode.codes长度相同长度的一个散列表中PyHash.hashes）。 当检索一个汉字的拼音时，首先从PyHash.hashes中获取和对应的PyCode.codes中数组下标，然后从对应字符串查找，当到要查找的字符时，字符 串的前6个字符即包含了该字的拼音。 此种方法的好处一是节约了存储空间，二是兼顾了查询效率。
namespace Common { internal class PyCode { internal static string[] codes = new string[] { "a :阿啊吖嗄腌锕", "ai :爱埃碍矮挨唉哎哀皑癌蔼艾隘捱嗳嗌嫒瑷暧砹锿霭", "an :安按暗岸案俺氨胺鞍谙埯揞犴庵桉铵鹌黯", "ang :昂肮盎", "ao :凹奥敖熬翱袄傲懊澳坳拗嗷岙廒遨媪骜獒聱螯鏊鳌鏖", "ba :把八吧巴拔霸罢爸坝芭捌扒叭笆疤跋靶耙茇菝岜灞钯粑鲅魃", "bai :百白败摆柏佰拜稗捭掰", "ban :办半板班般版拌搬斑扳伴颁扮瓣绊阪坂钣瘢癍舨", "bang :帮棒邦榜梆膀绑磅蚌镑傍谤蒡浜", "bao :报保包剥薄胞暴宝饱抱爆堡苞褒雹豹鲍葆孢煲鸨褓趵龅", "bei :北被倍备背辈贝杯卑悲碑钡狈惫焙孛陂邶埤萆蓓呗悖碚鹎褙鐾鞴", "ben :本奔苯笨畚坌贲锛", "beng :泵崩绷甭蹦迸嘣甏", "bi :比必避闭辟笔壁臂毕彼逼币鼻蔽鄙碧蓖毙毖庇痹敝弊陛匕俾荜荸薜吡哔狴庳愎滗濞弼妣婢嬖璧畀铋秕裨筚箅篦舭襞跸髀", "bian :变边便编遍辩扁辨鞭贬卞辫匾弁苄忭汴缏飚煸砭碥窆褊蝙笾鳊", "biao :表标彪膘婊骠杓飑飙镖镳瘭裱鳔髟", "bie :别鳖憋瘪蹩", "bin :宾彬斌濒滨摈傧豳缤玢槟殡膑镔髌鬓", "bing :并病兵柄冰丙饼秉炳禀邴摒", "bo :波播伯拨博勃驳玻泊菠钵搏铂箔帛舶脖膊渤亳啵饽檗擘礴钹鹁簸跛踣", "bu :不部步布补捕卜哺埠簿怖卟逋瓿晡钚钸醭", "ca :擦嚓礤", "cai :采才材菜财裁彩猜睬踩蔡", "can :参残蚕灿餐惭惨孱骖璨粲黪", "cang :藏仓苍舱沧"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a2ab351cf613fb1260efb958fac68f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cadb9a5ec447c342b24671a3e29f8a4e/" rel="bookmark">
			查找缺失的DLL工具Dependency Walker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近处理64位软件在32位的编译问题，遇到了一些dll加载不到（32位程序找不到对应的32位dll）导致程序启动不起来的情况，最后借助了工具Dependency Walker把问题找出来了，这里记录一下。
Dependencywalker，网站如下：http://www.dependencywalker.com 简单介绍： Dependency Walker是一个免费的实用工具，它可以扫描任何32位或64位Windows模块（EXE，DLL，OCX，SYS等），并建立所有相关模块的分层树形图。Dependency Walker对于排除加载和执行模块故障错误非常有用。 Dependency Walker能检测出许多常见应用问题，例如缺少模块，无效的模块，导入/导出不匹配，循环依赖错误，不匹配的机器类型模块和模块初始化失败。所以对于程序员来说，Dependency Walker(以下简称Depends)是一项必备技能。
使用教程： 已经有人写了，参考：CSDN博客
补充几点： 文件加载的时候会比较慢，博主的exe文件分析了几分钟，需要耐心等待一下。
关于一些系统64位dll报错的问题
%windir%\System32 目录下的位数报错等相关信息忽略即可，因为windows使用了文件系统重定向 https://docs.microsoft.com/zh-cn/windows/win32/winprog64/file-system-redirector?redirectedfrom=MSDN ，导致这个软件对这里的文件路径会找错路径，导致这里报错找到了64位的dll。
点这里显示完整路径效果看起来更好一点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43b99bf3b91a29d8669f4a056c271d24/" rel="bookmark">
			Soc FPGA搭建工程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、将镜像烧录进入SD卡 这一部分的操作很简单，直接将镜像文件传入格式化后的SD卡中即可。烧录之后，会有两个文件夹打不开，那是因为那两个文件夹需要在Linux中打开。另外一个文件夹打开后如下。
在完成烧录后，我们运行黄金工程，将生成得到的.sof文件进行转化成为.rbf文件。将生成的.rbf文件复制进入SD卡中（替代上图的.rbf)。
之后，在上一级目录找到generate_hps_qsys_header.sh文件，在SOC Eds Command Shell中运行它。
在黄金工程的目录下找到图示文件，并取代SD卡中响应的文件
完成上面的操作后，我们就完成了对系统的烧录。
二、软件方面 在黄金工程的目录下新建一个名为app的文件夹（可自定义命名），作为我们软件的工作空间。
在SoC的 Shell中运行eclipse
选择刚刚新建的文件夹作为工作空间
写入第一个C语言文件
将黄金工程中的此文件，复制到工程中
三、修改设备IP 修改电脑以太网的IP
使用MoBa，进入系统修改sshd_config文件
进入路径如下
找到44行，完成如图的修改
修改后使用reboot命令重启后，使用ifconfig eth0 192.168.0.1命令修改设备IP
设置静态IP
使用以下命令打开interfaces文件
vi /etc/network/interfaces
修改文件内容如下：
auto eth0 iface eth0 inet static address 192.168.0.1 netmask 255.255.255.0 gateway 192.168.0.1 dns-nameserve 114.114.114.114 至此，我们完成了对设备的设置
四、修改软件 选择此项
将之前的hello_world.c文件复制到OPT目录下
右键opt 选择Launch Terminal，在控制台输入chmod 777 hello_world修改文件属性，使用语句./hello_world执行该文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb668069119320577db5462335d6b2c8/" rel="bookmark">
			Golang:go静态文件处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		go静态文件处理 一.前言 golang在没有处理静态文件前是访问不到的，必须用到net/http包下的
http.Handle(),http.StripPrefix(),http.FileServer(),http.Dir()
二.示例 http.StripPrefix 会截取输入的前缀，http.FileServer 会自动在目录里面寻找文件，配合http.Dir使用 package main import ( "fmt" "html/template" "net/http" ) // html处理器 func htmlHandle(w http.ResponseWriter, r *http.Request) { // 解析一个模版文件 // Must函数用于包装返回(*Template, error)的函数/方法调用，它会在err非nil时panic，一般用于变量初始化： // ParseFiles函数创建一个模板并解析filenames指定的文件里的模板定义。返回的模板的名字是第一个文件的文件名（不含扩展名），内容为解析后的第一个文件的内容。至少要提供一个文件。如果发生错误，会停止解析并返回nil。 t := template.Must(template.ParseFiles("index.html")) // Execute方法将解析好的模板应用到data上，并将输出写入wr。如果执行时出现错误，会停止执行，但有可能已经写入wr部分数据。模板可以安全的并发执行。 t.Execute(w, "我是被传递的一段话") } func main() { // 路由器 http.HandleFunc("/", handle) http.HandleFunc("/html", htmlHandle) // 静态文件处理器 http.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.Dir("static")))) // 开启server服务 http.ListenAndServe(":8081", nil) } &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb668069119320577db5462335d6b2c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83f4c6eea11c4d466c7c2d3b833ce7dd/" rel="bookmark">
			Golang:go获取url和表单属性值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		go获取url和表单属性值 一.前言 本章节会使用到net/http包开启web服务，获取request请求, 以下的路由器方法会集成全局的handle处理器,为了让文章简化，所以在图片的代码块中，只更新handle处理器里面的执行逻辑
package main import ( "fmt" "net/http" ) // 处理器 func handle(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, "访问的path路径是: ", r.URL.Path) } func main() { // 路由器 http.HandleFunc("/", handle) // 开启server服务 http.ListenAndServe(":8081", nil) } 二.示例 获取访问url的path路径 // 处理器 func handle(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, "访问的path路径是: ", r.URL.Path) } 获取访问url的param参数值 // 处理器 func handle(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, "访问的path路径是: ", r.URL.Path) fmt.Fprintln(w, "访问的param参数是: ", r.URL.RawQuery) } 获取访问url单个的param参数值 // 处理器 func handle(w http.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83f4c6eea11c4d466c7c2d3b833ce7dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e11501e9936a0843530b8f3409520f7/" rel="bookmark">
			Golang:go模版引擎的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		go模版引擎的使用 一.前言 import “html/template”
template包（html/template）实现了数据驱动的模板，用于生成可对抗代码注入的安全HTML输出。本包提供了和text/template包相同的接口，无论何时当输出是HTML的时候都应使用本包。
二.示例 使用html/template解析模版文件并且传递参数至模版文件golang代码块 package mian import ( "fmt" "html/template" "net/http" ) // html处理器 func htmlHandle(w http.ResponseWriter, r *http.Request) { // 解析一个模版文件 // Must函数用于包装返回(*Template, error)的函数/方法调用，它会在err非nil时panic，一般用于变量初始化： // ParseFiles函数创建一个模板并解析filenames指定的文件里的模板定义。返回的模板的名字是第一个文件的文件名（不含扩展名），内容为解析后的第一个文件的内容。至少要提供一个文件。如果发生错误，会停止解析并返回nil。 t := template.Must(template.ParseFiles("index.html")) // Execute方法将解析好的模板应用到data上，并将输出写入wr。如果执行时出现错误，会停止执行，但有可能已经写入wr部分数据。模板可以安全的并发执行。 t.Execute(w, "我是被传递的一段话") } func main() { // 路由器 http.HandleFunc("/html", htmlHandle) // 开启server服务 http.ListenAndServe(":8081", nil) } html代码块 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e11501e9936a0843530b8f3409520f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b22e0ecb039993d301a84c55044c28e2/" rel="bookmark">
			IO多路复用和Reactor模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.同步阻塞式IO - BIO2.同步非阻塞式IO - NIO2.1 Selector 选择器2.1.1 SelectionKey2.1.2 Selector注册事件类型 2.2 Channels 通道2.3 Buffer 缓冲区2.3.1 Capacity2.3.2 Position2.3.3 Limit2.3.4 Buffer缓冲区的分配 3.Reactor模型3.1 单Reactor单线程模型3.1.1 单Reactor单线程模型的优点3.1.2 单Reactor单线程模型的缺点 3.2 单Reactor多线程模型3.3 多Reactor多线程模型（主从Reactor模型） 1.同步阻塞式IO - BIO BIO就是Blocking IO的简称，Java中BIO是由ServerSocket负责绑定IO地址启动监听端口等待客户端连接。客户端的Socket类发起连接。
BIO的阻塞主要体现在：
- 服务端程序启动后，会一直等待客户端的连接，在此期间线程是阻塞的，不能干其他的事。 - 在连接建立后，在读取到socket数据之前，线程仍然是阻塞状态。 2.同步非阻塞式IO - NIO NIO是JDK1.4版本引入的，NIO弥补了BIO的种种不足，BIO是面向字节流，而NIO则是面向缓冲区。
BIO在调用read、write等方法时，线程会阻塞，直到有数据到达。NIO的非阻塞模式下，线程从某个通道读取数据，如果没有可用的数据时候就不会阻塞，可以去做其它事情。一个独立的线程管理多个输入和输出通道，这样可以将阻塞等待时间拿来在其它通道上执行IO操作。
NIO有三大核心组件：
2.1 Selector 选择器 Selector选择器又称为事件订阅器、轮询代理器，Java的NIO的Selector选择器允许一个单独的线程来监视多个通道，然后使用一个单独的线程拿来操作这个选择器。
客户端向Selector注册它所关注的某个通道Channel以及关注的哪些事件(例如连接事件、读取事件等)，当然Selector中会维护一个Channel列表。
2.1.1 SelectionKey 这个key代表channe通道在Selector上注册的唯一标识。
2.1.2 Selector注册事件类型 - `OP_READ 读事件`：当读缓冲区有数据可读时触发的事件。 - `OP_WRITE 写事件`：当写缓冲区有空间空间时触发的事件。 - `OP_CONNECT 连接事件`：#connect( ) 请求连接成功后触发的事件，给客户端使用。 - `OP_ACCEPT 连接请求事件`：#accetp( ) 当接收到一个客户端连接请求时触发的事件，给服务端使用。 2.2 Channels 通道 channel通道，是对应用程序和操作系统交互数据通道的抽象。应用程序可以通过通道读取数据也可以通过通道向操作系统写入数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b22e0ecb039993d301a84c55044c28e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4412da28ba12a0802beca7b720e27841/" rel="bookmark">
			Linux下使用FFmpeg实现采集摄像头数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FFmpeg采集摄像头数据 文章目录 FFmpeg采集摄像头数据前言一、查看Linux系统下的摄像头设备二、代码1.在main函数中，所需要用到的参数的声明2.解码摄像头原始参数设置3.输出H264文件部分4.编解码开始部分5.收尾部分6.源码7.Cmake 三、运行结果 前言 博主对音视频蛮感兴趣的，学习了一段时间的FFmpeg。前几天，在逛博客的时候发现在Linux下使用FFmpeg采集摄像头的数据，由于这采集摄像头的数据没写过代码，于是复现了下人家的代码，是一个比较简单的demo程序，仅供参考。
一、查看Linux系统下的摄像头设备 前排提示：在看此博客的之前，需要在自己的Ubuntu环境中安装FFmpeg，若没安装FFmpeg，可以在网上搜教程（网上的教程还是蛮详细的）。
在Linux系统中，使用的是v4l2框架来驱动摄像头设备的。
使用FFmpeg的ffprobe命令来查看连接到Ubuntu系统中的摄像头设备，如下图。
从图中可以看到，所使用摄像头的参数，从图中可以看出摄像头输出的原始参数是yuyv422的形式，一般我们使用的是yuv420p的数据，因此在保存摄像头数据的时候，先对yuyu422的格式进行变化，将其变换为yuv420p的格式，然后再进行编码保存为h264的文件。
二、代码 1.在main函数中，所需要用到的参数的声明 int ret = 0; // 注册所有的设备 avdevice_register_all(); // 输入设备的相关参数 AVFormatContext *inFmtCtx = avformat_alloc_context(); AVCodec *inCodec = NULL; AVCodecContext *inCodecCtx = NULL; int inVideoSteamIndex = -1; struct SwsContext *img_ctx = NULL; AVFrame *yuvFrame = NULL; AVFrame *srcFrame = NULL; AVPacket *inPkt = av_packet_alloc(); // 输出文件的相关参数 AVFormatContext *outFmtCtx = avformat_alloc_context(); AVOutputFormat *outFmt = NULL; AVStream *outStream = NULL; AVCodecContext *outCodecCtx=NULL; AVCodec *outCodec = NULL; AVPacket *outPkt = av_packet_alloc(); 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4412da28ba12a0802beca7b720e27841/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a96d51e46aeb0b91f21e2f8c16b27eb/" rel="bookmark">
			基于WEB的小型酒店管理系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5.2.1 系统登录界面 用户登录时，如果输入用户是已注册用户，则输入正确用户名和密码，正确选择该用户对应的身份，即可成功登录到相应页面。如果输入有误，界面会出现相应提示。如果输入用户不存在，则需要先注册，注册成功后即可实现登录操作[8]。
5.2.2 系统主界面 该系统共分为三个主界面，是所有功能的一个入口。根据登录时选择不同身份（管理员、工作人员、客户），跳转到不同的主界面。主界面主要是由菜单栏、功能模块按钮组成，单击各按钮可以实现不同操作[9]。
（1）客户主界面 通过登录进入客户主界面[10]。在主界面左侧有个可收缩菜单，可选择不同操作。包括个人信息、房间信息查询、我要订房三种操作。打开“个人信息”页面后，打开对应页面，会有一个“编辑”按钮，点击可以对信息进行编辑操作。打开“房间信息查询”页面后，页面上会有搜索框和“查询”按钮，可以输入房间类型对房间信息进行查询。打开“我要订房”后，会有一个“预订”按钮，单击可以进行订房操作[11]。
左侧可伸缩菜单实现代码：
$(function(){
var dataTree=[{
text:'系统管理(客户)',
state:'closed',
children:[{
text:'个人信息',
attributes:{
url:'jsp/userList.jsp'
}
},{
text:'房间信息查询',
attributes:{
url:'jsp/uroominfoList.jsp'
}
},{
text:'我要订房',
attributes:{
url:'jsp/ubookroomList.jsp'
}
}]
}];
这里使用的是jQuery EasyUI的树形菜单实现左侧菜单栏的可伸缩菜单。
（2）工作人员主界面 通过登录进入工作人员主界面。在主界面左侧有个可收缩菜单，可选择不同操作。包括客户信息查询、客房信息查询、客户订房和交房结算四种操作。打开“客户信息查询”和“客房信息查询”页面后，打开对应页面，会有一个“编辑”按钮，点击可以对信息进行编辑操作；一个“添加”按钮，点击可以对信息进行添加操作；一个“删除”按钮，点击可以对信息进行删除操作；还有一个搜索框和“查询”按钮，可以输入用户姓名对用户信息进行查询。打开“客户订房”页面，会有一个“预订”按钮，单击可以进行订房操作。打开“交房结算”页面。
（3）管理员主界面 通过登录进入到管理员主界面。在主界面左侧有个可收缩菜单，可选择不同操作。包括用户信息维护、房间信息维护、房间类型维护、房间状态维护和客房经营管理五种操作。打开“用户信息维护”页面后，打开对应页面，会有一个“编辑”按钮，点击可以对信息进行编辑操作；一个“添加”按钮，点击可以对信息进行添加操作；一个“删除”按钮，点击可以对信息进行删除操作；还有一个搜索框和“查询”按钮，可以输入用户姓名对用户信息进行查询。打开“房间信息维护”、“房间类型维护”、“房间状态维护”页面会出现和“用户信息维护”页面相同的按钮，功能也相同。打开“客房经营管理”页面[12]。
传送门：https://download.csdn.net/download/qq_31151511/86242649
指导联系：首页-软件世家-淘宝网
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3adfc583a38292804ef52aadbad0c1ca/" rel="bookmark">
			带权重的交叉熵-CrossEntropyLoss，class_weight
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：例如2分类中，类别极度不均衡，ok样本10万张，ng样本3张，就算模型把所有的样本都预测成ok样本，也能达到99.997%的状态，但是可能实际情况是宁可过杀也不放过。对ng样本添加惩罚项可以缓解这个问题：如果标签为ng，预测成了ng，把这个损失拉满。
Demo：用mmcls框架，求带权重的交叉熵。 import mmcls.models import torch #输入和标签 inputs = torch.FloatTensor([0,1,0,0,0,1]) outputs = torch.LongTensor([0,1]) inputs = inputs.view((1,3,2)) outputs = outputs.view((1,2)) # 定义两种交叉熵，前面为正常交叉熵，后面为带权重的交叉熵 CE = mmcls.models.losses.CrossEntropyLoss() CE2 = mmcls.models.losses.CrossEntropyLoss(class_weight=[1,10,100]) loss1 = CE(inputs,outputs) #tensor(1.4803) loss2 = CE2(inputs,outputs) #tensor(9.8593) Demo2：手动求交叉熵和带权重的交叉熵
# step1:先求softmax，axis=1 inputs2 = inputs.softmax(inputs,1) print(inputs2) ''' tensor([[[0.3333, 0.4223], [0.3333, 0.1554], [0.3333, 0.4223]]]) ''' # step2:再求log inputs3 = inputs2.log() print(inputs3) ''' tensor([[[-1.0986, -0.8620], [-1.0986, -1.8620], [-1.0986, -0.8620]]]) ''' # 上述过程等价于： inputs3 = inputs.log_softmax(1) # step3：再根据标签，求损失。 ''' inputs3的shape为（1，3，2），1是批次大小，3是总共包含的类别，2是最终需要计算的交叉熵的向量长度。 除去批次后，inputs3的shape为（3，2）。标签为0，1。表示从第0列需要找第0个元素， 表示从第1列需要找第1个元素.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3adfc583a38292804ef52aadbad0c1ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3413ea25ba12c31908239eda1a69b4a3/" rel="bookmark">
			ubuntu下openssh升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ubuntu下openssh升级 安装依赖
sudo apt update 更新库 sudo apt install zlib1g libpam0g-dev libssl-dev 二、升级ssl，见本博客 https://blog.csdn.net/qq_42430287/article/details/125539316
三、升级openssh 备份原文件 mv /etc/init.d/ssh /etc/init.d/ssh.old cp -r /etc/ssh /etc/ssh.old # 卸载原openssh apt-get remove openssh-server openssh-client tar xf openssh-9.0p1.tar.gz cd openssh-9.0p1 ./configure --prefix=/usr --sysconfdir=/etc/ssh --with-md5-passwords --with-pam --with-zlib --with-ssl-dir=/usr/local/ssl --with-privsep-path=/var/lib/sshd make make install 查看版本 ssh -V 四、升级完成，更换配置文件 1. 修改默认配置文件 根据之前配置修改,保证配置相同
2. 也可使用原来的配置文件 cd /etc/ssh
mv sshd_config sshd_config.default
cp …/ssh.old/sshd_config ./
3.使用原来的/etc/init.d/ssh mv /etc/init.d/ssh.old /etc/init.d/ssh
4.取消注销指定服务 systemctl unmask ssh
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3413ea25ba12c31908239eda1a69b4a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7b34023295a642b2f35236fc587bea1/" rel="bookmark">
			C/C&#43;&#43; 三种方式获得文件的大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做项目时经常需要获得文件的大小操作，虽然在网络上已经有许多篇博客介绍了，但是还是想总结出自己一篇，记录一下自己在项目中是怎么获得文件大小的！
方式一 推荐使用此方式获得文件大小！
C/C++、Window、Linux 环境都可以使用！
通过结构体struct stat获得。
需要包含头文件：#include &lt;sys/stat.h&gt; // struct stat
// 通过stat结构体 获得文件大小，单位字节 size_t getFileSize1(const char *fileName) { if (fileName == NULL) { return 0; } // 这是一个存储文件(夹)信息的结构体，其中有文件大小和创建时间、访问时间、修改时间等 struct stat statbuf; // 提供文件名字符串，获得文件属性结构体 stat(fileName, &amp;statbuf); // 获取文件大小 size_t filesize = statbuf.st_size; return filesize; } 首先也是通过stat函数获得文件的基本属性，然后再从结构体中直接进行获取文件大小就行，很简单，也很好用。
直接拷贝代码到自己的项目中去就可以用了！
方式二 C语言方式获得文件大小
不推荐使用此方式
当文件太大时，移动文件光标指针会非常耗时！
// 通过打开文件 获得文件大小，单位字节 long long getFileSize2(const char *fileName) { /* 解释这里为什么用_fseeki64而不用fseek： _fseeki64可以兼容x64项目和x86项目 fseek只能兼容x86项目 这里说的兼容并不是能不能用的问题，而是准不准确的问题！ 在x64项目使用fseek，返回的数据可能会不准确！ */ if (fileName == NULL) { return -1; } FILE *fp = NULL; long long fileSize = 0; // 打开文件 errno_t err = fopen_s(&amp;fp, fileName, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7b34023295a642b2f35236fc587bea1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf6761dc22745f9787e2afbbb583d4e5/" rel="bookmark">
			js-export-excel插件的使用以及封装导出表格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装 npm i js-export-excel
2.使用 以下方法可使用与vue2、vue3、react
①react17中使用 import React from 'react' import CinemasGetlistAction from '../redux/action/CinemasGetlistAction' import ExportJsonExcel from 'js-export-excel'; import {connect} from 'react-redux' function Cinemas(props) { const data = [ { key: '1', name: '张三', isCompeleted: true, scored: 80, compeleteDate: '2022-12-12 08:00:00' }, { key: '2', name: '李四', isCompeleted: true, scored: 90, compeleteDate: '2022-12-12 08:00:00' }, { key: '3', name: '王五', isCompeleted: true, scored: 100, compeleteDate: '2022-12-12 08:00:00' }, { key: '4', name: '小明', isCompeleted: true, scored: 70, compeleteDate: '2022-12-12 08:00:00' }, { key: '5', name: '小红', isCompeleted: false, scored: 80, compeleteDate: '2022-12-12 08:00:00' }, { key: '6', name: '小李', isCompeleted: true, scored: 50, compeleteDate: '2022-12-12 08:00:00' }, { key: '7', name: '小张', isCompeleted: false, scored: 80, compeleteDate: '2022-12-12 08:00:00' }, ]; const downloadExcel = () =&gt; { //导出table数据 const data_ = data ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf6761dc22745f9787e2afbbb583d4e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f2efdb2abfc02eaa2dd4177d92398f7/" rel="bookmark">
			VINS-初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Initialization 陀螺仪偏置初始化速度、重力向量和尺度重力refine 实验一实验二实验三 Initialization 本文的方法是，将imu的信息，与视觉的对齐，完成初始化
陀螺仪偏置初始化 这里的变量只有陀螺仪的偏置。见实验一中， 将bias通过自己的方法求出来。同时在公式11中，当把这个近似公式求出来的时候，就不用反复求积分了，而是求出来一次，然后下一次迭代就是根据这个更新来了。
公式14其实就是说的这个意思。
速度、重力向量和尺度 为什么要估计速度和重力向量？
预积分中速度的增量，是以bk为基准的，这里这里首先将其转换到c0坐标系下. R c 0 b k β ^ b k + 1 b k R^{b_k}_{c_0} \hat{\beta}^{b_k}_{b_{k+1}} Rc0​bk​​β^​bk+1​bk​​ --&gt; c0坐标系下速度的增量.
c0坐标系下k+1时刻的速度， 加上重力加速度*时间，减去k时刻的速度。这个公式是从公式3来的。具体可以参考：https://blog.csdn.net/qq_41839222/article/details/89106128
见实验2；
重力refine 重力的大小是一个强约束，但是直接在前面加的话，就变成了一个非线性问题，不好解，这里将其norm作为一个额外的约束项加入进去。
根据实验3的结果，的确是不好收敛，主要是因为是一个norm的约束。符合vins论文中说的“it will become nonlinear and hard to solve.”
这里需要c0坐标系下的重力转换到惯性系下。且让相机的的yaw超前。
实验一 将陀螺仪的偏置设置为{0.1， 0.5， 1.0}，采用vins初始化的结果为：
这里尝试将这一部分改为优化:
ceres自动求导算出来的陀螺仪偏置与自动求导算出来的一样。
这里可以发现一个问题，当bg是变量估计的时候，这个预积分需要重复进行计算。论文中线性化部分的代码对加速是比较关键的。
比如这个地方迭代三次，那就需要把这个窗口内的预积分重新计算三遍。假设本窗口有1s，那么有200次的imu数据，那么就是600次计算。
实验二 将尺度的估计自己实现一遍；
TestInitScaleNode中实现。
与原文中略有差异，差别不太多。
可以看出，在相机坐标系下，重力是朝y方向向下的。再根据重力垂直朝下的特点，就可以求得惯性系下的相机初始pose。
实验三 当把grav的norm限定之后，发现的确不能很好的收敛了。
定位了若干个小时，这个问题的原因定位出来了，
template&lt;typename T&gt; bool operator()(const T* const grav, T* residuals) const { } 上面这个函数必须返回true，否则的话就会报evaluate 雅克比失败。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f2efdb2abfc02eaa2dd4177d92398f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7d75a2c42d5789af17de49ce9f749a4/" rel="bookmark">
			pycharm使用git进行部分分支合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需求：将分支A上的部分提交合并到分支B(git cherry-pick) 1. 在pycharm中将代码切换到分支B 2.然后在log中切换到分支A的提交记录 3. 右击需要合并的提交记录，选择cherry-pick，即可将当前的提交合并到分支B 4. 如果有多个需合并的提交记录，则多次重复步骤3即可 或者可参考:git cherry-pick常用命令详解 - lalalady - 博客园
5. 最后如果遇到冲突，编辑文件解决冲突即可，然后push 6. 如果在push之前需要撤销合并，则在命令行直接 git reset即可 7.如果push后需要撤销合并，则在刚刚cherry-Pick的地方，筛选出分支B的提交记录，然后对相应的提交记录进行Revert commit 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a35e3afee18366972252d8ae9f6f1b6/" rel="bookmark">
			IP第十天笔记 - - - BGP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BGP --- 边界网关协议
AS --- 自治系统 --- 由单一机构或组织管理的一系列IP网络及其设备的集合。
1、网络范围太大，协议跑不过来，需要进行划分；
2、自治管理
为了方便区分和标定不同的AS，我们给每一个自治系统设计了一个编号 --- AS号 --- 16位二进制构成 --- 0 - 65535；其中0和65535为保留值-不用；所以，AS号真正的取值范围为1 - 65534；我们将64512 - 65534AS号称为私有AS号。 --- 因为传统的AS号存在不够用的问题，所以目前也存在拓展版的AS号 --- 32位构成 --- 目前绝大多数设备已经支持拓展版的AS号。
EGP协议在之前还存在一款协议 --- EGP，但是由于其功能有限，后来在其基础上进行优化和改进，生成了现在的BGP协议。目前AS之间使用最广泛的协议就是BGP协议。
在目前IPV4环境下，使用最广泛发BGP版本是BGPV4。目前市场上已经存在BGPV4+。BGPV4+又可以称为MP --- BGP --- 可以支持多种地址族的应用。
在没有BGP协议的情况下，仅使用重发布技术，也可以实现AS之间的路由信息共享。但是，之所以不采用这种方案，其原因如下：
1、重发布技术本身存在缺陷 --- 在多点重发布中，因为种子度量值问题，必然造成选路不佳
2、ASBR设备的归属问题
BGP之间传递路由信息的方式一定是和RIP类似，通过传递路由条目信息来实现。 --- 之所以不使用拓扑信息，主要因为 ： 1、拓扑信息资源占用量太大，而BGP需要传递的数量是巨大的。2、传递拓扑信息将暴漏本AS内部的拓扑连接情况。
BGP --- 无类别的路径矢量型协议
距离矢量 --- 在距离矢量型协议中，距离是开销的体现，将跳数作为开销值的评判标准。将一个路由器看作是一个单位计算距离。
距离矢量是算法的概念，因为IGP协议本身需要通过算法来计算出未知网段的路由信息。
路径矢量 --- 是将一个AS看作一个整体
路径矢量不牵扯算法，因为BGP仅仅是将IGP计算出来的路由信息发送到其他AS之中，相当于仅将现成的路由进行传递而不需要计算。
IGP --- 选路佳，收敛快，占用资源少
BGP协议的关注点 ：
1、可控性 --- AS之间需要传递大量的路由信息，所谓可控，就是可以更方便的干涉选路，更容易做路由策略。
为了保证可控性，BGP舍弃了开销值。取而代之的是BGP给每条路由信息附加了很多路径属性。之后，可以通过这些属性来进行选路。因为多种属性的存在，将导致我们的选路变的更加的灵活和方便。使得BGP协议具有强大的可操控性。
因为BGP协议需要传递大量的路由信息，所以，其本身不可能存在周期更新机制。BGP仅存在触发更新。
2、可靠性 --- 保证数据传输的可靠。BGP为了保证传输的可靠性，其传输层协议直接选择使用TCP协议。使用TCP的179号端口进行工作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a35e3afee18366972252d8ae9f6f1b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e4e853d8520b63bd0ea67c43f24c90c/" rel="bookmark">
			MATLAB求解线性方程组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 求解条件 线性方程组
所用函数 求解函数过程中，设立两个矩阵。
1.系数矩阵
2.常数矩阵
3.MATLAB中利用 \ 来求解该方程，即(系数矩阵)\(常数矩阵)
求解范例 A=[1/2 1/3 1/4;1/3 1/4 1/5;1/4 1/5 1/6];%系数矩阵 B=[0.95;0.67;0.52];%常数矩阵 A\B C=[0.95;0.67;0.53];%矩阵稍微变动一点，结果就迥然不同。 A\C 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf6e4e79e8538196f8c2670fa93e7201/" rel="bookmark">
			P1084 [NOIP2012 提高组] 疫情控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 HH 国有 nn个城市，这 nn 个城市用n-1n−1条双向道路相互连通构成一棵树，11号城市是首都，也是树中的根节点。
HH国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。
现在，在 HH 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。
请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。
输入格式 第一行一个整数nn，表示城市个数。
接下来的 n-1n−1 行，每行33个整数，u,v,wu,v,w，每两个整数之间用一个空格隔开，表示从城市 uu到城市vv 有一条长为 ww 的道路。数据保证输入的是一棵树，且根节点编号为 11。
接下来一行一个整数 mm，表示军队个数。
接下来一行 mm个整数，每两个整数之间用一个空格隔开，分别表示这 mm 个军队所驻扎的城市的编号。
输出格式 一个整数，表示控制疫情所需要的最少时间。如果无法控制疫情则输出-1−1。
输入输出样例 输入 ： 输出 ：
4 3 1 2 1 1 3 2 3 4 3 2 2 2 说明/提示 【输入输出样例说明】
第一支军队在 22 号点设立检查点，第二支军队从 22 号点移动到33 号点设立检查点，所需时间为 33 个小时。
【数据范围】
保证军队不会驻扎在首都。
对于 20%的数据，2≤ n≤ 102≤n≤10；
对于 40%的数据，2 ≤n≤50,0&lt;w &lt;10^52≤n≤50,0&lt;w&lt;105；
对于 60%的数据，2 ≤ n≤1000,0&lt;w &lt;10^62≤n≤1000,0&lt;w&lt;106；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf6e4e79e8538196f8c2670fa93e7201/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf9aed514e7f8fcdbfad557d0435f48e/" rel="bookmark">
			深度学习Deep Learning学习笔记——网络设计技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源视频：https://www.bilibili.com/video/BV11K4y1S7AD?p=5
学习笔记总结
1 当损失函数随着参数更新而没有下降或者误差仍然很大，一般表示一阶偏微分梯度向量等于0。
此时判断方法：
二阶偏微分矩阵H来判断此时是否处于saddle pint；
在原有参数上加上对应的H矩阵负特征值对应的特征向量，从而逃离saddle point 继续寻找降低损失函数值。（计算量较大）
低维下找不到路径优化的损失函数放到高维空间也许很容易找到下降路径。
2 batch size 一次选取纳入训练的样本数，每读取一次batch size 计算一次梯度来更新参数，再读取下一个batch样本接着计算梯度更新参数，依次迭代。
一个epoch 是读取完一次所有batch。
有无并行运算决定了单次运行batch size的计算速度，通常来说 越小batch size训练出来的模型效果越好，但计算时间越长，而越大的batch size则计算速度更快。
3 趋势项 类似惯性概念，在传统梯度下降方法中加入趋势项，从而赋予梯度下降法逃逸saddle point 局部最优解的能力。
每一次更新权重时加入上一次参数变化move向量，梯度向量和move向量两者合成出新的参数更新向量。
4 自适应学习率 平方根法则或RMSprop来根据计算的梯度大小来自适应调整学习率，结合预先制定的学习率变化策略和趋势变化项 ，从而更好完成梯度下降（Adagrad方法则是实现不同参数应用不同学习率）
5 批标准化 对网络输入层和隐藏层输出做归一化处理，让训练速度更快收敛
6 回归转化为多分类 利用softmax激活函数将回归值应用到多分类问题，一般会默认使用交叉熵作为损失函数来更新参数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83c9b7ad70944816507ef606434b2f80/" rel="bookmark">
			SpringBoot：Thymeleaf 字符串连接、运算符、内置对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：
（1）字符串连接
（2）运算符
（3）Thymeleaf基本对象-内置对象使用
（4）内置对象#request、#session的方法
（5） 一些内置对象事例
（1）字符串连接
控制器：ThemeleafController：
package com.bjpowernode.controller; import com.bjpowernode.model.SysUser; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; @Controller @RequestMapping("/tpl") //放在类上方的这个注解会和@GetMapping一起组成完整的访问路径 public class ThymeleafController { //字符串连接 @GetMapping("/strjoin") public String strjoin(Model model){ model.addAttribute("sex","m"); model.addAttribute("age",20); model.addAttribute("name","张三"); model.addAttribute("city","北京"); model.addAttribute("isLogin",true); model.addAttribute("myuser",new SysUser(1005,"周峰","男",23)); return "strjoin"; } } index.html:
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;index.html--学习Thymeleaf语法&lt;/h3&gt; &lt;a href="tpl/expression1"&gt;标准变量表达式&lt;/a&gt; &lt;br&gt; &lt;a href="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83c9b7ad70944816507ef606434b2f80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f152b670c62729b95076cf3c801ef3c1/" rel="bookmark">
			【AutoSAR】 CP 和 AP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 AutoSAR,全称为Automotive Open System Architecture(汽车开放系统架构)。是由全球各家汽车制造商、零部件供应商以及各种研究、服务机构共同参与的一种汽车电子系统的合作开发框架，并建立了一个开放的汽车控制器(ECU)标准软件架构。
AutoSAR建立的背景是汽车的电子控制系统一直在高速的发展，面临的挑战也越来越多，主要体现以下几个方面：
汽车的电气化电子化程度提高，控制器数量增加，网络复杂度增加。软件功能数量急剧增加硬件平台多样化，软件可复用差软件开发周期缩短且成本占比增加 AUTOSAR当前有两个平台CP（经典平台）和AP（自适应平台）
Classsic AutoSAR Classic AutoSAR标准在最高抽象级别上将运行在控制器上的软件分为三层：Application,runtime environment(RTE)和Basic software（BSW）。
Application Layer,不依赖于硬件的软件模块间通过RTE交互，并通过RTE访问BSWRTE体现了application的所有接口BSW分为3大层和复杂驱动：服务层、ECU抽象层、MCU抽象层服务层又细分为不同的服务组件，比如系统服务、存储服务、通信服务等 CP软件架构图：
Classic AutoSAR主要特点：
基于C语言面向过程开发FOA架构(function-oriented architecture)基于信号的静态配置通信方式(LIN\CAN…通信矩阵)硬件资源的连接关系局限于线束的连接静态的服务模块，模块和配置在发布前进行静态编译、链接大部分代码静态运行在ROM，所有application共用地址空间OSEK OSCP用于硬实时的MCU平台 Adaptive AutoSAR AP标准定义了ARA运行环境。分为两种接口类型：service和APIs。平台由根据服务(Platform Service)和AP基础分组的多个功能栈组成。
每个功能栈：
聚合了自适应平台功能定义了功能栈需求规范从应用程序和网络角度描述软件平台的行为但不限制最终在自使用平台中具体的软件架构设计 AP软件架构图：
AP的主要特点:
基于C++面向对象开发SOA架构(Service-oriented architecture)基于服务的SOA动态通信方式(SOME/IP)硬件资源间的连接关系虚拟化，不局限于通信线束的连接关系(互联网)服务可根据应用需求动态加载，可通过配置文件动态加载配置，并可进行单独更新application 加载到RAM运行，每个application独享（虚拟）一个地址空间POSIX-basedOS,兼容性广，可移植性高AP用于高算力的MPU平台 Adaptive AutoSAR核心组件 AutoSAR的核心组件，也称功能集群，简称FC： Communication Middleware：通信中间件
Execution manager:执行管理
IAM: 权限管控
Diagnostic Manager：诊断
Network Manager：网络管理
Update Manager：升级
Log Manager：Log管理
Health Manager：健康状态监控
核心组件功能描述：
Execution Manager：执行管理，执行不同状态之间的转移
搜寻指定路径下所有可用的Executables并加入进程列表中，启动阶段按进程依赖顺序加载所有配置在默认功能组的进程当发生功能组状态切换时，终止未定义在新功能组的进程，并按照进程加载依赖顺序重新加载新功能组的所有进程。当功能组内的状态发生迁移时，驱动所有被加载的进程往相应的状态迁移。 State Manager：状态管理，处理时间，事件/请求优先级等以设置对应的内部状态的功能
请求将功能组设置为某一状态请求激活/关闭(部分)网络执行项目特定的操作 IAM：为应用访问及控制AutoSAR资源提供身份鉴权
用户需事先PolicyDescision Point(Grant或Deny的Policy)策略IAM把应用Application的身份鉴权请求，对接到用户的Policy策略，并给出鉴权结果回给Application Platform Health Manager：管理被监控运行实体的健康状态
监测及判断运行实体的运行状态当检测到异常状态时，按照定义执行RecoveryAction管理各个被监控简称报告的健康状况，并生成PHM的监控及状态切换结果给到用户Application,以便用户执行最终如Watchdog等自定义的决策 Log Manager：提供Log前台打印API及后台Log存储服务
可提供CONSOLE/FILE/DLT/SYSLOG等工作模式可配置多级别Verbose/Debug/Info/Warn/Error/Fatal的打印控制 Communication Manager：提供SOME IP Protocol的通信功能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f152b670c62729b95076cf3c801ef3c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fa7897e33aa1e98d3a447bacb64aa58/" rel="bookmark">
			[详解C语言]一文带你认识C语言,让你醍醐灌顶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 初识C语言前言1.什么是C语言2.简单的C语言程序3.C语言中有哪些数据类型4.变量4.1 如何定义变量4.2 如何给变量命名4.3变量的分类4.4 变量的使用4.5变量的作用域和生命周期 5.常量6.字符串+转义字符+注释6.1字符串6.2转义字符6.3注释 7.选择语句8.循环语句9.函数10.数组10.1数组的定义10.2数组的下标以及使用 11.操作符12.常见关键字13.指针13.1内存13.2指针的使用 14.结构体总结 初识C语言 前言 本文仅对C语言中部分知识进行简单介绍使读者可以后续看懂别人的代码后边对大纲中的内容都会详解 1.什么是C语言 为什么会有语言呢，大家有么有想过？
其实，语言的出现是为了交流，我们学英语是为了和外国人交流
那我们和计算机用什么交流呢?
有一部分帅气的小伙伴就要说了，用键盘和鼠标，手写笔…
其实，人类和计算机的交流采用的是计算机语言，如机器语言，汇编语言
C语言是一门通用计算机编程语言，广泛应用于底层开发。C语言的设计目标是提供一种能以简易的方式编译、处理低级存储器、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言C语言是一门面向过程的计算机编程语言，与C++，Java等面向对象的编程语言有所不同 2.简单的C语言程序 #include &lt;stdio.h&gt; //引入头文件，以便于使用库函数 //函数返回值类型 函数名(参数列表) int main(){ printf("hello world"); //使用printf打印其中的字符串 return 0;//返回值 } 这就是最简单的一个C语言函数了，看结果
main函数是程序的唯一入口，有且只有一个main函数哦
3.C语言中有哪些数据类型 让我们来看看C语言中的数据类型
char //字符数据类型 short //短整型 int //整形 long //长整型 long long //更长的整形 float //单精度浮点数 double //双精度浮点数 ..... C语言中的各种数据类型是为了匹配生活中的各种数据，比如整数小数，字母…
那为什么会有这么多整型呢？
因为数据是存储在内存中的，各种数据类型分配的空间不一样，各种整型所占空间不一样，所以，为了更好的利用内存，选择对应范围的数据类型尤为重要
那各种类型分配都多少空间呢?
先来给大家介绍一下计算机概念中的单位
1byte = 8 bit
1kb = 1024 byte
1mb = 1024 kb
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fa7897e33aa1e98d3a447bacb64aa58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ea33b478f579b5c722a00b94df1e7bc/" rel="bookmark">
			矩阵的行列式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		行列式的定义 行列式在数学中，是一个函数，其定义域为det的矩阵A，取值为一个标量，写作det(A)或 | A |
行列式与矩阵的区别 定义上面： 行列式是一个数，而矩阵是一个数组
表达上面： 行列式：IAI
矩阵：[A]
运算上面： 乘法：行列式被乘只能乘以一行或者一列，而矩阵乘以一个数，每个元素都被乘。
等于：行列数等于另外一个行列式只要他们的值相同就行了，而矩阵则要每一个元素都相同。
减法：行列式的减法是数值的加减，而矩阵的减法是矩阵的每个元素都减去。
行列式A中两行（或列）互换,其结果等于-A。 把行列式A的某行（或列）中各元同乘一数后加到另一行（或列）中各对应元上，结果仍然是A
行列式的值 二阶行列式的值计算如下：
n阶矩阵的行列式等于其任意行（或列）的元素与对应的代数余子式乘积之和，即：
代数余子式：在一个n阶行列式中，把元素aij(i，j=1，2，.....n)所在的行与列划去后，剩下的(n-1)^2个元素按照原来的次序组成的一个n-1阶行列式Mij称为元素aij的代数余子式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b625ff5d066fdc12f3d3e1d8a94b387/" rel="bookmark">
			STM32 热敏电阻测量温度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、硬件
STM32F103C8T6、热敏电阻传感器、OLED。
二、热敏电阻传感器的介绍
一个DO输出口，输出数字量，根据外界的温度是否超过传感器的阈值，输出0或1；一个AO口，输出模拟量。温度的检测要通过模拟量转换而来。
三、代码实现
要使得单片机读到的模拟量转换成温度需要经过以下步骤：1、读取的数值转电压；2、电压转电阻、3、根据公式计算实际的温度。
1、ADC读取。ADC怎么读取可以看之前的读取光敏电阻的文章，过程类似，就是引脚不一样。代码如下。
//初始化ADC //这里我们仅以规则通道为例 //我们默认将开启通道0~3 void temp_Adc_Init(void) { ADC_InitTypeDef ADC_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA |RCC_APB2Periph_ADC1, ENABLE ); //使能ADC1通道时钟 RCC_ADCCLKConfig(RCC_PCLK2_Div6); //设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M //PA1 作为模拟通道输入引脚 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; //模拟输入引脚 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); ADC_DeInit(ADC1); //复位ADC1,将外设 ADC1 的全部寄存器重设为缺省值 ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; //ADC工作模式:ADC1和ADC2工作在独立模式 ADC_InitStructure.ADC_ScanConvMode = DISABLE; //模数转换工作在单通道模式 ADC_InitStructure.ADC_ContinuousConvMode = DISABLE; //模数转换工作在单次转换模式 ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; //转换由软件而不是外部触发启动 ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; //ADC数据右对齐 ADC_InitStructure.ADC_NbrOfChannel = 6; //顺序进行规则转换的ADC通道的数目 ADC_Init(ADC1, &amp;ADC_InitStructure); //根据ADC_InitStruct中指定的参数初始化外设ADCx的寄存器 ADC_Cmd(ADC1, ENABLE); //使能指定的ADC1 ADC_ResetCalibration(ADC1); //使能复位校准 while(ADC_GetResetCalibrationStatus(ADC1)); //等待复位校准结束 ADC_StartCalibration(ADC1); //开启AD校准 while(ADC_GetCalibrationStatus(ADC1)); //等待校准结束 ADC_SoftwareStartConvCmd(ADC1, ENABLE); //使能指定的ADC1的软件转换启动功能 } //获得ADC值 //ch:通道值 0~3 u16 temp_Get_Adc(u8 ch) { //设置指定ADC的规则组通道，一个序列，采样时间 ADC_RegularChannelConfig(ADC1, ch, 1, ADC_SampleTime_239Cycles5 ); //ADC1,ADC通道,采样时间为239.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b625ff5d066fdc12f3d3e1d8a94b387/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1163a2c492d81547b96b01d2d15db8c3/" rel="bookmark">
			Vue3 解构赋值失去响应式引发的思考！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		image.png 前言 vue3发布以来经历两年风头正盛，现在大有和react 平分天下的势头，我们知道他是基于proxy 实现响应式的能力， 解决了vue2所遗留下来的一些问题，同时也正由于proxy的特性，也提高了运行时的性能
凡事有利有弊， proxy虽然无敌，但是他也有本身的局限，从而产生一些我认为的弊端（其实就是不符合js语言的自然书写方式，有的人觉得就是个特殊写法，他不属于弊端）
1、 原始值的响应式系统的实现 导致必须将他包装为一个对象， 通过 .value 的方式访问
2、 ES6 解构，不能随意使用。会破坏他的响应式特性
好奇心驱使，研究琢磨了一下，为什么他会造成这两个弊端
原始值的响应式系统的实现 在理解原始值的响应式系统的实现，我们先来温习一下proxy 的能力！
const obj = { name: 'win' } const handler = { get: function(target, key){ console.log('get--', key) return Reflect.get(...arguments) }, set: function(target, key, value){ console.log('set--', key, '=', value) return Reflect.set(...arguments) } } const data = new Proxy(obj, handler) data.name = 'ten' console.log(data.name,'data.name22') 复制代码 上述代码中，我们发现，proxy 的使用本身就是对于 对象的拦截， 通过new Proxy 的返回值，拦截了obj 对象
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1163a2c492d81547b96b01d2d15db8c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f0aec01829c9b079ab9d34fd792926d/" rel="bookmark">
			TCP网络应用程序开发流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、TCP 网络应用程序开发流程的介绍
1、TCP客户端程序开发流程的介绍
2、TCP服务端程序开发流程的介绍
二、TCP客户端程序开发
三、TCP服务端程序开发
四、TCP网络应用程序的注意
五、socket之send和recv原理
1、认识TCP socket的发送和接收缓冲区
2、send原理剖析
3、recv原理剖析
一、TCP 网络应用程序开发流程的介绍 TCP网络应用程序开发分为：
TCP客户端程序开发
TCP服务端程序开发
说明：客户端程序是指运行在用户设备上的程序　服务端程序是运行在服务器设备上的程序，专门为客户端提供数据服务
1、TCP客户端程序开发流程的介绍 步骤说明：
１.创建客户端套接字对象
２.和服务端套接字建立连接
３.发生数据
４.接收数据
５.关闭客户端套接字
2、TCP服务端程序开发流程的介绍 步骤说明：　１.创建服务端套接字对象　２.绑定端口号　３.设置监听
４.等待接受客户端的连接请求
５.接收数据
６.发送数据
７.关闭套接字
二、TCP客户端程序开发 步骤说明：
１.创建客户端套接字对象
２.和服务端套接字建立连接
３.发生数据
４.接收数据
５.关闭客户端套接字
开发代码：
import socket if __name__ == '__main__': # 创建tcp客户端套接字 # AF_INET：ipv4地址类型 # SOCK_STREAM：tcp传输协议类型 tcp_client_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM) # 和服务端套接字建立连接 tcp_client_socket.connect(("192.168.68.160",8080)) send_content = "hello" # 对字符串进程编码成二进制数据 send_data = send_content.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f0aec01829c9b079ab9d34fd792926d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ee018f2e67026ca28479d3db2dc5a43/" rel="bookmark">
			罗德里格斯（Rodrigues）旋转公式推导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：原文链接
1 罗德里格斯（Rodrigues）旋转公式简介 对于三维空间向量 v v v的旋转问题，给定罗德里格斯旋转向量 q q q（由旋转轴 n n n和旋转角度 θ \theta θ构成），那么，用罗德里格斯（Rodrigues）旋转公式就可以得出旋转后的向量 v ′ v' v′，如下：
v ′ = v + ( 1 − c o s θ ) ∗ N 2 ⋅ v + s i n θ ∗ N ⋅ v v'=v+(1-cos\theta)*N^{2} \cdot v+sin\theta*N\cdot v v′=v+(1−cosθ)∗N2⋅v+sinθ∗N⋅v （1） 或 v ′ = c o s θ ∗ v + ( 1 − c o s θ ) ∗ n ⋅ n T ⋅ v + s i n θ ∗ n ∧ ⋅ v v'=cos\theta*v+(1-cos\theta)*n\cdot n^{T}\cdot v+sin\theta*n^{\wedge}\cdot v v′=cosθ∗v+(1−cosθ)∗n⋅nT⋅v+sinθ∗n∧⋅v （2） 式中： v = [ v x v y v z ] v= \begin{bmatrix} v_{x} \\ v_{y} \\ v_{z} \\ \end{bmatrix} v=⎣ ⎡​vx​vy​vz​​⎦ ⎤​， v ′ = [ v x ′ v y ′ v z ′ ] v'= \begin{bmatrix} v'_{x} \\ v'_{y} \\ v'_{z} \\ \end{bmatrix} v′=⎣ ⎡​vx′​vy′​vz′​​⎦ ⎤​， n = [ n x n y n z ] n= \begin{bmatrix} n_{x} \\ n_{y} \\ n_{z} \\ \end{bmatrix} n=⎣ ⎡​nx​ny​nz​​⎦ ⎤​， n ∧ = N = [ 0 − n z n y n z 0 − n x − n y n x 0 ] n^{\wedge}=N= \begin{bmatrix} 0 &amp;-n_{z} &amp;n_{y} \\ n_{z} &amp;0 &amp;-n_{x}\\ -n_{y} &amp;n_{x} &amp;0\\ \end{bmatrix} n∧=N=⎣ ⎡​0nz​−ny​​−nz​0nx​​ny​−nx​0​⎦ ⎤​ （3） n ∧ n^{\wedge} n∧和 N N N表示向量 n n n的反对称矩阵形式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ee018f2e67026ca28479d3db2dc5a43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ba217c341f4f255a3ef1457e010c820/" rel="bookmark">
			osgearth学习笔记2：星空效果显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在三维地球场景中显示星空背景，需要增加一下代码即可
if (!m_earthNode) return nullptr; //查询地图节点 osgEarth::MapNode* mapNode = osgEarth::MapNode::findMapNode(m_earthNode); if (!mapNode) return nullptr; // 设置时间 osgEarth::DateTime dateTime(2022, 7, 17, 20);	//格林尼治时间 osgEarth::Util::Ephemeris* ephemeris = new osgEarth::Util::Ephemeris; osgEarth::Util::SkyNode* m_pSkyNode = osgEarth::Util::SkyNode::create(mapNode); m_pSkyNode-&gt;setName("SkyNode"); m_pSkyNode-&gt;setEphemeris(ephemeris); m_pSkyNode-&gt;setDateTime(dateTime); m_pSkyNode-&gt;attach(m_viewer, 0); m_pSkyNode-&gt;setLighting(true); m_pSkyNode-&gt;addChild(mapNode); m_root-&gt;addChild(m_pSkyNode); 发现skyNode创建时有一个参数，通过他可以控制夜间部分黑暗的程度，修改如下：
if (!m_earthNode) return nullptr; //查询地图节点 osgEarth::MapNode* mapNode = osgEarth::MapNode::findMapNode(m_earthNode); if (!mapNode) return nullptr; // 设置时间 osgEarth::DateTime dateTime(2022, 7, 17, 20);	//格林尼治时间 osgEarth::Util::SkyOptions skyOptions; skyOptions.ambient() = 0.4;//控制黑夜部分明暗程度，数值越小，越黑暗 osgEarth::Util::Ephemeris* ephemeris = new osgEarth::Util::Ephemeris; osgEarth::Util::SkyNode* m_pSkyNode = osgEarth::Util::SkyNode::create(skyOptions, mapNode); m_pSkyNode-&gt;setName("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ba217c341f4f255a3ef1457e010c820/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f471025b81d1850ed516f8456e63e121/" rel="bookmark">
			Redis三种启动方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis三种启动方式 1. 直接启动 进入redis根目录，执行命令：
./redis-server 2. 通过指定配置文件启动 可以为redis服务启动指定配置文件；如配置为/etc/redis/redis.conf
进入redis 根目录，输入命令：
./redis-server /etc/redis/redis.conf 如果更改了端口，使用“redis-cli”客户端连接时，也需要指定端口 例如：
./redis-cli -p 6378 3. 使用redis启动脚本设置开机启动 启动脚本redis_init_script位于 /redis安装目录/util/下。redis_init_script代码如下
#!/bin/sh # # Simple Redis init.d script conceived to work on Linux systems # as it does use of the /proc filesystem. ### BEGIN INIT INFO # Provides: redis_6379 # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: Redis data structure server # Description: Redis data structure server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f471025b81d1850ed516f8456e63e121/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9abec08a73c66cf486043a9c87e6242e/" rel="bookmark">
			C#获取到毫秒时间戳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#的System命名空间中，就包含了时间相关的类了，只要使用就可以罕见的的获取到时间戳。代码如下：
using System; private string GetTimeStamp() { return DateTime.Now.ToString("yyy-MM-dd HH.mm.ss.fff");	} 参考原文链接：https://blog.csdn.net/jiuba5/article/details/53884272
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/289d744460c46d00fcb2317d380eda90/" rel="bookmark">
			栈 Stack（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 栈（Stack）·概念·栈的使用·栈的应用场景 栈（Stack） ·概念 一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端成为栈顶，另一端称为栈底。栈中的元素遵守后进先出的原则。
压栈：栈的插入操作叫做压栈/进栈/入栈。
出栈：栈的删除操作叫做出栈。
·栈的使用 方法功能Stack()构造一个空的栈E push(E e)将e入栈，并返回eE pop()将栈顶元素出栈并返回E peek()获取栈顶元素int size()获取栈中有效元素的个数boolean empty()检测栈是否为空 栈的简单运用：
public static void main(String[]args){ Strack&lt;Integer&gt;s=new Stack(); s.push(1); s.push(2); s.push(3); s.push(4); //在栈中放入元素 System.out.println(s.size()); //获取栈的有效元素个数 4 System.out.println(s.peek()); //获取栈顶元素 4 s.pop(): //将栈顶元素出栈 出4剩下1、2、3 System.out.println(s.pop()); //3出栈 剩下1、2 if(s.empty()){ System.out.println("栈空"); }else{ System.out.println(s.size()); } } ·栈的应用场景 1. 改变元素序列
元素在进栈的过程中也可以出栈；元素依次入栈以及依次出栈都会改变元素序列。
2. 将递归转化为循环
// 递归方式 void printList(Node head){ if(null != head){ printList(head.next); System.out.print(head.val + " "); } } // 循环方式 void printList(Node head){ if(null == head){ return; } Stack&lt;Node&gt; s = new Stack&lt;&gt;(); // 将链表中的结点保存在栈中 Node cur = head; while(null !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/289d744460c46d00fcb2317d380eda90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7106df4a749d84d6c7179503aac59684/" rel="bookmark">
			初识Grad-CAM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于论文：Grad-CAM: Visual Explanations from Deep Networks via Gradient-based Localization
论文下载地址：https://arxiv.org/abs/1610.02391
Pytorch代码下载地址：https://github.com/jacobgil/pytorch-grad-cam
目录
Pytorch-Grad-CAM原理介绍
使用Grad-CAM绘制热力图
Pytorch-Grad-CAM原理介绍 以图像分类为例：
Activations:正向传播
Gradients:反向传播
A：从原图像中提取的特征层越往后抽象程度越高，语义信息越丰富，故在图像分类任务中我们取特征层的最后一层，即Features[-1]
在经过两个全连接层后得到损失，经过backpropagation后得到的彩色表示层表示的是A中相应层对图像的重要程度，对矩阵均值后加权求和然后经过ReLU激活函数激活，显色后得到热力图。
更多理论介绍可参见这篇blog，讲的很详细：https://blog.csdn.net/qq_37541097/article/details/123089851
使用Grad-CAM绘制热力图 从本文开头论文下载地址下载代码，我们来看main文件：
import os import numpy as np import torch from PIL import Image import matplotlib.pyplot as plt from torchvision import models from torchvision import transforms from utils import GradCAM, show_cam_on_image, center_crop_img def main(): model = models.mobilenet_v3_large(pretrained=True) target_layers = [model.features[-1]] #层结构列表 # model = models.vgg16(pretrained=True) # target_layers = [model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7106df4a749d84d6c7179503aac59684/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dac60bd9fcbef4455663edd12147da17/" rel="bookmark">
			pyspark基础学习——环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、配置版本二、windows下安装pyspark2.1 jdk安装2.2 spark安装2.3 Hadoop安装2.4 检测代码2.5 运行环境 总结 一、配置版本 Java JDK 1.8.0_111
Python 3.9.0
Spark 3.2.1
Hadoop 3.2.3
二、windows下安装pyspark python在代码的编辑上具有简单易懂的效果，而spark在处理大数据的功能在行业内已经得到了广泛的应用，如今我们可以通过python语句来实现spark 的相关功能，但是要想在python中使用pyspark并不是单纯的导入pyspark包就可以实现的。我们需要根据不同的环境搭建spark、Hadoop环境，才可以在python中使用pyspark。
在安装之间，若对数据处理的速度或者是数据量不是非常大的情况下，建议下载到非系统盘的位置，同时在命名的时候，尽量选用英文，避免后续可能因为中文而出现的问题。
2.1 jdk安装 下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
下载jdk8版本需要先进行注册
下载安装完后打开Windows中的环境变量
（1. 设置+系统+关于+高级系统设置+环境变量；2. win+r 输入cmd，在终端中输入sysdm.cpl，选择高级，再打开环境变量）：
创建JAVA_HOME：D:\Java\jdk1.8.0_111(此处为安装时jdk的下载位置)
创建CLASSPATH：.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar
在Path添加：%JAVA_HOME%\bin;
测试是否安装成功：打开cmd命令行，输入java -version
2.2 spark安装 下载地址：https://spark.apache.org/downloads.html
环境变量：
创建SPARK_HOME：D:\spark\spark-3.2.1-bin-hadoop3.2(根据自己安装的位置)
Path添加：%SPARK_HOME%\bin
2.3 Hadoop安装 下载地址：链接：https://dlcdn.apache.org/hadoop/common/
环境变量：
创建HADOOP_HOME：D:\hadoop\hadoop-3.2.3(根据自己安装的位置)
Path添加：%HADOOP_HOME%\bin
在安装Hadoop的时候要注意跟spark版本相互对应
测试是否安装成功：打开cmd命令行，输入pyspark
表示安装成功。
在运行代码之前，需要导入pyspark的包
pip install pysaprk 2.4 检测代码 import findspark findspark.init() from datetime import datetime, date from pyspark.sql import SparkSession spark = SparkSession.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dac60bd9fcbef4455663edd12147da17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b7d2c1625cbb3d0bfd208f38792f2fa/" rel="bookmark">
			Windows 下安装 RabbitMQ 服务器及基本配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 安装 Erlang安装 RabbitMQ设置 RabbitMQ 环境变量管理 rabbitmq_management 的用户测试总结 RabbitMQ 是一个在 AMQP 协议标准基础上完整的，可复用的企业消息系统。它遵循 Mozilla Public License 开源协议，采用 Erlang 实现的工业级的消息队列(MQ)服务器，Rabbit MQ 是建立在 Erlang OTP 平台上。 安装 RabbitMQ 服务器必须首先安装 Erlang 运行环境。
安装 Erlang 安装 Erlang 时要注意安装的 RabbityMQ 所依赖的 Erlang 版本，根据 RabbitMQ 的要求选择一个版本，这里我要安装的 RabbitMQ 的版本是 3.7.7 ，他依赖的Erlang版本范围是19.3.6.4 到 21.0.x，因此我选择版本是OTP 20.3. Erlang下载地址：https://www.erlang.org/downloads。下载Erlang安装包后直接安装就可以了。
设置 ERLANG_HOME 环境变量
注意：如果之前安装了 Erlang的其他版本，需要卸载后在进行重新安装和设置。
在开始菜单查找 Erlang，点击启动 打开如下界面，那么 Erlang 就安装成功了。接下来就安装 RabbitMQ。
安装 RabbitMQ 可以在 RabbitMQ 的官方网站下载最新版本的 RabbitMQ 服务器安装程序，RabbitMQ 下载地址：https://www.rabbitmq.com/install-windows.html 然后点击默认安装。
RabbitMQ 安装好后是作为 windows service 运行在后台。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b7d2c1625cbb3d0bfd208f38792f2fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d73f77d7b9e312727c52afc621eac5e6/" rel="bookmark">
			Android性能优化之APK瘦身详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 结构分析 首先上传一张瘦身前通过Analyze app分析出来的图片（打开方式：Android Studio下 ——&gt; Build——&gt; Analyze app）：
APK包结构如下：
lib/：包含特定于处理器软件层的编译代码。该目录包含了每种平台的子目录，像armeabi，armeabi-v7a， arm64-v8a，x86，x86_64，和mips。大多数情况下我们可以只用一种armeabi-v7a，后面会讲到原因。assets/：包含应用可以使用AssetManager对象检索的应用资源。res/：包含未编译到的资源 resources.arsc,主要有图片资源文件。META-INF/：包含CERT.SF和 CERT.RSA签名文件以及MANIFEST.MF 清单文件。resources.arsc：包含已编译的资源。该文件包含res/values/ 文件夹所有配置中的XML内容。打包工具提取此XML内容，将其编译为二进制格式，并将内容归档。此内容包括语言字符串和样式，以及直接包含在resources.arsc文件中的内容路径 ，例如布局文件和图像。classes.dex：包含以Dalvik / ART虚拟机可理解的DEX文件格式编译的类。AndroidManifest.xml：包含核心Android清单文件。该文件列出应用程序的名称，版本，访问权限和引用的库文件。该文件使用Android的二进制XML格式。 通过分析图可以知道，目前app主要是so文件占比比较大，占了31.7M,占了整个应用是38.2%。其次是assets目录，整个目录占了32M,第三就是资源文件res目录了。所以接下来我们处理步骤就是按这个顺序来处理。（简单说下图中的Raw File Size（磁盘解压后的大小）和DownLoad Size（从应用商店下载的大小），如果想了解更多关于Analyaer分析的知识，可以参考这篇文章使用APK Analyzer分析你的APK)，分析了包结构组成之后，我们可以开始瘦身操作了。
2.具体实操 1. 对lib目录下的文件进行瘦身处理 1. 修改lib配置：
参考资料 so文件的优化：通常我们在使用NDK开发的时候，我们经常会有如下这么一段代码:
ndk { //设置支持的so库架构 abiFilters "armeabi-v7a", "x86", "arm64-v8a", "x86_64", "armeabi" } 复制代码 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xNDtH3zt-1571353784450)(upload-images.jianshu.io/upload_imag…)]
最后我的修改代码如下：
ndk { //设置支持的so库架构 abiFilters "armeabi-v7a" } 复制代码 接下来说明这么做的依据： 看上面图分析，armeabi-v7主要不支持ARMv5(1998年诞生)和ARMv6(2001年诞生).目前这两款处理器的手机设备基本不在我公司的适配范围（市场占比太少）。 而许多基于 x86 的设备也可运行 armeabi-v7a 和 armeabi NDK 二进制文件。对于这些设备，主要 ABI 将是 x86，辅助 ABI 是 armeabi-v7a。 最后总结一点：如果适配版本高于4.1版本，可以直接像我上面这样写，当然，如果armeabi-v7a不是设备主要ABI，那么会在性能上造成一定的影响。 参考文章：安卓app打包的时候还需要兼容armeabi么？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d73f77d7b9e312727c52afc621eac5e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8cd7dc5dd7e88c4c50ed68469d36989/" rel="bookmark">
			Linux命令&#43;shell脚本大全：shell 的父子关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用于登录某个虚拟控制器终端或在GUI中运行终端仿真器时所启动的默认的交互shell，是一
个父shell。本书到目前为止都是父shell提供CLI提示符，然后等待命令输入。
在CLI提示符后输入 /bin/bash 命令或其他等效的 bash 命令时，会创建一个新的shell程序。
这个shell程序被称为子shell（child shell）。子shell也拥有CLI提示符，同样会等待命令输入。
当输入 bash 、生成子shell的时候，你是看不到任何相关的信息的，因此需要另一条命令帮助
我们理清这一切。第4章中讲过的 ps 命令能够派上用场，在生成子shell的前后配合选项 -f 来使用。
$ ps -f
UID PID PPID C STIME TTY TIME CMD
501 1841 1840 0 11:50 pts/0 00:00:00 -bash
501 2429 1841 4 13:44 pts/0 00:00:00 ps -f
$
$ bash
$
$ ps -f
UID PID PPID C STIME TTY TIME CMD
501 1841 1840 0 11:50 pts/0 00:00:00 -bash
501 2430 1841 0 13:44 pts/0 00:00:00 bash
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8cd7dc5dd7e88c4c50ed68469d36989/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/251/">«</a>
	<span class="pagination__item pagination__item--current">252/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/253/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>