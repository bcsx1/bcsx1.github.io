<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/308c4d437be8d637277e372965efc71f/" rel="bookmark">
			pycharm  安装basemap库失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有些库不用安装 anaconda里面就有，有些库需要用pip安装一下，有些库则需要下载whl文件进行安装
详细步骤https://zhuanlan.zhihu.com/p/34509847，亲测有效
pycharm重启一下，会自动引入刚刚用conda引入的那个库
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17592da48db00b28234004fe6a91079f/" rel="bookmark">
			VScode设置语言为中文，并且解决中文注释乱码问题。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode官网下载地址：https://code.visualstudio.com/
插件官网地址：https://marketplace.visualstudio.com/
1.设置语言为中文 在前端开发中，Visual Studio Code(简称vscode)是一个非常好用的工具，但第一次打开vscode会发现界面为英文，这对很多开发者来说会很不友好（比如我），把界面设置成中文只需要安装一个插件即可，下面是步骤。
1.打开vscode,界面如下：
2.安装插件的方法：
方法1：直接点击这里
方法2：按快捷键Ctrl+Shift+P,在出现的框里输入extensions,然后回车。
方法3：按快捷键Ctrl+P,在框内输入：ext install，然后回车。
完成方法一或方法二或方法三 中的其中一种都会来到下面这个界面：
3.在搜索框输入Chinese (Simplified) Language Pack for Visual Studio Code（基本上输入Chinese就出来了），然后点击install进行下载（可以根据自己选择中文简体和中文繁体）。
下载完之后如下图。
4.最后一步只需要把软件叉掉重新打开即可看到界面由英文变成了中文界面。
2.解决中文注释乱码问题 第一次用vscode打开代码会出现中文注释因识别不了而乱码的情况，类似这样：
解决它只需要按照下面步骤设置一下就可以了。
1.单击软件左下角设置（类似齿轮）的按钮
2.单击之后会出现这样的菜单栏，单击设置。
3.在出现的搜索框里输入：Files.autoGuessEncoding，按回车键确定。
4.把这个选项勾上即可。
5.返回到刚刚所查看的程序界面，发现乱码消失，中文注释可以正常显示。
完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6f4203b8567a0e2a922fa1c78a03ffb/" rel="bookmark">
			深度学习Object Detection目标检测之《YOLOv3原理详细剖析》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一，综述Object Detection概述作者简介Pytorch Implementation 代码实现 二，从输入到输出 Forward PassInput&amp;Output 网络的输入与输出是什么如何理解网络的三组输出三组输出如何转化为预测结果 三，从输出到输入 Back PropagationLoss Function 损失函数预测坐标x，y，w，h的设计 四，YOLOv3 Network Structure 网络结构Darknet53 五，Yolov3 Paper 论文拾遗六，后记 一，综述 2020年新年，新型冠状病毒肆虐，SARS的阴霾再次笼罩神州大地。在家自我隔离，正好写点东西，继续之前的几篇文章，这次写点目标检测的内容。
Object Detection概述 现在是2020年初，直到2018年以前，最具代表性的经典目标检测网络就是RCNN系列，YOLO系列，SSD系列。RCNN，YOLO，SSD这几篇经典论文奠定了使用神经网络进行目标检测的开创性工作基础。YOLO属于One Stage的经典Detection网络之一，YOLO v3算是最新的改进版本（YOLO nano？！）；Faster RCNN乃Two Stage的Detection网络，RPN网络的创造性设计给后续很多工作提供了思路。
个人比较喜欢YOLO，速度快，检测效果不错，网络结构清晰，非常适合工程上使用。本文之目的在于剖析目标检测网络之YOLOv3，目标是从作者的Paper，Darknet网络结构，Pytorch的实现，网络训练调参等目标检测网络的方方面面来彻底剖析和理解此网络的所有，如果有时间的话。。。
作者简介 Joseph Redmon
I am a graduate student advised by Ali Farhadi. I work on computer vision.
I maintain the Darknet Neural Network Framework, a primer on tactics in Coq, occasionally work on research, and try to stay off twitter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6f4203b8567a0e2a922fa1c78a03ffb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f81d7466155c9bcc1b7c972e119f608/" rel="bookmark">
			Docker容器ElasticSearch-Head创建索引无响应406
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ElasticSearch-Head创建索引无响应,F12查看发现406错误,
修改head的 Content-Type 设置.
docker exex -it 容器id /bin/bash root@b93fa4e29ba2:/usr/src/app# vim _site/vendor.js 1. 6886行 /contentType: "application/x-www-form-urlencoded 改成 contentType: "application/json;charset=UTF-8" 2. 7574行 var inspectData = s.contentType ==`= "application/x-www-form-urlencoded" &amp;&amp;` 改成 var inspectData = s.contentType === "application/json;charset=UTF-8" &amp;&amp; root@b93fa4e29ba2:/usr/src/app/_site# exit exit [root@localhost ~]# docker restart 容器id 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4c3cf1769f25f5b9444568a896973dd/" rel="bookmark">
			【工具使用】Vmware安装使用（问题汇总）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前安装过VMware Workstation Pro，后来由于机器内存空间紧张，就把CentOS-7-x86_64-DVD-1611.iso移除了，今天又用到了虚拟机，相当于重新安装了一次，出现各种问题。
1、已将该虚拟机配置为使用 64 位客户机操作系统。但是，无法执行 64 位操作。此主机支持 Intel VT-x，但 Intel VT-x 处于禁用状态........
此方法在网上百度都可以解决，基本上都是电脑的虚拟化技术功能Virtualization Technology没有打开
操作，重启机器，联想笔记本按fn+f2进入bios系统，找到Configure找到Virtualization Technology，按enter切到Enable，完成退出。（很多网上的都可以实现）
上面这个解决了，继续进行打开虚拟机，出现下面问题
2、VMware Workstation与Device/Credential Guard不兼容。
由于是win10的家庭版，是无法根据网上的说win+R后输入gpedit.msc，会提示Windows找不到文件‘gpedit.msc’
只需要在桌面上打开一个记事本，另存为xx.cmd，用管理员权限执行即可，代码内容如下（保留空行）：
@echo off pushd "%~dp0" dir /b %systemroot%\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;gp.txt dir /b %systemroot%\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;gp.txt for /f %%i in ('findstr /i . gp.txt 2^&gt;nul') do dism /online /norestart /add-package:"%systemroot%\servicing\Packages\%%i" pause 运行完之后，可能会出现无限执行，不用管，直接再次运行win+R，输入gpedit.msc就会打开，其实win10家庭版根本不管这一步，只是遇到这样的问题解决了一下而已，跟具体VMware没有关系
重点是：
1、打开控制面板，找到程序和功能，点击启用或关闭Windows功能
2、打开注册表，win+R，输入regedit打开注册表，按顺序找到DeviceGuard，如下：
计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\DeviceGuard
在右边右击新建一个key：RequireMicrosoftSignedBootChain，值为1默认，核对下为下图即可
3、win+R，输入cmd，按ctrl+shift+enter用管理员身份打开，输入下面命令完成重启；
bcdedit /set hypervisorlaunchtype off 3、继续打开虚拟机可以正常安装并进入系统，但是选择用户后虚拟机黑屏了，关闭虚拟机出现虚拟机繁忙的提示！
出现了不管任务管理器还是强制关闭都不管用，只能重启了。
首先：根据上面的方法打开管理员身份运行命令行，输入netsh winsock reset；
其次：win+R然后输入msconfig
按下图找到VMware Authorization Service，将其关闭后重新开启，这是个动作，虽然没有改变，但是要做，会提示重启即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4c3cf1769f25f5b9444568a896973dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38b682114a4daa8736b7cf41e7834ade/" rel="bookmark">
			自研海外PCDN系统技术架构与演进
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Photo by Nick Wehrli from Pexels
本文来自小溪流科技首席架构师张道远在LiveVideoStackCon 2019深圳站上的演讲，演讲内容主要涉及PCDN海外复杂环境中如何提高穿透率和分享率的同时，保证弱网的用户体验和内容版权的保护中采用的技术，架构演进及实际落地效果展示。
文 / 张道远
整理 / LiveVideoStack
大家好，我是来自深圳市小溪流科技有限公司的系统架构师张道远，主要负责公司PCDN的系统架构设计。我们公司主要是做方案集成商，包括CDN和PCDN这块，一直耕耘于海外。
今天我带来的主要内容是自研PCDN系统技术架构与演进。演讲主要从四个方面进行分享。如何提高穿透率和分享率，在海外弱网环境下的实践，另外就是安全体系建设的一些方面。
1. PCDN提高穿透率
1.1 NAT的分类
提到穿透率，避免不了提到NAT。快速给大家讲一下NAT的分类。
（1）完全锥形
完全锥形的特性是只要知道网关上映射的端口和IP，在任何一个地方都可以通过内网IP访问。
（2）限制锥形
限制锥形的映射方式与完全锥形相似，但在安全性上有所不同。它拒绝“不请自来”的IP访问。
（3）端口限制锥形
它的映射方式和限制锥形一样，但它对IP和端口都做了访问限制。如图，对于同一个IP，通过另外的端口访问时接收不到数据的。同一个端口，没有主动发出请求的IP也是收不到数据包的。
（4）对称型
不同的请求、目的、地址有不同的映射。同时它与限制锥形NAT映射相似，但它拒绝主动请求的IP及端口的访问。如上图，对S1、S2发出请求，S1虽然知道出口IP，但是主动发出请求并不会被接收。
实际中NAT类型还有很多种，例如公网IP、UDP Block等。
1.2 全球家庭级别网关NAT类型分布
我们对国外各类型网关NAT类型做了初步研究。上图是我们搜集的数据。我们发现端口限型和对称型分别占比75%和16%，两者占比非常高达91%，这意味着打通它们两者之间是我们面临的主要难题，也是提高穿透率的关键所在。
1.3 穿透率提高的关键
由于端口限制类型会拒绝接收主动请求的端口和IP的访问数据，对称型对新的访问数据会发起新的映射方式，所以正常情况下两者之间无法打洞。
对称型和对称型之间的都使用新的映射关系，而且对称型会拒绝主动请求的IP和端口访问，所以正常情况下，两者之间打洞是不成功的。我们用了以下方法成功打洞。
1.4 如何提高对称型的穿透率？
（1）生日算法
生日算法来源于生日悖论，应用到打洞场景上主要使用数据集有64511个端口(1024以下的端口不用)。据我们实验，假如设定对撞碰出端口的成功率是70%尝试的次数大概是三百到四百次。
（2）UPNP
UPNP是即插即用的通用缩写，主要用于智能设备的相互发现和通讯。我们在打洞时主要使用它将内网IP直接映射到出口IP当作公网服务模式使用。
（3）中继模式。
例如我有A、B、C三个节点，A和B之间可以打通，B和C之间可以打通，但是A和C之间由于NAT映射关系无法打通。当A和C通讯时可以将B作为中继点。中继节点具有服务器和客户端的特性，我们在选取中继节点时，最好选取带宽优质、能用内网或者UPNP模式开启的节点。
（4）MDNS
MDNS是多播协议。没有传统DNS的情况下，用于内部节点的相互发现和通讯。在打洞过程中可不通过服务器使内网节点相互发现通讯。它使用UDP端口协议，组播特性端口为5353。
1.5 全球UPNP开启NAT分布情况
我们搜集分析数据验证了这些方法的有效性。我们对全球UPNP开启NAT分布情况总结发现，端口映射型数据会增高，对称型基本不变，其它类型也基本不变。将样本总结分析发现，端口限制型的数据下降了，对称型增加了。我们关键要看的是第四个图。我们发现有46%的节点可直接以公共服务的方式提供P2P分享，保守估计P2P之间组网穿透率可达90%以上。我个人觉得穿透率的提高并不会直接带动分享率的提高。
2. PCDN提高分享率
接下来我会给大家介绍P2P节点组网模型、调度策略、跨区域或国际策略以及一些落地案例。
2.1 P2P组网模型
P2P常见组网模型有以下几种：
（1）树形组网
树形组网以顶层节点获取资源，常见的就是一分二、二分四这种模式，节点带宽够的话也可以一分多。但是我们可以很明显的看到它的缺点。随着树形高度增加，底层的累计延时会越来越大，如果父节点离线会导致子节点处于孤儿状态。同时，最底层的节点是一个完全消费者模型，无法进行数据分享。
（2）网状组网
网状模型中每个节点都是被动请求，只要节点的数据量级客观，数据肯定可以从周围节点请求得到。但是如果用于低延时，高可变的情况（比如直播），此模型就不是很合适。同时，此模型中消息互动是高频率互动的状态。
（3）分布式星际组网
分布式星级组网是去中心化，它的优势是每个节点状态容易同步一致，上线下线对网络影响状态小。但是它的缺点是消息冗余和消息延时，不适用于直播场景。这个模型稍作改动可作为点播类、文件分享比较合适；
2.2 调度策略
按照不同的国家，我们会按照区域调度，调度原则就是同城同网。对于跨区域调度，我们遵循同网划分，以节点间RTT值越小等级越高来区分。跨国调度以距离、RTT带宽为条件区分。混合调度结合了以上三种调度方式。
上图是我们自己的P2P组网模型。我们采用了树形组网，但是我们规避优化了传统树形模型的缺点。为防止延时过高，我们在调度时会严格控制树形高度。为弥补父节点掉线造成孤儿状态的不足，我们使系统中每个节点都首先从CDN拉流。如果出现父节点掉线的情况，它立即向服务器补片，同时触发新的组网。对于纯粹的消费者模型，我们目前有两种方案，其中一种是节点可以做中继服务。第二种方式我们目前还在规划，我们希望将树形组网与网状组网融合。这种方案目前还没有落地。
我们会在每个区域形成一张区域层级图，用mdns方式将同一内网用户串联起来，通过打洞调度将同区域同ISP节点组网，这样形成了ISP多根树模型。需要跨国际节点通过RTT等级区分并结合国际时差提供调度服务。通过这种方式，实现了不同国家，不同区域的层级拓扑图。
3. 全球弱网环境实践
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38b682114a4daa8736b7cf41e7834ade/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b3bdbb41e92aa56707992732998f990/" rel="bookmark">
			最新解决Toolbar toolbar = (Toolbar)findViewById(R.id.toolbar); setSupportActionBar(toolbar);报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据这个Toolbar来看，默认导入的类为：
import android.widget.Toolbar; 记得以前改为java import android.support.v7.widget.Toolbar;就可以了，但是现在这种方案已经行不通了
最新解决方案如下：
在Activity中引入的是：
import androidx.appcompat.widget.Toolbar; activity_main.xml如下： 在activity_main.xml中也不使用
&lt;android.support.v7.widget.Toolbar&gt; 而是使用： &lt;androidx.appcompat.widget.Toolbar
&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;androidx.appcompat.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" android:popupTheme = "@style/Theme.AppCompat.Light" /&gt; &lt;/FrameLayout&gt; MainActivity package com.example.materialtest; import android.os.Build; import android.os.Bundle; //import android.widget.Toolbar; import androidx.appcompat.app.AppCompatActivity; import androidx.appcompat.widget.Toolbar; import androidx.appcompat.app.AppCompatActivity; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar)findViewById(R.id.toolbar); setSupportActionBar(toolbar); } } values-&gt;styles.xml &lt;resources&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b3bdbb41e92aa56707992732998f990/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dcd6286196527ac068907acb3cc0663/" rel="bookmark">
			Unity UI架构设计理念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity UI架构设计理念 https://www.jianshu.com/p/e64347dff4fe
Unity UI架构设计理念 1.以ARPG为例，多个场景会反复出现相同的“UI窗体”，造成多个场景中反复加载相同的UI窗体。
解决方案：
“UI框架” 需要缓存项目（例游戏项目）中常用的“UI窗体"。
2.开发商业复杂项目时，各个UI(UI脚本)之间传值，容易出现“紧耦合”(相互交错,你中有我，我中有你)的情况。
解决方案：
各个UI的生成、销毁、切换，都是通过框架(Manger)实现，各个UI之间不直接联系（传值）。
3.卡牌、RPG等游戏类型项目，很多情况下会出现“UI窗体” 叠加现象。开发人员需要“手工”维护窗体中间的层级关系。
解决方案：
设计UI框架系统，使用“栈”的数据结构，保存与控制当前所有需要显示的“UI窗体”的层级关系。
4.商业开发项目中的多个“UI窗体” 之间叠加出现时，必须保持“模态窗口”类型，否则容易出现误操作。
解决方案 设计的框架本身，需要对当前显示的窗体做“遮挡处理”，即：不允许用户绕过当前
“UI窗体”直接操作底层窗体，或者误操作点击项目中的3D游戏对象等
5.从以上问题还可以推导出如下“UI框架”需要注意的设计问题：
UI框架，需要管理加载“窗体预设”，进行自动加载的管理
UI框架，需要支持不同的语言环境，即语言的国际化。
最后设计UI框架一个总的核心原则是： 尽量让框架本身完成与具体业务无关的事务性工作，让开发人员只需要专注游戏业务逻辑的开发即可。（这个原则同样适用于其他框架的设计中）
首先开发最简版本功能设计：
1：窗体自动加载管理。
2：缓存UI窗体。
3：窗体生命周期管理。
UI框架的核心类设计
1： BaseUIForms 基础UI窗体（父类）
2： UIManger.cs UI窗体管理器
3： UIType 窗体类型
4： SysDefine 系统定义类
在Unity5.5安装目录下，建立脚本模版。
建立必要的目录结构与核心类，导入素材。
BaseUIForms.cs
UIManager.cs
UIType.cs
SysDefine.cs [Config目录下]
导入UI贴图素材。
导入一些简单的UI素材即可。
建立框架中的三个重要枚举类型,定义 UIType 类。
UIFormsType UI窗体（位置）类型
UIFormsShowMode UI窗体显示类型
UIFormsLucencyType 窗体透明度类型
[提示： SysDefine 中定义]
定义“基础UI窗体” BaseUIForms
定义 “UI管理器” UIManager
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dcd6286196527ac068907acb3cc0663/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/316d2f70967e442439e6f30abe37c627/" rel="bookmark">
			Docker简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档 https://docs.docker.com/get-started 什么是 Docker Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 [2013 年 3 月以 Apache 2.0 授权协议开源][docker-soft]，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。
Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目已经超过 4 万 6 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。
Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为 容器 。最初实现是基于 LXC，从 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/316d2f70967e442439e6f30abe37c627/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58976b052112367d3e4e0849931e7da7/" rel="bookmark">
			代码管理平台gitlab
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.gitlab介绍 GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务。
gitlab官网：https://about.gitlab.com/
gitlab有免费和付费的，但是我们自己搭建的gitlab也是有全部的功能的。
gitlab和github的区别：
gitlab和github的主要区别在于gitlab可以部署到自己的服务器上，比较适合而github是不可以的，而且GitLab个人注册用户也可免费创建私有仓库，而github是不可以的，简单来说可把GitLab看作个人版的GitHub。
有关github的介绍和使用可以看我之前写的：https://blog.csdn.net/qq_37369726/article/details/103181539
二.gitlab安装 官方安装文档:
https://about.gitlab.com/install/
要求服务器内存不少于2G
首先我们可以先搭建一个gitlab的yum源，这样下载的时候不会太慢。官方的有可能要一个多小时。
#添加gitlab的yum源 vim /etc/yum.repos.d/gitlab.repo #添加下面的内容 [gitlab-ce] name=Gitlab CE Repository baseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el$releasever/ gpgcheck=0 enabled=1 安装：
yum makecache //重新生成缓存 yum install -y gitlab-ce //ce表示社区版 加载配置文件：
gitlab-ctl reconfigure //会自动的完成，会帮你把有关gitlab的服务启动起来 gitlalb安装是很简单，就是因为太简单，导致有什么问题维护起来有一定难度。一定要做好数据的备份，包括创建的用户、仓库和添加用户的一些key等等。
gitlab启动/重启/停止/状态：
gitlab-ctl start/restart/stop/status 然后查看有没有什么防火墙规则，加一条http放行或者80端口：
iptables -A INPUT -p tcp --dport 80 -j ACCEPT 检查内存和系统负载，负载很高的话说明配置太低了，有可能打不开网页或者很卡：
free -h w 打开网页，输入ip进入。
打开网页第一件事就是要求改密码：
三.使用gitlab gitlab常用命令：
#其中一项就是查看各个相关进程的日志。gitlab包含redis，postgresql等 gitlab-ctl tail redis gitlab-ctl tail postgresql gitlab-ctl tail gitlab-workhorse gitlab-ctl tail logrotate gitlab-ctl tail nginx gitlab-ctl tail sidekiq gitlab-ctl tail unicorn 更改gitlab端口和域名：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58976b052112367d3e4e0849931e7da7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d2df99056fcf1c09481e35198bd5630/" rel="bookmark">
			PAT甲级 1005 Spell It Right（C语言）测试点4通不过
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目： Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English.
Input Specification:
Each input file contains one test case. Each case occupies one line which contains an N (≤10​100​​).
Output Specification:
For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d2df99056fcf1c09481e35198bd5630/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/007d563ff0fe93cf0554740ba7cd65ec/" rel="bookmark">
			延迟着色法-G缓冲(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 简介
G缓冲(G-buffer)是对所有用来储存光照相关的数据，并在最后的光照处理阶段中使用的所有纹理的总称。趁此机会，让我们顺便复习一下在正向渲染中照亮一个片段所需要的所有数据：
• 一个3D位置向量来计算(插值)片段位置变量供lightDir和viewDir使用
• 一个RGB漫反射颜色向量，也就是反照率(Albedo)
• 一个3D法向量来判断平面的斜率
• 一个镜面强度(Specular Intensity)浮点值
• 所有光源的位置和颜色向量
• 玩家或者观察者的位置向量
有了这些(逐片段)变量的处置权，我们就能够计算我们很熟悉的(布林-)冯氏光照(Blinn-Phong Lighting)了。光源的位置，颜色，和玩家的观察位置可以通过uniform变量来设置，但是其它变量对于每个对象的片段都是不同的。如果我们能以某种方式传输完全相同的数据到最终的延迟光照处理阶段中，我们就能计算与之前相同的光照效果了，尽管我们只是在渲染一个2D方形的片段。
二、 G缓冲
OpenGL并没有限制我们能在纹理中能存储的东西，所以现在你应该清楚在一个或多个屏幕大小的纹理中储存所有逐片段数据并在之后光照处理阶段中使用的可行性了。因为G缓冲纹理将会和光照处理阶段中的2D方形一样大，我们会获得和正向渲染设置完全一样的片段数据，但在光照处理阶段这里是一对一映射。
整个过程在伪代码中会是这样的：
while(…) // 游戏循环
{
// 1. 几何处理阶段：渲染所有的几何/颜色数据到G缓冲
glBindFramebuffer(GL_FRAMEBUFFER, gBuffer);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
gBufferShader.Use();
for(Object obj : Objects)
{
ConfigureShaderTransformsAndUniforms();
obj.Draw();
}
// 2. 光照处理阶段：使用G缓冲计算场景的光照
glBindFramebuffer(GL_FRAMEBUFFER, 0);
glClear(GL_COLOR_BUFFER_BIT);
lightingPassShader.Use();
BindAllGBufferTextures();
SetLightingUniforms();
RenderQuad();
}
对于每一个片段我们需要储存的数据有：一个位置向量、一个法向量，一个颜色向量，一个镜面强度值。所以我们在几何处理阶段中需要渲染场景中所有的对象并储存这些数据分量到G缓冲中。我们可以再次使用多渲染目标(Multiple Render Targets)来在一个渲染处理之内渲染多个颜色缓冲，在之前的泛光教程中我们也简单地提及了它。
对于几何渲染处理阶段，我们首先需要初始化一个帧缓冲对象，我们很直观的称它为gBuffer，它包含了多个颜色缓冲和一个单独的深度渲染缓冲对象(Depth Renderbuffer Object)。对于位置和法向量的纹理，我们希望使用高精度的纹理(每分量16或32位的浮点数)，而对于反照率和镜面值，使用默认的纹理(每分量8位浮点数)就够了。
GLuint gBuffer;
glGenFramebuffers(1, &amp;gBuffer);
glBindFramebuffer(GL_FRAMEBUFFER, gBuffer);
GLuint gPosition, gNormal, gColorSpec;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/007d563ff0fe93cf0554740ba7cd65ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d86c9eceb43803e0dd1c47ba5407a42/" rel="bookmark">
			微信公众号支付--1--获取openid
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：只有企业公众号才可以申请微信支付，个人公众号无权限申请。所以，我们得先有一个企业公众号。
一、参考官网文档 进入微信支付开发文档的官网地址https://pay.weixin.qq.com/wiki/doc/api/index.html，点击JSAPI支付。
1、主要交互流程 可以看到的是：商户系统和微信支付系统主要交互在于：
1、商户server调用统一下单接口请求订单，api参见公共api【统一下单API】
2、商户server接收支付通知，api参见公共api【支付结果通知API】
3、商户server查询支付结果，api参见公共api【查询订单API】
2、设置授权域名 开发JSAPI支付时，在统一下单接口中要求必传用户openid，而获取openid则需要您在公众平台设置获取openid的域名，只有被设置过的域名才是一个有效的获取openid的域名，否则将获取失败。
2.1、登录企业公众平台 在“开发 - 接口权限 - 网页服务 - 网页授权- 网页授权获取用户基本信息”的配置选项中，修改授权回调域名。请注意，这里填写的是域名（是一个字符串），而不是URL，因此请勿加 http:// 等协议头。
注意：配置的时候需要将该txt文件放置到公众号的根目录下，并且确保可以通过浏览器直接访问该文件。
2.2、使用内网穿透工具将域名映射到本地，方便调试 这里我使用的是https://www.ngrok.cc/，使用方法参考博客https://blog.csdn.net/hjfcgt123/article/details/104173788，配置域名http://hungteshun.viphk.ngrok.org指向本地开发的项目地址127.0.0.1:8080，方便调试。
二、手动方式获取openid 官网文档：https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html#0
1、第一步：用户同意授权，获取code 在确保微信公众账号拥有授权作用域（scope参数）的权限的前提下（服务号获得高级接口后，默认拥有scope参数中的snsapi_base和snsapi_userinfo），在微信客户端打开以下链接：
https://open.weixin.qq.com/connect/oauth2/authorize?appid=公众号的appId&amp;redirect_uri=http://hungteshun.viphk.ngrok.org/sell/weixin/callback&amp;response_type=code&amp;scope=snsapi_base&amp;state="state"#wechat_redirect 参数说明 参数是否必须说明appid是公众号的唯一标识redirect_uri是授权后重定向的回调链接地址， 请使用 urlEncode 对链接进行处理response_type是返回类型，请填写codescope是应用授权作用域，snsapi_base （不弹出授权页面，直接跳转，只能获取用户openid），snsapi_userinfo （弹出授权页面，可通过openid拿到昵称、性别、所在地。并且， 即使在未关注的情况下，只要用户授权，也能获取其信息 ）state否重定向后会带上state参数，开发者可以填写a-zA-Z0-9的参数值，最多128字节#wechat_redirect是无论直接打开还是做页面302重定向时候，必须带此参数 这里的redirect_uri值，必须是公众平台中配置的授权域名下的url，否则不能回调。
请求成功之后，将会跳转至 http://hungteshun.viphk.ngrok.org/sell/weixin/callback?code=CODE&amp;state=STATE，携带的参数为code和state。
2、第二步：通过code换取网页授权access_token和openid 在微信客户端打开以下链接
https://api.weixin.qq.com/sns/oauth2/access_token?appid=公众号的appid&amp;secret=公众号的secret&amp;code=CODE&amp;grant_type=authorization_code 参数说明 参数是否必须说明appid是公众号的唯一标识secret是公众号的appsecretcode是填写第一步获取的code参数grant_type是填写为authorization_code 正确时返回的JSON数据包如下：
{ "access_token":"ACCESS_TOKEN", "expires_in":7200, "refresh_token":"REFRESH_TOKEN", "openid":"OPENID", "scope":"SCOPE" } 参数说明：
参数描述access_token网页授权接口调用凭证,注意：此access_token与基础支持的access_token不同expires_inaccess_token接口调用凭证超时时间，单位（秒）refresh_token用户刷新access_tokenopenid用户唯一标识，请注意，在未关注公众号时，用户访问公众号的网页，也会产生一个用户和公众号唯一的OpenIDscope用户授权的作用域，使用逗号（,）分隔 如果网页授权的作用域为snsapi_base，则本步骤中获取到网页授权access_token的同时，也获取到了openid，snsapi_base式的网页授权流程即到此为止。
如果网页授权的作用域为snsapi_base，则可以继续获取用户的信息，具体操作参考官方文档。
三、通过sdk方式获取openid（推荐） 这里的sdk包并非官方给出，而是由其他开发者整合了微信官网给出的url调用方式，封装了一套api：
github地址：https://github.com/Wechat-Group/WxJava
码云地址：https://gitee.com/binary/weixin-java-tools
其中 weixin-java-mp 项目是企业公众号的源代码
1、引入maven依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.binarywang&lt;/groupId&gt; &lt;artifactId&gt;weixin-java-mp&lt;/artifactId&gt; &lt;version&gt;2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d86c9eceb43803e0dd1c47ba5407a42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cdf105f950b817276547f8f3981551c/" rel="bookmark">
			用calibre自制图文并茂且支持kindle的mobi电子书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		缘起
目前看电子书的电子墨水设备很多，但是还是kindle卖的最多，而且功能简单，换句话说就是能更好的沉浸式看书
mobi格式电子书不仅能在kindle上观看，且很多设备都支持，在此以kindle为例子来分享
kindle电子书有两个途径，一个是从amazon上付费购买，另一个是自己制作，发送到特定邮箱中，amazon convert后会发送到kindle设备上
kindle个人服务支持的文档格式：
Kindle个人文档服务目前只能转换并发送以下类型的文档：
Microsoft Word (.doc, .docx) RTF文件(.rtf) HTML(.htm, .html)
TXT文件(.txt) Zip, x-zip压缩文件
Mobi格式电子书 JPEG (.jpg), GIF (.gif), Bitmap (.bmp) 和 PNG (.png) 格式的图片。
Adobe PDF (.pdf)文档可维持原文件格式，发送至您的Kindle。
Adobe PDF (.pdf)文档可转换为Kindle格式发送，目前处于试用阶段。
支持的格式不少，但是txt格式缺点是只有文本，dox(x)格式排版容易有问题，图片字体不能调整
这么多格式，mobi格式能兼顾图文丰富和格式排版最好
电子书制作工具calibre下载地址
https://calibre-ebook.com/download
我下载的是macOS格式
安装及语言选择
双击dmg文件，看到下图，然后将calibre拖入Applications文件夹即可安装
安装完后，在启动台点击图标运行，在欢迎界面选择语言Simplified Chinese
制作电子书
制作前准备，先在word把电子书排版好，如果需要目录则先在word里生成目录，导入calibre目录也能使用
导入word文档到calibre，点击“添加书籍”，选中要导入的书籍
转换格式，选中书籍，点击“转换书籍”，将word格式转换成azw3格式，才能进行下一步，编辑书籍
编辑书籍，选中书籍“一日禅**”，点击编辑书籍，弹出编辑书籍新窗口
编辑书籍窗口如下
点击红色标记1，可以显示标记4和5，4是源代码（专家用户可以直接编辑源代码），5是效果预览
重点：2，3两个文件需要做下调整，避免在kindle设备中出现图片不能自动缩放和背景字体颜色无法自适应问题
上图在0001.css中，注释掉所有的background-color,color,width,height ，以去掉所有的固定颜色和大小，适应不同的kindle设备
上图在0002.css中加入img全局样式，让所有图片自适应不同kindle设备大小，css样式如下
img {
width: auto;
height: auto;
max-width: 100%;
max-height: 100%;
}
编辑完记着保存
书籍编辑完毕后，可以生成封面，这不是必要步骤
最后在做一次转换，将awz3格式转换成mobi格式,下图是不正确的，左侧默认是docx
下面这幅图片才是第二次转换的正确方式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cdf105f950b817276547f8f3981551c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffd2bd4f393f3509b97ca7ed02072386/" rel="bookmark">
			Gradle问题——编译错误compileJava FAILED
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用gradle项目时，build一个文件过程中出现以下情况：
&gt; Task :compileJava /home/user_1/idea-program/avro-car-sensor-simulator-master/src/main/java/com/hivemq/CarDataPayloadGenerator.java:7: error: cannot access PluginPayloadGenerator import com.hivemq.simulator.plugin.sdk.load.generators.PluginPayloadGenerator; ^ bad class file: /home/user_1/idea-program/avro-car-sensor-simulator-master/device-simulator-plugin-sdk-1.0.0.jar(com/hivemq/simulator/plugin/sdk/load/generators/PluginPayloadGenerator.class) class file has wrong version 55.0, should be 52.0 Please remove or make sure it appears in the correct subdirectory of the classpath. &gt; Task :compileJava FAILED FAILURE: Build failed with an exception. * What went wrong: Execution failed for task ':compileJava'. &gt; Compilation failed; see the compiler error output for details. * Try: Run with --stacktrace option to get the stack trace.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffd2bd4f393f3509b97ca7ed02072386/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccdb69daf0316ad75f88878bcfd0e790/" rel="bookmark">
			02-配置项目工程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用pipenv创建虚拟环境 创建虚拟环境：在cmd中cd命令到指定文件夹下（此处使用F:\Code\PyTest\PyQt5），使用pipenv -three创建python3的虚拟环境激活虚拟环境：pipenv shell安装必要的包：将Pipfile中的url改为"https://pypi.tuna.tsinghua.edu.cn/simple"获取更快的下载速度。 使用pipenv -install pyqt5
安装完成后开始配置PyCharm
附录：pipenv的安装及使用
PyCharm的配置 配置使用环境 打开PyCharm，在"File"-&gt;"Open"中打开刚才创建虚拟环境的目录。
在"File"-&gt;“Settings”-&gt;"Project:xxx(项目名)"中配置环境为当前虚拟环境。并可检查当前环境的包是否安装好。
现在即可测试py文件是否可执行。测试py如下，可正常工作。 from PyQt5.Qt import * import sys app = QApplication(sys.argv) window = QWidget() window.setWindowTitle("title") window.resize(500, 500) window.move(400, 200) label = QLabel(window) label.setText("Hello Phill") label.move(200, 200) window.show() sys.exit(app.exec_()) 配置qt工具 下载安装pyqt5-tools，tools包含Qt designer（UI设计师）工具，可通过手动安装，或者借助PyCharm安装。
手动安装
pip install PyQt5-tools
借助PyCharm安装
打开PyCharm，“File”-&gt;“Settings”-&gt;“Project"中找到环境配置，点击”+",查找自己要安装的三方包，点击"Install Package",等待安装完成即可。
在PyCharm中配置外部工具
“File”-&gt;“Settings”-&gt;“External Tools”,进行配置。将"designer.exe",“pyrcc5.exe”,"pyuic5.exe"全部进行配置。配置中的路径和参数，可用宏来进行表示。
使用外部工具
右键ui或qrc文件，选择对应的外部工具进行处理
pycharm调试方法 pycharm调试方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a7e4f749c490e6bece83d81c6d3da30/" rel="bookmark">
			克隆U盘win10系统启动盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		克隆U盘win10系统启动盘 手里已经有一个2018年新版的Win10的U盘启动盘，现在想重新做一个启动盘，经历了多次失败，现在将制作经历和大家分享一下。
思路步骤： 1.使用ultraiso将已有的win10启动U盘制作iso文件； 2.将iso文件用ultraiso制作成U盘启动盘。 实测记录： 1.第一次测试结果： 但是经过反复测试，上述思路不成功。因为新版的win10当中有个文件“sources\install.wim”，此文件有4.1G，超过了fat32的容量限制，而使用ultraiso制作启动盘，无论你之前是采用NTFS还是FAT32格式格式化，在写入iso映像的时候都会把这个变成Fat32，反正我是先用win10系统把U 盘 Fat32格式化，然后将iso用ultraiso写入U盘，最后发现的确U盘写入不报错，但是格式又成了Fat32，而且启动的install.wim只有100多M，写入过程没有报错，但是在安装启动的时候说install.wim读取失败。但是明知错误，当U盘制作好之后，想再把正确的install.wim写入覆盖错误的install.wim，也是不行的，应为U盘是fat32的。
2.第二次测试改进思路 于是现在有两种方法：
1.用NTFS格式化U盘，然后用文件备份工具“freefilesync”将好的U盘拷贝给新U盘；
2.还是用之前的方法制作U盘启动，然后用DOS命令更改U盘文件格式为NTFS，再用正确的install.wim更替那个错误的文件。
现在测试第一种方法。
3.第二次测试结果 结果是：成功！居然正常的启动安装了。
既然成功了，那么第二种方法还测试吗？测测吧。先确保一下，用ultraiso自带的格式化来格式化U盘为NTFS格式，看能否正常格式化为NTFS并写入iso映像。测试发现，用ultraiso自己的格式化用NTFS格式完成之后也不成，写完后还是FAT32，看来重要是iso映像是FAT32的。怎么能制作NTFS的iso？
选用几种格式，另存为iso，要么保存出错（Joliet），要么也不能用（UDF），反正不能生成NTFS格式。
没办法，只有用生成的错误install.wim的iso先生成启动盘，再用NTFS转换，也就是采用上述第2种方法测试。
4.第三次测试 于是按照方法2进行测试：
1.先用ultraiso生成启动盘：启动——写入硬盘映像——选择待写入的U盘驱动器“硬盘驱动器”，写入方式“USB-HDD+”；
2.转换格式：1）打开“运行”，然后输入cmd，点击确定后进入管理员后台；2）在光标处输入convert XX:/FS:ntfs，然后点击回车，其中XX是指待转换的盘符。只要不是C盘，其他盘都直接生效，否则重启生效。
结果提示转换失败：
按照提示，输入：chkdsk h: /F
C:\Users\lucky&gt;chkdsk h:/F
文件系统的类型是 FAT32。
20200203_22 卷创建了 2020/2/4 0:46
卷序列号为 B4FE-5315
Windows 正在校验文件和文件夹…
已完成文件和文件夹验证。
Windows 已扫描文件系统并且没有发现问题。
无需采取进一步操作。
总共有 30,293,792 KB 磁盘空间。
87 个文件夹中有 768 KB。
948 个文件中有 941,920 KB。
29,351,096 KB 可用。
每个分配单元中有 8,192 字节。
磁盘上共有 3,786,724 个分配单元。
磁盘上有 3,668,887 个可用的分配单元。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a7e4f749c490e6bece83d81c6d3da30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56f5f1623905084f752f92c3351adf5f/" rel="bookmark">
			类加载时是否会执行静态代码块？静态代码块的骚操作。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类加载时是否会执行静态代码块？ 杂谈问答解第一种形式，类名.Class 第二种形式， new 对象 第三种形式 ，Class.forName("类的全路径")第三种形式的特殊用法 总结扩展 杂谈 厦门的口罩都卖完了，前几天都开始摇号卖口罩了，太难了，今天是大年初十，可比去年大年初一还冷清，而且随着疫情的发展，我明显能感觉到周围的朋友情绪不断的低落，希望疫情早日过去，武汉加油！中国加油！
问 类加载时是否会执行静态代码块？
答 不一定。类加载的方式有多种，并不是每一种方式都能执行静态代码块
解 类加载的三种方式（常用方式）
1 new 对象 2 Class.forName(“类的全路径”) ps(有个 点 ，注意一下)3 类名.Class 在执行的时候加上以下一句JVM的运行参数，可以观看类加载过程
-XX:+TraceClassLoading
例，用idea就这样添加
来吧，小伙子们，上代码~
第一种形式，类名.Class class ClassTest{ static { System.out.println("执行了静态代码块"); } } public class ClassLoderTest { public static void main(String[] args) throws ClassNotFoundException { Class&lt;?&gt; aClass2 = ClassTest.class; } } 运行结果如下
ClassTest 这个类有被加载器加载，但是并没有输出语句，所以并没有被执行。
第二种形式， new 对象 new 一个对象，以及利用这个对象调用成员变量方法等，就不在一一赘述。
class ClassTest{ static { System.out.println("执行了静态代码块"); } } public class ClassLoderTest { public static void main(String[] args) throws ClassNotFoundException { new ClassTest(); } } 运行结果如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56f5f1623905084f752f92c3351adf5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29a7002d8a9366ff24aee6333fdb4268/" rel="bookmark">
			安装packetdrill出现的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为不同的版本可能成功，但是我的没有成功，所以以下是我的机子发行版本
安装的时候报错：
但是之前我已经安装了这两个库，但是按照这个报错的来看就是因为某个库缺少了这个libtextstyle.so，所以我们去源码看看有什么发现：
然后我们发现我们需要下载这个tar.gz
两种方法
一 下载缺少的这个文件 # 解压 tar -zxvf libtextstyle-0.8.tar.gz # 进入目录并编译 cd libtextstyle-0.8 ./configure 二 安装gettext 看第一次的图我们发现libtextstyle属于gettext下的，所以
sudo pacman -S gettext 之后make就不报错了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f04dc2004fe0f7f596efb1018deec08/" rel="bookmark">
			Postman每次请求携带token
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 单点登录，登录成功之后获取token,每次登录 token都会改变 且token具有过期时间
测试中，每次post请求都要携带一个token，token是通过get请求得来的，动态变化的，并且token有有效期的限制。为了避免重复获取token来手工修改给post请求赋值：
1.把token做成环境变量，这样多个post请求可以复用
在post请求中使用环境变量，携带token信息
2.发送get请求获取当前可用token之后，在单点登录颁发token接口的Tests中给环境变量赋值
var acquiretoken = JSON.parse(responseBody); //定义一个acquiretoken方法(获取token)，把responseBody转为json字符串 pm.environment.set("token",acquiretoken.data); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/837495fa03d85094aee921cad1def956/" rel="bookmark">
			推特开发者账号 elevated academic学术权限申请
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020年推特开发者注册流程：
以前是不需要成为开发者，可以直接申请应用。现在是要先成为开发者账号，然后以开发者的身份进行申请app。
1.首先你要有一个推特账号：
twitter官网
2.打开开发者平台申请开发者账号：
开发者平台
3.申请elevated权限：
一步一步来就行。
选择你的用途，公司的填公司，学校的填学校
这个地方写的东西就多了，细节就是尽量多写，详细写，写的少肯定过不了，比如你是做什么用的呀，计划怎么用的都写上。
按步骤走，等消息就行了
academic呢，大体流程也差不多： 比如你是某个学校的老师、学生。按网站上的要求上传一些信息就行，感觉academic比elevated的数据量多了些，而且可以搜索所有历史推文，其他的用途和elevated的差不了多少。
import datetime import tweepy import time # 填写twitter提供的开发Key和secret consumer_key = 'your consumer_key' consumer_secret = 'your onsumer_secret' access_token = 'your access_token ' access_token_secret = 'your access_token_secret ' # 提交你的Key和secret auth = tweepy.OAuthHandler(consumer_key, consumer_secret) auth.set_access_token(access_token, access_token_secret) # 获取类似于内容句柄的东西 api = tweepy.API(auth, proxy='127.0.0.1:1080') for status in tweepy.Cursor(api.home_timeline).items(2): print(status.text) print("time:", datetime.datetime.now()) 就可以打印出用户自己首页的推文了。验证成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12382796ada571d253aaa891cfb121e4/" rel="bookmark">
			STM32简单的PID控制器代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /************************************************************************** 函数功能：位置式PID控制器 入口参数：编码器测量位置信息，目标位置 返回 值：电机PWM 根据位置式离散PID公式 pwm=Kp*e(k)+Ki*∑e(k)+Kd[e（k）-e(k-1)] e(k)代表本次偏差 e(k-1)代表上一次的偏差 ∑e(k)代表e(k)以及之前的偏差的累积和;其中k为1,2,,k; pwm代表输出 **************************************************************************/ int Position_PID (int Encoder,int Target) { float Position_KP=80,Position_KI=0.1,Position_KD=500; static float Bias,Pwm,Integral_bias,Last_Bias; Bias=Encoder-Target; //计算偏差 Integral_bias+=Bias;	//求出偏差的积分 Pwm=Position_KP*Bias+Position_KI*Integral_bias+Position_KD*(Bias-Last_Bias); //位置式PID控制器 Last_Bias=Bias; //保存上一次偏差 return Pwm; //增量输出 } /************************************************************************** 函数功能：增量PI控制器 入口参数：编码器测量值，目标速度 返回 值：电机PWM 根据增量式离散PID公式 pwm+=Kp[e（k）-e(k-1)]+Ki*e(k)+Kd[e(k)-2e(k-1)+e(k-2)] e(k)代表本次偏差 e(k-1)代表上一次的偏差 以此类推 pwm代表增量输出 在我们的速度控制闭环系统里面，只使用PI控制 pwm+=Kp[e（k）-e(k-1)]+Ki*e(k) **************************************************************************/ int Incremental_PI (int Encoder,int Target) { float Kp=20,Ki=30;	static int Bias,Pwm,Last_bias; Bias=Encoder-Target; //计算偏差 Pwm+=Kp*(Bias-Last_bias)+Ki*Bias; //增量式PI控制器 Last_bias=Bias;	//保存上一次偏差 return Pwm; //增量输出 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a1e87d6faff32efb8427b6f7da59990/" rel="bookmark">
			windows 上 Kafka 启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 下载 Kafka 官网下载链接
现在比较新的版本都集成了 Zookeeper ,无需另行下载. 尽量下载最新版本吧.
本例 下载的是 kafka_2.13-2.4.0.tgz
解压至 D:\Kafka\kafka_2.13-2.4.0 下面
也请确保本机配置了 JDK
2. 启动服务 需遵循以下几步, 依次打开新的命令行启动, 也不要关闭之前的命令行窗口
cmd 先进入至 D:\Kafka\kafka_2.13-2.4.0
启动 Zookeeper 服务, 默认端口 2181bin\windows\zookeeper-server-start.bat config\zookeeper.properties 启动 Kafka 服务,默认端口 9092bin\windows\kafka-server-start.bat config\server.properties 创建 Topicbin\windows\kafka-topics.bat --create --bootstrap-server localhost:2181 --replication-factor 1 --partitions 1 --topic test 该命令 表示创建一个 名为 test 的主题，1 个副本，1个分区启动生产者bin\windows\kafka-console-producer.bat --broker-list localhost:9092 --topic test 该命令可以从控制台获取输入，将其作为 消息 存储至 kafka， 再由消费者读取，一次回车代表一条消息
启动消费者bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test --from-beginning 该命令 会读取kafka中存储的消息， – from-beginning 表示从最开始，意味着每次重启消费者，都会将之前的信息读取过来
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d57a3b67e84e32386356f5771b475ef/" rel="bookmark">
			电脑上的文件删除不掉,需要管理员权限怎么办?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 刚才想删除电脑上的一个文件夹,但怎么都删除不掉,非得需要我以前一个U盘的管理员权限,可是我早就不用那个U盘了,弄了好久终于把这个问题解决了,赶紧来记录一下.
按下WIN+R,打开运行对话框输入gpedit.msc,按回车键,进入本地组策略编辑器 点击计算机配置打开windows设置进入安全设置点击本地策略进入安全选项找到"用户账户控制:以管理员批准模式运行所有管理员",并禁用它 完成到这里可能需要重启一下就可以删除文件夹了,但是上一步可能会有问题,可能会进入不到本地组策略编辑器,就是运行对话框输入代码之后找不到文件,怎么办呢,下面是解决方法*
鼠标右键单击屏幕,创建文本文档输入以下内容: @echo off pushd "%~dp0" dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;List.txt dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;List.txt for /f %%i in ('findstr /i . List.txt 2^&gt;nul') do dism /online /norestart /add-package:"C:\Windows\servicing\Packages\%%i" pause 保存文档,关闭选择重命名,将后缀名改为cmd右键单击这个文件,以管理员身份运行等待电脑处理完成就可以了,按任意键结束,并退出cmd窗口.这个时候就可以执行上面的步骤了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0acffa3482bd07d67b97573ab5f5a7f/" rel="bookmark">
			Listview和Databinding实现数据绑定 (一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先 创建一个实体类 为啥要实体类?因为你需要使用Databinding,这个东西就需要实体类
public class ListviewItemTestDomain { private String text; public ListviewItemTestDomain(String text) { this.text = text; } public String getText() { return text; } public void setText(String text) { this.text = text; } } 其次 创建list view 的item 记得也要&lt;data&gt;标签导入实体类
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;layout xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;data&gt; &lt;variable name="listTest" type="com.primer.gaotest.mvp.control.domain.ListviewItemTestDomain" /&gt; &lt;/data&gt; &lt;TextView android:textColor="@color/black" android:id="@+id/list_view_adapter_test" android:layout_height="wrap_content"&gt; &lt;/TextView&gt; &lt;/layout&gt; 接下来 主界面的list view布局 导入adapter
&lt;data&gt; &lt;variable name="listviewTest" type="com.primer.gaotest.mvp.view.adapter.ListviewAdapterTest" /&gt; &lt;variable name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0acffa3482bd07d67b97573ab5f5a7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2a264b5d83dd77a93ecb1c21d08dcfe/" rel="bookmark">
			执行python setup.py install时报错：error: can&#39;t create or remove files in install directory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 报错mac&amp;linuxWindows 报错 在研究setuptools时，执行python setup.py install，遇到不能创建文件夹的权限报错，完整的错误日志如下：
~ python setup.py install running install error: can't create or remove files in install directory The following error occurred while trying to add or remove files in the installation directory: [Errno 13] Permission denied: '/Library/Python/2.7/site-packages/test-easy-install-19811.write-test' The installation directory you specified (via --install-dir, --prefix, or the distutils default setting) was: /Library/Python/2.7/site-packages/ Perhaps your account does not have write access to this directory? If the installation directory is a system-owned directory, you may need to sign in as the administrator or "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2a264b5d83dd77a93ecb1c21d08dcfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2db38e916e6c3163b2b0dd469349aefd/" rel="bookmark">
			算法实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完美数列(25)-PAT乙级真题 给定一个正整数数列，和正整数p，设这个数列中的最大值是M，最小值是m，如果M &lt;= m * p，则称这个数列是完美数列。
现在给定参数p和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
输入格式：
输入第一行给出两个正整数N和p，其中N（&lt;= 105）是输入的正整数的个数，p（&lt;= 109）是给定的参数。第二行给出N个正整数，每个数不超过109。
输出格式：
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
输入样例：
10 8
2 3 20 4 5 1 6 7 8 9
输出样例：
8
分析：首先将数列从小到大排序，设当前结果为result = 0，当前最长长度为temp = 0；从i = 0～n，j从i + result到n，【因为是为了找最大的result，所以下一次j只要从i的result个后面开始找就行了】每次计算temp若大于result则更新result，最后输出result的值～
# include&lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; int main() { int n; long long p; scanf("%d%lld", &amp;n, &amp;p); vector&lt;int&gt; v(n); for (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i]; sort(v.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2db38e916e6c3163b2b0dd469349aefd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3db70c80018f8d55816d802ea1cee571/" rel="bookmark">
			因特网接入技术简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、因特网接入二、窄带与宽带三、主要接入技术 一、因特网接入 1.1 因特网接入技术
因特网(Internet) 是世界上规模最大的互联网络，让我们的计算机连接到广阔的因特网海洋是尽情冲浪的基础和前提。
因特网接入技术（Internet access technology）是指连接因特网用户（subscriber）(一般是私人用户和商业机构）和因特网服务提供商（Internet Service Provider，ISP）（例如电话公司或电缆公司）的数据通信系统。
1.2 非对称模式
大多数因特网用户安装非对称方式使用因特网，也就是说，典型的用户从互联网接收的数据量远多于发送的数据量。运行web服务器的商业用户可能相反。
所以因特网接入技术在设计时一个方向上的传输量远大于另一个方向上的传输量。
1.3 上行与下行
术语上行表示数据从用户传输到服务提供商（或者说网络），下行表示数据从因特网服务提供商传输到用户，一般下行速度高于下行速度。
二、窄带与宽带 2.1 窄带技术
窄带 通常是指 数据传输速率低于64Kbps（有的书上是128Kbps）的网络接入技术。
主要的因特网窄带接入技术：
窄带拨号电话连接使用调制解调器的租用电路部分T1数据电路ISDN及其他数据电信业务 2.2 宽带技术
宽带 一般是指提供高速数据服务的技术，不过宽带和窄带之间没有确切的界限，许多专业人员建议宽带数据传输速率应大于1Mbps.
主要的宽带接入技术：
宽带DSL技术电缆调制解调器技术无线接入技术T1速率和更高速率的数据电路 三、主要接入技术 3.1 拨号接入
安装简单但速度最慢，所需介质为电话线，通过拨打ISP提供的电话号实现上网。
传输速率慢拨号连接占用电话线，即固定电话和上网无法同时进行 3.2 ISDN
综合业务数字网（Integrated Service Digital Network），为用户提供三个独立的数字信道——2B+D，即2个B信道，一个D信道。B信道提供数据通信，承载数字话音信息、数据或者压缩视频信息，速度为64Kbps，D信道作为控制信道，上网时可以同时占用两个B信道，以最高128Kbps的速率通信，有通话服务时为其分配出一个信道，可以同时上网和打电话。
3.3 DSL
用户数字线路（Digital Subscriber Line）,通过铜线或本地电话网提供数字连接的技术，由贝尔实验室一位工程师发明，将数字信号加载到电话线路未使用的频段，从而在不影响电话服务的同时进行数据通信。
DSL技术具有多种类型，ASDL,ADSL2,HDSL,VDSL等。
ADSL(Asymmetric Digital Subscriber Line，非对称数字用户线)是当前使用最广泛的一种类型，它使用频分复用技术把本地环路的带宽划分为三段，其中一段用于普通老式电话服务，其余两段划归数据通信使用。如下图：
3.4 电缆调制解调技术
电缆调制解调（Cable Modem），是利用有线电视网络进行数字连接的技术。ADSL提供了足够的传输速率，但是其配线采用抗电磁干扰能力较弱的双绞线，造成传输性能下降。而有线电视配线采用同轴电缆，带宽较高，抗电磁干扰能力强于双绞线。
CATV综合了频分复用和统计复用技术，为一组用户分配一个单独的信道，每个用户分配一个唯一的地址。
3.5 光纤接入
顾名思义，传输介质采用光纤，包括 FTTC(Fiber to the Curb), FTTB(Fiber to the Building), FTTH(Fiber to the Home) 等多种技术。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3db70c80018f8d55816d802ea1cee571/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e01ef0819eeea0d2401ed53b0ec69442/" rel="bookmark">
			OpenCV中cv::recoverPose()函数详细介绍和用法，以及求解出的R,t的坐标相对关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在OpenCV中cv::recoverPose()函数主要是用来从本质矩阵中恢复 R , t R,t R,t 该函数在OpenCV中一共有以下这几种形式： int recoverPose( InputArray E, InputArray points1, InputArray points2, InputArray cameraMatrix, OutputArray R, OutputArray t, InputOutputArray mask = noArray() ); int recoverPose( InputArray E, InputArray points1, InputArray points2, OutputArray R, OutputArray t, double focal = 1.0, Point2d pp = Point2d(0, 0), InputOutputArray mask = noArray() ); int recoverPose( InputArray E, InputArray points1, InputArray points2, InputArray cameraMatrix, OutputArray R, OutputArray t, double distanceThresh, InputOutputArray mask = noArray(), OutputArray triangulatedPoints = noArray()); 参数介绍：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e01ef0819eeea0d2401ed53b0ec69442/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b95548bb9be1d95a6de89a8bf3d4581/" rel="bookmark">
			迭代算法6——近似迭代法之二分法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用二分法求方程3x^3-13x+2=0在区间[1,9]的根。
【分析】
1.相关概念
零点：函数y=f(x)的零点就是f(x)=0的根，如果y=f(x)有根存在，则说明函数y=f(x)的图像与x轴有交点。
2.零点存在的判断方法
函数y=f(x)在区间[a,b]上连续，且f(a)·f(b)&lt;0，则y=f(x)在(a,b)内有零点存在，如图所示。
3.二分法定义
对于区间[a,b]上连续且f(a)·f(b)&lt;0的函数y=f(x)，通过不断地将函数f(x)的零点所在区间一分为二，使区间的两个端点逐步靠近零点，进而得到零点近似值的方法叫二分法。
具体的做法为：
（1）当f(a)·f(b)&lt;0，则说明区间[a,b]上存在零点，求出中间值c=(a+b)/2，判断f(a)·f(c)正负。
（2）如果f(a)·f(c)&lt;0，说明区间[a,c]上存在零点，令b=c；否则说明区间[c,b]上存在零点，令a=c。
（3）如果|f(c)|&gt;EPS（精度）且|a-b|&gt;EPS，则转步骤（1），执行；否则停止执行，将c作为近似值。
【示例】
利用二分法求函数f(x)=3x^3-13x+2在区间[1,4]的零点。
计算过程如下：
（1）令a=1，b=4，计算a、b中间值c=2.5。
（2）因为f(1)=-8，f(2.5)=16.375，所以f(1)·f(2.5)&lt;0。因此零点位于区间[1,2.5]，令b=2.5。
（3）求出a、b中间值c=1.75。
（4）因为f(1)=-8，f(1.75)=-4.67188，所以f(1)·f(1.75)&gt;0。因此零点位于区间[1.75,2.5]，令a=1.75。
（5）不断重复上述过程直到 |f(c)| &lt; EPS时，停止执行，将c作为近似值。
code：
#include&lt;stdio.h&gt; #include&lt;math.h&gt; #include &lt;iostream&gt; #define EPS 1e-6 double f(double x); void main() { double a, b, c=0; printf("请输入一个区间(如:1,4):"); scanf("%lf,%lf", &amp;a, &amp;b); printf("方程3*x*x*x-13*x+2=0的解:x="); if (fabs(f(a)) &lt;= EPS) { printf("%lg\n", a); } else if (fabs(f(b)) &lt;= EPS) { printf("%lg\n", b); } else if (f(a)*f(b) &gt; 0) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b95548bb9be1d95a6de89a8bf3d4581/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d640ad74524477de3a6a686ebe5eda0/" rel="bookmark">
			codeforce div2 b Infinite Prefixes详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目如图
题目表达的很复杂，看了很久都不能理解一堆abc的例子在表达什么，在别人帮助翻译后大致理解了题意
其实简单来说就是给一个长度已知可以无限重复的字符串，只有0和1两种字符，问有几个点可以使0比1多x个，比如样例1,
010010 1个子串0比1多2个，所以前四个子串结束后0一共比1多了8个，而0比1多10个将在下一个子串中出现，也就是28 30 和32
需要注意的还有如果要求为0，则需要考虑空前缀的问题
那么开始设计程序，我们必须考虑所有情况，但因为字符穿无限，我们不能直接全部搜索，于是我们把问题先分解成两种情况，及子串中0和1个数相同或不同，先讨论相同的情况，如果0和1相同，就意味着次数的累计不能帮助0比1多的个数增加。所以遍历一遍子串，看其中有没有可以使0比1多x的点，如果有则后续一定有无限个，输出-1，如果没有就永远不会出现这个点，输出0.
再看第二种情况，如果在一个子串完结后0比1多了T个，那么在一次次的累计种，0比1多的会越来越多，解一点是有限个甚至0个，但是我们不能确定解的具体位置，那么想一想答案出现的点会有的特征，不难发现，这个点一定是在某一个子串中的某一个位置出现的，所以我们还是只用遍历一个子串用d记录当前0比1多的次数，至于如何确定答案，我认为T的某个倍数加目前此次遍历过程中0比1多的次数等于x的点就是答案存在的点，翻译成程序就是（x-d）%T==0与此同时我们还要保证此时（x-d）应该和T同号，否则随着子串的延长，会离答案越来越远，
想好了思路代码自然就可以顺利的出`
#include&lt;bits/stdc++.h&gt; using namespace std; char a[1000] int main() { int n,q,d,x,T,ans; cin&lt;&lt;n; while(n--) { ans=0;T=0;d=0; (int i=1;i&lt;=1000;i++) a[i]='0';//数组初始化 scanf("%d%d",&amp;q,&amp;x) scanf("%s",a+1)； for(int i=1;i&lt;=q;i++) { if(a[i]=='0')T++; else T--; } if(x==0)ans++; if(T==0) { for(int i=1;i&lt;=q;i++) { if(a[i]=='0')d++; else d--; if(d==x)ans=-1; } } else { for(int i=1;i&lt;=q;i++) { if(a[i]=='0')d++; else d--; if((x-d)%T==0&amp;&amp;(x-d)/T&gt;=0)ans++; } } printf("%d\n",ans); return 0; } 主要注意几个坑，考虑x==0是存在空前缀的情况
注意在每一遍的过程一定可以找到所有符合答案的情况。
tnl
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d929c4da1e818cdff8f1c0f24562262c/" rel="bookmark">
			Matlab--索引图像转换成真彩色图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		索引图像转换成真彩色图 [X,map] = imread('corn.tif'); //%索引图像X是uint8类型的415×312 数组.颜色图 cmap 是 double 类型的 256×3 矩阵，因此索引图像中有 256 种颜色。 RGB = ind2rgb(X,map); //%将索引图像转换为 RGB 图像。结果为一个 double 类型的 415×312×3 数组。 disp(['Range of RGB image is [',num2str(min(RGB(:))),', ',num2str(max(RGB(:))),'].']); //%检查 RGB 图像的值是否在 [0, 1] 范围内。 imshow(RGB); ind2rgb()函数详解 语法 RGB = ind2rgb(X,map) RGB = ind2rgb(X,map)将索引图像X和对应的颜色图map转换为RGB（真彩色）格式。
输入参数 X--索引图像 m×n整数矩阵
如果将 X 指定为整数数据类型的数组，则值 0 对应于颜色图 map 中的第一种颜色。对于包含 c 种颜色的颜色图，图像 X 的值会被裁剪到范围 [0, c-1] 内。如果将 X 指定为 single 或 double 数据类型的数组，则值 1 对应于颜色图中的第一种颜色。对于包含 c 种颜色的颜色图，图像 X 的值会被裁剪到范围 [1, c] 内。 数据类型：single | double | uint8 | uint16
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d929c4da1e818cdff8f1c0f24562262c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7da1edaeb13ae390e8c950a40838df44/" rel="bookmark">
			Hive UDAF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UDAF是用户自定义聚合函数。Hive支持其用户自行开发聚合函数完成业务逻辑。 从实现上来看，Hive的UDAF分为两种：
Simple。即继承org.apache.hadoop.hive.ql.exec.UDAF类，并在派生类中以静态内部类的方式实现org.apache.hadoop.hive.ql.exec.UDAFEvaluator接口。这种方式简单直接，但是在使用过程中需要依赖JAVA反射机制，因此性能相对较低。在Hive源码包org.apache.hadoop.hive.contrib.udaf.example中包含几个示例。可以直接参阅。但是这些接口已经被注解为Deprecated，建议不要使用这种方式开发新的UDAF函数。
Generic。这是Hive社区推荐的新的写法，以抽象类代替原有的接口。新的抽象类org.apache.hadoop.hive.ql.udf.generic.AbstractGenericUDAFResolver替代老的UDAF接口，新的抽象类org.apache.hadoop.hive.ql.udf.generic.GenericUDAFEvaluator替代老的UDAFEvaluator接口。
UDAF相关类和接口简介 AbstractGenericUDAFResolver 该抽象类实现了GenericUDAFResolver2的接口。UDAF主类须继承该抽象类，其主要作用是实现参数类型检查和操作符重载。可以为同一个函数实现不同入参的版本。
org.apache.hadoop.hive.ql.udf.generic.GenericUDAFEvaluator 该抽象类为UDAF具体的逻辑处理，包括几个必须实现的抽象方法，这几个方法负责完成UDAF所需要处理的逻辑。
UDAF的运行流程简介 抽象类GenericUDAFEvaluator中，包含一个静态内部枚举类，和一系列抽象方法。这个枚举类的注释中，解释了各个枚举值的运行阶段和运行内容。按照时间先后顺序，分别有：
PARTIAL1：原始数据到部分聚合，调用 iterate 和 terminatePartial --&gt; map 阶段PARTIAL2: 部分聚合到部分聚合，调用 merge 和 terminatePartial --&gt; combine 阶段FINAL: 部分聚合到完全聚合，调用 merge 和 terminate --&gt; reduce 阶段COMPLETE: 从原始数据直接到完全聚合 --&gt; map 阶段，并且没有 reduce 那么，这几个方法分别干了些啥呢？ Init 实例化Evaluator类的时候调用的，在不同的阶段需要返回不同的OI。其入参和返回值，以及Mode阶段的关系如下表：
getNewAggregationBuffer 获取存放中间结果的对象。
iterate 处理一行数据。
terminatePartial 返回部分聚合数据的持久化对象。因为调用这个方法时，说明已经是map或者combine的结束了，必须将数据持久化以后交给reduce进行处理。只支持JAVA原始数据类型及其封装类型、HADOOP Writable类型、List、Map，不能返回自定义的类，即使实现了Serializable也不行，否则会出现问题或者错误的结果。
merge 将terminatePartial返回的部分聚合数据进行合并，需要使用到对应的OI。
terminate 结束，生成最终结果。
计算器四钟模式 计算器有4种模式，由枚举类GenericUDAFEvaluator.Mode定义：
public static enum Mode { PARTIAL1, //从原始数据到部分聚合数据的过程（map阶段），将调用iterate()和terminatePartial()方法。 PARTIAL2, //从部分聚合数据到部分聚合数据的过程（map端的combiner阶段），将调用merge() 和terminatePartial()方法。 FINAL, //从部分聚合数据到全部聚合的过程（reduce阶段），将调用merge()和 terminate()方法。 COMPLETE //从原始数据直接到全部聚合的过程（表示只有map，没有reduce，map端直接出结果），将调用merge() 和 terminate()方法。 }; UDAF开发 构造UDAF代码骨架部分 public class GenericUDAFHistogramNumeric extends AbstractGenericUDAFResolver { static final Log LOG = LogFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7da1edaeb13ae390e8c950a40838df44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95502e7f077115eda9a7f8dba9635d73/" rel="bookmark">
			Hadoop HDFS操作命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hadoop HDFS操作命令 查看Hadoop HDFS支持的所有命令 hadoop fs 列出目录及文件信息 hadoop fs -ls 循环列出目录、子目录及文件信息 hadoop fs -lsr 将本地文件系统的test.txt复制到HDFS文件系统的/user/sunlightcs目录下 hadoop fs -put test.txt /user/sunlightcs 将HDFS中的test.txt复制到本地文件系统中，与-put命令相反 hadoop fs -get /user/sunlightcs/test.txt 查看HDFS文件系统里test.txt的内容 hadoop fs -cat /user/sunlightcs/test.txt 查看最后1KB的内容 hadoop fs -tail /user/sunlightcs/test.txt 从HDFS文件系统删除test.txt文件，rm命令也可以删除空目录 hadoop fs -rm /user/sunlightcs/test.txt 删除/user/sunlightcs目录以及所有子目录 hadoop fs -rmr /user/sunlightcs 从本地文件系统复制文件到HDFS文件系统，等同于put命令 hadoop fs -copyFromLocal test.txt /user/sunlightcs/test.txt 从HDFS文件系统复制文件到本地文件系统，等同于get命令 hadoop fs -copyToLocal /user/sunlightcs/test.txt test.txt 修改HDFS系统中/user/sunlightcs目录所属群组，选项-R递归执行，跟linux命令一样 hadoop fs -chgrp [-R] /user/sunlightcs 修改HDFS系统中/user/sunlightcs目录拥有者，选项-R递归执行 hadoop fs -chown [-R] /user/sunlightcs 修改HDFS系统中/user/sunlightcs目录权限，MODE可以为相应权限的3位数或+/-{rwx}，选项-R递归执行 hadoop fs -chmod [-R] MODE /user/sunlightcs 查看PATH目录下，子目录数、文件数、文件大小、文件名/目录名 hadoop fs -count [-q] PATH 将文件从SRC复制到DST，如果指定了多个SRC，则DST必须为一个目录 hadoop fs -cp SRC [SRC …] DST 显示该目录中每个文件或目录的大小 hadoop fs -du PATH 类似于du，PATH为目录时，会显示该目录的总大小 hadoop fs -dus PATH 清空回收站，文件被删除时，它首先会移到临时目录.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95502e7f077115eda9a7f8dba9635d73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41fd833377f3619c7026265d6d963eb1/" rel="bookmark">
			docker由来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 没有虚拟化技术的原始年代使用虚拟机部署应用的年代docker 是什么？ 没有虚拟化技术的原始年代 准备一台物理服务器，然后在物理服务器上安装一个操作系统(Operating System)，有了操作系统之后，便在操作系统上安装运行我们的应用程序，这个过程可以用下面的图来表示：
物理服务器部署应用示意图
那么，这种方式有什么问题呢？其实，在物理机上部署应用有以下几个缺点：
部署非常慢：因为我们得先准备硬件服务器，接着还要安装操作系统，然后再部署应用程序，而且应用程序还有很多的依赖软件，所以这个过程是比较慢的。
成本非常高：主要是物理器成本太高，即使是部署一个简单的应用，也需要一台服务器。
资源浪费：如果应用太简单，也容易浪费硬件资源，比如CPU和内存
迁移和扩展太慢：如果需要迁移应用，或者扩展应用，都要再准备其他的物理服务器，过程很麻烦，也很慢。
那么有什么办法可以解决这些问题呢？答案便是虚拟化技术
使用虚拟机部署应用的年代 什么是虚拟化技术
谈到计算机的虚拟化技术，我们直接想到的便是虚拟机，虚拟机允许我们在一台物理计算机模拟出多台机器,简单地理解，虚拟化技术就是在一台物理计算机上，通过中间虚拟软件层Hypervisor隔离CPU、内存等硬件资源，虚拟出多台虚拟服务器，这样做的话，一台物理服务器便可以安装多个应用程序，达到资源利用的最大化，而且多个应用之间相互隔离，如下图所示：
虚拟机上部署应用示意图
虚拟机的优点
可以把资源分配到不同的虚拟机，达到硬件资源的最大化利用
与直接在物理机上部署应用，虚拟机更容易扩展应用。
云服务:通过虚拟机虚拟出不同的物理资源，可以快速搭建云服务。
虚拟机的不足之处
虚拟机的不足之处在于对物理服务器资源的消耗，当我们在物理服务器创建一台虚拟机时，便需要虚拟出一套硬件并在上面运行完整的操作系统，每台虚拟机都占用许多的服务器资源。
docker 是什么？ 相对于虚拟机的笨重，Docker则更显得轻量化，因此不会占用太多的系统资源。
Docker是使用时下很火的Golang语言进行开发的，其技术核心是Linux内核的Cgroup,Namespace和AUFS类的Union FS等技术，这些技术都是Linux内核中早已存在很多年的技术，所以严格来说Docker并不是一个完全创新的技术，Docker通过这些底层的Linux技术，对Linux进程进行封装隔离，而被隔离的进程也被称为容器，完全独立于宿主机的进程。
所以Docker是容器技术的一种实现，也是操作系统层面的一种虚拟化，与虚拟机通过一套硬件再安装操作系统完全不同。
docker容器与系统关系示意图
Docker与虚拟机之间的比较
Docker是在操作系统进程层面的隔离，而虚拟机是在物理资源层面的隔离，两者完全不同，另外，我们也可以通过下面的一个比较，了解两者的根本性差异。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20179743006fed12dc9667938ec83ac2/" rel="bookmark">
			Java多线程协同通信，学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多线程编程时，往往需要线程间协同通信，比如控制运行顺序、等待处理结果等。Java提供的多种控制方式可以满足不同场景需求。
学习资料：https://mp.weixin.qq.com/s/NUJL_mEfXSo0e-nf2UUNJQ
示例代码：https://github.com/wingjay/HelloJava/blob/master/multi-thread/src/ForArticle.java
消费者生产者模式：https://github.com/rickding/HelloJava/tree/master/HelloThread
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/601742e0ae31ca599ad24b923f482c91/" rel="bookmark">
			java P1162 填涂颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述
由数字0组成的方阵中，有一任意形状闭合圈，闭合圈由数字1构成，围圈时只走上下左右4个方向。现要求把闭合圈内的所有空间都填写成2.例如：6×6的方阵（n=6），涂色前和涂色后的方阵如下：
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/601742e0ae31ca599ad24b923f482c91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/533a3f33a4302d3b70ee72d7aaa72094/" rel="bookmark">
			卜若的代码笔记-一周速通LayaAir-第一章：环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.安装IDE
https://ldc2.layabox.com/layadownload/?type=layaairide-LayaAir%20IDE%202.5.0beta
直接下载之后解压，建议使用最新版，因为2.4以后支持VSCode，用着非常爽
2.安装VSCode
https://code.visualstudio.com/docs/?dv=win64user
download一下，推荐不装c盘，除非你喜欢
3.安装完成之后，推荐使用TypeScript，因为后面的教程就是使用TypeScript作为教程的
创建完成后，你可以通过运行：
进行调试。
4.如果你使用layaair调试
点击视图，选择开发人员选项，你可以看到控制台
如果你选择chorme，那就F12呼出控制台。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e0dc442ce3ddf236d3a14b7d9d14c6d/" rel="bookmark">
			F2FS技术拆解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		F2FS (Flash Friendly File System) 是专门针对SSD、eMMC、UFS等闪存设备设计的文件系统。由三星工程师Jaegeuk Kim于2012年10月发布到Linux社区，并于2012年12月进入Linux 3.8 内核主线。和UBIFS、JFFS2等文件系统不同，F2FS并不直接面向裸NAND闪存设计，而是和其他通用文件系统一样基于块设备层接口实现。既然如此，为什么说F2FS是针对SSD、EMMC、UFS等闪存设备设计呢？另一方面SSD、eMMC、UFS等拥有FTL（Flash Translation Layer）的闪存存储已经对外提供了通用块设备接口，是否真的需要针对性地设计一个文件系统呢？F2FS的“Flash Friendly”体现在哪些方面呢？请跟随本文对F2FS的设计实现做详细拆解，揭开F2FS与FTL“剪不断理还乱”的“爱恨交织”。
F2FS继承了日志结构文件系统的衣钵，使用异地更新的数据写入方式化随机为顺序。同时改善了日志结构文件系统的一些已知问题，如滚雪球效应和高清理开销。而FTL为了对上隐藏NAND闪存无法覆盖写的特性（先擦后写），其内部实现也采用了类似的日志结构写入方式。从软件模块化设计的角度看，两个层次的相近冗余设计似乎并不合理。然而存在即合理，F2FS实际上是摸准了FTL的软肋：那就是由于缺少上层（系统层、应用层）信息，FTL并不能很好的实现冷热分离、做到高效垃圾回收、减少写放大。同时FTL承载了太多目标：地址映射、磨损均衡、坏块管理等等，以及一些器件厂商无法言说的原因导致将FTL上移到软件层或是提供地址映射表等接口困难重重。因此即使拥有FTL，SSD、eMMC、UFS等设备也是需要一个针对性设计的文件系统来实现性能和寿命的优化。
F2FS虽然基于通用块设备层接口实现，但并不像通用文件系统一样无差别的对待机械磁盘和闪存盘，在设计上是”flash-awared”。根据闪存内部结构和闪存管理机制(FTL)，F2FS可通过多个参数配置磁盘布局、选择分配和回收单元大小从而适配不同实现的闪存存储设备。为方便理解F2FS，我们先简单介绍下FTL的地址映射方式和日志结构文件系统，然后从空间布局和索引结构入手建立F2FS的基本概念，进而深入到冷热分离、垃圾回收、块分配等细节中去。
FTL的地址映射方式 FTL(Flash Translation Layer)的本职工作是完成Host端逻辑地址到Flash侧物理地址的映射。需要地址映射的原因是闪存只能异地更新，为了对上支持数据块原地更新则需要通过地址转换实现。由于闪存先擦后写、擦写有次数限制（寿命）、使用过程中会不断出现坏块（块寿命不同）等特性，FTL还需具备垃圾回收、磨损均衡、坏块管理等十八般武艺。闪存内部的基本存储单位是Page（4KB）,N个Page组成一个Block。这里主要介绍下逻辑地址LPN（Logical Page Number）到物理地址PPN（Physical Page Number）的映射方式：
块级映射：将块映射地址分为两部分：块地址和块内偏移。映射表只保存块的映射关系，块内偏移直接对应。映射表比较小，需要内存（RAM）少。但无法很好的处理随机写，容易产生频繁的有效数据搬移和块擦除操作。
页级映射：映射表维护每个页的映射关系，这种方式灵活，能有效减少数据搬移。缺点是映射表很大（每个表项内容为PPN以4字节计算，128GB的闪存存储需要128GB/4KB*4B=128MB大小的内存保存映射表），约占存储容量的千分之一。
混合映射：主要思路是针对频繁更新的数据采用页级映射，很少更新的数据采用块级映射。其中采用Log Structed思想的混合映射将存储分为数据块（Data Block）和日志块（Log Block）。数据块用于存储数据，采用块级映射，日志块用于存储对于数据块更新后的数据，采用页级映射。混合映射是低端SSD、eMMC、UFS广泛采用的映射方式。根据日志块和数据块的对应关系又可以分为全相关映射（FAST）、块相关映射（BAST）、组相关映射（SAST）等等。下图是SAST映射的一个示例：2个日志块对应4个数据块，当日志块用完时需要通过搬移有效数据回收日志块。对于顺序写场景，最好情况下日志块对应位置记录了数据块的更新，则可以无需搬移数据，直接将日志块作为新的数据块，数据块进行擦除操作作为新的日志块。对于大量随机写场景，则需要将日志块和数据块中的有效数据搬移到空闲块的对应位置作为新的数据块，然后擦除原日志块和数据块。
图1 SAST映射数据搬移示例
日志结构文件系统 日志结构文件系统,Log Structured File System（注意：不是Journaling File System。Journaling File System是指在磁盘特定区域记录所有写入动作以便在需要时回溯和恢复，如：EXT4）思想的提出非常早，可以追溯到1992年时任UC Berkeley计算机系教授的John Ousterhout和他的学生Mendel Rosenblum发表的论文“The Design and Implementation of a Log-Structured File System”。John Ousterhout还是强大的Tcl语言（Tool Command Language，读：tickle，不是家电品牌哦）的发明者，就是下图这位白眉老爷爷。
图2 Tcl、LFS作者John Ousterhout
日志结构文件系统将所有的更改以日志式的结构连续的写入磁盘，以此加速文件写入和崩溃恢复。日志中包含索引信息，文件可以被高效的读出。为了快速的写入需要保留大块的空闲区域，可以将日志分成多个固定大小的连续空间——段（segment），在空闲区域不足时通过在碎片化的段中搬移有效数据回收新的连续空间。文章中还介绍了基于日志结构文件系统理念实现的Sprite LFS，较当时的UNIX文件系统FFS在小文件随机写上性能提升一个数量级。即使去除垃圾回收的开销，仍可以利用70%的磁盘带宽。日志结构文件系统如此优秀的写入性能不是没有代价的，如何高效的进行垃圾回收保持较高的写入性能特别是剩余空间较少、碎片化严重后的性能一直是众多日志结构文件系统致力于解决的问题。
下图展示了一个日志结构文件系统基本的索引结构和空间布局，以及数据更新方式。超级块Super Block（SB）自不必说，用于保存文件系统的基础信息。检查点Checkpoint（CP）则是指文件系统某一时点所有文件系统有效数据、索引结构一致完整的记录。创建检查点通常分两步：1.落盘所有文件数据、索引、inode表、段使用情况表，2.在固定的检查点区记录所有有效的inode表和段使用情况表地址以及时间戳等。为了应对检查点过程中的系统崩溃，实际有两个检查点区交替更新。由于时间戳是检查点最后更新的内容，每次重启后只需选择最新的检查点区即可保证有效性。在恢复到检查点后，还可根据日志记录继续前向恢复（roll-forward）数据。F2FS就针对单个文件的fsync实现了前向恢复能力，fsync时只需落盘文件数据和其直接索引。
除了超级块和检查点是保存在固定位置的，其他元数据和数据都是异地更新的日志。以更新一个文件的内容为例：先写入文件数据内容，再更新各级索引块，最后还要更新Inode Map。这种更新数据带来的索引数据更新问题被形象的称为“滚雪球效应”（英文语境中为：Wandering Tree），这也是日志结构文件系统的另一大问题。
图3日志结构文件系统索引结构和数据更新示意图
接下来的部分，我们先看F2FS如何在空间布局和索引结构上解决“滚雪球”效应，再看基于空间布局的冷热分离和垃圾回收算法如何减少回收代价以及块分配策略对碎片化后写性能的改善。
空间布局和索引结构 F2FS的空间布局在设计上试图匹配闪存存储内部的组织和管理方式。如下图所示，整个存储空间被化分为固定大小的Segment。Segment是F2FS空间管理的基本单元，也确定了文件系统元数据的初始布局。一定数量连续的Segment组成Section,一定数量连续的Section组成Zone。Section和Zone是F2FS日志写入和清理的重要单元，通过配置合适的Section大小可以极大地减少FTL层面垃圾回收的开销。
图4 F2FS空间布局
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e0dc442ce3ddf236d3a14b7d9d14c6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4126c398d4f07c4c99e725b57b47dde9/" rel="bookmark">
			ElasticSearch7.3在Windows系统的环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装ElasticSearch7.3 1、下载ElasticSearch7.3
百度搜索ElasticSearch官网或者直接去官网下载，地址https://www.elastic.co/cn/downloads/elasticsearch
版本7.3，windows环境
但是， 注意！！！我们ES默认是最新版本7.5.2，这个版本跟我们后面需要的IK插件最新版本7.5.1不兼容，我们的ES需要下载7.5.1版本跟我们的IK版本一致才行！ 我们需要找到过去的版本
在第一个下拉框选择ES，页面自动过滤搜索出ES的所有版本，这里我们选择7.5.1版本，点击右侧的download下载
这里是
2、安装ElasticSearch
下载完毕，直接解压，进入路径bin目录下，直接双击运行elasticsearch.bat。
首先会检测你本机的jdk环境，7.3使用的是jdk11，我本机的是1.8.
7.3版本自带了jdk，所以此时es用的是自带的jdk环境，路径在安装路径的 elasticsearch-7.3.0/jdk 路径下。
这个时候不需要做任何操作，es自己判断，直接启动了。如图：
这个时候使用浏览器访问地址 http://localhost:9200/ 可一看到es的当前环境信息，表明已经成功启动了。
3、ElasticSearch安装为Windows服务【如果在服务中能发现ES服务，这步可以跳过】
elasticsearch的bin目录下有一个elasticsearch-service.bat
进入bin目录，在上面地址栏输入cmd
在cmd中输入：elasticsearch-service.bat install
安装服务后，启动任务管理器中的服务，找到elastcisearch右击选中开始，就能把服务启动了
elasticsearch-service.bat 后面还可以执行这些命令
install: 安装Elasticsearch服务
remove: 删除已安装的Elasticsearch服务（如果启动则停止服务）
start: 启动Elasticsearch服务（如果已安装）
stop: 停止服务（如果启动）
manager:启动GUI来管理已安装的服务
三、安装kibana Kibana是一个开源的分析和可视化平台，设计用于和Elasticsearch一起工作。你用Kibana来搜索，查看，并和存储在Elasticsearch索引中的数据进行交互。你可以轻松地执行高级数据分析，并且以各种图标、表格和地图的形式可视化数据。Kibana使得理解大量数据变得很容易。它简单的、基于浏览器的界面使你能够快速创建和共享动态仪表板，实时显示Elasticsearch查询的变化。
接下来，需要安装kibana，官网给出了地址https://www.elastic.co/guide/en/kibana/7.3/install.html，此时选择windows版本，https://www.elastic.co/guide/en/kibana/7.3/windows.html，
下载路径https://artifacts.elastic.co/downloads/kibana/kibana-7.3.0-windows-x86_64.zip
下载完毕后解压，进入bin目录，直接运行kibana.bat
因为7.3版本不需要手动安装sense插件之类的，kibana自带有图形化的界面。
浏览器输入地址http://localhost:5601，直接进入图形化界面
左侧边栏有各种功能，其中DevTools，就可以代替Sense插件。
四、安装 elasticsearch-analysis-ik 接下来，安装分词插件elasticsearch-analysis-ik，
在GitHub上下载对应的7.3版本https://github.com/medcl/elasticsearch-analysis-ik/releases，
下载地址https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.3.0/elasticsearch-analysis-ik-7.3.0.zip
下载完毕直接解压
然后在es的安装目录plugin下创建文件夹analysis-ik(可以随意命名)，将加压完的文件夹的内容放进去。
这时，只需要重启就可以了，和之前的版本不用，不需要配置elasticsearch-7.3.0\config\elasticsearch.yml文件，重启完毕自动加载。
安装完毕。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7821da9885cb24f252128f60cf8a1e84/" rel="bookmark">
			15年&#43;码龄，用过的所有笔记本电脑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		15+年来，电脑用了确实不少，有各种台式机，也接触过多种服务器。
今天我们只说笔记本，讲一讲对笔记本的深情！
第一台是方正颐和系列，样子大概是图片这样，而外观颜色是银色，银色图片已经找不到，用结构相似的图片做下展示。
陪伴我很长时间，包括整个大学时期和刚毕业的几年。
他的外观和名字一样方正，当时还没流行宽屏，14#普通屏幕是主流。
他陪伴了我的整个大学时期，最美好的青春年华，感情很深。
也是最结实耐用的，外壳被摔坏，网卡被雷电击坏，甚至后来屏幕也坏了，淘宝买的屏幕自己换后继续使用。
也被我拆开过无数次，但是始终能正常工作，直到后来实在太慢，无法使用。
当时的配置是256M内存+40G硬盘，在软盘的年代配置已经是很高了。
当时的java版本还是1.4，Jbuilder是最好的IDE。
在这台电脑上玩过游戏、编译过linux、尝试学习各种语言、安装过黑苹果等等。。。
第二台是HP笔记本电脑，用自己的工资买的，我当时挺喜欢它，它的生命很短暂，在意外中损坏。
第三台是MAC Book Air，公司给配的，用来开发公司IOS App。当时刚刚兴起MAC笔记本，大家还不习惯。
但是对我来说是惊喜，很轻薄，电池也很给力。磁吸充电充满创意，再也不怕伴着充电线了。
Magic Mouse是可以换电池的。
第四台是一台旧的13#小红帽，ThinkPad没被联想收购前的版本，据说新本买来的价格要3W+¥，那时通货膨胀还没现在厉害，真是价格不菲，X安全架构，硬盘浮动技术，等等黑科技于一身。
键盘的手感真的很好。不过二手本用来开发JAVA还是有点吃力。
买了它是满足了自己的情怀，但是实际上用途并不大，大概可以用来做个网络设备做个下载机器之类的。
第五台是仍然是一台HP电脑，15#，hp好像外观一直变化不大，缺点是发热量很大，之所以买，是因为接触的很多电脑就是HP。
每次码代码时，收托部分都很烫手。后来同事想要个笔记本给孩子看动画，就卖给她了，也算是物尽其用。
第六台是MAC Book Pro 15#，目前也是我的主力笔记本电脑。作为处女座，对电脑始终很挑剔，以上的笔记本其实都觉得不完美。
遇到这台电脑后，我的挑剔变得少了。
视网膜显示几乎完美，16G内存跑JAVA也很轻松，相见恨晚，命令行工具接近linux，使用方便。
系统很少关机，几秒进入工作状态。。。
第七台，计划中下一台，16#Mac Book Pro。上一台MAC电脑用的很好，我还会继续用下去。
很幸运的错过了MBP键盘的蝶式键盘这一代，16#Mac Book Pro又回归到剪刀式，跟我现在的MBP基本一样。
下一个本毫无疑问，还是MBP。已经习惯了，而且和我的IPHONE配合的很好。
全文结束
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ef46d353f37f44d607ad0fcebfdb832/" rel="bookmark">
			用什么方法将BitConverter.ToString产生字符串再转换回去
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来自森大科技官方博客
http://www.cnsendblog.com/index.php/?p=334
GPS平台、网站建设、软件开发、系统运维，找森大网络科技！
http://cnsendnet.taobao.com
byte[] bytTemp = System.Text.Encoding.Default.GetBytes(“String”);
string str = System.BitConverter.ToString(bytTemp);
Console.WriteLine(str);
string[] strSplit = str.Split(’-’);
byte[] bytTemp2 = new byte[strSplit.Length];
for (int i = 0; i &lt; strSplit.Length; i++)
bytTemp2[i] = byte.Parse(strSplit[i], System.Globalization.NumberStyles.AllowHexSpecifier);
string str2 = System.Text.Encoding.Default.GetString(bytTemp2);
Console.WriteLine(str2);
来自森大科技官方博客
http://www.cnsendblog.com/index.php/?p=334
GPS平台、网站建设、软件开发、系统运维，找森大网络科技！
http://cnsendnet.taobao.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eec3b8f562897218d5bbdb5b379657ab/" rel="bookmark">
			Nodejs fs模块方法图鉴
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/216f9de0eb30d76f80b2bf341e471726/" rel="bookmark">
			Idea 发布最适合程序员的字体!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为 编译期界的大佬, JetBrains公司一直致力于提供更好的编码环境.
前两天, JetBrain推出了一个新的字体 JetBrain Mono. 号称是最适合程序员的编码的字体, 我赶紧尝了尝鲜, 体验了一天之后发现确实好看, 因此推荐给大家.
首先是官网 JetBrain Mono字体.
看一下官方的示例:
.
是不是看起来很棒, 怎么安装呢?
如果你的IDEA 是2019.3 之后的版本, 那么会自带这个, 直接进入Preference-&gt;font, 选择Jetbrain Mono即可. 当然你可以自己安装. 进入官网, 找到安装教程.也就是下面的画面, 之后按照教程进行下载-&gt;解压-&gt;全选-&gt;双击就完事了.
之后重启IDEA, 进入字体设置, 选择 JetBrain Mono即可.
.
个人体验来讲还是特别香的, 建议诸位同学可以都尝试一下~. 我要去给我的VS code 也装上了.
完。
联系我 最后，欢迎关注我的个人公众号【 呼延十 】，会不定期更新很多后端工程师的学习笔记。
也欢迎直接公众号私信或者邮箱联系我，一定知无不言，言无不尽。
以上皆为个人所思所得，如有错误欢迎评论区指正。
欢迎转载，烦请署名并保留原文链接。
联系邮箱：huyanshi2580@gmail.com
更多学习笔记见个人博客或关注微信公众号 &lt;呼延十 &gt;------&gt;呼延十
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecd1a79a24d7d0124af829b4cd058a14/" rel="bookmark">
			使用Nodejs完成文件操作代码集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nodejs实现文件操作的代码集合 最近有一个小项目需要做一个桌面程序，所用使用了 Electron-vue + nodejs进行开发，借此机会学习了一下nodejs的一些操作，因为以前长时间做后端工作，对于nodejs也是只是了解，没有正儿八经的使用过，这里就总结一下自己写的一些文件操作代码，留个备份吧~
注意：下面方法中会出现相互引用的情况，所以如果那个方法中引用了其他方法，可查询一下，都在这里。 引用的包 const fs = require("fs-extra"); const path = require("path"); const join = require("path").join; const request = require("request"); const compressing = require("compressing");	// 用于文件压缩 const pump = require("pump");	// 用于文件压缩 自定义日志 /** * 自定义log，一个简单的日志定义，在测试时会打开，发布时会关闭，下面代码中用到的打印日志用的这个的方法 */ const customLogSwitch = true; export function logger(msg) { if (customLogSwitch) { console.log(msg); } } 判断是否为文件 /** * 判断是否为文件 * @param filePath 文件路径 * @return Boolean */ export function isFile(filePath) { let stats = fs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecd1a79a24d7d0124af829b4cd058a14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/170ef6f3f4c7d861d9a7fb1989a24026/" rel="bookmark">
			Redis系列(九)底层数据结构之五种基础数据类型的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言定义字符串对象 intrawembstr浮点数如何保存？编码转换条件总结 列表对象 总结 集合对象 intsethashtable总结 有序集合对象 ziplist 编码skiplist 编码总结 散列对象 ziplist 编码hashtable 编码总结 全文总结参考文章联系我 前言 Redis 已经是大家耳熟能详的东西了，日常工作也都在使用，面试中也是高频的会涉及到，那么我们对它究竟了解有多深刻呢？
我读了几本 Redis 相关的书籍，尝试去了解它的具体实现，将一些底层的数据结构及实现原理记录下来。
本文将介绍 Redis 中 五种基础数据类型 的实现方法。 这五种基本类型基本覆盖了我们业务中使用的 80%的场景，对面试也覆盖至少 90%.（其中重点当然是有序集合以及散列结构咯）.
定义 在前面的八篇文章中，我们详细的介绍了 Redis 中的 8 种基本数据结构，但是众所周知，Redis 常用的数据类型有五种。包括，字符串，列表，集合，有序集合，哈希。
而这五种数据类型，底层就是用前面介绍的数据结构实现的，当然，并不是直接一对一的绑定关系，而是采用了精妙的设计，构建了一个对象系统。
熟悉 OOP 编程的读者，可能很快就能想到为什么要这么设计了，对象系统带来的好处是非常多的，但是并不在这一篇文章中讲。这里只是提到对象系统，让大家对于五种数据类型为什么可以用一些花里胡哨的方法来实现，有一个初步的了解。
接下来将逐一分析五种数据类型的底层实现数据结构，及实现方式（编码）之间的切换条件。
注：后续提到五种数据类型，用 xx 对象来指代。比如 字符串对象，列表对象。提到的底层数据结构，用全称来讲。
字符串对象 涉及到的数据结构，SDS, 强烈建议阅读本系列第一篇文章。
字符串对象的底层实现有三种可能：int, raw, embstr.
int 如果一个字符串对象，保存的值是一个整数值，并且这个整数值在 long 的范围内，那么 redis 用整数值来保存这个信息，并且将字符串编码设置为 int.
比如：
raw 如果字符串对象保存的是一个字符串, 并且长度大于 32 个字节，它就会使用前面讲过的SDS（简单动态字符串）数据结构来保存这个字符串值，并且将字符串对象的编码设置为raw.
embstr 如果字符串对象保存的是一个字符串, 但是长度小于 32 个字节，它就会使用embstr来保存了，embstr编码不是一个数据结构，而是对 SDS 的一个小优化，当使用 SDS 的时候，程序需要调用两次内存分配，来给 字符串对象 和 SDS 各自分配一块空间，而embstr只需要一次内存分配，因为他需要的空间很少，所以采用 连续的空间保存，即将 SDS 的值和 字符串对象的值放在一块连续的内存空间上。这样能在短字符串的时候提高一些效率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/170ef6f3f4c7d861d9a7fb1989a24026/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2313c3cf552444b1eef5669c7e249292/" rel="bookmark">
			数塔问题（递推算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【题目描述】 如例所示一个数字三角形，计算从顶到底的某处的一条路径，使该路径所经过数字总和最大。
1.一步可延左斜线向下或延右斜线向下走；
2.三角形行数小于等于100；
3.三角形中数字为0，1，2，……，99；
例： 7 3 8
8 1 0
2 7 4 4
4 5 2 6 5
【输入】 第一行输入n，表示输入n行三角形，第二行到n+1行，输入三角形每行数字。
【输出】 一行，数字总和。
【分析】 吐槽信息奥赛这本教材→_→
这道题应该怎样思考呢？
首先想他是要选择最长路径，第一个想法是遍历每条路径然后比较，思路没毛病，就是想怎么实现。该题是运用递推的方法，从倒数第二行开始，每个元素，看下方两步哪个大，加到该行该元素上，一直到第一行，就已经计算好总和了。
即a[i][j] (i行第j个元素) = max{a[i+1][j],a[i+1][j+1]}，最后求出来a[1][1]即最大值。
【源代码】 #include &lt;iostream&gt; using namespace std; int main() { int n,i,j,a[101][101]; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=i;j++) cin &gt;&gt; a[i][j]; for(int i=n-1;i&gt;=1;i--) for(int j=1;j&lt;=i;j++) { if(a[i+1][j]&gt;=a[i+1][j+1]) a[i][j] += a[i+1][j]; else a[i][j] += a[i+1][j+1]; } cout &lt;&lt; a[1][1] &lt;&lt;endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f559808b011e5c442f7c243bf6d81921/" rel="bookmark">
			PDF文件转成图片保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最新版访问：https://blog.csdn.net/wmf_helloWorld/article/details/107105353
1、根据文件路径获取文件，并将PDF文件的每一页转换为一个图片。其中要将图片转为base64格式的。
/** * &lt;p&gt;Description PDF文件转成图片&lt;/p&gt; * @author wumf * @date 2020年1月20日 上午11:00:47 * @param PdfFilePath PDF文件路径 * @param fileImageList 存放图片文件 * @param dpi 越大越清晰，转换也越慢 * @return 文件页数 * @throws CodeException */ public int pdfTurnImage(String pdfFilePath, List&lt;String&gt; fileImageList, int dpi) throws CodeException { File file = new File(pdfFilePath); PDDocument pdDocument; int pages = 0; try { pdDocument = PDDocument.load(file); PDFRenderer renderer = new PDFRenderer(pdDocument); PdfReader reader = new PdfReader(pdfFilePath); pages = reader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f559808b011e5c442f7c243bf6d81921/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7468472715bd60ad043087e0217ada54/" rel="bookmark">
			VMware workstation 14.1.8 pro 下载地址 14最新版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware Workstation 14.1.8 Pro
发布于2019年11月12日
官网下载地址如下：
https://download3.vmware.com/software/wkst/file/VMware-workstation-full-14.1.8-14921873.exe
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edb663925614fc392eb5bbe338125d6d/" rel="bookmark">
			【红日Day13-CTF】特殊WAF SQL注入绕过
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		练习记录 复现代码： index.php
&lt;?php require 'config.php'; function dhtmlspecialchars($string) { if (is_array($string)) { foreach ($string as $key =&gt; $val) { $string[$key] = dhtmlspecialchars($val); } } else { $string = str_replace(array('&amp;', '"', '&lt;', '&gt;', '(', ')'), array('&amp;amp;', '&amp;quot;', '&amp;lt;', '&amp;gt;', '（', '）'), $string); if (strpos($string, '&amp;amp;#') !== false) { $string = preg_replace('/&amp;amp;((#(\d{3,5}|x[a-fA-F0-9]{4}));)/', '&amp;\\1', $string); } } return $string; } function dowith_sql($str) { $check = preg_match('/select|insert|update|delete|\'|\/\*|\*|\.\.\/|\.\/|union|into|load_file|outfile/is', $str); if ($check) { echo "非法字符!"; exit(); } return $str; } // 经过第一个waf处理 foreach ($_REQUEST as $key =&gt; $value) { $_REQUEST[$key] = dowith_sql($value); } // 经过第二个WAF处理 $request_uri = explode("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edb663925614fc392eb5bbe338125d6d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/448/">«</a>
	<span class="pagination__item pagination__item--current">449/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/450/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>