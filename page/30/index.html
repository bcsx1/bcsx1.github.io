<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7723a217b85fe30c3886f524b148fec/" rel="bookmark">
			基于 Webpack 插件体系的 Mock 服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 在软件研发流程中，对于前后端分离的架构体系而言，为了能够更快速、高效的实现功能的开发，研发团队通常来说会在产品原型阶段对前后端联调的数据接口进行结构设计及约定，进而可以分别同步进行对应功能的实现，提升研发速率。除了常见的研发流程提效之外，对于一些特殊的无法满足前后端联调场景下，也可在条件不允许的情况下进行 Mock 处理，等待条件满足后再进行真实的接口联调，如：网络不通、多地协同等。本文从前端研发过程中的 Mock 需求场景出发，结合前端业界通用的 Webpack 工程化的方案来提供 Mock 服务，以期能够给读者提供一些 Mock 工程化的实现方案借鉴。
架构 对于绝大多数业务开发而言，在目前成熟的生产实践中，前端开发团队仍然是以Webpack作为前端工程打包构建的主流工具。因而，对于前端 Mock 服务的工程化方案而言，前端工程架构基建团队提供适配Webpack体系的插件方案是一个不错的工程基建选择。虽然各方前端团队都以各大框架或者框架生态的脚手架方案进行构建，但大部分现有生态工程打包器底层仍然是以Webpack为主，如：@vue/cli、umi、create-react-app等。
对于Webpack插件，其本质是一个类（ps：更准确的说是函数，JavaScript 中没有真正意义上的类），需要在类中定义apply方法，用于通过compiler对象挂载Webpack的事件钩子，该回调中可以获取到当前编译的compilation对象以及异步的callback。Webpack提供了丰富的插件入口，并通过tapable钩子事件系统，串联起整个Webpack钩子函数的生命周期流程。对于 Mock 服务而言，其实现的核心思路是在compiler的钩子watchRun进行 Mock 服务器的启动与监听，其 Mock 服务器可以是基于koa或者express的 node 服务器。
注意：在自定义 Webpack 插件时，Webpack4 和 Webpack5 中的守护进程模式、异步加载、定义全局变量、访问实例对象、事件监听器等方面均有所变化，需要开发者进行相应的兼容处理。
目录 ├─ lib // Mock服务的核心包 | ├─ app.js | ├─ utils.js ├─ index.js // MockServiceWebpackPlugin插件导出 实践 对于项目工期较紧且某一时间段内无法进行前后端联调的场景下，业务开发下的实践可通过引入mock-service-webpack-plugin的插件进行前端 Mock。由于团队是基于 Vue 全家桶进行的业务开发，故而本实践案例以@vue/cli脚手架方案作为工程基建的底座来对业务中的某一个接口联调进行介绍。
在 Vue 脚手架配置中引入mock-service-webpack-plugin插件，对configureWebpack字段进行配置，代码如下：
const path = require("path"); const resolve = (dir) =&gt; path.join(__dirname, dir); const MockServiceWebpackPlugin = require("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7723a217b85fe30c3886f524b148fec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/226f035e08abe64d0f27854f6937d102/" rel="bookmark">
			前端工程注入版本号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、`webpack`三、`vite`四、最后 一、前言 容器化时代，当页面出现问题时，如果你的新版本有可能已经修复了，那样你再排查它就没有意义了。为什么不一定是最新版本呢？一是可能是缓存作祟，二是可能运维成员由于某种原因回退了版本。
怎么确认问题发生在哪个版本呢？这就需要我们往页面注入版本号。
通常这一步，是在打包构建时，将package.json中的version字段注入到html上（所以要求每次发布版本，都修改对应的version，最好使用npm version命令操作）。我比较推荐在head中添加一个meta，当然你也可以将它打印出来。
二、webpack 以React的脚手架搭建出来的工程为例，核心是html-webpack-plugin这个插件。
使用npm run eject之后，修改config/webpack.config.js文件，添加一句：
// 放在const paths = require("./paths");之后。这句就是读取了package.json文件 const appPackageJson = require(paths.appPackageJson); 搜索HtmlWebpackPlugin，找到这段代码：
plugins: [ // Generates an `index.html` file with the &lt;script&gt; injected. new HtmlWebpackPlugin( Object.assign( {}, { inject: true, template: paths.appHtml, }, ... ))] 修改Object.assign的第一个参数：
Object.assign( { meta: { version: appPackageJson.version, }, }, { inject: true, template: paths.appHtml, }, ) 这样，页面的head中就有了版本号：
不使用eject当然也是可以的，有脚手架提供的钩子函数，原理一样，都是修改这里，就不赘述了。
三、vite 对于vite项目，可以使用vite-plugin-html-template插件。在vite.config.ts中添加以下代码：
import htmlTemplate from 'vite-plugin-html-template' import { version } from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/226f035e08abe64d0f27854f6937d102/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7abf35fcefe0d99311a16dba8d621aad/" rel="bookmark">
			音视频转码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 音视频转码是指：
容器中音视频数据编码方式转换，如由H.264编码转成mpeg-4编码，mp3转成AAC；音视频码率的转换，如4Mb视频码率降为2Mb，视频分辨率的转换，如1080P转换为720P，音频重采样等 音视频转码一般过程是先解码再编码，方式可以是通过软件解码和编码（俗称软解软编），亦可以是通过硬件解码和编码（俗称硬解硬编）。视频解码一般是解码为YUV格式，音频解码一般是解码为PCM格式。
什么叫视频？
当连续的图像变化每秒超过24帧以上，根据视觉暂留原理，人眼无法辨别单幅的静态画面，看上去是平滑连续的视觉效果，这样的连续的画面就叫视频。
根据视频定义，我们不难理解，在视频数据中往往在时间域和空间域层面都存在大量冗余信息，而压缩技术就是去掉当中的冗余信息。
视频编码就是通过特定的压缩技术，将某个视频格式文件转换成另一种视频格式。
去除时间域的冗余信息主要包括：运动估计，运动补偿；去除空间域冗余信息主要包括变换编码、量化编码、熵编码。
运动补偿是通过先前的局部图像来预测、补偿当前的局部图像，这样可以有效减少帧序列冗余信息；运动估计是指从视频序列中抽取运动信息，通用的压缩标准使用基于块的运动估计和运动补偿。运动表示不同区域的图像使用不同的运动向量来描述运动信息，运动向量通过熵编码进行压缩，熵编码在编码过程中不会丢失信息变换编码是指将空间域的信息转换到另一正交向量空间，使相关性下降，数据冗余度减少。 未编码的数字视频的数据量很大，存储和传输都比较困难。据说一部90分钟的电影就大到1000GB，1s的视频大小就有186多MB，所以必须经过编码压缩之后才方便存储、方便网络上传输。
音视频转码就是将已压缩编码的音视频码流转换成另一种格式的码流，以适应不同的网络带宽、不同的终端处理能力和不同的用户需求。音视频转码都是先解码再编码的过程。转换前后的码流可能遵循不同的视频编码标准，可能会改变视频数据现有的码流和分辨率。音视频转码可能会涉及以下几个方面：
容器格式的转换，如mp4转换为mov容器中的音视频数据编码方式转换，如H.264编码转换成MPEG-4编码，MP3编码转换成AAC编码音视频码率的转换，如4Mb的视频码率降为2Mb视频分辨率的转换，如1080P转换为720P 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b987f840b8cb99651e2cd4e323841ad/" rel="bookmark">
			[交互]交互的实战问题2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[交互]交互的实战问题2 axios升级导致的问题axios 设置请求 header 方式 多页签时，切换页签是否应该取消交互请求 axios升级导致的问题 axios 设置请求 header 方式 axios 早期设置请求 header 方式
config.headers.common.set('Pragma', 'no-cache') 有一天发现该方式突然不生效了，最后发现是升级axios导致的
axios 设置请求 header 方式的"^1.1.2" 版本
config.headers["Pragma"] = "no-cache"; 多页签时，切换页签是否应该取消交互请求 首先需要确定我们的项目是不是允许缓存的，这与项目中页面是否为微服务并无关系
如果是不允许缓存，那么可以在切换页签时直接取消未完成的交互，因为下次再打开此页面的时候,需要重新发起所有的交互，所以不论是不是微服务都需要重新发起交互。
如果允许缓存，那么可以在切换页签后，页面需要展示上次的操作结果，如果直接取消未完成的交互会导致展示数据不正确，因为再次打开此页面的时候,需要展示上次交互的结果，因此也与是否是微服务没有关系
交互是否取消只与是否缓存有关系
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fe497daf35e23b7328e21ab0e76137c/" rel="bookmark">
			AI智能体的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近几个月
随着大语言模型的持续火爆
利用大模型来构建AI智能体的研究呢
也陆续进入了人们的视野
AI智能体这个概念呢
也逐渐的流行开来
先是斯坦福大学谷歌的研究者们
成功的构建了一个虚拟小镇
小镇上的居民呢不再是人
而是25个AI的智能体
他们的行为呢
比人类角色扮演更加真实
甚至还举办了一场情人节的派对
随后
商汤清华等机构提出了能够自主学习
解决任务的通才AI智能体GITM
在我的世界中比以往所有的智能体
都更有优秀的表现
同一时间
英伟达开元的Voyager
也给AI圈带来了不小的震撼
作为一个大模型驱动
可以终身学习的游戏智能体
Voyager在我的世界中玩出了很高的水平
这些AI智能体的先后涌现
甚至让人认为
是未来通用人工智能AGI的雏形
很多AI领域的大佬和科技巨头
对AI智能体的发展
都产生了极大的兴趣
并寄予了厚望
今年年初回归OpenAI的安德烈卡帕西
在OpenAI的黑客马拉松活动上就透露
每当有新的AI智能体论文出现的时候
OpenAI内部呢就会感到非常的有兴趣
并且认真的进行讨论
那么我们不禁要问
到底什么是AI智能体
它由哪些部分组成
它的神奇之处又具体表现在哪些方面呢
近日OpenAI安全系统的负责人Lilian Weng
就写了一篇关于AI智能体的博客
首先简单介绍一下作者啊
Lilian Weng是2018年加入的OpenAI
在GPT4项目中
主要参与一训练强化学习和对齐
模型安全等方面的工作
那在她的这篇博客文章中呢
她就认为AI智能体的核心驱动力是大语言模型
而规划planning
记忆memory和工具使用Tool use
是实现它的三个关键组件
Lilian Weng对每个组件都展开了详细的剖析
并且提供了一些案例的研究
比如说科学发现智能体
生成式智能体模拟和概念验证的示例
对于AI智能体未来将面临哪些挑战呢
他也给出了自己的观点
我对文章的内容呢做了一些提炼
在这里跟大家分享一下
有兴趣的同学
可以去详细阅读一下原文
首先Lilian介绍了一下智能体系统的概念
在大语言模型赋能的自主智能体系统中
大语言模型充当了智能体的大脑
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fe497daf35e23b7328e21ab0e76137c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b086e7c5612bb06d009cda3be0386bdb/" rel="bookmark">
			web前端之拖拽API、vue3实现图片上传拖拽排序、拖放、投掷、复制、若依、vuedraggable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MENU vue2+html5+原生dom+原生JavaScript实现跨区域拖放vue2实现跨区域拖放vue2+mousedown实现全屏拖动，全屏投掷vue3+element-plus+vuedraggable实现图片上传拖拽排序vue2+transition-group实现拖动排序原生拖拽排序 vue2+html5+原生dom+原生JavaScript实现跨区域拖放 关键代码
// 放 function drop(ev) { let data = ev.dataTransfer.getData("Text"), i = ev.path[1].getAttribute("i"), text = document.getElementById(data).cloneNode(true).innerText.trim(); if (i == null) return alert('请放置在文件名上'); if (app.fileS[i].divs.includes(text)) return alert('不能放重复数据'); app.fileS[i].divs.push(text); for (let is = 0; is &lt; app.fileS.length; is++) { if (i == is) { app.fileS[is].isShow = true; } else { app.fileS[is].isShow = false; } } } 完整代码
gitee(码云) - mj01分支 - copyDragAndDrop 文件
vue2实现跨区域拖放 关键代码
dragend(item) { console.log(item); if (this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b086e7c5612bb06d009cda3be0386bdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3f9ca6d019f2e26674e432905a0a8c4/" rel="bookmark">
			案例144:基于微信小程序的自修室预约系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：SSM
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
管理员模块的实现
学生信息管理
公告通知管理
自修室管理
座位预约管理
小程序学生模块的实现
学生注册
小程序首页
我的
自习室预约
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 随着信息技术在管理上越来越深入而广泛的应用，管理信息系统的实施在技术上已逐步成熟。本文介绍了基于微信小程序的自修室预约系统的开发全过程。通过分析基于微信小程序的自修室预约系统管理的不足，创建了一个计算机管理基于微信小程序的自修室预约系统的方案。文章介绍了基于微信小程序的自修室预约系统的系统分析部分，包括可行性分析等，系统设计部分主要介绍了系统功能设计和数据库设计。
本基于微信小程序的自修室预约系统有管理员和学生两个角色。管理员功能有个人中心，学生管理，公告通知管理，自修室管理，座位预约管理，预约取消管理，管理员管理，系统管理等。学生角色有，查看公告通知，查看自修室，预约和取消自修室等功能。因而具有一定的实用性。
本站后台采用Java的SSM框架进行后台管理开发，可以在浏览器上登录进行后台数据方面的管理，MySQL作为本地数据库，微信小程序用到了微信开发者工具，充分保证系统的稳定性。系统具有界面清晰、操作简单，功能齐全的特点，使得基于微信小程序的自修室预约系统管理工作系统化、规范化。
系统展示 管理员模块的实现 学生信息管理 管理员可以管理学生信息，可以对通过微信小程序端注册的学生信息修改删除。
公告通知管理 管理员可以对线上公告通知进行添加，修改删除查询操作。
自修室管理 系统管理员可以查看自修室，并且可以对自修室的信息进行添加修改删除操作。
座位预约管理 系统管理员可以查看座位预约，并且可以对座位预约信息进行修改删除以及审核操作。
小程序学生模块的实现 学生注册 小程序学生是需要注册才可以进行登录的。界面如下图所示：
小程序首页 小程序首页会显示自修室以及公告通知，通过下滑就可以获取到。界面如下图所示：
我的 小程序最下面是导航模块，点击我的，可以出现关于我的相关功能。界面如下图所示：
自习室预约 小程序最下面是导航模块，点击自习室信息后预约需要输入信息才可以预约。界面如下图所示：
代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3f9ca6d019f2e26674e432905a0a8c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ff30fb25562a24e82da2daded52d34d/" rel="bookmark">
			案例142:基于微信小程序的点餐系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：SSM
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
管理员模块的实现
菜品信息管理
用户信息管理
订单信息管理
用户评价管理
小程序用户模块的实现
系统首页
我的菜单
收藏与预定
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 随着信息技术在管理上越来越深入而广泛的应用，管理信息系统的实施在技术上已逐步成熟。本文介绍了微信点餐系统小程序的开发全过程。通过分析微信点餐系统小程序管理的不足，创建了一个计算机管理微信点餐系统小程序的方案。文章介绍了微信点餐系统小程序的系统分析部分，包括可行性分析等，系统设计部分主要介绍了系统功能设计和数据库设计。
本微信点餐系统小程序管理员功能有个人中心，用户管理，菜品管理，新上菜品管理，预定订单管理，活动信息管理，用户评价管理，系统管理，订单管理等。用户功能有个人中心，订购菜品，我的订单，我的收藏，评价菜品等。因而具有一定的实用性。
本站后台采用Java的SSM框架进行后台管理开发，可以在浏览器上登录进行后台数据方面的管理，MySQL作为本地数据库，微信小程序用到了微信开发者工具，充分保证系统的稳定性。系统具有界面清晰、操作简单，功能齐全的特点，使得微信点餐系统小程序管理工作系统化、规范化。
系统展示 管理员模块的实现 菜品信息管理 管理员可以管理菜品信息，可以对菜品信息添加修改删除。
用户信息管理 管理员可以对用户信息进行添加，查询修改，删除操作。
订单信息管理 系统管理员可以对订单信息发货和查询。界面如下图所示：
用户评价管理 系统管理员可以对用户评价删除操作，还可以查看评论。界面如下图所示：
小程序用户模块的实现 系统首页 小程序用户是需要注册才可以进行登录的，登录后在首页可以搜索菜品名称，以及查看菜品，并且下面导航可以点击到其他功能模块。界面如下图所示：
我的菜单 在小程序里点击我的，会出现关于我的界面，在这里可以修改个人信息，以及可以点击其他功能模块。界面如下图所示：
收藏与预定 在商品详情界面，可以对商品进行收藏和预定操作，点击菜品图片右下角的五角星，是收藏操作，双击是取消，点击页面右下角的预定按钮，会进行预定操作。界面如下图所示：
代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ff30fb25562a24e82da2daded52d34d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4851c7fe82e2894b521697804f160665/" rel="bookmark">
			C&#43;&#43;中的继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.继承的概念及定义
继承的概念
继承的定义
继承关系和访问限定符
​编辑
继承基类成员访问方式的变化
​编辑
二.基类和派生类对象赋值转换
总结：
三.继承中的作用域
四.子类的默认成员函数
五.继承与友元
六. 继承与静态成员
七.菱形继承及菱形虚拟继承
菱形继承
二义性与数据冗余
使用虚拟继承解决菱形继承的二义性与数据冗余
八.继承的总结和反思
3. 继承和组合
一.继承的概念及定义 继承的概念 继承 (inheritance) 机制是面向对象程序设计 使代码可以复用 的最重要的手段，它允许程序员在 保 持原有类(父类，也叫做基类)特性的基础上进行扩展 ，增加功能，这样产生新的类，称派生类(子类)。继承 呈现了面向对象 程序设计的层次结构 ，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用， 继 承是类设计层次的复用。 举例理解： 现在要用C++写一个学校管理系统，在里面有学生类与老师类。根据常识，这些类里均有性别，姓名，年龄等相同的属性，如果在定义类时，把这些在每一个类中都写一份不免会使代码冗余，但这些属性又是不可缺少的。这里C++采用，将两个类里相同的部分（成员变量或函数）提取出来，放到一个新定义的类里（父类）.学生类与老师类通过继承获取父类里的属性。 这里我们把Person类叫做父类（基类）。
Student与Teacher类叫做子类（派生类）
继承的本质可以看成类设计层次的复用。
继承的定义 定义格式：
下面我们看到Person是父类，也称作基类。Student是子类，也称作派生类
继承关系和访问限定符 继承基类成员访问方式的变化 总结：
1. 基类 private 成员在派生类中无论以什么方式继承都是不可见的。这里的 不可见是指基类的私 有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类面 都不能去访问它 。 2. 基类 private 成员在派生类中是不能被访问，如果基类成员不想在类外直接被访问，但需要在 派生类中能访问，就定义为protected 。 可以看出保护成员限定符是因继承才出现的 。 3. 实际上面的表格我们进行一下总结会发现，基类的私有成员在子类都是不可见。基类的其他 成员在子类的访问方式 == Min( 成员在基类的访问限定符，继承方式 ) ， public &gt; protected &gt; private 。 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4851c7fe82e2894b521697804f160665/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3857f90dc456e3fd75840d4e30f8082/" rel="bookmark">
			分布式搜索引擎03
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分布式搜索引擎03 0.学习目标 1.数据聚合 **聚合（aggregations）**可以让我们极其方便的实现对数据的统计、分析、运算。例如：
什么品牌的手机最受欢迎？这些手机的平均价格、最高价格、最低价格？这些手机每月的销售情况如何？ 实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现近实时搜索效果。
1.1.聚合的种类 聚合常见的有三类：
**桶（Bucket）**聚合：用来对文档做分组
TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组 **度量（Metric）**聚合：用以计算一些值，比如：最大值、最小值、平均值等
Avg：求平均值Max：求最大值Min：求最小值Stats：同时求max、min、avg、sum等 **管道（pipeline）**聚合：其它聚合的结果为基础做聚合
**注意：**参加聚合的字段必须是keyword、日期、数值、布尔类型
1.2.DSL实现聚合 现在，我们要统计所有数据中的酒店品牌有几种，其实就是按照品牌对数据分组。此时可以根据酒店品牌的名称做聚合，也就是Bucket聚合。
1.2.1.Bucket聚合语法 语法如下：
GET /hotel/_search { "size": 0, // 设置size为0，结果中不包含文档，只包含聚合结果 "aggs": { // 定义聚合 "brandAgg": { //给聚合起个名字 "terms": { // 聚合的类型，按照品牌值聚合，所以选择term "field": "brand", // 参与聚合的字段 "size": 20 // 希望获取的聚合结果数量 } } } } 结果如图：
1.2.2.聚合结果排序 默认情况下，Bucket聚合会统计Bucket内的文档数量，记为_count，并且按照_count降序排序。
我们可以指定order属性，自定义聚合的排序方式：
GET /hotel/_search { "size": 0, "aggs": { "brandAgg": { "terms": { "field": "brand", "order": { "_count": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3857f90dc456e3fd75840d4e30f8082/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3459882142680d2ef45f94d436a76b94/" rel="bookmark">
			Kafka日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		位置 server.properties配置文件中通过log.dir指定日志存储目录
log.dir/{topic}-{partition}
核心文件 .log
存储消息的日志文件，固定大小为1G，写满后会新增一个文件，文件名表示当前日志文件记录的第一条消息的偏移量。
.index
以偏移量为索引来记录对应的.log日志文件中的消息偏移量
.timeindex
以时间戳为索引来记录对应的.log日志文件中的消息偏移量
partition.metadata
记录当前Partition所属的cluster和Topic
leader-epoch-checkpoint
和epoch机制相关
index和timeindex加速读取log消息日志
index和timeindex都是以相对偏移量的方式建立log消息日志的数据索引。比如 0000.index和0550.index中记录的索引数字，都是从0开始的。表示相对日志文件起点的消息偏移量。而绝对的消息偏移量可以通过日志文件名 + 相对偏移量得到。
这两个索引并不是对每一条消息都建立索引。而是Broker每写入40KB的数据，就建立一条index索
引。
Kafka的消费者通过这两个索引能够指定从某一个offset或者某一个时间点读取消息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee12c4da7658c7192602116b672559e3/" rel="bookmark">
			基于Java (spring-boot)的在线考试管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目介绍
系统功能说明
1、系统共有管理员、老师、学生三个角色，管理员拥有系统最高权限。
2、老师拥有考试管理、题库管理、成绩管理、学生管理四个模块。
3、学生可以参与考试、查看成绩、试题练习、留言等功能
二、作品包含
三、项目技术
后端语言：Java
项目架构：B/S架构
数据库：MySQL
前端技术：Vue
后端技术：Spring Boot
四、运行环境
JDK版本：1.8
操作系统：Window、MacOS
数据库：MySQL8.0
主要开发工具：IDEA
Maven：3.8
node.js
五、运行截图
登录界面
管理员主页面
学生主页面
考试管理
题库管理
成绩查询
学生管理
教师管理
基于Java (spring-boot)的在线考试管理系统一、项目介绍系统功能说明1、系统共有管理员、老师、学生三个角色，管理员拥有系统最高权限。2、老师拥有考试管理https://mp.weixin.qq.com/s/zvaa0fd1jPH_m1R-Xy8KwA
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de0ac5a09c844d2413d2d4866387f651/" rel="bookmark">
			Day69力扣打卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 打卡记录 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c5a7985177e324948d5f25b16283f94/" rel="bookmark">
			STM32f103c8t6 系统结构介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cortex-M3内核引出三条总线：ICode 指令总线、DCode 数据总线、System 系统总线。ICode总线和DCode总线主要用来连接Flash闪存的（Flash里面存储的就是我们编写的程序），ICode指令总线是用来加载程序指令的，DCode数据总线是用来加载数据的（比如常量和调试数据），System总线连接到了SRAM，用于存储程序运行时的变量数据。
AHB：先进高性能总线（挂载主要外设）；APB：先进外设总线
DMA：当作内核CPU的小秘书（用于数据搬运的）
stm32板子引脚名称介绍
1号引脚 VBAT：备用电池供电的引脚（可接一个3V的电池，当系统断电时，备用电池可以给内部的RTC时钟和备份寄存器提供电源）
2号引脚 PC13-TAMPER-RTC：IO口（可以根据程序输出或读取高低电平）或者侵入检测（做安全保障功能）或者RTC（输出RTC校准时钟、RTC闹钟脉冲或者秒脉冲）
3、4号引脚 PC14-OSC32_IN、PC15-OSC32_OUT：IO口或者接32.768KHz的RTC晶振
5、6号引脚 OSC_IN、OSC_OUT：接系统的主晶振，一般是8Hz的（芯片内部有锁相环电路，可以对这个8Hz的频率进行倍频，最终产生72MHz的频率，作为系统的主时钟）
7号引脚 NRST：系统复位引脚（N代表低电平复位的）
8、9号引脚 VSSA、VDDA：内部模拟部分的电源（比如ADC、RC震荡器等），VSS是负极接GND，VCC是正极接3.3V
10~19号引脚 PA0-WKUP、PA1、PA2、PA3、PA4、PA5、PA6、PA7、PB0、PB1：都是IO口（PA0还有WKUP功能，这个可以用于唤醒处于待机模式的STM32）
20号引脚 PB2：IO口或者BOOT1引脚（BOOT引脚是用来配置启动模式的）
21、22号引脚 PB10、PB11：IO口
23~24、35~36、47~48号引脚 VSS_1、VDD_1、VSS_2、VDD_2、VSS_3、VDD_3：系统的主电源口（VSS是负极，VCC是正极）
25~33号引脚 PB12、PB13、PB14、PB15、PA8、PA9、PA10、PA11、PA12：IO口
34、37~40号引脚 PA13、PA14、PA15、PB3、PB4：IO口或者调试端口（调试程序或者下载程序，这STM32支持SWD和JTAG两种调试模式：SWD：SWDIO和SWCLK；JTAG：JTMS、JTCK、JTDI、JTDO、NJTRST）；需在程序中配置才能当做IO口使用
41~43、45~46号引脚 PB5、PB6、PB7、PB8、PB9：IO口
44号引脚 BOOT0：用来做启动配置的
启动配置的作用就是指定程序开始的位置，一般情况下，程序都是在Flash程序存储器开始执行（如下表）
————————————————
转载自csdn：侵删
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4c7a2923a7e985570a7ff225a4758a1/" rel="bookmark">
			MATLAB遗传算法工具箱的三种使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB中有三种调用遗传算法的方式： 一、遗传算法的开源文件 下载“gatbx”压缩包文件，解压后，里面有多个.m文件，可以看到这些文件的编辑日期都是1998年，很古老了。
这些文件包含了遗传算法的基础操作，包含创建种群、适应度计算、选择函数、变异算子、交叉算子、子种群的支持等各种经典功能，适合入门遗传算法这套优化方法的人深入学习及理解，各文件的详细功能见下表：（想要“gatbx”压缩包文件的人，我可以分享压缩包）
缺点： 显然，这种方法需要深入了解上述代码的功能，需要自行对各函数进行取舍，过犹不及。因此，大家往往采用下述集成的工具箱直接计算。
二、遗传算法的GUI操作界面 在MATLAB命令窗内，输入“gatool”，弹出以下界面：
在该页面输入：线性不等式约束（A、b）、线性等式约束（Aeq、beq）、Bound、非线性约束函数、整数变量、初始化种群等信息，然后计算即可。
缺点： 显然，这种方法也存在缺点，即不是代码撰写的方式，不方便运行、修改及调试。因此，更多人采用下述 ga 函数的方式，直接调用该函数，利于集成。
三、遗传算法的命令行调用方法（力荐！） ga 函数的使用方法可在MATLAB命令窗输入 “doc ga” 查看
本文只是三种方法的分类及概述，至于详细的 ga 函数的使用方法和细则，参见本人的后续博客。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd39957fb5d5599ef567fe392eb406fa/" rel="bookmark">
			RocketMQ实践：确保消息不丢失与顺序性的高效策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用RocketMQ如何保证消息不丢失？ 这个是在面试时，关于MQ，面试官最喜欢问的问题。这个问题是所有MQ都需要面对的一个共性问
题。大致的解决思路都是一致的，但是针对不同的MQ产品又有不同的解决方案。分析这个问题要从以 下几个角度入手：
1、哪些环节会有丢消息的可能？ 我们考虑一个通用的MQ场景：
其中，1,2,4三个场景都是跨网络的，而跨网络就肯定会有丢消息的可能。
然后关于3这个环节，通常MQ 存盘时都会先写入操作系统的缓存page cache中，然后再由操作系统异 步的将消息写入硬盘。这个中间有个时间差，就可能会造成消息丢失。如果服务挂了，缓存中还没有来 得及写入硬盘的消息就会丢失。
这个是MQ场景都会面对的通用的丢消息问题。那我们看看用Rocket 时要如何解决这个问题
2、RocketMQ 消息零丢失方案 1》生产者使用事务消息机制保证消息零丢失 这个结论比较容易理解，因为RocketMQ 的事务消息机制就是为了保证零丢失来设计的，并且经过阿里 的验证，肯定是非常靠谱的。
但是如果深入一点的话，我们还是要理解下这个事务消息到底是不是靠谱。我们以最常见的电商订单场 景为例，来简单分析下事务消息机制如何保证消息不丢失。我们看下下面这个流程图：
1、 为 什 么 要 发 送 个half 消 息 ? 有 什 么 用 ?
这个half消息是在订单系统进行下单操作前发送，并且对下游服务的消费者是不可见的。那这个消息的 作用更多的体现在确认RocketMQ的服务是否正常。相当于嗅探下RocketMQ服务是否正常，并且通知 RocketMQ，我马上就要发一个很重要的消息了，你做好准备。
2.half消息如果写入失败了怎么办？
如果没有half消息这个流程，那我们通常是会在订单系统中先完成下单，再发送消息给MQ。这时候写 入消息到MQ如果失败就会非常尴尬了。而half消息如果写入失败，我们就可以认为MQ的服务是有问题 的，这时，就不能通知下游服务了。我们可以在下单时给订单一个状态标记，然后等待MQ服务正常后 再进行补偿操作，等MQ服务正常后重新下单通知下游服务。
3.订单系统写数据库失败了怎么办？
这个问题我们同样比较下没有使用事务消息机制时会怎么办？如果没有使用事务消息，我们只能判断下 单失败，抛出了异常，那就不往MQ发消息了，这样至少保证不会对下游服务进行错误的通知。但是这 样的话，如果过一段时间数据库恢复过来了，这个消息就无法再次发送了。当然，也可以设计另外的补 偿机制，例如将订单数据缓存起来，再启动一个线程定时尝试往数据库写。而如果使用事务消息机制， 就可以有一种更优雅的方案。
如果下单时，写数据库失败(可能是数据库崩了，需要等一段时间才能恢复)。那我们可以另外找个地方 把订单消息先缓存起来(Redis、文本或者其他方式)，然后给RocketMQ返回一个UNKNOWN状态。这样 RocketMQ就会过一段时间来回查事务状态。我们就可以在回查事务状态时再尝试把订单数据写入数据 库，如果数据库这时候已经恢复了，那就能完整正常的下单，再继续后面的业务。这样这个订单的消息 就不会因为数据库临时崩了而丢失。
4.half消息写入成功后RocketMQ挂了怎么办？
我们需要注意下，在事务消息的处理机制中，未知状态的事务状态回查是由RocketMQ的Broker主动发 起的。也就是说如果出现了这种情况，那RocketMQ就不会回调到事务消息中回查事务状态的服务。这 时，我们就可以将订单一直标记为"新下单"的状态。而等RocketMQ恢复后，只要存储的消息没有丢
失， RocketMQ就会再次继续状态回查的流程。
5.下单成功后如何优雅的等待支付成功？
在订单场景下，通常会要求下单完成后，客户在一定时间内，例如10分钟，内完成订单支付，支付完成
后才会通知下游服务进行进一步的营销补偿。
如果不用事务消息，那通常会怎么办？
最简单的方式是启动一个定时任务，每隔一段时间扫描订单表，比对未支付的订单的下单时间，将超过 时间的订单回收。这种方式显然是有很大问题的，需要定时扫描很庞大的一个订单信息，这对系统是个 不小的压力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd39957fb5d5599ef567fe392eb406fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/650fb2e74e474b90c38837e5b30645d2/" rel="bookmark">
			电子科大系统分析与设计学堂在线期末考试答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 先看答题成绩1~5 题6~10 题11~15 题16~50题 先看答题成绩 1~5 题 1.在类图的几种可视性中，下面哪种可视性的属性或操作对本类和子类可见？C
2.状态机图描述什么场景？D
3.下面哪项不属于系统规划的原则？C
4.针对一个网络订餐系统需求分析，采用下面哪种需求采集方法最合适？B
5.在系统开发的哪个阶段进行架构设计？B
6~10 题 11~15 题 16~50题 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2c78db3d70ebda51aaefc92f5982c9e/" rel="bookmark">
			模式识别与机器学习（九）：Adaboost
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.原理 AdaBoost是Adaptive Boosting（自适应增强）的缩写，它的自适应在于：被前一个基本分类器误分类的样本的权值会增大，而正确分类的样本的权值会减小，并再次用来训练下一个基本分类器。同时，在每一轮迭代中，加入一个新的弱分类器，直到达到某个预定的足够小的错误率或预先指定的最大迭代次数再确定最后的强分类器。
1.算法步骤
首先，是初始化训练数据的权值分布D1。假设有N个训练样本数据，则每一个训练样本最开始时，都会被赋予相同的权值：w1 = 1/N。
训练弱分类器Ci。具体训练过程：如果某个训练样本点，被弱分类器Ci准确地分类，那么再构造下一个训练集中，它对应的权值要减小；相反，如果某个训练样本点被错误分类，那么它的权值就应该增大。权值的更新过的样本被用于训练下一个弱分类器，整个过程如此迭代下去。
最后，将各个训练得到的弱分类器组合成一个强分类器。各个弱分类器的训练过程结束后，加大分类误差率小的弱分类器的权重，使其在最终的分类函数中起着较大的决定作用，而降低分类误差率大的弱分类器的权重，使其在最终的分类函数中起着较小的决定作用。
换而言之，误差率低的弱分类器在最终分类器中占的权重较大，否则较小。
2.算法过程
(1).首先，初始化训练集的权值分布。每个训练样本最开始都被赋予相同的权值： w i = 1 N w_{i}=\frac{1}{N} wi​=N1​这样样本集的权值初始分布为 D 1 ( i ) = ( w 1 , w 2 , ⋯ w N ) = ( 1 N , 1 N , ⋯ 1 N ) D_{1}(i)=(w_{1},w_{2},\cdots w_{N})=\left(\frac{1}{N},\frac{1}{N},\cdots\frac{1}{N}\right) D1​(i)=(w1​,w2​,⋯wN​)=(N1​,N1​,⋯N1​)
(2).进行迭代 t = 1 , 2 , ⋯ , T t=1,2,\cdots,T t=1,2,⋯,T
(a).选取一个当前误差率最低的分类器h作为第t个基分类器H_t，并计算弱分类器h_t在训练集上的分类误差率： e t = ∑ i = 1 m w t , i I ( h t ( x i ) ≠ f ( x i ) ) e_{t}=\sum_{i=1}^{m}w_{t,i}I\big(h_{t}(x_{i})\neq f(x_{i})\big) et​=i=1∑m​wt,i​I(ht​(xi​)=f(xi​))
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2c78db3d70ebda51aaefc92f5982c9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e04cebcfc176bf5c19bed24915267d12/" rel="bookmark">
			IDA7.7绿色版 Python路径错误,相关IDA插件加载失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述:
整理电脑工具时,移动IDA到新的目录下,重启后发现部分插件(keypatch,findcrypto等失效)
通过观察,发现启动后,在输出框发现python版本为3.10.7(自带的py版本为3.8.10)
并且很多插件在这里提示没有找到(实际上这些插件在ida的plugins目录内)
在ida文件夹内,查看使用说明得知,可以使用IDA_initTool修复ida python路径 修复成功后,正常使用keypatch等插件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3443cab0f1e5e2dda7506a26d28f5071/" rel="bookmark">
			计算机毕业设计 基于SpringBoot的房屋租赁管理系统的设计与实现 Java实战项目 附源码&#43;文档&#43;视频讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌从事软件开发10年之余，专注于Java技术领域、Python人工智能及数据挖掘、小程序项目开发和Android项目开发等。CSDN、掘金、华为云、InfoQ、阿里云等平台优质作者✌
🍅文末获取源码联系🍅
👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟
————————————————
计算机毕业设计《1000套》✌
目录
1、项目介绍及开发技术
1.1 项目介绍
1.2 开发技术
2、系统功能设计结构图
3、功能截图
3.1 前台功能
3.2 后台功能
4、数据库表结构设计
5、关键代码
5.1 房源租赁Controller模块 5.2 房源租赁Service模块 5.3 房源租赁ServiceImpl模块
5.4 房源租赁Dao模块
6、论文目录结构
7、源码获取
1、项目介绍及开发技术 1.1 项目介绍 如今社会上各行各业，都喜欢用自己行业的专属软件工作，互联网发展到这个时候，人们已经发现离不开了互联网。新技术的产生，往往能解决一些老技术的弊端问题。因为传统房屋租赁管理系统信息管理难度大，容错率低，管理人员处理数据费工费时，所以专门为解决这个难题开发了一个房屋租赁管理系统管理系统，可以解决许多问题。
房屋租赁管理系统管理系统按照操作主体分为管理员和用户。管理员的功能包括报修管理、字典管理、租房房源管理、租房评价管理、房源租赁管理、租房预约管理、论坛管理、公告管理、投诉建议管理、用户管理、租房合同管理、管理员管理。用户的功能等。
房屋租赁管理系统管理系统可以提高房屋租赁管理系统信息管理问题的解决效率，优化房屋租赁管理系统信息处理流程，保证房屋租赁管理系统信息数据的安全，它是一个非常可靠，非常安全的应用程序。
1.2 开发技术 Java开发语言、SpringBoot、MyBatisPlus、MySQL数据库、Maven、IDEA开发工具、JDK1.8+、Vue、HTML、CSS、JS。
2、系统功能设计结构图 3、功能截图 3.1 前台功能 房源
报修管理
公告管理
3.2 后台功能 租房房屋管理：管理员在房源管理界面中可以对界面中显示，可以对房源信息的房源状态进行查看，可以添加新的房源信息等。
报修管理： 管理员在报修管理界面中查看，新增报修信息等。
投诉建议管理： 管理员在投诉建议管理界面中新增投诉建议，可以删除投诉建议。
公告管理：管理员在公告管理界面查看公告的工作状态，可以对公告的数据进行导出，可以添加新公告的信息，可以编辑公告信息，删除公告信息。
4、数据库表结构设计 CREATE TABLE `baoxiu` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键 ', `yonghu_id` int(11) DEFAULT NULL COMMENT '用户', `baoxiu_uuid_number` varchar(200) DEFAULT NULL COMMENT '报修编号', `baoxiu_address` varchar(200) DEFAULT NULL COMMENT '报修标题 Search111 ', `baoxiu_name` varchar(200) DEFAULT NULL COMMENT '报修位置', `baoxiu_types` int(11) NOT NULL COMMENT '报修类型 Search111 ', `baoxiu_content` longtext COMMENT '报修内容', `baoxiu_money` decimal(10,2) DEFAULT NULL COMMENT '报修费用 ', `insert_time` timestamp NULL DEFAULT NULL COMMENT '报修时间', `baoxiu_zhuangtai_types` int(11) DEFAULT '1' COMMENT '报修状态 Search111 ', `create_time` timestamp NULL DEFAULT NULL COMMENT '创建时间 show3 listShow', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8 COMMENT='报修'; /*Data for the table `baoxiu` */ insert into `baoxiu`(`id`,`yonghu_id`,`baoxiu_uuid_number`,`baoxiu_address`,`baoxiu_name`,`baoxiu_types`,`baoxiu_content`,`baoxiu_money`,`insert_time`,`baoxiu_zhuangtai_types`,`create_time`) values (1,1,'1679554992982','报修标题1','报修位置1',1,'报修内容1','214.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3443cab0f1e5e2dda7506a26d28f5071/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e855e27b5a89032a0d02e7a581ca2a02/" rel="bookmark">
			中伟视界：车辆超速检测AI盒子如何助力智慧园区实现高效管理？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智慧园区是指利用信息技术建设的新一代园区，其以提高管理效率、降低资源消耗、增强服务水平、改善环境质量等为目标。在智慧园区中，车辆超速一直是一个值得重视的问题，超速不仅会影响交通安全，也会对园区内的行人和其他车辆造成不利影响。因此，为了有效监管和管理车辆超速问题，智慧园区常常会引入车辆超速检测AI盒子。
车辆超速检测AI盒子采用了先进的人工智能技术，可以精准检测车辆的速度，并对超速行为进行实时监测和记录。其工作原理是通过摄像头和视频分析技术，实时捕捉车辆的行驶过程，识别车辆的牌照信息和速度，并将超速情况实时传输到监控中心，从而可以及时采取相应的管理措施。与传统的超速检测设备相比，车辆超速检测AI盒子不仅检测更加精准，还可以实现全天候无死角监控，真正实现了智慧园区车辆安全管理的科技化和智能化。
在智慧园区中，车辆超速检测AI盒子的应用是非常广泛的。首先，在园区的主干道和重要路口安装车辆超速检测AI盒子，可以有效监测和管理车辆的行驶速度，避免交通事故的发生，提高园区交通安全水平。其次，在园区的停车场和人员密集区域也可以设置车辆超速检测AI盒子，及时发现超速行为，提醒驾驶员注意行车安全，保障园区内的行人和车辆安全。此外，车辆超速检测AI盒子还可以与园区的车辆管理系统相连，实现车辆超速行为的记录和报警，为园区交通管理部门提供更准确的数据支持，进一步提升管理效率和水平。
除了在智慧园区中的应用，车辆超速检测AI盒子还可以应用于各种道路交通管理场景，比如高速公路、城市主干道、机场、港口等。随着智慧交通建设的不断推进，车辆超速检测AI盒子将在更多的领域发挥重要作用。总的来说，车辆超速检测AI盒子在智慧园区等场景中的应用，有助于提升交通安全和园区管理水平，促进智慧园区建设的可持续发展。
综上所述，车辆超速检测AI盒子在智慧园区等场景中的应用具有重要意义。它不仅可以有效监管车辆超速问题，提升交通安全水平，还可以提高园区管理效率，为智慧园区建设提供有力的技术支持。相信随着技术的不断进步和智慧园区建设的不断完善，车辆超速检测AI盒子的应用将得到进一步扩大和深化，为园区安全管理保驾护航。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d826e4dda6454eb8c76f965fdc464f92/" rel="bookmark">
			ospf学习纪要
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、为避免区域（area0,area1等）间的路由形成环路，非骨干区域之间不允许直接相互发布区域间的路由。因此，所有的ABR（Area Border Router,区域边界路由器）都至少有一个借口属于Area0,所以Area0始终包含所有的ABR
2、OSPF要求ABR只能将自己到达直连区域的区域内部的路由通告给Area0（而不能将自己到达其他区域的区域间路由通告给Area0），另外ABR可以将自己到达直连区域的区域内部路由以及到达其他区域的区域间路由通告给非骨干区域
路由器角色
内部路由器(Internal Router,IR):所有接口都接入同一个OSPF区域的路由器。
区域边界路由器(Area Border Router,ABR):接入多个区域的路由器。并非所
有接入多个区域的路由器都是ABR，它必须有至少一个接口在Area0中激活，同时还有
其他接口在其他区域中激活。ABR负责在区域之间传递路由信息，因此ABR必须连接
到Area0，同时连接着其他区域。
骨干路由器(Backbone Router,BR):接入Area0的路由器。一台路由器如果所
有的接口都接入Area0，那么它就是一台骨干路由器，另外ABR也是骨干路由器。
AS 边界路由器(AS Boundary Router,ASBR):工作在OSPF自治系统(Autonomous
System,AS)边界的路由器。ASBR将OSPF域外的路由引入本域,外部路由在整个OSPF
域内传递。例如除了接入OSPF网络，它还接入了一个RIP网络，并将自己路由表中通过RIP学习到的路由重分发到了OSPF中。并不是同时运行多种路由协议的OSPF路由器就一定是ASBR，ASBR一定是将外部路由重分发到OSPF，或者执行了路由重分发操作的路由器。
LSA类型
OSPFNssa区域功能介绍：
1、OSPF规定STUB区域是不能引入外部路由的，这样可以避免大量外部路由对STUB区域路由器带宽和存储资源的消耗。对于既需要引入外部路由又要避免外部路由带来的资源消耗的场景，STUB区域就不再满足需求了。因此产生了NSSA区域。
2、OSPF NSSA区域(Not-So-Stubby Area )是OSPF新增的一类特殊的区域类型。
NSSA区域和STUB区域有许多相似的地方。两者的差别在于，NSSA区域能够将自治域外部路由引入并传播到整个OSPF自治域中，同时又不会学习来自OSPF网络其它区域的外部路由。
OSPFNssa区域应用场景：
1、某些网络中的路由表规模过大，导致网络资源浪费，CPU占用率较高。为了缩减路由表的规模，将位于自治系统边缘的非骨干区域配置成STUB区域或NSSA区域，减少传递的路由信息数量。
2、在NSSA区域中使用Type-7 LSA描述引入的外部路由信息。Type-7 LSA由NSSA区域的自治域边界路由器（ASBR）产生，其扩散范围仅限于边界路由器所在的NSSA区域。NSSA区域的区域边界路由器（ABR）收到Type-7 LSA时，会有选择地将其转化为Type-5 LSA，以便将外部路由信息通告到OSPF网络的其它区域。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62bfeb8434b0b0627d5888ec60f7baa3/" rel="bookmark">
			[EFI]联想Thinkpad X1 (2020)电脑 Hackintosh 黑苹果efi引导文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		硬件型号驱动情况主板 Thinkpad X1 Carbon
处理器Intel Core i5-10210U (formerly Comet Lake)已驱动内存8GB DDR3 (or something like that)已驱动硬盘WDC PC SN730 SDBQNTY-256G-1001已驱动显卡Intel UHD 620+Nvidia GeForce MX250(屏蔽)无法驱动声卡Realtek ALC285已驱动网卡 Intel 82574IT Gigabit Ethernet Controller
无线网卡+蓝牙Intel Wireless-AC 9560 160MHz Wireless Network Adapter已驱动 支持系统版本
macos High Sierra（10.13）——Sonoma （14）
引导文件类型版本
opencore 0.9.8
下载地址：黑果魏叔
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceb389cdd4a97f62073bcc5175e31c66/" rel="bookmark">
			8、优化服务器设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mysql配置的工作原理 首先我们应该知道的是Mysql从哪里获取配置信息：命令行参数和配置文件。如果打算长期使用某些配置那么就应该写到全局配置文件，而不是在命令行指定。
语法、作用域和动态性 配置项设置都使用小写，单词之间用下划线或者横线隔开。例如：
/usr/sbin/mysqld --auto-increment-offset=5
配置项可以有多个作用域。有些设置是服务器级的（即全局作用域），有些对每个连接是不同的（即不同会话作用域），剩下的一些事对象级的。许多会话级变量相等，可以认为是默认值。如果改变会话级变量，他只影响改动的当前连接，当连接关闭时所有参数变量都会失效。我们可以看看下面的一些例子：
query_cache_size: 全局变量 sort_buffer_size: 默认是全局的，但是每个线程也可以单独设置 join_buffer_size: 默认是全局的，每个线程也可以单独设置，但是如果一个查询中关联多张表，可以为每个关联分配一个关联缓冲，所以每个查询可能有多个关联缓冲 除了在配置文件中设置变量，有很多变量也可以在服务器运行时修改，Mysql把这些归为动态配置变量。如果动态地设置变量要注意Mysql关闭时可能丢失这些设置。如果想保持这些设置就需要修改配置文件。
如果在服务器运行时修改了变量的全局值，这个值对当前会话和其他任何已经存在的会话都不起效果，这是因为会话的变量值是在连接创建时就从全局值初始化来的。
设置变量的副作用 动态设置变量可能导致一些副作用，例如从缓冲中刷新脏块。下面我们看看常用的一些变量修改后的效果：
key_buffer_size: 设置这个变量可以一次性为键缓冲区分配所有指定的空间。操作系统不会真的立即分配内存，而是到使用的时候才真正的分配。table_cache_size：设置这个变量不会立即生效，会在下次有连接打开表时才有效果。当有线程打开表时，Mysql会检查这个值。如果值大于缓存中的表的数量，线程可以把最新打开的表放入缓存；如果值比缓存中的表数量小，Mysql将从缓存中删除不常用的表。thread_cache_size：设置这个变量不会立即生效，将在下次有连接被关闭时产生效果。当有连接被关闭时，Mysql检查缓存中是否还有空间来缓存线程。如果有则缓存该线程以备下次连接重用；如果没有将销毁该线程而不再缓存。query_cache_size：Mysql在启动时一次性分配并且初始化这块内存。如果修改这个变量Mysql会立即删除所有缓存的查询，重新分配这片缓存到指定大小。并且重新初始化内存。read_buffer_size：Mysql只会在查询需要使用时才会为该缓存分配内存。并且会一次性分配该参数指定大小的内存。read_rnd_buffer_size：Mysql 只会在查询需要使用时才会为该缓存分配内存，并且只会分配需要的内存大小而不是全部指定的大小。sort_buffer_size：Mysql 只会在查询需要做排序时才会为该缓存分配内存。并且分配指定大小的内存。 入门 设置变量时并不是值越大越好，如果设置的值太高可能更容易由于内存不足导致服务器内存交换。
在开始修改配置前，应该先优化查询和schema。
创建Mysql配置文件 实际上Mysql大多数配置的默认值已经是最佳了，所以最好不要改动太多配置。
[client] port = 3306 socket = /tmp/mysql.sock [mysqld] port = 3306 socket = /tmp/mysql.sock basedir = /usr/local/mysql datadir = /data/mysql pid-file = /data/mysql/mysql.pid user = mysql bind-address = 0.0.0.0 server-id = 1 #表示是本机的序号为1,一般来讲就是master的意思 skip-name-resolve # 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项， # 则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求 #skip-networking back_log = 600 # MySQL能有的连接数量。当主要MySQL线程在一个很短时间内得到非常多的连接请求，这就起作用， # 然后主线程花些时间(尽管很短)检查连接并且启动一个新线程。back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。 # 如果期望在一个短时间内有很多连接，你需要增加它。也就是说，如果MySQL的连接数据达到max_connections时，新来的请求将会被存在堆栈中， # 以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。 # 另外，这值（back_log）限于您的操作系统对到来的TCP/IP连接的侦听队列的大小。 # 你的操作系统在这个队列大小上有它自己的限制（可以检查你的OS文档找出这个变量的最大值），试图设定back_log高于你的操作系统的限制将是无效的。 max_connections = 1000 # MySQL的最大连接数，如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，当然这建立在机器能支撑的情况下，因为如果连接数越多，介于MySQL会为每个连接提供连接缓冲区，就会开销越多的内存，所以要适当调整该值，不能盲目提高设值。可以过'conn%'通配符查看当前状态的连接数量，以定夺该值的大小。 max_connect_errors = 6000 # 对于同一主机，如果有超出该参数值个数的中断错误连接，则该主机将被禁止连接。如需对该主机进行解禁，执行：FLUSH HOST。 open_files_limit = 65535 # MySQL打开的文件描述符限制，默认最小1024;当open_files_limit没有被配置的时候，比较max_connections*5和ulimit -n的值，哪个大用哪个， # 当open_file_limit被配置的时候，比较open_files_limit和max_connections*5的值，哪个大用哪个。 table_open_cache = 128 # MySQL每打开一个表，都会读入一些数据到table_open_cache缓存中，当MySQL在这个缓存中找不到相应信息时，才会去磁盘上读取。默认值64 # 假定系统有200个并发连接，则需将此参数设置为200*N(N为每个连接所需的文件描述符数目)； # 当把table_open_cache设置为很大时，如果系统处理不了那么多文件描述符，那么就会出现客户端失效，连接不上 max_allowed_packet = 4M # 接受的数据包大小；增加该变量的值十分安全，这是因为仅当需要时才会分配额外内存。例如，仅当你发出长查询或MySQLd必须返回大的结果行时MySQLd才会分配更多内存。 # 该变量之所以取较小默认值是一种预防措施，以捕获客户端和服务器之间的错误信息包，并确保不会因偶然使用大的信息包而导致内存溢出。 binlog_cache_size = 1M # 一个事务，在没有提交的时候，产生的日志，记录到Cache中；等到事务提交需要提交的时候，则把日志持久化到磁盘。默认binlog_cache_size大小32K max_heap_table_size = 8M # 定义了用户可以创建的内存表(memory table)的大小。这个值用来计算内存表的最大行数值。这个变量支持动态改变 tmp_table_size = 16M # MySQL的heap（堆积）表缓冲大小。所有联合在一个DML指令内完成，并且大多数联合甚至可以不用临时表即可以完成。 # 大多数临时表是基于内存的(HEAP)表。具有大的记录长度的临时表 (所有列的长度的和)或包含BLOB列的表存储在硬盘上。 # 如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。还可以通过设置tmp_table_size选项来增加临时表的大小。也就是说，如果调高该值，MySQL同时将增加heap表的大小，可达到提高联接查询速度的效果 read_buffer_size = 2M # MySQL读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySQL会为它分配一段内存缓冲区。read_buffer_size变量控制这一缓冲区的大小。 # 如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能 read_rnd_buffer_size = 8M # MySQL的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时， # MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大 sort_buffer_size = 8M # MySQL执行排序使用的缓冲大小。如果想要增加ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。 # 如果不能，可以尝试增加sort_buffer_size变量的大小 join_buffer_size = 8M # 联合查询操作所能使用的缓冲区大小，和sort_buffer_size一样，该参数对应的分配内存也是每连接独享 thread_cache_size = 8 # 这个值（默认8）表示可以重新利用保存在缓存中线程的数量，当断开连接时如果缓存中还有空间，那么客户端的线程将被放到缓存中， # 如果线程重新被请求，那么请求将从缓存中读取,如果缓存中是空的或者是新的请求，那么这个线程将被重新创建,如果有很多新的线程， # 增加这个值可以改善系统性能.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ceb389cdd4a97f62073bcc5175e31c66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4efff4a1636b2771108425e2adb102f3/" rel="bookmark">
			2.7 转置与置换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、转置 A A A 的转置（transpose）记作 A T A^T AT， A T A^T AT 的列就是 A A A 的行。
若 A A A 是 m × n m\times n m×n 的矩阵，则它的转置 A T A^T AT 就是 n × m n\times m n×m 的矩阵： 转置 如果 A = [ 1 2 3 0 0 4 ] 则 A T = [ 1 0 2 0 3 4 ] \pmb{转置}\kern 10pt如果\,A=\begin{bmatrix}\pmb1&amp;\pmb2&amp;\pmb3\\0&amp;0&amp;4\end{bmatrix}\kern 5pt则\kern 5ptA^T=\begin{bmatrix}\pmb1&amp;0\\\pmb2&amp;0\\\pmb3&amp;4\end{bmatrix} 转置如果A=[10​20​34​]则AT= ​123​004​ ​可以将 A A A 的行写成 A T A^T AT 的列，也可以将 A A A 的列写成 A T A^T AT 的行，它的转置矩阵是关于其主对角线翻转（即交换关于主对角线对称的元素）。 A T A^T AT 的行 i i i 列 j j j 元素来自于原始矩阵 A A A 的行 j j j 列 i i i 元素：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4efff4a1636b2771108425e2adb102f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e35e86ac56a044c624e8736236108c89/" rel="bookmark">
			蓝桥杯2020年4月青少组Python程序设计省赛真题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、小明带两个妹妹参加元宵灯会。别人问她们多大了，她们调皮地说:“我们俩的年龄之积是年龄之和的6倍小明又补充说:“她们可不是双胞胎，年龄差肯定也不超过8岁啊。请你写出:小明的较小的妹妹的年龄。
2、用下面的语句，输出下图
for i in range(0,4):
fori in range(0,4):
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2194629809c992f0f1f329a094f994f8/" rel="bookmark">
			在Excel中，如何简单快速地删除重复项，这里提供详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当你在Microsoft Excel中使用电子表格时，意外地复制了行，或者如果你正在制作其他几个电子表格的合成电子表格，你将遇到需要删除的重复行。这可能是一项非常无脑、重复、耗时的任务，但有几个技巧可以让它变得更简单。
删除重复项 1、单击数据集中的任意单元格。
2、在“数据”选项卡的“数据工具”组中，单击“删除重复项”。
将出现以下对话框。
3、勾选全选复选框，然后单击“确定”。
​结果：Excel删除除找到的第一个相同行（黄色）外的所有相同行（蓝色）。
删除某些列中具有相同值的行 1、删除具有相同姓氏和国家/地区的行。
2、检查姓氏和国家/地区，然后单击“确定”。
​结果：Excel删除具有相同姓氏和国家/地区（蓝色）的所有行，但找到的第一个实例除外（黄色）。
删除重复项很酷的Excel功能 你可以使用高级筛选器提取唯一的行（或列中的唯一值）。
1、在“数据”选项卡的“排序和筛选”组中，单击“高级”。
将显示“高级筛选器”对话框。
2、单击“将筛选结果复制到其他位置”。
3、在列表区域框中单击，然后选择范围A1:A17（见下图）。
4、单击“复制到”框，然后选择单元格F1（参见下图）。
5、勾选选择不重复的记录。
6、单击“确定”。
结果：Excel删除所有重复的姓氏，并将结果发到列F。
注意：在步骤8中，选择范围A1:D17而不是A1:A17来提取唯一的行。
7、最后，你可以在Excel中使用条件格式来突出显示重复的值。
8、或者在Excel中使用条件格式来突出显示重复的行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1a30dbbfed4c198ceee77efb1ec56f7/" rel="bookmark">
			【新版】软考 - 系统架构设计师（总结笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人总结学习笔记，仅供参考！！！!
→点击 笔者主页，欢迎关注哦（互相学习，共同成长）
笔记目录 📢【系统架构设计系列】系统架构设计专业技能 计算机组成与结构操作系统信息安全技术网络规划与设计信息系统基础系统工程与系统性能数据库设计软件工程之过程开发模型软件工程之需求工程软件工程之系统分析与设计软件工程之软件测试与维护软件工程之UML建模设计结构化需求分析 - 数据流图 系统架构设计高级技能 软件架构概念、架构风格、ABSD、架构复用、DSSA软件可靠性分析与设计系统质量属性与架构评估构件与中间件技术 系统架构设计理论与实践 面向服务架构设计理论与实践安全架构设计理论与实践云原生架构设计理论与实践层次式架构设计理论与实践大数据架构设计理论与实践通信系统架构设计理论与实践Web架构 设计原则（10大设计原则）设计模式（23种设计模式） 📢【系统架构设计系列】 系统架构设计专业技能 计算机组成与结构 计算机结构、CPU 组成、冯·诺依曼结构与哈佛结构、嵌入式芯片、存储系统、层次化存储结构、Cache、主存编址、磁盘管理、磁盘调度、数据传输控制方式、总线、CISC与RISC、流水线、校验码、奇偶校验、循环校验码CRC
→点击 计算机组成与结构
操作系统 操作系统概述、进程管理、进程概念、进程状态、进程的同步与互斥、PV操作、前趋图、死锁、银行家算法、存储管理、逻辑地址与物理地址、类型、分区存储（连续空间）、页式存储/分页存储（非连续空间）、段式存储/分段存储（非连续空间）、段页式存储管理（非连续空间）、快表、虚拟存储管理、页面置换算法、文件管理、索引文件结构、位示图、树形目录结构、设备管理、数据传输控制方式 I/O管理软件、SPOOLing技术、微内核
→点击 操作系统
信息安全技术 （1）信息安全基础知识、信息安全系统的组成框架、信息加解密技术、秘钥管理技术、访问控制及数字签名技术、信息安全的抗攻击技术、信息安全的保障体系和评估方法。
→点击 信息安全技术
网络规划与设计 （2）网络协议与OSI层次模型关系、TCP/IP 协议族、DNS服务应用、DHCP服务应用、IPv6、网络规划与设计、层次化网络设计网络冗余设计、网络存储技术、网络接入技术综合布线技术、物联网技术、云计算技术。
→点击 网络规划与设计
信息系统基础 （3）信息系统的定义、信息系统的分类、信息系统生命周期、信息系统建设原则、信息系统的开发方法、信息化的典型应用（业务处理系统（TPS）、电子数据处理系统（EDPS）、管理信息系统（MIS）、决策支持系统（DSS）、专家系统（ES）、办公自动化系统（OAS）、企业资源规划（ERP））、典型信息系统架构模型（电子政务（EG）、 企业信息化（EI）、电子商务（EC）。
→点击 信息系统基础
系统工程与系统性能 （4）系统工程概念、系统工程方法、霍尔的三维结构、切克兰德方法、并行工程、综合集成法、WSR系统方法、系统工程的生命周期、基于模型的系统工程、系统性能、系统性能指标（评价）、性能计算、性能设计、性能调整、阿姆达尔（Amdahl）解决方案、性能评估。
→点击 系统工程与系统性能
数据库设计 （5）数据库概念、数据模型、数据库模式、关系数据库、关系模型、关系运算、关系数据设计的基本理论、 函数依赖、键/候选键、函数依赖的公理（Armstrong 公理）、 规范化理论、模式分解（是否保持函数依赖&amp;是否无损）、数据库设计、概念结构设计、E-R模型、 ER图两个不同实体的联系、概念结构设计的过程、逻辑结构设计、并发控制、事务的ACID特性、数据库的安全性、数据库备份与恢复、数据库性能优化、应用程序与数据库的交互、NoSQL数据库、分布式数据库、数据库优化技术、分布式缓存技术Redis。
→点击 数据库设计
软件工程之过程开发模型 （6）软件工程概念、软件危机、软件能力成熟度模型、软件过程模型、瀑布模型、原型模型、增量模型、螺旋模型、 V 模型、喷泉模型、CBSD基于构件的模型（构件组装模型/基于构件的软件开发）、 敏捷模型、RAD模型（快速应用开发模型）、统一过程模型（RUP/UP）、逆向工程。
→点击 软件工程之过程开发模型
软件工程之需求工程 （7）软件需求的层次、 需求工程、需求开发（主线、目标）、需求分类、需求获取、需求分析、结构化分析方法 - SA、SA - 数据字典DD、数据流图DFD、状态转换图STD、SA - E-R图/实体联系图、面向对象的分析方法 - OOA、OOA - UML、OOA - UML 4+1视图、OOA - 用例模型与分析模型、需求分析工具、使用用例建模系统需求、数据建模与分析、过程建模、向对象分析与建模、需求定义（形成需求规格）、需求确认与验证、需求管理（支持，保障）、定义需求基线、需求的状态、需求变更管理、需求变更管理过程、需求风险、需求跟踪。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1a30dbbfed4c198ceee77efb1ec56f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95d2b0dbe231b94609c5f0cc3e058375/" rel="bookmark">
			BP网络识别26个英文字母matlab
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		wx供重浩：创享日记
对话框发送：字母识别
获取完整源码源工程文件
一、 设计思想
字符识别在现代日常生活的应用越来越广泛，比如车辆牌照自动识别系统，手写识别系统，办公自动化等等。本文采用BP网络对26个英文字母进行识别。首先将待识别的26个字母中的每一个字母都通过长和宽分别为7×5的方格进行数字化处理，并用一个向量表示。其相应有数据的位置置为1，其他位置置为0。
二、 程序的调用
将M文件及相应的字母图标复制到桌面上。
（一）、打开shibie.m文件，1运行会出现下列提示：请直接按回车键正在生成输入向量和目标向量，请稍等…。2直接按回车键，会出现下列提示：输入向量和目标向量生成结束！请按回车键进行神经网络的训练。3再按回车键，会进行训练，训练完毕后会出现下图所示的结果（图1）
（二）、打开shibie2.m文件，1运行会出现下列提示：请输入测试的图像2输入图形编号如O的为143，回车。会出现如下图所示的结果
同理，字母M为123，其输出结果为
三、 总结
通过仿真结果可看出，基于BP算法的字母识别其容错性和识别率相对较高，在有噪声的情况下训练其识别出错率也相应增加，许进一步改进。
部分源码：（其余完整详见下载）
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%识别26个大写字母%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%% clc; clear all; disp('回车键 ...') chos=input('请直接按回车键正在生成输入向量和目标向量，请稍等… '); if isempty(chos), chos=0; end if chos==0, for kk=0:256 p1=ones(16,16);% 初始化16×16的二值图像像素值(全白) m =strcat('nums\',int2str(kk),'.bmp');% 形成训练样本图像的文件名(0～89.bmp) x=imread(m,'bmp');% 读入训练样本图像文件 bw=im2bw(x,0.5);% 将读入的训练样本图像转换为二值图像 [i,j]= find(bw==0);% 寻找二值图像中像素值为0(黑)的行号和列号 imin=min(i);% 寻找二值图像中像素值为0(黑)的最小行号 imax=max(i);% 寻找二值图像中像素值为0(黑)的最大行号 jmin=min(j);% 寻找二值图像中像素值为0(黑)的最小列号 jmax=max(j);% 寻找二值图像中像素值为0(黑)的最大列号 bw1=bw(imin:imax,jmin:jmax);% 截取图像像素值为0(黑)的最大矩形区域 rate=16/max(size(bw1));% 计算截取图像转换为16×16的二值图像的缩放比例 bw1=imresize(bw1,rate);% 将截取图像转换为16×16的二值图像(由于缩放比例 % 大多数情况下不为16的倍数,所以可能存在转换误差) [i,j]=size(bw1);% 转换图像的大小 i1=round((16-i)/2);% 计算转换图像与标准16×16的图像的左边界差 j1=round((16-j)/2);% 计算转换图像与标准16×16的图像的上边界差 p1(i1+1:i1+i,j1+1:j1+j)=bw1;% 将截取图像转换为标准的16×16的图像 p1= -1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95d2b0dbe231b94609c5f0cc3e058375/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d8a5c00036fb7d5db5529225d48101b/" rel="bookmark">
			PMP项目管理 - 成本管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 系统架构设计
PMP项目管理 - 整合管理
PMP项目管理 - 范围管理
PMP项目管理 - 质量管理
PMP项目管理 - 采购管理
PMP项目管理 - 资源管理
PMP项目管理 - 风险管理
PMP项目管理 - 沟通管理
现在的一切都是为将来的梦想编织翅膀，让梦想在现实中展翅高飞。
Now everything is for the future of dream weaving wings, let the dream fly in reality.
PMP项目管理 - 成本管理 系列文章目录一、划成本管理（规划）- 制定成本管理计划，用来指导后续的项目成本管理工作二、估算成本（规划）- 制定估算各项进度活动的成本三、制定预算（规划）- 制定把估算成本过程得出的各活动或工作的成本逐层向上汇总，建立成本基准四、控制成本（监控）- 制定监督项目成本绩效，管理成本基准变更五、PMP考试要点 成本术语：
一、划成本管理（规划）- 制定成本管理计划，用来指导后续的项目成本管理工作 规划成本管理 制定成本管理计划，用来指导后续的项目成本管理工作。
二、估算成本（规划）- 制定估算各项进度活动的成本 估算成本 定义对完成项目活动所需资金进行近似估算。
估算成本的工具 类比估算、参数估算、三点估算。与估算活动持续时间的使用方法相同。
估算成本的工具：自下而上估算
首先对单个工作包或活动的成本进行最具体、细致的估算，然后将这些细节性成本向上汇总或“滚动”到更高层次。
估算成本的工具：储备分析
（1）为应对成本方面的不确定性或风险 ，估算时需考虑 应急储备 。应急储备应包含在成本基准中，用来应对已经接受的已识别风险。随着项目信息越来越明确，可以动用、减少或取消应急储备。 （2）管理储备 是为了管理控制的目的而特别留出来的项目预算，为用来应对项目范围中不可预见的工作 。为管理储备不包含在成本基准中，但属于项目总预算和资金需求的一部分 。当动用管理储备资助不可预见的工作时，为就要把动用的管理储备增加到成本基准中，从而导致成本基准的变更。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d8a5c00036fb7d5db5529225d48101b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb8d560856627e03d905043684569d7a/" rel="bookmark">
			SpringMVC：Ajax、拦截器、文件上传、文件下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 SpringMVC - 06一、Ajax1. 概述2. Ajax 异步加载数据1. 单个数据2. 对象 3. 实践4. 总结 二、拦截器1. 概述2. 实现3. 实践4. 总结 三、文件上传：Upload1. 准备工作2. 步骤3. 效果 四、文件下载：Download1. 步骤2. 效果3. 总结 注意： SpringMVC - 06 一、Ajax 1. 概述 Ajax：Asynchronous Javascript And XML（异步 JavaScript 和 XML）
使用 Ajax 技术，网页能够快速地将增量更新呈现在用户界面上，而不需要刷新整个页面，这使得程序能够更快地回应用户的操作；
Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的 Web 应用程序的技术；
使用 Ajax 的最大优点，就是能在不更新整个页面的前提下维护数据，即在不需要刷新页面的情况下，就可以产生局部刷新的效果。
需要用到 jQuery 实现 Ajax，它是一个快速、简洁的 JavaScript 框架，具有 js 的大量函数，引入 jQuery 的方法：
进入 jQuery 官网：点此进入，找到 [Download the uncompressed, development jQuery 3.7.0] ；点击链接，出现 js 代码，通过 Ctrl + S 保存到下载的位置；在 web 文件夹新建 static 文件夹，将下载好的 jQuery 框架导入。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb8d560856627e03d905043684569d7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c96d7273d2ba4a6002bb2e396c8ed68/" rel="bookmark">
			基于长短期记忆网络LSTM结合自适应带宽核函数密度估计区间预测。LSTM-ABKDE区间概率预测，LSTM核密度估计下置信区间预测。区间预测(区间覆盖率PICP、区间平均宽度百分比PINAW，CR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		%% 清空环境变量
warning off % 关闭报警信息
close all % 关闭开启的图窗
clear % 清空变量
clc % 清空命令行
res = xlsread('数据集.xlsx');
%%
num_size = 0.8;% 训练集占数据集比例
dataran = 0; %不打乱数据
%%
%% 数据分析
outdim = 1; % 最后一列为输出
num_samples = size(res, 1); % 样本个数
num_train_s = round(num_size * num_samples); % 训练集样本个数
AA1 = res(1:num_train_s,:);
AA2 = res(num_train_s+1:end-1,:);
AA3 = res(end,:);
clear res;
if dataran == 1 AA1 = AA1(randperm(size(AA1, 1)), :); % 打乱数据集
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c96d7273d2ba4a6002bb2e396c8ed68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a5ef577417b62d2c4d4cb6146811fec/" rel="bookmark">
			uniapp怎么动态渲染导航栏的title?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接在接口请求里面写入以下：
自己要什么参数就写什么参数 本人仅供参考：
this.name = res.data.data[i].name; console.log('名字', res.data.data[i].name); uni.setNavigationBarTitle({ title: this.name }) 效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/222d9146785c7812c9c1205cb6201b6d/" rel="bookmark">
			WPF中使用ListView封装组合控件TreeView&#43;DataGrid
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（关注博主后，在“粉丝专栏”，可免费阅读此文） wpf的功能非常强大，很多控件都是原生的，但是要使用TreeView+DataGrid的组合，就需要我们自己去封装实现。
我们需要的效果如图所示：
这2个图都是第三方控件自带的，并且都是收费使用。
现在我们就用原生的控件进行封装一个。
本文源码效果截图，（搞了好几天，的确有难度，所以源码也收费，便宜，赚点辛苦费）
功能如上图所示， 目前基本上把常用的样式都实现了，购买源码后，可以自行修改样式。
首先说明一下，实现上面的效果，有3种方法
第一种：技术的选择是TreeView。
WPF中使用TreeView封装组合控件TreeView+DataGrid-CSDN博客
第二种：技术的选择是DataGrid。
WPF中使用DataGrid封装组合控件TreeView+DataGrid-CSDN博客
第三种：技术的选择是ListView。（也就是本文的演示）
本文演示的是ListView的实现。
1.首先建立一个wpf程序
2.封装TreeList.cs
namespace ListView.TreeDataGrid { using System; using System.Collections; using System.Collections.Generic; using System.Collections.ObjectModel; using System.Collections.Specialized; using System.Linq; using System.Windows; using System.Windows.Controls; using System.Windows.Controls.Primitives; public class TreeList : ListView { #region Properties /// &lt;summary&gt; /// Internal collection of rows representing visible nodes, actually displayed in the ListView /// &lt;/summary&gt; internal ObservableCollectionAdv&lt;TreeNode&gt; Rows { get; private set; } private ITreeModel _model; public ITreeModel Model { get { return _model; } set { if (_model !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/222d9146785c7812c9c1205cb6201b6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74affe3f67fe0c95a590c1bbad40f4eb/" rel="bookmark">
			图像分析与应用-药片胶囊缺陷检测课程设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		wx供重浩：创享日记
对话框发送：胶囊检测
获取完整论文报告+源码源文件
一、简介 该项目的任务是胶囊缺陷检测：找到所有胶囊的位置，正确的胶囊标绿色的方框，错误的胶囊标红色，错误的胶囊存在如下缺陷：漏装胶囊、胶囊放置在错误的位置、胶囊泄漏内部药粉、胶囊被挤压变形等。如图1所示分别为漏装胶囊、胶囊放置在错误的位置、胶囊泄漏内部药粉、胶囊被挤压变形对应的实物图。
图1 漏装胶囊、胶囊放置在错误得位置、胶囊泄漏内部药粉、胶囊被挤压变形（从左至右）
主要思路：
1.找到胶囊板的位置，将其进行定位并从背景中提取出来。
2.找到每一个胶囊的位置，对其进行定位并从胶囊板背景中的提取出来。
3.对胶囊进行缺陷检测，将正确的胶囊标绿色方框，错误的胶囊标红色方框。
二、建议的办法 利用常规的开闭运算和连通域识别来获取胶囊板的位置；利用去雾算法增强胶囊与胶囊板背景之间的对比度，在HSV空间提取出胶囊的信息；利用开闭运算、图像重建、连通域识别获取胶囊的位置及其外接矩形的大小；对胶囊位置进行矩阵式重排列，并利用template中的位置信息作为模板对待检测的胶囊位置进行位置校正、对胶囊的外接矩形大小进行校正；利用校正后的胶囊位置和外接矩形将每一个胶囊从原始图像和中间二值图像中截取出来原始胶囊图集ISRC和二值胶囊图集IBW；对二值胶囊图集IBW中的每一个胶囊进行面积检测，通过判断面积占比来检测漏装胶囊、胶囊泄漏内部药粉、胶囊被挤压变形这三种缺陷；对原始胶囊图集ISRC中的每一个胶囊进行RGB检测，通过计算RGB三个通道的直方图相似性获取每一张图片相互比对后的相似性系数矩阵，分析矩阵来检测胶囊放置在错误的位置这种缺陷；最后将正确的胶囊标绿色方框，错误的胶囊标红色方框。
2.1 胶囊板位置获取
观察图像，发现药板和黑色背景对比度较强，可以用简单的开闭运算和连通域识别来获取胶囊板的位置，具体的步骤如下：
读入原始图像—&gt;转变为灰度图片—&gt;利用80*80的模板进行闭开运算去除黑色背景中可能存在的干扰—&gt;二值化—&gt;连通域识别获取胶囊板的中心位置和外接矩形的大小。
具体代码如下：
I=imread(['images of project\set 1\blister_mixed_',num2str(z_p,'%02d'),'.png']); I_gray=im2gray(I); se=ones(80,80); I_close=imclose(I_gray,se); I_open=imopen(I_close,se); I_bw=imbinarize(I_open,0.5); [l,b_n] = bwlabel(I_bw,8); status_box_b=regionprops(l,'BoundingBox'); centroid_box = regionprops(l,'Centroid'); 效果展示：
2.2 去雾算法增强对比度
观察图像，发现两种胶囊板的背景略有区别：蓝白色胶囊的背景更为复杂，同时有彩色的反光，导致无法利用RGB阈值将胶囊从背景中提取出来。同时观察发现胶囊板透明的塑料类似于雾，所以采用去雾算法来提高胶囊与背景之间的对比度。再利用HSV阈值来提取胶囊成分，并对胶囊成分进行滤波、图像重建、二值化处理得到待定位的胶囊图片。具体步骤如下：
利用2.1中获取得到的胶囊板的中心位置和外接矩形截取胶囊板的局部图像—&gt;去雾处理—&gt;转换到HSV空间—&gt;设置HSV阈值提取胶囊成分—&gt;变回RGB空间、灰度化—&gt;中值滤波得到I_UnW_Gray—&gt;开运算分离残余的背景和胶囊得到I_UnW_Gray_Open—&gt;以I_UnW_Gray_Open为MAKER，I_UnW_Gray为MASK重构图像—&gt;二值化
具体代码如下：
center_xy=centroid_box(1).Centroid; BoundingBox=status_box_b(1).BoundingBox(1,3:4)-[20,50]; I_Board_nor=I(uint16(center_xy(1,2)-BoundingBox(1,2)/2):uint16(center_xy(1,2)+BoundingBox(1,2)/2),uint16(center_xy(1,1)-BoundingBox(1,1)/2):uint16(center_xy(1,1)+BoundingBox(1,1)/2),:); I_Board=dehazing_main(I_Board_nor); I_Board_hsv=rgb2hsv(I_Board); I_Board_hsv(:,:,3)=I_Board_hsv(:,:,3)-I_Board_hsv(:,:,3)+0.5; [m,n,~] = size(I_Board); I_UnW=double(zeros(m,n,3)); for i=1:m for j=1:n if((I_Board_hsv(i,j,2)&gt;0.43 &amp;&amp; I_Board_hsv(i,j,1)&lt;0.6)==1) I_UnW(i,j,1)=I_Board_hsv(i,j,1); I_UnW(i,j,2)=I_Board_hsv(i,j,2); I_UnW(i,j,3)=I_Board_hsv(i,j,3)+0.4; end end end I_UnW_rgb=hsv2rgb(I_UnW); I_UnW_rgb=uint8(255.*I_UnW_rgb); I_UnW_Gray=im2gray(I_UnW_rgb); I_UnW_Gray=medfilt2(I_UnW_Gray,[3,3]); se=ones(5,5); I_UnW_Gray_Open=imopen(I_UnW_Gray,se); I_UnW_Gray=imreconstruct(I_UnW_Gray_Open,I_UnW_Gray); I_UnW_BW=imbinarize(I_UnW_Gray,0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74affe3f67fe0c95a590c1bbad40f4eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8231074561090116544b99c646530a41/" rel="bookmark">
			Hadoop入门学习笔记——四、MapReduce的框架配置和YARN的部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频课程地址：https://www.bilibili.com/video/BV1WY4y197g7
课程资料链接：https://pan.baidu.com/s/15KpnWeKpvExpKmOC8xjmtQ?pwd=5ay8
Hadoop入门学习笔记（汇总）
目录 四、MapReduce的框架配置和YARN的部署4.1. 配置MapReduce和YARN4.2. YARN集群启停脚本4.2.1. 一键启停脚本4.2.2. 单独进程启停 4.3. 提交MapReduce示例程序到YARN运行4.3.1. 提交wordcount（单词统计）示例程序4.3.2. 提交根据Monte Carlo蒙特卡罗算法求圆周率的示例程序 四、MapReduce的框架配置和YARN的部署 本次YARN的部署结构如下图所示：
当前，共有三台服务器（虚拟机）构成集群，集群规划如下所示：
主机部署的服务node1ResourceManager、NodeManager、ProxyServer、JobHistoryServernode2NodeManagernode3NodeManager MapReduce是运行在YARN上的，所以MapReduce只需要配置，YARN需要部署并启动。
4.1. 配置MapReduce和YARN 1、在node1节点，修改mapred-env.sh文件：
# 进入hadoop配置文件目录 cd /export/server/hadoop-3.3.4/etc/hadoop/ # 打开mapred-env.sh文件 vim mapred-env.sh 打开后，在文件中加入以下内容：
# 设置JDK路径 export JAVA_HOME=/export/server/jdk # 设置JobHistoryServer进程的内存为1G export HADOOP_JOB_HISTORYSERVER_HEAPSIZE=1000 # 设置日志级别为INFO export HADOOP_MAPRED_ROOT_LOGGER=INFO,RFA 2、再修改同目录下的mapred-site.xml配置文件，在其configuration标签内增加以下内容：
&lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;description&gt;&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt; &lt;value&gt;node1:10020&lt;/value&gt; &lt;description&gt;&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt; &lt;value&gt;node1:19888&lt;/value&gt; &lt;description&gt;&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.intermediate-done-dir&lt;/name&gt; &lt;value&gt;/data/mr-history/tmp&lt;/value&gt; &lt;description&gt;&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.done-dir&lt;/name&gt; &lt;value&gt;/data/mr-history/done&lt;/value&gt; &lt;description&gt;&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8231074561090116544b99c646530a41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d8a01a476725dba1f7a9e213eea9d82/" rel="bookmark">
			Redis Streams 实现消息队列 (redis命令实现&#43;python代码实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单介绍 Redis中有三种消息队列模式：
可以看出，作为Redis 5.0 引入的专门为消息队列设计的数据类型，Stream 功能更加健全，更适合做消息队列分发。 Stream 可以包含 0个 到 n个元素的有序队列，并根据ID的大小进行排序。
Stream类型消息队列的具备以下命令特点：
可以序列化生成消息ID，方便索引、排序消息可回溯支持Consumer Groups 消费组：多消费者消息争抢，加快消费速度可以阻塞读取消息和非阻塞读取消息没有消息漏读风险有ACK消息确认机制，保证消息至少被消费一次支持多播模式：可以让队列从逻辑上分组进行隔离消费
详细的stream操作见官网文档：https://redis.io/docs/data-types/streams-tutorial/ 示例Demo 环境准备
需要下载Redis 5+版本（Redis 5+才支持streams）。
https://github.com/redis-windows/redis-windows/releases/tag/7.0.8
可以在命令行或者客户端进行测试。
客户端下载链接：
https://redis.com/redis-enterprise/redis-insight/
测试步骤 创建一个名为 "stream_demo" 的 Stream XADD stream_demo* message "Message 1" 创建消息组： XGROUP CREATE stream_demo mygroup $ MKSTREAM 阻塞式监听 Stream，等待消息到达 将消费者 "consumer1" 加入到消息组 "mygroup" 中，并且阻塞式地监听消息。 一旦消息到达，它会被消费者处理，然后使用 XACK 命令来确认已处理的消息。 XREADGROUP GROUP mygroup consumer1 BLOCK 0 STREAMS stream_demo &gt; 执行添加消息的命令 XADD stream_demo * message "Message 2" Python实现 import redis def func(message): print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d8a01a476725dba1f7a9e213eea9d82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9088bffef3451b98feb7d66f4cf45480/" rel="bookmark">
			Hadoop入门学习笔记——五、在虚拟机中部署Hive
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频课程地址：https://www.bilibili.com/video/BV1WY4y197g7
课程资料链接：https://pan.baidu.com/s/15KpnWeKpvExpKmOC8xjmtQ?pwd=5ay8
Hadoop入门学习笔记（汇总）
目录 五、在虚拟机中部署Hive5.1. 在node1虚拟机安装MySQL5.2. 配置Hadoop5.3. 下载并加压Hive5.4. 下载MySQL驱动包5.5. 配置Hive5.6. 初始化元数据库5.7. 使用hadoop用户身份启动Hive 五、在虚拟机中部署Hive Hive是单机工具，只需要部署在一台服务器即可。
Hive虽然是单机的，但是它可以提交分布式运行的MapReduce程序运行。
本次部署服务清单：
服务部署节点Hive服务node1元数据服务所需的关系型数据库（本次选择MySQL）node1 5.1. 在node1虚拟机安装MySQL 本次安装的是MySQL 5.7 社区版。
以root用户身份，在node1虚拟机分别执行以下命令：
# 更新rpm中MySQL相关仓库的密钥 rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022 # 安装MySQL yum库 rpm -Uvh http://repo.mysql.com//mysql57-community-release-el7-7.noarch.rpm # yum安装Mysql社区版 yum -y install mysql-community-server # 启动MySQL服务 systemctl start mysqld # 启动MySQL服务设置开机启动 systemctl enable mysqld # 检查Mysql服务状态 systemctl status mysqld # 通过MySQL的日志查看默认生成的MySQL root用户的密码 cat /var/log/mysqld.log | grep 'password' 查看root用户的密码结果如下图所示，图中红框部分便是自动生成的密码。
使用mysql -u root -p命令，输入上面的密码登录MySQL。
在MySQL命令行中执行以下命令，实现对root命令的修改。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9088bffef3451b98feb7d66f4cf45480/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a46e7aade1412f07e73807f44f85e6a7/" rel="bookmark">
			Hadoop入门学习笔记——六、连接到Hive
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频课程地址：https://www.bilibili.com/video/BV1WY4y197g7
课程资料链接：https://pan.baidu.com/s/15KpnWeKpvExpKmOC8xjmtQ?pwd=5ay8
Hadoop入门学习笔记（汇总）
目录 六、连接到Hive6.1. 使用Hive的Shell客户端6.2. 使用Beeline客户端连接HiveServer2操作Hive6.3. 使用DataGrip连接HiveServer2操作Hive6.4. 使用DBeaver连接HiveServer2操作Hive 六、连接到Hive 6.1. 使用Hive的Shell客户端 1、在HDFS集群、JobHistoryServer、YARN集群、metastore服务均已启动的前提下，进入hive客户端
su hadoop cd /export/server/hive/bin # 进入hive客户端 ./hive 2、创建表
create table test(id int, name string, gender string); 3、展示当前数据库的所有表
show tables; 4、插入数据
INSERT INTO test VALUES(1, '王力红', '男'), (2, '周杰轮', '男'), (3, '林志灵', '女'); 执行时会发现非常慢，查看执行日志之后发现，虽然写的是SQL代码，但是实际是一个MapReduce程序在执行。
虽然这里执行很慢，但是在实际使用场景中，Hive数据都是批量（一次性几百万以上）插入的，不会一条条的插入，所以性能会更高。
5、查询数据
# 查询数据 select * from test; # 按性别统计人数 SELECT gender, COUNT(*) AS cnt FROM test GROUP BY gender; 执行之后会发现，第一条语句执行非常快，没有转换成MapReduce程序，第二条语句又会转换成MapReduce程序进行执行（慢的原因主要在于提交到YARN集群，YARN集群准备阶段慢）。
6、Hive中数据库和数据的存放路径位于HDFS文件系统的/user/hive/warehouse路径下，该路径下，每个Hive库中的表都是一个文件夹，使用fs -ls /user/hive/warehouse命令可以查看，下图test文件夹表示刚才创建的test表（一个hive库就是一个HDFS系统中的文件夹，一个表也是HDFS系统中的一个文件夹，default库下的表直接体现为/user/hive/warehouse下的文件夹，其他自定义库也是/user/hive/warehouse下的文件夹，然后其库内的表，是下一层的文件夹）；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a46e7aade1412f07e73807f44f85e6a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f36f6ea3832d6d2e0054c339b97a0f7/" rel="bookmark">
			Unity中Shader观察空间推导（在Shader中实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、观察空间矩阵推导1、求观察空间基向量2、求观察空间的基向量在世界空间中的矩阵 的 逆矩阵2、求平移变换矩阵3、相乘得出 观察空间转化矩阵4、得到顶点的世界空间坐标，然后转化到观察空间5、把观察空间坐标转化为齐次裁剪坐标输出到屏幕 二、最终效果1、这是我们用默认Shader，在该摄像机坐标下的游戏界面2、使用我们的Shader，并且给我们的ViewPos赋值为摄像机坐标3、最终代码 前言 在上篇文章中，我们是实现了Shader中的观察空间推导。
Unity中Shader观察空间推导 我们在这篇文章中，根据上篇文章的推导，在Shader中实现观察空间矩阵的推导。
一、观察空间矩阵推导 Pview = [Wview] * Pworld
Pview = [Vworld]-1 * Pworld
Pview = [Vworld]T * Pworld
在属性面板定义测试使用到的 摄像机坐标 和 测试顶点坐标
_ViewPos(“View Pos”,vector) = (0,0,0,0)
_ViewTarget(“View Target”,vector) = (0,0,0,0)
1、求观察空间基向量 Z坐标轴基向量 float3 ViewZ = normalize(_ViewPos - _ViewTarget);
假设Y坐标轴基向量为（0，1，0） float3 ViewY = float3(0,1,0);
求 X 坐标基向量 float3 ViewX = cross(ViewZ,ViewY);
求 Y 坐标基向量 ViewY = cross(ViewX,ViewZ);
2、求观察空间的基向量在世界空间中的矩阵 的 逆矩阵 float4x4 M_viewTemp = float4x4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f36f6ea3832d6d2e0054c339b97a0f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5d840ff02af27c6e717c6b9f73ac240/" rel="bookmark">
			20231223解决使用4线的公公线缆链接PC（WIN10）和Firefly的AIO-3399(RK3399)开发板出现ADB链接不上的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		20231223解决使用4线的公公线缆链接PC（WIN10）和Firefly的AIO-3399(RK3399)开发板出现ADB链接不上的问题
2023/12/23 20:47
开发板：Firefly的AIO-3399J【RK3399】
SDK：rk3399-android-11-r20211216.tar.xz【Android11】
Android11.0.tar.bz2.aa【ToyBrick】
Android11.0.tar.bz2.ab
Android11.0.tar.bz2.ac
https://wiki.t-firefly.com/AIO-3399J/prepare_compile_android.html
AIO-3399J产品规格书 立即购买
AIO-3399J 采用 RK3399 六核(A72x2+A53x4) 64 位处理器，主频高达1.8GHz，集成了四核 Mali-T860 GPU，性能优异。
1、简略步骤：
rootroot@rootroot-X99-Turbo:~/3TB$ cat Android11.0.tar.bz2.a* &gt; Android11.0.tar.bz2
rootroot@rootroot-X99-Turbo:~/3TB$ tar jxvf Android11.0.tar.bz2 rootroot@rootroot-X99-Turbo:~/3TB$ mv Android11.0 61Android11.0
rootroot@rootroot-X99-Turbo:~/3TB$ cd 61Android11.0
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0$ cd u-boot
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0/u-boot$ ll
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0/u-boot$ rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0/u-boot$ ./make.sh rk3399
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0/u-boot$ rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0/u-boot$ cd ..
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0$ ll
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0$ cd kernel/
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0/kernel$ ll
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0/kernel$ rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0/kernel$ make ARCH=arm64 rockchip_defconfig android-11.config -j36
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0/kernel$ ll
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0/kernel$ rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0/kernel$ make ARCH=arm64 BOOT_IMG=.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5d840ff02af27c6e717c6b9f73ac240/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f0b2861027010f5a4b569280f123450/" rel="bookmark">
			C&#43;&#43;中的内存锁定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内存锁定(memory locking)是确保进程保留在主内存中并且免于分页的一种方法。在实时环境中，系统必须能够保证将进程锁定在内存中，以减少数据访问、指令获取、进程之间的缓冲区传递等的延迟。锁定内存中进程的地址空间有助于确保应用程序的响应时间满足实时要求。作为一般规则，时间关键的进程(time-critical process)应该被锁定到内存中。
虚拟地址空间(virtual address space)被划分为固定大小的单元(fixed-sized unit)，称为页(page)。每个进程通常占用多个页，这些页在进程执行时独立地移入和移出主内存。通常，当进程执行时，进程页的子集驻留在主内存(primary memory)中。
由于可用的主内存量是有限的，因此分页通常会牺牲一些页即要移入页，必须移出其他页。如果要替换的页在执行期间被修改，则该页将被写入文件区域。该页根据需要被带回主内存，并且在内核检索该页时延迟执行。
分页通常对当前进程是透明的。通过增加物理内存的大小或将页锁定到内存中可以减少分页量。但是，如果进程非常大或者页频繁调入和调出，则调页所需的系统开销可能会降低效率。
对于实时应用程序来说，拥有足够的内存比非实时应用程序更重要。实时应用程序必须确保进程被锁定到内存中，并且有足够的内存可供实时进程和系统使用。对于关键的实时任务来说，由于分页引起的延迟通常是不可接受的。
内存锁定适用于进程的地址空间。只有映射到进程地址空间的页才能被锁定到内存中。当进程退出时，页将从地址空间中删除，并且锁也被删除。
内存锁定有两个主要应用：实时算法和高安全性数据处理。
页锁定内存无法从RAM移动到交换文件，确保该内存始终驻留在物理内存中。与传统内存相比,它提高了GPU的PCI-Express(CPU和GPU之间的总线) I/O速度。
NVIDIA的GPU是一个协处理器(co-processor),GPU内核启动、数据初始化和传输均由CPU进行.
CUDA中有四种类型的内存分配：
1.Pageable memory(可分页内存):主机中分配的内存默认是可分页内存。该内存位置的数据可供主机使用。为了将此数据传输到设备，CUDA运行时会将此内存拷贝到临时固定内存，然后传输到设备内存。因此，存在两次内存传输。因此，这种类型的内存分配和传输速度很慢。GPU无法直接从可分页主机内存访问数据。涉及的函数：malloc, cudaMalloc, cudaMemcpy
2.Pinned memory(固定内存):也称为页锁定，数据可以直接在主机固定存储器中初始化。与malloc分配的常规可分页主机内存相反。通过这样做，我们可以避免像可分页内存中那样的两次数据传输。这将使该过程更快，但会牺牲主机性能。当数据在固定存储器中初始化时，主机处理的存储器可用性会降低。涉及的函数：cudaMallocHost, cudaMalloc, cudaMemcpy
优点：
(1).对于某些设备，页锁定主机内存和设备内存之间的拷贝可以与内核执行同时执行。
(2).在某些设备上，页锁定主机内存可以映射到设备的地址空间，从而无需将其拷贝到设备内存或从设备内存中拷贝。
(3).在具有前端总线(front-side bus)的系统上，如果主机内存被分配为页锁定，则主机内存和设备内存之间的带宽(bandwidth)会更高。
注：页锁定主机内存不会缓存在非I/O一致Tegra设备上。此外，非I/O一致Tegra设备不支持cudaHostRegister。
3.Mapped memory(映射内存)或Zero copy memory(零拷贝内存):零拷贝内存是映射到设备地址空间的固定内存。主机和设备都可以直接访问该内存。涉及的函数：cudaHostAlloc, cudaHostGetDevicePointer
优点：
(1).当设备内存不足时，可以利用主机内存。
(2).可以避免主机和设备之间显式的数据传输。
(3).提高PCI-Express传输速率。
缺点：由于它被映射到设备地址空间，因此数据不会被拷贝到设备内存中。传输将在执行期间发生，这将大大增加处理时间。
4.Unified memory(统一内存):这将创建一个托管内存池，其中来自该内存池的每个分配都可以在主机和设备上使用相同的地址或指针进行访问。底层系统将数据迁移到主机和设备。涉及的函数：cudaMallocManaged
优点:无需为所需的设备显式分配和恢复内存。这降低了编程复杂性。
缺点:在内存管理方面添加了额外的指令.
RAM(Random Access Memory):随机存取存储器,是一种计算机存储器，它用于临时存储数据和指令，以便在计算机运行时快速访问。RAM可以随时读取和写入数据，而且读取和写入的速度非常快。相比之下，硬盘、闪存等存储设备的数据访问速度要慢得多。RAM通常用于计算机的主存(内存)，以便CPU可以快速访问指令和数据。它也用于缓存和其他高速存储设备，以加快数据访问速度。
linux下的用于内存锁定的函数mlock/mlockall, munlock/munlockall声明如下：
int mlock(const void *addr, size_t len); int munlock(const void *addr, size_t len); int mlockall(int flags); int munlockall(void); mlock:锁定从addr开始并持续len字节的地址范围内的页。当调用成功返回时，所有包含指定地址范围的页都保证驻留在RAM中，直到稍后解锁。
munlock:解锁从addr开始并持续len字节的地址范围内的页。在此调用之后，包含指定内存范围的所有页都可以由内核再次移动到外部交换空间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f0b2861027010f5a4b569280f123450/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/750a8770e38368e17bf82b9fa495ff36/" rel="bookmark">
			DBO-DELM分类【23年新算法】，基于蜣螂优化算法DBO优化深度极限学习机DELM数据分类。多特征输入单输出的二分类及多分类模型。程序内注释详细，直接替换数据就可以用。程序语言为matla
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		warning off % 关闭报警信息
close all % 关闭开启的图窗
clear % 清空变量
clc % 清空命令行
%% 导入数据
res = xlsread('数据集.xlsx');
智能算法及其模型预测
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d67a8d3d8008602c10479d5489493c0d/" rel="bookmark">
			win10如何关闭自动更新,win10关闭自动更新的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用win10系统后很多小伙伴会因为系统自动更新而导致各别的驱动文件丢失从而使各别的软件不能正常运行，那么有什么方法可以关闭win10系统自动更新呢，小编在这分享两种win10系统关闭自动更新的方法，希望能帮到大家。
方法一
1、鼠标指向此电脑右击选择【管理】
2、进入计算机管理界面选择【服务和应用程序】
3、在中间窗口双击选择【服务】
4、在【服务】窗口下拉找到【Windows Update】
5、双击选择【Windows Update】进入设置界面选择【禁用】再【确认】就可
方法二
1、右击电脑左下角的微软按钮，弹出的界面，点击【运行】
2、在【运行】界面内输入services.msc，点击【确定】
3、进入服务界面后找到【Windows Update】
4、双击进入【Windows Update】进入设置界面选择【禁用】再【确认】就可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c8d5db32448c72763c957a062089c7b/" rel="bookmark">
			4.1 媒资管理模块 - Nacos与Gateway搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 媒资管理模块 - 媒资项目搭建一、需求分析1.1 介绍1.2 数据模型1.3 分析网关 二、 搭建Nacos2.1 服务发现中心2.2.1 Maven2.2.2 配置Nacos 2.2 配置中心2.2.1 介绍2.2.2 Maven 坐标2.2.3 配置 content-api 工程2.2.4 配置 content-service 工程2.2.5 配置 system-api 工程2.2.6 配置 system-service 工程 2.3 配置中心 - 公用配置2.4 配置中心 - 配置加载优先级2.5 配置中心 - 灵活切换环境2.6 配置中心 - 导入配置 三、 搭建 Gateway 网关3.1 创建xuecheng-plus-gateway网关工程3.2 Maven坐标3.3 bootstrap.yaml配置文件3.4 Nacos配置网关路由策略3.5 测试网关 媒资管理模块 - 媒资项目搭建 一、需求分析 1.1 介绍 媒资管理系统是每个在线教育平台所必须具备的
每个教学机构都可以在媒资系统管理自己的教学资源，包括:视频、教案等文件，目前媒资管理的主要管理对象是视频、图片、文档等，包括:媒资文件的查询、文件上传、视频处理等.
媒资查询:教学机构查询自己所拥有的媒资信息
文件上传:包括上传图片、上传文档、上传视频
比如说内容管理中课程编辑和新增时需要添加课程封面图片
视频处理:视频上传成功，系统自动对视频进行编码处理
假如我们上传了一个avi格式的视频，这个视频在浏览器上是无法播放的需要进行转码，比如说转成Mp4格式
文件删除:教学机构删除自己上传的媒资文件
1.2 数据模型 mdia_files媒资文件表：存储文件信息，包括图片、视频、文档等，并不是文件本身，真正的文件存储在我们的分布式系统中。
media_process: 待处理视频表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c8d5db32448c72763c957a062089c7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59b8bdd7941eac29f1b23ab8dc8445e9/" rel="bookmark">
			MyBatis的动态SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.什么是动态sql
2.if标签
3.where标签
4.set标签
5.trim标签
5.1trim标签可以代替where标签、set标签
5.2trim主要用于动态向表中插入数据
6.foreach标签
7.sql标签
8.include
9.choose(when,otherwise) 语句
10. bind 标签 1.什么是动态sql MyBatis的映射文件中支持在基础SQL上添加一些逻辑操作，并动态拼接成完整的SQL之后再执行，以达到SQL复用、简化编程的效果。
Mybatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能。
2.if标签 我们根据实体类的不同取值，使用不同的SQL语句来进行查询。比如在id如果不为空时可以根据 id查询，如果username不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。
if 语句使用方法简单，常常与 test 属性联合使用。语法如下。
&lt;if test="判断条件"&gt; SQL语句&lt;/if&gt; mapper接口：
public interface UserDao { //复杂条件查询 public List&lt;User&gt; findByUser(User user); } xml映射文件：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.by.dao.UserDao"&gt; &lt;select id="findByUser" resultType="user"&gt; select * from user where 1=1 &lt;if test="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59b8bdd7941eac29f1b23ab8dc8445e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3f94b315f78509de8f523d96a4062bb/" rel="bookmark">
			PMP项目管理 - 进度管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 系统架构设计
PMP项目管理 - 整合管理
PMP项目管理 - 范围管理
PMP项目管理 - 质量管理
PMP项目管理 - 采购管理
PMP项目管理 - 资源管理
PMP项目管理 - 风险管理
PMP项目管理 - 沟通管理
现在的一切都是为将来的梦想编织翅膀，让梦想在现实中展翅高飞。
Now everything is for the future of dream weaving wings, let the dream fly in reality.
PMP项目管理 - 进度管理 系列文章目录一、规划进度管理（规划）- 是项目管理计划的组成部分，为编制、监督和控制项目进度建立准则和明确活动二、定义活动（规划）- 识别和记录为完成项目可交付成果而采取的具体行动三、排列活动顺序（规划）- 识别和记录项目活动之间的关系的过程四、估算活动持续时间（规划）- 根据资源估算的结果，估算完成单项活动所需工作时段（period）数的过程五、制定进度计划（规划）- 分析活动顺序、持续时间、资源需求和进度制约因素，创建项目进度模型六、控制进度（监控）- 监督项目活动状态，管理进度基准变更七、PMP考试要点 项目进度管理 包括为管理项目按时完成所需的各个过程。
项目进度计划（Schedule） 说明了项目如何以及何时交付项目范围中定义的产品、服务和成果。
一、规划进度管理（规划）- 是项目管理计划的组成部分，为编制、监督和控制项目进度建立准则和明确活动 规划进度管理 是项目管理计划的组成部分，为编制、监督和控制项目进度建立准则和明确活动。内容：
（1）项目进度模型制定：需要规定用于制定项目进度模型的进度规划方法论和工具；
（2）准确度：需要规定活动持续时间估算的可接受区间，以及允许的应急储备数量；
（3）计量单位：需要规定每种资源的计量单位，例如，用于测量时间的人时数、人天数或周数；用于计量数量的米、升、吨、千米或立方；
（4）组织程序链接：工作分解结构为进度管理计划提供了框架，保证了与估算及相应进度计划的协调性
（5）项目进度模型维护：需要规定在项目执行期间，将如何在进度模型中更新项目状态，记录项目进展
（6）控制临界值：可能需要规定偏差临界值，用于监督进度绩效。它是在需要采取某种措施前，允许出现的最大偏差。
（7）绩效测量规则：需要规定用于绩效测量的挣值管理（EVM）规则或其他测量规则
（8）报告格式：需要规定各种进度报告的格式和编制频率
（9）过程描述：对每个进度管理过程进行书面描述
可以是正式或非正式、详细或概括的，视项目需要而定。
二、定义活动（规划）- 识别和记录为完成项目可交付成果而采取的具体行动 定义活动 定义识别和记录为完成项目可交付成果而采取的具体行动。创建 WBS 得到的是工作包，将工作包继续往下分解得到活动，以便更好地对项目工作进行估算、进度规划、执行、监督和控制。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3f94b315f78509de8f523d96a4062bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51d69bf5432874e2d55ae0a793828777/" rel="bookmark">
			分布式锁常见问题及其解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、为什么要使用分布式锁？ 因为在集群下，相当于多个JVM，就相当于多个锁，集群之间锁是没有关联的，会照成锁失效从而导致线程安全问题
分布式锁可以分别通过MySQL、Redis、Zookeeper来进行实现
二、redis分布式锁的实现（基于setnx实现的分布式锁） 创建ILock接口 package com.hmdp.utils; public interface ILock { /** * 尝试获取锁 * @param timeoutSec * @return */ boolean tryLock(long timeoutSec); /** * 释放锁 */ void unLock(); } 创建SimpleRedisLock实现类 package com.hmdp.utils; import cn.hutool.core.lang.UUID; import org.springframework.data.redis.core.StringRedisTemplate; import java.util.concurrent.TimeUnit; public class SimpleRedisLock implements ILock { private String name; private StringRedisTemplate stringRedisTemplate; public SimpleRedisLock(String name, StringRedisTemplate stringRedisTemplate) { this.name = name; this.stringRedisTemplate = stringRedisTemplate; } private static final String KEY_PREFIX = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51d69bf5432874e2d55ae0a793828777/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/102c3e915e9df64dd3589a3acdbc90d5/" rel="bookmark">
			windows下使用vccode&#43;cmake编译cuda程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在vscode中安装Nsight Visual Studio Code Edition
在vscode中安装插件能够对cuda的代码进行语法检查
2、编写cuda程序
#include &lt;iostream&gt; __global__ void mykernelfunc(){}; int main() { mykernelfunc&lt;&lt;&lt;1,1&gt;&gt;&gt;(); std::cout &lt;&lt; "hello,cuda" &lt;&lt; std::endl; return 0; } 3、编写CMakeLists.txt
cmake_minimum_required(VERSION 3.23)	# 指定cmake最小版本 project(hello-cuda LANGUAGES CXX CUDA)	# 指定项目名称和编译语言 CXX为C++ add_executable(hello-cuda hello.cu)	# 指定编译的代码 4、使用cmake进行编译
4.1 查询cmake编译器
cmake -B build -G 4.2 指定编译器构建项目
cmake -B build -G"Visual Studio 16 2019" 4.3 编译程序
cmake --build build 5、运行编译好的程序
编译好的程序在.\build\Debug目录下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36f42bdb4b29f75730d9ab4a0f05d247/" rel="bookmark">
			word2003 open word2007&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		==
Win 7
C:\Documents and Settings\Administrator\Application Data\Microsoft\Templates
还是不行，重装office2003吧，再安装转换插件，但是再高版本好像没转换工具
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/29/">«</a>
	<span class="pagination__item pagination__item--current">30/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/31/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>