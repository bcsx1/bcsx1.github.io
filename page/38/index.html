<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/537287f711fd5601a389adc189a7662b/" rel="bookmark">
			python造测试数据存到excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码：
from ExcelHandler import ExcelHandler from faker import Faker	# 导入faker库的Faker方法 # ↓默认为en_US，只有使用了相关语言才能生成相对应的随机数据 fk=Faker(locale="zh_CN") def create_date(): m =int(input('请输入要造的数据条数m的值：')) for i in range(1,m+1): """手机号""" fk.phone_number() ExcelHandler(file=r'C:\Users\dell\Desktop\test_data_01.xlsx').write( file=r'C:\Users\dell\Desktop\test_data_01.xlsx', row=i + 1, column=1, name='ceshi', data=fk.phone_number()) """身份证号""" ExcelHandler(file=r'C:\Users\dell\Desktop\test_data_01.xlsx').write( file=r'C:\Users\dell\Desktop\test_data_01.xlsx', row=i + 1, column=2, name='ceshi', data=fk.ssn()) if __name__=="__main__": print(create_date()) 结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3afd2dcc5c00d29dad1587e2632fc5cf/" rel="bookmark">
			深度学习有意思的探讨系列——Self-Attention那么为什么要进行缩放呢？ 为什么很大的值，不利于梯度的传播？为什么使用维度的根号来进行缩放？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我自己做了一个视频，欢迎大家一起探讨：
深度学习有意思的探讨系列——Self-Attention那么为什么要进行缩放呢？ 为什么很大的值，不利于梯度的传播？为什么使用维度的根号来进行缩放？_哔哩哔哩_bilibili
softmax又称归一化指数函数。它是二分类函数sigmoid在多分类上的推广，目的是将多分类的结果以概率的形式展现出来。它将多个神经元的输出，映射到（0,1）区间内，可以看成概率来理解，从而来进行多分类！假设我们有一个数组，V，Vi表示V中的第i个元素，那么这个元素的softmax值就是
参考资料：(很详细，能看懂)
transformer中的缩放点积注意力为什么要除以根号d_transformer 根号d-CSDN博客
大模型面试系列-基础面试问题（1） - 知乎 (zhihu.com)
为什么在进行softmax之前需要对attention进行scaled（为什么除以 d_k的平方根）_attention为什么要除以根号d-CSDN博客
softmax详解-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deb6e4e15a2fb646719479cd094a5637/" rel="bookmark">
			python装饰器解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象
它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。
一、类装饰器
如：自动化测试中，@ddt就是装饰器，使用ddt类中的data方法，作用是解析*login_data.data数据包的数据为一条一条的执行以下的test_01_login函数
执行的顺序就是：ddt.data函数先执行，执行ddt类中携带参数*login_data.data的data()函数，并返回一个参数，传递给test_01_login(case)中的case参数
在执行test_01_login函数，
二、内置装饰器
内置装饰器名称含义@property()将一个函数方法转成一个属性，使方法想属性一样被访问，可以保护属性的值，避免被修改@classmethod在类中实例化类，执行时不用实例化，减少代码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5cda07dfec612de0707ca648a52733c/" rel="bookmark">
			基本频谱分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本频谱分析 傅里叶变换是用于对时域信号执行频率和功率谱分析的工具。
频谱分析数量 频谱分析研究非均匀采样的离散数据中包含的频谱。傅里叶变换是通过在频率空间表示基于时间或空间的信号来揭示该信号的频率分量的工具。下表列出了用于描述和解释信号属性的常用量。要了解有关傅里叶变换的更多信息，请参阅傅里叶变换。
数量描述x 采样的数据
n = length(x) 样本数量
fs 采样频率（每单位时间或空间的样本数）
dt = 1/fs 每样本的时间或空间增量
t = (0:n-1)/fs 数据的时间或空间范围
y = fft(x) 数据的离散傅里叶变换 (DFT)
abs(y) DFT 的振幅
(abs(y).^2)/n DFT 的幂
fs/n 频率增量
f = (0:n-1)*(fs/n) 频率范围
fs/2 奈奎斯特频率（频率范围的中点）
含噪信号 傅里叶变换可以计算被随机噪声破坏的信号的频率分量。
创建具有 15 Hz 和 40 Hz 分量频率的信号，并插入随机高斯噪声。
rng('default') fs = 100; % sample frequency (Hz) t = 0:1/fs:10-1/fs; % 10 second span time vector x = (1.3)*sin(2*pi*15*t) ... % 15 Hz component + (1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5cda07dfec612de0707ca648a52733c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13353a7bb7cf4a5057c886e6c191f44d/" rel="bookmark">
			XT3410 是一款由基准电压源、振荡电路、比较器、PWM/PFM 控制电路等构成的 CMOS 降压型 DC/DC 调整器。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 XT3410 PWM/PFM 控制 DC-DC 降压转换器 概述： XT3410 是一款由基准电压源、振荡电路、比较器、PWM/PFM 控制电路等构成的 CMOS 降压型 DC/DC 调整器。利用 PWM/PFM 自动切换控制电路达到可调占空比，具有全输入电压范围内的低纹波、高效率和大输出电流等特点。XT3410 内置功率 MOSFET，集成了过压、过流、过热、短路等诸多保护电路，在超过控制值时会自动断开，以保护芯片。本产品结合了微型封装和低消耗电流等特点，最适合在移动设备的电源内部使用。 产品特点： 高效率 最大效率可达 95％ 最大输出电流 1.5A 超低静态电流 40μA 甚小输出纹波 &lt;±0.4% 低压操作 可达 100％占空比 PWM/PFM 自动切换 占空比自动可调以保持全负载范围内的高效率、低纹波 短路保护 ■ 用途： 数码相机、电子记事本、PDA 等移动设备电源 照相机、视频设备、通信设备的稳压电源 微机电源 机顶盒 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd1a256916ad79a991b353f09f65037c/" rel="bookmark">
			gorm_generate根据表生成对应结构体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. 先了解jen代码生成二. gorm.io/gorm 新版本 gorm + jen 生成表对应结构体介绍 gorm Migratorgorm Migrator 读取数据库表结构 + jen 生成对应结构体 三. github.com/jinzhu/gorm 老版本 gorm + jen 生成表结构 一. 先了解jen代码生成 有一个专门用于代码生成的三方库"github.com/dave/jennifer/jen",下方一个简单的示例
它可以让你以编程的方式创建和修改.go文件 func testJen() { //导包 "github.com/dave/jennifer/jen" //1.通过jen可以创建文件,入参指定的是pacakge f := jen.NewFile("main") //2.在文件中添加结构体的定义 f.Type().Id("Person").Struct( //2.1添加属性 jen.Id("Age").Int(), //设置属性的tag jen.Id("ID").Int64().Tag(map[string]string{ "gorm": "primary_key", }), jen.Id("Name").String().Tag(map[string]string{ "json": "name", }), ) //3.在文件中添加函数 f.Func().Id("main").Params().Block( // 创建一个结构体变量 jen.Id("p").Op(":=").Id("Person").Values( jen.Id("Name").Op(":").Lit("Alice"), jen.Id("Age").Op(":").Lit(20), ), // 调用函数 jen.Id("p").Dot("PrintInfo").Call(), ) //4.在文件中给结构体绑定方法 f.Func().Params(jen.Id("p").Op("*").Id("Person")).Id("PrintInfo").Params().Block( jen.Qual("fmt", "Printf").Call( jen.Lit("Name: %s, Age: %d\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd1a256916ad79a991b353f09f65037c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11f3427b0195296bf0b12cd9ec34c764/" rel="bookmark">
			IDEA 黑色主题很难看到鼠标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 “控制面板”—搜索“鼠标”关键字—选择“更改鼠标设置”
参考：
IDEA 黑色主题很难看到鼠标 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c0cc04dd931b574049b67d6eb3af396/" rel="bookmark">
			【【迭代七次的CORDIC算法-Verilog实现】】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迭代七次的CORDIC算法-Verilog实现求解正弦余弦函数 COEDIC.v module CORDIC #( parameter DATA_WIDTH = 4'd8 , // we set data width parameter PIPELINE = 4'd8 )( input clk , input rst_n , input [DATA_WIDTH - 1 : 0] phase , input ena , output reg [DATA_WIDTH - 1 : 0] sin_out , output reg [DATA_WIDTH - 1 : 0] cos_out ); // ------------------------------------------------ \\ // next is define and parameter \\ // -------------------------------------------------\\ reg [DATA_WIDTH - 1 : 0] phase_reg ; reg [DATA_WIDTH - 1 : 0] X0 ; reg [DATA_WIDTH - 1 : 0] Y0 ; reg [DATA_WIDTH - 1 : 0] Z0 ; wire [DATA_WIDTH - 1 : 0] X1 , Y1 , Z1 ; wire [DATA_WIDTH - 1 : 0] X2 , Y2 , Z2 ; wire [DATA_WIDTH - 1 : 0] X3 , Y3 , Z3 ; wire [DATA_WIDTH - 1 : 0] X4 , Y4 , Z4 ; wire [DATA_WIDTH - 1 : 0] X5 , Y5 , Z5 ; wire [DATA_WIDTH - 1 : 0] X6 , Y6 , Z6 ; wire [DATA_WIDTH - 1 : 0] X7 , Y7 , Z7 ; reg [1:0] quadrant[PIPELINE : 0] ; integer i ; always@(posedge clk or negedge rst_n) begin if(rst_n == 0) for(i = 0 ; i &lt;= PIPELINE ; i=i+1) quadrant[i] &lt;= 0 ; else if(ena == 1) begin for(i = 0 ; i &lt;= PIPELINE ; i=i+1) quadrant[i+1] &lt;= quadrant[i] ; quadrant[0] &lt;= phase[DATA_WIDTH - 1 : DATA_WIDTH - 2] ; end end // we set a new phase to Unify the phase in the first quadrant // we set 8'h 0010 0000 =&gt; 45度 and 1000 0000 =&gt; 180度 always@(posedge clk or negedge rst_n) begin if(rst_n == 0) begin phase_reg &lt;= 0 ; end else if(ena == 1) begin case(phase[DATA_WIDTH -1 : DATA_WIDTH -2]) 2'b00 : phase_reg &lt;= phase ; 2'b01 : phase_reg &lt;= phase - 8'h40 ; // subtract 90 2'b10 : phase_reg &lt;= phase - 8'h80 ; // subtract 180 2'b11 : phase_reg &lt;= phase - 8'hC0 ; // subtract 270 default : ; endcase end end // start to calculate // we should set x0= 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c0cc04dd931b574049b67d6eb3af396/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36b3a838466c309410eac0daa6627280/" rel="bookmark">
			spring 定时任务Scheduler和异步任务Async
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 概述 Spring框架分别通过TaskExecutor和TaskScheduler接口为任务提供异步执行和调度。
ThreadPoolTaskScheduler(继承自TaskScheduler)ThreadPoolTaskExecutor（继承自TaskExecutor）备注含义任务调度器，定时任务线程池执行器，异步任务用途主要用于在指定的时间间隔内执行任务或定时任务用于执行异步任务和多线程任务线程池基于java.util.concurrent.ScheduledExecutorService基于 java.util.concurrent.ThreadPoolExecutorthreadPool默认配置springboot默认线程池大小为1springboot默认线程池大小8注解@EnableScheduling
@Scheduled@EnableAsync
@EnableScheduling
@Async
@Scheduled1注解的方法必须是public方法
2.方法一定要从另一个类中调用，也就是从类的外部调用，类的内部调用是无效的，因为注解的实现都是基于Spring的AOP，而AOP的实现是基于动态代理模式实现的。那么注解失效的原因就很明显了，有可能因为调用方法的是对象本身而不是代理对象，因为没有经过Spring容器。
3. 异步方法使用注解@Async的返回值只能为void或者Future函数返回值函数可以有返回值函数没有返回值异步执行单个任务同步执行。
当执行时间大于我们间隔时间时，上一次任务执行完成后才会开始下一个任务。非阻塞异步执行。
每次执行定时任务都会新开一个线程，即使之前的任务没有完成。 2. 定时任务Scheduler 定时任务会创建线程池ScheduledThreadPoolExecutor，用于执行任务。springboot默认Scheduler线程池corePoolSize=1
2.1 定时任务 - 相关注解及使用方法（一个简单的例子） spring定时任务使用非常简单，只需要添加两个注解@EnableScheduling，@Scheduled
1.@EnableScheduling：在spring管理的类上添加都可以，通常添加在启动类上
@EnableScheduling @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 2. @Scheduled: 在定时任务的实现方法上添加该注解（@Scheduled注解的详细介绍见4. @Scheduled参数详解）
@Slf4j @Service public class ScheduledTask { @Scheduled(cron ="* * * * * *") public int ScheduledTaskOne() throws InterruptedException { log.info("------- ScheduledTaskOne start..."); Thread.sleep(10000L); log.info("------- ScheduledTaskOne done."); return 1; } } 如上任务配置了每秒运行一次。由于函数中执行了 Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36b3a838466c309410eac0daa6627280/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1404fe37b37215086a3b1e86c3368e83/" rel="bookmark">
			在编程中遇到的问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA空包粘黏问题 创建好目录以后会发现idea自动将空包合并在一起了，而且点击设置里面也没有Compact Middle Package
Compact Middle Package如果不在设置的主面板上，则点击Tree Appearance，会发现Compact Middle Package在Tree Appearance里面，然后去掉Compact Middle Package前面的勾选即可展开包
IDEA中解决控制台乱码问题 IDEA控制台输出乱码解决办法 - 知乎
在使用Filter的时候只重写doFilter方法带来的问题 在使用过滤器的时候，xml文件配置都没有问题：
但访问页面的时候(不管是静态的还是动态的)，都会报404错误。原因就是因为没有重写Filter里面的init方法。在 web 工程启动的时候执行构造器方法和init 初始化方法 ，如果没有重写过滤器的初始化方法，那么就没法使用过滤器，而xml文件里面有配置了过滤器的信息，所以服务器在执行的时候，根据xml的配置他找MyFilter这个类，发现这个类没有初始化，根本就没有，所以就会报404。 在mapper.xml文件中插入对象的SQL语句遇到的问题 当我们需要在mapper.xml文件中插入对象时，我们可以像下面这样写：
&lt;insert id="addStudent" parameterType="com.example.demo.entity.Student"&gt; insert into student (name,age,school,gender) values(#{name},#{age},#{school},#{gender}); &lt;/insert&gt; 上面的parameterType只是使用指定参数类型的，可有可无，没有也不会出错，但是协商以后含义更加明确。 将对象存储到Redis遇到的问题 再将封装好的对象转化为json字符串存储到redis中时，遇到了下面问题
@RestController @RequestMapping("/users") public class UserController { @Autowired private UserService userService; @Autowired private StringRedisTemplate stringRedisTemplate; @Autowired private ObjectMapper objectMapper; //登录操作 @RequestMapping("/login") public Object login(HttpServletRequest req,String username,String password) throws IOException { if(StringUtils.hasLength(username) &amp;&amp; StringUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1404fe37b37215086a3b1e86c3368e83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d9d241b8ea58cf38c2d6c344b14395a/" rel="bookmark">
			emoji表情符号，unicode表情符号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 😎前言👨‍💻使用✈️Unicode 1.1 版本新增☙ Unicode 3.0 版本新增♻️Unicode 3.2 版本新增☕Unicode 4.0 版本新增🀨Unicode 5.1 版本新增⚽ Unicode 5.2 版本新增🌊Unicode 6.0 版本新增😙Unicode 6.1 版本新增🦁Unicode 7.0 版本新增🦄Unicode 8.0 版本新增🥀Unicode 9.0 版本新增🥣Unicode 10.0 版本新增🦵Unicode 11.0 版本新增🛕Unicode 12.0 版本新增 😎前言 本文记录了 Unicode 标准中常见的表情符号字符，你可以直接复制表情符号用到你的网页上。
关于所有表情符号的含义你还可以查看 emojipedia表情符号网站 和 emoji-cheat-sheet
👨‍💻使用 你可以在你的网页页面中像下面这样使用它
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;/head&gt; &lt;body&gt; &lt;font size = 6&gt;👨‍🎓&lt;/font&gt; &lt;font size = 6&gt;🤪&lt;/font&gt; &lt;font size = 6&gt;🚐&lt;/font&gt; &lt;font size = 6&gt;🙋&lt;/font&gt; &lt;font size = 6&gt;🐫&lt;/font&gt; &lt;font size = 6&gt;🐴&lt;/font&gt; &lt;font size = 7&gt;💏&lt;/font&gt; &lt;font size = 8&gt;👨‍💻&lt;/font&gt; &lt;font size = 9&gt;🐖&lt;/font&gt; &lt;/body&gt; &lt;/html&gt; 效果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d9d241b8ea58cf38c2d6c344b14395a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fee457e0d3485752290ee5e3bfb65ddc/" rel="bookmark">
			我该如何解除微软账户儿童模式？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前注册微软账户时把日期填成小于14岁的了，现在出现由于你的家庭安全设置，你不能使用 Google Chrome。
您可以访问以下网页
https://account.microsoft.com/family/home?lang=...
首先登陆后点击添加家庭成员，添加此账户
之后访问以下网页
Sign in to your Microsoft account
点击编辑这个孩子的个人信息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40aeac28bdbcf9aa514aa09bacd81bae/" rel="bookmark">
			Obsidian使用教程（如何构建你的个人知识库，第二大脑）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、简介二、与Typora的图片兼容性问题三、基本的使用3.1 创建一个仓库3.2 创建文件夹/笔记3.3 笔记之间的链接3.4 全局搜索功能3.4 缩略预览功能 四、第三方插件推荐1、 File Explorer Note Count（笔记数量统计）2、Calendar（日历插件）3、增强编辑存在问题 4、Clear Unused Images（批量删除未引用的图片）4.1 如何使用 五、问题解决：无法加载社区插件步骤: 一、简介 安装下载：
https://obsidian.md/download
Obsidian采用markdown文档编辑器，提供强大的笔记链接功能，支持单向链接、反向链接和双向链接，可以自由地链接文档、文本内容块。它拥有丰富的插件，例如阅读PDF文档时随手标记、标记视频播放时间（在观看视频课程时，你觉得某一段很重要，就标记一个“时间戳”，Obsidian自动生成链接，复习时只要点一下链接，就从标记处开始播放）、自动整合文档中的标题及列表生成思维导图。
该软件采用本地存储策略，所有的文档都存储在用户的硬盘中，无须账号、无须登录。
这是我用Obsidian生成的个人知识网络关系图谱
你可以用它来管理你的众多用Typora写的markdown格式的笔记。
二、与Typora的图片兼容性问题 不更改设置会遇到的问题：
从obdisian中插入的图片跟typora中插入的图片在不同的文件夹在obsidian中插入的图片在typora中不显示的问题 完成以下三步操作即可解决：
1、图片显示
设置如图所示：
2、图片放置的位置
设置如图所示：
3、更改Typora的图片设置
这样无论是使用Typora还是Obsidian，图片都能够正常显示了。
其实更好的方案是使用图床，这个我暂时还没用，等用了再来补充。
三、基本的使用 这里介绍一些最基本的操作，让你能够直接上手进行使用。
3.1 创建一个仓库 就相当于将你的笔记全部都放到一个文件夹下面，让Obsidian进行管理
3.2 创建文件夹/笔记 创建文件夹
创建笔记（markdown格式）
3.3 笔记之间的链接 直接打【【 或[[就会出现你已经有的笔记列表，然后选择一个进行链接。
链接后，按着ctrl键单击就能直接跳转，这在你笔记很多的时候是很有用的。还能够在关系图谱中进行显示。
两条笔记之间进行链接
查看关系图谱，笔记多了之后，你的知识地图就会构建起来啦，就像我开头的那张图一样。
3.4 全局搜索功能 当笔记很多的时候，就算是分好层级了，找起来也比较慢，这时候就需要用到这个全局搜索了，obsidian这个全文检索的速度还是很快的，笔记再多也不怕。
我们从这个左上角点击这个放大镜就能进入搜索功能了，然后输入要搜索的关键字就可以了。
3.4 缩略预览功能 obsidian还有一个我比较喜欢且比较实用的功能，就是能在小窗口中查看一个文件的内容，你在不打开这个文件的情况下就能预览它的内容。
其他的操作可以自己慢慢摸索，如果有想知道的可以去看官方帮助文档，能帮助你更快的上手。
官网中文帮助文档：https://publish.obsidian.md/help-zh/%E7%94%B1%E6%AD%A4%E5%BC%80%E5%A7%8B
四、第三方插件推荐 为了让Obsidian更好用，更符合我们的使用习惯，除了Obsidian自带的插件外，我们还可以安装第三方插件对Obsidian的功能进行扩展。
我们打开设置，关闭安全模式，然后浏览插件市场，搜索插件并进行安装。
注意：在不同的笔记仓库中，插件可能显示的不同，我们只需要把.obsidian文件夹下的plugins文件夹粘贴到想要用的仓库中即可。
我们可以看到是有非常多的插件的。
下面介绍几个好用的插件（持续更新）：
1、 File Explorer Note Count（笔记数量统计） 这款插件的作用是进行笔记数量统计功能的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40aeac28bdbcf9aa514aa09bacd81bae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57f262c7b39df2bf5d8f977e65f0154c/" rel="bookmark">
			Microsoft Family Safety Microsoft 家庭安全将人员添加到你的家庭组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在 创建家庭组 后，通过添加家庭成员来浏览 Microsoft 家庭安全 的功能和权益！
如果某人已是家庭组成员，则在加入另一个组之前，他们必须 退出该组或从该组中删除。 他们还可以 创建一个新的 Microsoft 帐户 以与新的家庭组相关联。 家庭组织者 可以通过执行以下步骤来添加家庭成员。 Web
使用 Web 浏览器访问 family.microsoft.com。 登录 Family Safety 帐户。
单击添加家庭成员。
输入家庭成员的电话号码或电子邮件地址，单击下一步。
确定家庭成员角色（成员或组织者），然后单击下一步 &gt; 邀请。
注意: 受邀者将通过电子邮件收到加入的链接。 它会提示他们登录到其 Microsoft 帐户以接受并加入家庭组。 如果他们未满法定年龄，他们还将收到请求成人许可的提示。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f70d6c1344ba4a8b042a9cb7e4b0c436/" rel="bookmark">
			31. 深度学习进阶 - 全连接层及网络结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hi，你好。我是茶桁。
之前的课程咱们学习了卷积以及池化，那到底卷积是如何构成卷积神经网络的呢？我们这节课来好好讲一下。
全连接层 整个卷积的运算就是经过卷积，再经过pooling，再经过卷积。会把这个图形变的很小。然后再经过pooling，又会一直把我们的特征变得越来越小，之后有一个很重要的层，这个层叫做全连接层。
后面的几个柱状图就是它的线性变化，就是它的全连接层。
先是将图片卷积、池化变小，变成很小的高级特征，然后拉平之后进入全连接层进行线性变化。 这就是卷积操作的整个工作流，也是为什么卷积操作需要的参数少的原因。
我们在这里重点说一下全连接层。
我们做了很多pooling， 很多卷积之后，我们会生成一个很厚的一个值。把很厚的这个值给他拉平，在PyTorch里面直接就flatten, 或者用reshape直接进行，把它拉平成一个1乘以n的一个向量。然后给这个1乘以n进行熟悉的wx+b。
我们对它进行线性变化，第一是对它的维度进行了变化。假如要给它变成一个10分类，纬度进行的变化。
另外一点，我们每一层都会有不同的特征点，这些特征点代表这图像不同的位置把它抽象成的值。然后一层一层的，又是不同的filter的结果，提取出来的不同的特征。比如横向，竖向之类的。机器可能还会自动提取一些颜色，形状等等。
那么现在我们要把这些东西进行一个综合考量，要把这些信息全部拿起来综合做个判断。比如我们有三个filter, 也就是有三层，这三层里面拿出四个位置。 那么拉平的画，就变成3乘以4，这里面有12个数值。这12个数值提取出来通过不同的方式了，关注点不同，提出来的12高级特征。
现在要把这12个高级特征全盘考虑、综合考虑。我们要给这些数据加一个不同的权重。就要给它做一个wi * xi，就给它这些全盘综合做了一个权重的这个赋值。
所以说，全连接不仅对维度进行了变化，它还对之前提取出来的局部信息进行了综合，这个就是全连接层的作用。既进行了变化又进行了维度信息的综合。
所以说，大家看一下
这些不同的著名的网络结构，都是进行完之后要进行线性变化，线性变化之后把它变到我们期望的target上，就是最前面的这些东西进行综合。
算出来这个数值之后，然后用全连接层进行分类。但是全连接层不一定是只能进行分类，其实还进行特征的一个变化。
进行线性变化完了之后，通过Softmax，然后再给它进行cross-entropy，就可以求出它的loss值了。
其实最近几年，就从2019年左右开始呢，其实大家慢慢的不用Softmax和cross entropy了，当然用这个也可以。为什么不用了呢？
比方我现在有三个图片，IMAGE1、IMAGE2和IMAGE3，对应的label分别是3、5、6。那么要做cross-entropy的时候，就要把3变成[0,0,1,0,0,0,0,0]，然后5和6都要进行变化。然后才能跟Softmax预测出来这个probability做cross-entropy。也就是说，在这里要进行一次one-hot编码。结果后来就发现可以做一个简化操作，进行了Softmax之后给它前面加个log。
假如说，Softmax之后是0.1, 0.3, 0.3, 0.2, 0.1, 给它加个log,就会是一个负的比较大的数字，越接近于1，比方0.99，越接近于1结果会越接近于0，越远离1，这个负的值会越大。
所以现在大家会有一个非线性变化，叫做log Softmax，出来的结果就是负的。然后还有一个loss叫做NLLloss, negative log likelihood loss，这个在PyTorch里边也有。
这个有趣的地方就来了，如果我们它的label是3，直接来看一下log之后的值是不是-3, 给它再取个负号，那么就直接说这个的loss是3。如果它的label是5，那么log之后是另外一个值，假如说是-0.7，那么它取5，我们发现结果是-0.7，加个负号，它的loss直接就是0.7。
这样就不需要进行one-hot编码了，而且也能达到一个效果，就是我们期望的地方越接近于1，loss越接近于0。
所以，现在在工作中，我们看大量代码都开始这么做了，相当于是一个简化板的Softmax。
那这个呢就是我们整个卷积神经网络的工作流程，全连接层的作用大家一定要知道。
好，我们做一个总结。第一节课，给大家讲解卷积的原理。那么什么是卷积神经网络呢？只要用了卷积(Conv)这个操作的网络, 它就叫卷积神经网络。所以理论上，你可以让一个图形先经过卷积，再经过RNN，再经过卷积，再经过RNN，都可以。这个你既可以叫它卷积网络，也可以叫它循环神经网络。
然后呢跟大家说了CNN可以用在很多地方，比方说分类，探测，还有分割，其实背后都是卷积神经网络在做。
还有给大家讲了filters, padding, stride和channel，它的作用。除此之外，我们讲了Parameters sharing和Location Invariant。
在整个过程中，我们哪一层做卷积，哪一层做pooling，线性变化做几层，是不是纯靠经验？说白了这个确实还是纯靠经验，所以有一个很重要的特点就是我们需要去借鉴，我们需要去借鉴前人的经验。
几种神经网络结构 我们需要看前人的网络结构是怎么搭的，有几种比较重要的结构，LE-NET5，ALEX-NET。Alex那个net结构就是2012年ImageNet取得第一名的，上面有图。
它的特点就是第一次用Relu去做了非线性变化, 作用就会进行的比较快，它还在GPU上进行运算。
Relu就是一个非线性变化，如果把它做了卷积操作之后，给它再加个Relu，可以把它值再进行一个非线性变化就可以了，就是把它卷积出来的结果做了一个非线性变化。
GPU运算的作用是什么呢？GPU为什么重要？
假设现在有一张1万 * 1万的一张图，有3 * 3的卷积核，如果说原始的状态我们得先从左到右再从上到下的做。我们得进行998乘以998次移动。
有GPU的话，我们可以让其中一部分在GPU的某个地方进行计算，另外一部分同时在GPU的另外一个地方计算，就可以分布式的。因为GPU所做的事情就是把矩阵运算可以分布式的在不同的地方并行运算。
这就是为什么有GPU玩游戏不卡，因为加载图片的时候它一部分图片在GPU某个地方加载，另外一部分图片在GPU另外一个地方加载，这是同时一起加载的。
如果年龄在30岁以上的小伙伴应该知道，以前看网页的时候那个大的图片会一行一行显示出来，就90年代末那会儿，图片是一行一行一行显示出来的。而对于GPU的话，显示图片是一块一块一起去渲染的。
那么对于卷积神经网络来说，这一块一块的filters，也是一起渲染一起计算的。所以说在做一层的计算的时候它就快了。而且如果你的GPU足够多，你还可以让它每一层的filters也并行计算。每一层的filters在每一块上又可以快速计算。
所以有了GPU的运行速度可以快十几倍，二十几倍，甚至上百倍都可以。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f70d6c1344ba4a8b042a9cb7e4b0c436/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b4cfa34f219107984d47776c323a185/" rel="bookmark">
			给定一个未排序的整数数组 nums ，找出数字连续的最长序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目: 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。你设计并实现时间复杂度为 O(n) 的算法解决此问题
如:nums = [100,4,200,1,3,2],最长数字连续序列是 [1, 2, 3, 4]。它的长度为4。
思路: 1.把所有数都先放在set集合中去重
2.利用贪心思想，假设每个数都有可能是最长序列的首数字
3.返回最大长度
代码: //方法1
public static int longestConsecutive2(int[] nums){
if(nums.length==0){
return 0;
}
Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) { set.add(nums[i]); } /** * 有一点贪心的思想,假设每个位置都有可能在最长序列的第一个位置 * 1.把所有数放在set集合中 * 2.判断+1的数是否在集合中存在，如果存在就把长度+1 * 3.返回最大长度 */ int max = 0; for(int j=0;j&lt;nums.length;j++){ if(!set.contains(nums[j]-1)){ int cur = nums[j]; int count = 1; while (set.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b4cfa34f219107984d47776c323a185/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f353f8fc7a04f29d8c53ab16b98d4ee/" rel="bookmark">
			Mybatis基础教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyBatis是一个可以自定义SQL、存储过程和高级映射的持久层框架
1.Mybatis基本配置 1.1引入Mybatis 要使用 MyBatis， 只需将 mybatis-x.x.x.jar 文件置于类路径（classpath）中即可。
如果使用 Maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中：
&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt; &lt;/dependency&gt; 1.2导入Mybatis相关jar包 &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.21&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;/dependency&gt; 1.3编写resources下的文件 1.3.1编写Mybatis核心配置文件 MyBatis的配置文件是一个XML文件，包含了MyBatis的大部分配置信息，例如数据库连接信息、映射文件位置、缓存配置等，放在resources下面。
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;!-- 数据库连接信息 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="com.zaxxer.hikari.HikariDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/test?useSSL=false&amp;amp;serverTimezone=Asia/Shanghai"/&gt; &lt;property name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f353f8fc7a04f29d8c53ab16b98d4ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24e8b08b605a224a9d41f349ba0ee60b/" rel="bookmark">
			生产问题（十二）GC垃圾回收导致空指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 最近线上出现由于线程池任务执行超时导致的空指针，按道理说基本不会很多执行超时的，看了看监控，那个时间点发生了gc，gc时间超过5s。
说明这次是gc垃圾回收导致的问题，实际上需要排查解决的是垃圾回收问题。表象总是和实际的原因差距很大。
二、环境 操作系统、容器环境没什么好说的，主要是GC相关的
jvm参数：
-Xmx12288m -Xms12288m -Xss256k -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=256m -XX:MaxGCPauseMillis=200 -XX:+UseG1GC -XX:-OmitStackTraceInFastThrow -XX:MinHeapFreeRatio=30 -XX:MaxHeapFreeRatio=50 -Djava.util.concurrent.ForkJoinPool.common.parallelism=4 -XX:CICompilerCount=3 -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=512m -XX:ActiveProcessorCount=4 -XX:+PreserveFramePointer -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=32M -XX:+HeapDumpOnOutOfMemoryError gc收集器是g1
最大堆大小：12288.00 MB
最大非堆大小：1256.00 MB
g1是整堆收集，收集他定义的region策略。所以监控上所有的gc时间都给到了young gc，达到5s，是让同事很疑惑的。其实监控显示的不太对，属于汇总时间。
三、分析-TCP丢包 这个方向实际对不上这个问题，只是有一些特征显示有这种可能，后面被其他机器的现象排除了。
但是这个猜测方向有没有必要呢，当然是有的。发现问题去排查解决本来就是根据原理先提出一些方向，对这些方向进行论证，排除错误的方向，留下可能的方向再去找依据支持这个论点，再通过实验解决问题。
即使一个方向对不上这次的问题，只要他的理论没有问题，他就可能在下一次映射在其他的问题上。老话说的好：大胆猜测，小心求证。
1、丢包监控 作者为什么会产生丢包影响gc的猜测呢？因为在监控上显示在对应的时间点发生了tcp丢包重传的问题，监控拉长之后这个突峰也是非常明显。
但是这个现象为什么会联系到gc延长的问题呢？作者是这样思考的：TCP丢包重传默认上1s，如果是本来很快结束的请求因为重传而迟迟不结束，那么这个处理任务相关的所有对象都不能释放，不能被gc回收。 这也是之前作者的经验，丢包导致了请求延长，有兴趣的同学可以看看之前发生的问题
生产问题（五）TCP丢包排查_tcp connection lost怎么排查-CSDN博客
生产问题（五）TCP丢包解决_tcp丢包的解决方案-CSDN博客
2、TCP参数 有了猜测就看看当前的设置是不是这样，说不定重传设置的很低呢，在机器上输入
sysctl -a 查看一下重传的retrans参数，的确是1s
3、其他机器 接下来需要确认其他机器，是不是所有的发生这种gc延长的机器和对应的时间都有丢包重传的现象。
很明显，作者发现其他机器或者其他时间点都没有，那就不是这个原因。也幸好有多个机器、多个时间点，不然这个可能性不能排查，也就需要更多的验证。
四、分析-GC日志 工具还是挺全的，在机器发布的时候就会生成一份GC日志，后续不断写入，所以可以看到当时发生了什么。
基本上每一个对应的机器和时间点都看到了Evacuation Failure，在region复制转移的时候，对象分配失败了，to-space exhausted也是一个比较明显的特征
五、分析-GC调优 1、G1ReservePercent G1ReservePercent没有设置，那就是默认的10%预留空间给存活对象转移，这个比例是相对于整堆的，那么预留空间就有1.2g左右，这个看起来也是满了，因为Heap: 12115.1M(12288.0M)-&gt;10604.0M(12288.0M)。
那么要不要调大G1ReservePercent呢，作者感觉是不需要的，1.2g不少了，这样还不行，再调大也没什么用处。比例应该没什么问题。
2、G1HeapRegionSize G1HeapRegionSize没有设置，通常情况下，G1 会将堆内存划分为 2048 个 Region，我们堆内存的大小为 12G ，那么每个 Region 的大小为 6MB左右。那么超过1/2Region大小的都会作为大对象准备放入Humongous区域，对象的大小为Region的几倍，会使用多个连续的Humongous区域来存储这个大对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24e8b08b605a224a9d41f349ba0ee60b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9febbab82895f02f55935f5eb953edc/" rel="bookmark">
			burp证书安装_模拟器_pem_真实手机安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模拟器_burp证书安装_pem_真实手机安装 一、下载burp证书，安装openssl http://burp
自己找官网安装openssl
Win32/Win64 OpenSSL Installer for Windows - Shining Light Productions (slproweb.com)
二、查看模拟器端口并连接 adb devices adb connect 127.0.0.1:62026 adb root adb remount openssl x509 -inform der -in cacert.der -out burp.pem openssl x509 -subject_hash_old -in burp.pem 三、 改下生成的burp.cer,并传到模拟器里 burp.pem改名为9a5ba575.0 adb push 9a5ba575.0 /system/etc/security/cacerts/ 四、手机装证书 分两种
1：adb方式
2：自己拿手机移动（无命令行，但需要手机root并安装面具）
第一种 adb devices 手机上允许调试 adb root adb remount	'adb remount' 将 '/system' 部分置于可写入的模式，默认情况下 '/system' 部分是只读模式的。这个命令只适用于已被 root 的设备。 开始传 adb push 9a5ba575.0 /system/etc/security/cacerts/ 第二种 将文件传到手机上自己在mt管理器（需要root权限）上移动
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9febbab82895f02f55935f5eb953edc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44548db42d19434936d259a7020b3a6f/" rel="bookmark">
			redis 缓存穿透、击穿、雪崩、无底洞分析及解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis缓存处理流程:
前台请求，后台先从缓存层取数据，取到直接返回结果，取不到时从存储层取，存储层取到更新缓存，并返回结果，存储层未取到，那直接返回空结果。
缓存穿透：
缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中，导致不存在的数据每次请求都要到存储层去查询，造成存储层压力巨大甚至down机
解放方案：
1)针对不存在的key也缓存一个null值,,同时设置一个过期时间,,(弊端:内存中可能会存放大量无效key、时间窗口数据不一致)
2)采用布隆过滤器,,对于不存在的key直接返回null值
缓存击穿:
指的是某个热点key在过期时间点上,此时有大量请求去查询这个key,,导致存储层压力增大
1)设置热点数据永不过期
2)使用setnx加互斥锁，容易影响吞吐量，大部分项目设置热点key永不过期基本解决问题
缓存雪崩：
某个时刻Redis集群中的热点key都失效了。存储层查询数据量巨大，引起存储层压力过大甚至down机。
和缓存击穿不同的是， 缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。
解决方案：
1)设置热点数据永不过期
2)缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生，是一种比较取巧的解决方案。在一定程度上减轻了存储层的瞬时压力，
但是这种方案也在一定程度上增加了维护的成本
缓存无底洞：
当集群维持到一定个数后，再增加集群个数，性能反而下降的问题
解决方案：
常见的IO优化思路
1)IO优化
1 命令本身的优化，例如优化SQL语句。
2 减少网络通信次数。
3 降低接入成本，例如客户端使用长连/连接池、NIO等。
2)减少网络通信次数（批量操作解决方案）：
1 串行命令：客户端n次get:n次网络+n次get命令本身。
Redis Cluster：无法使用mget命令一次性获取。
优：实现起来比较简单。
缺：时间复杂度较高。大量keys超时严重。
2 串行IO：node次网络时间+n次命令时间。
Redis Cluster：使用CRC16算法计算出散列值，再取对16383的余数就可以算出slot值。
Redis Cluster：Smart客户端会保存slot和节点的对应关系。
优：实现起来比较简单。
缺：时间复杂度较高。大量nodes也会超时严重。
可以得到得到每个节点的key子列表，然后分别对每个结点执行批量操作。
3 并行IO：
将方案2中的最后一步改为多线程执行，网络次数虽然还是节点个数，但由于使用多线程网络时间变为O(1)。
优：利用编程特性，时间取决于最慢的线程。
缺：增加编程复杂度。多线程并发，出现问题定位也会比较难。
4 hash_tag实现：1次网络时间+n次命令时间
Redis Cluster：的hash_tag功能，它可以将多个key强制分配到一个节点上。
优：性能较好。
缺：业务维护成本高。容易出现数据倾斜。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eee0255fc6bec5a68b963da2b2be9f4/" rel="bookmark">
			在线绘制er图:itbuilder
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：介绍
在线画ER图网站：itbuilder，是一个提供用户在线绘制和设计关系型数据库实体关系图（ER图）的网站。其旨在为业内从事数据库开发的工程师、学生等提供一个便捷的、高效的绘制ER图的工具。
二：功能
1.可视化设计表结构，制作ER图
itbuilder提供了直观的可视化界面，让您能够轻松设计表结构并制作ER图。您可以根据个人需求设置颜色、设置表之间字段关联，以及进行灵活的布局。不再需要手动绘制ER图，itbuilder让您的设计更加直观和专业。
2.让AI帮您生成代码
itbuilder内置强大的人工智能功能，可以帮助您生成代码。不论您使用的是Java、Python、JavaScript等编程语言，itbuilder都能涵盖几乎所有语言，并通过插件自动将生成的代码同步到您的开发工具中。让AI为您减轻编码的负担，让您更专注于核心的业务逻辑。
3.DDL导入和导出
itbuilder支持随时查看或导出DDL，用户可以方便地查看表结构的定义或进行导出。同时，也支持PowerDesigner的导入，方便用户从其他软件迁移数据。
4.支持团队协作
itbuilder支持团队多人协作，实时通信，实现无缝协作。多个开发者可以同时在itbuilder上进行表结构设计，轻松共享和协同编辑。无论是本地团队还是远程团队，都可以通过itbuilder实现高效的协作，极大地提升团队的工作效率。
三：适用
1、适用人群：
该网站适用于从事关系型数据库开发的工程师、学生，以及需要进行ER图设计的企业和公司。
2、适用场景：
a、个人和团队在进行数据库设计时，需要快速绘制出ER图；
b、需要对已有的数据库进行优化和修改时，可以将数据模型导入网站进行修改；
c、需要进行团队协作的场景下，可以通过该网站完成在线协作。
总结：
无论您是个人开发者还是团队成员，itbuilder都是您不可或缺的开发工具。它的可视化设计、团队协作和AI代码生成功能，让您的开发过程更加高效和便捷。不仅如此，itbuilder还提供了强大的数据管理功能和安全可靠的云端存储，保证您的数据安全和可靠性。
赶快体验itbuilder吧！让它成为您的得力助手，助您轻松设计表结构、制作ER图，并加速代码开发的过程。不论您是新手还是老手，itbuilder都将成为您迈向成功的重要一步！https://www.itbuilder.cn/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7161602af2ff4bb8644de3827e2d8c1c/" rel="bookmark">
			免费在线数据库表结构设计工具itbuilder
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着数据库规模日趋庞大，数据库设计者所面临的问题也越来越复杂，面对各个用户对数据库结构和内容的不同观点，权衡不同应用对于数据库组织和存取的不同需求，以及大量的结构信息和数据之间的复杂关系，面对这种设计环境，工具就是很重要的存在了，在线数据库表结构设计工具itbuilder可为您解决此问题。
什么是在线数据库设计？ 在线数据库设计是一种通过互联网进行数据库设计和管理的方法。它给用户提供了一个友好的界面，使用户能够轻松地创建、修改和管理数据库。与传统的数据库设计方法相比，在线数据库设计具有更高的灵活性和便捷性。
为什么选择在线数据库设计？ 在线数据库设计具有许多优势，使其成为企业数据管理的理想选择：
灵活性：在线数据库设计工具提供了各种功能和选项，可以根据您的具体需求进行操作使用。您可以根据业务需求添加、删除或修改数据库表和字段。
易于使用：在线数据库设计工具通常具有直观简单的用户界面，使非技术人员也能够轻松地创建和管理数据库。不需要编写复杂的代码或具有专业的数据库知识。
协作性：在线数据库设计工具使团队成员能够共同协作创建和管理数据库。可以邀请其他人加入项目，并共享设计和修改数据库的权限。
实时更新：在线数据库设计工具可以实时更新数据库结构和数据，使您能够及时获取最新的信息。
安全性：在线数据库设计工具通常具有安全措施，可以保护您的数据免受未经授权的访问和损坏。
怎么用itbuilder软件在线创建数据库表结构？ AI建表
输入需求，AI会进行需求分析，根据分析设计表结构，我们可以对认可的表结构设计进行勾选保存。
手动建表
手动输入表名称，在“字段设计器”中设计表的字段、索引、外键，可以根据喜好重新定义结构、表单和表单之间的关系。
建表后可创建er图来表示表之间的关联状态，更直观让人看到其他用户看到。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a018f48683fe46916aab8ec549cdb94/" rel="bookmark">
			CSS新手入门笔记整理：CSS3颜色样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		opacity透明度 语法
div{opacity:数值;} opacity属性的取值范围为0.0~1.0。其中0.0表示完全透明，1.0表示完全不透明。opacity属性不仅作用于元素的背景颜色，还会作用于内部所有子元素以及文本内容。 RGBA颜色 RGB是一种色彩标准，由红（Red）、绿（Green）、蓝（Blue）3种颜色变化来得到各种颜色。而RGBA是在RGB基础上增加了一个透明度通道Alpha。
语法
div{background-color:rgba(R, G, B, A)；} div{background-color:rgba(255, 255, 0, 0.5)；} div{background-color:rgba(50%, 80%, 50%, 0.5)；} R，指的是红色值（Red）；G，指的是绿色值（Green）；B，指的是蓝色值（Blue）；A，指的是透明度（Alpha）。R、G、B这三个参数可以为整数，取值范围为0~255，也可以为百分比，取值范围为0%~100%。参数A为透明度，跟opacity属性是一样的，取值范围为0.0~1.0。
渐变 线性渐变linear-gradient 语法
div{background:linear-gradient(方向, 开始颜色, 结束颜色)；} 线性渐变的“方向”取值有两种:
一种是使用角度（单位为deg）另一种是使用关键字 线性渐变的“方向”取值
属性值
对应角度
说明
to top
0deg
从下到上
to bottom
180deg
从上到下(默认值)
to left
270deg
从右到左
to right
90deg
从左到右
to top left
无
从右下角到左上角(斜对角)
to top right
无
从左下角到右上角(斜对角)
线性渐变也可以接受一个“值列表”，用于同时定义多种颜色的线性渐变，颜色值之间用英文逗号隔开即可。
径向渐变radial-gradient 语法
div{background:radial-gradient(position, shape size, start-color, stop-color)；} div{background:radial-gradient((center, orange, blue))；} position用于定义圆心位置。shape size用于定义形状大小，由两部分组成，shape定义形状，size定义大小。start-color和stop-color分别用于定义开始颜色和结束颜色。其中，position和shape size都是可选参数。如果省略，则表示采用默认值。start-color和stop-color都是必选参数，可以有多个颜色值。 圆心位置position position常用取值有两种：一种是“长度值”（如10px），另一种是“关键字”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a018f48683fe46916aab8ec549cdb94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55f8c2a92bff97b0e85103db3950e1a2/" rel="bookmark">
			缓存清除 刷新与预热的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理介绍 缓存刷新方式有URL刷新、目录刷新,URL剧新是以文件或一个资源为单位进行缓存刷新;目录刷新是以目录为单位,将目录下的所有文件进行缓存刷新。预热是以文件为单位进行的缓存预热。泛域名不支持直接预热或刷新,可以通过具体的域名做剧新或预热。如果泛域名是共享缓存的,使用其中任意一个具体域名做刷新或预热即可。
刷新与预热的区别 刷新后,会删除该资源在所有CDN节点上的缓存。当用户请求到达节点时,节点会回源站拉取对应的资源,返回给用户并缓存到节点,保证用户获取到最新的资源。刷新功能会降低缓存命中率。
预热后,该资源会提前被缓存到CDN节点上。当用户请求到达节点时,可以直接在节点获取到资源。预热一般在集中资源要发布前进行,会很大程度降低源站的压力。预热功能会提高缓存命中率。
PS: 您在源站上更新资源后，如果希望用户访问时不再获取旧资源，直接获取新资源，您可以使用URL刷新或目录刷新功能。如果希望CDN预先将资源由源站主动缓存至CDN节点,则可以使用预热功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81cc036b88ea458e2e4d0f0e9ee7f1e6/" rel="bookmark">
			易优建站修改文章模板中的地图大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是新建了一个栏目放置的百度地图
然后再这个栏目下创建地图
然后再页面中添加代码标签，显示地图，其实就是显示文章的内容
接下来就是修改地图的大小
第一步：打开文件public/plugins/Ueditor/dialogs/map/show.html
第二步：打开同级文件下的map.html文件
第三步：修改放置地图的iframe大小即可，可以在template/pc/skin/css/style.css中添加样式，也可以自己创建新的css文件下添加样式即可
】
一定要是.ueditor_baidumap这个样式名
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e90bec4ebc01c042b2744f0d275f0090/" rel="bookmark">
			json-server 的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		json-server 的使用 功能 json-server可以直接把一个json文件托管成一个具备全RESTful风格的API,并支持跨域、jsonp、路由订制、数据快照保存等功能的 web 服务器。
简单说：node启动服务，使用本地一个json文件，快速形成一个具备CRUD的接口服务。方面前台临时调试使用。
Json-server 是一个零代码快速搭建本地 RESTful API 的工具。它使用 JSON 文件作为数据源，并提供了一组简单的路由和端点，可以模拟后端服务器的行为。
github地址：https://github.com/typicode/json-server
npm地址：https://www.npmjs.com/package/json-server
环境准备 电脑已安装node ,配置环境变量。
创建工程 创建工程目录(不要叫json-server)，如D:\workspace\json-server-demo，在工程目录下执行npm init，输入项目名、描述、作者(如果不输入就是默认的，直接回车)执行成功后，工程目录下会出现一个package.json文件继续执行npm install json-server –save安装json-server模块。–save就是将模块存储到package.json文件中 4.修改package.json 添加scripts指令
“json:server”: “json-server --watch db.json” 5.输入指令npm run json:server运行项目，命令中的“json:server”就是在package.json的scripts中配置的命令。
访问http://localhost:3000
CRUD &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;删除数据&lt;/title&gt; &lt;script src="./jquery.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id="delete"&gt;删除数据&lt;/button&gt; &lt;script&gt; //查询数据 // $("#delete").click(function() { // $.ajax({ // type: 'get', // url: 'http://localhost:3000/articles', // dataType: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e90bec4ebc01c042b2744f0d275f0090/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/317ef68e0c4afaf3d3a8ebc3eedc213d/" rel="bookmark">
			Python语言来操作Android应用程序的用户界面，从而实现自动化！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介
Android Uiautomator2 Python Wrapper是一个强大的开源项目，旨在简化Android应用程序的自动化测试过程。它提供了一个易于使用的Python包装器，基于Google开源的Uiautomator2库，使开发人员和测试人员能够更轻松地编写和运行自动化测试脚本。
为什么选择Android Uiautomator2 Python Wrapper？
无缝集成：该项目是基于Uiautomator2库构建的，该库是Google官方提供的用于进行Android自动化测试的工具。通过使用Android Uiautomator2 Python Wrapper，开发人员可以无缝集成现有的Uiautomator2功能，并利用Python的灵活性进行更高级的自动化测试。
简化的API：Android Uiautomator2 Python Wrapper提供了一个简洁、直观的API，使用户能够轻松地定位和操作Android应用程序的UI元素。无论是点击按钮、填写表单还是验证文本，都可以通过简单的几行代码完成，大大减少了编写测试脚本的时间和工作量。
强大的设备兼容性：Android Uiautomator2 Python Wrapper支持广泛的Android设备，可以在各种不同型号和版本的设备上运行自动化测试。这使得开发人员和测试人员能够在不同的设备上验证应用程序的兼容性和稳定性，提高了测试的全面性和可靠性。
丰富的测试功能：该项目提供了丰富的测试功能，包括UI元素的查找和操作、滚动和拖动、截图和录屏、设备信息获取等。开发人员和测试人员可以根据具体的测试需求，灵活地利用这些功能进行全面的自动化测试。
使用Android Uiautomator2 Python Wrapper的示例代码
下面是一个简单的示例代码，展示了如何使用Android Uiautomator2 Python Wrapper进行自动化测试：
from uiautomator2 import Device
连接到设备 device = Device()
打开应用程序 device.app_start(“com.example.app”)
点击登录按钮 device(text=“登录”).click()
填写用户名和密码 device(className=“android.widget.EditText”, instance=0).set_text(“username”)
device(className=“android.widget.EditText”, instance=1).set_text(“password”)
点击确认按钮 device(text=“确认”).click()
验证登录成功 assert device(text=“欢迎回来！”).exists
截图保存 device.screenshot(“login_success.png”)
关闭应用程序 device.app_stop(“com.example.app”)
通过以上示例代码，可以看到使用Android Uiautomator2 Python Wrapper进行自动化测试非常简单直观，开发人员和测试人员可以快速编写出高效可靠的测试脚本。
结论
Android Uiautomator2 Python Wrapper是一个强大且易于使用的开源项目，为开发人员和测试人员提供了简化Android自动化测试的利器。通过它，用户可以轻松编写和运行自动化测试脚本，验证应用程序的功能和性能，提高开发效率和测试质量。无论是个人开发者还是企业团队，都可以从这个项目中获益，并加速他们的Android应用程序开发和测试过程。
项目地址：https://github.com/openatx/uiautomator2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b93d160f6c1861a0dd6331731b83cf7/" rel="bookmark">
			cryptoJS模块和Node.js的crypto模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Node.js的crypto模块和cryptoJS模块都是用于加密和解密数据的库，但它们之间有一些区别。
区别 功能：Node.js的crypto模块提供了基本的加密和解密功能，而cryptoJS模块则提供了更多的加密算法(支持多种加密算法，如AES、SHA等)和工具(提供丰富的加密工具，如HMAC、MD5等)。
性能：cryptoJS模块的性能通常优于Node.js的crypto模块，因为它使用了更高效的算法和优化。
兼容性：cryptoJS模块支持更多的浏览器环境，而Node.js的crypto模块主要针对服务器端环境。
社区支持：cryptoJS模块有更大的社区支持和更多的文档，因此更容易找到解决问题的方法。
使用crypto const crypto = require('crypto'); // 生成密钥对 const { publicKey, privateKey } = crypto.generateKeyPairSync('rsa', { modulusLength: 2048, }); // 加密数据 const data = 'Hello, world!'; const encryptedData = crypto.publicEncrypt(publicKey, Buffer.from(data)); console.log('加密后的数据：', encryptedData.toString('base64')); // 解密数据 const decryptedData = crypto.privateDecrypt(privateKey, encryptedData).toString(); console.log('解密后的数据：', decryptedData); 使用cryptoJS const CryptoJS = require('crypto-js'); // 生成密钥对 const keyPair = CryptoJS.lib.WordArray.random(256 / 8); const publicKey = keyPair.words; const privateKey = keyPair.sigBytes; // 加密数据 const data = 'Hello, world!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b93d160f6c1861a0dd6331731b83cf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bef692b939ef785deae81a52a6061ddb/" rel="bookmark">
			CSS 设置文字间距
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		span {
letter-spacing: 0.1em;
}
所有文本都将具有 0.1em 的字符间距。如果想让字符之间的距离更远，可以将值设为更大的正值，例如 0.2em 或 0.3em。如果想让字符更接近，可以将值设为负值，例如 -0.1em 或 -0.2em。
需要注意的是，letter-spacing 属性不会影响单词之间的间距，只会影响字符之间的间距。如果想要控制单词之间的间距，可以使用 word-spacing 属性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ff38d39e1a84427aa6391d1c63fe7db/" rel="bookmark">
			Charles 修改请求和响应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Charles 修改请求和响应 已有请求 http://172.17.1.1:8080/test/health
设置请求断点 断点明细设置
开启断点
新增接口设置
其中 query 设置为 *
修改请求 修改响应 注意，charles 拦截请求最后还是会请求到服务器端的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ad89a6a85a65153cc4140ca8b310837/" rel="bookmark">
			Mybatis配置-环境配置（environments）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyBatis支持配置多个环境，这有助于将您的SQL映射应用于多个数据库，无论出于何种原因。例如，您可能希望为开发、测试和生产环境使用不同的配置。或者，您可能有多个共享相同模式的生产数据库，并且想要在两者上使用相同的SQL映射。有许多使用情况可以考虑。
有一件重要的事需要记住：虽然您可以配置多个环境，但在每个SqlSessionFactory实例中只能选择一个环境。
因此，如果您想要连接到两个数据库，您需要创建两个SqlSessionFactory实例，每个实例连接一个数据库。对于三个数据库，您需要三个实例，依此类推。这是非常容易记住的。
每个数据库使用一个SqlSessionFactory实例。 要指定要构建的环境，只需将其作为可选参数传递给SqlSessionFactoryBuilder。接受环境参数的两种签名是：
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties); 如果省略了环境参数，则会加载默认环境，如下所示：
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, properties); environments元素定义了环境的配置。
&lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"&gt; &lt;property name="..." value="..."/&gt; &lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="${driver}"/&gt; &lt;property name="url" value="${url}"/&gt; &lt;property name="username" value="${username}"/&gt; &lt;property name="password" value="${password}"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; 请注意以下关键部分：
默认环境ID（例如 default="development"）。每个定义环境的环境ID（例如 id="development"）。事务管理器的配置（例如 type="JDBC"）。数据源的配置（例如 type="POOLED"）。 默认环境和环境ID可以根据您的喜好进行命名，只要确保默认环境与其中一个环境ID匹配即可。
transactionManager
MyBatis包含两种事务管理器类型（即type="[JDBC|MANAGED]"），它们分别是：
JDBC – 这个配置直接使用JDBC的提交和回滚功能。它依赖于从数据源（dataSource）获取的连接来管理事务的范围。默认情况下，它在关闭连接时启用自动提交，以保证与一些驱动程序的兼容性。然而，对于某些驱动程序来说，启用自动提交不仅是不必要的，而且还是一个昂贵的操作。因此，从版本3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ad89a6a85a65153cc4140ca8b310837/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43cf0fb9516fb11ff8bcf19692833907/" rel="bookmark">
			2017年第六届数学建模国际赛小美赛B题电子邮件中的笔迹分析解题全过程文档及程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2017年第六届数学建模国际赛小美赛 B题 电子邮件中的笔迹分析 原题再现： 笔迹分析是一种非常特殊的调查形式，用于将人们与书面证据联系起来。在法庭或刑事调查中，通常要求笔迹鉴定人确认笔迹样本是否来自特定的人。由于许多语言证据出现在电子邮件中，从广义上讲，笔迹分析还包括如何根据电子邮件的语言特征识别作者的问题。
作者归属是语言学家开始使用语言风格的可识别特征（从词频到首选句法结构）来识别有争议文本的作者的过程。电子邮件内容短小，作者语言风格明显。请构造一个有效的模型，通过捕获电子邮件的语言特征来识别作者。您可以使用安然电子邮件数据集来培训和测试您的模型。
安然电子邮件数据集链接：http://bailando.sims.berkeley.edu/enron_email.html
整体求解过程概述(摘要) 本文开发了一个工具，可以用来识别这类电子邮件的作者。作者的风格可以通过测量文本中的各种茎秆特征来简化为一种模式。电子邮件还包含可测量的宏结构特征。这些特征可与支持向量机（SVM）学习算法一起使用，以分类或将电子邮件的作者身份归属给作者，提供适当的消息样本以供比较。
首先，第3章讨论了实验过程的计划和范围，该实验过程用于确定分析电子邮件的作者特征和识别电子邮件的作者身份是否可行。概述了需要评估的特征列表，并说明了为什么要使用支持向量机（SVM）算法进行这项工作。特征集包括但不限于：基于文档的特征、基于单词的特征、虚词比率、字长频率分布、搭配频率、基于字符的特征和字母2-gram。
接下来，第4章详细介绍了为对电子邮件作者进行系统分类而进行的实验，并报告了实验结果。这是通过首先进行一系列实验来完成的，这些实验旨在揭示纯文本块（不是电子邮件）的成功SVM作者属性的基线值，从而设置特征集、文本大小和消息数量的约束。这些基线实验为该项目的核心——识别电子邮件文本中包含的有用特性的任务——设置了框架。本章报告的实验列表见表12（第25页）。第38页报告了这些结果，证实了迄今使用的方法可作为进一步研究电子邮件数据的基础。
最后，第5章讨论了电子邮件的属性和分析。第5.1节讨论了对电子邮件数据进行的初步实验。电子邮件数据用于本章中讨论的实验，因此可以首次测试电子邮件特定功能的影响。第5.2节概述了如何改进结果。第5.3节确定了电子邮件中讨论主题的影响。本研究的目的是使用加权的宏平均F1度量，在大约85%的水平上实现电子邮件数据的正确分类。本章报告的结果表明，在增加了电子邮件的结构特征之后，这一目标就实现了。本章报告的实验列表见表22（第39页）。
最后一章对本文的主要结论进行了总结。这也为今后的工作提出了一些可能的扩展。
模型假设： •我们已经考虑的因素发挥着至关重要的作用。
•我们收集的数据是准确的。
•人们的写作习惯没有改变。
问题分析： 问题背景:
许多公司和机构已经开始依赖因特网来处理业务，随着个人使用因特网，特别是自万维网建立以来，电子邮件流量显著增加。Lyman和Varian（2000年）估计，2000年将发送5 000亿至6 000亿封电子邮件，进一步估计到2003年，每年发送的电子邮件将超过2万亿封。在GVU’s1第8次WWW用户调查中（Pitkow等人，1997年），84%的受访者表示电子邮件是不必要的。
随着电子邮件流量的增加，出于不正当的原因，电子邮件的使用量也随之增加。误用的例子包括：发送垃圾邮件或未经请求的商业电子邮件（UCE），这是垃圾邮件的广泛传播；发送威胁；发送恶作剧；以及计算机病毒和蠕虫的传播。此外，贩运毒品或儿童色情制品等犯罪活动很容易通过发送简单的电子邮件来协助和教唆。
本文讨论的问题包括：
•设置使用支持向量机进行分类实验的框架
•选择候选文体特征以解决电子邮件作者分类问题
•确定测试电子邮件作者身份分类是否成功的实验序列
模型的建立与求解整体论文缩略图 全部论文请见下方“ 只会建模 QQ名片” 点击QQ名片即可 部分程序代码：(代码和文档not free) with open('x_C.pickle','rb') as f: x_C = pickle.load(f) f.close() with open('y.pickle','rb') as f: y = pickle.load(f) f.close() with open('x_W.pickle','rb') as f: x_W = pickle.load(f) f.close() with open('x_F.pickle','rb') as f: x_F = pickle.load(f) f.close() with open('x_L.pickle','rb') as f: x_L = pickle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43cf0fb9516fb11ff8bcf19692833907/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9dfbcd2b3c7cb4b11b6672d682dd38d/" rel="bookmark">
			Charles 代理谷歌浏览器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Charles 代理谷歌浏览器 window 打开代理设置 在网络 -&gt; 代理设置
charles设置 设置代理根证书 安装到受信任根证书颁发机构
charles设置代理端口 和window 设置的端口一致 如 8888, proxy-&gt;proxy Settings
问题 您目前无法访问 因为此网站使用了 HSTS
在谷歌浏览器 访问 chrome://net-internals/#hsts删除指定的域名即可删除指定的域名即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0981e4f0f5c783aebb9e5c4089d34b1/" rel="bookmark">
			Unity 物体高亮插件 Highlighting System 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图 下载链接 链接：https://pan.baidu.com/s/1ojCibjIt6FpBej6KRw3mtw
提取码：nngq
使用简介 导入插件
HighlightingSystemEditor.cs：脚本用来控制高亮插件的渲染。
HighlightableObject.cs：挂载到需要高亮的物体
HighlightingEffect.cs：挂载到需要显示高亮物体的摄像机上，不然不渲染
HighLightControl.cs.cs：自定义控制物体高亮的脚本给摄像机挂载HighlightingEffect.cs脚本：
给需要高亮的物体添加HighlightableObject.cs和HighLightControl.cs.cs脚本：
运行程序，查看效果：
常用函数 ReinitMaterials()：如果高亮显示的对象更改了其材质或子对象，则调用此方法。可以在每次更新时调用多次——渲染器的重新初始化将只发生一次。
OnParams(Color color)：为一帧高亮模式设置颜色。
On()：打开一帧高亮。
On(Color color)：用指定的颜色打开一帧高亮。每次可以调用多次更新，颜色只有从最新的调用才会被使用。
FlashingOn(Color color1, Color color2)：闪烁的参数设置。使用默认闪烁频率
FlashingParams(Color color1, Color color2, float freq)：闪烁的参数设置。参数：开始颜色，结束颜色，闪烁频率
FlashingOff()：关闭闪烁
FlashingSwitch()：切换闪烁模式
ConstantParams(Color color)：设置恒定高亮颜色。
ConstantOn()：淡入持续高亮
ConstantOff()：淡出持续高亮
ConstantOnImmediate()：立即打开持续高亮
ConstantOnImmediate(Color color)：立即用给定的颜色打开持续高亮(不褪色)。
HighlightingEffect.cs脚本参数 每个参数具体表现自行测试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aa495e05a97961de0dbebdae38e6fd2/" rel="bookmark">
			2017年第六届数学建模国际赛小美赛A题飓风与全球变暖解题全过程文档及程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2017年第六届数学建模国际赛小美赛 A题 飓风与全球变暖 原题再现： 飓风（也包括在西北太平洋被称为“台风”的风暴以及在印度洋和西南太平洋被称为“严重热带气旋”）具有极大的破坏性，往往造成数百人甚至数千人死亡。
许多气象学家一致认为，在过去的几十年里，全球变暖（大约半摄氏度）已经发生在地球表面，而且这种趋势可能会继续下去。问题是，全球变暖对飓风活动意味着什么？请构造一个合理的模型，测量全球变暖的程度和全球飓风活动的强度，并估计两者之间的关系。
整体求解过程概述(摘要) 全球变暖被认为是影响飓风强度的重要因素之一。全球变暖对飓风影响的研究已经展开，但尚未得出确切的结论。
本文通过建立模型来衡量全球变暖的程度和飓风的强度，并得出它们之间的关系。
在模型1中，建立了反映全球变暖程度的评价指标体系。采用熵权法计算各变量的权重。然后类比动量方程，建立一个综合指标来表征全球变暖的程度。
在模式2中，我们对海温如何影响单个飓风进行了微观分析。建立运动方程，分析速度梯度和温度梯度之间的关系。然后应用回归分析方法，求出海温、强度、速度、加速度、压力、运动方向之间的相关关系。通过聚类分析将模型推广到一般情况。结果表明，海温直接影响飓风的运动路径，改变加速度的方向和值。海温对飓风的压力和速度也有影响。在此基础上，进一步得出温度与飓风频率密度分布关系不大的结论。
在模式3中，分别分析了不同地区的飓风强度特征，计算出全球变暖程度的相关性。结果表明，飓风强度与全球蠕虫的关系因地区而异。尤其在东太平洋地区，飓风强度与全球变暖呈负相关。这可以用厄尔尼诺现象来解释。
在模型4中，我们定义了一个基于总能量耗散的飓风潜在破坏性（PDI）指数来表示飓风的强度，然后进行回归以确定与全球变暖的关系。结果表明，PDI与热带海表温度相关，反映了已有的气候信号，但与飓风频率的关系更为显著。
在模型5中，我们建立了预测模型，并对PDI和GWD的趋势进行了预测，结果表明全球GWD面临急剧增长，而PDI仍将处于波动之中。最后给出了未来PDI和GWD的可能值。
最后，分析了本文提出的方法的优缺点。该研究在现实世界中也具有一定的应用价值。
模型假设： （1） 数据来源真实可靠
（2） 全球变暖的程度主要体现在海平面、冰山数量和高度、海表温度、全球温度等方面。
（3） 全球变暖的程度主要受人口、温室气体排放、森林覆盖率等因素的影响。
（4） 飓风强度的大小主要受强度等级、飓风频次、各等级飓风频次的影响。
问题分析： 现将问题分为以下具体分析，根据要求可分为两个子部分：
建立模型，了解全球变暖对飓风活动的影响。
构建一个合理的模型，测量全球变暖的程度和全球飓风活动的强度，并估计两者之间的关系。
解决问题可分为3个步骤：
分别分析了飓风的运动特征，得出了温度变化对飓风的影响。
分析全球变暖与不同地区飓风强度的关系。比较得出结论。
分析全球变暖对全球飓风强度的影响。
为了解决每个环节的问题，我们建立了综合评价指标体系，定义了三个体系的层次：
全球变暖影响全球变暖的因素，这些因素表达了飓风强度的程度。每个索引包含不同的对应变量。通过分析各指标之间的关系，可以得出全球变暖对飓风强度的影响。
模型的建立与求解整体论文缩略图 全部论文请见下方“ 只会建模 QQ名片” 点击QQ名片即可 部分程序代码：(代码和文档not free) D=[]; D0=DC; D1=D0(1:,6); D2=D0(1:,7); D3=D0(1:,8); D4=D0(1:,9); e1=mean(D1); e2=mean(D2); e3=mean(D3); e4=mean(D4); d1=std(D1); d2=std(D2); d3=std(D3); d4=std(D4); for i=1:6349 if abs(D1(i) -e1)&gt;3*d1 D0(i,:)= -1; end if abs(D2(i) -e2)&gt;3*d1 D0(i,:)= -1; end if abs(D3(i) -e3)&gt;3*d1 D0(i,:)= -1; end if abs(D4(i) -e4)&gt;3*d1 D0(i,:)= -1; end end for i=1:6349 if D0(i,1)~= - 1 D=[D;D0(i,:)]; end end clc,clear gmr=xlsread('data' ,'V2:X30'); ppl=gmr(:,1); carb=gmr(:,2); forest=gmr(:,3); sst=xlsread('data' ,'I2:I30'); ssh=xlsread('data' ,'Q2:Q30'); ice=xlsread('data' ,'N2:N30') ; sst_entropy=xlsread('data' ,'J2:J30'); gmf=[sst ssh ice sst_entropy]; temp=xlsread('data' ,'B2:B30'); gmr_min=min(gmr); gmr_max=max(gmr); gmf_min=min(gmf); gmf_max=max(gmf); for i=1:length(gmr); for j=1:3 if j==3 gmr_nor(i,j)=(gmr_max(j)-gmr(i,j))/(gmr_max(j)-gmr_min(j)); else gmr_nor(i,j)=(gmr(i,j)-gmr_min(j))/(gmr_max(j)-gmr_min(j)); end end end for i=1:length(gmf) for j=1:4 if j==3 gmf_nor(i,j)=(gmf_max(j)-gmf(i,j))/(gmf_max(j)-gmf_min(j)); else gmf_nor(i,j)=(gmf(i,j)-gmf_min(j))/(gmf_max(j)-gmf_min(j)); end end end EWr=EntropyWeight(gmr_nor); EWf=EntropyWeight(gmf_nor); alpha=gmr_nor*EWr'; beta=gmf_nor*EWf'; GWD=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0aa495e05a97961de0dbebdae38e6fd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1559cbf03a9a895b981300df85df6ace/" rel="bookmark">
			【.NET Core】反射（Reflection）详解（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【.NET Core】反射（Reflection）详解（一） 文章目录 【.NET Core】反射（Reflection）详解（一）一、什么是反射二、Assembly类2.1 LoadFile2.2 Load2.3 LoadFrom(String)2.4 GetName()2.5 GetModules()2.6 GetModule(String)2.7 GetTypes()2.8 GetType(String,Boolean,Boolean) 三、Module 类3.1 FilterTypeName3.2 FilterTypeNameIgnoreCase3.3 Assembly3.4 FullyQualifiedName3.5 ModuleVersionId3.6 Name3.6 ScopeName3.7 Equals(Object)3.7 FindTypes(TypeFilter,Object)3.8 GetCustomAttributes方法3.9 GetField方法3.10 GetFields()方法3.11 GetMethods()方法3.12 GetMethod()方法3.13 GetType()方法3.14 GetCustomAttribute方法 四、总结五、参考 一、什么是反射 Reflection（反射）是动态获取运行时类型信息的一种方式。.NET的应用程序由几个部分组成：程序集（Assembly）、模块（Module）、类型（Class）组成，而反射提供了一种编程方式。能让程序员可以在程序运行期获得这几个组成部分的相关信息。
二、Assembly类 Assembly表示一个程序集，它是一个可重用、无版本冲突且可自我描述的公共语言运行时应用程序构建基块。
Assembly使用类加载程序集，浏览程序集的元数据和构成部分、发现程序集中包含的类型以及创建这些类的实例。
如要获取表示当前加载到应用程序集的Assembly数组。可以使用AppDomain.GetAssemblies方法。
下面介绍Assembly常用的属性和方法:
2.1 LoadFile 加载指定路径上的程序集文件的内容。
Assembly assembly = Assembly.LoadFile("D:\\DLL\\GoyeerClassLoad.dll"); 2.2 Load Assembly.Load(AssemblyName)：在给定程序集的AssemblyName的情况下，加载程序集。Assembly.Load(Byte[])：加载带有基本通用对象文件格式（COFF）的映像的程序集，该映像包含已发出的程序集。此程序集将会加载到调用方的应用程序域中。Assembly.Load(Byte[],Byte[])：加载带有基本通用对象文件（COFF）的映射的程序集，此映像包含一个已发出的程序集，并且还可以选择包含程序集的符号。此程序集将会加载到调用方的应用程序域中。Assembly.Load(String)：用指定的名称加载程序集。 Assembly assemblyLoad = Assembly.Load("AwinicClassLoad, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null"); 2.3 LoadFrom(String) 已知程序集的文件名或路径，加载程序集。
Assembly assemblyForm = Assembly.LoadFrom("D:\\DLL\\AwinicClassLoad.dll"); 2.4 GetName() 此方法获取此程序集的AssemblyName。
AssemblyName assemblyName= assembly.GetName(); 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1559cbf03a9a895b981300df85df6ace/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f3d39dc7d400c134d5bdd09db10af8f/" rel="bookmark">
			一个字符串数组，请你将字母异位词组合在一起。可以按任意顺序返回结果列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 一个字符串数组，请你将字母异位词组合在一起。可以按任意顺序返回结果列表。
字母异位词 是由重新排列源单词的所有字母得到的一个新单词。
输入: strs = [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]
输出: [[“bat”],[“nat”,“tan”],[“ate”,“eat”,“tea”]]
解法1: 思路:
遍历所有字符串，每个字符串进行排序然后作为key放在map中，这样排序后一样的字符串都会落下一个集合中。
public List&lt;List&gt; groupAnagrams(String[] strs) {
if(strs==null||strs.length==0){ return null; } List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); HashMap&lt;String,List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for(String str : strs){ //获取字符序列 char[] chars = str.toCharArray(); //排序 Arrays.sort(chars); //排序后的字符串 String sortStr = new String(chars); //以排序后的字符串为key,获取可以排序后获得当前字符串的集合 List&lt;String&gt; existsList = map.getOrDefault(sortStr, new ArrayList&lt;&gt;()); existsList.add(str); map.put(sortStr,existsList); } result.addAll(map.values()); return result; } 解法2: 思路:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f3d39dc7d400c134d5bdd09db10af8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be2bd3e2af7df4ce66b7a6fb4b0334b8/" rel="bookmark">
			go语言指针变量定义及说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		go语言指针主要需要记住两个特殊符号，
一个是 &amp; 用来获取变量对应的内存地址
另一个是 * 用来获取指针对应的变量值
下面是个最简单的go语言指针说明
package main import "fmt" //指针为内存地址 func main() { var a string = "指针对应的变量" fmt.Println(&amp;a) // *stirng 定义指针变量 var p *string = &amp;a fmt.Println(p) fmt.Println("p的内存地址为", &amp;p) fmt.Printf("p对应的变量为 %v", *p) } 执行结果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ae114e27899717da3d8806c787a5649/" rel="bookmark">
			刘二大人《PyTorch深度学习实践》p5用pytorch实现线性回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刘二大人《PyTorch深度学习实践》p5用pytorch实现线性回归 一、零碎知识点1.torch.nn2.nn.Module3.nn.linear4.nn.MSELoss5.torch.optim.SGD 二、课程代码1.思路流程2.代码 三、课后小练习 一、零碎知识点 1.torch.nn torch.nn 是 PyTorch 中用于构建神经网络模型的模块。它是 PyTorch 的神经网络库，提供了一系列的类和函数，用于定义、组合和训练神经网络。
我的一些拙见：pytorch作为一个深度学习框架，给我们提供了一个torch工具库，里面包含nn（神经网络）、Tensor（张量）、optim（优化器）等一些列工具包，每个包里面又有不同的工具库，比如nn里面有Module、linear、MSELoss等不同功能的类。
当我们想使用linear“这个工具”时，就可以调用torch.nn.linear()
我们为了方便代码的书写（偷懒），可以简化为：
import torch.nn as nn 2.nn.Module torch.nn.Module 是 PyTorch 中用于定义神经网络模型的基类。
3.nn.linear torch.nn.Linear 是 PyTorch 中的一个线性层类，用于定义全连接层。
基本语法是：linear = nn.Linear(in_features, out_features)
in_features 和 out_features，分别表示输入特征的大小和输出特征的大小。
举个栗子：假设我们要构建一个简单的线性回归模型来预测房屋价格。
在这个例子中，输入特征是房屋的面积和房间数量，输出特征是房屋的价格。
例如，如果我们有100个样本，每个样本的特征由面积和房间数量组成，其中面积的维度是1（一个特征），房间数量的维度也是1（一个特征），那么输入特征的大小（in_features）可以设置为2。
同理，如果我们想要预测房屋的价格，这个预测可以看作是一个输出特征，价格可以被视为一个特征。因此，对于这个线性回归模型中，输出特征的大小（out_features）可以设置为1。
import torch import torch.nn as nn # 创建一个线性层，输入特征大小为 2，输出特征大小为 1 linear = nn.Linear(2, 1) # 随机生成输入数据 x = torch.randn(100, 2) # 100个样本，每个样本有 2 个特征 # 使用线性层进行前向传播 output = linear(x) print(output.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ae114e27899717da3d8806c787a5649/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b8e75555b9ed0345f0a7333f49509e3/" rel="bookmark">
			《剑指offer》Java版--10.求斐波那契数列的第n项。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		剑指offer原题:求斐波那契数列的第n项。
写一个函数，输入n，求斐波那契（Fibonacci）数列的第n项。斐波那契数列的定义如下:
F(0) = 0，F(1) = 1。
F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1。
LeetCode原题：https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/description/
class Solution { int f0 = 0, f1 = 1, f2; final static int mod = 1000000007; public int fib(int n) { if(n &lt; 2) return n; while(n - 2 &gt;= 0) { f2 = (f0 + f1) % mod; f0 = f1; f1 = f2; n--; } return f2; } } 时间复杂度O(n)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b8e75555b9ed0345f0a7333f49509e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2620aa0a23c6a652a199566fcbad52cf/" rel="bookmark">
			【异常解决】MySQL数据库：Lock wait timeout exceeded； try restarting transaction问题解析及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL数据库：Lock wait timeout exceeded; try restarting transaction问题解析及解决方案 一、背景描述二、原因分析三、解决方案3.1 方案一 事务信息查询3.2 方案二 如果杀掉线程依然不能解决，可以查找执行线程耗时比较久的任务，kill掉3.3 方案三 innodb_lock_wait_timeout 锁定等待时间改大3.4 方案四 优化SQL语句 一、背景描述 MySQL数据库，版本号为 5.7.37 。其中有一个设备数据消息表，数据量为 130万多条。设备订阅的MQTT消息定时的会添加新的消息到此消息表中。
在维护项目过程中，由于设备更换，导致历史数据无法与新更换的设备对应上，导致历史数据丢失。为了解决这个问题，临时解决方案就是把历史数据关联的字段更换成新安装的设备的值。于是便有了以下操作。
UPDATE device_data_message SET device_id = 45, pillar_id = 10086, collect_id = 64 WHERE monitor_id IN ( SELECT monitor_id FROM (SELECT monitor_id FROM device_data_message WHERE pillar_id = 10010 AND collect_type = 1) a ); 上述SQL语句在本地电脑执行正常（执行时间为29秒）。达到预期效果。但是同样的SQL语句跑到开发环境就不行了，执行了100多秒后，直接报 Lock wait timeout exceeded; try restarting transaction 这样的错误。
二、原因分析 因为使用的数据库为 MySQL，而 device_data_message 表的引擎是 InnoDB 表类型，此时会出现锁等待的情况，在出现锁等待时，会根据参数 innodb_lock_wait_timeout（默认50s）的配置，判断是否需要进行 timeout 的操作，如果等待时间超过了设置的时间就会报错。如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2620aa0a23c6a652a199566fcbad52cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcdffaaa803e9d8c1d539345fd8abd92/" rel="bookmark">
			Redis高可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主从复制 读写分离，主库和从库都可以进行读操作；主库进行写操作，然后将数据同步给从库。
主从库第一次数据同步（全量复制） 建立连接，协商同步。为全量复制做准备，从库和主库建立起连接，并告诉主库即将进行同步，主库回复确认之后，主从库之间开始数据同步。 从库给主库发送psync命令，表示要进行数据同步，命令中包括主库的runID和复制进度offset两个参数，主库根据命令以及参数启动复制。 runID：每个Redis实例启动时都会自动生成的一个随机ID，用来唯一标识这个实例，第一次复制时，从库不知道主库的runID，所以设为一个?。offset：复制进度，-1表示第一次复制 主库收到psync命令之后，在第一次数据同步的时候会用FULLRESYNC响应带上主库的runID和主库目前的复制进度offset返回给从库，从库收到响应后会记录下这两个参数。 主库同步数据给从库。FULLRESYNC响应表示第一次复制采用的全量复制，主库会把所有的数据同步给从库。 主库执行bgsave命令，生成RDB文件，将文件发送给从库从库接收到RDB文件后，会将所有数据清空（防止从库中存在其他数据与主库不一致），然后再加载接收到的RDB文件 主库发送新的写命令给从库。主库在执行bgsave的时候还可以正常接收请求，这些数据不会记录到生成的RDB文件中，为了保证主从库的一致性，主库中会有一个专门的replication buffer，用来记录RDB文件生成后的所有写操作，当主库完成RDB文件发送后，就将此时的replication buffer中的修改操作发给从库，从库再执行一遍这些操作。 主从级联模式 传统的主从模式中，主库要负责生成RDB文件以及传输RDB文件，这两个操作都是比较耗时的操作，如果从库过多，可能会造成主库的主线程阻塞，所以就有了主-从-从模式。
通过主-从-从模式，可以将主库生成RDB和传输RDB的压力，以级联的方式分散到从库上。也就是有的从库是从主库的从库中获取同步数据。
增量复制 一旦主从库完成了全量复制，两者之间就会一直维护一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，这个过程也称为基于长连接的命令传播，可以避免频繁建立连接的开销
Redis2.8开始，如果主从之间网络断连，主从库之间会采用增量复制的方式继续同步，也就是只需要同步网络断连期间主库收到的命令。
Redis通过环形缓冲区repl_backlog_buffer来实现增量复制的功能
在主服务器进行命令传播的时候，不但将写命令发送给从服务器，同时会将写命令写入到repl_backlog_buffer环形缓冲区，该缓冲区就会保存着主服务器最近传播的写命令。
网络断开后，当从服务器重新连接到主服务器时，会发送psync命令，会带有slave_repl_offset参数，主服务器收到之后会对比slave_repl_offset和master_repl_offset之间的差距
如果判断出数据还在环形缓冲区内，则进行增量复制，即将数据复制到replication buffer中发送给从服务器如果数据不在环形缓冲区内，就进行全量复制 出现阶段
缓冲区满了之后
replication buffer
全量复制和增量复制阶段都会出现，主节点会给每个从节点都分配一个
会导致连接断开，删除缓存，从节点重新连接，重新开始全量复制
repl backlog buffer
增量复制阶段出现，一个主节点只分配一个
环形缓冲区，直接覆盖旧数据
如何判断节点是否存活 Redis通过ping-pong机制来判断节点是否存活，如果有一半的节点ping一个节点的时候没有pong返回，就认为该节点挂了，会断开与这个节点的连接。
对于主节点来说，每隔10秒对从节点发起ping命令，判断从节点的存活性和连接状态，可以通过repl-ping-slave-period控制发送频率。
对于从节点来说，每隔1秒发送replconf ack{offset}命令，给主节点上报自身当前的复制偏移量
实时检测主从节点网络状态上报自身复制偏移量，检查复制数据是否丢失，如果从节点数据丢失，再从主节点的复制缓冲区拉取丢失的数据 过期key 主节点删除了一个key或者通过淘汰算法淘汰了一个key后，主节点会模拟一条del命令发送给从节点，从节点收到命令后就删除该key
主从不一致 尽量保证主从节点间的网络连接状况良好，避免主从节点在不同的机房通过外部程序来监控主从节点之间的复制进度 可以通过Redis的INFO replication命令查看主节点接收写命令的进度以及从节点接收写命令的进度，通过计算两者的差值来监控复制进度如果某个节点的进度差值大于阈值，可以让客户端不再从该节点读取数据 主从切换 主从复制模型在主节点挂了的情况下，从节点无法自动升级为主节点。这个过程需要人工处理，在此期间Redis无法对外提供写操作
主从切换异步复制导致数据丢失 当客户端写入数据到主节点后，主节点还没来得及同步到从节点就发生了断电，那么主节点内存中的数据就会丢失。
Redis有一个min-slaves-max-lag参数，表示一旦所有从节点数据复制和同步的延迟都超过了这个值后，主节点会拒绝任何请求，这样就控制了数据丢失的大小，只会丢失这个参数配置时间内的数据，减少了损失客户端发现Redis写入失败之后，可以采取降级措施，比如写到本地缓存或者写入消息队列 集群脑裂 由于网络问题，集群节点之间失去联系。主从数据不同步，重新平衡选举，产生两个主节点。等网络恢复，旧的主节点会降级为从节点，再与新的主节点进行同步复制，此时由于会进行全量同步，会清空自己的缓冲区，这样前面客户端写入的数据就会丢失。
解决方案：
当主节点发现从节点下线的数量太多或者网络延迟太大的时候，主节点会禁止写入操作，直接把错误返回给客户端
min-slaves-to-write x：主节点至少x个从节点，从节点小于这个数的时候，主节点会禁止写入操作min-slaves-max-lag x：主从复制和同步延迟不能超过x秒，如果超过，主节点会禁止写入操作 哨兵机制 哨兵其实就是一个运行在特殊模式下的Redis进程，主从库实例运行的同时，哨兵也在运行。
哨兵职责 哨兵主要有以下三个任务：
监控选主通知 监控 哨兵进程在运行的时候，会周期性地给所有主从库发送ping命令，检测它们是否仍然在线运行。
如果从库没有在规定时间内响应哨兵的ping命令，哨兵就会把它标记为下线状态如果主库没有在规定时间内响应哨兵的ping命令，哨兵就会判定主库下线，然后开始自动切换主库的流程如果经过换主操作后旧的主节点重新上线，将其会设置为从节点 主观下线 哨兵进程会使用ping命令来检测自身和主从库的连接情况，用来判断实例的状态。
如果哨兵发现主从库对于ping命令的响应超时了，就会将该节点标记为主观下线
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcdffaaa803e9d8c1d539345fd8abd92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc67b4aa30c85ea07aeff7878d33e853/" rel="bookmark">
			深入探索Zookeeper的ZAB协议：分布式系统的核心解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 自我进入软件开发领域以来，我一直对分布式系统充满着浓厚的兴趣。在这个领域中，Zookeeper无疑是一个备受关注的重要组件。作为一名资深的Java工程师，我有幸深入探索过Zookeeper的许多方面，其中最让我着迷的部分莫过于其核心机制之一——Leader选举机制。
在这篇博客中，我打算与大家分享我的经验和理解，尤其是关于Zookeeper的Leader选举机制。为什么要重点关注这一机制呢？原因很简单：在任何分布式系统中，数据的一致性和高可用性是至关重要的。而在Zookeeper这样的系统中，Leader选举机制扮演着确保这两个关键要素的核心角色。
通过Leader选举，Zookeeper能够高效地管理其集群状态，保证即使在面对节点故障时也能快速恢复正常服务。这一机制不仅是Zookeeper高效运作的基石，也是维护分布式系统稳定性的关键。在我的职业生涯中，我见证了它在实际应用中的强大能力，从处理复杂的服务协调到在多节点环境中维持数据一致性，Zookeeper的Leader选举机制展现了其不可或缺的价值。
在接下来的内容中，我将深入探讨Leader选举机制的工作原理，分析其在Zookeeper整体架构中的作用，以及解析相关的源码实现。我希望通过我的分享，能够帮助你更深入地理解Zookeeper，并激发你对分布式系统更广泛探索的兴趣。
Zookeeper基础知识 作为一名对分布式系统充满热情的Java工程师，我深知掌握Zookeeper的基础知识对于理解其更高级特性的重要性。在这一部分，我将分享Zookeeper的一些基本概念和它如何在分布式环境中发挥作用。
Zookeeper是一个开源的分布式协调服务，它主要用于维护配置信息、命名服务、提供分布式同步以及提供组服务。简而言之，Zookeeper为分布式应用提供了一种可靠的协调机制。
集群和节点： Zookeeper的集群由一组服务器（称为节点）组成，这些节点存储数据并在它们之间同步状态。每个节点都存储了整个数据树的一个副本。数据存储在称为“znodes”的层次化命名空间中，这些znodes可以有数据，也可以没有数据，就像文件系统中的文件和目录。
事务日志： Zookeeper的数据一致性依赖于事务日志的概念。每个写操作都会在日志中记录，确保即使在系统崩溃的情况下，也能从这些日志中恢复数据。
代码示例 - 连接Zookeeper： 连接到Zookeeper集群是任何Zookeeper应用程序的第一步。以下是一个简单的Java代码示例，演示如何连接到Zookeeper服务器：
import org.apache.zookeeper.ZooKeeper; public class ZookeeperConnection { private ZooKeeper zoo; public ZooKeeper connect(String host) throws Exception { zoo = new ZooKeeper(host, 5000, watchedEvent -&gt; { if (watchedEvent.getState() == Watcher.Event.KeeperState.SyncConnected) { System.out.println("Successfully connected to Zookeeper"); } }); return zoo; } public void close() throws Exception { zoo.close(); } public static void main(String[] args) throws Exception { ZookeeperConnection connector = new ZookeeperConnection(); ZooKeeper zk = connector.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc67b4aa30c85ea07aeff7878d33e853/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e95c8346b420cf2af6e692cd13284575/" rel="bookmark">
			【Linux】进程等待和替换——进程等待的原理、wait/waitpid方法、进程程序替换、进程替换原理、替换函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 进程等待和进程替换1.进程等待1.1进程等待的概念1.2进程等待的方法1.3wait方法1.4waitpid方法 1.3获取子进程status1.4进程的阻塞和非阻塞等待 2.进程程序替换2.1进程替换的概念2.2进程替换的方法 进程等待和进程替换 1.进程等待 1.1进程等待的概念 进程等待指的是父进程等待子进程退出，以获取子进程的退出返回值，并释放子进程占用的资源。
当子进程先于父进程退出，但父进程没有关注子进程的退出状态时， 子进程会为了保存自己的退出状态而保持资源占用，这种情况被称为“僵尸进程”。为了避免这种情况，父进程可以通过进程等待的方式回收子进程资源。
在Linux中，可以使用wait()函数来实现进程等待。该函数会阻塞父进程，直到有子进程退出。当有子进程退出时，wait()函数会返回子进程的PID，并获取子进程的退出状态。这样，父进程就可以根据子进程的退出状态来决定下一步的操作。
总之，进程等待是Linux中一个重要的概念，它可以帮助父进程回收子进程占用的资源，避免僵尸进程的产生。
1.2进程等待的方法 进程等待的方法主要有两种：
使用wait()函数等待任意一个子进程的退出。
使用waitpid()函数等待指定的子进程的退出。
1.3wait方法 #include&lt;sys/types.h&gt; #include&lt;sys/wait.h&gt; pid_t wait(int*status); 返回值：成功返回被等待进程pid，失败返回-1。
参数：输出型参数，获取子进程退出状态,不关心则可以设置成为NULL
1.4waitpid方法 pid_ t waitpid(pid_t pid, int *status, int options); 返回值：
当正常返回的时候waitpid返回收集到的子进程的进程ID；
如果设置了选项WNOHANG,而调用中waitpid发现没有已退出的子进程可收集,则返回0；
如果调用中出错,则返回-1,这时errno会被设置成相应的值以指示错误所在；
参数：
pid：
Pid=-1,等待任一个子进程。与wait等效。
Pid&gt;0.等待其进程ID与pid相等的子进程。
status:
WIFEXITED(status): 若为正常终止子进程返回的状态，则为真。（查看进程是否是正常退出）
WEXITSTATUS(status): 若WIFEXITED非零，提取子进程退出码。（查看进程的退出码）
options:
WNOHANG: 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回该子进程的ID。
（1）如果子进程已经退出，调用wait/waitpid时，wait/waitpid会立即返回，并且释放资源，获得子进程退出信息。
（2）如果在任意时刻调用wait/waitpid，子进程存在且正常运行，则进程可能阻塞。
（3）如果不存在该子进程，则立即出错返回。
1.3获取子进程status wait和waitpid，都有一个status参数，该参数是一个输出型参数，由操作系统填充。如果传递NULL，表示不关心子进程的退出状态信息。否则，操作系统会根据该参数，将子进程的退出信息反馈给父进程。status不能简单的当作整形来看待，可以当作位图来看待。
1.4进程的阻塞和非阻塞等待 进程的阻塞等待方式
int main() { pid_t pid; pid = fork(); if(pid &lt; 0) { printf("%s fork error\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e95c8346b420cf2af6e692cd13284575/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/252fc682379455fd15710b96e82985b3/" rel="bookmark">
			在TOF PET中，为什么 dw(t-l)fdl dl的积分等于0呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在TOF PET中，为什么 dw(t-l)f/dl dl的积分等于0呢？ 坑
在经过衰减校正后，整体上不会改变数据的统计性质，或者说不会对重建的图像产生净影响。这是因为正的和负的变化会相互抵消。
图像的一阶导数，是否可以理解成噪声？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b13e5a164a50637b8d68c0956c6b354/" rel="bookmark">
			kafka启动报错“输入行太长。 命令语法不正确“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下午想试一下本地安装启动一下 kafak，参考网上的安装文档，结果一直报错，最开始报的是这个错误：
Classpath is empty. Please build the project first e.g. by running gradlew jarAll 参考了很多网上的解决办法，最后发现是下载包的问题，最开始下载解压的是带有 “src” 的包，原来window版本不能使用源码版，改成第一个即可
然后定位到解压目录下，使用命令启动命令
.\bin\windows\kafka-server-start.bat .\config\server.properties 又报了命令一个错：
最开始参考了一下文章：
kafka启动问题报错 命令语法错误 找不到或无法加载主类 Files\Java\jdk1.8.0_144\lib\dt.jar;C:\Program
windows10 kafka 环境搭建 踩坑记录
最开始我还在怀疑 classpath 的配置问题，但是本电脑已经工作量这么多年了，java环境都没出过问题，看了里面说 “文件路径太长”，最开始我是不信，后来我把文件路径去掉 “kafka” 后，绝了，发现真的是
启动成功：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3dfce187ae27bebb570ab146641887b/" rel="bookmark">
			备忘： java 查询es7索引补全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考该文中https://blog.csdn.net/MinggeQingchun/article/details/126762570
查询索引一节，补充，先判断索引是否存在，再查询具体索引细节，并加上异常处理，代码如下：
import org.apache.http.HttpHost; import org.elasticsearch.ElasticsearchException; import org.elasticsearch.client.RequestOptions; import org.elasticsearch.client.RestClient; import org.elasticsearch.client.RestHighLevelClient; import org.elasticsearch.client.indices.GetIndexRequest; import org.elasticsearch.client.indices.GetIndexResponse; import java.io.IOException; public class testES { public static void main(String[] args) throws Exception { RestHighLevelClient esClient = new RestHighLevelClient( RestClient.builder(new HttpHost("localhost", 9200, "http")) ); try { String indexName = "test-2023-12-06"; GetIndexRequest request = new GetIndexRequest(indexName); //boolean exists = esClient.indices().exists(request, RequestOptions.DEFAULT); if (esClient.indices().exists(request, RequestOptions.DEFAULT)) { //查询索引 GetIndexResponse getIndexResponse = esClient.indices().get(request, RequestOptions.DEFAULT); System.out.println(getIndexResponse.getAliases()); System.out.println(getIndexResponse.getMappings()); System.out.println(getIndexResponse.getSettings()); } else { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3dfce187ae27bebb570ab146641887b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78347c5d480a9fcf12973e1c4757fa6b/" rel="bookmark">
			mybatis 根据实体类自动生成resultMap工具类 拿来即用！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为java后端程序员，每日都免不了接触一些重复且繁琐的代码工作，下面是一个平时自用断电根据实体类自动生成resultMap工具类，现把代码贴出来供大家参考使用：
package com.koron.imj.utils; import java.lang.reflect.Field; import java.util.LinkedList; import java.util.List; import java.util.regex.Matcher; import java.util.regex.Pattern; public class ResultMapUtil { private Pattern humpPattern = Pattern.compile("[A-Z]"); List&lt;String&gt; ListObject = new LinkedList&lt;&gt;(); List&lt;String&gt; stringList = new LinkedList&lt;&gt;(); List&lt;String&gt; Lists = new LinkedList&lt;&gt;(); public void getResultMap(Class&lt;?&gt; clazz) throws ClassNotFoundException { try{ getresultMap(clazz,0); }catch (Exception e){ e.printStackTrace(); return ; } } private void getresultMap(Class&lt;?&gt; clazz, int i) throws ClassNotFoundException { getresultMap(clazz,0,null,""); } private void getresultMap (Class&lt;?&gt; clazz,int num,String strd,String fieldName) throws ClassNotFoundException { Field[] fields = clazz.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78347c5d480a9fcf12973e1c4757fa6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0f094ea095d8a8aba64ab73ca583432/" rel="bookmark">
			http、socket、tcp、udp的区别及四层/七层网络协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、OSI模型也称七层网络模型 &amp; TCP/IP 模型也称四层网络模型 二、SOCKET、TCP、UDP和HTTP的关系 1.socket 本身不是一种协议，而是用来操作TCP/UDP协议的接口。
而是对传输层中的 TCP/UDP 协议进行了封装，对用户隐藏了内部 TCP/UDP 是如何传输的，只提供一套接口（API）给程序员调用，从而完成socket编程。
2.通过socket接口，我们才能使用TCP/UDP协议。
3.而我们通常浏览网页用到的 http 协议，是建立在TCP协议之上的一种应用层协议（底层也是socket）。
（http协议最显著的特点是它是一种无状态连接，客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接，是一种“短连接”。）
http 等应用层协议，都是通过 socket 接口从而调用 tcp udp 等传输层协议，从而达到 网络通信。
http
||
socket
||
tcp udp
我们编程不会直接去调用tcp udp，而是通过他们封装好的接口socket去通信。可以说，现在几乎网络上所有的通信，底层都是通过socket完成的，一切皆Socket。
综上所述，我们编程不会直接去调用tcp udp，而是通过他们封装好的接口socket去通信。可以说，现在几乎网络上所有的通信，底层都是通过socket完成的，一切皆Socket。
套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。
Socket连接与HTTP连接 由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。
而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。
很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步：
此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。 http协议是应用层的协议。有个比较形象的描述：
HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。
————————————————
参考自：
socket、tcp、udp、http 的认识及区别_socket udp-CSDN博客
一篇搞懂tcp，http，socket，socket连接池之间的关系 - 知乎 (zhihu.com)
TCP、UDP、HTTP、SOCKET_http、tcp、udp、socket-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb288829f01fe561a1911639f9999530/" rel="bookmark">
			scannet v2 数据集下载（WP）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		scannet数据集：
一共1513个采集场景数据（每个场景中点云数量都不一样，如果要用到端到端可能需要采样，使每一个场景的点都相同），共21个类别的对象，其中，1201个场景用于训练，312个场景用于测试，有四个评测任务：3D语义分割、3D实例分割、2D语义分割和2D实例分割。
本文末尾会放网盘链接。
如果去官网下载，要填一个TOS协议，然后发邮件过去，会得到python脚本。
类似下面这样，脚本放在github里保存。
#coding:utf-8 #!/usr/bin/env python # Downloads ScanNet public data release # Run with ./download-scannet.py (or python download-scannet.py on Windows) # -*- coding: utf-8 -*- import argparse import os import urllib.request #(for python3) # import urllib import tempfile BASE_URL = 'http://kaldir.vc.in.tum.de/scannet/' TOS_URL = BASE_URL + 'ScanNet_TOS.pdf' FILETYPES = ['.sens', '.txt', '_vh_clean.ply', '_vh_clean_2.ply', '_vh_clean.segs.json', '_vh_clean_2.0.010000.segs.json', '.aggregation.json', '_vh_clean.aggregation.json', '_vh_clean_2.labels.ply', '_2d-instance.zip', '_2d-instance-filt.zip', '_2d-label.zip', '_2d-label-filt.zip'] FILETYPES_TEST = ['.sens', '.txt', '_vh_clean.ply', '_vh_clean_2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb288829f01fe561a1911639f9999530/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/37/">«</a>
	<span class="pagination__item pagination__item--current">38/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/39/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>