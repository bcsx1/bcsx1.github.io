<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24be6e17e186317b657cba32317ef041/" rel="bookmark">
			C语言 函数题（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6-11 弹球距离 设有一个球从高度为h米的地方落下，碰到地面后又弹到高度为原来p倍的位置，然后又落下，再弹起，再落下…。请编写函数求初始高度为h的球下落后到基本停下来（高度小于给定阈值TOL）时在空中所经过的路程总和。
函数接口定义： doubledist( double h, double p ); 其中h是球的初始高度，p是球弹起高度与弹起前落下高度的比值；函数dist要返回球下落后到基本停下来时在空中所经过的路程总和。注意：当弹起的高度小于裁判程序定义的常数TOL时，弹起的距离不计算在内。
裁判测试程序样例： #include&lt;stdio.h&gt;#define TOL 1E-3doubledist( double h, double p ); intmain(){ double h, p, d; scanf("%lf %lf", &amp;h, &amp;p); d = dist(h, p); printf("%.6f\n", d); return0; } /* 你的代码将被嵌在这里 */ 输入样例： 1.0 0.4 输出样例： 2.331149 double dist( double h, double p ) { double s=0; while(1) { s=s+h; if(h*p&gt;=TOL) { s=s+h*p; h=h*p; } else break; } return s; } 6-12 输出每个月的天数 本题要求实现一个简单函数，能计算给定的年份和月份的天数。使得可以利用该函数，输出给定年份中每个月的天数。其中1、3、5、7、8、10、12月有31天，4、6、9、11月有30天，2月平年有28天，闰年有29天。判断闰年的条件是：能被 4 整除但不能被 100 整除，或者能被 400 整除。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24be6e17e186317b657cba32317ef041/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd17abb8adea7d55d422ed358a2c0d48/" rel="bookmark">
			C语言 函数题（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6-7 分类统计字符个数 本题要求实现一个函数，统计给定字符串中英文字母、空格或回车、数字字符和其他字符的个数。
函数接口定义： voidStringCount( char s[] ); 其中 char s[] 是用户传入的字符串。函数StringCount须在一行内按照
letter = 英文字母个数, blank = 空格或回车个数, digit = 数字字符个数, other = 其他字符个数 的格式输出。
裁判测试程序样例： #include&lt;stdio.h&gt;#define MAXS 15voidStringCount( char s[] ); voidReadString( char s[] ); /* 由裁判实现，略去不表 */intmain(){ char s[MAXS]; ReadString(s); StringCount(s); return0; } /* Your function will be put here */ 输入样例： aZ &amp; 09 Az 输出样例： letter = 4, blank = 3, digit = 2, other = 1 void StringCount( char s[] ) { int letter=0,blank=0,digit=0,other=0; for(int i=0;i&lt;=s[i];i++) { if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z'||s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z') letter++; else if(s[i]==' '||s[i]=='\n') blank++; else if(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9') digit++; else other++; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd17abb8adea7d55d422ed358a2c0d48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75c85acd909afaaa642497110c845a2b/" rel="bookmark">
			C语言 函数题（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6-1 多项式求值 本题要求实现一个函数，计算阶数为n，系数为a[0] ... a[n]的多项式f(x)=∑i=0n(a[i]×xi) 在x点的值。
函数接口定义： doublef( int n, double a[], double x ); 其中n是多项式的阶数，a[]中存储系数，x是给定点。函数须返回多项式f(x)的值。
裁判测试程序样例： #include&lt;stdio.h&gt;#define MAXN 10doublef( int n, double a[], double x ); intmain(){ int n, i; double a[MAXN], x; scanf("%d %lf", &amp;n, &amp;x); for ( i=0; i&lt;=n; i++ ) scanf("%lf", &amp;a[i]); printf("%.1f\n", f(n, a, x)); return0; } /* 你的代码将被嵌在这里 */ 输入样例： 2 1.1 1 2.5 -38.7 输出样例： -43.1 double f( int n, double a[], double x ) { double sum=0; for(int i=0;i&lt;=n;i++) { sum=sum+a[i]*pow(x,i); } return sum; } 6-2 简单求和 本题要求实现一个函数，求给定的N个整数的和。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75c85acd909afaaa642497110c845a2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f672abc09a6722c7a56ccffcc26627c0/" rel="bookmark">
			MicroPython开发ESP32入门笔记 -- 蓝牙篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、 ESP32 和 Micropython 简介二、蓝牙模组通讯原理简介三、手机端和ESP32蓝牙通讯1. ESP32蓝牙呼吸灯代码2. 手机端准备 总结 前言 博主之前学习了用C语言去开发了51单片机，虽然没有将各种外设和传感器都玩遍，但博主基本将一些重要的外设和传感器通过原理学习加小项目实验的方式比较深入地玩了一下。众所周知，51单片机是相对底层的，用来开发一些大项目的效率会比较低，所以我们很有必要学习一下stm32、esp32的开发。
博主希望下来学习用MicroPython来开发esp32，先从esp32的特色功能蓝牙和WiFi玩起，再接触一下之前没有玩过的传感器和外设：DHT11温湿度传感器、超声波传感器、MG60s舵机、PIR红外传感器等。整个过程中，我们都会通过MQTT、蓝牙、WiFi的形式让esp32和其他设备进行交互。
一、 ESP32 和 Micropython 简介 ESP32是一系列低成本，低功耗的单片机微控制器，集成了Wi-Fi和双模蓝牙。 ESP32系列采用Tensilica Xtensa LX6微处理器，包括双核心和单核版本，内置天线开关，RF射频模块，功率放大器，低噪声接收放大器，滤波器和电源管理模块。ESP32 可作为独立系统运行应用程序或作为主机 MCU 的从设备，通过 SPI / SDIO 或 I2C / UART 接口提供 Wi-Fi 和蓝牙功能。
MicroPython是一种非常小巧的Python解释器，它能运行于微控制器和其他嵌入式系统中。它的设计使得它可以轻易地运行于微处理器上，并且拥有丰富的类库，特别适合开发嵌入式应用程序。MicroPython的核心功能可以在几秒钟内完成，允许开发者快速构建完整的嵌入式系统，而不必编写大量的代码。MicroPython还可以被用于在微控制器上控制传感器和执行其他操作，可以帮助开发者利用微控制器的全部功能。此外，MicroPython还可以被用作与互联网连接的IoT设备的开发平台，以及其他复杂的嵌入式应用程序。博主这里用的MicroPython的IDE是Thonny和Upycraft。
二、蓝牙模组通讯原理简介 蓝牙技术规定每一对设备之间进行蓝牙通讯时，必须一个为主端，另一为从端，才能进行通信，通信时，必须由主端进行查找，发起配对，建链成功后，双方即可收发数据。
蓝牙主端设备发起呼叫，首先是查找周围可被查找的蓝牙设备。主端设备找到从端蓝牙设备后，与从端蓝牙设备进行配对时输入从端设备的PIN 码，也有设备不需要输入PIN码。配对完成后，从端蓝牙设备会记录主端设备的信任信息，此时主端即可向从端设备发起呼叫，已配对的设备在下次呼叫不需要重新配对。已配对的设备，做为从端的蓝牙耳机也可以发起建链请求，但做数据通讯的蓝牙模块一般不发起呼叫。 链路建立成功后，主从两端之间即可进行双向的数据通讯。在通信状态下，主端和从端设备都可以发起断链，断开蓝牙链路。
蓝牙设备在出厂前即提前设好两个蓝牙设备之间的配对信息，主端预存有从端设备的PIN 码、 地址等，两端设备加电即自动建链，透明串口传输，无需外围电路干预。一对一应用中从端设备可以设为两种类型，一是静默状态，即只能与指定的主端通信，不被别的蓝牙模组查找；二是开发状态，既可被指定主端查找，也可以被别的蓝牙设备查找建链。蓝牙通讯和I2C通讯有相似之处，都存在主机和从机，主机和从机的应答都遵照一定的标准，都有唯一的地址来进行寻找配对。
蓝牙技术利用短距离、低成本的无线连接替代了电缆连接，从而为现存的数据网络和小型的外围设备接口提供了统一的连接。
三、手机端和ESP32蓝牙通讯 1. ESP32蓝牙呼吸灯代码 首先要定义一个蓝牙的类，蓝牙的类包括初始化函数，连接函数，连接状态判断函数，地址注册函数，发送数据函数，广播函数，然后实例化为ble，先调用状态判断函数接收其他终端返回的数据，然后按UTF-8解码，如果消息是开灯就以打开呼吸灯，如果消息是关灯就以关闭呼吸灯
from machine import Pin, PWM from machine import Timer from time import sleep_ms import bluetooth BLE_MSG = "" class ESP32_BLE(): def __init__(self, name): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f672abc09a6722c7a56ccffcc26627c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12605b03788508196d4c98157da71c32/" rel="bookmark">
			DevEco Studio 端云协同开发之云函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 端云一体化 之前本人在OpenHarmony/HarmonyOS应用程序中集成了AppGallery Connect中的认证服务做应用程序的登录入口，而HarmonyOS 3.1 Beta1更进一步提升了开发体验，依托AppGakkery Connect的Serverless云服务开放接口，通过DevEco Studio的云开发能力，开发者可以在创建工程时通过选择云开发模板，即可体验端云一体化协同开发，关于端云一体化详细介绍可参见端云一体化开发，这里关于概念性的不在赘述。
1.1 创建端云一体化示例应用 使用DevEco Studio创建端云一体化示例应用程序HelloCloud，选择模板为Empty Ability with CloudDev。
端云一体化需要关联云开发资源，需要在DevEco Studio中使用已实名认证的华为开发者账号登录。
登录完成后在Team下拉框中选择开发团队，若提示以下错误信息，则说明未在AppGallery Connect中创建对应的应用，因此需要先去AppGallery Connect中创建对应的应用。点击错误信息中的AppGallery Connect链接跳转到创建应用界面。
首先添加一个项目，然后添加一个应用，配置如下：
在AppGallery Connect中创建应用完成后，回到DevEco Studio创建工程向导，工程向导会自动查询该组织下，包名下的云端相匹配的应用信息。
HelloCloud工程创建完成后，在主界面Project页签中会显示详细工程目录，包括端开发工程(Application)、云开发工程(CloudProgram)、端侧公共库(External Libraries)。
端开发工程主要用于开发应用端侧业务代码；
云开发工程主要用于为端侧应用用到的云函数、云数据库等。 clouddb：云数据库工程目录
cloudfunctions：云函数工程目录
创建端云一体化应用程序并关联云开发资源后，DevEco Studio会自动初始化配置并开启云开发相关服务，如认证服务、云函数、云数据库、云托管、API网关。服务开通状态可在Event Log窗口查看，也可以在AppGallery Connect控制台查看。
相较于我之前发布的集成AppGallery Connect认证服务实现登录而言，端云一体化开发更加便捷，创建应用完成后会端侧应用自动集成agconnect-services.json配置文件以及相关云服务最新版本HarmonyOS SDK，云端自动集成云数据库SDK。
1.2 端云一体化开发体验 使用端云一体化开发，可以让团队协同开发更简单，同时可以更大程度节省企业开发成本。接下来以云函数为例，更多请参见官网。
1.2.1 创建云函数 打开云端工程，在cloudfunctions目录右键选择New --&gt; Cloud Function，输入云函数名称，自动生成ts文件。
云函数创建完成后需要在function-config.json函数配置文件中配置触发器(会自动完成HTTP触发器配置)，当前可配置HTTP、CLOUDDB、AUTH、CLOUDSTORAGE、CRON五种触发器，每种触发器配置规则不同。HTTP触发器属性如下所示：
参数说明type触发器类型，配置为"http"enableUriDecode触发器是否启用decode。
true：启用；
false：不启用。authFlag是否鉴权，默认为true。authAlgor鉴权算法，默认为HDA-System。authTypeHTTP触发器的认证类型。
apigw-client：API客户端鉴权(Client)端适用。
cloudgw-client：API客户端鉴权(Server端适用)。 在函数入口文件addition-test.ts中完善函数业务逻辑。
// myHandler为入口方法名称 // event 调用方法传递的事件对象，JSON格式 // context 函数运行时上下文对象，封装了日志接口、回调接口、环境变量env对象等 // callback 事件处理结果 // logger 记录日志 let myHandler = async function (event, context, callback, logger) { // do something here let res = new context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12605b03788508196d4c98157da71c32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f872cd498322d7f352e90a7c4bda5be/" rel="bookmark">
			Oracle：基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle数据库 1、Oracle Database，又名Oracle RDBMS，或简称Oracle
2、是目前世界上流行的关系型数据库管理系统，是目前最流行的C/S或B/S体系结构的数据库之一，它具有系统可移植性好、使用方便、功能强，适用于各类大、中、小、微机环境。它是一种高效率、可靠性好的 适应高吞吐量的数据库解决方案
3、oracle目前是世界上使用最为广泛的数据库管理系统，作为一个通用的数据库系统，它具有完整的数据管理功能；作为一个关系型数据库，它是一个完备关系的产品；作为分布式数据库它实现了分布式处理功能
oracle的一些基本概念 数据库：database 1、oracle数据库是数据的物理存储。包括数据文件ORA或者DBF，控制文件，联机文件，日志文件，参数文件
2、oracle数据库的概念和其他数据库概念有些不一样，比如mysql
⑴mysql数据库创建数据库的过程是：创建库--&gt;创建表
⑵oracle创建数据库的过程是：创建一个表空间--&gt;创建一个用户--&gt;由用户去创建表
3、所以oracle数据库和其他数据库是有不同之处的。可以这样理解，oracle是只有一个数据库，是一个大的数据库，由用户来管理的
实例 1、一个oracle的实例由一系列的后台进程和内存结构组成。一个数据库可以有多个实例(一般情况下只会用到一个实例)
2、实例是访问Oracle数据库所需的一部分计算机内存和辅助处理后台进程，是由进程和这些进程所使用的内存(SGA)所构成一个集合，其实就是用来访问和使用数据库的一个进程，只存在于内存中，就像Java中new出来的实例对象一样
注：Orcal数据库正常工作时只会用到下面两个进程，由于Oracle数据库比较大，因此如果是自己学习用的话，可以把这两个进程设置为手动启动(不开机自动启动)，那样有利于电脑的性能。需要用到Oracle时把这两个进程打开就好了。下面第二个进程(有ORCL的就是Oracle数据库的实例进程)
例1：
数据文件：dbf 1、数据文件是数据库的物理存储单位
2、oracle的数据库的数据存储在表空间中，而真正是存储在一个或多个数据文件中。而一个表空间可以由一个或者多个数据文件组成，而一个数据文件只能属于一个表空间
3、一旦数据文件被放入一个表空间过后，就不能删除这个数据文件。如果要删除某个数据文件，则必须删除其所属的表空间
表空间 1、表空间是oracle对物理数据库上相关数据文件的逻辑映射(表空间是一个逻辑概念)
2、Oracle是通过表空间来存储物理表的
⑴一个数据库实例可以有N个表空间
⑵每个数据库至少有一个表空间（system表空间）
⑶一个表空间只能属于一个数据库
⑷一个表空间下可以有N张表。有了数据库，就可以创建表空间
⑸每个表空间由一个或者多个文件组成，这些文件就是数据文件
⑹一个数据文件只能属于一个表空间 4、空间分为：永久表空间、临时表空间、UNDO表空间（存放被修改之前的数据）
⑴永久表空间：存放数据库永久的数据（表，视图等）
⑵临时表空间：存放数据库操作中中间执行的过程，执行结束后释放掉
⑶undo表空间：存储数据被修改前的数据
用户 1、用户是在实例下建立的。不同实例中可以建相同名字的用户
2、表的数据，是由用户放入某一个表空间的，而这个表空间会随机把这些表数据放到一个或多个数据文件DBF中
3、oracle是由用户和表空间对数据进行管理和存储的。但是表数据不是由表空间去查询的，而是由用户去查询的。因为不同用户可以在同一个表空间建立相同名字的表
4、Oracle中，一个数据库拥有多个实例，一个实例可以拥有多个用户，而一个用户可以拥有多个表空间（注意表空间多个用户可以交叉使用，但是前提是要有权限！）
注：
安装完Oracle后，它会自动的生成一些实例、用户和表空间，并在对应的表空间中生成一些自带的表(自动关联用户与表空间)。这些默认的表我们一般是用不到的，因此一般下我们需要自己创建用户、表空间、表来存放我们的数据，不然我们自己的数据(表)与自带的表放一起的话，就不怎么方便了
总结 注：
1、oracle只有一个数据库，是一个大的数据库
⑴一个数据库下面有一个或多个实例(通常我们只用一个实例)
2、一个实例下面可以有一个或多个用户；一个实例下面可以有一个或多个表空间
3、表空间是有一个或多个数据文件组成
⑴数据文件格式为dbf或ora
4、我们在存储数据时我们是通过用户(USER)来存储的，存储在数据文件中
⑴数据是存到数据文件中的，但是我们又不能直接操作数据文件，因此是通过用户操作表空间来进行数据的增删改查的
5、用户与表空间的对应关系：用户和表空间都可以存在多个，那我们在进行数据的增删改查时，是怎么来确定该用户操作的表空间是正确的呢
⑴每一个用户都有一个默认的表空间：在安装好Oracle数据库后，会提供一些默认的用户和表空间，并且这些用户和表空间之间的关系是已经一一帮你对应好了的
⑵一个用户可以拥有一个或多个表空间
①一个用户下有多个表空间：如上图中用户1(蓝色线)。即用户1可以操作表空间1或表空间2
②一个用户下只有一个表空间：如上图中用户1和用户N(橙色和黄色线)。用户1和用户2操作的是两个表空间，它们互不干扰(平常用到最多的就是这种)
③用户和表空间的关系：一个用户有一个默认的表空间，一个表空间可以为多个用户作为默认表空间，用户和用户之间的数据是隔离，数据不会混
Oracle和MySql的区别 mysql模型
注：
1、MySql中最上层的是用户：比如安装完后会提供一个root用户
2、一个用户下有一个或多个数据库
mysql数据源 driver:com.mysql.jdbc.Driver url:jdbc:mysql://localhost:3306:[databaseName] username:root password:root 注：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f872cd498322d7f352e90a7c4bda5be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f4b08190cf6a79995684108a24e49db/" rel="bookmark">
			我嘞个神——原来创建应用根本不需要会编码(看我10分钟应用上线)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、官网功能查询与环境初始化
YonBuilder应用开发
三、测试过程
3.1、创建应用
3.2、数据建模
3.3、页面建模
3.4、页面发布
四、时间累计
五、效率评价
六、总结
一、前言 这里我用到了用友的平台，很多学生们刚毕业都在从事运维和实施的岗位，而且这个平台在我这面也是非常流行的，每年毕业季都会在我们学校这招聘走很多学生，因为很多学生都会使用到这个平台的功能，所以我就进行了尝试，毕竟看着是【低代码】应用开发，按照程序员的思路就是【按照逻辑点吧点吧】就能出应用，非常快捷高效，方便以后做一些临时小应用的时候方便，没想到测试完成后发现，哦，我的天，是真的快，前后就几分钟而且操作过程全中文化，这对于大一刚来的英语不太硬的小朋友们也都是很友好，以后有这个东西在应用起来那是非常方便了呢。
二、官网功能查询与环境初始化 主页地址：用友开发者中心
注册过程我就略过了啊，非常简单，用手机和邮箱都能注册，我们的主要目标是测试低代码方便程度。
YonBuilder应用开发 产品首页中的产品里面我们在第一个位置上就看到了一个叫做【YonBuilder】的低代码应用开发构建，这里写的词还有一个无代码，我就好奇了，所以我们来试试
点开看看效果，看到是个锚点链接，能看到通过组建模型就能构建Web、移动应用以及小程序，好家伙，真是齐全呢啊。那咱们得试试啊， 到了主页面的时候看到需要实名认证，这里直接认证就可以了，不过消耗的时间比较长，得吃一顿饭。
用友开发者中心实名认证前的效果：
用友开发者中心实名认证后的效果：
这里我们可以直接开启体验环境。
过程初始化，这个需要等待一下，毕竟给咱们免费常见一个空间还是需要部署环境的。 ​​​​​​​
终于创建完毕了，这个时候你的手机也会收到一条开通成功的短信。还有温馨提示，有工作人员的联系方式，超级贴心。
三、测试过程 大致流程我是测试过了的，故而我先把整个过程说一下，方便我们理解如何快速构建一个【YonBuilder应用】
创建应用:分析需求,新建应用 数据建模:创建实体元数据 页面建模:根据实体元数据创建页面 应用发布:发布应用至工作台、移动端等 我大致就按照这四个步骤来的，过程我留了截图，我们来看看一个新手是如何快速根据提示上手的。
3.1、创建应用 我们在首页左侧菜单中很明显的能看到【应用构建】四个大字，直接点就行。
这里需要创建【新应用】，直接给与应用名称，领域，默认引擎就行，图标随便选。
看看，我们刚创建好的【未发布】应用，现在是长这样的，我们点击第二项进行编辑。
3.2、数据建模 进入到编辑中其实我们从上面的五个过程就能看到如何操作了，但是这里显示的默认页面是第二页，应该是第一页把，所以就点到了对象建模。
建模页面中直接一个大按钮就放在中间，点击【新增业务对象】。
创建一个首页，毕竟是测试，我们起名也就加上了一个test，编码就一页面所以我就写了个page1
点击确定后我们看到已经有了【mytest_1】的这个业务对象，我们在这个对象中添加一个实体，也就是我们要发布的表信息的列设置。
有一些提示，都是中文的，故而我们直接按照要求填写就行，这里需要一点点编码知识，就是文件类型，其实这个类型与Excel是一样一样的，所以都很好理解，我就写了三列信息，最后我们发布的时候会看到。
创建完成实体我们就能看到了，因为我们点的是保存并发布，故而状态上写着【已发布】代表我们可以直接使用。我就不复杂化的创建表单了啊。
3.3、页面建模 我们有了对象的实体，接下来我们进入到第三步【页面建模】
建模这里我们需要选择页面，不过我们就创建了一个实体，所以就选择列表吧，从示例页面中我们能看到可以同时生成PC与移动两个端的页面呢，点上后点击下一步。 新建页面的最后一个步骤，需要输入页面的名称以及元数据，这个元可以理解成源，也就是我们创建的实体表。我们用普通发布就可以了，最后点击完成。
我们可以看到我们的业务对象建模成功。
3.4、页面发布 话说到了页面发布，看是中间有两个内容呢，我点开了流程&amp;自动化，这里也就是工作流，能根据具体的业务流程进行绘制，如果业务逻辑比较大的话就非常方便了呢。
这里我们创建完成后点击【进入设计】
可以看到这个活动流程图，双击点开后我们在角色里面添加上【全员】，我们收集信息列表，故而是勾选全员。
完成了也就能保存并发布了。
可以看到发布的提示信息，那么我们返回到页面看看是否在流程状态中看到开启状态。
状态没有问题，已经是【启用】状态了。
到了最后一个步骤，发布管理，我们在左右分组列表中能看到一个【+】号。
点击后能看到能添加我们刚刚创建的两个服务，PC和移动端的都有。
以为添加完成后就可以了呢，这里还需要点击【发布】，确认名称，选择一下工作台就能点确定了。
有了两个待操作的服务了，我们直接上页面发布。
点击页面发布后这里让选择发布的网页，我用PC测试的，所以直接选择的是PC的页面。
复制路径后访问，看到了最终的效果。
移动端生成链接
移动端访问效果，我们F12改一下就能看到移动端访问样式，非常nice的。
四、时间累计 身份认证的时候吃了一顿中午饭，认证完成之后的操作一个代码没写过，就敲了几个列名算是多的，其它的操作都是点点点，那么我们来具体算算时间消耗。
环境初始化：【3分钟】
测 试 流 程：【7分钟】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f4b08190cf6a79995684108a24e49db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa68c3cb6df75296d57c8f7e03fff273/" rel="bookmark">
			招4000人！美团2023年春季校园招聘启动！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b9ea9b1a6b265b6ddd7ae85fa0d09a8/" rel="bookmark">
			C&#43;&#43;多线程的同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引用：windows程序员面试指南
多个线程在并发执行的时候，他们在CPU中是随机切换执行的，这个时候我们想多个线程一起来完成一件任务，这个时候我们就需要线程之间的通信
1.全局变量 使用volatile修饰，防止被寄存器优化
2.临界区 Critical Section（临界区）
特点：不是内核对象，速度效率最高
缺点：无超时机制，不可以跨进程
方法：InitializeCriticalSection、EnterCriticalSection、LeaveCriticalSection、DeleteCriticalSection
3.互斥 Mutex （互斥内核对象）
优点：跨线程+跨进程
方法：CreateMutex、OpenMutex、WaitForSingleObject、ReleaseMutex
特点：非拥有者执行ReleaseMutex会出错
4.事件 Event（事件内核对象）
优点：跨线程+跨进程
特点：核心对象，有句柄，人工重置+自动重置
方法：CreateEvent， OpenEvent，SetEvent， ResetEvent， PulseEvent
5.信号量 Semaphore
方法：CreateSemaphore、ReleaseSemaphore、WaitForSingleObject
特点：核心对象，没有拥有者，任何线程都可释放、设置最大访问量，支持多个线程同时访问和并发执行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c337c73287dc05fdd4a966b91a99963c/" rel="bookmark">
			DNS协议使用UDP还是TCP?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DNS帧格式 DNS协议运行在UDP/TCP协议之上，使用的端口号是53（绝大部分情况DNS解析是使用UDP 53端口）
有这么两种情况DNS会使用TCP 1.解析器发出一个request后，返回的response中的TC删节标志比特位被置1时，说明报文因为超长而有删节，因为UDP最大长度是512字节。这时解析器发现后，将使用TCP重发request，TCP允许报文超过512字节。
以太网帧在局域网中的MTU是1500byte，但是在非局域网环境，如：internet下的时候，MTU是各个路由器进行一个配置的。所以，通常路由器默认的MTU为576字节。所以，为了适应网络环境，DNS协议在返回的数据报大于512的时候，就转化为了TCP协议。
2.DNS在进行区域传输的时候使用TCP协议，其他时候则使用UDP协议。
区域传输时: 一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息，传输协议是tcp。
域名解析时: 一般返回的内容都不超过512字节，首选的通讯协议是udp。使用udp传输，不用经过TCP三次握手，这样DNS服务器负载更低，响应更快
3.当域名解析的反馈报文的长度超过512字节时，将不能使用udp协议进行解析，此时必须使用tcp。通常传统的UDP报文一般不会大于512字节。
区域传输使用TCP协议的原因大概是：
1） 区域传输的数据量相比单次DNS查询的数据量要大得多
2） 区域传输对数据的可靠性和准确性相比普通的DNS查询要要高得多，因此使用TCP协议。
原文链接：https://blog.csdn.net/ljc1999/article/details/112392801
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4867925d2b8d7744e2db0f79d340325/" rel="bookmark">
			在ubantu系统用手机通过有线或者蓝牙上网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这里写自定义目录标题 在ubantu系统用蓝牙上网在ubantu系统用有线上网 在ubantu系统用蓝牙上网 用手机打开热点
打开通过蓝牙共享网络
手机蓝牙连接电脑&lt;\p&gt; 在ubantu系统中的网络设置，的其他设备打开对应热点开关&lt;\p&gt; 在ubantu系统用有线上网 用手机打开热点
打开通过usb共享网络
手机有线连接电脑&lt;\p&gt; 在ubantu系统中的网络设置，的usb以太网打开对应热点开关&lt;\p&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/092ed6278bfd4455055e67fb4ba33e2d/" rel="bookmark">
			【数据结构】LSM树（log-structed-merge-tree）原理及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 基本概念读写流程写入读取 CompactSize Tiered Compaction StrategyLeveled Compaction Strategy RocksDB 的压缩策略 基本概念 LSM树（log-structed-merge-tree）:
日志结构的：系统日志是不会出错的，只需要在后面追加。所以日志结构就代指追加型结构。
原理：把磁盘看做一个日志，在日志中存放永久性数据及其索引，每次都添加到日志的末尾。文件传输（存取）大多是顺序的，提高磁盘带宽利用率。
LSM-tree是专门为key-value存储系统设计的，主要业务是查找和插入。
LSM的特点是利用磁盘的顺序写，写入速度比随机写入的B-树更快。
LSM 树的思想是使用顺序写代替随机写来提高写性能，与此同时会略微降低读性能。HBase、 Cassandra、 LevelDB、 RocksDB 以及 ClickHouse MergeTree 等流行的 NoSQL 数据库均采用 LSM 存储结构。
LSM树(Log Structured Merged Tree)的名字往往给人一个错误的印象, 实际上LSM树并没有严格的树状结构。
LSM 树的思想是使用顺序写代替随机写来提高写性能，与此同时会略微降低读性能。
LSM 的高速写入能力与读缓存技术带来的高速读能力结合受到了需要处理大规模数据的开发者的青睐，成为了非常流行的存储结构。
HBase、 Cassandra、 LevelDB、 RocksDB 以及 ClickHouse MergeTree 等流行的 NoSQL 数据库均采用 LSM 存储结构。
读写流程 具体来说 LSM 的数据更新是日志式的，修改数据时直接追加一条新记录（为被修改数据创建一个新版本），而使用 B/B+ 树的数据库则需要找到数据在磁盘上的位置并在原地进行修改。
这张经典图片来自 Flink PMC 的 Stefan Richter 在Flink Forward 2018演讲的PPT
写入 在执行写操作时，首先写入 active memtable 和预写日志(Write Ahead Logging, WAL)。因为内存中 memtable 会断电丢失数据，因此需要将记录写入磁盘中的 WAL 保证数据不会丢失。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/092ed6278bfd4455055e67fb4ba33e2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b16657b6c9c962f0bc85ce71421fe3d2/" rel="bookmark">
			C&#43;&#43;类和对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、C++类定义
二、定义C++对象
三、访问数据成员
四、类和对象详解
C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。
类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类中被称为类的成员。
一、C++类定义 定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。
类定义是以关键字 class 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 class 定义 Box 数据类型，如下所示：
class Box
{
public:
double length; // 盒子的长度
double breadth; // 盒子的宽度
double height; // 盒子的高度
};
关键字 public 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的也可以指定类的成员为 private 或 protected。
二、定义C++对象 类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Box 的两个对象：
Box Box1; // 声明 Box1，类型为 Box
Box Box2; // 声明 Box2，类型为 Box
对象 Box1 和 Box2 都有它们各自的数据成员。
三、访问数据成员 类的对象的公共数据成员可以使用直接成员访问运算符 . 来访问。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b16657b6c9c962f0bc85ce71421fe3d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db03e41ceb3d4e16b60f1ae5be94503e/" rel="bookmark">
			【Python 】yyyy-MM-dd HH:mm:ss 时间格式 时间戳 全面解读超详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间格式 时间格式(协议)描述gg时期或纪元。y不包含纪元的年份。不具有前导零。yy不包含纪元的年份。具有前导零。yyyy包含纪元的四位数的年份。M月份数字。一位数的月份没有前导零。MM月份数字。一位数的月份有一个前导零。MMM月份的缩写名称，在AbbreviatedMonthNames中定义。MMMM月份的完整名称，在MonthNames中定义。d月中的某一天。一位数的日期没有前导零。dd月中的某一天。一位数的日期有一个前导零。ddd周中某天的缩写名称，在AbbreviatedDayNames中定义。dddd周中某天的完整名称，在DayNames中定义。h12小时制的小时。一位数的小时数没有前导零。hh12小时制的小时。一位数的小时数有前导零。H24小时制的小时。一位数的小时数没有前导零。HH24小时制的小时。一位数的小时数有前导零。m分钟。一位数的分钟数没有前导零。mm分钟。一位数的分钟数有一个前导零。s秒。一位数的秒数没有前导零。ss秒。一位数的秒数有一个前导零。f秒的小数精度为一位。其余数字被截断。 字符串与时间格式转换 Python 字符串转时间格式：
import datetime str_time = '2022-01-01 12:00:00' time_obj = datetime.datetime.strptime(str_time, '%Y-%m-%d %H:%M:%S') 时间格式转字符串：
time_obj = datetime.datetime.now() str_time = time_obj.strftime('%Y-%m-%d %H:%M:%S') 时间戳 时间戳是一个以秒为单位的数字，表示从 1970 年 1 月 1 日（UTC 时间）开始的时间。
要将时间戳转换为其他时间格式，可以使用各种编程语言中的内置函数或库。
例如，在 Python 中，可以使用 datetime 模块中的 datetime 函数来将时间戳转换为时间字符串。
from datetime import datetimetimestamp = 1609459200 # 转换为本地时间 dt_obj = datetime.fromtimestamp(timestamp) # 转换为指定的格式 time_str = dt_obj.strftime('%Y-%m-%d %H:%M:%S')print(time_str) # Output: "2021-01-01 00:00:00" 注意，时间戳是以 UTC 时间为基准的，如果需要转换为本地时间，需要使用 fromtimestamp 函数，而不是 utcfromtimestamp 函数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3b68ab9d4b6eb9751652597db27b1d2/" rel="bookmark">
			黑马程序员Java教程学习笔记（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 黑马程序员Java学习笔记Java版本Java语言的跨平台原理JRE和JDKJDK的下载和安装HelloWorld案例注释关键字常量数据类型标识符类型转换运算符字符"+"操作字符串"+"操作赋值运算符自增自减运算符关系运算符逻辑运算符三元运算符案例：两只老虎案例：三个和尚数据输入案例：三个和尚升级版if...else语句案例：判断奇偶数if...else...if结构案例：考试奖励switch语句案例：春夏秋冬for循环语句案例：输出数据案例：求和案例：求偶数和案例：水仙花数案例：统计While循环语句案例：珠穆朗玛峰do...while语句跳转控制语句循环嵌套随机数Random案例：猜数字 黑马程序员Java学习笔记 Java版本 Java(5.0)：是更新力度很大的一个版本，直接让Java的发展进入了快车道
Java(8.0)：是公司中生产/开发环境使用的最多的版本
Java(11.0)：是Java学习者使用的最多的版本
Java语言的跨平台原理 在需要运行Java应用程序的操作系统上，安装一个与操作系统相对应的Java虚拟机(JVM Java Virtual Machine)即可。
JRE和JDK JRE(Java Runtime Environment)
是Java程序的运行时环境，包含JVM和运行时所需要的核心类库
只是想要运行一个Java程序，那么只需要安装JRE即可。
JDK(Java Development Kit)
是Java程序开发工具包，包含JRE和开发人员使用的工具。
其中的开发工具：编译工具(javac.exe)和运行工具(java.exe)
JDK、JRE、JVM的关系如下图：
JDK的下载和安装 Java11 for WIndows: https://www.oracle.com/java/technologies/downloads/#java11-windows
JDK的安装目录
目录名称说明bin该路径下存放了JDK的各种工具命令。javac和java就在这个目录conf该路径下存放了JDK的相关配置文件include该路径下存放了一些平台特定的头文件jmods该路径下存放了JDK的各种模块legal该路径下存放了JDK各模块的授权文档lib该路径下存放了JDK工具的一些补充JAR包其他其余文件为说明性文档 HelloWorld案例 HelloWorld.java
public class HelloWorld { public static void main(String[] args) { System.out.println("Hello World"); } } D:\Java\mycode&gt;javac HelloWorld.java D:\Java\mycode&gt;java HelloWorld Hello World D:\Java\mycode&gt; 注释 单行注释格式：	//注释信息 多行注释格式：	/* 注释信息 注释信息 */ 文档注释格式：	/** 注释信息 */ /* Java程序中最基本的组成单位是类。 类的定义格式: public class 类名 { } 这是我定义的HelloWorld类 */ public class HelloWorld { /* 这是main方法 main方法是程序的入口，代码的执行是从main方法开始的 */ public static void main(String[] args) { //这是输出语句，"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3b68ab9d4b6eb9751652597db27b1d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/948ef8edab3b9aff67cdf21de14ef192/" rel="bookmark">
			java中的几种加密方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种 DES加解密 import java.security.Key; import java.security.SecureRandom; import javax.crypto.Cipher; import javax.crypto.KeyGenerator; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import sun.misc.BASE64Decoder; import sun.misc.BASE64Encoder; /** * DES是一种对称加密算法，所谓对称加密算法:加密和解密使用相同的秘钥的算法 * @author llp * */ public class DESUtil { private static final Logger logger = LoggerFactory.getLogger(DESUtil.class); private static Key key; //设置秘钥key private static String KEY_STR="myKey"; private static String CHARSETNAME="UTF-8"; private static String ALGORITHM="DES"; static{ try{ //生成DES算法对象 KeyGenerator generator=KeyGenerator.getInstance(ALGORITHM); //运用SHA1安全策略 SecureRandom secureRandom=SecureRandom.getInstance("SHA1PRNG"); //设置上密钥种子 secureRandom.setSeed(KEY_STR.getBytes()); //初始化基于SHA1的算法对象 generator.init(secureRandom); //生成密钥对象 key=generator.generateKey(); generator=null; }catch(Exception e){ throw new RuntimeException(e); } } /** * 获取加密的信息 * @param str * @return */ public static String getEncryptString(String str){ //基于BASE64编码，接收byte[]并转换成String BASE64Encoder base64Encoder=new BASE64Encoder(); try { // 按UTF8编码 byte[] bytes = str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/948ef8edab3b9aff67cdf21de14ef192/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03acc8185794cf21a06fcf06e7285db6/" rel="bookmark">
			KingabseES 隐式游标属性值(SQL%attribute)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		隐式游标介绍 Oracle数据库迁移到KingbaseES数据库，不需要将源PL/SQL脚本，大规模修改为KES语法，因为KingbaseES支持大部分PLSQL语法。
1、隐式游标 隐式游标是由 PL/SQL 构造和管理的会话游标。
每次运行 SELECT 或 DML 语句时，PL/SQL 都会打开一个隐式游标。您无法控制隐式游标，但可以从其属性中获取信息。
隐式游标属性值的语法是 SQL%attribute，SQL%attribute 总是指向最近运行的 SELECT 或 DML 语句。 如果没有运行这样的语句，则 SQL%attribute 的值为 NULL。隐式游标在其关联语句运行后关闭。但是，在另一个 SELECT 或 DML 语句运行之前，它的属性值仍然可用。最近运行的SELECT或DML语句可能在不同的范围内。要保存属性值以供以后使用，请立即将其分配给局部变量。 否则，其他操作(例如子程序调用)可能会在您测试之前更改属性的值。
2、隐式游标属性值的用途 隐式游标属性是：
- SQL%ISOPEN 属性：游标是否打开？
- SQL%FOUND 属性：是否有任何行受到影响？
- SQL%NOTFOUND 属性：没有行受到影响？
- SQL%ROWCOUNT 属性：有多少行受到影响？
3、简单例子 --SQL%attribute的值，可以获得最新一条DQL和DML语句的运行信息 do language plsql $$ declare i int; begin delete from oo02 where rownum &lt;= 0; DBMS_OUTPUT.PUT('staSQL : '); DBMS_OUTPUT.PUT_LINE(sql % rowcount || ',' || sql % ISOPEN || ',' || sql % found || ',' || sql % notfound); GET DIAGNOSTICS i := row_count; DBMS_OUTPUT.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03acc8185794cf21a06fcf06e7285db6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df085c11e833e75e9e8082af91ed972d/" rel="bookmark">
			yaml文件详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、K8S支持的文件格式
1、yaml和json的区别
2、yaml语言格式
3、yaml支持的数据结构
二、yaml格式的Pod配置文件内容及注解
三、编写nginx-test.yaml资源配置清单
1、编写资源配置清单
2、创建资源对象
3、查看创建的pod资源
四、创建service服务对外提供访问并测试
1、编写nginx-svc-test.yaml
2、创建资源对象
3、查看创建的service
4、访问测试
一、K8S支持的文件格式 kubernetes支持YAML和JSON文件格式管理资源对象
JSON格式：主要用于api接口之间消息的传递YAML格式：用于配置和管理，YAML是一种简洁的非标记性语言，内容格式人性化，较易读 1、yaml和json的区别 YAML 使用空格缩进，这是 Python 开发人员熟悉的领域。JavaScript 开发人员喜欢 JSON，因为它是 JavaScript 的一个子集，可以直接在 JavaScript中解释和编写，同时使用简写方式声明 JSON，在使用没有空格的典型变量名时，不需要键中的双引号。有很多解析器在 YAML 和 JSON 的所有语言中都能很好地工作。在许多情况下，YAML 的空白格式可以更容易查看，因为格式化需要更人性化的方法。如果您的编辑器中没有空格可见或缩进线指示符，那么 YAML 的空白虽然更紧凑，更容易查看，但可能难以手动编辑。JSON 的序列化和反序列化要快得多，因为要检查的功能明显少于 YAML，这使得更小更轻的代码能够处理 JSON。一个常见的误解是 YAML 需要较少的标点符号并且比 JSON更紧凑，但这完全是错误的。空格是不可见的，所以看起来字符较少，但是如果你计算实际的空格是必要的，以便正确解释 YAML以及正确的缩进，你会发现 YAML 实际上需要比 JSON 更多的字符。JSON不使用空格来表示层次结构或分组，并且可以通过删除不必要的空格来轻松展平，以实现更紧凑的传输。 2、yaml语言格式 大小写敏感使用缩进表示层级关系不支持 Tab 键制表符缩进，只使用空格缩进缩进的空格数目不重要，只要相同层级的元素左侧对齐即可，通常开头缩进两个空格符号字符后缩进一个空格，如冒号，逗号，短横杠（-）等— 表示 YAML 格式，一个文件的开始，用于分隔文件# 表示注释 3、yaml支持的数据结构 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）纯量（scalars）：单个的、不可再分的值 二、yaml格式的Pod配置文件内容及注解 # yaml格式的pod定义文件完整内容： apiVersion: v1 #必选，版本号，例如v1 kind: Pod #必选，Pod metadata: #必选，元数据 name: string #必选，Pod名称 namespace: string #必选，Pod所属的命名空间 labels: #自定义标签 - name: string #自定义标签名字 annotations: #自定义注释列表 - name: string spec: #必选，Pod中容器的详细定义 containers: #必选，Pod中容器列表 - name: string #必选，容器名称 image: string #必选，容器的镜像名称 imagePullPolicy: [Always | Never | IfNotPresent] #获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像，否则下载镜像，Nerver表示仅使用本地镜像 command: [string] #容器的启动命令列表，如不指定，使用打包时使用的启动命令 args: [string] #容器的启动命令参数列表 workingDir: string #容器的工作目录 volumeMounts: #挂载到容器内部的存储卷配置 - name: string #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名 mountPath: string #存储卷在容器内mount的绝对路径，应少于512字符 readOnly: boolean #是否为只读模式 ports: #需要暴露的端口库号列表 - name: string #端口号名称 containerPort: int #容器需要监听的端口号 hostPort: int #容器所在主机需要监听的端口号，默认与Container相同 protocol: string #端口协议，支持TCP和UDP，默认TCP env: #容器运行前需设置的环境变量列表 - name: string #环境变量名称 value: string #环境变量的值 resources: #资源限制和请求的设置 limits: #资源限制的设置 cpu: string #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数 memory: string #内存限制，单位可以为Mib/Gib，将用于docker run --memory参数 requests: #资源请求的设置 cpu: string #Cpu请求，容器启动的初始可用数量 memory: string #内存清楚，容器启动的初始可用数量 livenessProbe: #对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可 exec: #对Pod容器内检查方式设置为exec方式 command: [string] #exec方式需要制定的命令或脚本 httpGet: #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port path: string port: number host: string scheme: string HttpHeaders: - name: string value: string tcpSocket: #对Pod内个容器健康检查方式设置为tcpSocket方式 port: number initialDelaySeconds: 0 #容器启动完成后首次探测的时间，单位为秒 timeoutSeconds: 0 #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒 periodSeconds: 0 #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次 successThreshold: 0 failureThreshold: 0 securityContext: privileged:false restartPolicy: [Always | Never | OnFailure]#Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod nodeSelector: obeject #设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定 imagePullSecrets: #Pull镜像时使用的secret名称，以key：secretkey格式指定 - name: string hostNetwork:false #是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络 volumes: #在该pod上定义共享存储卷列表 - name: string #共享存储卷名称 （volumes类型有很多种） emptyDir: {} #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值 hostPath: string #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录 path: string #Pod所在宿主机的目录，将被用于同期中mount的目录 secret: #类型为secret的存储卷，挂载集群与定义的secre对象到容器内部 scretname: string items: - key: string path: string configMap: #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部 name: string items: - key: string path: string 三、编写nginx-test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df085c11e833e75e9e8082af91ed972d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f675d2525cc7d76f6f0379858e60e40/" rel="bookmark">
			Vue3学习笔记：基础语法，指令，表达式，语法糖，动态参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关绑定参数的配置 &lt;style&gt; #d1{ color:red; } #d11{ color:blue; } .d1{ font-size: 50px; } &lt;/style&gt; const Counter={//配置对象 data:function(){ return{ num:0, uname:"张三", msg:"&lt;h2&gt;标题&lt;/h2&gt;", id:"d1", url:"https://img10.360buyimg.com/img/jfs/t1/192028/25/33459/5661/63fc2af2F1f6ae1b6/d0e4fdc2f126cbf5.png", mouseevent:"click", attributename:"id" } }, methods:{ changeuname: function(){ this.uname='李四' }, changeColor: function(){ if(this.id == "d1") {this.id = "d11"} else {this.id = "d1"} } } } let app =Vue.createApp(Counter).mount('#counter')//创建应用，将配置对象传入 console.log(app); //app.num= 数据的双向绑定 能让页面上的num值随之修改 vue语法，p标签里填入的是变量 &lt;p&gt;{{num}}&lt;/p&gt; &lt;p&gt;{{uname}}&lt;/p&gt; &lt;p v-once&gt;{{uname}}&lt;/p&gt; &lt;p&gt;{{msg}}&lt;/p&gt; v-html指令，只对信任内容使用，不可对用户填入的值使用 &lt;p v-html="msg"&gt;&lt;/p&gt; &lt;button @click="changeuname"&gt;change user name&lt;/button&gt; v-bind指令，对属性变量进行赋值使用 &lt;p v-bind:id="id"&gt;绑定id&lt;/p&gt; &lt;img v-bind:src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f675d2525cc7d76f6f0379858e60e40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19e078d704270b30160c554348b5ceb7/" rel="bookmark">
			word 文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何删除Word空白页，这四种方法轻松搞定 - 知乎 (zhihu.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8c6a64160900a137547d173d9404229/" rel="bookmark">
			淘宝TMF 2.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何实现32.5万笔/秒的交易峰值？阿里交易系统TMF2.0技术揭秘
阿里妹导读：基于TMF 2.0关键模型，阿里交易平台实现了业务定义可视、可管、可配。今天我们来一起了解交易平台遇到的挑战、TMF2.0解决的关键问题、以及TMF 2.0的关键模型。
本文作者为毗卢，阿里巴巴资深技术专家，主导设计了TMF2.0框架，并基于该框架完成交易平台架构升级改造，目前负责商品中心，专注电商领域业务建模与工程交付相结合的研究与平台推广。
交易平台遇到的挑战
2017双11，交易峰值达到了32.5万笔/秒，这给整个交易系统带来了非常大的挑战。
一方面，系统需要支撑全集团几十个事业部的所有交易类需求：要考虑如何能更快响应需求、加快发布周期；如何能为新小业务提供快速支撑、降低准入门槛；是否足够开放使得业务方能做到自助式扩展；新需求是否已经在其他事业部有可复用资产等问题。
另一方面，整个电商体系涉及的应用高达7000+：要考虑需求的评估是否具有全链路视角；业务需求的技术评估是否分析全面、技术方案的影响范围是否评估到位；业务的全链路稳定性保障、调用链路监控、强弱依赖等问题。此外面对每天几百个业务需求，500+个独立的发布变更：要考虑各业务方的需求发布是否会相互产生影响；需求代码是否对平台有侵入、导致平台腐化；高频率的需求发布下如何管控质量；能否按业务维度进行业务监控、故障分析等等。
TMF2.0解决的关键问题
面对这些挑战，TMF2.0框架需要解决六大关键问题。
业务可视化：平台能力、业务规则决定是否对外透出；
需求结构化支持：基于透出的业务能力、已有的业务规则完成需求结构化分解降低沟通成本；
业务配置化：这是可视化的前提，要在需求明确的情况下在线配置业务、快速发布上线；
业务测试一体化：根据修改的代码进行自动化用例筛选、自动化测试；
业务监控：以精细化的业务维度进行监控，而不仅仅局限于交易大盘；
故障排查：当业务故障时快速拿到故障快照、还原故障现场以及迅速定位问题原因。
针对以上六大关键问题，TMF2.0的关键设计点有以下三个层面。
首先，需要实现业务/平台分离插件化架构。平台提供插件包***制，实现业务方插件包在运行期的注册。业务代码只允许存在于插件包中，与平台代码严格分离。业务包的代码配置库也与平台的代码库分离，通过二方包的方式，提供给容器加载。
其次，要统一业务身份。平台需要能有按“业务身份”进行业务与业务之间逻辑隔离的能力，而不是传统SPI架构不区分业务身份，简单过滤的方式。如何设计这个业务身份，也成为业务与业务之间隔离架构的关键。
另外，要注重管理域与运行域分离。业务逻辑不能依靠运行期动态计算，要能在静态期进行定义并可视化呈现。业务定义中出现的规则叠加冲突，也在静态器进行冲突决策。在运行期，严格按照静态器定义的业务规则、冲突决策策略执行。
下文将针对这三块的内容分别展开来详细介绍。
业务定制包与平台分离的架构
如何实现32.5万笔/秒的交易峰值？阿里交易系统TMF2.0技术揭秘
如上所示的业务定制包与平台分离架构可以分为四个层次。最底层是交易规范层，包括一些交易模型、交易领域的划分、业务领域的划分、以及交易启动环境下的配置项。基于这个理论模型，就可以进行一些定义及规范工作，比如接口定义、流程规范、模型规范等，而且其中的很多内容都可以在不同的领域进行复用。
上面一层是解决方案层。大家都知道阿里巴巴目前正在走国际化的战略，所以面对不同的市场会构建不同的解决方案，不同的解决方案中也就有自己不同的业务玩法、业务逻辑。所以要将不同的市场解决方案和他们自身的流程、规则结合起来。但是这一过程中会发现，不同的市场解决方案会有很多可以复用的地方，比如营销模式。所以形成的可复用基础实现就可以在不同的解决方案中得到复用，那么在面对不同的市场时就不用考虑可复用基础实现的内容，只需要关注市场相关的业务就可以了。
往上一层是业务定制层。即使是在一个市场内，也会有各种细分的定制玩法，这些不同的细分点就会有各自不同的业务逻辑，这就是制定业务定制层的原因。团队会根据底层的需求点来进行一些业务定制包的组装，就可以实现不同的业务逻辑和玩法了。
在这样一个复杂的分离架构中，最重要的是要将不同层次间的职责划分清晰，整个代码都严格地、有意识地进行分离。所以在最后的部署过程中，首先要完成底层业务的复用，然后形成不同市场的解决方案，再在解决方案下对不同的业务实现差异化。
业务身份定义标准化
上面所讲的是业务和平台的分离，在业务和平台分离之后就要进行业务和业务之间的隔离，即统一的业务身份，类似于身份证号码，在整个交易链路上必须是唯一的。业务身份需要通过人、货、场三个维度进行抽象，比如市场类型、垂直市场、渠道来源等等，确定了这个唯一的业务身份后就可以将业务流程和业务规则进行关联。
基于业务识别，团队也提供了一个基于UIL的业务身份识别方案，总体设计基于标准模型来抽象，自定义语法，统一管理模型。事实上，通过样品模型、买家模型、卖家模型、类目模型这四个维度，99%的商品都可以有效地进行标识。业务身份确定后，就可以按照业务身份维度，对业务配置、部署进行统一管理，在这其中要注意配置隔离性、热部署、配置回滚、配置确定性等核心要素。
业务管理域与运行域分离的框架
如何实现32.5万笔/秒的交易峰值？阿里交易系统TMF2.0技术揭秘
业务身份确定后就要进行业务定义，这其中就涉及管理域和运行域分离的问题。管理域就是指对业务生命周期、业务身份、业务对象进行定义，包括业务流程、业务管理等。这些操作完成之后就会将配置文件下发，运行域上的各种平台就会自动解析配置域所下发的配置文件，然后将配置文件解析成业务命令来执行。
在上面所讲的业务域中，一个核心的问题就是如何定义业务：核心三要素是业务身份、业务叠加关系、冲突决策，即基于业务协议标准定义业务，执行单元按协议执行业务逻辑。
如何实现32.5万笔/秒的交易峰值？阿里交易系统TMF2.0技术揭秘
在业务叠加关系中，业务的复杂度就在于业务规则在不同维度下产生的冲突。业务的复杂度可以分为两个维度，一个是横向维度，一个是垂直维度。
垂直维度，也可称之为“行业”。往往一个特定的“业务对象”（如商品），在静态期就能确认其具体归属于哪个行业。行业与行业之间的业务规则是不会有叠加的。比如，付款超时时间，各可以设置为1天超时。但“天猫汽车”把超时时间改了，一定不会联动改其他业务的超时设置。横向维度，也称为产品维度，特点有：产品是可以被多个垂直业务所使用的、一个垂直业务是可以使用多个产品的、产品是否生效是需要结合业务会话的。比如，“电子凭证”是否生效，要看用户是否选择了“电子凭证”的交付方式。
通过业务复杂度的分析，可以得出一个结论是：一次业务会话完整的规则=1个垂直业务规则集合+ N个水平业务规则集。所以在做业务定义和管理的时候，具体就是在管某一个垂直业务是和哪些横向业务在叠加。在叠加之后产生的业务冲突又是怎么解决的？要基于这一点进行业务管理。这是比较关键的一点。
TMF 2.0的关键模型介绍
基于以上的业务域介绍，下面详细阐述一下TMF 2.0的关键模型，主要包括业务配置主线和业务运行主线。
如何实现32.5万笔/秒的交易峰值？阿里交易系统TMF2.0技术揭秘
在业务配置主线中，由项目的业务PD来看一下当前业务涉及到哪些业务域，以及这些业务域下面有哪些功能和产品可以去使用，哪些业务点是可以去扩展的。这其中就需要能力域模型的支撑，通过这个模型所透出的结构化数据，来研究平台中每个域具备的能力、每个能力具有的可变点，从而有针对性地进行设置。在配置模型里，通过关键的视图模板，进行模板透出，然后保存、下发配置数据到业务运行主线。业务配置主线和业务运行主线是相交互的。
基于TMF 2.0关键模型，整个交易平台实现了业务定义可视、可管、可配。业务定义可视化包括系统能力可视化、业务流程可视化、业务规则可视化、产品叠加可视化等；业务可配置，所见即所得的业务规则可配置能力，凡是基于TMF2标准构建的系统均立刻可获取业务可配置能力，不需做额外的开发；配置版本化，针对业务配置有完善的版本化管理机制，配置推送可实现按版本快速生效或者回退；业务多租户管理，不同的业务系统之间可以通过租户完全隔离的。不同的租户有自己的数据空间，以及配置推送策略。
在实际应用中，基于TMF2.0交易平台改造效果具体如下：
业务需求平均开发周期缩短至12天。比如汽车4S服务中，在老系统上做了一个月（未完成），新系统7天完成；五道口业务中，在老系统中评估工作量两个月，新系统12个工作日完成；饿了么业务中，老系统评估要两周，基于新系统2天完成。
平台与业务解耦。目前已完成的业务，其业务定制均只存在于业务包；在平台未改动情况下，业务方的发布更加灵活（有多次单业务发布，不需要其他业务方进行回归的案例）。
业务资产库。积累形成了50+业务资产库，新业务可快速进行快速复制、调整并发布。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afd0e641990e23c61031f8378708c84e/" rel="bookmark">
			Android Kotlin学习（五）-OpenCV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Kotlin学习（五）-OpenCV OpenCV导入初始化格式转换绘制文字和图形 因为经常需要使用OpenCV，所以试下Kotlin如何使用OpenCV库 OpenCV导入 OpenCV有封装好的Android库，直接去这里下载：
OpenCV
下载好后在项目里通过Import Module导入到项目中
初始化 OpenCV在Application中初始化：
class MainApplication : Application() { override fun onCreate() { super.onCreate() MMKV.initialize(this); if (!OpenCVLoader.initDebug()){ OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_3_0_0, this, mLoaderCallback); } else { mLoaderCallback.onManagerConnected(LoaderCallbackInterface.SUCCESS); } } private val mLoaderCallback: BaseLoaderCallback = object : BaseLoaderCallback(this) { override fun onManagerConnected(status: Int) { } } } 格式转换 首先加载Assets目录下图片，通过ImageView展示
var am = this.resources.assets; var inputStream = am.open("test.jpg"); var bitmap = BitmapFactory.decodeStream(inputStream); binding.iv1.setImageBitmap(bitmap); Bitmap转Mat，然后转成灰度图
var mat = Mat(bitmap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afd0e641990e23c61031f8378708c84e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/402b782a71b652ff4e03c39755b0ed16/" rel="bookmark">
			深度学习网络学习记录 SRI-Net、改进Unet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、SRI-Net（2019）
修改后的ResNet-101编码器生成多级特征F2、F3、F4，F2、F3和F4的空间分辨率分别为输入大小的1/4、1/8和1/16，解码器使用空间残差起始（SRI）模块来捕获和聚合多尺度信息，然后通过融合多层次语义特征来逐步恢复对象细节。
精度：
二、 改进Unet
基于改进U-Net模型的无人机影像建筑物提取研究.ashx (wanfangdata.com.cn)
下采样 过程包括两个 3×3 的卷积层和一个 2×2 的最大池化层，激活函数 ReLU 保持不变每次 下采样操作都使图像尺寸大小减半，通道数加倍；在网络解码部分，每次上采样过程包括 两个 3×3 的卷积层，激活函数 ReLU 保持不变，每次上采样操作都使图像尺寸大小加倍， 通道数减半。在编码器和解码器之间用一个空洞卷积 DCM 代替传统 U-Net 网络中的底部 卷积层，针对建筑物特点，在单个空洞卷积后添加 1×1 卷积，可以在不破坏特征尺度的基 础上引入非线性因素，提高网络对复杂特征的表达能力，分别采用空洞率为 1、3、5 的空 洞卷积以串并联结合方式进行特征融合，以获取多个尺度的上下文信息。
空洞卷积模块、正则化方法和 scSE 注意力模块都对网络精度提升 做出了贡献，其中空洞卷积和正则化方法使 U-Net 经典网络总体精度提高 2.2%，F1-Score 提高 0.9%，交并比提高 1.9%，但 Kappa 系数有 0.3%的轻微下降；scSE 注意力模块使 UNet 经典网络总体精度提高 2.9%，F1-Score 提高 0.4%，交并比提高 2.1%，Kappa 系数提高 2.8%，加入全部建筑物提取策略的总体精度提高 3.6%，F1-Srore 提高 2.8%，交并比提高 2.9%，Kappa 系数提高 2.9%，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d14e0a7d398999e6f3510cb4918f357/" rel="bookmark">
			MybatisPlus 实体类与数据库表映射关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用MybatisPlus时，需要确定实体类与数据库中数据的映射关系，具体的应该关系有三种
默认：采用驼峰映射规则 例如MyUserTable 对应的数据库表为 my_user_table ; TEMyUserTable 对应数据库表名为t_e_my_user_table;
注解@TableName 在类名上方添加@TableName(“my_user_table”)
采用 mapping 映射文件做映射 &lt;mapper namespace="com.project.main.excel.out.mapper.WorkersOutMapper"&gt; &lt;resultMap type="com.project.main.excel.out.entity.WorkersVO" id="WorkersVOResultMap"&gt; &lt;result property="cardNum" column="card_num"/&gt; &lt;result property="workerName" column="worker_name"/&gt; &lt;result property="age" column="age"/&gt; &lt;result property="sex" column="sex"/&gt; &lt;result property="address" column="address"/&gt; &lt;result property="position" column="position"/&gt; &lt;result property="workDate" column="work_date"/&gt; &lt;/resultMap&gt; &lt;select id="getWorkersToExcelOut" resultMap="WorkersVOResultMap"&gt; SELECT card_num,worker_name,age,sex,address,position,work_date FROM data.workers_data_df &lt;/select&gt; &lt;/mapper&gt; 代码位注释resultMap type
实体类所在位置
id
自定义唯一标识id
result property
实体类对应字段名
column
数据库对应字段名
select id
接口类对应id
resultMap
映射返回参数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00f895e6ba741bca324840a63417aa70/" rel="bookmark">
			【DataX-Web的搭建（Windows/Linux环境）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		备注：我本地目录规划，统一放到文件夹：
D:\java\Projects\sync-data\dataxD:\java\Projects\sync-data\datax-web 一、安装DataX (1) 安装python3（配置环境变量），但从github上下载的版本只支持python2.x版本，而现在python3.x正流行，这给我们带来不少麻烦。
datax 支持Python3需要修改替换datax/bin下面的三个python文件，替换文件地址：datax-web/doc/datax-web/datax-python3 at master · WeiYe-Jing/datax-web · GitHub
(2) 安装jdk8（配置环境变量）
(3) 安装 maven 3.x（配置环境变量）
(4) datax.tar.gz包下载并解压：http://datax-opensource.oss-cn-hangzhou.aliyuncs.com/datax.tar.gz
(5) datax源码下载：https://github.com/alibaba/DataX。(下载源码主要是因为某些源码需要自己修改，然后重新打包覆盖导datax，如下述的mysql版本不一致例子)
ps1：自动下载依赖，如果hitsdb-client报错，则将hitsdb-client依赖版本改为0.3.7即可ps2：因为我的项目用的是mysql8，所以需要将mysqlReader、mysqlWriter服务的mysql的依赖改为8.0.17，默认是5.xps3：datax-all服务执行clean-installps4：将mysqlReader、mysqlWriter生成的target–&gt;datax–&gt;plugins复制到datax的bin同级的目录下，覆盖即可ps5：将“datax\plugin\reader\mysqlreader\libs”、“datax\plugin\writer\mysqlwriter\libs”目录下的mysql5的包删除
二、使用DataX (1) 打开cmd界面
(2) 进入datax的bin目录下
(3) 输入CHCP 65001 防止中文乱码
(4) 查看模板命令行：python datax.py -r streamreader -w streamwriter
(5) 执行脚本：python datax.py E:\datax\datax\datax\job\job.json
ps1：报错：提供的配置文件[D:\java\Projects\sync-data\datax\plugin\reader._cassandrareader\plugin.json]不存在. 请检查您的配置文件.
​ —&gt;解决：删除datax\plugin\writer、datax\plugin\reader底下"._"开头文件
(6) 编写脚本，将脚本存放到datax\datax\job目录底下，然后执行后python datax.py datax\job\你的脚本.json运行
ps1：脚本格式信息可以去https://github.com/alibaba/DataX/查看
ps2：脚本基础参数说明（mysql、oracle）
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00f895e6ba741bca324840a63417aa70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e819a78d5cad606dc6d3f038f828d5dc/" rel="bookmark">
			ubuntu20.04分区方案 for deeplearning
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一共分出4个系统分区。
1. 设置efi引导
因为是u盘的uefi启动，因此设置一个efi引导项。
具体参数：
大小: 500到1024mb即可
（视自身的存储空间而定）
新分区的类型： 逻辑分区
新分区的位置： 空间起始位置
用于： EFI系统分区
2.swap
swap用作虚拟内存，根据自身的物理内存决定。
如果物理内存在8G以下，则swap设置为物理内存一样的大小，如果超过8G，则一般设置为8G大小的虚拟内存就足够了。根据自身的使用需求，也可以适当增大swap大小。
我的电脑用了两个8g的内存条，因此大小设置为了16g*1024=16384MB。
具体参数：
大小: （视自身的物理内存而定）
新分区的类型： 主分区
新分区的位置： 空间起始位置
用于： 交换空间
3. 挂载点/
主要用来存放ubuntu系统文件。有固态硬盘的可以安在固态盘中。
具体参数：
大小: 80G
（视自身的存储空间而定）
新分区的类型： 逻辑分区
新分区的位置： 空间起始位置
用于： Ext4日志文件系统
挂载点： /
4.挂载点/home
存放用户文件。这个分区尽量设置大一些，分配剩下的存储空间给它。
具体参数：
大小: 剩余空间 &gt;=300G
（视自身的存储空间而定）
新分区的类型： 逻辑分区
新分区的位置： 空间起始位置
用于： Ext4日志文件系统
挂载点： /home
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76937a0ba46507c2b663677ab1ca4577/" rel="bookmark">
			【教程】如何使用Java生成PDF文档？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在如今数字化时代，越来越多的人使用PDF文档进行信息传递和共享。而使用Java生成PDF文档也成为了一个非常重要的技能，因为Java作为一种通用的编程语言，可以在不同的操作系统和平台上运行。下面，我们将为您介绍如何使用Java生成PDF文档。
一、概述 PDF文档的生成通常包括两个步骤，首先需要使用Java代码创建一个PDF文档对象，然后向文档中添加内容。要生成PDF文档，我们可以使用多种Java开源库，如iText、Apache PDFBox和Flying Saucer等。
在本教程中，我们将使用iText库来生成PDF文档。iText是一个流行的开源Java库，它提供了创建PDF文档所需的所有功能。
二、环境搭建 在开始之前，我们需要安装Java和iText库。如果您还没有安装Java，可以从Oracle官网上下载Java Development Kit（JDK）。要使用iText库，您可以从iText官网上下载iText库的最新版本。
当您下载并解压缩iText库后，将iText.jar文件添加到您的Java项目的类路径中。如果您正在使用Maven项目，则可以将以下依赖项添加到pom.xml文件中：
&lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itextpdf&lt;/artifactId&gt; &lt;version&gt;5.5.13&lt;/version&gt; &lt;/dependency&gt; 三、创建PDF文档 现在，我们已经准备好开始创建PDF文档了。在iText库中，我们使用Document类表示PDF文档。要创建Document对象，请按照以下步骤进行操作：
//创建文档对象 Document document = new Document(); //设置输出流 PdfWriter.getInstance(document, new FileOutputStream("example.pdf")); //打开文档 document.open(); //向文档中添加内容 document.add(new Paragraph("Hello World!")); //关闭文档 document.close(); 在上面的代码中，我们首先创建了一个Document对象。然后，我们使用PdfWriter类将文档输出到文件系统中的example.pdf文件中。接下来，我们打开文档并向其中添加一个段落，最后关闭文档。
四、添加文本和图片 现在，我们已经创建了一个简单的PDF文档，接下来我们将向其中添加更多的内容。iText库提供了许多类来添加文本、图片和表格等内容。
添加文本：在iText库中，我们使用Paragraph类表示一个段落。可以使用以下代码将文本添加到PDF文档中：
Paragraph paragraph = new Paragraph(); paragraph.add(new Chunk("This is some text ")); paragraph.add(new Chunk("and some more text")); document.add(paragraph); 在上面的代码中，我们创建了一个新的段落并添加了两个文本块。可以使用Chunk类创建文本块。接下来，我们将段落添加到PDF文档中。
添加图片：我们可以使用Image类将图片添加到PDF文档中。以下是一个简单的示例代码：
Image image = Image.getInstance("logo.png"); document.add(image); 在上面的代码中，我们首先创建一个Image对象并将其初始化为logo.png文件中的图像。然后，我们将该图像添加到PDF文档中。
五、创建表格 要在PDF文档中创建表格，我们可以使用iText库中的Table和Cell类。以下是一个简单的示例代码：
//创建表格对象 Table table = new Table(3); //向表格中添加内容 table.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76937a0ba46507c2b663677ab1ca4577/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59769a88ae9480cc63d1032671d1c36c/" rel="bookmark">
			RS&amp;D锁存器基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 1. 基本SR锁存器电路图特性表 2. 同步SR锁存器3. 同步D锁存器电路图时序图 1. 基本SR锁存器 电路图 特性表 Q n Q^n Qn （现态）：Q在接受输入信号R,S 前的状态（
Q n + 1 Q^{n+1} Qn+1（次态）：Q在接受输入信号R,S 后的状态
Q ‾ \overline{Q} Q​：一般与Q相反，但也有相同的情况。相同时为不定态，设计时需避免。
S ‾ \overline{S} S=1, R ‾ \overline{R} R=1时，Q值不变，实现保持功能（记忆为，RS都无效，实现保持功能） S ‾ \overline{S} S=0, R ‾ \overline{R} R=1时，体现S（set）低电平有效，把Q强制置1（置位（set）=置1） S ‾ \overline{S} S=1, R ‾ \overline{R} R=0时，体现R（reset）低电平有效，把Q强制置0（复位（reset）=置0） S ‾ \overline{S} S=0, R ‾ \overline{R} R=0时，Q= Q ‾ \overline{Q} Q​，Q值在不停变化，不稳定，一般不用这个状态（记忆为，RS都有效，会出错，就不用） 2. 同步SR锁存器 等价于SR触发器，加一个开关（控制线CR）
CP=0时，Q保持不变
CP=1时，Q的输出受RS的控制（作用相当于RS触发器）
3. 同步D锁存器 同步D触发器相当于把RS触发器的R和S，集合成D（置1效果和置0效果合成为跟随效果），再加入一条控制线CLK。CLK相当于一个开关，开启时（CLK=1），Q跟随D变化；关闭时（CLK=0），Q保持不变，不受D的影响。另外，还有一种边沿D触发器：开启=CLK上升沿；关闭=CLK下降沿 电路图 D为输入端，CLK为时钟信号控制端
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59769a88ae9480cc63d1032671d1c36c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d19d1ff2344ec26939fa5d1959cfe10b/" rel="bookmark">
			Android 开发中获取屏幕宽高(分辨率)的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Android 开发中获取屏幕宽高(分辨率)的几种方式 获得手机屏幕的宽高 ：（方式一） 获取WindowManager有两种方式：1: WindowManager wm = this.getSystemService(WINDOW_SERVICE); 2: WindowManager wm = this.getWindowManager(); Display display = this.getWindowManager().getDefaultDisplay();	//获得默认（本地）的显示设备 screen_width = display.getWidth(); screen_Height = display.getHeight(); // 两个函数已经过时！，但是最简单 获得手机屏幕的宽高 ：（方式二） ------【推荐使用】----------- DisplayMetrics dm = new DisplayMetrics();//屏幕度量 getWindowManager().getDefaultDisplay().getMetrics(dm); screen_width = dm.widthPixels;//宽度 screen_height = dm.heightPixels ;//高度 获得手机屏幕的宽高 ：（方式三） ---------【C工程师常用–推荐】----------- Point p = new Point(); Display display = this.getWindowManager().getDefaultDisplay();	//获得默认（本地）的显示设备 display.getSize(p); int screen_width = p.x; int screen_Height = p.y; 【注意：使用这这种方式，必须设置应用的最低支持SDk为13以上(安卓3.2以上)。】	
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ac26c38bc5a4987eda8d863e371c9a3/" rel="bookmark">
			js 实现俄罗斯方块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现思路
MVC思路。三个端分工合作。可以仔细看。整个俄罗斯方块为一个二维数组。C控制M, M控制二维数组，V只要把二维数组渲染出来就行 。我下面的实现思路可以应用到任何一个这种二维数组感觉的小游戏。扩展性还算不错。
视图层
html部分
&lt;canvas id="canvas"&gt;&lt;/canvas&gt; js部分
这里就是画背景和画全部方框的方法。
// 画背景 function drawBG(){ CTX.lineWidth = 1; CTX.fillStyle = "#000"; CTX.fillRect(0,0, CANVAS.width, CANVAS.height); CTX.strokeStyle = "#eee"; // 画横线 for(let i = BLOCK_SIZE; i &lt; CANVAS.height; i +=BLOCK_SIZE){ CTX.beginPath(); //新建一条path CTX.moveTo(0, i); CTX.lineTo(CANVAS.width, i); CTX.closePath(); CTX.stroke(); //绘制路径。 } // 画竖线 for(let i = BLOCK_SIZE; i &lt; CANVAS.width; i += BLOCK_SIZE){ CTX.beginPath(); //新建一条path CTX.moveTo(i, 0); CTX.lineTo(i, CANVAS.height); CTX.closePath(); CTX.stroke(); //绘制路径。 } } // 绘制全部格子 function drawAllBlock(){ for(let i = 0; i &lt; Y_MAX; i++){ for(let j = 0; j &lt; X_MAX; j ++){ CTX.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ac26c38bc5a4987eda8d863e371c9a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e291422bcbac1171db283cf502310648/" rel="bookmark">
			java汉字转拼音工具类-全部拼音或每个汉字拼音首字母
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用pinyin4j
纯汉字 可以直接转成全部拼音，或者每个拼音的首字母
汉字-英文-数字 中间的符号会忽略，英文数字原样保留，汉字 可以直接转成全部拼音，或者每个拼音的首字母
以下是
带有测试主方法的工具类 import net.sourceforge.pinyin4j.PinyinHelper; import net.sourceforge.pinyin4j.format.HanyuPinyinCaseType; import net.sourceforge.pinyin4j.format.HanyuPinyinOutputFormat; import net.sourceforge.pinyin4j.format.HanyuPinyinToneType; import net.sourceforge.pinyin4j.format.HanyuPinyinVCharType; import net.sourceforge.pinyin4j.format.exception.BadHanyuPinyinOutputFormatCombination; import org.apache.commons.lang.StringUtils; /** * 汉子转拼音工具类（使用pinyin4j） */ public class HanyuPinyinUtil { private static HanyuPinyinOutputFormat format; static { format = new HanyuPinyinOutputFormat(); // UPPERCASE：大写 (ZHONG) // LOWERCASE：小写 (zhong) format.setCaseType(HanyuPinyinCaseType.LOWERCASE); // WITHOUT_TONE：无音标 (zhong) // WITH_TONE_NUMBER：1-4数字表示英标 (zhong4) // WITH_TONE_MARK：直接用音标符（必须WITH_U_UNICODE否则异常） (zhòng) format.setToneType(HanyuPinyinToneType.WITHOUT_TONE); // WITH_V：用v表示ü (nv) // WITH_U_AND_COLON：用"u:"表示ü (nu:) // WITH_U_UNICODE：直接用ü (nü) format.setVCharType(HanyuPinyinVCharType.WITH_V); } /** * 获取全部拼音 */ public static String transform2Pinyin(String str) throws BadHanyuPinyinOutputFormatCombination { return filterSpecialChar(transform2Pinyin(str, format)); } /** * 获取拼音首字母 */ public static String transform2PinyinInitial(String str) throws BadHanyuPinyinOutputFormatCombination { return filterSpecialChar(getPinyinInitial(str, format)); } private static String transform2Pinyin(String str, HanyuPinyinOutputFormat outputFormat) throws BadHanyuPinyinOutputFormatCombination { if (StringUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e291422bcbac1171db283cf502310648/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f258702b5edf1064eb8c6fedce2b443/" rel="bookmark">
			使用代理时网页访问正常，git无法clone
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		明明已经使用了vpn，命令行还git clone一直被拒绝
fatal: unable to access 'https://github.com/pytorch/vision/': Failed to connect to github.com port 443 after 21206 ms: Couldn't connect to server 首先，检测ping是否成功
$ ping github.com Pinging github.com [20.205.243.166] with 32 bytes of data: Request timed out. Request timed out. Request timed out. Request timed out. Ping statistics for 20.205.243.166: Packets: Sent = 4, Received = 0, Lost = 4 (100% loss), $ ping yuque.com Pinging yuque.com [139.224.214.226] with 32 bytes of data: Reply from 139.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f258702b5edf1064eb8c6fedce2b443/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/069200b1e9634b9b68f46dab883460a7/" rel="bookmark">
			jmeter获取请求参数保存到文件中用于后续的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
为了解决压测中多个脚本要获取同一个数据的场景，如：其他接口需要用到登录操作的请求数据，因为需要在注册的时候保存下一级注册的数据作为后续登录的请求数据
如下图中，想要获取注册接口的手机号作为后续登录的请求参数
使用BeanShell后置处理程序，提取请求的参数并保存到指定的文件中
代码【借鉴其他大佬的，亲测可用】
import org.json.*; import com.alibaba.fastjson.*; import java.io.*; //获取接口中的请求参数 String request=ctx.getCurrentSampler().getArguments().getArgument(0).getValue(); log.info("request is:"+request); //将请求参数转为JSON格式 JSONObject data_obj=JSON.parseObject(request); //拿到指定入参 String data_1=data_obj.getString("phone"); log.info("fund_account is: "+data_1); FileWriter file=new FileWriter("C:/Users/dell/Desktop/zhuce_phone.csv",true); BufferedWriter out = new BufferedWriter(file); out.write(data_1+"\n"); out.close(); file.close(); 保存结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/996d920c291336d9cc9ae079ae7fed61/" rel="bookmark">
			XLSX.js导出,支持单元格合并,背景色,列宽,字体大小等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始之前先上效果图，代码可直接复制前端使用，觉得不错的可以点个赞
1.需要用到的js自行下载 (1)js-xlsx.js
https://github.com/Ctrl-Ling/XLSX-Style-Utils或者https://github.com/SheetJS/js-xlsx
里面的xlsx.core.min.js或xlsx.full.min.js(本文用到xlsx.core.min.js)
(2)xlsxStyle.js
https://github.com/Ctrl-Ling/XLSX-Style-Utils
里面的xlsxStyle.core.min.js(本文用到xlsxStyle.core.min.js)
(3)xlsxStyle.utils.js
https://github.com/Ctrl-Ling/XLSX-Style-Utils
里面的xlsxStyle.utils.js
引入文件
&lt;script src = '/xlsx.core.min.js' &lt;/script&gt;; &lt;script src = '/xlsxStyle.core.min.js' &lt;/script&gt;; //表头 let tableHead = { 'name': '姓名', 'subject': '学科', 'score': '成绩' }; //json数据 let tableData=[{ 'name': '李明', 'subject': '数学',//以下给该字段加上颜色，详情见代码 'score': '98' },{ 'name': '李明', 'subject': '语文', 'score': '96' },{ 'name': '赵寻', 'subject': {'value':'数学','fgColor':'92D050'},//这里为了演示自定义颜色数据格式 'score': '95' },{ 'name': '王力', 'subject': '数学', 'score': '80' }]; let countNum = [];//统计相同姓名的占列个数 tableData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/996d920c291336d9cc9ae079ae7fed61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfb04fc3963fd00abb1ceede4e2f112f/" rel="bookmark">
			vscode和vs有什么区别?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode是微软新推出的一款代码编辑器， 内置了一些编译器，免费开源跨平台的工具。VS是微软的商业企业级开发环境IDE。
在这之前 我们写代码的工具可以分为三个层次。最轻量级的叫做代码编辑器，例如notepad,notepad++,subline等，这些基本上只带有代码编辑功能，以及少量调试功能。剩下的更多的像是综合商业开发环境，例如Eclipse,Jbuilder,AndroidStudio以及微软的Visual Studio(VS)，这些工具包含了工程管理，代码管理，代码编辑编译，团队协作，代码重构等一些列功能.
问题是一般情况下，前者功能不足，后者又过于笨重。所以就有一些个于两者之间的工具，例如Vim,Emacs,以及Visual Studio Code(VSC)即VSCode, Visual Studio Code，一般简称VSC，是微软推出的于编辑器和IDE之间的工具。句令了全套代码编辑器的功能，同时增加了一部分最常用的功能，比如项目管理，代码编译和调试等。并且支持通过插件扩展和跨平台。
简言之 ：
VSCode--代码编辑器Plus
VS--全家桶IDE
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd75d1eea56c5c7e79425e4f757a5870/" rel="bookmark">
			Linux服务器snmp协议v2/v3配置方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Snmp V2 配置方法 1、确保本机已经安装了snmp服务
[root@idc ~]# rpm -qa |grep snmp net-snmp-libs-5.1.2-11.EL4.7 net-snmp-5.1.2-11.EL4.7 如果没有，可以使用： “yum install net-snmp” 使其自动上网下载安装。如果机器无法上网，最好使用光盘rpm包安装，一般需要安装三个文件:
vi /etc/snmp/snmpd.conf
net-snmp
lm_sensors_libs
net_snmp_libs
2、snmpd.conf文件配置vi /etc/snmp/snmpd.conf
按照如下方式修改snmpd.conf文件，修改团体名，并新增一行内容，然后保存
3、重启snmpd服务
service snmpd restart
service snmpd stop(停止)
service snmpd start（启动） 完成snmpd的配置
4、查看是否开启snmp进程
命令：ps -ef |grep 161或者ps -ef |grep snmpd
关闭防火墙
Snmp V3配置方法 CentOS7下如何配置v3版本snmpd服务
snmp v3安全级别有三种，分别为noAuthNoPriv（不认证也不加密）、authNoPriv（认证但是不加密）、authPriv（既认证又加密）
snmp v3安装
1.在centos/redhat平台下通过如下命令安装：
# yum -y install net-snmp net-snmp-devel net-snmp-utils
Snmp v3配置 【authNoPriv/authPriv】
1.配置前，先使用service snmpd stop命令停止snmpd服务。不停止进行服务时行配置时，会提示“Apparently at least one snmpd demon is already running.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd75d1eea56c5c7e79425e4f757a5870/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86881fda841ae9cf05f47c7814c5b96d/" rel="bookmark">
			【uGUI笔记】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c933f83f6aef6914b7c518f34974284/" rel="bookmark">
			【Unity】[UI文本多行对齐] 怎么把多行文本对齐 | 多行类似 xx : 1 ,x:115 对齐冒号和数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 成品 代码 totalResidentText.text = $"Total\t:{Data.totalResidentNumber,-2}"; sickText.text = $"Sick\t:{Data.sickNumber,-2}"; curedText.text = $"Cured\t:{Data.curedNumber,-2}"; deadText.text = $"Dead\t:{Data.deadNumber,-2}"; 另 $符号是字符串内插https://blog.csdn.net/gongfpp/article/details/128995042?spm=1001.2014.3001.5502 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8460128379ca381c6011d7d126de7ca8/" rel="bookmark">
			中兴盒子B860AV1.1-T2版刷公版固件教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		宽带到期后，机顶盒也没有再继续使用。放在角落里闲置的机顶盒放着落了一层灰，闲来无事想着能不能改造他们。变废为宝呢？
改造思路：目前宽带赠送的IPTV机顶盒都是基于安卓系统开发，因为有之前移动机顶盒系统刷机经验，随想可以用公版系统去替代原来的系统。安卓系统支持线刷和卡刷，之前改造移动的盒子是用的线刷。移动机顶盒刷机全过程已经发布，有需要可以查阅此链接研究查看。查阅相关盒子介绍，再结合网上很多前辈的经验，电信盒子可以用卡刷。
卡刷刷机前期准备事宜：
硬件设备：Windows笔记本一台，安卓手机或者平板一台，需要刷系统的机顶盒一台。
软件设备：1、下载公版ROM，2、ADB工具，3、ADB密码计算器。
ROM介绍：
1.这个固件目前只适用中兴B860AV1.1-T2盒子，是纯净精简包，系统包含当贝桌面和当贝市场纯净版。
2.用这个ROM刷机后将导致原IPTV失效，一般刷已经不再使用的IPTV盒子，请谨慎选择！
3.刷机后可支持自由安装第三方应用，电视家，火星直播，奇异果，腾讯视频等一众软件可以自由玩耍；
4.注意：四川地区等高安CA版本请勿下载，不可刷入！
需要的刷机的同学，请一定注意：严谨操作，谨慎刷机
1、准备刷机工具：
1.1刷机包下载：百度网盘https://pan.baidu.com/s/1ia9gzanuo84T7JPhtpnszw?pwd=9l5a 提取码：9l5a
下载后解压，得到主要2个文件：ota.zip和recovery.img，
电脑插上一个U盘（请格式为FAT32的），将recovery.img复制U盘根目录，然后再新建一个文件夹，命名ZTESTBUSB，并将ota.zip复制到ZTESTBUSB文件夹里，复制完毕后，将U盘插到机顶盒的USB接口上。
1.2 ADB组件下载：http://cdn.tvapk.com/zndsjc/adb.zip将下载好的ADB组件解压到C盘的根目录
1.3 最新ADB密码计算器下载：http://cdn.tvapk.com/zndsrom/app/zikaikeji.apk
准备一台安卓手机，将最新的ADB密码计算器安装上（如果没有安卓手机或平板，也可以在电脑安装一个电脑安卓模拟器）
2、开启盒子，准备刷机：
进入中兴盒子的设置，一般密码为：6321或运营商的号码（10086、10000、10010），连接Wi-Fi（或者网线）（注意：机顶盒和电脑需要处于同个网段）。
接着选择运维调试，打开ADB。点击打开ADB的时候会弹出一个提示，提示将MAC地址和随机数发送给厂家，获取ADB密码。显然，我们不可能问厂家要到这个密码。那这个时候该怎么办呢？往下看，这个时候就需要刚才安卓手机或平板安装的ADB密码计算器上场了。
当看到提示将MAC地址和随机数发送给厂家获取ADB密码时，在手机上运行ADB密码计算器，将对应的MAC地址与随机数填入。
这里需要注意，如果随机数是不带C的就选第一个“计算20170106”，如果随机数是带C的就选择“计算20180207”，然后将计算的密码填入，确定后提示：成功激活ADB！
3、回到电脑操作，按下键盘快捷键“WIN+R”
输入“cmd”确定，进入命令终端：
复制以下加粗的代码黏贴上去之后，按回车键。
C:\Users\Jack&gt;cd c:/adb
c:\adb&gt;adb connect 192.168.31.232 （connect的Ip地址是机顶盒的，每个网络的都可能不一样，不要以我的为准，打开盒子设置——设备信息里面可以找到你的盒子IP地址，输入自己盒子的IP）
* daemon not running. starting it now on port 5037 *
* daemon started successfully
*connected to 192.168.31.232:5555
c:\adb\adb&gt;adb she11
shel10square:/$su
SU
she11@square:/ # mount -o remount -o rw /system
mount -oremount-o rw/system
she11@square:/ # df
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8460128379ca381c6011d7d126de7ca8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eecc5faf2ef3da626b0493702cb24a57/" rel="bookmark">
			VS2022快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ctrl+tab 切换页面
Ctrl+D 粘贴光标所在行代码
Ctrl+/ 行注释掉/取消行注释
Ctrl+shift+/ 块注释/取消块注释
Tab 向右缩进（两格）
Shift+Tab 回退一个制表符
Ctrl+enter 当前行之前开辟一行
Ctrl+Z 撤销
Ctrl+Y 反撤销
Ctrl+A 全选
Ctrl+C 复制
Ctrl+V 粘帖
Ctrl+S 保存
Ctrl+F 快速查找
Ctrl+Shift+F 在文件中查找
Ctrl+H 快速替换
Home 回到行首
End 跳到行尾
Shift+Left/Right 向左/向右选中字符
Ctrl+Left/Right 以一个单词为粒度向左/向右移动光标 1、F4，显示属性窗口。
2、F12，转到定义。
3、Shift+Tab，取消制表符。
4、F5，运行调试； Ctrl + F5，运行不调试；Shift+F5，结束调试。
5、Ctrl+K+C，注释选中内容；Ctrl+K+U，取消注释内容。
6、Ctrl+W+X，打开工具箱。
7、Ctrl+E+W，自动换行。
8、Ctrl+M+M，隐藏或展开当前嵌套的折叠状态。
9、Ctrl+L，删除一行内容。
10、Ctrl+E+D，排版整个文档格式。
11、F11,逐语句调试；F10，逐过程调试；F9，启用/停止断点；ctrl+shift+F9，删除全部断点。
12、Ctrl+E+S，查看空白。
13、Ctrl+Alt+L，打开解决方案资源管理器。
14、F1，显示MSDN帮助。
15、Shift+Alt+F10，导入命名空间。
16、Ctrl+F4，关闭当前标签窗口。
17、Ctrl+Shift+空格键，查看参数信息。
18、Shift+Alt+C，添加类。
19、Ctrl+R+E，声明属性后，快捷键生成属性的get和set方法。
20、光标快速切换到下一行：Ctrl + Shift + Enter；
光标快速切换到上一行：Ctrl + Enter。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eecc5faf2ef3da626b0493702cb24a57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17cf2175f36375397146e7f62ba71712/" rel="bookmark">
			一、SpringCloud初步了解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringCloud基础构建 SpringCloud组件说明 停更引发的“升级惨案”停更不停用被动修复bugs不再接受合并请求不再发布新版本Cloud升级
父工程Project空间新建 约定&gt;配置&gt;编码
1.New Project - maven工程 - create from archetype: maven-archetype-site
2.聚合总父工程名字
3.Maven选版本
4.工程名字
5.字符编码 - Settings - File encoding
6.注解生效激活 - Settings - Annotation Processors
J7.ava编译版本选8
8.File Type过滤 - Settings - File Type
父工程POM文件 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;cloud-provider-payment8001&lt;/module&gt; &lt;module&gt;cloud-consumer-order80&lt;/module&gt; &lt;/modules&gt; &lt;!-- 统一管理jar包版本 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;12&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;12&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;mysql.version&gt;5.1.47&lt;/mysql.version&gt; &lt;druid.version&gt;1.1.16&lt;/druid.version&gt; &lt;mybatis.spring.boot.version&gt;1.3.0&lt;/mybatis.spring.boot.version&gt; &lt;/properties&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17cf2175f36375397146e7f62ba71712/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af2c3d31e21f331ff336f9ad825f6171/" rel="bookmark">
			webrtc-mediasoup 学习- 调试相关（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 官方文档node 相关语法node 进程相关protoo.websocket 基本API：info, accept, reject gulp 使用node 调试三种启动方式服务端调试dump 工具mediasoup-worker 应用程序 客户端调试 mediasoup-demo 设置默认视频编码 VP8 修改为 H264ffmpeg 推流 h264 脚本修改 wireshark 解析数据配置 wireshark 解密 chrom 的加密数据导出 RTP 打包的 H264 H265 码流rtp_h264_export.luartp_h265_export.lua 官方文档 v3 Documentation
node 相关语法 node 进程相关 Node child_process的fork，spawn，exec我有话要说
node 通过 child_process.spawn 完成多个子线程创建。
spawn英 [spɔːn] 美 [spɔːn] v.产卵;引发;引起;导致;造成 protoo.websocket 基本API：info, accept, reject protoo.websocket 基本API讲解与使用（六
gulp 使用 gulp是一个常见的自动化构建工具，主要用来设定程序自动处理静态资源的工作。简单的说，gulp就是用来打包项目的。
node 调试 三种启动方式 node的3种运行方式
node xx.jsnode startnpm start 服务端调试 启动 node --inspect-brk service.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af2c3d31e21f331ff336f9ad825f6171/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/620d45460beae122ba9ccc9a8973be71/" rel="bookmark">
			webrtc-mediasoup 学习-ubuntu20.04 搭建 mediasoup-demo-3（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 官方文档工程相关开发组件模块组件 ubuntu20.04 安装部署 mediasoup-demo-3工具npm 安装依赖安装证书和私钥错误解决 官方文档 v3 Documentation
工程相关 开发组件 .ts 文件： typescript 语法c++ 底层 模块组件 mediasoup-3 // 工程源码 mediasoup-demo-3 // WebRTC demo 演示例子：信令协议协议实现的示例 mediasoup-client-3 //客户端 JavaScript 库 libmediasoupclient-3 //基于 google libwebrtc 的 C++ 库,保持了和 mediaclient 一样的接口 aiortc //是Python中用于WebReal-Time通信（WebRTC）和对象Real-Time通信（ORTC）的库。它构建在asyncio（Python的标准异步I/O框架）之上。 ubuntu20.04 安装部署 mediasoup-demo-3 工具 找一个好的 T 子
npm 安装依赖 server brody@brody:~/workspace/software/mediasoup-demo/server$ npm install npm WARN deprecated source-map-url@0.4.1: See https://github.com/lydell/source-map-url#deprecated npm WARN deprecated urix@0.1.0: Please see https://github.com/lydell/urix#deprecated npm WARN deprecated resolve-url@0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/620d45460beae122ba9ccc9a8973be71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b1a5d09ef4b9c82b4a3ec7ecef1705f/" rel="bookmark">
			集成学习（bagging/boosting/stacking）BERT,Adaboost
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 集成学习（ensemble learning）1.bagging(装袋法)2.boosting(提升法)3.stacking(堆叠法) 集成学习（ensemble learning） 集成学习是集合多个弱监督模型，通过一定的结合策略，得到一个更好更全面的强监督模型的过程
潜在的思想是即使某一个弱分类器得到了错误的预测，其他的弱分类器也可以将错误纠正回来
弱学习器：常指泛化性能略优于随机猜测的学习器，例如在二分类问题中精度略高于50%的分类器
强学习器：通过一定的方式集成一些弱学习器，达到了超过所有弱学习器的准确度的分类器
构建集成学习模型时需要先明确两个问题：
1.如何得到若干个个体学习器2.如何选择结合策略 问题1：如何得到若干个个体学习器 若学习器是同质的，一个类型的---bagging,boosting 继续划分，看学习器之间是否存在依赖关系 - 不在依赖关系：bagging - 存在：boosting 学习器异质---Stacking 1.bagging(装袋法) 方法的关键是自主采样法(Bootstrap sampling),方法原理是，从N个样本的训练集中，取N次样本，每取一次，放回，也就是说取到的N个样本中，可能有重复的，也会有相当一部分样本没有被取到过
这样做的话，初始数据集中约有63.2%的样本出现在采样数据集中，36.8%的样本不出现
概率计算：
从数据集中取N次样本，每次都放回，样本A不被取到的概率为 ( 1 − 1 N ) N (1-\frac 1 N)^N (1−N1​)N，当 N → ∞ N\to\infty N→∞，上式 = 1 e =\frac 1 e =e1​
该方法可分类，可回归
分类任务，投票表决，回归任务，平均法
代表：随机森林
2.boosting(提升法) 原理：先基于数据集，对每个样本附一个初始权重（相等），构建一个基模型，根据基模型的表现，对训练样本的权重进行调整，对分错的训练样本予以更大权重，在后续模型中重点关注、学习这些难分的样本，如此重复直到构建好K个模型再将这K个模型进行加权整合学到这里，我有几个疑问需要后续解决： 1.初始权重是否都是一样的值2.对难分的训练样本权重调整多少？有什么规则？怎样选择调整量？3.最后对这K个模型进行加权整合时，每个模型的权重是如何确定的？4.在加大对难分的样本的权重后，模型是否会有效果的提升？5.就算加大了这个训练样本的权重，在训练时怎么运用这个权重？ 代表模型：AdaBoost， Xgboost，GBDT 3.stacking(堆叠法) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff25e1d8f1045133a37a624e649837fa/" rel="bookmark">
			【FFmpeg】PCM编码成AAC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用FFmpeg把PCM裸数据编码成AAC音频流，具体步骤跟YUV编码成H264差不多。
1、命令行 ffmpeg -f s16le -ar 44100 -ac 2 -i bb1.pcm output.aac -f PCM数据为s16le
-ar 采样率为44100
-ac 通道数为2
这样就通过命令把PCM数据编码成AAC了。
2、使用API编码 FFmpeg内部AAC格式只支持AV_SAMPLE_FMT_FLTP格式的PCM，由于我们的PCM数据是s16le的，因此我们需要把s16le格式转换成fltp格式再进行编码。我们可以在AVCodec结构体中的sample_fmts字段中判断编码器是否支持你的格式。
初始化输出文件上下文
int avformat_alloc_output_context2(AVFormatContext **ctx, ff_const59 AVOutputFormat *oformat, const char *format_name, const char *filename); ctx 输出文件的上下文
oformat 输出文件的AVOutputFormat，传NULL，FFmpeg会根据filename的格式初始化oformat
format_name 输出文件的格式， 传NULL，FFmpeg会根据filename的格式初始化format_name
filename 输出文件路径
初始化编码器上下文
dec = avcodec_find_encoder(ofmt_ctx-&gt;oformat-&gt;audio_codec); if (!dec) { printf("avcodec_find_encoder fail \n"); goto __FAIL; } dec_ctx = avcodec_alloc_context3(dec); dec_ctx-&gt;sample_fmt = AV_SAMPLE_FMT_FLTP; if (!check_sample_fmt(dec, dec_ctx-&gt;sample_fmt)) { fprintf(stderr, "Encoder does not support sample format %s"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff25e1d8f1045133a37a624e649837fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d56e7db5c4cff22aa0147e0992ed8b25/" rel="bookmark">
			Matlab保存double图像，解决imwrite与imshow不一致的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常情况下，我们输入的图像是 unit8 格式，而 Matlab 为了提高运算时的精度，都会把图像转为 double 类型。
但是我们在使用 imwrite 保存图像时，如果直接使用 double 类型，会导致图像变成二值图像。而且此时使用 imshow 查看的话，显示出来的图像还是正常的。
为了解决这个问题，需要对double图像进行归一化：
Orimax = max(max(img)); Orimin = min(min(img)); saveImg = img./(Orimax-Orimin+eps); 其中 img 为输入图像，saveImg 为输出图像，归一化之后再保存saveImg就正常了，亲测有效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee9e9b0499840019eec6d4c9079f51d4/" rel="bookmark">
			chatGPT 生成随机漫步代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. chatGPT 写的随机漫步代码
2. 笔者写的随机漫步代码 3. 总结 1. chatGPT 写的随机漫步代码 最近在学习 Python 中的 随机漫步 知识点，突发奇想，心血来潮，想着用 chatGPT 来生成随机漫步代码，让我们来看看是啥效果吧 ！！
import numpy as np import matplotlib.pyplot as plt # Set the number of steps n = 5000 # Set the step size step_size = 0.1 # Generate the random walk model walk = np.cumsum(np.random.normal(0, step_size, n)) # Plot the random walk model plt.plot(walk) # Set the plot title and axis labels plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee9e9b0499840019eec6d4c9079f51d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5adbe7cfecbd90248ec691e13f043ea9/" rel="bookmark">
			chrome浏览器官方（稳定版）下载以及历史版本下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		chrome浏览器 官方（稳定版） 下载** 以及历史各个版本下载 一、地址 总地址：chrome（稳定版）下载以及历史版本下载
历史版本：历史各个版本下载
二、介绍 Google Chrome，又称谷歌浏览器，是一个由Google（谷歌）公司开发的网页浏览器。本软件的程式码是基于其他开放源代码软件所撰写，包括WebKit和Mozilla，目标是提升稳定性、速度和安全性，并创造出简单且有效率的使用者界面。软件的名称是来自于又称作“Chrome”的网络浏览器图形使用者界面（GUI）。
Chrome相应的开放源代码计划名为Chromium，而Google Chrome本身是非自由软件，未开放全部源代码。
软件的 beta 测试版本在2008年9月2日释出，提供 43 种语言版本，目前支持包括 Windows、macOS、Linux、Android、iOS等平台。在 Chrome 50 版本时结束了对 Windows XP 与 Windows Vista 系统的支持，这两个系统上的最后版本为49.0.2623.112。
官方的正式宣布在 2008 年 9 月 3 日举行，并将寄给记者和部落客一则解说新浏览器特色和研发动机的漫画，该漫画由史考特·迈克劳德（Scott McCloud）所绘制，并在创作共享的“姓名标示-非商业性-禁止改作 2.5 ”版权协议下发行。由于要送往欧洲的信件提早寄出，因此德国 “Google Blogoscoped” 部落格的作者菲利普·蓝森（Philipp Lenssen）在 2008 年 9 月 1 日收到漫画后就扫描并放上自己的网站。随后 Google 就将这则漫画放到 Google Books 和 Google 网站上，并在自家的部落格中说明了提早释出的原因。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20895f4cdd194fac3e623cbbd892488f/" rel="bookmark">
			C# 获取 本周、本月、本年 的开始或结束时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取 本周、本月、本年 的开始或结束时间 public class DateTimeUtil { // 获取 本周、本月、本年 的开始或结束时间 /// &lt;summary&gt; /// 获取开始时间 /// &lt;/summary&gt; /// &lt;param name="TimeType"&gt;Week、Month、Year&lt;/param&gt; /// &lt;param name="NowTime"&gt;当前时间&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string GetStarTimetByType(string TimeType, DateTime NowTime) { switch (TimeType) { case "Week": return NowTime.AddDays((7 - (int)NowTime.DayOfWeek) % 7 - 7 + 1).ToString("yyyy-MM-dd 00:00:00"); case "Month": return NowTime.AddDays(-NowTime.Day + 1).ToString("yyyy-MM-dd 00:00:00"); case "Year": return NowTime.AddDays(-NowTime.DayOfYear + 1).ToString("yyyy-MM-dd 00:00:00"); default://出错啦！！！ throw new NotImplementedException(); } } /// &lt;summary&gt; /// 获取结束时间 /// &lt;/summary&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20895f4cdd194fac3e623cbbd892488f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32c5a97762b54a4ba6ba5ffabf5919e1/" rel="bookmark">
			车载软件背景（留坑）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前，车载软件已经成为汽车电子系统中不可或缺的一部分。随着汽车制造商不断增加车载软件的功能和性能，车载软件的市场规模也在不断扩大。据市场研究公司 Grand View Research 预测，到2025年，全球车载软件市场规模将达到190亿美元。
1 常见术语 概念描述作用EEA（Electrical ElectronicArchitecture）电子电气架构，是软硬件的抽象整车电子电气解决方案ECU（Electronic Control Unit）电子控制器单元，是一块独立的电路板主要是利用各种传感器、总线的数据采集与交换，来判断车辆状态以及司机的意图并通过执行器来操控汽车CAN（Controller Area Network）控制器局域网络，是一种总线协议应用在汽车计算机控制系统和嵌入式工业控制局域网的标准总线DCU（Domain Control Unit）域控制器，是一块更加强劲（相对 ECU）的电路板汽车功能域核心的平台硬件AUTOSAR（AUTomotive Open System Architecture）汽车开放系统架构，是一种系统软件规范定义了汽车系统的软件框架和接口标准AUTOSAR CP（Classic Platform）经典平台，是一种系统架构设计理念定义一个静态系统，面向信号通信AUTOSAR AP（Adaptive Platform）自适应平台，是一种系统架构设计理念定义一个动态系统，面向服务通信 2 EEA 演进 汽车电子框架演进为三个阶段：分布式（ECU）、集中式（域控制器）、中央式（硬件虚拟化+SOA），当前主流是第三个阶段，未来还会有第四个阶段 车云一体 。
2.1 分布式 1968 年电子设备首次出现在汽车中，当时大众汽车在 大众1600 轿车的发动机中安装了 电子控制单元 (ECU)，以帮助 控制燃油喷射。随着汽车智能化的发展，汽车里面 ECU 逐渐增多，汽车软件这时候的构架是 分布式 的，汽车里的各个 ECU 都是通过 CAN和LIN总线 连接在一起。 2.2 集中式 随着分布式架构的演进，车上更多的 ECU 导致成本变高，另外对系统的协调工作变得困难（满足不了智能控制的需求）。为解决这样的问题，开始逐渐将分离的 ECU 集成整合到一个电路板上，就有了 域控制器。硬件上，集中式EEA 划分到不同的功能域：控制域（动力域、底盘域、车身域）、座舱域、自动驾驶域。软件上，为规范 集中式EEA 软硬件统一， AUTOSAR 组织致力于将软件融合和接口统一规范， AUTOSAR 定义分层架构将系统分 硬件层 - 基础软件层 - 应用软件层 。 2.3 中央式 随着汽车智能化，软硬件构件越来越复杂，AUTOSAR 软件规范从 CP 到 AP；硬件上从多个板子向一个板子演进。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32c5a97762b54a4ba6ba5ffabf5919e1/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/173/">«</a>
	<span class="pagination__item pagination__item--current">174/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/175/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>