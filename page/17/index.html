<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf2fbe8232c304f21e126325c30679c1/" rel="bookmark">
			【动态规划】斐波那契数列模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到Cefler的博客😁
🕌博客主页：那个传说中的man的主页
🏠个人专栏：题目解析
🌎推荐文章：题目大解析（3）
前言
算法原理
1.状态表示
是什么？dp表(一维数组)里面的值所表示的含义
怎么来？
（1）：题目要求 （2）：经验+题目要求 (3) :分析问题的过程中，发现重复子问题
2.状态转移方程
dp[i] = ?
3.初始化
保证填表的时候不越界
4.填表顺序
为了填写当前状态的时候，所需要的状态已经计算过了
5.返回值
题目要求+状态表示
编写代码四步骤：创建dp表-&gt;初始化-&gt;填表-&gt;返回值
目录 👉🏻第 N 个泰波那契数👉🏻三步问题👉🏻使用最小花费爬楼梯解法一解法二 👉🏻解码方法 👉🏻第 N 个泰波那契数 原题链接：第 N 个泰波那契数
mycode:
class Solution { public: int tribonacci(int n) { //处理dp表可能越界情况 if(n==0)return 0; if(n==1||n==2) return 1; //1.建表 vector&lt;int&gt; v(n+1); //2.初始化 v[0] = 0,v[1] = v[2] = 1; //3.填表 for(int i = 3;i&lt;=n;i++) v[i] = v[i-3]+v[i-2]+v[i-1]; //返回值 return v[n]; } }; 空间优化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf2fbe8232c304f21e126325c30679c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a89bb7166a8300355477e6dbd7c06082/" rel="bookmark">
			数据库02_约束和范式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整性约束&amp;主键约束&amp;外键约束&amp;其他约束&amp;三范式 约束就是我们在建表过程中，给表中字段添加一些条件，在这些条件的配合下可以保证数据的唯一性，完整性，有的约束针对于整行有效，有的约束只针对某一列有效。
一、完整性约束： 列值要求（约束） 输入类型是否正确？年龄必须是数字输入的格式是否正确？身份证号码必须是18位整行要求（约束） 是否在允许的范围内？性别只能是“男”或“女”是否存在重复输入？学员信息输入了两次是否符合其他特定要求？信誉值大于5的用户才能够加入会员列表域完整性：限制数据类型，外键约束，默认值，非空约束。实体完整性约束：唯一约束，主键约束，自增列。参照完整性：主外键关联。自定义完整性：规则，存储过程，触发器。 二、主键约束 表中有一列或几列组合的值能用来唯一标识表中的每一行，这样的一列或多列的组合叫做表的主键。如：学号可以作为学生表的主键，课程号可以作为课程表的主键，（学号、课程号）作为成绩表的主键（组合键）。
主键标识的列不能为空不能重复，唯一标识。
一个表只能有一个主键，主键约束确保了表中的行是唯一的。
表中可以没有主键，但是通常情况下应当为表设置一个主键。
主键选择原则： 1、最少性：尽量选择一个键作为主键2、稳定性：尽量选择数值更新少的值作为主键3、去业务性：尽量不选择具备业务含义的列作为主键，例如：身份证，电环号码……主键的3种方式： 1、直接在字段定义后面声明主键 create table student_info ( id bigint primary key, student_name varchar(20), age tinyint, gender tinyint, telphone varchar(11), study_direction varchar(20)) engine=innodb character set = utf8mb4; 2、用constraint声明主键 #规范pk_表名 create table student_info( id bigint, studneg_name varchar(20), age tinyint, gender tinyint, telphone varchar(11), study_direction varchar(20), CONSTRAINT pk_student_info primary key (id)) engine=innodb character set = utf8mb4; #设置student_name和telphone为符合键 create table student_infoo( id bigint, student_name varchar(10), age tinyint, gender tinyint, telphone varchar(11), study_direction varchar(20), PRIMARY KEY(student_name,telphone)) engine=innodb character r set = utf8mb4; 3、用ALTER语句补充声明主键 create table student_info ( id bigint, student_name varchar(20), age tinyint, gender tinyint, telphone varchar(11), study_direction varchar(20)) engine=innodb character set = utf8mb4; #ALTER语句补充声明主键 ALTER TABLE student_info add CONSTRAINT pk_studnet_info PRIMARY KEY (id); #删除主键的方式： ALTER TABLE student_info DROP PRIMARY KEY; 三、外键约束 1、为什么要添加外键约束？ 假设学生表中学生的学号从3000到3110的，如果在成绩表中添加学号为3111的学生的成绩，那么这条数据在成绩表里面就是脏数据。同时如果学生表中某个学生退学，那么删除学生表中的学生的话，会在成绩表中产生脏数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a89bb7166a8300355477e6dbd7c06082/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e6a1fa4bbf014e8e11b5ab86ace35fe/" rel="bookmark">
			PostGIS学习教程十六：几何图形的相等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PostGIS学习教程十六：几何图形的相等 在处理几何图形时确定相等可能很困难。PostGIS支持三种不同的函数与操作符，可以用来确定不同级别的相等。为了说明这些函数和操作符，我们将使用以下多边形。
使用以下命令加载这些多边形：
CREATE TABLE polygons (id integer, name varchar, poly geometry); INSERT INTO polygons VALUES (1, 'Polygon 1', 'POLYGON((-1 1.732,1 1.732,2 0,1 -1.732, -1 -1.732,-2 0,-1 1.732))'), (2, 'Polygon 2', 'POLYGON((-1 1.732,-2 0,-1 -1.732,1 -1.732, 2 0,1 1.732,-1 1.732))'), (3, 'Polygon 3', 'POLYGON((1 -1.732,2 0,1 1.732,-1 1.732, -2 0,-1 -1.732,1 -1.732))'), (4, 'Polygon 4', 'POLYGON((-1 1.732,0 1.732, 1 1.732,1.5 0.866, 2 0,1.5 -0.866,1 -1.732,0 -1.732,-1 -1.732,-1.5 -0.866, -2 0,-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e6a1fa4bbf014e8e11b5ab86ace35fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d177a20e48b4f01dd661f7f5c65cb28f/" rel="bookmark">
			计算机毕设ssm营养美食管理网站s22t99【附源码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
vue + mybatis + Maven +mysql5.7或8.0等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 4G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目
6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末) 3.1 需求描述 根据日常实际需要，一方面需要在网站中实现基础信息的管理，同时还需要结合实际情况的需要，提供营养美食功能，方便营养美食管理工作的展开，综合考虑，本套网站应该满足如下要求：
首先，在网站中需要实现对基础信息，包括系统首页、个人中心、用户管理、商家管理、美食类型管理、美食信息管理、美食分享管理、系统管理等信息的管理，这些是网站的基础信息，和网站中其他内容密切相关。
然后，网站中需要实现对用户的管理，允许管理员对用户进行必要的设置，同时要避免管理员对个人信息进行操作，保障用户的信息安全。
3.2 网站角色需求分析 综合营养美食管理经历和对网上信息归纳整理的结果，在实际应用中，将用户分为三种：管理员、用户和商家三个角色。其中普通用户可以操作的内容是有限的，管理员可以进行的操作最多。了解网站用户的分类以及可以进行的操作，对于接下来实现相关的功能具有重要的意义。
3.3 网站功能需求分析 (1)网站的通用功能包括用户登录和密码修改，是三个角色共同需要使用的功能，用例分析如图3-1所示。
图3-1 网站通用功能用例分析图
(2)管理员可以对系统首页、个人中心、用户管理、商家管理、美食类型管理、美食信息管理、美食分享管理、系统管理等进行基本的信息管理。其用例分析如图3-2所示。
图3-2 管理员用例图
(3) 商家可以对系统首页、个人中心、美食信息管理进行操作，用例分析如图3-3所示。
图3-3商家用例图
(4) 用户进入网站可以实现对首页、商家、美食信息、美食分享、美食资讯、后台管理、个人中心进行操作，用例分析如图3-4所示。
图3-4用户用例图
3.4 非功能性需求分析 在网站的需求分析中除了保证网站功能需求分析准确完整，还应考虑与其相辅相成的各种其他因素，这样才能确保网站后续设计能够更加完善、清晰，确保网站实现后的有较高的使用价值。
3.4.1 先进性 为保证网站的先进性开发过程中应尽量使用先进的软件开发技术、设计方法、体系架构，符合当下的应用需求和保证性能可靠。
3.4.2 安全性 本网站中涉及三种用户角色，根据用户角色类型合理划分其页面访问权限。网站允许管理员对用户和商家进行必要的设置，同时要避免管理员对个人重要信息进行操作，保障用户和商家的信息安全。
3.4.3 易用性 网站使用方便、界面友好是提高用户使用体验的重要因素。网站实现其主体功能同时，界面设计要简洁大方、使用方便、美观清晰。网站的每一项反馈都要逻辑严密，弹窗信息也是简洁明了[12]。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d177a20e48b4f01dd661f7f5c65cb28f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/639e9b810ec28c4fcfd0f0b90866788e/" rel="bookmark">
			TCP协议及工作原理（三）客户端的搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ui界面的搭建 ：
QTcpServer是基于TCP的服务器类提供一种方便的方式管理和创建TCP服务器，QTcpSocket处理TCP套接字编程用于建立TCP连接，发送接收数据等功能。
参考前两篇可深入理解！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd89fb4b83485745fb24f8e0d78f56d1/" rel="bookmark">
			PostGIS学习教程十五：几何图形的有效性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PostGIS学习教程十五：几何图形的有效性 在90%的情况下，“为什么我的查询给了我一个’TopologyException’错误"的问题的答案是"一个或多个输入的几何图形是无效的”，这就引出了这样一个问题:几何图形"无效"是什么意思？我们为什么要关注它?
文章目录 PostGIS学习教程十五：几何图形的有效性一、什么是有效性？二、检测有效性三、修复无效的图形3.1、ST_MakeValid函数3.2、ST_Buffer 一、什么是有效性？ 对于多边形来说，有效性是最重要的，因为多边形定义了有界区域，需要很好的结构。线串非常简单，不会无效，点也不会无效。
多边形有效性的一些规则很明显，而另一些规则是任意的。
多边形的环必须闭合
内环必须位于外环的内部
环不能自相交（它们不能相互接触，也不能交叉）
除了在某个点接触，环不能与其他环接触
最后两条规则属于任意类别。定义多边形的其他规则也是自洽合理的，但是上面的规则是PostGIS所遵循的OGC SFSQL标准所定义的多边形有效性的规则。
规则之所以重要，是因为几何图形的计算依赖于输入的几何图形的结构。可以构建没有结构假设的算法，但这些程序往往非常慢，因为任何无结构程序的第一步都是分析输入并在其中构建结构。
这里有一个解释为什么几何图形的结构重要的例子。首先这个多边形是无效的：
POLYGON((0 0, 0 1, 2 1, 2 2, 1 2, 1 0, 0 0)); 在此图中，你可以更清楚地看到无效的原因：
这个多边形的外环实际上是一个数字8的形状，中间有一个自交点（也就是这个多边形的环自相交了）。图形程序成功地渲染了多边形填充，使其在视觉上看起来是一个"区域"：两个一个单位的正方形，因此多边形总面积为两个单位的面积。
让我们看看PostGIS数据库认为多边形的面积是多少：
SELECT ST_Area(ST_GeometryFromText( 'POLYGON((0 0, 0 1, 1 1, 2 1, 2 2, 1 2, 1 1, 1 0, 0 0))' )); 这里发生了什么？计算面积的算法假设环不自相交。程序始终计算位于边界线的一侧的区域的面积。
然而，在我们的（表现不佳）的形似数字8的多边形中，对于其中一个部分，图形区域位于边界线的右侧，而对于另一个部分，图形区域在边界线的左侧。这将导致为每个部分计算的面积互相抵消（一个为1，另一个为-1），因此结果为"0面积"。
二、检测有效性 在前面的示例中，我们可以轻易发现一个多边形是无效的。然而我们如何在一个包含数百万个几何图形的表中检测无效？答案是使用ST_IsValid(geometry)函数：
SELECT ST_IsValid(ST_GeometryFromText( 'POLYGON((0 0, 0 1, 1 1, 2 1, 2 2, 1 2, 1 1, 1 0, 0 0))' )); 现在我们知道这个图形是无效的，但是我们不知道为什么无效。我们可以使用ST_IsValidReason(geometry)函数来查找无效的原因：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd89fb4b83485745fb24f8e0d78f56d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8495de802591592af7378a70e05a7316/" rel="bookmark">
			微信小程序的bindtap和catchtap的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 事件 1.事件是视图层到逻辑层的通讯方式。
2. 事件可以将用户的行为反馈到逻辑层进行处理。
3. 事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。
二. 如何使用事件 1. 简单来说就是将事件绑定到组件上面，bindtap和catchtap都属于点击事件，绑定了之后点击组件可以触发这个函数。
2. 函数tapName会接受一个参数event，event里面存储了一些函数调用的上下文信息
3. 标签元素
4.绑定事件
三. bindtap和catchtap的区别 1. 相同点：首先他们都是作为点击事件函数，就是点击时触发。在这个作用上他们是一样的，可以不做区分。
2. 不同点：他们的不同点主要是bindtap是冒泡的，catchtap是非冒泡的。
四. 小程序中事件分为冒泡事件和非冒泡事件。 (1) 本文以冒泡事件tap（手指触摸后马上离开，也就是点击事件）为例子来区别bind和catch事件
(2) bindtap: 事件绑定不会阻止冒泡事件向上冒泡
(3) catchtap: 事件绑定可以阻止冒泡事件向上冒泡
原创作者：吴小糖
创作时间：2023.12.26
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51544f0411b98d4f5c2fa3cc1e9b00e8/" rel="bookmark">
			【2024考研】心情记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天是12.26日。距离24考研已经过去了2天，自认为缓过来了，故写下这篇文章。
25日早上简单过了一下答案，但实在是记不住答案了，不知道是我的脑子抵触还是怎的，像一块灰色的布遮住了我的记忆，羞于打开，记得不太清楚，估分状况如下：政治60、英语70、数学70（可能还不够）、专业课110。总分：310。离我的目标院校十万百千里，也我和我的目标分数也相差很多。所以经过了两天心里建设，在这个寒假之中，打算准备专业课的同时（抓住万分之一的进复试的机会，我不想到时候我会后悔，我真的很怕做后悔的事情）准备明年的春招项目。大概率是直接工作了。
01 有没有想过二战呢？ 在考研初期的时候真的没有想过，但是在临近考试的那一两周，特别是背肖四的那一两周，“新思想”、“两个结合”、“高质量发展”很多很多“高大上”、“又红又专”的名词在向我的脑海中涌入的时候，在我不得不一遍遍毫无感情地朗诵的时候，我就觉得二战可能不适合我。考完这几天，每当我想到如果再来一年，我会是何种抗拒，何种万般无奈，万般不愿，内心就很难翻起像今年考研的那种热血澎湃。这一年，不知道什么事休息，仿佛休息都是犯罪，仿佛就一定要虐待自己你就不快乐一样，为什么不能尝试和自己和解呢？为什么不能尝试多正向鼓励鼓励自己呢？仿佛就像弦上的箭，蓄势待发，但是弦已经要被崩坏了，这只箭又怎会正中靶心呢？仿佛我给自己增加了很多无形又很牢固的囚笼，仿佛你考不上别人都会怪你似的，仿佛你就一定要考上似的？你以为以你的成绩你就该考上的，就连你自己是这么以为的，你以为自己很优秀，但当往外看的时候，看到了更高的山，更远的海，那看不到顶的山让你绝望，那一望无际的海让你窒息。那又能怎么样呢？你还是你……山还是山，海还是海……
02 这一年你后悔吗？ 不后悔，就像上面说的，尊重自己的每一个决定，不后悔，也从不会美化那一条自己从来没选择的道路。我认为如果我再来一年我还是会这样，这样学习，这样思考。（或许是我的学习和思维方式不对，在之后的学习中也会优化，看看怎么让自己有效率一些，但我认为不再会是考研了）。
03 尝试与自己和解？ 我是个很少为自己找借口的人，在我看来，什么事情都是结果最重要，是个只看结果的人，很现实，极端到我甚至会下意识否定这一路的努力、风景。不知何时，我变成了一个唯结果论的人，在我看来loser的发言，都是外在的借口。总是这样认为。所以当我失败的时候，我总是会归结为自己的能力不行（但事实就是这样，甚至到现在我还是这么认为），我不会像外人解释什么，我觉得很丢脸，失败就是失败了，为自己找借口不会更丢脸吗？所以一直以来我都是这么看自己的失败的：失败-&gt;PUA自己-&gt;很失落-&gt;负向反馈-&gt;失败。当每次面对这种世俗上所谓的失败的时候，我总觉得，哇，天要塌下来了，我就是个loser，原来我真的什么也做不成啊，哈！看吧，你就是能力不行，承认你的普通吧，就你？还想上研究生？就你？…
在一次又一次地否定自己中，我就真的被自己洗脑了。不能从心底认同自己，说到底就是不能接受自己的失败，不能客观地看待自己，不能理性分析，一股脑的全归结为自己的能力不足，陷入无限地自我内耗的无聊价值当中。问题呢？仍然存在。客观事实地存在，并没有改变。既然问题已经发生，为什么不能打从心底里认同自己，从心底里爱自己，认可自己呢？在你的世界里承认自己很优秀真的很困难吗？毕竟在你的世界里只有你一个人呐哈哈。最近听到一句话：人这一生只会和三种人打交道：第一种是人和人、第二种是人和世界、第三种是人和自己，你这一生，陪伴你最长时间的就是自己。那么为何你不能好好对待这个矢志不渝的“伴侣”呢？我只希望在三十岁的时候，你回看自己的二十岁，能笑笑说：哈哈我那时候真幼稚。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54a9c44e454b1dab0ca8caa78d3359f7/" rel="bookmark">
			20231226在Firefly的AIO-3399J开发板上在Android11下调通后摄像头ov13850
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		20231226在Firefly的AIO-3399J开发板上在Android11下调通后摄像头ov13850
2023/12/26 8:22
开发板：Firefly的AIO-3399J【RK3399】
SDK：rk3399-android-11-r20211216.tar.xz【Android11】
Android11.0.tar.bz2.aa【ToyBrick】
Android11.0.tar.bz2.ab
Android11.0.tar.bz2.ac
https://wiki.t-firefly.com/AIO-3399J/prepare_compile_android.html
AIO-3399J产品规格书 立即购买
AIO-3399J 采用 RK3399 六核(A72x2+A53x4) 64 位处理器，主频高达1.8GHz，集成了四核 Mali-T860 GPU，性能优异。
前情提要：由于使用Firefly的AIO-3399J开发板的Android10的SDK，kernel编译使用Firefly的AIO-3399J的，lunch之后的Android使用Rockchip官方的编译模式，也能打开前后摄像头ov13850。
可能的原因，Firefly只针对kernel中的（config）DTS和ov13850的驱动程序动过手术。可能Android10还是比较原始的！
【或者没有修改Android系统中的camera部分！】
（一）、kernel部分的修改：
1、firefly_defconfig
Z:\AIO-3399J\rk3399_Android10.0\rk3399_Android10.0\kernel\arch\arm64\configs\firefly_defconfig
Z:\rk3399-android-11\kernel\arch\arm64\configs\firefly_defconfig
2、拷贝Firefly的AIO-3399J开发板的Android10的SDK中的Firefly的DTS文件：
Z:\AIO-3399J\rk3399_Android10.0\rk3399_Android10.0\kernel\arch\arm64\boot\dts\rockchip
Z:\rk3399_Android10.0\kernel\arch\arm64\boot\dts\rockchip\
Z:\rk3399_Android10.0\kernel\arch\arm64\boot\dts\rockchip\Makefile
Z:\rk3399_Android10.0\kernel\arch\arm64\boot\dts\rockchip\rk3399-android.dtsi
Z:\rk3399_Android10.0\kernel\arch\arm64\boot\dts\rockchip\rk3399-dram-default-timing.dtsi
Z:\rk3399_Android10.0\kernel\arch\arm64\boot\dts\rockchip\rk3399-firefly-aio.dts
Z:\rk3399_Android10.0\kernel\arch\arm64\boot\dts\rockchip\rk3399-firefly-aio.dtsi
Z:\rk3399_Android10.0\kernel\arch\arm64\boot\dts\rockchip\rk3399-firefly-core.dtsi
Z:\rk3399_Android10.0\kernel\arch\arm64\boot\dts\rockchip\rk3399-firefly-demo.dtsi
Z:\rk3399_Android10.0\kernel\arch\arm64\boot\dts\rockchip\rk3399-firefly-port.dtsi
Z:\rk3399_Android10.0\kernel\arch\arm64\boot\dts\rockchip\rk3399-opp.dtsi
Z:\rk3399_Android10.0\kernel\arch\arm64\boot\dts\rockchip\rk3399-sched-energy.dtsi
Z:\rk3399_Android10.0\kernel\arch\arm64\boot\dts\rockchip\rk3399-vop-clk-set.dtsi
Z:\rk3399_Android10.0\kernel\arch\arm64\boot\dts\rockchip\rk3399.dtsi
3、解决DTS编译不过的问题！
Z:\AIO-3399J\rk3399_Android10.0\rk3399_Android10.0\kernel\arch\arm64\boot\dts\rockchip-firefly\rk3399-firefly-core.dtsi
Z:\rk3399-android-11\kernel\arch\arm64\boot\dts\rockchip\rk3399-firefly-core.dtsi
&amp;i2s1 {
status = "okay";
rockchip,i2s-broken-burst-len;
rockchip,playback-channels = &lt;2&gt;;
rockchip,capture-channels = &lt;2&gt;;
#sound-dai-cells = &lt;0&gt;;
assigned-clocks = &lt;&amp;cru SCLK_I2S1_DIV&gt;, &lt;&amp;cru SCLK_I2S_8CH&gt;; //SCLK_CIF_OUT_SRC
assigned-clock-parents = &lt;&amp;cru PLL_GPLL&gt;, &lt;&amp;cru SCLK_I2S1_8CH&gt;;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54a9c44e454b1dab0ca8caa78d3359f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8e2811d61c4e68eb493170abb980e27/" rel="bookmark">
			LeetCode206反转链表(java实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天带来的题目解析是leetcode206，反转链表，我们来看下题目描述
如何实现链表的反转呢？我在这里提供的思路是双指针的思路。
具体的思路如下：
假设我们的原链表如下
首先定义一个指针pre，用于指向head之前的位置，那么我们初始可以将它置为NULL因为链表反转之后第一个节点的next就是null。
也就是如下图所示。
我们首先定义cur用于指向head，我们要进行反转链表首先，要先将cur.next的位置用临时节点进行保存，也就是上图的temp，然后是将cur.next赋值给pre节点，然后将pre和cur后移，继续遍历链表。
这里需要注意的是，也就是pre和cur后移时
这两行代码的位置是先将pre=cur，然后是将cur=temp；假如交换这两行代码的位置就会导致后续pre=cur时赋值的是错误的cur位置。
最后将pre进行返回即可。
具体的代码如下
class Solution { public ListNode reverseList(ListNode head) { ListNode cur = head; //pre指针一直在cur前面 ListNode pre = null; //定义临时节点主要是存放cur.next节点。 ListNode temp=null; while (cur!=null){ //用临时节点存放cur.next temp=cur.next; //将cur的next指向pre cur.next=pre; //移动pre和cur位置 pre=cur; cur=temp; } return pre; } } 那么本次题目解析就到这里结束了，希望对你有帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2b98a056fc50fc7141cd76f3a0c2d2c/" rel="bookmark">
			python作业题百度网盘,python作业答案怎么查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，小编来为大家解答以下问题，python作业题百度网盘，python作业答案怎么查，今天让我们一起来看看吧！
1 以下代码的输出结果为：
alist = [1, 2, 3, 4]
print(alist.reverse())
print(alist)
A.[4, 3, 2, 1] [1, 2, 3, 4] B.None [-1,-2, -3, -4] C.[4, 3, 2, 1] [4, 3, 2, 1] D. None [4, 3, 2, 1]
2 以下代码的输出结果为：
alist = [[] for i in range(3)]
alist[0].append(1)
print(alist)
A.[[1], [], []] B.[[1], [1], [1]]
C.[[], [], [],1] D. 报错
3 以下代码的输出结果为：
print(bool([]))
print(bool(‘0’))
A.True True B.True False
C.False True D.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2b98a056fc50fc7141cd76f3a0c2d2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b7b935eb800f0b198855c6d8bdf349a/" rel="bookmark">
			Request对象和Response对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Request对象 1.1概念 客户端发送请求，而请求是以HTTP请求数据格式进行发送，因而Servlet就创建了一个Request类来封装这些接收数据
1.2常用方法 getRequestURL() //获取的完整的URL，即统一资源定位符 getRequestURI() //获取资源的名字，即统一资源标识符 getQueryString() //获取一个url参数部分 getRemoteAddr() //返回的是客户端的ip地址 getRemoteUser() //返回的是客户端的用户 getRemotePort() //返回的是客户端的主机的端口号 getRemoteHost() //返回的是客户端的主机地址 getCookie() //获取Cookie对象 getSession() //获取Session对象 getLocalName() //获取Web服务器主机的名字 getServletContext() //获取上下文对象的 setCharacterEncoding() //设置编码集的 getParameter() //获取前端传过来的数据 setAttribute() //将数据设置给request对象 geAttribute() //获取request对象中的数据 1.3实例 package com.by.servlet; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class RequestServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws Exception { doGet(request, response); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws Exception{ //获取一个完整的url //http://localhost:8080/01_servlet_HelloWorld_war/request1 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b7b935eb800f0b198855c6d8bdf349a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76eb805d9719fcb1373547132373f84c/" rel="bookmark">
			Linux - 记录问题：Ubuntu查看文件夹大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Ubuntu中，你可以使用du命令来查看文件夹的大小。du命令的全称是"disk usage"，用于估计和显示目录或文件的磁盘使用空间。
如果你想查看某个特定文件夹的大小，你可以使用以下命令：
du -sh /path/to/directory 在这个命令中，-s选项表示"summary"，它将只给出总计的大小，而不是每个子目录的大小。-h选项表示"human-readable"，它将以易于阅读的格式（例如KB，MB，GB）显示大小。
例如，如果你想查看名为"Documents"的文件夹的大小，你可以运行：
du -sh ~/Documents 这将显示"Documents"文件夹的总大小。
以下是du命令的一些常见用法和选项：
du：在没有任何参数的情况下运行du命令，将显示当前目录中所有文件和子目录的大小（以KB为单位）。
du /path/to/directory：显示指定目录中所有文件和子目录的大小。
du -a /path/to/directory：-a选项表示"all"，它将显示指定目录中所有文件和子目录的大小。
du -h /path/to/directory：-h选项表示"human-readable"，它将以易于阅读的格式（例如KB，MB，GB）显示大小。
du -s /path/to/directory：-s选项表示"summary"，它将只给出总计的大小，而不是每个子目录的大小。
du -sh /path/to/directory：这个命令结合了-s和-h选项，它将以易于阅读的格式显示指定目录的总大小。
du -c /path/to/directory：-c选项表示"total"，它将显示指定目录的总大小，以及所有单独文件和子目录的大小。
du --max-depth=1 /path/to/directory：--max-depth选项可以用来指定du命令应该深入目录结构的程度。例如，--max-depth=1将只显示直接在指定目录下的文件和子目录的大小。
du -d 1 /path/to/directory：-d选项是--max-depth的简写形式。
这些是du命令的一些基本用法，但是请注意，不同的系统可能会有一些差异，你可以通过运行man du或du --help来查看你的系统中du命令的具体用法和选项。
分享一个有趣的 学习链接：https://xxetb.xet.tech/s/HY8za
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cced88e8c5e3dc155a50fd4072735ee/" rel="bookmark">
			Go和Java实现工厂方法模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go和Java实现工厂方法模式 本文通过计算器案例来说明工厂方法模式的使用，使用Go语言和Java语言实现。
1、工厂方法模式 工厂方法模式是最常用的设计模式之一，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方
式。
在工厂方法模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建
的对象。
意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂方法模式使其创建过程延迟到
子类进行。
主要解决：主要解决接口选择的问题。
何时使用：我们明确地计划不同条件下创建不同实例时。
如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。
关键代码：创建过程在其子类执行。
应用实例：1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个
汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。
优点：1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只
要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。
缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定
程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。
使用场景：1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到
什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计
一个连接服务器的框架，需要三个协议，“POP3”、“IMAP”、“HTTP”，可以把这三个作为产品类，共同实现一
个接口。
注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注
意的地方就是复杂对象适合使用工厂方法模式，而简单对象，特别是只需要通过 new 就可以完成创建的对
象，无需使用工厂方法模式。如果使用工厂方法模式，就需要引入一个工厂类，会增加系统的复杂度。
适用性：1、当一个类不知道它所必须创建的对象的类的时候。2、当一个类希望由它的子类来指定它所创建
的对象的时候。3、当类将创建对象的职责委托给多个帮助子类中的某一个，并且类希望将哪一个帮助子类是
代理者这一信息局部化的时候。
简单说工厂方法模式就是为了提供代码结构的扩展性，屏蔽每⼀个功能类中的具体实现逻辑，让外部可以更加简单
的只是知道调⽤即可，同时这也是去掉众多 ifelse 的⽅式。
2、Go实现简单计算器 下面实现一个简单的计算器，包含简单的加减乘除功能。
package factory // 这里实现一个简单的计算器 // 计算接口,包含计算数的设置和结果的计算 type Operation interface { // 设置进行计算的两个数 SetNumberA(float64) SetNumberB(float64) // 计算 Calculate() (float64, error) } package factory // ============加法=========== type AddOperation struct { // 包含两个操作数 numberA float64 numberB float64 } func (addOperation *AddOperation) Calculate() (float64, error) { return addOperation.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cced88e8c5e3dc155a50fd4072735ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2f52bc6dac3b2e648a0c4059b18444f/" rel="bookmark">
			nat地址转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理 将内网地址转换成外网地址 方式 掌握动态NAT的配置方法
掌握Easy IP的配置方法
掌握NAT Server的配置方法
实验 r1 r2 是内网 ar1 ip地址 ip add ip地址 掩码 ip route-static 0.0.0.0 0 192.168.1.254 默认网关 吓一跳网关 相等于设置了网关 ar2
ip地址
254 就是r1的网关 ip地址 ip rpute-static 0.0.0.0 0 1.2.3.254 （网关 ）
ar3 ip地址 第二步骤 开启远程 r1 和r3 user-interface vty 0 4 用户5个可以同时登录 authentication-mode aaa q
aaa
local-user ccy password cipher ccy 设置账户和密码 local-user ccy service-type telnet 设置服务类型 local-user ccy privilege level 15 服务级别15
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2f52bc6dac3b2e648a0c4059b18444f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3032c46a6f2d547da052eba98f3e2c5d/" rel="bookmark">
			Debian Linux完全卸载gitlab-ce
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Debian Linux完全卸载gitlab-ce 在Debian上本地安装了gitlab-ce，维护起来比较麻烦，而且占用了80和443端口
后面想改用docker，就想完全卸载gitlab-ce
卸载服务
sudo gitlab-ctl uninstall 清理所有产生的数据，会提示等待60秒，如果想反悔，可以按Ctrl+C
sudo gitlab-ctl cleanse 需要等待60秒
******************************************************************* * * * * * * * * * * * STOP AND READ * * * * * * * * * * ******************************************************************* This command will delete *all* local configuration, log, and variable data associated with gitlab. You have 60 seconds to hit CTRL-C before configuration, logs, and local data for this application are permanently deleted.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3032c46a6f2d547da052eba98f3e2c5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/677968abd4bab5409957d1961cdb94a5/" rel="bookmark">
			web渗透安全学习笔记：1、入门基础知识/ XXS漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 自编写python渗透工具编写学习笔记专栏以来，笔者便发现了一个较为严重的问题：我们大多数文章都是学习如何用python编写扫描与利用漏洞的渗透工具，却没有真正解析漏洞的形成原因，长此以往我们的学习就只会浮于表面，广而不深。为了改变这一现状，笔者决定以深入学习漏洞为主，编写漏洞渗透工具为辅（当然不意味着两专栏更新频率不均），新开了web渗透安全学习笔记专栏。那么，就让我们开始今天的学习吧！
坚持科技向善，勿跨越法律界限，代码仅供教学目的。初出茅庐，如有错误望各位不吝赐教。
点此前往python渗透工具编写学习笔记专栏：python渗透工具编写学习笔记 1.1 web的组成 Web的组成主要包括以下几个要素：
网络基础设施：包括各种网络设备，如服务器、路由器、交换机等，用于连接和传输数据。
互联网协议（Internet Protocol, IP）：是互联网数据传输的基本协议，负责将数据分割成数据包并传输给指定的目标地址。
域名系统（Domain Name System, DNS）：用于将易于记忆的域名转换为对应的IP地址，方便用户访问网站。
HTTP协议（HyperText Transfer Protocol）：是Web中用于传输超文本（如HTML、CSS、JS等）的协议，它定义了客户端和服务器之间的通信规则。
CSP（Web Content Security Policy）：是一种基于HTTP头部的安全策略，用于保护网站免受恶意代码的攻击。它允许网站管理员定义哪些外部资源可以被加载，并限制内联脚本、内联样式和其他不安全的操作。
万维网（World Wide Web）：是一个基于HTTP协议的信息系统，包括了各种网页、网站和资源。
编写web的语言主要是一下三种： HTML（HyperText Markup Language）：是用于创建Web页面的标记语言，是Web的基础。
CSS（Cascading Style Sheets）：是用于控制网页样式的语言，可以定义网页的布局、字体、颜色等外观。
JavaScript：是一种用于增强网页交互性的脚本语言，可以操作网页元素、响应用户操作等。
C/S架构（Client/Server）：是指客户端和服务器之间的架构模式。在C/S架构中，客户端负责处理用户界面和用户交互，而服务器负责处理数据存储和业务逻辑。客户端通过网络连接到服务器，发送请求并接收响应。这种架构模式通常用于需要高性能和复杂业务逻辑的应用程序，例如在线游戏和大型企业应用。
B/S架构（Browser/Server Architecture）：是指浏览器和服务器之间的架构模式。在B/S架构中，浏览器作为客户端，负责处理用户界面和用户交互，而服务器负责处理数据存储和业务逻辑。用户通过浏览器访问网页，浏览器发送请求到服务器并接收响应。这种架构模式通常用于Web应用程序，例如网上购物和社交媒体
1.2 同源策略 同源策略是一种Web浏览器安全机制，它的目的是防止恶意网站通过脚本等方式访问用户的敏感信息或者执行恶意操作。同源策略允许同一个域名下的不同网页、文件或数据之间进行相互交互。要透彻的学习同源策略，我们先来学习源是什么：
源（origin）：是一个由协议（如HTTP、HTTPS）、域名和端口号组成的标识。源被用于确定一个文档或脚本来自哪个源，以及允许哪些源访问特定资源的规则。同源策略通过限制不同源之间的交互来增加Web应用程序的安全性，防止恶意代码对不同源的资源进行访问和操作。
Web 内容的源由用于访问它的 URL 的方案（协议）、主机名（域名）和端口定义。只有当协议、主机和端口都匹配时，两个对象才具有相同的源。示例如下：
服务器默认从 80 端口传送 HTTP 内容，所以以下两个地址同源：
http://Eleven.com:80http://eleven.com 协议不同，以下两个地址不属于同源：
http://eleven.com/sp1https://eleven.com/sp2 主机名不同，以下几个地址不属于同源：
http://eleven.comhttp://www.eleven.comhttp://myapp.eleven.com 端口不同，以下几个地址不属于同源： http://eleven.comhttp://eleven.com:70 例如，当你在一个网页中使用JavaScript代码发送AJAX请求时，同源策略会阻止该请求访问不同域的资源。这意味着，如果你的网页代码来自于一个域名，那么它只能与来自同一域名的资源进行交互，而不能与其他域名的资源进行交互。 域:是指在计算机网络中，一组具有相同属性的计算机或设备的集合。域可以根据网络规模的不同，分为局域网（LAN）、城域网（MAN）和广域网（WAN）。
域名:是指通过域名系统（DNS）来进行解析的由一串字符组成的名称，用于标识并定位互联网上的计算机、服务或资源。域名一般由若干部分组成，如www.example.com，其中www为子域名，example为二级域名，com为顶级域名。域名可以转化为对应的IP地址，从而实现网络上的通信与访问。
资源：可以包括文字、图片、视频、音频文件等等。
1.3 浏览器沙箱 浏览器沙箱是一种安全机制，用于隔离浏览器中运行的不可信任代码（例如JavaScript代码）与操作系统和主机系统的其他部分。它创建了一个受控的环境，在其中运行代码，以确保代码无法直接访问或修改操作系统或主机系统中的敏感资源。
浏览器沙箱通过限制不可信任代码的权限和访问范围来保护用户的设备和数据安全。它通常使用以下技术和措施来实现：
进程隔离：浏览器将不同的标签页或网站运行在不同的进程中，以确保它们之间的代码和数据互相隔离。这样一来，一个恶意的网站或插件无法直接访问或修改其他网站或标签页中的数据。
沙盒环境：浏览器为每个标签页或网站创建一个沙盒环境，在其中运行不可信任的代码。沙盒环境限制了代码的权限，例如禁止访问文件系统、网络以及操作系统级的功能。
内存保护：浏览器使用内存保护技术来防止代码通过缓冲区溢出等漏洞来攻击系统。这些技术包括地址空间布局随机化（ASLR）和数据执行保护（DEP）。
权限管理：浏览器沙箱使用权限管理机制，允许用户控制哪些资源可以被访问。例如，浏览器会提示用户是否允许某个网站获取地理位置或访问摄像头。
1.4 初识XXS漏洞 XXS漏洞（Cross-Site Scripting vulnerability）允许攻击者在网页上注入恶意脚本代码，从而获取用户的敏感信息或者对用户进行恶意操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/677968abd4bab5409957d1961cdb94a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d834d7ebcb25e0bd021286561f29c93/" rel="bookmark">
			ServletConfig和ServletContext对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.ServletConfig对象
1.1ServletConfig对象是什么
1.2ServletConfig对象里的方法 1.3ServletConfig的配置方式
1.4ServletConfig实现步骤
2. ServletContext对象
2.1ServletContext对象是什么
2.2ServletContext对象里的方法
2.3ServletContext对象的配置方式
2.4ServletContext对象的实现步骤
3.ServletConfig和ServletContext对象的区别
1.ServletConfig对象 1.1ServletConfig对象是什么 ServletContext是javax.servlet包下的一个接口，又称上下文对象，是配置对象也是一个域对象；
当服务器启动时，会为服务器中的每一个web应用程序创建一个ServletContext对象；
在web应用中的servlet要想实现资源的共享，可以通过ServletContext来完成；
1.2ServletConfig对象里的方法 getInitParameter() //获取指定参数名称的全局参数值 getRealPath(String path) //获得当前项目的服务器磁盘路径 getContextPath() //获取项目的根路径 getAttribute(String parameterName) //获取ServletContext域中指定名称的参数值； setAttribute(String paramterName,Object parameterValue) //存储参数到ServletContext域中； removeAttribute(String parameterNam) //将ServletContext域中指定名称的参数移除； 1.3ServletConfig的配置方式 在&lt;servlet&gt;标签种，通过&lt;init-param&gt;标签来配置。有两个子标签：
1. &lt;param-name&gt;：代表初始化参数的key。
2. &lt;param-value&gt;: 代表初始化参数的value。
&lt;context-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;root&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;root456&lt;/param-value&gt; &lt;/context-param&gt; 1.4ServletConfig实现步骤 定义一个类，继承HttpServlet。重写doGet()和doPost()方法。在web.xml进行配置。在请求方法中通过请求对象获取到ServletConfig对象。然后再通过getInitParameter()方法获取到配置的初始化参数。部署并启动项目。通过浏览器测试。 代码实现：
package com.by.servlet; import javax.servlet.*; import javax.servlet.http.HttpServlet; public class ServletConfigServlet extends HttpServlet { @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException { //1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d834d7ebcb25e0bd021286561f29c93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53e1d1e148d8d27083b10de9124510c5/" rel="bookmark">
			CNVD原创漏洞审核和处理流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、CNVD原创漏洞审核归档和发布主流程 （一）审核和归档流程 审核流程分为一级、二级、三级审核，其中一级审核主要对提交的漏洞信息完整性进行审核，漏洞符合可验证（通用型漏洞有验证代码信息或多个互联网实例、事件型漏洞有验证过程和相关截图）、描述准确（不存在虚假信息）即可通过一级审核；二级审核为CNVD对漏洞的信息整理，对于漏洞标题以及描述情况进行初步核对整理；三级审核为CNVD对漏洞进行有效性和原创性核验的环节，有效性核验即复现漏洞相关情况或在不具备复现环境的情况下转交对口厂商复现，原创性核验则是CNVD根据已收录漏洞信息及互联网已公开漏洞信息进行查重比对。
通过上述三级审核之后，确认漏洞存在且认定具备原创性则进行CNVD归档。在归档环节，CNVD秘书处主要进行漏洞的中文规范化收录整理以及对漏洞危害进行评价（CNVD采用CVSS2.0评价标准）。
时限要求：对于事件型漏洞，到归档时间一般不超过2个工作日。对于通用软硬件漏洞，到归档时间一般不超过5个工作日。对于一些无法具备复现条件需要由厂商确认的，以厂商反馈时间为准，在厂商未反馈或拒绝反馈之前，CNVD秘书处也将自行开展评估工作，加快归档流程。
（二）发布流程 目前，CNVD暂不发布事件型漏洞信息，仅通过CNVD网站首页“绵羊墙”功能对已经完成通报处置流程的涉事单位系统或软硬件产品进行公示。对于通用软硬件漏洞，CNVD遵循处置后发布原则（与厂商补丁发布时间同步）或未反馈情况下默认45天后发布描述信息（暂不公开利用代码信息）。另外，根据CNVD参与签署的《中国互联网协会漏洞信息披露和处置自律公约》，对于需要较长周期的漏洞处置工作，涉事厂商可与CNVD秘书处协商漏洞发布时间。
二、CNVD原创漏洞验证和处置支线流程 （一）事件型漏洞验证和处置流程 CNVD以可复现为基准，同时在复现过程中恪守国家法律和有关部门规定，不执行可能对信息系统机密性、可用性、完整性造成破坏性的验证操作。CNVD依托国家上级信息安全协调机构、CNCERT国家中心、CNCERT各分中心的处置协作渠道，积极协调通报涉及党政机关、重要行业单位以及企事业单位的漏洞风险。
时限要求：事件型漏洞验证不超过1个工作日，通报到涉事单位时间不超过3个工作日。
（二）通用软硬件漏洞验证和处置流程 对于通用软硬件漏洞的验证和处置CNVD主要根据《中国互联网协会漏洞信息披露和处置自律公约》规定的厂商以及漏洞应急组织相关责任和义务，强调厂商的主动响应以及漏洞库组织（CNVD）的技术协助。CNVD对通用漏洞进行核验后将直接通过已有联系渠道或公开联系渠道向产品厂商通报，并要求其在5个工作日内反馈是否有补丁（含临时解决方案）或是否已经着手应急处置事项。
对于有可能造成大规模攻击威胁（如：涉及大量党政机关和重要行业单位用户），CNVD要求厂商采取主动响应原则，依托技术手段和市场渠道主动完成用户的防护工作。同时，CNVD也可协助厂商开展全网安全评估和全局应急响应,提供受影响用户列表相关情况。必要时，CNVD将组织专项行动进行漏洞的全网处置。
时限要求：通用型漏洞验证取决于复现条件，通报到厂商时间不超过5个工作日。对于处置周期，视处置难度和修复情况而定。
三、CNVD原创漏洞证书和奖金积分支线流程 对于通过CNVD归档的原创漏洞，CNVD将对漏洞进行原创漏洞奖金积分评分。积分评定具体参见《CNVD原创漏洞积分评分细则》。
时限要求：在漏洞归档后1个工作日内。
对于中危及中危以上通用型漏洞（CVSS 2.0基准评分超过4.0分），以及涉及党政机关、重要行业单位、科研院所、重要企事业单位（如：中央国有大型企业、部委直属事业单位等）的高危事件型漏洞(后续对事件型漏洞证明颁发标准将参考中央网信办颁布的关键基础设施相关定义和分类)，CNVD将给予原创漏洞证明（即CNVD漏洞证书，电子版），该证明可通过编号在CNVD官方网站进行查询跟踪。
时限要求：按周对上一周归档漏洞且满足证书颁发条件的进行批量制作。
CNVD公告地址： https://www.cnvd.org.cn/webinfo/show/3933 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/936d1ace9adc2f604e9f69a0d456f75d/" rel="bookmark">
			arm day7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开关中断控制
main.c
#include "key_it.h" #include "uart.h" void delay(int ms) { int i,j; for(i=0;i&lt;ms;i++) { for(j=0;j&lt;2000;j++); } } int main() { key2_it_config(); key1_it_config(); key3_it_config(); all_led_init(); char buf[128]; gets(buf); while (1) { puts(buf); delay(1000); } } // 最终现象：键盘输入a,串口工具显示b key_it.c
#include "key_it.h" void key1_it_config() { //使能GPIOF时钟 RCC-&gt;MP_AHB4ENSETR |= (0x1&lt;&lt;5); //设置PF9管脚为输入 GPIOF-&gt;MODER &amp;= (~(0x3&lt;&lt;18)); //设置PF9作为EXTI9事件的输入 EXTI-&gt;EXTICR3 &amp;= (~(0x1f&lt;&lt;8)); EXTI-&gt;EXTICR3 |= (0x05&lt;&lt;8); //设置下降沿使能检测EXTI9事件 EXTI-&gt;FTSR1 |= (0x1&lt;&lt;9); //设置EXTI9事件不屏蔽 EXTI-&gt;C1IMR1 |= (0x1&lt;&lt;9); //GICD使能EXTI9（99号）中断 GICD-&gt;ISENABLER[3] |= (0x1&lt;&lt;3); //GICD 设置99号中断的优先级 GICD-&gt;IPRIORITYR[24] &amp;= (~(0x1f&lt;&lt;27)); //选择CPU0处理当前中断 GICD-&gt;ITARGETSR[24] |= (0x1&lt;&lt;24); //全局使能组0中断被转发到GICC GICD-&gt;CTRL |= (0X1); //设置中断的优先级掩码 GICC-&gt;PMR |= (0x1f&lt;&lt;3); //允许组0中断被CPU处理 GICC-&gt;CTRL |= (0x1); } void key3_it_config() { //使能GPIOF时钟 RCC-&gt;MP_AHB4ENSETR |= (0x1&lt;&lt;5); //设置PF8管脚为输入 GPIOF-&gt;MODER &amp;= (~(0x3&lt;&lt;16)); //设置PF8作为EXTI8事件的输入 EXTI-&gt;EXTICR3 &amp;= (~(0xff&lt;&lt;0)); EXTI-&gt;EXTICR3 |= (0x05&lt;&lt;0); //设置下降沿使能检测EXTI8事件 EXTI-&gt;FTSR1 |= (0x1&lt;&lt;8); //设置EXTI8事件不屏蔽 EXTI-&gt;C1IMR1 |= (0x1&lt;&lt;8); //------------------------------------------------- //GICD使能EXTI8（98号）中断 GICD-&gt;ISENABLER[3] |= (0x1&lt;&lt;2); //GICD 设置98号中断的优先级 GICD-&gt;IPRIORITYR[24] &amp;= (~(0x1f&lt;&lt;19)); //选择CPU0处理当前中断 GICD-&gt;ITARGETSR[24] |= (0x1&lt;&lt;16); //全局使能组0中断被转发到GICC GICD-&gt;CTRL |= (0X1); //设置中断的优先级掩码 GICC-&gt;PMR |= (0x1f&lt;&lt;3); //允许组0中断被CPU处理 GICC-&gt;CTRL |= (0x1); } void key2_it_config() { //使能GPIOF时钟 RCC-&gt;MP_AHB4ENSETR |= (0x1&lt;&lt;5); //设置PF7输入模式 GPIOF-&gt;MODER &amp;=(~(0x3&lt;&lt;14)); //设置PF7作为EXTI7事件输入 EXTI-&gt;EXTICR2 &amp;=(~(0xff&lt;&lt;24)); EXTI-&gt;EXTICR2 |=(0x5&lt;&lt;24); //设置下降沿检测 EXTI-&gt;FTSR1 |=(0x1&lt;&lt;7); //设置EXTI7事件不屏蔽 EXTI-&gt;C1IMR1 |=(0x1&lt;&lt;7); //使能GICD中断 GICD-&gt;ISENABLER[3] |=(0x1&lt;&lt;1); //设置GICD中断优先级 GICD-&gt;IPRIORITYR[24] &amp;=(~(0x1f&lt;&lt;11)); //设置cpu0处理当前中断 GICD-&gt;ITARGETSR[24] |=(0x1&lt;&lt;8); //全局使能使组0中断可以被转发到GICC GICD-&gt;CTRL |=(0x1); //设置优先级掩码 GICC-&gt;PMR |=(0x1f&lt;&lt;3); //设置允许组0中断被cpu处理 GICC-&gt;CTRL |=(0x1); } do_it.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/936d1ace9adc2f604e9f69a0d456f75d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64f19841a27507b3130465d8fb4ff629/" rel="bookmark">
			中伟视界：燃气站的烟火、安全帽、抽烟、打电话检测等AI算法的工作原理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工智能（AI）技术在各行各业中的应用越来越广泛，燃气站的安全管理也在逐步引入AI算法。本文将详细介绍AI算法在燃气站安全管理中的应用，包括烟火检测、安全帽识别、抽烟、打电话检测等方面的工作原理。
烟火检测是燃气站安全管理中非常重要的一环。AI算法通过图像识别技术，可以实时监测燃气站周边的环境，一旦发现有人在燃气站附近燃放烟火，系统就会自动报警并进行相关处理。其工作原理是通过预先训练的模型，在监控画面中识别烟火的特征，从而进行检测和预警。
安全帽识别也是燃气站安全管理中的一项重要任务。AI算法可以通过监控摄像头实时识别燃气站内员工是否佩戴安全帽，一旦发现未佩戴安全帽的行为，系统会立即进行提醒和记录。其工作原理是通过人脸识别技术，对员工是否佩戴安全帽进行实时判断。
AI算法还可以实现对抽烟、打电话等行为的检测。通过图像识别和行为识别技术，系统可以自动监测燃气站内员工的行为，一旦发现有员工在工作期间抽烟或者打电话，系统会及时进行提醒和记录，从而有效管理员工的行为。其工作原理是通过分析监控画面中的人体动作特征，结合预训练模型对抽烟、打电话等行为进行识别和分析。
总的来说，AI算法在燃气站的安全管理中扮演着非常重要的角色。通过烟火检测、安全帽识别、抽烟、打电话检测等方面的应用，AI算法可以有效地提升燃气站的安全管理水平，减少事故的发生，保障员工和设施的安全。同时，AI算法也可以带来更高的工作效率和管理效果。相信随着科技的不断进步，AI算法在燃气站安全管理中的应用将会更加广泛和深入，为燃气站的安全发展提供更多的支持和保障。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f75ec5ddc69d2e070fb457be5ced50bc/" rel="bookmark">
			vue中的动态组件和混入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、动态组件
二、混入
全局混入：
局部混入：
混入规则：
一、动态组件 component标签动态切换组件,使用is属性切换组件
&lt;!-- 使用component动态切换组件 is属性 组件名称 --&gt; &lt;component v-bind:is="current"&gt;&lt;/component&gt; 使用component切换组件，组件会不停的创建和销毁，如果想在第一次创建时候缓存组件，可以使用keep-alive包裹
&lt;!-- keep-alive作用： 希望第一次创建组件时候被缓存 后续切换不会重新创建和销毁 --&gt; &lt;keep-alive&gt; &lt;component v-bind:is="current"&gt;&lt;/component&gt; &lt;/keep-alive&gt; 与keep-alive相关生命周期:
activated 使用keep-alive缓存的组件激活(进入)的时候触发 activated(){ console.log('被keep-alive缓存的组件激活的时候触发 进入组件时触发'); }, deactivated 使用keep-alive缓存的组件失活(离开)的时候触发
deactivated(){ console.log('被kepp-alive缓存的组件失活的时候触发 离开组件的时候触发'); }, errorCaptured 捕获后代组件错误 error(错误对象),vm(发生错误的组件),info(错误提示字符串)
// 捕获后代组件发生错误时触发 errorCaptured(err, vm, info){ console.log(err,'发生错误'); console.log(vm,'发生错误组件'); console.log(info,'字符串信息提示'); }, 二、混入 分为Vue可复用的功能，可以对数据和对象选项进行混入，接收组件任意选项。
全局混入： 全局混入对象会影响到每一个组件，谨慎使用。
// 混入对象配置项 混入作用： 分发Vue的可复用功能 let myMixin = { data() { return { mixinData:'我是混入对象的数据', msg:'我是混入对象的msg' } }, created(){ console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f75ec5ddc69d2e070fb457be5ced50bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b159f3c6f63c80641635514dfc2bcf97/" rel="bookmark">
			C语言之初识C语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、什么是C语言二、第一个C语言程序三、数据类型四、变量，常量1、变量1.1 变量的命名1.2 变量的分类1.3 变量的使用1.4 变量的作用域和生命周期2、变量 五、字符串1. 概念2. 求解字符串的长度【strlen】3. 转义字符【含笔试题】 六、注释七、选择语句八、循环语句九、函数十、数组1、数组的定义2、数组的下标3、数组的使用 十一、操作符1、算数运算符2、移位操作符3、位操作符4、赋值操作符5、单目操作符6、关系操作符7、逻辑操作符8、条件操作符9、逗号表达式10、其他 十二、常见关键字1、前言2、有关数据存储的底层原理3、typedef关键字4、static关键字4.1、static关键字修饰局部变量4.2、static关键字修饰全局变量4.3、static关键字修饰函数 十三、 #define 定义常量和宏十四、 指针1、引言2、内存的概念和介绍3、指针变量的大小 十五、结构体 前言 想必刚接触C语言的同学们不知道C语言是什么？，有什么用，那么你来对了，本系列就会带你入门C语言，从入门到“入土”,开玩笑的，正如标题所说，本教程首先对C语言有一个初步的认识，能够看懂别人写的是什么，有一个大概的框架，那么，我要开始讲解了。 这一章主要是初始C语言的一个大纲。
一、什么是C语言 C语言是什么？
语言：汉语，日语，英语等。语言是一个自然语言，是人与人交流的语言。
计算机语言：类比过来，是人与计算机之间的交流。
C语言是一门通用计算机编程语言，广泛应用于底层开发。C语言的设计目标是提供一种能以简易 的方式编译、处理低级存储器、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语 言。 尽管C语言提供了许多低级处理的功能，但仍然保持着良好跨平台的特性
二、第一个C语言程序 我们在了解完C语言是什么后，我们需要了解如何使用集成开发环境去完成第一个C语言程序。 什么是集成开发环境呢？
集成开发环境（IDE，Integrated Development Environment ）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。
像vscode就是一种编辑器，它不是集成开发环境，但是它可以添加许多的插件来编辑代各种形式的代码。
像vs2022就是一种集成开发环境，在平时使用很方便，但是存储空间比较大，毕竟有好有缺点嘛，不能两者兼容。
但是我本人不太推荐使用那种上古编译器比如VC++,DEV++…
接下来我们就开始正式写第一个C语言程序
进入官网下载VS2022，不要去别的地方下载那些盗版的！！！点击进入官网 点击个人免费下载，学习下载这个完全够用了。 打开下载 打开软件，创建一个新项目 在C语言的学习中，大多数人的第一个程序就是hello word!，那么我们怎么打印出hello word，开始我们学习编程之旅，下面就跟着我来一起学习。 我们知道，C语言所有的字符，符号，都是英文的。C语言中代码是从main函数的第一行开始的。main函数是程序的入口，一个工程中main函数有且只有一个。其中代码中的printf是编译器的头文件引入的，可以直接使用。&lt;stido.h&gt;是头文件，后缀为.c是源文件，后缀.h为头文件。 #include&lt;stdio.h&gt; int main() { printf("hello world!\n"); return 0; } 有人可能看到我这里写的是int main(){ ... return 0},通常就是这样写的，也是最普遍的写法
还有一种就是void main(){ },这种写法比较古老，现在不会使用这种写法。 三、数据类型 写出了我们的第一个C语言程序，接下来我们来说一说C语言中的数据类型
在了解数据类型前，我们先探究为什么要写程序？
是为了用程序解决生活中的一些问题。在现实生活中，我们的各种数据有很多不同的类型，为了更加丰富的表达生活中的各种值，所以在C语言程序中设置这么多数据类型。 char //字符数据类型 short //短整型 int //整形 long //长整型 long long //更长的整形 float //单精度浮点数 double //双精度浮点数 每种类型的字节大小是多少？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b159f3c6f63c80641635514dfc2bcf97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acad9788818f87e522d72db62ff8587a/" rel="bookmark">
			揭秘Pod状态与生命周期管理的秘密（中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章中主要介绍了Pod的基础概念与使用、删除。本文将带你一起学习Pod的几种容器(Init、Pause)
点击 这里 可以查看所有相关文章。
Init 容器 本文讲解 Init 容器的基本概念，这是一种专用的容器，在应用程序容器启动之前运行，用来包含一些应用镜像中不存在的实用工具或安装脚本。
理解 Init 容器 Pod 能够具有多个容器，应用运行在容器里面，但是它也可能有一个或多个先于应用容器启动的 Init 容器。
Init 容器与普通的容器非常像，除了如下两点：
Init 容器总是运行到成功完成为止。每个 Init 容器都必须在下一个 Init 容器启动之前成功完成。 如果 Pod 的 Init 容器失败，Kubernetes 会不断地重启该 Pod，直到 Init 容器成功为止。然而，如果 Pod 对应的 restartPolicy 为 Never，它不会重新启动。
指定容器为Init容器，在PodSpec中添加initContainers字段，以v1.Container类型对象的 JSON 数组的形式，还有app的containers数组。Init 容器的状态在status.initContainerStatuses字段中以容器状态数组的格式返回（类似 status.containerStatuses 字段）。
与普通容器的不同之处 Init 容器支持应用容器的全部字段和特性，包括资源限制、数据卷和安全设置。 然而，Init 容器对资源请求和限制的处理稍有不同。 而且 Init 容器不支持 Readiness Probe，因为它们必须在 Pod 就绪之前运行完成。
如果为一个 Pod 指定了多个 Init 容器，那些容器会按顺序一次运行一个。只有当前面的 Init 容器必须运行成功后，才可以运行下一个 Init 容器。当所有的 Init 容器运行完成后，Kubernetes 才初始化 Pod 和运行应用容器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acad9788818f87e522d72db62ff8587a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bf0756ab74055cbb3a5dac6d1fe61f7/" rel="bookmark">
			2312llvm,用匹配器构建clang工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文
用LibTooling和LibASTMatchers构建工具 这里展示如何基于Clang的LibTooling构建有用的源到源翻译工具.基础
步骤0:取Clang 因为Clang是LLVM项目的一部分,因此你需要先下载LLVM的源码.Clang和LLVM都在同一个git仓库中,在不同的目录下.更多见入门指南.
cd ~/clang-llvm git clone https://github.com/llvm/llvm-project.git 接着,要取CMake构建系统和Ninja构建工具.
cd ~/clang-llvm git clone https://github.com/martine/ninja.git cd ninja git checkout release ./bootstrap.py sudo cp ninja /usr/bin/ cd ~/clang-llvm git clone git://cmake.org/stage/cmake.git cd cmake git checkout next ./bootstrap make sudo make install 好.现在构建Clang!
cd ~/clang-llvm mkdir build &amp;&amp; cd build cmake -G Ninja ../llvm -DLLVM_ENABLE_PROJECTS="clang;clang-tools-extra" -DLLVM_BUILD_TESTS=ON # 允许测试,默认关闭. ninja ninja check # Test LLVM only. ninja clang-test # Test Clang only.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bf0756ab74055cbb3a5dac6d1fe61f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/999445c309ccde396b9e69da06c381e5/" rel="bookmark">
			Java代码审计&amp;鉴权漏洞&amp;Interceptor&amp;Filter&amp;Shiro&amp;JWT（非常详细！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
0x00 前言
0x01 鉴权方式&amp;审计思路 1、目前主流的鉴权方式
2、鉴权漏洞审计思路
0x02 Interceptor鉴权审计 - NewbeeMall电商系统
1、项目介绍 - NewbeeMall
2、Interceptor 补充介绍
3、NewbeeMall - Interceptor鉴权 - 代码审计
0x03 Filter鉴权审计 - 华夏ERP进销存系统
1、项目介绍 - 华夏ERP
2、华夏ERP - Filter - 代码审计
0x04 Shiro鉴权审计 - Tumo博客系统
1、项目介绍 - Tumo博客系统
2、Tumo - Shiro - 代码审计
0x05 JWT鉴权审计 - FastCMS
1、项目介绍 - FastCMS
2、JWT鉴权漏洞审计思路
3、FastCMS - JWT - 代码审计
0x00 前言 希望和各位大佬一起学习，如果文章内容有错请多多指正，谢谢！ 个人博客链接：CH4SER的个人BLOG – Welcome To Ch4ser's Blog
0x01 鉴权方式&amp;审计思路 1、目前主流的鉴权方式 Interceptor是一种拦截器，也称之为拦截器链（Interceptor Chain），主要用于拦截请求、响应或处理过程中的某些事件，比如权限认证、日志记录、性能测试等。在 Java 中，Interceptor可以用来扩展框架，增加或修改某个方法的行为，或者对应用流程做些前置处理、后置处理、环绕处理等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/999445c309ccde396b9e69da06c381e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39c8fcea794f6e842d95b0089585af9f/" rel="bookmark">
			cms垃圾回收器的优点和垃圾收集的详细过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是cms
CMS（Concurrent Mark Sweep）是Java虚拟机中的一种垃圾回收器，它主要针对长时间运行的大型应用程序进行优化，其主要优点包括：
并发收集：CMS垃圾回收器可以在应用程序运行时并发收集垃圾，减少了应用程序暂停时间，提高了应用程序的响应性能。
低延迟：由于CMS垃圾回收器采用了增量标记和清除算法，在垃圾回收过程中可以尽可能地减少应用程序的暂停时间，提高了应用程序的响应速度。
较短的停顿时间：CMS垃圾回收器采用了标记-清除算法，可以将整个垃圾回收过程分为多个阶段，每个阶段的暂停时间都较短，从而减少了应用程序的停顿时间。
适合大内存：由于CMS垃圾回收器不需要一次性扫描整个堆空间，所以它可以处理非常大的内存空间，适合于大型应用程序使用。
CMS垃圾回收器的详细过程如下：
初始标记阶段：在这个阶段中，CMS垃圾回收器会暂停应用程序，对存活对象进行标记，并记录下所有被标记的对象。
并发标记阶段：在这个阶段中，CMS垃圾回收器会并发地扫描堆空间，标记所有与初始标记阶段标记的对象有关联的存活对象。
重新标记阶段：在这个阶段中，CMS垃圾回收器会暂停应用程序，重新扫描堆空间，标记在并发标记阶段有被修改的存活对象，并记录下所有被标记的对象。
并发清除阶段：在这个阶段中，CMS垃圾回收器会并发地清除未被标记的对象，并释放空间。
需要注意的是，在并发清除阶段和应用程序运行时，可能会产生新的垃圾对象，这些垃圾对象需要等待下一次垃圾回收才能被清除。因此，CMS垃圾回收器需要进行多次垃圾回收才能完全清除所有垃圾对象。
为什么说cms是以牺牲吞吐量来获取最大停顿时间的垃圾收集器？
与其他传统的垃圾回收器比如标记-清除（Mark-Sweep）算法相比，CMS采用了并发的方式进行垃圾回收，即在应用程序执行的同时进行垃圾回收操作。这意味着在执行垃圾回收时，程序可以继续运行，减少了停顿时间，提高了系统的实时性和响应性。
然而，为了达到较短的回收停顿时间，CMS必须牺牲一定的吞吐量。具体来说，CMS在进行垃圾回收过程中，需要占用一部分CPU资源，可能会导致应用程序的执行速度略有降低。这是因为CMS在进行并发回收时，需要与应用程序竞争CPU资源。
另外，CMS使用的是标记-清除算法，该算法在回收结束后会产生大量的内存碎片，这些内存碎片可能会增加后续的内存分配操作的开销。为了解决这个问题，CMS还引入了后台的“碎片整理”（compaction）操作，用于合并和整理内存碎片。这个操作也会增加一定的开销，进一步影响吞吐量。
综上所述，CMS以较低的回收停顿时间为目标，通过并发回收和后台整理操作来实现。但为了达到这个目标，它需要牺牲一定的吞吐量。在某些情况下，特别是对于对实时性要求较高的应用程序，CMS是一种比较合适的垃圾回收器选择。但对于强调整体吞吐量的应用程序，可能需要考虑其他垃圾回收算法或调整CMS的配置参数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/488289ab1718fbe2fa4e6806b017e1a2/" rel="bookmark">
			亿级并发，API网关等核心组件，如何设计？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说在前面 在40岁老架构师 尼恩的读者交流群(50+)中，很多小伙伴拿到一线互联网企业如阿里、网易、有赞、希音、百度、滴滴的面试资格。
最近，尼恩指导一个小伙伴简历，写了一个《高并发网关项目》作为简历黄金项目，帮这个小伙拿到 字节/阿里/微博/汽车之家 面邀，并且成功拿到大厂offer。
所以说，《高并发网关项目》是一个牛逼的项目。为了帮助大家拿到更多面试机会，拿到更多大厂offer。尼恩专门出了一章视频，介绍这个项目的架构和实操——《33章：10Wqps 高并发 Netty网关架构与实操》，结合视频，再结合一对一的简历指导，让大家的简历金光闪闪、脱胎换骨。
《33章：10Wqps 高并发 Netty网关架构与实操》 目录如下：
配合《33章：10Wqps 高并发 Netty网关架构与实操》， 尼恩会梳理几个工业级、生产级网关案例，作为架构素材、设计的素材。
前面，已经梳理了下面的经典案例：
《日均数十亿访问，个推API网关如何架构？》《工业级Netty网关，京东是如何架构的？》《2亿用户，B站API网关如何架构？》《100万级连接，石墨文档WebSocket网关如何架构？》《单体120万连接，小爱网关如何架构？》《亿级长连接，淘宝接入层网关的架构设计》《100万级连接，爱奇艺WebSocket网关如何架构》《日200亿次调用，喜马拉雅网关的架构设计》《千万级连接，知乎如何架构长连接网关？》《日流量200亿，携程网关的架构设计》 除了以上的10个案例，这里，尼恩又找到一个漂亮的生产级案例：《亿级并发，API网关等核心组件，如何设计？》。
这些案例，并不是尼恩的原创。仅仅是尼恩在《33章：10Wqps 高并发 Netty网关架构与实操》学习材料中，供大家学习和交流使用。
《尼恩 架构笔记》《尼恩高并发三部曲》《尼恩Java面试宝典》的PDF，请到文末公号【技术自由圈】获取
文章目录 说在前面蚂蚁金服面对亿级并发场景的组件体系设计移动研发基础服务体系蚂蚁移动接入架构演进网关架构代码变革统一接入网关网络协议优化SYNC 数据同步 移动调度中心网关去中心化SYNC-PULL 读扩散 大促活动场景应对之道应对大促的几个步法大促活动场景应对之道——流控自动化真机测试客户端智能发布——确保客户端万无一失舆情分析——及时获取用户反馈 对外输出的基础服务产品技术组件产品服务输出：成熟一个，开放一个 说在最后：有问题可以找老架构取经尼恩技术圣经系列PDF 蚂蚁金服面对亿级并发场景的组件体系设计 作者：吕丹，蚂蚁金服技术专家
本文内容可以分为四大块，第一块是标准移动研发所需的基础服务体系，第二块是支撑亿级并发的核心组件“移动接入”的架构演进过程，第三块是双十一、双十二、新春红包这种大促活动的的应付方法，最后一块是目前已经对外输出的基础服务产品。
移动研发基础服务体系 首先介绍一下支付宝客户端的演进过程。
之前，支付宝客户端的主要功能是转账、订单支付、交易查询等等，它更像是一个专门为支付而设计的工具 APP，用户在需要支付时才会使用，支付完成后便不再打开。
然而，2013 年，蚂蚁金服 all in 无线之后，加入了很多服务，例如余额宝、卡券、探索发现等，几乎将支付宝网站的所有功能都转移到了移动端，支付宝也逐渐演化成一个平台级别的客户端。
之后，随着移动互联网的快速发展，公司内部孵化出了更多的 APP，其他行业也在移动互联网圈内铺开了大量的业务，为了提升用户量、用户粘性，APP 之间也开始进行了大量的业务融合，超级 APP 也因此而诞生，APP 开始朝着生态化的模式发展。
至今，支付宝客户端的年活跃用户数已超过8亿，在大促销活动期间，同时在线用户数超过3亿，并发请求超过1亿，每秒同时上线用户数超过百万。
这些数据背后，必然需要一套庞大、复杂、完整的支持系统来保障支付宝的顺畅运行，而移动研发基础服务体系便是这一体系的重要组成部分。
在研发过程中，我们将移动研发基础服务体系划分为四个主要部分：
在APP研发阶段，主要包括应用框架、基础组件、云端服务和研发工具；在APP测试阶段，主要包括研发协作平台和真机测试平台，研发协作平台涵盖版本管理、迭代管理、安装包编译、构建和打包等功能，而真机测试则旨在替代人工服务，减少人力成本，提高测试效率；在APP运维阶段，主要包括智能发布、日志回溯、应急管理和动态配置；在APP运营阶段，主要包括舆情反馈、实时分析、离线计算和智能营销。 支付宝客户端的发展不仅体现在功能的丰富和用户基数的增长，更在于其背后支撑体系的日益完善和智能化。
从单一的工具应用成长为集多种服务于一体的平台，支付宝客户端的演进映射了整个移动应用生态的发展趋势，即通过不断的创新和整合，提升用户体验，满足用户多样化的需求。
蚂蚁移动接入架构演进 今天的主题为支撑亿级并发下的基础服务，而在亿级并发下移动接入又是最核心、最重要的一个环节。
移动接入并不是单个系统，而是一整套组件的总称，包括：Spanner+ 连接管理、API网关、PUSH通知和SYNC数据同步等。
这些组件共同构成了移动业务流量的主要通道，不仅要保持客户端的状态，还需实现集中管理和部分业务数据处理。
起初，并不存在“移动接入”这一概念，它的形成与发展与支付宝客户端的历程相似，都是通过不断的迭代和改进逐步完善的。
最初阶段，各个业务单元各自提供API或直接向客户端展示能力，缺乏统一的架构、模型和管控机制。
为了应对这一挑战，在 all in 阶段我们引申出了一个 API 网关，以实现集中管理，并且增加了PUSH推送功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/488289ab1718fbe2fa4e6806b017e1a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf4de5b42b1ba57eff18d9ee1a7f61f5/" rel="bookmark">
			蓝桥杯 归并排序 acwing版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上次题目答案 先公布一下上次内容的留的题目的答案吧，我相信看了并练习之后的人那个题目不成问题。
题目在上讲里面有，这里不再放出来了。
#include&lt;iostream&gt; using namespace std; bool check(int i){ for(int a = 1;a&lt;=i;a++){ for(int b = 0;b &lt; a;b++){ if(a*a-b*b==i){ return true; } } } return false; } int main(){ int ans = 0; for(int i = 1;i &lt;= 2021;i++){ if(check(i)){ ans++; } } cout &lt;&lt; ans; return 0; } 答案：1516
分析：
n = a*a-b*b
b的范围是(0,a)
a的范围是[1，n],为什么a至多能取到n呢?
以n=9为例：假设a=9，为了让a*a-b*b=9，就算b取最大值8，9*9-8*8仍然远大于9，所以a永远不会超过n(1例外)
下面开始讲解归并排序内容了： 1.归并排序介绍： 简单来说，我们可以说合并排序的过程是将数组分成两半，对每一半进行排序，然后将排序后的两半合并在一起。重复此过程，直到对整个数组进行排序。
2.动画展示过程 可以看出来现在不是跟之前一样一味的代数法了。其实代数法是为了能更好的理解函数递归的过程，除此之外无非就是验证程序的对错，所以还是希望大家能从本质上理解一个算法的思路，这样省时省力，我初学算法的时候就是一直不明白程序傻傻的老实想用代数法理解为什么这么写的，我现在的评价是大可不必，理解原理，模仿别人的写出代码，别跟自己过不去。不多bb了上内容。
合并排序是如何工作的？ 合并排序是一种递归算法，它连续地将数组分成两半，直到无法进一步分割，即数组只剩下一个元素（具有一个元素的数组总是排序）。然后，将排序的子数组合并为一个排序的数组。
请参阅下图以了解合并排序的工作原理。
插图：
让我们考虑一个数组 arr[] = {38， 27， 43， 10}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf4de5b42b1ba57eff18d9ee1a7f61f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49ad1e3c74062d4e58cb3aa21c2693dd/" rel="bookmark">
			金蝶云星空创建普通动态表单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 金蝶云星空创建普通动态表单动态表单的种类动态表单与单据的区别新建普通动态表单启动开发环境 金蝶云星空创建普通动态表单 动态表单的种类 动态表单与单据的区别 单据本质上也是动态表单，只不过单据更多的是用来保存业务数据，而普通的动态表单是用来显示内容，可以简单的理解动态表单就是一个界面。另，单据的实体有对应的表，而动态表单没有。
新建普通动态表单 业务需求：售后单明细点击按钮，弹出动态表单，根据单据客户和组织过滤，选择一个未发生售后且序列号是在库状态的序列号，确定后将序列号写回售后单的明细【替换系列号】字段上。
添加菜单按钮【确认】、【取消】
XXXX_tbSure 确定
XXXX_tbCancel 取消
取消按钮配置关闭操作
拖取一个基础资料控件
重命名标识，并绑定基础资料
售后单表单插件，点击按钮弹窗
动态表单-表单插件
接收参数，干预基础资料的条件
启动开发环境 授权，测试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6079487a27709852c597a4a4c79d6fcc/" rel="bookmark">
			css的继承属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 继承属性： （1）说明 当一个元素的继承属性没有指定值的时候，就会使用父元素的属性的计算值。
css的计算值：在继承过程中从父级传输到子级的值。根据指定值计算。
处理特殊值 inherit、initial、revert、revert-layer 和 unset。initial取在文档根元素该属性的概述。执行达到属性定义表中“计算值”行中描述的值所需的计算。涉及到讲相对值（例如单位或百分比值）转换为绝对值。 （2）继承的属性： 字体属性 font：组合字体font-family：规定字体系列font-weight：字体的粗细font-size：字体的尺寸font-style：字体的风格font-variant：设置小型大写字母的字体显示文本，所有的小写字母均会被转换为大写，所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小。font-stretch：可对元素进行收缩变形font-size-adjust：为某个元素规定一个 aspect 值，字体的小写字母 "x" 的高度与"font-size" 高度之间的比率被称为一个字体的 aspect 值。这样就可以保持首选字体的 x-height。文本属性： 内联元素： color：文本颜色direction：文本书写方向text-transform：文本的大小写line-height：文本的行高word-spacing：增加或减少单词间的空白（即字间隔）letter-spacing：增加或减少单个字符间的空白（字符间距）块级元素： text-indent：文本块的首行文本缩进text-align：文本对齐方式元素可见性： visbility：规定元素是否可见表格布局属性：caption-side，border-collapse，border-spacing，empty-cells，table-layout列表布局属性：list-style，list-style-type，list-style-image，list-style-position光标属性：cursor页面样式属性：page、page-break-inside、windows、orphans 声音样式属性：speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、pitch、pitch-range、stress、richness、、azimuth、elevation
非继承属性： （1）说明： 当元素的一个非继承属性没有指定值时，取该属性的原始值。
（2）不能继承的属性： display：设置元素是否被视为块或者内联元素以及用于子元素的布局。文本属性：vertical-align，text-decoration盒子模型的属性：width，height，margin，border，padding背景属性：background，background-color，background-image定位属性：float，clear，position，top，right，bottom，left，min-width，min-height，max-width，max-height，overflow，clip inherit： inherit关键字表示显式声明继承父元素。这个关键字对继承和非继承都是有效的。
继承来自文档树中的父元素，即使父元素不是包含块。
作用： inherit关键字可以让子元素获取其父元素的计算值，可以适用于所有css属性。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5fe3845ec8bafa55db30df9d4feaa0e/" rel="bookmark">
			[网站更新]正版软件&#43;正版游戏限免！马上过期！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		「 静静地做自己，让世界发现你 」
科技毒瘤君将不定时分享优质工具，大家可以把科技毒瘤君公众号设为★星标，第一时间获取最新推送，以防错过优质内容
官网地址：www.exehub.net - 互联网免费资源中心
本次主要给大家分享一下网站刚更新的两款软件和其他内容分享。
因为在公众号一次性不能发那么多篇文章，一篇文章太长了也没人看，所以以后我都会在公众号做一次通知，建议大家直接收藏www.exehub.net。网站内容全部免费分享，不存在任何收费情况。现在不，以后也不。
今天分享的内容第一款是正版系统卸载软件，含授权码，授权码还有200天左右，需要的自取，第二款是EPIC的免费游戏，昨天也分享了一款，但是没有置顶公众号的朋友可能错过了，以后每天都会分享一期：仅剩3小时，Epic限免，原价249元直接白嫖
正文开始
嫌复制链接麻烦的朋友，直接点击文章最后的阅读原文即可！
《The Outer Worlds》EPIC游戏限免
https://www.exehub.net/387.html
Windows 专业卸载工具 IObit Uninstaller Pro 13 限时正版免费领取
https://www.exehub.net/362.html
Xterminal，一款颜值超高，功能还特别强大的SSH工具
https://www.exehub.net/384.html
SingleFile,一键保存网页内容的神器
https://www.exehub.net/381.html
翻译软件推荐：Pot，支持Windows、macOS和Linux
https://www.exehub.net/378.html
各类网盘直链在线解析, 已支持蓝奏云/奶牛快传/小飞机盘/123云盘等
https://www.exehub.net/376.html
学会从各大高校镜像站下载软件，速度又快又安全
https://www.exehub.net/372.html
vivo创作平台，新短视频平台，刚起步，快来薅羊毛
https://www.exehub.net/368.html
免费分享一个海外问卷赚米站点，附上注册流程和注意事项
https://www.exehub.net/364.html
往期分享
时隔半年，我的网站终于又回来了
4K Video Downloader+ 最全面的网路影片下载工具评测与推荐！
这个下载器支持超过10,000 影音平台！还能下载。。
每天分享十篇，我们不见不散
最后，网站新开，大家多多支持！
无偿分享，如果觉得有用！
点赞+转发就是最大的帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c814b48d5da1b197456b213f3d64bb9/" rel="bookmark">
			基于Java公廉租房维保系统设计和实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌全网粉丝30W+,csdn特邀作者、博客专家、CSDN新星计划导师、Java领域优质创作者,博客之星、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于Java技术领域和学生毕业项目实战,高校老师/讲师/同行交流合作✌
主要内容：SpringBoot、Vue、SSM、HLMT、Jsp、PHP、Nodejs、Python、爬虫、数据可视化、小程序、安卓app、大数据、物联网、机器学习等设计与开发。
🍅文末获取源码联系🍅
👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟
2022-2024年最全的计算机软件毕业设计选题大全：1000个热门选题推荐✅
Java项目精品实战案例《100套》
Java微信小程序项目实战《100套》
Python项目实战《100套》
感兴趣的可以先收藏起来，还有大家在毕设选题，项目以及论文编写等相关问题都可以给我留言咨询，希望帮助更多的人
​ 系统介绍： 本毕业设计的内容是设计并且实现一个基于java技术的公廉租房维保系统。它是在Windows下，以MYSQL为数据库开发平台，java技术和Tomcat网络信息服务作为应用服务器。公廉租房维保系统的功能已基本实现，主要实现首页、个人中心、业主管理、维修单位管理、房屋信息管理、维修申报单管理、维修完成管理、房屋维护管理等功能的操作系统。
论文主要从系统的分析与设计、数据库设计和系统的详细设计等几个方面来进行论述，系统分析与设计部分主要论述了系统的功能分析、系统的设计思路，数据库设计主要论述了数据库的设计，系统的详细设计部分主要论述了几个主要模块的详细设计过程。
一、业主管理功能
该部分内容提供业主资料修改，包含首页、个人中心、房屋信息管理、维修申报单管理、维修完成管理等功能。
二、维修单位管理功能
该部分内容提供业主资料修改，包含首页、个人中心、维修申报单管理、维修完成管理等功能。
三、管理员管理功能
该部分内容包含了首页、个人中心、业主管理、维修单位管理、房屋信息管理、维修申报单管理、维修完成管理、房屋维护管理等功能。管理员可对所有的信息进行增、删、改、查，能对用户信息进行管理,更新最近的公廉租房维保信息。
为了方便更直观的理解,下图以图形形式给出关于整个网站的结构图。网站总体功能结构图3-1如图所示：
程序上交给用户进行使用时，需要提供程序的操作流程图，这样便于用户容易理解程序的具体工作步骤，现如今程序的操作流程都有一个大致的标准，即先通过登录页面提交登录数据，通过程序验证正确之后，用户才能在程序功能操作区页面操作对应的功能。
​ 程序操作流程图
功能截图： 系统登录，管理员、业主和维修单位进入系统前在登录页面根据要求填写用户名和密码，选择角色等信息，点击登录进行登录操作，如图5-1所示。
图5-1系统登录界面图
5.1管理员功能模块 管理员登录系统后，可以对首页、个人中心、业主管理、维修单位管理、房屋信息管理、维修申报单管理、维修完成管理、房屋维护管理，如图5-2所示。
图5-2管理员功能界面图
业主管理，在业主管理页面可以对索引、业主号、业主姓名、性别、业主手机、身份证、楼房号、车牌号等内容进行详情、修改或删除等操作，如图5-3所示。
图5-3业主管理界面图
维修单位管理，在维修单位管理页面可以对索引、维修工号、师傅姓名、性别、年龄、师傅手机等内容进行详情、修改或删除等操作，如图5-4所示。
图5-4维修单位管理界面图
房屋信息管理，在房屋信息管理页面可以对索引、房屋编号、房屋名称、 房屋类型、房屋面积、业主号、业主手机、身份证、业主姓名、楼房号等内容进行详情、房屋维护、修改或删除等操作，如图5-5所示。
图5-5房屋信息管理界面图
维修申报单管理，在维修申报单管理页面可以对索引、报修编号、报修设备、报修日期、业主号、业主姓名、业主手机、楼房号、完成状态、审核回复、审核状态等内容进行详情、修改或删除等操作，如图5-6所示。
图5-6维修申报单管理界面图
维修完成管理，在维修完成管理页面可以对索引、报修设备、业主号、业主姓名、报修编号、楼房号、维修工号、师傅手机、完成时间、回执单等内容进行详情、修改或删除等操作，如图5-7所示。
图5-7维修完成管理界面图
房屋维护管理，在房屋维护管理页面可以对索引、房屋编号、房屋名称、房屋类型、业主号、维护时间、维护人员等内容进行详情、修改或删除等操作，如图5-8所示。
图5-8房屋维护管理界面图
5.2业主功能模块 业主登录进入系统可以对首页、个人中心、房屋信息管理、维修申报单管理、维修完成管理等功能进行详细操作，如图5-9所示。
图5-9业主功能界面图
房屋信息管理，在房屋信息管理页面可以对、索引、房屋编号、房屋名称、 房屋类型、房屋面积、业主号、业主手机、身份证、业主姓名、楼房号等内容进行详情等操作，如图5-10所示。
图5-10房屋信息管理界面图
维修申报单管理，在维修申报单管理页面中可以对索引、报修设备、业主号、业主姓名、报修编号、楼房号、维修工号、师傅手机、完成时间、回执单等内容进行详情或删除等操作，如图5-11所示。
图5-11维修申报单管理界面图
5.3维修单位功能模块 维修单位登录进入系统可以对首页、个人中心、维修申报单管理、维修完成管理等功能进行详细操作，如图5-12所示。
图5-12维修单位功能界面图
维修申报单管理，在维修申报单管理页面可以对索引、报修编号、报修设备、报修日期、业主号、业主姓名、业主手机、楼房号、完成状态、审核回复、审核状态、审核等内容进行详情或维修完成等操作，如图5-13所示。
图5-13维修申报单管理界面图
维修完成管理，在维修完成管理页面可以对索引、报修设备、业主号、业主姓名、报修编号、楼房号、维修工号、师傅手机、完成时间、回执单等内容进行详情、修改或删除等操作，如图5-14所示。
图5-14维修完成管理界面图
代码实现： /** * 登录相关 */ @RequestMapping("users") @RestController public class UserController{ @Autowired private UserService userService; @Autowired private TokenService tokenService; /** * 登录 */ @IgnoreAuth @PostMapping(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c814b48d5da1b197456b213f3d64bb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e10bf6611ee351266ce331fcbcd2eda/" rel="bookmark">
			55. 跳跃游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。
示例 1：
输入：nums = [2,3,1,1,4] 输出：true 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。 示例 2：
输入：nums = [3,2,1,0,4] 输出：false 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。 提示：
1 &lt;= nums.length &lt;= 1040 &lt;= nums[i] &lt;= 105 方法二：
public static boolean canJump(int[] nums) { if (nums == null) { return false; } //前n-1个元素能够跳到的最远距离 int k = 0; for (int i = 0; i &lt;= k; i++) { //第i个元素能够跳到的最远距离 int temp = i + nums[i]; //更新最远距离 k = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e10bf6611ee351266ce331fcbcd2eda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba1725e42c337bfb8e14640a604f6335/" rel="bookmark">
			HTTP小记2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
HTTP/1.1优化
QUIC协议
路由器
RTT（Round-Trip Time）
计算机网络体系结构
体系结构各层在整个过程中的作用
HTTP/1.1优化 1.通过缓存技术来避免/减少发送HTTP请求
2.减少HTTP请求的次数
将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数将多个小资源合并成一个大资源再传输，减少HTTP请求次数以及头部的重复传输，进而减少TCP连接数量，进而省区TCP握手和慢启动造成的网络消耗按需访问资源，不获取全部的资源，只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源，达到延迟发送请求的效果 3.压缩相应资源，降低传输资源大小，提高传输效率，选择更为优秀的压缩算法
QUIC协议 一种基于UDP的传输层协议。
QUIC=HTTP/2+TLS+UDP
QUIC允许在单个连接上并行传输多个数据流，并且每个流都可以独立的处理，也就是某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，所以不存在队头阻塞问题。
QUIC内部包含TLS。
QUIC是新协议，对于很多网络设备，根本不知道什么是QUIC，只会当做是UDP，这样就会出现新的问题，因为有的网络设备是会丢掉UDP包的，QUIC是基于UDP实现的，网络设备无法识别是QUIC包，会当做UDP包丢弃。
路由器 是连接两个或多个网络的硬件设备，在网络间起网关的作用，是读取每一个数据包中的地址然后决定如何传送的专用智能性的网络设备。
计算机通常采用的是分组交换。
在路由器中的输入和输出端口之间没有直接连线。
路由器处理分组的过程是：
把收到的分组先放入缓存（暂时存储）；查找转发表，找出到某个目的地址应从哪个端口转发；把分组送到适当的端口转发出去。 RTT（Round-Trip Time） RTT是数据流往返的网络耗时，我们一般的http请求与服务端的交互时间。
往返时间RTT也是一个重要的性能指标。
计算机网络体系结构 常见的计算机网络体系结构
如今用的最多的是TCP/IP体系结构，现今规模最大的、覆盖全球的、基于TCP/IP的互联网并未使用OSI标准。TCP/IP体系结构相当于将OSI体系结构的物理层和数据链路层合并为了网络接口层，并去掉了会话层和表示层。TCP/IP在网络层使用的协议是IP协议，IP协议的意思是网际协议，因此TCP/IP体系结构的网络层称为网际层 网络接口层：并没有规定具体内容，这样做的目的是可以互连全世界各种不同的网络接口，例如：有线的以太网接口，无线局域网的WIFI接口等。
网际层：它的核心协议是IP协议。
运输层：TCP和UDP是这层的两个重要协议。
应用层：这层包含了大量的应用层协议，如 HTTP , DNS 等。
体系结构各层在整个过程中的作用 应用层
按照HTTP协议的规定构建一个HTTP请求报文。应用层将HTTP请求报文交付给运输层处理 运输层
给HTTP请求报文添加一个TCP首部，使之成为TCP报文段运输层将TCP报文交付给网络层处理 网络层
给TCP报文段添加一个IP首部，使之成为IP数据报网络层将IP数据报交付给数据链路层处理 数据链路层
给IP数据报添加一个首部和一个尾部，使之成为帧数据链路层将帧交付给物理层 物理层
先讲帧看作比特流，假设这里的网络N1是以太网，物理层还会给该比特流前面加上前导码物理层将装有前导码的比特流变换成相应的信号发送给传输媒体 信号再通过传输媒体到达路由器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/442ccb5a803e6ce9c5de658de50cdef3/" rel="bookmark">
			【C&#43;&#43;逆向 - 1】C&#43;&#43;函数新特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内联函数 本质：用函数代码替换函数调用
使用方式：在函数声明和函数定义前加上 inline 关键字
笔者感觉跟C语言中的宏定义差不多，但是内联函数更加“智能”（应该是编译器更加智能）。即使程序员将函数作为内联函数，但是编译器会检查是否满足一些要求，比如是否是递归调用，函数是否过大等。
笔者还是喜欢宏，当然因人而异
引用变量 int a; int &amp;b = a; int c = 20; b = c; // ==&gt; 这里是将 c 的值赋给 b 即 b = a = 20 [其实b的值是a的地址......] 注意：引用变量必须初始化；引用变量不得更换引用对象
本质：b 保存着 a 的地址；每次操作 b 时，会取出其保存的 a 的地址进行操作【是不是感觉跟指针很像，但是指针操作每次还得解引用，所以这里可以看作&lt;指针+自解引用&gt;】
考虑如下代码：
#include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;string&gt; using namespace std; int add(int a, int b) { return a + b; } inline int sub(int a, int b) { return a - b; } int main() { int a = 10; int &amp;b = a; b = 20; cout &lt;&lt; &amp;a &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/442ccb5a803e6ce9c5de658de50cdef3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/765daf90b0875ad527f62777206880bc/" rel="bookmark">
			如何写出高效的软件测试用例？用例两小时，摸鱼一整天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要编写出高效的测试用例，需要搞清楚什么是测试用例，以及如何编写出高效的测试用例？接下来将从以下几个部分来进行展开
1、什么是测试用例 2、如何编写测试用例 3、测试用例专项学习资源分享 一、什么是测试用例 测试用例 ：为了特定目的而设计的由一组测试输入、执行条件、预期结果构成的文档。
简单理解就是将产品的需求拆分为一个个功能点，然后去验证其正确性 二、如何编写测试用例 编写测试用例主要分为下面两种方式：
覆盖需求所有测试点挖掘需求外的测试点 下面我们来分别阐述如何实现：
1、看怎样去实现覆盖需求所有测试点 1）能看懂需求文档，找准测试测试依据
作为测试人员，需求文档是测试软件的依据，首先需要看懂产品的需求文档。对于需求文档涉及的测试点能够整理出来，简单理解就是把大段的文字描述转化为思维导图的过程，推荐大家通过Xmind的形式整理。
其次，在需求文档的基础上结合测试环境或者产品人员，加深对需求的理解，方便后续更好的熟悉需求，整理测试点编写用例。
2)整理测试点
整理测试点的好处就是给编写用例的人员提供一个全面可靠的思路，防止设计用例过程的遗漏或者错误。同时也可以降低直接拿着需求文本编写用例的难度。编写的宗旨，最起码确保能 覆盖需求。 将需求文档中的需求转化为测试点，方便编写测试用例，一般按照需求文档拆分成小的功能点，分别取验证。拆分到直接能够编写用例的程度，这个过程中可以使用一些设计用例的方法，即分别验证每一个小的测试目的。
举例，现在页面登录功能需求如下
若上诉需求要拆分成测试点，则可以制作如下所示：
2、挖掘需求外测试点 在讲这个话题之前，需要提前给大家普吉一个概念：质量模型特性。
质量模型特征包含：功能性、性能效率、安全性、易用性、兼容性、可靠性等 还是以上方的登录功能为例，根据质量模型特征，我们可以得到需求外测试点如下所示：
覆盖需求中的测试点，这是最基本的要求，再此基础上还需要挖掘需求外的测试点，可以借助于软件质量模型的特性进行思考，想法设法多思考用户使用过程中可能存在的各种场景。例如上述登录功能可以从非功能层面考虑设计：
三、提供测试用例专项视频供大家学习 总之，在确认覆盖需求的基础上，通过质量模型的特性进行思考补充，熟练使用质量模型过程实际是在对系统比较熟悉的基础上进行扩展补充，当然这个过程可以借助内部测试人员的讨论和评审补充会更加完善。
总结 如果你对此文有任何疑问，如果你也需要接口项目实战，如果你对软件测试、接口测试、自动化测试、面试经验交流感兴趣欢迎加入我们，加入方式在文章的最后面 自动化测试相关教程推荐： 2023最新自动化测试自学教程新手小白26天入门最详细教程,目前已有300多人通过学习这套教程入职大厂！！_哔哩哔哩_bilibili 2023最新合集Python自动化测试开发框架【全栈/实战/教程】合集精华，学完年薪40W+_哔哩哔哩_bilibili 测试开发相关教程推荐 2023全网最牛，字节测试开发大佬现场教学，从零开始教你成为年薪百万的测试开发工程师_哔哩哔哩_bilibili postman/jmeter/fiddler测试工具类教程推荐 讲的最详细JMeter接口测试/接口自动化测试项目实战合集教程，学jmeter接口测试一套教程就够了！！_哔哩哔哩_bilibili 2023自学fiddler抓包，请一定要看完【如何1天学会fiddler抓包】的全网最详细视频教程！！_哔哩哔哩_bilibili 2023全网封神，B站讲的最详细的Postman接口测试实战教学，小白都能学会_哔哩哔哩_bilibili 总结： 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。 ​
​
如果对你有帮助的话，点个赞收个藏，给作者一个鼓励。也方便你下次能够快速查找。
如有不懂还要咨询下方小卡片，博主也希望和志同道合的测试人员一起学习进步
在适当的年龄，选择适当的岗位，尽量去发挥好自己的优势。
我的自动化测试开发之路，一路走来都离不每个阶段的计划，因为自己喜欢规划和总结，
测试开发视频教程、学习笔记领取传送门！！
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c13be3a8e652ee3170f08b1da026bd45/" rel="bookmark">
			重定向和转发（完整理解及总结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.重定向
1.1重定向是什么
1.2重定向的特征
1.3重定向核心代码
1.4重定向实例演示
1.4.1书写login.jsp
1.4.2继承HttpServlet
1.4.3配置web.xml
1.4.4创建main.jsp
1.4.5测试
2.转发
2.1转发是什么
2.2转发的特征
2.3转发的核心代码 2.4转发实例演示
2.4.1书写login.jsp
2.4.2继承HttpServlet
2.4.3配置web.xml
2.4.4创建main.jsp
2.4.5测试
3.重定向和转发的区别 3.1定义不同 3.2跳转方式不同
3.3数据共享不同
3.4最终URL地址不同
3.5代码实现不同
web网站上面有一些跳转按钮。比如登录成功以后跳转到主页面！！！
1.重定向 1.1重定向是什么 用户通过浏览器发送一个请求，Tomcat服务器接收这个请求，会给浏览器发送一个状态码302，并设置一个重定向的路径，浏览器如果接收到了这个302的状态码以后，就会去自动加载服务器设置的路径
一个页面跳转到另外一个页面（应用场景）、登录页面跳转到主页面： login.jsp====&gt;LoginServlet====&gt;main.jsp
1.2重定向的特征 ①重定向的过程是浏览器（客户端）的行为
②实际上浏览器做了2次请求（当点击登录按钮的时候做了两次请求）（分别是请求login和main.jsp）
③注意上一次请求的request对象会丢失
④重定向有一个非常明显的特征，即浏览器的url变化了
1.3重定向核心代码 response.sendRedirect("main.jsp"); //就这一行代码，但是这一行代码必须写在doGet或者doPost方法中 1.4重定向实例演示 1.4.1书写login.jsp &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%--请求RedirectServlet--%&gt; &lt;form action="redirect" method="post"&gt; &lt;input type="text" name="username"/&gt;&lt;br&gt; &lt;input type="text" name="password"/&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c13be3a8e652ee3170f08b1da026bd45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef39b4f972f0aa5b0f75e4745dacea5b/" rel="bookmark">
			详解Keras3.0 Layer API: LSTM layer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LSTM layer 用于实现长短时记忆网络，它的主要作用是对序列数据进行建模和预测。
遗忘门（Forget Gate）：根据当前输入和上一个时间步的隐藏状态，计算遗忘门的值。遗忘门的作用是控制哪些信息应该被遗忘，哪些信息应该保留。输入门（Input Gate）：根据当前输入和上一个时间步的隐藏状态，计算输入门的值。输入门的作用是控制新的信息应该被添加到隐藏状态中，还是应该替换掉旧的信息。候选记忆单元（Candidate Memory Unit）：将遗忘门和输入门的输出相加，得到候选记忆单元的值。候选记忆单元的作用是将新的记忆和旧的记忆结合起来，形成一个新的记忆单元。输出门（Output Gate）：根据当前输入和候选记忆单元，计算输出门的值。输出门的作用是决定下一个时间步的隐藏状态应该是什么。 keras.layers.LSTM( units, activation="tanh", recurrent_activation="sigmoid", use_bias=True, kernel_initializer="glorot_uniform", recurrent_initializer="orthogonal", bias_initializer="zeros", unit_forget_bias=True, kernel_regularizer=None, recurrent_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, recurrent_constraint=None, bias_constraint=None, dropout=0.0, recurrent_dropout=0.0, seed=None, return_sequences=False, return_state=False, go_backwards=False, stateful=False, unroll=False, **kwargs ) 参数说明 units: 整数，表示LSTM层的神经元数量。activation: 字符串或激活函数对象，表示LSTM层的激活函数。默认为"tanh"。recurrent_activation: 字符串或激活函数对象，表示LSTM层的循环激活函数。默认为"sigmoid"。use_bias: 布尔值，表示是否在LSTM层中使用偏置项。默认为True。kernel_initializer: 初始化器对象，用于初始化LSTM层的权重矩阵。默认为"glorot_uniform"。recurrent_initializer: 初始化器对象，用于初始化LSTM层的递归权重矩阵。默认为"orthogonal"。bias_initializer: 初始化器对象，用于初始化LSTM层的偏置项。默认为"zeros"。unit_forget_bias: 布尔值，表示是否在LSTM层中添加遗忘门的偏置项。默认为True。kernel_regularizer: 正则化器对象，用于对LSTM层的权重矩阵施加正则化。默认为None。recurrent_regularizer: 正则化器对象，用于对LSTM层的递归权重矩阵施加正则化。默认为None。bias_regularizer: 正则化器对象，用于对LSTM层的偏置项施加正则化。默认为None。activity_regularizer: 正则化器对象，用于对LSTM层的输出施加正则化。默认为None。kernel_constraint: 约束器对象，用于对LSTM层的权重矩阵施加约束。默认为None。recurrent_constraint: 约束器对象，用于对LSTM层的递归权重矩阵施加约束。默认为None。bias_constraint: 约束器对象，用于对LSTM层的偏置项施加约束。默认为None。dropout: 浮点数，表示LSTM层的丢弃率。默认为0.0。recurrent_dropout: 浮点数，表示LSTM层的循环丢弃率。默认为0.0。seed: 整数，表示随机数生成器的种子。默认为None。return_sequences: 布尔值，表示是否返回整个序列的输出。默认为False。return_state: 布尔值，表示是否返回最后一个时间步的状态。默认为False。go_backwards: 布尔值，表示是否反向处理输入序列。默认为False。stateful: 布尔值，表示是否保持状态以供后续时间步使用。默认为False。unroll: 布尔值，表示是否展开LSTM层以减少计算复杂性。默认为False。**kwargs: 其他关键字参数，将传递给底层的TensorFlow操作。 示例 from keras.models import Sequential from keras.layers import LSTM, Dense #创建一个Sequential模型对象 model = Sequential() #添加一个LSTM层，设置单元数为32，输入形状为(timesteps, input_dim) model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef39b4f972f0aa5b0f75e4745dacea5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0ae57e50320ea3cd14e84facef38ab7/" rel="bookmark">
			C&#43;&#43;软件调试与异常排查从入门到精通系列文章汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀 前言 本文是C++软件调试与异常排查从入门到精通系列教程专栏的导航贴（点击链接，跳转到专栏主页，欢迎订阅，持续更新…）。
📢 建议在阅读专栏文章时，使用本篇导航文章，本导航文章对专栏中的文章进行了分类与排序，读起来更有条理！
专栏介绍：根据近几年C++软件异常排查的项目实践，系统地总结了引发C++软件异常的常见原因以及排查C++软件异常的常用思路与方法，详细讲述了C++软件的调试方法与手段，以图文并茂的方式给出具体的实战问题分析实例，带领大家逐步掌握C++软件调试与异常排查的相关技术，适合基础进阶和想做技术提升的相关C++开发人员！
专栏适用人群：C++软件开发人员。
📢 在做技术分享与内部交流时，从刚毕业的C++新手到工作七八年及以上的老程序员，反应都比较强烈，都表示很有价值！
📢 通过沟通交流及对身边同事的观察发现，很多C++开发人员在软件调试及异常排查方面都比较欠缺，甚至有时会直接影响工作效率和项目进度！
📢 所以决定推出这方面成体系的技术专栏，希望能有效地解决大家的痛点问题！
专栏文章还在持续更新 ing… 如果文章有用，可以点赞、收藏、关注，也可以订阅专栏！
🌾 通过对项目实战问题中的技术点及相关细节进行思考、总结及整理，可以加深对关联知识点的认知和理解，可以做更进一步的归纳与提炼，将相关的技术点高效串联起来，最后形成一套属于自己的系统完整的知识体系，这样也可以更好地服务于工作实践！多多关注细节，会有更深刻的理解和认识！
🔰 文章列表 专栏文章分以下几个部分来展开：
📢 概述篇：系统地总结了引发C++软件异常的常见原因，并给出了排查异常问题的常用方法。然后详细讲述了排查C++软件异常所需要掌握的汇编语言基础知识。根据多年的开发调试经验，分享了一些Visual Studio高效的调试手段与技巧。
📢 常用工具篇：详细地介绍了SPY++、Dependency Walker、GDIView、Process Explorer、Prcoess Monitor、API Monitor、Windbg和IDA等常用软件分析工具的使用，并给出详细的工具分析实例。
📢 异常分析基础知识篇：详细讲解了C++程序的五大内存分区、C++函数调用调用的栈分布、函数调用堆栈的栈回溯原理、C++虚函数调用的汇编代码解读、函数调用约定等与异常排查相关的基础内容。
📢 调试器Windbg使用篇：介绍了Windbg调试器及其常用命令，并详细讲解了如何使用Windbg去静态分析dump文件、如何使用Windbg进行动态调试。
📢 程序启动异常分析篇：以实际项目中遇到的问题实例，详细讲述C++程序启动异常时的分析方法。
📢 异常分析实例篇（项目问题分析实战）：以实际项目中遇到的C++软件异常实例为主线，详细讲述这些C++软件异常实例的完整分析与解决过程。
📚Part1 概述篇 ⭐️第1章：为什么要学习C++软件调试技术？掌握调试技术都有哪些好处？
功能介绍：本文系统地讲述了为什么要学习C++软件调试技术以及掌握这类技术都有哪些好处。
⭐️第2章：C++软件异常分析概述
功能介绍：本文概要性地讲述了C++软件异常的分类以及常用的排查方法。
⭐️第3章：引发C++软件异常的常见原因分析与总结
功能介绍：本文根据近几年排查C++软件异常的实践经历与实战经验，系统地总结出引发C++软件异常的常见原因，给大家提供借鉴或参考。
⭐️第4章：排查C++软件异常的常见思路与方法
功能介绍：本文系统地讲述了排查C++软件异常的常用思路与方法。
⭐️第5章：分析C++软件异常需要掌握的汇编知识汇总
功能介绍：本文详细地讲述了排查C++软件异常时所要了解及掌握的一些汇编方面的基本知识与要点。
⭐️第6章：Visual Studio高效调试手段与技巧总结
功能介绍：本文根据多年的Visual Studio使用经验，带着大家逐一认识并掌握Visual Studio多种实用的调试方法和技巧，以帮助大家去高效、快速地解决开发过程中遇到的多种问题。
⭐️第7章：Visual Studio调试方式详解
功能介绍：本文详细讲述了Visual Studio 3种常用的调试方式：Debug下调试、Release下调试及附加调试。
⭐️第8章：Windows和Linux下排查C++软件异常的常用调试器与内存检测工具详细介绍
功能介绍：本文详细讲述Windows和Linux两平台下排查C++软件异常的常用调试器与内存检测工具。
⭐️第9章：内存越界一定会导致程序崩溃吗？详解内存越界
功能介绍：本文详细解释了内存越界不一定导致内存越界的问题，全面介绍了C++内存越界的相关内容。
⭐️第10章：引发C++程序内存错误的常见原因分析与总结
功能介绍：本文全面总结了引发C++程序内存错误的常见原因。
⭐️第11章：C++程序卡死、UI界面卡顿问题的原因分析与总结
功能介绍：C++程序卡死、客户都软件的UI界面卡顿问题的原因分析与总结。
⭐️第12章：为什么要学习汇编？学习汇编有哪些好处？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0ae57e50320ea3cd14e84facef38ab7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceea1cd6b3226abeef6f654c8dd12b47/" rel="bookmark">
			gRPC-Go基础（1）基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基础简介环境搭建 基础简介 gRPC
gRPC是Google发起的、开源的、高性能远程过程调用（RPC）框架系统，该系统基于HTTP/2协议传输，使用Protocol Buffer作为接口描述语言。
在gRPC中，客户端程序可以像调用函数一样地调用不同机器上的应用程序，其客户端和服务端可以在各种gRPC支持的语言的环境之间互相通信
Protocol Buffers
Protocol Buffers是谷歌发起的开源的， 语言无关、平台无关、可扩展的序列化结构化数据的协议。其具有性能好，效率高，且具有代码生成机制的优点，gRPC默认以Protocol Buffer作为接口描述语言。
gRPC和Go
gRPC支持多种语言，其中就包括golang，有关golang和grpc相关的官方资料详见google.golang.org和grpc-go。
环境搭建 Go插件安装
protoc-gen-go插件生成xxx.pb.go，protoc-gen-go-grpc插件生成xxx_grpc.pb.go。
安装 $ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28 $ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2 更新 $ export PATH="$PATH:$(go env GOPATH)/bin" 另外，在用到gateway的项目中还需要用到protoc-gen-grpc-gateway插件，参数校验可能用到protoc-gen-validate插件等。
至此，基本的gRPC开发环境就搭建好了，接下来就可以进行gRPC的项目开发了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeac65b7fe49554de173a7340ad11236/" rel="bookmark">
			使用Dependency Walker和Process Explorer排查瑞芯微工具软件RKPQTool.exe启动报错问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、问题说明
2、使用Dependency Walker查看工具程序的库依赖关系
3、在可以运行的电脑上使用Process Explorer查看依赖的msvcr120.dll和msvcp120.dll库的路径
4、C/C++运行时库介绍
5、可以下载安装VC_redist.x86.exe或VC_redist.x64.exe解决系统库缺失问题
C++软件异常排查从入门到精通系列教程（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/125529931C/C++基础与进阶（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_11931267.htmlVC++常用功能开发汇总（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/124272585C++软件分析工具从入门到精通案例集锦（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/article/details/131405795开源组件及数据库技术（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_12458859.html网络编程与网络问题分享（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_2276111.html 安卓开发组的同事在调试使用瑞芯微主控CPU芯片的嵌入式设备（嵌入式设备使用的是Android系统）时，需要在PC上使用瑞芯微提供的一个工具软件去配置图像质量参数，但这个工具启动时会报错，无法运行。同事找到我，让我帮他们看看是怎么回事，看能否让这个工具正常跑起来。
1、问题说明 部分嵌入式设备使用的是安卓系统，两年前使用的CPU主控芯片是华为海思的，因为华为被制裁，海思芯片无法供货，所以转而使用国内二线芯片厂商的CPU芯片，最终选择的是瑞芯微。
使用了一段时间的瑞芯微CPU芯片，这些二线厂商的芯片实在是一言难尽，无论是性能，还是稳定性，亦或是功能的完备性，都和海思有较大的差距。以前能正常使用海思芯片的时候，不觉得，断供后才知道海思的芯片是真的好用！没有对比就没有伤害！
在设备调试的过程中遇到了一些问题，需要使用瑞芯微提供的软件工具去远程配置图像质量参数，但拿到工具后却运行不起来。在一台笔记本上双击该软件程序，就会弹出如下的错误：
安卓开发组的同事是专职做安卓app开发的，对Windows程序开发不太了解，于是找到我，希望我帮他们看一下，看看怎么回事，看看能否把软件运行起来。
在这里，给大家重点推荐一下我的几个热门畅销专栏：
专栏1：（该专栏订阅量接近350个，有很强的实战参考价值，广受好评！专栏文章持续更新中，预计更新到200篇以上！）
C++软件调试与异常排查从入门到精通系列文章汇总https://blog.csdn.net/chenlycly/article/details/125529931
本专栏根据近几年C++软件异常排查的项目实践，系统地总结了引发C++软件异常的常见原因以及排查C++软件异常的常用思路与方法，详细讲述了C++软件的调试方法与手段，以图文并茂的方式给出具体的实战问题分析实例，带领大家逐步掌握C++软件调试与异常排查的相关技术，适合基础进阶和想做技术提升的相关C++开发人员！
专栏中的文章均是通过项目实战总结出来的（通过项目实战积累了大量的异常排查素材和案例），有很强的实战参考价值！专栏文章还在持续更新中，预计文章篇数能更新到200篇以上！
专栏2： C/C++基础与进阶（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_11931267.html
以多年的开发实战为基础，总结并讲解一些的C/C++基础与进阶内容，以图文并茂的方式对相关知识点进行详细地展开与阐述！专栏涉及了C/C++领域的多个方面的内容，同时给出C/C++及网络方面的常见笔试面试题，并详细讲述Visual Studio常用调试手段与技巧！
专栏3： 开源组件及数据库技术https://blog.csdn.net/chenlycly/category_12458859.html
以多年的开发实战为基础，分享一些开源组件及数据库技术！ 2、使用Dependency Walker查看工具程序的库依赖关系 我们做Windows开发的，对这个报错提示框比较熟悉，这个是因为这个软件工具依赖了msvcr120.dll，但在出问题的笔记本上找不到这个库。程序启动时，会先将依赖的dll库加载到进程空间中，等所有依赖的库加载到进程空间中后，就会将主程序运行起来。如果在加载依赖的库在系统找不到时，就会报类似下面的错误：
除了这个库，可能还缺少其他库，可以直接将查看库依赖关系的Dependency Walker拷贝到这台无法运行的电脑上，直接用该工具查看exe主程序依赖的哪些库在该机器上找不到。
在本例中，我们将Dependency Walker拷贝到笔记本上，并将之双击运行起来，然后将软件工具的exe主程序文件RKPQTool.exe拖到Dependency Walker中，等待Dependency Walker打开完成。
Dependency Walker打开exe主程序后，会以树状结构将exe主程序依赖的库以及这些库依赖的其他库展示出来。默认情况下，会自动将树中的节点全部展开。
注意一下，当前最新的Dependency Walker还是2016年的，当运行在Win10等新的系统中时，打开文件可能会比较慢，甚至要等好几分钟才能打开完成，要稍微耐心等待一下。
在展开的树中，节点太多，除了软件的业务库，还包含大量的Windows系统库，为了方便查看，我们可以将系统库的节点给折叠起来。这就要求我们要识别出来哪些库是系统库，比如常见的user32.dll、ntdll.dll、kernel32.dll，还有以API-MS-WIN开头的系统库：
这对于经常搞Windows软件开发的人很简单，但对于新手或者不熟悉Windows软件开发的人来说，可能很难分辨。
在Dependency Walker中，如果库找不到或者库中的接口有问题，问题节点前面会显示特别的异常图标：
1）在运行的机器中找不到某个库，会在该库的节点前显示一个黄色的问号图标，如下所示：
这可能是打包软件时，没有将程序依赖的库打包进安装包中。比如忘记将一个新增的dll库打包到安装包中、没有将运行时库打包到安装包中。注意，不同版本的Visual Studio使用的运行时库名称是不一样的，比如Visual Studio 2010的运行时库是msvcr100.dll和msvcp100.dll，Visual Studio 2017的运行时库是msvcp140.dll、vcruntime140.dll和ucrtbase.dll（不再有msvcr140.dll、新增了vcruntime140.dll和ucrtbase.dll）。
使用Visual Studio编译出来的程序，在打安装包时都需要把对应版本的运行时库打包进去。关于不同Visual Studio版本对应的运行时库的详细说明，可以参见我的文章：
使用Dependency Walker和Process Explorer排查程序启动时缺少ucrtbase.dll等运行时库以及报0xC000007B错误https://blog.csdn.net/chenlycly/article/details/131505299此外，很多系统库节点前面也会显示一个黄色的问号图标，这些系统库一般可以忽略掉，不用管。
2）在某个库中找不到调用的接口，会在对应的接口行前面显示一个红色的图标，如下所示：
可能这个接口在库中已经不存在了（被删除了），也可能是接口的参数修改了，生成的函数符号变了。
在本案例中，我们将系统库折叠起来之后，看到了如下的结果：
我们从上图中可以看出，依赖的两个库msvcr120.dll和msvcp120.dll在这台笔记本上找不到。
3、在可以运行的电脑上使用Process Explorer查看依赖的msvcr120.dll和msvcp120.dll库的路径 上述工具软件缺少msvcr120.dll和msvcp120.dll两个库，这两个是微软IDE开发工具Visual Studio 2013自带的运行时库，使用Visual Studio 2013开发的程序会依赖这两个库，在程序发布时需要将这两个运行时库带上的（放置在exe主程序的同级目录中）。当前RKPQTool工具是瑞芯微开发并提供的，应该是瑞芯微在打包程序时把这两个库带上的，结果没带上，这点确实不太专业。可能他们是做硬件的公司，软件这块做的比较少。
将RKPQTool工具拷贝到我们的开发机器上，是可以正常运行的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aeac65b7fe49554de173a7340ad11236/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/922a31a4d8ab3c23fba7f5bd365213b0/" rel="bookmark">
			云原生Kubernetes：K8S集群版本升级(v1.22.14 - v1.23.14)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、理论
1.K8S集群升级
2.环境
3.升级集群（v1.23.14）
4.验证集群（v1.23.14）
二、实验
1. 环境
2.升级集群（v1.23.14）
2.验证集群（v1.23.14）
一、理论 1.K8S集群升级 （1）概念
搭建K8S集群的方式有很多种，比如二进制，kubeadm，RKE（Rancher）等，K8S集群升级方式也各有千秋，目前准备使用kubeadm方式搭建的k8s集群升级方法。
需要注意的是，升级集群版本建议逐步升级，比如v1.20.4–&gt;v1.21.4–&gt;v1.22.4–&gt;v1.23.4–&gt;v1.24.4，不能跨度过大，否则会报错。
2.环境 （1）主机
表1 主机
主机架构当前版本目标版本IPmaster1K8S master节点v1.22.14v1.23.14192.168.204.180master2K8S master节点v1.22.14v1.23.14192.168.204.181node1K8S node节点v1.22.14v1.23.14192.168.204.182 3.升级集群（v1.23.14） 升级策略为直接升级到v1.23.14
v1.22.14–&gt;v1.23.14
（1）确定升级版本
可以看到目前的版本是v1.22.14。
kubectl get nodes # 查看集群版本 NAME STATUS ROLES AGE VERSION master1 Ready control-plane,master 95d v1.22.14 master2 Ready control-plane,master 95d v1.22.14 node1 Ready worker 95d v1.22.14 # 执行如下命令确定升级版本 yum list --showduplicates kubeadm --disableexcludes=kubernetes 我的目标版本是1.23.14-0。
（2）升级Master
①所有 master 节点操作
# 升级kubeadm yum install -y kubeadm-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/922a31a4d8ab3c23fba7f5bd365213b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f652176737d83bf78b43928b4940dad9/" rel="bookmark">
			记录Postman接口测试，配置token为全局变量，配置测试环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要进行接口测试： 因为不同端（前段，后端）的工作进度不一样，所以我们要针对最开始出来的接口，以及需要调用其他公司的（银行，支付宝，微信，qq等）一些接口进行接口测试及验证数据，从安全层面来说，只依赖前端进行限制已经完全不能满足系统的安全要求（绕过前面实在太容易），需要后端同样进行控制，在这种情况下就需要从接口层面进行验证。前后端传输、日志打印等信息是否加密传输也是需要验证的，特别是涉及到用户的隐私信息，如身份证，银行卡等。
举两个实例来说明接口测试的运用：
1、比如你在web前段创建一个用户，提示创建失败，这个时候其实你可以直接抛出bug，但是你用接口创建用户，发现是可以创建，此时可以将bug定位为前端的问题
2、如果你们公司前端和后端的开发进度不一致，此时你就可以用postman先做接口测试一下这些功能
先认识一下postman的界面功能： ①：这里这些功能就很简单了，都是一些简单的英文，字面意义就可以理解，不做解释，平时测试用的话就直接new collection就可以了，然后在collection里面添加接口
②：这里可以直接创建一个接口，但是这个接口没有所属collection，所以在Ctrl+s的时候选择将接口save到哪个collection中
③：这里代表的是选择测试环境，前提是你设置好了环境，没有设置的话就是默认显示 no environment，一般这里我都是设置测试环境的，就比如将接口基地址放在环境里面
④：第四部分是选择请求方法，对于请求方法是用哪个不是我决定的，而是看接口文档上怎么约定的，选择对应的请求方法才可以正确的去测试该接口
⑤：第五部分就是接口地址了也可以叫请求头，接口地址可以是接口文档获取，也可以是抓包获取
⑥：第六部分是请求体，请求体里面有各种不同的数据类型，根据接口文档的需求选择对应正确的请求体格式
⑦：响应体里面是接口返回的数据，返回的内容是是后端给出的，同样响应体的数据也是检验该接口的正确性
postman配置一些测试环境 1.配置环境变量，也就是“no environment”这一下拉框 第一步：点击这个“眼睛”的图案，在点击edit
第二步：
2.配置token为全局变量，也就是后置处理器 第一步：在登录接口的Tests里面添加一小段代码，获取响应体里的token并设置为全局变量（代码仅供参考，不会的可以问开发），token有效期一般为10分钟（可以百度搜索一下JWT，去了解token的一些机制），超过时间之后需要重新再登录一次。
获取到的token可以在environment里面看到，在global这一栏里面：
第二步：编辑collection接口集，使其token应用于整个接口集中，完成了这几步操作之后，只要登录了一次服务器，拿到token之后，在规定时间内，该接口集里面的所有接口都可以正常运行。
举例一条配置好所有环境的成功执行的接口测试用例（仅供参考）： ①：代表的是测试环境，如果不手动去配置的话，显示的No Environment，配置测试环境的好处就在于，假如有多个测试服务器，并且某些接口集是通用的，此时我就可以不用在通用的接口集里面逐个去修改url，只需要将测试环境切换就可以了。
②：代表该接口的接口地址，我上面是因为将https://172.16.99.1/api/v1这个接口基地址配置在了测试环境中，并且设定变量名为“url”
③：代表的是请求方法，具体用什么方法需要根据接口文档来定
④：代表该接口的请求体，请求体的具体内容需要根据接口文档来
⑤：JSON代表数据格式，
⑥：response代表接口的响应内容。接口是成功与否都会在这显示出来。
简单的一些报错怎么处理 这个错误是代表没有权限，一般这种情况就分为两种原因，一种是因为token失效了，解决方法很简单，只需要重新登录一次就可以了。另一种原因是你拿到了token，但是你这个接口不在配置好的接口集里面，所以无法使用到你获取的token，解决方式只要把这个接口放到已经配置好token的接口集里面即可
API约定： HTTP Method 行为约定
GET 查询请求，通常是获取单个数据或所有数据
POST 创建请求
PUT 更改请求
DELETE 删除请求
参数传递
GET: URL传递
POST: 内容传递
PUT: 内容传递
DELETE: URL传递
HTTP Code
200: 操作被接受并执行，具体业务状态代码需根据返回结构进一步判定
302: 资源重定向，需按新地址访问
400: 请求无效，需检查请求体
401: Token无效或过期
403: 权限不足，Token有效但权限不足
500: 服务器内部错误
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f652176737d83bf78b43928b4940dad9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2382d5d53d43ccea411b612d5c45f7f5/" rel="bookmark">
			接口文档设计的12个注意点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们做后端开发的,经常需要定义接口文档。
最近在做接口文档评审的时候，发现一个小伙伴定义的出参是个枚举值，但是接口文档没有给出对应具体的枚举值。其实，如何写好接口文档，真的很重要。今天我给你带来接口文档设计的12个注意点~
1. 你的接口名称是否清晰？ 换句话说，你的接口是做什么的，是否易懂清晰？一般接口url也要求能看得出接口的作用。比如说，查询用户信息（queryUserInfo），就是一个不错的接口名称。
2. 你的接口地址是否完整 接口的地址，也叫接口的URL地址。即别人调用你的接口，用的是什么URL。比如/api/user/queryUserInfo就是一个接口地址。但是，我想说的是，这还不是一个完整的接口地址。你的接口是不是HTTP调用呢？
如果是HTTP调用的话，域名是什么呢？端口呢。一个好的http接口地址，应当是这样的：
https//tianluo.com:15000/api/user/queryUserInfo
3.你的接口请求方式是否正确 接口请求方式通常有以下几种：
GET：从服务器获取资源，可以在URL中传递参数，通常用于查询数据。
POST：向服务器提交数据，通常用于新增、修改、删除等操作。
PUT：向服务器更新资源，通常用于更新数据。
DELETE：从服务器删除资源，通常用于删除数据。
PATCH：向服务器局部更新资源，通常用于修改部分数据。
HEAD：类似于GET请求，但是只返回响应头，不返回实体内容，通常用于获取资源的元信息。
OPTIONS：请求服务器返回支持的请求方式等信息，通常用于客户端与服务端协商请求方式。
你定义接口文档的时候，需要写清楚，你的接口请求方式是哪一个？一般情况下，我们用POST和GET比较多。也有些公司的所有接口都用POST请求。
4.请求参数的8大要素 我们定义接口的时候,请求参数是最主要的部分之一。一份合格的接口文档,请求参数应当包含这八大要素:
参数名: 参数的名字,都是驼峰命名，比如userId。
类型: 参数的类型,比如String、Integer等。
是否必填: 请求参数是不是必填的，如果要求必填的，当上游不传这个参数的时候，应当抛参数校验异常。
默认值: 如果这个参数不传，是否有默认值，默认值是多少。
取值范围: 如果是Long，Integer等数值类型的话，这个就是一个范围值，比如1~10， - 如果是枚举值的话，那就是枚举范围，比如ACTIVE、INACTIVE。
参数格式：比如你的参数是个日期的话，就需要说明参数格式，如yyyyMMdd
入参示例值: 提供该响应参数的示例值，以便开发人员更好地理解和使用该参数。
备注: 如果这个入参字段有特殊说明的话，可以在这一栏说明。如果没有特殊说明，那只描述这个参数作用也可以。
以下就是入参的文档样例：
5.响应参数的7大要求 响应参数其实跟入参差不多，有7种要素：
参数名称：描述该响应参数的名称。
参数类型：描述该响应参数的数据类型，如String、Integer等。
参数格式：描述该响应参数的数据格式，如yyyy-MM-dd、HH:mm:ss等。
参数说明：对该响应参数的含义进行详细的描述。
取值范围：描述该响应参数的取值范围，如整数范围、字符串长度等。
是否必填：描述该响应参数是否为必填项。
示例值：提供该响应参数的示例值，以便开发人员更好地理解和使用该参数。
不一样的地方是，响应参数，一般都是按照code，msg，data的格式返回的：
{ "code": 0, "message": "success", "data": { "name": "Tom", "age": 20, "gender": "男" } } 6. 接口错误码 一份好的接口文档，一定少不了错误码列举。一般错误码定义包括三列：错误码、错误码信息、含义
7.接口安全 定义接口文档时，对于一些需要保护的接口，也需要考虑接口的安全，例如权限管理、防止 SQL 注入等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2382d5d53d43ccea411b612d5c45f7f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/851f886b25b1e040cba8355a108ad723/" rel="bookmark">
			ARAM 中断实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路：按键-&gt;EXTI-&gt;GIC-&gt;CPU-&gt;异常向量表
//使能GPIOF时钟
//设置PF9管脚为输入(KEY1)
//设置PF9作为EXTI9事件的输入(事件编号对应管脚号)
//设置下降沿使能检测EXTI9事件 (也可设置上升沿没有下降沿严谨方便,不同场景不同选择)
//设置EXTI9事件不屏蔽 (只有不屏蔽中断事件才能继续执行)
//GICD使能EXTI9（99号）中断 (给中断信号使能)
//GICD 设置99号中断的优先级 (中断信号的优先级要设置的高)
//选择CPU0处理当前中断
//全局使能组0中断被转发到GICC (在组0 组1 选择 组0)
//设置中断的优先级掩码 （让掩码的优先级降到最低，使自己的中断优先级高于他）
//允许组0中断被CPU处理
irq就是IRQ中断
key_it.h
#ifndef __KEY_IT_H__ #define __KEY_IT_H__ #include"stm32mp1xx_gpio.h" #include"stm32mp1xx_gic.h" #include"stm32mp1xx_exti.h" #include"stm32mp1xx_rcc.h" #include "led.h" void key1_it_config(); void key2_it_config(); void key3_it_config(); void delay(int ms); #endif key_it.c
#include"key_it.h" void key1_it_config() { //使能GPIOF时钟 RCC-&gt;MP_AHB4ENSETR |= (0x1&lt;&lt;5); //设置PF9管脚为输入 GPIOF-&gt;MODER &amp;= (~(0x3&lt;&lt;18)); //设置PF9作为EXTI9事件的输入 EXTI-&gt;EXTICR3 &amp;= (~(0x1f&lt;&lt;8)); EXTI-&gt;EXTICR3 |= (0x05&lt;&lt;8); //设置下降沿使能检测EXTI9事件 EXTI-&gt;FTSR1 |= (0x1&lt;&lt;9); //设置EXTI9事件不屏蔽 EXTI-&gt;C1IMR1 |= (0x1&lt;&lt;9); //GICD使能EXTI9（99号）中断 GICD-&gt;ISENABLER[3] |= (0x1&lt;&lt;3); //GICD 设置99号中断的优先级 GICD-&gt;IPRIORITYR[24] &amp;= (~(0x1f&lt;&lt;27)); //选择CPU0处理当前中断 GICD-&gt;ITARGETSR[24] |= (0x1&lt;&lt;24); //全局使能组0中断被转发到GICC GICD-&gt;CTRL |= (0X1); //设置中断的优先级掩码 GICC-&gt;PMR |= (0x1f&lt;&lt;3); //允许组0中断被CPU处理 GICC-&gt;CTRL |= (0x1); } void key2_it_config() { //使能GPIOF时钟 RCC-&gt;MP_AHB4ENSETR |= (0x1&lt;&lt;5); //设置PF7管脚为输入 GPIOF-&gt;MODER &amp;= (~(0x3&lt;&lt;14)); //设置PF7作为EXTI7事件的输入 EXTI-&gt;EXTICR2 &amp;= (~(0x1f&lt;&lt;24)); EXTI-&gt;EXTICR2 |= (0x05&lt;&lt;24); //设置下降沿使能检测EXTI7事件 EXTI-&gt;FTSR1 |= (0x1&lt;&lt;7); //设置EXTI7事件不屏蔽 EXTI-&gt;C1IMR1 |= (0x1&lt;&lt;7); //GICD使能EXTI7（97号）中断 GICD-&gt;ISENABLER[3] |= (0x1&lt;&lt;1); //GICD 设置97号中断的优先级 GICD-&gt;IPRIORITYR[24] &amp;= (~(0x1f&lt;&lt;11)); //选择CPU0处理当前中断 GICD-&gt;ITARGETSR[24] |= (0x1&lt;&lt;8); //全局使能组0中断被转发到GICC GICD-&gt;CTRL |= (0X1); //设置中断的优先级掩码 GICC-&gt;PMR |= (0x1f&lt;&lt;3); //允许组0中断被CPU处理 GICC-&gt;CTRL |= (0x1); } void key3_it_config() { //使能GPIOF时钟 RCC-&gt;MP_AHB4ENSETR |= (0x1&lt;&lt;5); //设置PF8管脚为输入 GPIOF-&gt;MODER &amp;= (~(0x3&lt;&lt;16)); //设置PF8作为EXTI8事件的输入 EXTI-&gt;EXTICR3 &amp;= (~(0x1f)); EXTI-&gt;EXTICR3 |= (0x05); //设置下降沿使能检测EXTI8事件 EXTI-&gt;FTSR1 |= (0x1&lt;&lt;8); //设置EXTI8事件不屏蔽 EXTI-&gt;C1IMR1 |= (0x1&lt;&lt;8); //GICD使能EXTI8（98号）中断 GICD-&gt;ISENABLER[3] |= (0x1&lt;&lt;2); //GICD 设置98号中断的优先级 GICD-&gt;IPRIORITYR[24] &amp;= (~(0x1f&lt;&lt;19)); //选择CPU0处理当前中断 GICD-&gt;ITARGETSR[24] |= (0x1&lt;&lt;16); //全局使能组0中断被转发到GICC GICD-&gt;CTRL |= (0X1); //设置中断的优先级掩码 GICC-&gt;PMR |= (0x1f&lt;&lt;3); //允许组0中断被CPU处理 GICC-&gt;CTRL |= (0x1); } do_irq.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/851f886b25b1e040cba8355a108ad723/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/895282cf3eae40ccdb465853320d4d69/" rel="bookmark">
			同步异步怎么理解的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		同步（Synchronous）和异步（Asynchronous）是计算机科学中描述事件或操作之间的执行顺序和等待机制的术语。它们主要用于描述程序或程序的某些部分是否在等待某些操作完成时阻塞（等待 CPU 资源）或者继续执行其他任务。
同步（Synchronous）：
当一个操作正在执行时，其他操作必须等待它完成才能开始执行。换句话说，事件或操作之间具有固定的顺序。同步操作通常会阻塞执行，直到它们完成。这意味着，如果一个操作需要很长时间才能完成，那么其他操作可能会被迫等待，直到该操作完成。
异步（Asynchronous）：
在异步操作中，一个操作可以在另一个操作执行时同时进行。当一个异步操作开始时，其他操作不需要等待它完成。异步操作通常不会阻塞执行。这意味着，如果一个操作需要很长时间才能完成，其他操作可以在此期间继续执行。
举个例子：
同步操作：当你在餐厅用餐时，你需要等待服务员为你准备好食物，然后才能开始用餐。在这个过程中，你不能同时与朋友聊天或处理其他事务。
异步操作：如果餐厅提供外卖服务，你可以在等待外卖的过程中与朋友聊天或处理其他事务。当外卖送达时，你再去处理食物。
同步和异步操作在编程中非常重要，因为它们影响程序的性能、响应能力和资源利用率。在处理耗时操作（如文件读写、网络请求等）时，使用异步操作可以提高程序的执行效率和用户体验。
文件读写操作中，异步操作通常比同步操作更好，原因如下：
避免阻塞：同步文件读写操作会导致程序在操作执行期间阻塞，无法执行其他任务。这在处理大量数据或慢速设备（如网络存储设备）时可能导致显著的性能下降。而异步文件读写操作允许程序在等待操作完成时继续执行其他任务，从而提高整体执行效率。
提高响应能力：同步操作可能导致程序在执行文件读写任务时无法响应其他事件（如用户输入、其他资源加载等）。这会导致应用程序在执行文件读写操作时出现明显的延迟和卡顿。异步操作可以使程序在等待文件读写完成时继续处理其他事件，从而提高程序的响应能力。
更好的资源利用：在处理多个文件读写请求或执行其他并行任务时，异步操作允许程序更有效地利用系统资源。同步操作可能会导致资源闲置，因为在等待一个操作完成时，其他资源无法被利用。而异步操作可以让程序在等待某个操作完成的同时继续执行其他任务，从而充分利用系统资源。
支持现代编程模式：异步操作通常与现代编程模式和框架（如事件驱动、协程、异步编程库等）相结合，可以使开发人员更容易地编写高效、可扩展和可维护的代码。同步操作可能会导致代码变得复杂，难以理解和维护。
总之，在处理文件读写操作时，使用异步操作可以提高程序的性能、响应能力和资源利用率，并使开发过程更加高效。然而，在某些简单的场景中，同步操作可能更易于实现和理解。在选择同步还是异步操作时，需要根据具体需求和场景进行权衡。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0347d397c03a1374c30c998e46eef8c4/" rel="bookmark">
			Sublime Text 4 中文汉化教程（Version: Build 4169）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sublime Text 4汉化 1 知识小课堂1.1 sublim简介1.2 其他编辑器 2 安装过程2.1 安装Install Package Control2.2 Install Package2.3 安装工具包2.4 常用的插件2.5 安装中文包 1 知识小课堂 1.1 sublim简介 Sublime是一款代码编辑器，致力于为开发人员提供快速、高效、特性丰富的代码编辑环境。它支持多种编程语言，包括但不限于Python、JavaScript、Ruby、HTML、CSS等。Sublime拥有一套强大的插件系统，允许开发人员自定义编辑器的外观和行为，包括自动完成、语法高亮、代码拆分、代码注释等，极大地提高了开发人员的编码效率和质量。
Sublime的功能包括但不限于：
Goto Anything功能：使用这个功能可以快速地在当前项目中查找任何文件或符号。Multiple Selection功能：这个功能允许用户在多个位置进行选择和编辑，提高了处理大量代码的效率和精确度。拼写检查功能：可以帮助用户在编写代码时避免拼写错误。书签功能：允许用户在文件中设置书签，以便快速跳转到特定的位置。完整的Python API：这意味着用户可以通过Python脚本来扩展Sublime的功能。即时项目切换功能：这个功能允许用户在多个项目中快速切换。多窗口功能：允许用户同时打开多个Sublime窗口，方便同时编辑多个文件。自动保存功能：Sublime可以自动保存用户的代码，避免了因突然断电或程序崩溃造成的数据丢失。 此外，Sublime的界面非常简洁易用，所有的鼠标操作都可以用键盘替代。而且，Sublime可以在不同行的相同位置上进行选择，让用户可以一次性对多个代码块进行修改。
1.2 其他编辑器 Visual Studio Code（VS Code）：VS Code是微软开发的一套免费、轻量级、功能强大的源代码编辑器工具。它支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比、Diff、GIT等特性，并针对网页开发和云端应用开发做了优化。Source Insight：一款功能强大的代码编辑器、浏览器和分析器，可在代码编辑时快速理解代码。同时，它具有针对C/C++、C#、Java、Objective-C等语言的动态分析功能。VIM：一个可高度自由配置的文本编辑器，是Vi编辑器的改进版，同时也是免费软件。它允许编辑文本并保存简单的文本文件，但它的主要功能还是编辑代码。它支持语法高亮显示和行编号，这是写程序必备的两个基本功能。用户也可以改变界面颜色以便增加代码的可视性。GNU Emacs：一个可移植、可扩展、免费的文本编辑器。 2 安装过程 2.1 安装Install Package Control 安装 Sublime Text 4 成功后，点击菜单 【Tools】 -&gt; 【Install Package Control】；
注意：安装包控件需要等待一会，点击可能出现没有反应的情况，耐心等待弹窗即可！
2.2 Install Package 点击菜单 【Preferences】 -&gt; 【Package Control】-&gt; 选择【Install Package】;
2.3 安装工具包 输入关键词【Install Package】，即可看到中文安装包，点击即可安装！
左下角在更新安装信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0347d397c03a1374c30c998e46eef8c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee2e6c0a0650e29a69a8edf0dcc2d1f5/" rel="bookmark">
			算符优先语法分析设计原理与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 作者的词法分析程序以及算符优先语法分析设计程序仓库链接
1、目标任务
**[实验项目] **以专题 1 词法分析程序的输出为语法分析的输入，实现算符优先分析算法，完成以下描述算术表达式的算符优先文法的算符优先分析过程。
G[E]:E→E+T∣E-T∣T T→T*F∣T/F∣F F→(E)∣i [设计说明] 终结符号 i 为用户定义的简单变量,即标识符的定义。
**[设计要求] **（1）构造该算符优先文法的优先关系矩阵或优先函数；（2）输入串应是词法分析的输出二元式序列，即某算术表达式“专题 1”的输出结果。输出为输入串是否为该文法定义的算术表达式的判断结果。（3）算符优先分析过程应能发现输入串出错。（4）设计至少四个测试用例（尽可能完备，正确和出错），并给出测试结果；
优先关系矩阵的构造如下图所示：
程序功能描述：
程序的功能是执行算符优先分析，用于对给定的表达式进行语法分析。它基于算符优先算法来确定表达式中运算符的优先级和结合性，以此进行语法分析。主要步骤包括：
读取输入表达式: 从名为 “test.txt” 的文件中读取表达式。预处理: 将读取的表达式中的变量和常量替换为 ‘i’ 符号，得到用于分析的表达式。算符优先级分析: 使用算符优先算法对表达式进行分析。分析过程: 逐步检查表达式中的运算符优先级，利用预先定义的优先级矩阵和语法规则来判断是否存在语法错误或可以规约的部分。输出结果: 根据分析结果，程序会输出语法分析的结果，指出是否表达式符合定义的语法规则。 主要数据结构描述：
map&lt;char, map&lt;char, char&gt;&gt; priorityMatrix: 这是一个嵌套的 map 结构，用于表示算符之间的优先关系。外部的 char 表示当前栈顶运算符，内部的 map&lt;char, char&gt; 表示当前输入运算符和栈顶运算符的优先级关系。map&lt;string, char&gt; grammer: 这个 map 结构定义了语法规则，将字符串作为键，将对应的非终结符作为值。它表示了规约过程中可以使用的规则。vector Vt: 包含终结符号的向量。这里存储了表达式中可能出现的所有终结符号。vector Vn: 包含非终结符号的向量。这个向量包含了在语法规则中用于推导的非终结符号。vector s: 这是模拟的分析栈，用于存储算符优先分析过程中的中间状态。 程序结构描述：
函数定义和其功能：
readFile():
从文件 “test.txt” 中读取输入的表达式。 对读取的表达式进行预处理，将变量和常量替换为 ‘i’ 符号。返回预处理后的表达式字符串。 OperatorPrecedenceAnalysis(string&amp; str):
实现算符优先语法分析的核心逻辑。接收一个字符串作为输入，对其进行算符优先分析。利用优先级矩阵和语法规则进行分析，判断是否符合语法规则，返回分析结果（true/false）。 reduce(string&amp; temp):
用于在分析过程中进行规约操作。根据规约的临时字符串，在语法规则中查找对应的规约字符。 isVt(char ch) 和 isVn(char ch):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee2e6c0a0650e29a69a8edf0dcc2d1f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d4c961cf108dbf43af6eb288bc72db5/" rel="bookmark">
			【JavaWeb学习笔记】17 - ThreadLocal
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目代码 https://github.com/yinhai1114/JavaWeb_LearningCode/tree/main/threadlocal/src/com/yinhai/thread
目录
项目代码
一、什么是ThreadLocal?
二、ThreadLocal快速入门
三、源码解读
一、什么是ThreadLocal? 1. ThreadLocal的作用，可以实现在同一个线程数据共享从而解决多线程数据安全问题。
2. ThreadLocal可以给当前线程关联一个数据(普通变量、对象、数组)set方法
3. ThreadLocal可以像Map一样存取数据，key为当前线程, get方法
4.每一个ThreadLocal对象，只能为当前线程关联一个数据， 如果要为当前线程关联多个数据，就需要使用多个ThreadLocal对象实例
5.每个ThreadLocal对象实例定义的时候，一般为 static类型
6. ThreadLocal中保存数据，在线程销毁后，会自动释放
二、ThreadLocal快速入门 T1类 package com.yinhai.thread; import com.sun.javafx.tk.Toolkit; /** * @author 银小海 * @version 1.0 * @email yinhai14@qq.com */ public class T1 { //创建ThreadLocal对象 做成static public static ThreadLocal&lt;Object&gt; threadLocal1 = new ThreadLocal&lt;&gt;(); //Task是线程类 是内部类 public static class Task implements Runnable{ @Override public void run() { Dog dog = new Dog(); Pig pig = new Pig(); //给threadLocal1对象放入set dog System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d4c961cf108dbf43af6eb288bc72db5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/16/">«</a>
	<span class="pagination__item pagination__item--current">17/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/18/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>