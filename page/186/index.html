<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb0d842df474e6af5ed9cb988ee912c8/" rel="bookmark">
			登录拦截设置白名单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求： 登录拦截的时候我们一般会写一个permision.js放在main.js中，当页面每登录的时候会跳转到登录页面
代码如下：permision.js
// 权限拦截 导航守卫 路由守卫 router import router from '@/router' // 引入路由实例 import store from '@/store' // 引入vuex store实例 import NProgress from 'nprogress' // 引入一份进度条插件 import 'nprogress/nprogress.css' // 引入进度条样式 const whiteList = ['/login', '/404'] // 定义白名单 所有不受权限控制的页面 // 路由的前置守卫 router.beforeEach(function(to, from, next) { NProgress.start() // 开启进度条 // 首先判断有无token if (store.getters.token) { // 如果有token 继续判断是不是去登录页 if (to.path === '/login') { // 表示去的是登录页 next('/') // 跳到主页 } else { next() // 直接放行 } } else { // 如果没有token if (whiteList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb0d842df474e6af5ed9cb988ee912c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58784990addbd9b4dca3cc7688e04042/" rel="bookmark">
			C#常用加密解密方法（DES加密解密）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常开发过程中，总会遇到需要加密解密的需求，这里我整理了C#常用的加密解密方法分享给大家。
先看看加密的基本概念：
"加密"，是一种限制对网络上传输数据的访问权的技术。原始数据（也称为明文，plaintext)被加密设备(硬件或软件)和密钥加密而产生的经过编码的数据称为密文（ciphertext）。将密文还原为原始明文的过程称为解密，它是加密的反向处理，但解密者必须利用相同类型的加密设备和密钥对密文进行解密。
加密的基本功能包括:
1. 防止不速之客查看机密的数据文件；
2. 防止机密数据被泄露或篡改；
3. 防止特权用户(如系统管理员)查看私人数据文件；
4. 使入侵者不能轻易地查找一个系统的文件。
一、本节摘要 本节主要分享DES加密解密：
DES，全称Data Encryption Standard，是一种对称加密算法。由于其安全性比较高（有限时间内,没有一种加密方法可以说是100%安全）,很可能是最广泛的密钥系统（我们公司也在用，估计你们也有在用....），唯一一种方法可以破解该算法，那就是穷举法。
DES(Data Encryption Standard)和TripleDES是对称加密的两种实现。
DES和TripleDES基本算法一致，只是TripleDES算法提供的key位数更多，加密可靠性更高。
DES使用的密钥key为8字节，初始向量IV也是8字节。
TripleDES使用24字节的key，初始向量IV也是8字节。
两种算法都是以8字节为一个块进行加密，一个数据块一个数据块的加密，一个8字节的明文加密后的密文也是8字节。如果明文长度不为8字节的整数倍，添加值为0的字节凑满8字节整数倍。所以加密后的密文长度一定为8字节的整数倍。
二、源码分享 using System; using System.Security.Cryptography; using System.Text; namespace Core.Common { /// &lt;summary&gt; /// DES加密/解密类。 /// &lt;/summary&gt; public class DESEncrypt { public DESEncrypt() {	} #region ========加密======== /// &lt;summary&gt; /// 加密 /// &lt;/summary&gt; /// &lt;param name="Text"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string Encrypt(string Text) { return Encrypt(Text,"MARCOPRO"); } /// &lt;summary&gt; /// 加密数据 /// &lt;/summary&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58784990addbd9b4dca3cc7688e04042/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1be7919b094f0f1733635b05ad932274/" rel="bookmark">
			.Net中ORM实现原理及常用 C# ORM框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ORM实现原理 ORM(Object Ralational Mapping，即对象关系映射)实现思想就是将关系数据库中表的数据映射成对象。
用来把对象模型表示的对象映射到基于SQL的关系模型数据库结构中去。在具体的操作实体对象的时候，就不再需要和复杂的SQL语句打交道，只需操作实体对象的属性和方法。
ORM是在对象和关系之间提供了一条桥梁，前台的对象型数据和数据库中的关系型的数据通过这个桥梁来相互转化。
ORM不仅仅管理.NET类到数据库表的映射(包括.NET 数据类型到SQL数据类型的映射)，还提供数据查询和获取数据的方法，可以大幅度减少开发时人工使用SQL和http://ADO.NET处理数据的时间。
ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象与关系数据库相互映射，用于实现面向对象编程语言里不同类型系统的数据之间的转换。
ORM可以解决数据库与程序间的异构性，比如：在C#中我们使用string表示字符串，而Oracle中可使用varchar2，MySQL中可使用varchar，SQLServer可使用nvarchar。
二、常用ORM框架
序号名称说明特点1SqlSugarSqlSugar是国人开发者开发的一款基于.NET的ORM框架，是可以运行在.NET 4+ &amp; .NET CORE的高性能、轻量级ORM框架，众多.NET框架中最容易使用的数据库访问技术。官网：https://www.donet5.com/开源、免费；国内开发者开发、维护;支持.NET Core;支持主流数据库，如：SQL Server,MySql,Oracle,Sqlite,达梦，金仓，时序数据库 等;维护更新及时；2PetaPoco轻量的POCO对象和数据库映射的ORM框架。开源、免费3linq2dblinq2db也是一款快速、轻量、类型安全的POCO对象和数据库映射的ORM框架。从构架上来说，linq2db是对比如：Dapper、PetaPoco这个的微ORM的进一步封装，但它不像Entity Framework那样笨重。它没有实现状态跟踪，需要自己处理实体的状态更改等。4Dos.ORMDos.ORM(原Hxj.Data)于2009年发布，2015年正式开源。在开发过程中参考了NBear与MySoft，吸取了他们的一些精华，加入新思想，同时参考EF的Lambda语法进行大量扩展。该组件已在数百个成熟项目中应用。官方网站：http://ITdos.com/Dos/ORM/Index.html开源、免费;上手简单，0学习成本。使用方便，按照sql书写习惯编写C#.NET代码。功能强大;高性能，接近手写Sql;体积小(不到150kb，仅一个dll);完美支持Sql Server(2000至最新版),MySql,Oracle,Access,Sqlite等数据库;支持大量Lambda表达式写法，国产ORM支持度最高，开源中国ORM排行前三;不需要像NHibernate的XML配置，不需要像EF的各种数据库连接驱动;遵循MIT开源协议，除不允许改名，其它随意定制修改;5ServiceStack.OrmLiteServiceStack.OrmLite的目标是提供一种方便，无干扰，无配置的RDBMS无关类型的封装，与SQL保持高度的契合，展现直观的API，可以生成可预测的SQL。ServiceStack.OrmLite的宗旨：Fast, Simple, Typed ORM for .NET开源、收费(免费版只支持单个库10张表)6Entity Framework (EF)http://ADO.NET Entity Framework 是微软以 http://ADO.NET 为基础所发展出来的对象关系对应 (O/R Mapping) 解决方案。该框架曾经为.NET Framework的一部分，但version 6之后从.NET Framework分离出来7NHibernateNHibernate是一个面向.NET环境的对象/关系数据库映射工具。对象/关系数据库映射(object/relational mapping，ORM)这个术语表示一种技术，用来把对象模型表示的对象映射到基于SQL的关系模型数据结构中去。开源、免费;批量写入;批量读/多重查询特性;批量的集合加载;带有lazy=”extra”的集合;集合过滤器和分页集合;二级缓存;集成和扩展性;代码自动生成，减少代码和sql的开发量，使开发人员摆脱开sql，http://ado.net和事务，缓存等底层;8Massive小巧，动态的微ORM框架。 文章来源Net码农。
希望对你有用！最后大家如果喜欢我的文章，还麻烦动动小手点个关注。你有任何与 C#/.NET 有关的问题，欢迎在评论区与我沟通，也欢迎大家加入最活跃的编程技术交流群 (.NET/WPF )与国内大部分,优质内容的作者（包括我）直接对线哈
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a0c4c25f16cf3cd7b76e20bbac34ce3/" rel="bookmark">
			SCI论文阅读-深度学习在测井气体红外光谱定量分析中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		期刊： Applied Optics中科院最新分区（2022年12月最新版）：4区影响因子（2021-2022）：1.905第一作者：宋丽梅通讯作者：Yangang Yang原文链接：Application of deep learning in quantitative analysis of the infrared spectrum of logging gas 目录
论文标题
摘要
引言
方法
A. Introduction to Infrared Spectroscopy (红外光谱学导论)
B. Introduction to Convolutional Neural Networks (卷积神经网络简介)
实验
A. Preparation of Experimental Gas (实验气体制备)
B. Spectrum Acquisition and Preprocessing (频谱采集和预处理)
C. Experiments with Elemental Gases and Mixed Gases (基本气体和混合气体的实验)
结论
论文标题 Application of deep learning in quantitative analysis of the infrared spectrum of logging gas
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a0c4c25f16cf3cd7b76e20bbac34ce3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90bb831981fc269782e60aacb2395b7e/" rel="bookmark">
			PyTorch常用代码段合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		last upate time: 2023-02-03 20:29:50
PyTorch最好的资料是官方文档。本文是PyTorch常用代码段，在参考资料[1](张皓：PyTorch Cookbook)的基础上做了一些修补，方便使用时查阅。
1. 基本配置 导入包和版本查询 import torch import torch.nn as nn import torchvision print(torch.__version__) print(torch.version.cuda) print(torch.backends.cudnn.version()) print(torch.cuda.get_device_name(0)) 可复现性 在硬件设备（CPU、GPU）不同时，完全的可复现性无法保证，即使随机种子相同。但是，在同一个设备上，应该保证可复现性。具体做法是，在程序开始的时候固定torch的随机种子，同时也把numpy的随机种子固定。
np.random.seed(0) torch.manual_seed(0) torch.cuda.manual_seed_all(0) torch.backends.cudnn.deterministic = True torch.backends.cudnn.benchmark = False 显卡设置 如果只需要一张显卡
#Device configuration device = torch.device('cuda' if torch.cuda.is_available() else 'cpu') 如果需要指定多张显卡，比如0，1号显卡。
import os os.environ['CUDA_VISIBLE_DEVICES'] = '0,1' 也可以在命令行运行代码时设置显卡：
CUDA_VISIBLE_DEVICES=0,1 python train.py 清除显存
torch.cuda.empty_cache() 也可以使用在命令行重置GPU的指令
nvidia-smi --gpu-reset -i [gpu_id] 2. 张量(Tensor)处理 张量的数据类型 PyTorch有9种CPU张量类型和9种GPU张量类型。
张量基本信息 tensor = torch.randn(3,4,5) print(tensor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90bb831981fc269782e60aacb2395b7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44bf725ecc4a642cb67e9db20d79dfca/" rel="bookmark">
			3.路径规划算法解析及实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		星火计划2.0基础课：https://apollo.baidu.com/community/online-course/2
星火计划2.0专项课：https://apollo.baidu.com/community/online-course/12
APOLLO中Planning主要分为两个步骤：
首先进行路径规划，然后进行速度规划。对于路径规划主要是针对于静态环境的规划，比如道路、静止或低速的障碍物，会产生对障碍物进行绕行的路径；对于速度规划，主要是针对于动态环境的规划，比如道路中中高速的障碍物，会对障碍物产生绕行或超越。主路的规划算法任务配置在lane_follow_config.pb.txt这个配置文件中，该配置文件首先进行路径规划，即红框中内容，其中所有以DECIDER为结尾的，都是Apollo中的决策器，所有以OPTIMIZER为结尾的都是Apollo中的优化器。路径规划和速度规划每个又分为两个部分，一个是决策和优化，先进行路径决策再进行路径优化，先进行速度决策，再进行速度优化。
现在来具体讲一下其中每一个task是做什么的:
第一个Task是LANE_CHANGE_DECIDER,主要是换道的决策，首先会判断由参考线生成器产生的参考线的数量，如果只有一条参考线就不会进行换道，如果参考线生成器产生多条的参考线，还会继续判断换道的条件，比如车辆的前方和后方有没有障碍物，或者旁边车道有没有障碍物，是否达到了换道的距离，当所有条件满足后，里面会产生一个换道的决策。
第二个Task是PATH_REUSE_DECIDER是路径重用的决策，主要可以判断是否可以重用上一帧的路径，因为路径规划中每一帧都在进行规划，假如感知到障碍物边界不稳定，那么每一帧规划路径会随着障碍物的边界会上下跳动，这样会带来的问题就是行驶上的不稳定，路线也会跟着障碍物进行上下跳动。所以Apollo设计了一种路径重用的决策，如果上一帧路径没有与障碍物发生碰撞就会复用上一帧的路径，这样就不会进行上述的重新路径规划了，会直接跳到速度规划部分，如果上一帧路径和障碍物存在碰撞，就会进行重新路径规划。
第三个Task是PATH_BORROW_DECIDER是否借道的决策，主要是处理自车道前方有一个阻挡自车行驶的障碍物的场景，它会来决策是否要借助旁边车道来进行绕行，这里决策也是要一些判断的条件，比如是否只有一条车道，如果只有一条车道就没法借道了，比如自车前方是否有左侧道路的障碍物，这个障碍物是否远离路口，如果这个障碍物离路口比较近，就不会产生一个借道的决策。这个障碍物是否是长期存在的，就避免其是一个临时停车的障碍物，这个障碍物是否是长期存在的，就排除其是一个临时停车的障碍物，以及旁边车道是实线还是虚线，当条件满足后会产生一个向左或者向右借道的决策。
下一个决策：
Task是PATH_BOUNDS_DECIDER,主要处理的是SL坐标系内确定车辆可行驶的确定边界，即路径可以走的边界范围，会利用前几个决策，产生对于每个候选路径的边界。
下一个是优化算法：
Task:PIECEWISE_JERK_PATH_OPTIMIZER对每个边界规划出一个最优的路径,规划出一条没有碰撞且平滑的路径，这个算法后面会详细的介绍。
算法会对每一个决策产生一个最优的路径，PATH_ASSESSMENT_DECIDER,会对路径进行评价，会从路径中选出一条最优的路径，最优路径的选择也是遵循一些规则，比如路径是否会对障碍物碰撞，如果会碰撞就会排除该路径；路径长度，哪一条路径更短；路径是否会停在对向车道上，哪条路径可以更早的回到自车道上。
Task是PATH_DECIDER,是对每个障碍物去赋予决策，如上图所示，对于前方障碍物选择绕行，对于左前方障碍物，选择停止。该决策主要用于速度规划上。
下面来讲解基于二次规划的路径规划算法
二次规划是用于求解目标函数为二次型的，约束为线性约束的问题。二次规划的标准型如上图所示。其中x为优化的变量，我们要求解满足最小值时的x，其是一组n维的向量，P是一个二次项的系数，其为一个正定矩阵，正定是为了保证xTPx大于0，才能有极小值点。q为n维的实数向量，A为m*n的矩阵，m是约束函数的个数，A为约束函数一次项的系数，l和u分别是m维的向量，主要是约束函数取得了上边界和下边界。
二次规划是成熟的一类优化问题，里面有很多现成的开源求解器，比如osqp，qpOASES.
对于所有二次规划问题，其设计步骤都是一样的。
首先定义优化变量(即标准型里的x)，然后设计目标函数，然后设计约束，最后代入求解器求解。
接下来看Apollo的二次规划算法是如何设计的。
首先定义优化变量，由于路径规划算法在参考线的frenet坐标系进行规划，采用，s和l分别表示沿着参考线和垂直参考线的坐标，然后将障碍物分别投影到sl坐标系上
即把S这条线拉直了，在s方向分别以固定的间隔▲s选取路径规划的点，比如s0,s1,s2…..sn-1,从0到n-1就是路径规划的长度。选取每个间隔点对应的l作为优化的变量，再将l的一阶导和二阶导也作为优化的变量，最后就会得到x(二次规划的优化向量)，其包含了三个部分：l，一阶导，二阶导
定义完优化变量，来设计目标函数：
首先来表述期望路径是什么样的：
因此可以得到目标函数：
对每个点cost求和，前面的w为对应的惩罚项。其中包含一个对三阶导的惩罚，三阶导由以下公式求得：
目标函数一次项，二次项系数(q,P)以矩阵形式表示为：
接下来讲解二次函数的约束是如何设置的：
路径规划首先要满足一些硬性的约束要求
其次要根据当前状态，满足主车的横向速度/加速度/加加速度的运动学限制要求：
首先要讲一下对于曲率的约束，因为车辆行驶时有着最大曲率的限制，根据曲率的坐标转换公式(Frenet公式)，l的二阶导和轨迹的曲率有一些关系，但是这里没办法直接得到曲率的公式应用于约束函数。因为约束函数只能做一次项，所以要对曲率和二阶导的函数关系进行简化，首先需要做一些假设，假设轨迹几乎沿着参考线规划：
假设θ-θref等于0.
由于曲率实际上是很小的，远远小于1，所以两个曲率相乘可以近似看作0.
则此时二阶导的公式简化为：
由车辆运动学可知，车辆可行驶的最大曲率为：
（最大前轮转角除以轴距），前轮最大转角对于每个车辆也是固定的，其和方向盘转角存在一个固定比例的关系。则二阶导的约束为：
另外轨迹还要满足曲率变化率的要求，即使得曲率变化率满足方向盘能打得过来。
这里还要做一些假设：
同时假设，速度是恒定的:
然后代入三阶导公式，即：
最后总结一下：
即每个点的二阶导要是连续的，同时也要可导的。(三阶导积分可以得到二阶导，二阶导积分可以得到一阶导，一阶导积分可以得到l，所以每两个点之间的三阶导值是恒定的，二阶导，一阶导的值是连续可导的，所以这样的一个曲线就是每两个点之间满足三阶导恒定的多项式的关系式)
将优化变量的约束和等式约束转化为约束矩阵A
其分别包含，l，一阶导，二阶导，三阶导，然后是满足运动学连续的函数关系式，最后是起点的硬性约束。
最后将算法代入求解器求解：
求解主要包括了四个步骤，第一步是设置求解器的参数，在SolverDefaultSettings里面包含了一些求解器的默认参数。
然后是计算Q,P系数矩阵，即计算二次规划的q和p的系数。
红线是分别计算P，A和q的系数的函数。
计算完之后，构造OSQP求解器进行求解：
主要通过调用osqp_setup这个函数，把数据导进去就可以自动进行求解。
最后获取优化结果：
红线分别是获得优化值，获得优化变量的取值。
接下来讲解路径规划算法的执行过程：
整个路径规划首先从参考线平滑开始，首先其会产生ReferenceLineInfo这样一个类，保存所有的ReferenceLine的计算结果。接下来在路径规划部分按顺序依次执行每个任务。这里的任务包含了决策器和优化器的任务，这里每个决策器或优化器的入口函数都是Process函数：
求解的结果保存在reference_line或reference_line_info中。
第一个换道决策器，主要产生是否换道的状态:
主要产生是否换道的状态，它产生的状态会保存在injector中，其在planning中是一个单一类，其保存的变量会贯穿planning始终，也就是可以在不同帧之间进行共用。(因为换道也是要贯穿好几帧进行的决策)
接下来是借道决策，其保存的变量在reference_line_info中，如果产生借道决策，后面的值设置为true，另外会把借道的状态向左或向右保存到injector中
第三步是产生路径边界，根据现有决策在参考线上采样，获得每个点的在l方向上的可行驶区域，其包含了四种边界：
最后将所有路径边界通过setCandidatePathBoundarier保存在reference_line_info中
接下来是路径优化
其主要通过调用piecewise_jerk_problem去进行优化求解(其是二次规划求解器的一个类)，这里会设置二次优化问题的一个权重以及一些约束，最后调用Optimize函数去进行一个优化的求解。这里通过从reference_line_info获得候选路径，把每条路径生成的边界，保存在该变量中。
最后选择最优路径，其会调用ComparePathData函数，两两比较每一条path哪个更优，将最优的path保存在reference_line_info中(mutable_path_data中)，同时把这个path中阻塞的最近的障碍物放入blocking_obstacle中，也是供速度规划进行进一步的处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c7c566e05f8e97bdb088bd4e71e9217/" rel="bookmark">
			VScode禁止格式化时大写PX转换为小写px
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要把小写px改成大写PX？这是因为项目里面有些比例我希望是固定死的宽度/高度，而框架里面是有规定如果是大写的PX，格式化时就不会去将这个大写PX单位进行换算转换。
在样式文件中： .boxClass{ display: inline-block; /* prettier-ignore */ width: 12PX; height: 12px; margin-right: 10px; background: #0066ff; } 添加prettier-ignore注释后，该代码下面一行得代码格式化时，大写PX不会转换成小写px
在html中： &lt;!-- prettier-ignore --&gt; &lt;p style="width:20PX"&gt;testStyle&lt;/p&gt; 其实就是有包含prettier-ignore就可以了，然后注释格式就得看具体在什么文件格式中使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f26f27d4c179442aa891d20d241d1f8/" rel="bookmark">
			C语言的4种方式实现空格转换为%20
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言的4种方式实现空格转换为%20 下面介绍C语言将空格的转换为%20的四种方法
方法一 介绍：
//在 C 语言标准(C89)没有定义布尔类型，所以 C 语言判断真假时以 0 为假，非 0 为真。所以我们通常使用逻辑变量的做法：
//定义一个int类型变量，当变量值为0时表示false，值为1时表示true int flag; flag = 0; //...... flag = 1; if( flag ) { //...... } //在最新的 C 语言标准(C99)解决了布尔类型的问题。C99 提供了 _Bool 型，所以布尔类型可以声明为 _Bool flag。//C99还提供了一个头文件 &lt;stdbool.h&gt; 定义了 bool 代表 _Bool，true 代表 1，false 代表 0。只要导入 stdbool.h ，就能非常方便的操作布尔类型了。
//C 库函数 - gets() ，c标准库&lt;stdio.h&gt; 描述：C 库函数 char *gets(char *str) 从标准输入 stdin 读取一行，并把它存储在 str 所指向的字符串中。当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。
#include&lt;stdio.h&gt; #include&lt;string.h&gt; //导入 stdbool.h 来使用布尔类型 #include &lt;stdbool.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f26f27d4c179442aa891d20d241d1f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24720d371875678b6669656cb68883b1/" rel="bookmark">
			Postman 实现备份数据 Postman恢复数据 postman 导出导入数据 postman 导入导出数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Postman 实现备份数据 Postman恢复数据 postman 导出导入数据 postman 导入导出数据 一、需求描述 在使用postman调试接口时，若遇到内网的环境，无法通过账户同步数据； 在A电脑调试的接口数据，需要移动到B电脑上，如何实现postman 的数据迁移（导出）功能呢？
在新的电脑上，如何导入postman的数据呢？
本文将整理 postman的数据导出、导出功能，从而实现 内网环境中，postman数据迁移。
本文示例postman版本是： Version 10.8.7 ，不同版本之间，操作界面略有差异。
二、postman 数据导出 1、全局数据导出 步骤：左上角 --- File --- Settings --- Data --- Export data ---
2、单个 Collections 导出 步骤：选中 某个 Collection --- 右键 --- Export
三、导入数据 1、快捷导入 步骤：左上角 --- File --- Import
2、postman 数据导入（限postman导出数据）： 步骤：左上角 --- File --- Settings --- Data --- Import data
注意：因为是在 内网环境中，故不能登录 postman 帐号的 。 若登录postman 可以无法 按照上述步骤进行 导入、导出数据的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24720d371875678b6669656cb68883b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9911b826a01771ed34b99bc2198b3780/" rel="bookmark">
			【word】插图报错EMBED Visio.Drawing
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、报错信息 word插图报错：
{EMBED Visio.Drawing.15}
二、解决方案 文件-选项-高级-显示文档内容，取消勾选“显示域代码而非域值”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c149a6df8abe197ff5b8f4d3b2063439/" rel="bookmark">
			Qt学习基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Qt是什么？ Qt是一个基于C++语言的图形用户界面（GUI）开发框架，Qt不仅仅可以进行GUI开发，除此之外Qt也能进行很多其它功能开发，包括但不限于多线程、数据库、图像处理、音视频处理、网络通信与文件IO等。
Qt广泛地应用于嵌入式开发和传统软件开发中：
（1） 传统软件客户端
（2）上位机：远程控制嵌入式下位机
（3）嵌入式产品控制程序
2. Qt的优势 Qt与各种竞品相比，主要的优势是跨平台特性。
跨平台特性指的是：一次编程，到处编译。
除此之外，Qt也拥有一些其它竞品的共同优势特点：
● 面向对象开发
● 丰富的API，并配以大量的开发文档
● 易用且开源的开发环境
3. 开发环境 学习QT过程中主要用到了以下软件 主界面是这样的
4. 工作目录与构建目录 4.1工作目录 工作目录：即新建项目时配置的路径，存放源代码文件的目录。
4.2构建目录 构建目录：当程序构建时，会在此目录下生成编译的文件。
需要注意的是，默认情况下开启影子构建，此时工作目录与构建目录分离。如果取消此模式，构建目录会合并到工作目录，优势是可以提升编译的稳定性，劣势是文件分类不明确。
5. 查看帮助文档 Qt自带了大量的帮助文档，可以通过以下几种方式打开：
方法一： 直接打开Assistant程序，可以在一个独立窗口中打开帮助文档。
方法二： 在Qt Creator中点击左栏的“帮助”，可以打开一个内置的帮助文档。
方法三： 在Qt Creator中，光标定位到要查询的内容，双击键盘F1，可以直接通过内置的帮助文档查询到对应的内容。
每个类在文档中需要注意下面的部分。
6. 解析默认文件代码 6.1 项目配置文件 项目名称.pro
#------------------------------------------------- # # Project created by QtCreator 2023-01-30T21:19:35 # #------------------------------------------------- # 当前项目需要添加的模块 QT += core gui # 当Qt主版本号大于4时，添加widgets模块 greaterThan(QT_MAJOR_VERSION, 4): QT += widgets TARGET = HelloQt # 可执行文件名称 TEMPLATE = app # 当前项目的构建模式 # 当前项目包含的源文件 SOURCES += main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c149a6df8abe197ff5b8f4d3b2063439/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9daceb805e5ff29bf3bb28bc62c338f1/" rel="bookmark">
			mysql定时任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0:查看事件的状态
show variables like '%event_sche%';-- 查询mysql的事件的状态，默认是OFF
启动事件
set global event_scheduler=1;-- 设置事件为启动状态，但数据库重启后失效；
修改配置文件(my.cfg)，在[mysqld]下增加一行内容： event_scheduler=ON
1:创建存储过程
在mysql workbench工具的数据库中创建存储过程的方法是选择“stored procedures”,创建一个存储过程
CREATE PROCEDURE `teacher_test` ()
BEGIN
insert into teacher(tid,tname,tsex) values(1,'张三','男');
END
10:创建定时事件
create event second_event #second_event表示事件的名称
on schedule every 5 second #每隔5秒执行一次
on completion preserve disable #创建后不立即执行
do call teacher_test(); #调用存储过程
11: 常见的定时时间函数
周期执行–关键字 EVERY
单位有：second,minute,hour,day,week(周),quarter(季度),month,year
如：
on schedule every 1 second //每秒执行1次
on schedule every 2 minute //每两分钟执行1次
on schedule every 3 day //每3天执行1次
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9daceb805e5ff29bf3bb28bc62c338f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2a38fb84d2a62c277a221b5df45beeb/" rel="bookmark">
			C#常用加密解密方法（MD5加密解密）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常开发过程中，总会遇到需要加密解密的需求，这里我整理了C#常用的加密解密方法分享给大家。
先看看加密的基本概念：
"加密"，是一种限制对网络上传输数据的访问权的技术。原始数据（也称为明文，plaintext)被加密设备(硬件或软件)和密钥加密而产生的经过编码的数据称为密文（ciphertext）。将密文还原为原始明文的过程称为解密，它是加密的反向处理，但解密者必须利用相同类型的加密设备和密钥对密文进行解密。
加密的基本功能包括:
1. 防止不速之客查看机密的数据文件；
2. 防止机密数据被泄露或篡改；
3. 防止特权用户(如系统管理员)查看私人数据文件；
4. 使入侵者不能轻易地查找一个系统的文件。
一、本节摘要 本节主要分享MD5加密解密： MD5全称是message-digest algorithm 5，简单的说就是单向的加密，也就是说无法根据密文推导出明文。
MD5主要用途：
1、对一段信息生成信息摘要，该摘要对该信息具有唯一性,可以作为数字签名
2、用于验证文件的有效性(是否有丢失或损坏的数据)
3、对用户密码的加密
4、在哈希函数中计算散列值
二、源码分享 1、主方法
private void Test() { string o = "i love u"; o = AddMD5Profix(o); //o += " "; Console.WriteLine(o); Console.WriteLine(ValidateValue(o)); o = RemoveMD5Profix(o); Console.WriteLine(o); } 2、MD5加密解密类
using System; using System.IO; using System.Collections.Generic; using System.Text; namespace Commons { /// &lt;summary&gt; /// MD5各种长度加密字符、验证MD5等操作辅助类 /// &lt;/summary&gt; public class MD5Util { public MD5Util() { } /// &lt;summary&gt; /// 获得32位的MD5加密 /// &lt;/summary&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2a38fb84d2a62c277a221b5df45beeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e689b76ee736c077e388e60e3163b042/" rel="bookmark">
			【Go语言】gin &#43; go:embed 打包静态资源文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 package main import ( "embed" "github.com/gin-gonic/gin" "html/template" "io/fs" "net/http" ) var ( //go:embed static/assets/* templates/* f embed.FS ) func main() app := gin.Default() fp, _ := fs.Sub(f, "static/assets") app.StaticFS("/static/assets/", http.FS(fp)) /* app.GET("/static/uploads/:filename", func(ctx *gin.Context) { ctx.File("./static/uploads/" + ctx.Param("filename")) }) */ tmpl := template.Must(template.New("").ParseFS(f, "templates/**/*")) app.SetHTMLTemplate(tmpl) app.GET("/", func(ctx *gin.Context) { ctx.HTML(http.StatusOK, "index/index.html", nil) }) _ = app.Run() } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b9840bd1cc174bbdcd3d3106eb6a845/" rel="bookmark">
			机器学习——特征空间映射以及核函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/873ad32512eccf5925f9968a2364e7d4/" rel="bookmark">
			javax.net.ssl.SSLHandshakeException: No appropriate protocol (protocol is disabled or cipher suites
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		idea连接不上远程的数据库
在数据库设置URL的后面拼接?useSSL=false，操作如图：
报错如下：
拼接操作：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cc1f6ac34370c08d8108daa096e13da/" rel="bookmark">
			Zemax学习笔记（16）- ZEMAX_分析＞报告使用说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zemax学习笔记（16）- ZEMAX_分析&gt;报告使用说明 总述1.报告图2.数据报告3.摘要数据 总述 在ZEMAX中，想要获取系统最直接的参数，最方便的工具不失为系统分析&gt;报告。
很明显，报告分为三个部分，从上到下依次为报告图、数据报告、摘要数据。
1.报告图 报告图的主要功能是将点列图、MTF、像差图等分窗口展示的数据按照2×2、2×3或者3×3的格式展示在一个窗户。如图所示。
2.数据报告 表面数据报告
该数据报告详细说明每一个表面的相关数据，包括材料、厚度、光焦度、形状因子等，可以在左上角设置出选择展示的表面。
系统数据报告
该部分数据主要展示系统层级的数据，包括系统的有效焦距、后焦距、入瞳直径、近轴放大率等相关参数。
分类数据报告
分类数据报告（Prescription Data（Ctrl+H））数据是系统最全面的数据，不仅包含系统层级的数据。也包含每一个面的数据，尤其是每一个面在某个像差中的贡献度，在对系统进行优化时非常有用。
3.摘要数据 摘要数据中包括系统数据摘要和基点数据。
系统数据摘要
基点数据
基点数据包含主点和主面，焦点和焦面的位置信息，查看起来十分方便。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e4c30a0cb496541a7365ea1b8a5f521/" rel="bookmark">
			最详细蓝桥杯嵌入式教程（三）：LCD液晶屏显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习完点亮LED灯之后，我们开始学习LCD液晶屏的显示。
首先我们所需要的有关LCD的文件在比赛的时候，都会被提供。我们只要把这些文件添加到工程里就可以了。
这样我们就实现了最基本的配置。
然后我们就可以在该基础上做出更改。如下：
到此为止，我们完成LCD的学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a468016e414956460c90e22fae1beda/" rel="bookmark">
			关于border的一个问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给div设置一个边框，为什么border的值设置成偶数，控制台显示的border值是相同的，但是设置成奇数就会比原设置的值小。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30cfa197f5cd4aaa03bd84917793b061/" rel="bookmark">
			Android设置之Preference源码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇分析的库是基于：androidx.preference.preference:1.1.1@aar
先来看张微信中的页面，这个页面实现其来比较简单，实现的方式也有很多，但按可扩张性和简单程度来说，个人认为还是要数Preference了，基本就是xml中配置了。
android中有提供给我们专门用作设置处理的库Preference（支持的控件可直接在该库下查看），对于怎么使用，android studio有提供模板Settings Activity，接下来就看下它的实现。
先来简单看下Preference定义的xml：
&lt;PreferenceScreen xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;PreferenceCategory app:title="@string/sync_header"&gt; &lt;SwitchPreferenceCompat app:key="sync" app:title="@string/sync_title" /&gt; &lt;SwitchPreferenceCompat app:dependency="sync" app:key="attachment" app:switchTextOn="kai" app:switchTextOff="guan" app:summaryOff="@string/attachment_summary_off" app:summaryOn="@string/attachment_summary_on" app:title="@string/attachment_title" /&gt; &lt;/PreferenceCategory&gt; &lt;/PreferenceScreen&gt; 在来看下在Fragment中的使用：
public static class SettingsFragment extends PreferenceFragmentCompat { @Override public void onCreatePreferences(Bundle savedInstanceState, String rootKey) { setPreferencesFromResource(R.xml.root_preferences, rootKey); } } 这里就是调用了setPreferencesFromResource()把xml设置进去，接着就是使用这个Fragment就可以了。
咋一看，这里并没有view啊，那是设置页面是怎么显示的呢，带着这个疑问，一起来看下PreferenceFragmentCompat的源码，Fragment创建view是在onCreateView这个方法中：
private int mLayoutResId = R.layout.preference_list_fragment; public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { ​ TypedArray a = getContext().obtainStyledAttributes(null, R.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30cfa197f5cd4aaa03bd84917793b061/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/004f935067cd5961ec1475a8791587c1/" rel="bookmark">
			MATLAB学习之多项式拟合和多项式插值（附源代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、多项式的拟合二、多项式的插值1、一维插值2、二维插值 三、问题探究1、船在该海域会搁浅吗？2、薄膜渗透率的测定 四、源代码下载 前言 公司最近在做单颗粒质谱的设备，在数据计算展示上用到了MATLAB的运算展示，比较方便，这里搜集到了一些资料给大家分享一下，有需要的可参考。
一、多项式的拟合 多项式的拟合（Polynomial Fitting）又称为曲线拟合(Curve Fitting)，其目的就是在众多的样本点中进行拟合，找出满足样本点分布的多项式。所用指令为polyfit，指令格式为：p=polyfit (x,y,n),其中x与y为样本点向量，n为所求多项式的阶数，p为求出的多项式。# 二、使用步骤
二、多项式的插值 1、一维插值 一维插值 interp1(x,y,x0, ‘method’) ，其中x , y分别表示为数据点的横、纵坐标向量，x0为需要插值的横坐标数据（或数组）。而method为可选参数，对应于四种方法，可从以下四个值中任选一个：
‘nearest’---------最近邻点插值
‘linear’-----------线性插值
‘spline’----------三次样条插值
‘cubic’-----------立方插值
其中‘nearest’是缺省值。
2、二维插值 二维插值 interp2(x,y,z,xi,yi, ‘method’),其中x和y是自变量。X是m维向量，指明所给数据网格点的横坐标，y是n维向量，指明所给数据网格点的纵坐标，z是mxn维矩阵，标明相应于所给数据网格点的函数值。向量xi，yi是给定的网格点的横坐标和纵坐标，指明函数zi=interp2(x,y,z,xi,yi, ‘method’)返回在网格(xi,yi)处的函数值。method为可选参数，选取方法同一维。
注意：向量x，y的分量值必须是单调递增的。Xi和yi应是方向不同的向量。即一个是行向量，另一个是列向量。
三、问题探究 1、船在该海域会搁浅吗？ 在某海域测得一些点处的水深z（单位：英尺）由下表给出，水深数据是在低潮时测得的。船的吃水深度为5英尺，问在矩形里的哪些地方船要避免进入。
水道水深测量数据（单位：英尺）
假设：该海域海底是平滑的。由于测量点是散乱分布的，先在平面上作出测量点的分布图，在利用二维插值方法补充一些点的水深，然后作出海底曲面图和等高线图，并求出水深小于5的海域范围。
作出测量点的分布图：
作出海底地貌图
危险区域海底地貌图
危险区域平面图
2、薄膜渗透率的测定 某种医用薄膜有允许一种物质的分子穿透它，从高浓度的溶液向低浓度的溶液扩散的功能，在试制时需测定薄膜被这种分子穿透的能力。测定方法如下：
用面积S的薄膜将容器分成体积分别为的两部分，在两部分中分别注满该物质的两种不同浓度的溶液。此时该物质分子就会从高浓度溶液穿过薄膜向低浓度溶液中扩散。通过单位面积膜分子扩散的速度与膜两侧溶液的浓度差成正比，比例系数K表证了薄膜被该物质分子穿透的能力，称为渗透率。定时测量容器中薄膜某一侧的溶液浓度值，以此确定K的值。
1、薄膜两侧的溶液始终是均匀的，即在任何时刻膜两侧的每一处溶液的浓度都是相等的
2、当两溶液的浓度不一致时，物质的分子穿透薄膜总是从高浓度溶液向低浓度溶液扩散
3、通过单位面积膜分子扩散的速度与膜两侧溶液的浓度差成正比
4、薄膜是双向同性的即物质从膜的任何一侧向另一侧渗透的性能是相同的
符号说明
建模
考察时段[t,t+Δt]薄膜两侧容器中该物质质量的变化。以容器A为例，在该时段物质质量的增加量为：
另一方面从B侧渗透至A侧的该物质质量为：
由质量守恒定律有：
由此得：
又整个容器 中含有该物质的质量应该不变，所以有下式：
模型求解
此时极小化的函数为：
代码结果：
四、源代码下载 有需要的可以参考，有代码自行下载。
MATLAB多项式的拟合和多项式的插值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35b156b2eff8fcbd072c6520356c923e/" rel="bookmark">
			2.4.1QT输入控件组之Line Edit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.4.1QT输入控件组之Line Edit 文章目录 2.4.1QT输入控件组之Line Editui界面的输入控件组2.4.1lineEdit单行文本编辑器2.4.1.1常用的成员函数2.4.1.2常用的槽函数(已经实现)2.4.1.3常用信号2.4.1.4数据校验器2.4.1.5浮点数值验证器2.4.1.6正则表达式验证器2.4.1.7LineEdit自动补全功能 总结 ui界面的输入控件组 Combo Box:组合框Font Combo Box:字体组合框Line Edit:单行编辑框Text Edit:多行文本编辑框Plain Text Edit:纯文本编辑Spin Box:整数显示框Double Spin Box:浮点数显示框Time Edit:时间编辑Data Edit:日期编辑Data/Time Edit:日期/时间编辑器Dial:转盘（刻度盘）Horizontal Scroll Bar:横向滚动条Vertical Scroll Bar:垂直滚动条Horizontal Slider:横向滑块Vertical Slider:垂直滑块Key Sequence Edit:设置快捷键 提示：以下是本篇文章正文内容，下面案例可供参考
2.4.1lineEdit单行文本编辑器 使用场景：用户名，密码输入框，搜索框等。
头文件：#include&lt;QLineEdit&gt;
2.4.1.1常用的成员函数 1、文本设置函数
QString text() const	获取文本数据 void setText(const QString &amp;)	设置文本数据 2、文本的最大允许长度
int maxLength() const 获取文本最大允许的长度 void setMaxLength(int)	设置文本最大允许的长度 注意：lineEdit控件的文本长度默认是32767，超出限制就无法进行输入
3、设置文本显示
在输入密码时，不想让文本内容显示出来，可以设置文本显示的方式
EchoMode echoMode() const 获取文本显示的模式 void setEchoMode(EchoMode) 设置文本显示的模式 EchoMode模式枚举类型：
常量数字描述QLineEdit::Normal0默认显示模式，输入什么内容就显示什么内容。QLineEdit::NoEcho1不显示任何内容，Unix/Linux 下常用的密码显示模式。QLineEdit::Password2输入的每一个字符都用星号显示。QLineEdit::PasswordEchoOnEdit3输入一个字符时，短暂显示该字符，然后迅速将该字符显 4、设置只读属性
bool isReadOnly() const 获取属性 true 表示只读，false 表示可读可编辑 void setReadOnly(bool) 设置属性 true 表示只读，false 表示可读可编辑 在只读模式下，用户仍然可以将文本复制到剪贴板或拖放文本，但不能编辑它。属性默认为（false）表示可读可编辑。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35b156b2eff8fcbd072c6520356c923e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7f8bb4fb0b323947b99963ba114a371/" rel="bookmark">
			git commit后如何撤销
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改本地代码后，提交改动的代码到远程库里时可能会遇到将注释写错的情况，那么这个时候该如何撤回错误的commit操作重新commit。
情况一：撤销git commit命令和撤销git add
命令：git reset --hard HEAD^
作用：删除工作空间修改过的代码，撤销commit&amp;撤销add
情况二：仅撤销git commit 命令
命令：git reset --soft HEAD^
作用：不删除工作空间修改过的代码，仅撤销commit
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7c51599964c829dfdf05d28780b2503/" rel="bookmark">
			Power BI饼图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		饼图展现的是个体占总体的比例，利用扇面的角度来展示比例大小。
在PowerBI默认的可视化对象中当然也有这种标准饼图，通过点击拖拽轻松生成，
通过对标题和图例的格式稍加设置，一个简单而不失专业的饼图就可以用了，
饼图的使用上应注意一些细节：
类别不应太多，3-5个为宜一般从12点方向开始，从大到小排列如果要显示比例数据，保证总和为100%饼图展现的是比例关系，不同的饼图不可轻易比较 另外，数据之间占比的差异最好比较明显，如果比例都差不多，比如5个分类都是20%左右，从饼图上其实很难区分哪个占比更大，因为人类视力对于角度的辨别力要比长短弱的多，饼图的这个缺陷也因此被诟病。
饼图能做的其实柱形图和条形图都可以实现，并且柱形图和条形图让人可以根据柱子的长短高低一眼可以辨别大小。
无论如何，饼图的简单和易于理解性已经为大众所接受，并且根据数据的选择以及数据标签的运用，可以绕开上面所述的缺点。
在PowerBI默认的可视化中，还有一个环形图。
选中刚才的饼图，然后在可视化区域中点击环形图，
环形图表示比例的大小已经不再依靠扇形的角度，而是依靠环形的长度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/272f1cd0ecd3dbad5faa1661e915a056/" rel="bookmark">
			关于python中Process finished with exit code -1073741819 (0xC0000005)错误，PyQt5导包错误的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于在pycharm中导入可视化程序开发框架PyQt5，PyQt6是出现的问题Process finished with exit code -1073741819 (0xC0000005)有以下尝试解决的方法。（每一种方法亲测）
1.在File-&gt;Settings-&gt;Build,Execution,Deployment-&gt;Python Debugger中去掉勾选的PyQt compatible点击确定。
2.更换python版本，作者测试了更换成python3.8后，能够兼容pyqt5。
python3.8版本下载地址：Python Release Python 3.8.10 | Python.org
下载安装完之后在pycharm右下角更换解释器。点击Add New Interpreter,在解释器一行找到你的python3.8.exe的安装位置。
3.以上两种方法是针对pyqt5出现Process finished with exit code -1073741819 (0xC0000005)错误的最实用方法，最后推荐检查一下代码是否有字母大小写错误，或语句错误，或判断条件错误等。其他问题详见该文章：pycharm报错：Process finished with exit code -1073741819 (0xC0000005)_qiao1025566574的博客-CSDN博客_process finished with code -1073741819
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45f9ac008bc59cb21516ccac62b6c986/" rel="bookmark">
			Selenium：下列列表使用懒加载如何下滑定位元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Selenium：自定义下拉列表组件使用懒加载如何下滑定位元素 问题：1.方法一循环滑动下拉列表中的元素，直到指定元素出现： 问题： selenium定位自定义下拉列表选择组件，并且数据加载方式是懒加载，不能直接定位到元素。
1.方法一循环滑动下拉列表中的元素，直到指定元素出现： WebElement element = driver.findElement(By.xpath("//*[@class='ant-select-item-option'][1]/div/span")); String rowName = element.getText(); System.out.println("====默认置顶元素=====" + rowName); int i=0; while(i&lt;30){ //设置最大滑动次数避免死循环 JavascriptExecutor JS = (JavascriptExecutor)driver; element = driver.findElement(By.xpath("//*[@class='ant-select-item-option'][2]/div/span")); rowName= element.getText(); if(rowName.equals("目标行元素名称")){ break; } System.out.println("====第二行元素======" + rowName+i); Thread.sleep(100); JS.executeScript("arguments[0].scrollIntoView();", element); Thread.sleep(100); element = driver.findElement(By.xpath("//*[@class='ant-select-item-option'][1]/div/span")); rowName= element.getText(); System.out.println("====当前最顶端元素======" + rowName+i); i++; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7217a7671d99c82b550c3d64daff388c/" rel="bookmark">
			C#常用加密解密方法（Base64加密解密）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常开发过程中，总会遇到需要加密解密的需求，这里我整理了C#常用的加密解密方法分享给大家。
先看看加密的基本概念：
"加密"，是一种限制对网络上传输数据的访问权的技术。原始数据（也称为明文，plaintext)被加密设备(硬件或软件)和密钥加密而产生的经过编码的数据称为密文（ciphertext）。将密文还原为原始明文的过程称为解密，它是加密的反向处理，但解密者必须利用相同类型的加密设备和密钥对密文进行解密。
加密的基本功能包括:
1. 防止不速之客查看机密的数据文件；
2. 防止机密数据被泄露或篡改；
3. 防止特权用户(如系统管理员)查看私人数据文件；
4. 使入侵者不能轻易地查找一个系统的文件。
一、本节摘要 本节主要分享Base64加密解密：
Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。可查看RFC2045～RFC2049，上面有MIME的详细规范。
Base64编码是从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息。采用Base64编码具有不可读性，需要解码后才能阅读。
Base64由于以上优点被广泛应用于计算机的各个领域，然而由于输出内容中包括两个以上“符号类”字符（+, /, =)，不同的应用场景又分别研制了Base64的各种“变种”。为统一和规范化Base64的输出，Base62x被视为无符号化的改进版本。
二、源码分享 1、主方法
protected void Test() { //m_codeTable = @"STUVWXYZbacdefghivklABCDEFGHIJKLMNOPQRmnopqrstu!wxyz0123456789+/"; //m_pad = "j"; this.InitDict(); string test = "abc ABC 你好！◎＃￥％……!@#$%^"; string encode = this.Encode("false"); string decode = this.Decode(encode); Console.WriteLine(encode); Console.WriteLine(test == decode); } 2、Base64加密解密类
using System; using System.Collections.Generic; using System.Text; namespace Common { /// &lt;summary&gt; /// 基于Base64的加密编码， /// 可以设置不同的密码表来获取不同的编码合解码 /// &lt;/summary&gt; public class Base64Util { public Base64Util() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7217a7671d99c82b550c3d64daff388c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/814a739e175edca726d50af7fcc4dfc4/" rel="bookmark">
			postgres实现任意时间点恢复（使用pg_basebackup）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置postgresql.conf文件 #日志级别 wal_level = replica #归档开关 archive_mode = on #归档命令 archive_command = 'cp %p /usr/local/postgres/archive/%f' 第一次执行这个配置，需要重启数据库；
查看归档目录 此后数据库的操作都会记录wal日志文件到/usr/local/postgres/archive目录下
如果归档目录中没有内容，需要执行强制日志归档命令
select pg_switch_wal(); 使用pg_basebackup进行基础备份 [bxy@localhost postgres]$ ./bin/pg_basebackup -h 127.0.0.1 -Ft -Pv -Xf -D backup/ 备份完成后，对应备份目录会出现基础备份 是一个压缩包
准备试验数据 在2023-02-01 16:40:00 创建表dog 并随意插入几条数据
等待适当时间，在16:43:00创建表cat 并随意插入几条数据
恢复时间点 2023-02-01 16:42:00 （创建两张表之间的时间点就行）
如果恢复后数据库中存在dog表，不存在cat表 则试验成功。
模拟数据库故障 模拟数据库故障，停掉数据库
使用备份替换data目录 修改postgresql.conf restore_command = 'cp /usr/local/postgres/archive/%f %p' recovery_target_time = '2023-02-02 06:55:00' 添加空文件 提醒postgresql要做recovery
touch data/recovery.signal 重启数据库 [bxy@localhost postgres]$ ./bin/pg_ctl -D /usr/local/postgres/data/ start waiting for server to start.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/814a739e175edca726d50af7fcc4dfc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9313c344ede3f18c70f8bc6e2a9f1210/" rel="bookmark">
			python ddddocr库的安装（window系统）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 # chcp 1252 如果只出现下载，不安装需要这个输入 # 1、 ddddocr安装 #python386 -m pip install ddddocr -i https://pypi.tuna.tsinghua.edu.cn/simple/ # 2、 需要升级 numpy #python386 -m pip show numpy #python386 -m pip install --upgrade numpy -i https://pypi.tuna.tsinghua.edu.cn/simple/ # 3、 需要安装 pillow # python386 -m pip install pillow==6.2.1 -i https://pypi.tuna.tsinghua.edu.cn/simple/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3eda8cc15f2e542e715f0f7423db402/" rel="bookmark">
			扫雷完整代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		play.h
#pragma once #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;time.h&gt; #define ROW 9 #define COL 9 #define ROWS ROW + 2 #define COLS COL + 2 #define COUNT 10 //初始化棋盘 void is_board(char board[ROWS][COLS], int rows, int cols,char ret); //打印棋盘 void print_board(char board[ROWS][COLS], int row, int col); //布置雷的位置 void set_mine(char mine[ROWS][COLS], int row, int col); //排查雷 void clear_mine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col); tast.c
#define _CRT_SECURE_NO_WARNINGS #include"play.h" void game() { //二维数组 --- 9 * 9 棋盘 --- 考虑一个方格周围8个方格时，可以横纵增大一圈，即为 11 * 11 char mine[ROWS][COLS] = { 0 };//排查雷 char show[ROWS][COLS] = { 0 };//排查出雷的信息 //初始化棋盘 is_board(mine, ROWS, COLS,'0'); is_board(show, ROWS, COLS,'*'); //打印棋盘 print_board(show, ROW, COL); //print_board(mine, ROW, COL); //布置雷的位置 --- 排查雷 set_mine(mine,ROW,COL);//布置雷的位置--- 传入mine //print_board(mine, ROW, COL); clear_mine(mine,show, ROW, COL);//排雷 -- mine排查雷 -- 放到show } void menu() { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3eda8cc15f2e542e715f0f7423db402/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/069ee2706464d97f08aa690d1c0e73f9/" rel="bookmark">
			IEEE参考文献格式生成 之 谢谢你Zotero！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谢谢你Zotero！ 心酸的开始方法1（有文献pdf）方法2（无文献pdf）方法3（自己写）怎么找到bib文件呢？期刊论文会议论文书籍（专著） 心酸的开始 一开始在看到论文模板的参考文献格式时就蒙了，不知道怎么搞，墨迹了好久才发现的方法！
方法1（有文献pdf） 首先要有一个Zotero，把你的要参考的pdf挪到里面，等zotero生成条目的时候右击用所选条目创建参考文献。然后在里面找到IEEE，剩下的按照下图来就行。
方法2（无文献pdf） 这个时候就只能依靠文献部落，如果在这里找到pdf就回到方法1中就ok了。
如果没有的话，可以到百度学术里面去，可能会找到该文献的官方网站。
然后在里面搜索Cite这个词，就是用来引用文献的，幸运的话还会给你.bib的下载路径。把.bib下载这个bib文件在再扔到Zotero中，就能再继续使用方法一了。
反正总的来说，感谢Zotero就我狗命
方法3（自己写） 下面是IEEE的参考文献格式 ，另外用以.bib文件中的格式为准。
怎么找到bib文件呢？ 期刊论文 &lt;名(首字母)&gt;. &lt;姓（全）&gt;, "&lt;论文标题&gt;," &lt;期刊名称&gt;, vol. &lt;卷号&gt;, no. &lt;期号&gt;, pp. &lt;起始页码-终止页码&gt;, &lt;年份&gt;.
@article{标识符, author = {{姓, 名 and 姓, 名 and ... and 姓, 名}}, title = {{论文标题}}, journal = {{期刊名称}}, volume = {卷号}, number = {期号}, pages = {起始页码--终止页码}, year = {年份} } 几点要注意的地方：
标识符一般以第一作者姓+年份表示，当然也可以用自己便于识别的标识符很多人熟悉的外国人姓名排列顺序为名在前，姓在后，但是在 IEEE 格式的 bib 文件中，是姓在前，名在后。如果作者有中间名，按照下列顺序：&lt;姓, 中间名 名&gt;。bib文件中的所有标点符号必须是英文标点符号。特殊符号，一般包含下划线(_)，与符号(&amp;)等等。在使用这些符号时请注意在前面加上反斜杠()，使其转义，不然 bibtex 无法编译。pages 字段中使用双横杠(–)来连接起始页码和终止页码。 会议论文 &lt;名(首字母)&gt;.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/069ee2706464d97f08aa690d1c0e73f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e55dfc5aa891cde4959aa9394cc93635/" rel="bookmark">
			【无标题】质量管理10题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 欢迎使用Markdown编辑器新的改变功能快捷键合理的创建标题，有助于目录的生成如何改变文本的样式插入链接与图片如何插入一段漂亮的代码片生成一个适合你的列表创建一个表格设定内容居中、居左、居右SmartyPants 创建一个自定义列表如何创建一个注脚注释也是必不可少的KaTeX数学公式新的甘特图功能，丰富你的文章UML 图表FLowchart流程图导出与导入导出导入 欢迎使用Markdown编辑器 你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。
新的改变 功能快捷键 撤销：Ctrl/Command + Z
重做：Ctrl/Command + Y
加粗：Ctrl/Command + B
斜体：Ctrl/Command + I
标题：Ctrl/Command + Shift + H
无序列表：Ctrl/Command + Shift + U
有序列表：Ctrl/Command + Shift + O
检查列表：Ctrl/Command + Shift + C
插入代码：Ctrl/Command + Shift + K
插入链接：Ctrl/Command + Shift + L
插入图片：Ctrl/Command + Shift + G
查找：Ctrl/Command + F
替换：Ctrl/Command + G
合理的创建标题，有助于目录的生成 直接输入1次#，并按下space后，将生成1级标题。
输入2次#，并按下space后，将生成2级标题。
以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e55dfc5aa891cde4959aa9394cc93635/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa37e303e98c65fe41d8708bd351a62f/" rel="bookmark">
			程序员，你真的理解什么是“财富自由”吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序员，你真的理解什么是“财富自由”吗？ 眼前这闪着光芒的“财富自由”，明明感觉自己工资收入比身边大多数人都高，工作也一直很努力，从无一分钟的懈怠，但是这么多年过去了，为何却感觉自己离它反而越来越远了。
我看了百度百科，它说“财富自由就是有足够多的时间和足够多的钱做你想做的事情。”这样的定义，我看不出有任何的指导意义，反复琢磨，反复思考，也不知道下一步应该做什么？
如今程序员的现状 我们想过努力工作，努力学习新的技能来提高自己的工资。可是，我们在这一家公司的工资，不是自己技术有多牛能决定的，而是看老板能拉来多大的项目。项目不好的情况下，不仅得不到涨薪的机会，技术上也很难有成长。
我们想过跳槽，可又害怕另一家公司的同事的不好相处，也怕频繁跳槽的履历形象不利于以后的职业生涯。更重要的是，跳槽，换了一家公司，能解决我们无力追往“财富自由之路”的问题吗？
不能！随着我们年龄越来越大，熬不了夜加不了班了，再加上成家后要分精力到家庭孩子身上，我们竞争力只会越来越弱。
年轻一代的应届生，五七八门培训班出来找工作的人，他们都可以加班，而且要很低的薪资，这扑面而来的压力，越来越大。
最重要的是，即使我们特别优秀，抗住了这些压力，薪资也逐年上涨到所期待的水平。可是，打工者的属性决定了，你只要不上班，就没有钱拿，你永远不会有“财富自由”的一天。
我们想要接私活，很多私活可以有效锻炼我们的技术能力，但是大部分能抛给我们的私活性价比很低，属于活多钱少的类型。
我们想要写教学文章、拍教学视频，但是很久很无法看到收入，无法坚持。
因为我们理解错了“财富自由”的真正概念，我们才会如此无所适从 所谓的“个人财富自由”，其实指的是某个人再也不用为了满足生活必需而出售自己的时间了。
我们一生所做的所有事，都在消耗着只去不回的时间。如果你做的事能让你有所收获，那么你付出的时间就可以视作“被出售”了。我们每个人做的所有奋斗的本质，都是让自己出售的时间单价更高。
我们理解了“财富自由”的真正概念，我们该怎么办 我们要知道，人和公司一样，都有商业模式，一个人的商业模式，就是他售卖自己时间的方式。
按照这个定义，个人商业模式可以分为三种：
第一种：同一份时间出售一次。比如上班，一次打包出售自己一个月的时间给老板，老板每月给你发工资，你每天的8个小时，只能出售一次，也只能收益一次。
第二种：重复出售同一份时间。比如你花一年时间写了一本书，卖了10年，赚了10年版税，就相当于写书的那一年时间你重复出售了10年。比如你花一个月时间，做了一个 PPT 教程，然后放在知识付费平台上卖一年，也是同样的道理。
第三种：购买他人的时间再出售。比如你创业做老板，招10个员工，让他们为你赚钱。这就相当于，你花钱购买了这10个人的时间，然后再利用这10个人的时间赚钱，这个过程中只要是低买高卖，你就是赚的。投资人同样道理，只不过他购买的是创业者的时间。
第一种是大多数人的常态，第三种只有少数人能做到，第二种是每个人都可以立马动手优化的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba3744c8ba8aef10f2333e05a5fee88a/" rel="bookmark">
			【数据结构初阶】第七篇——二叉树的顺序结构及实现(堆的向下，向上调整算法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树的顺序结构
堆的概念及结构
堆的向下调整算法
堆的向上调整算法
堆的实现
初始化堆
销毁堆
打印堆
堆的插入
堆的删除
获取堆顶的数据
获取堆的数据个数
堆的判空
建堆的时间复杂度
二叉树的顺序结构 普通二叉树是不适合用数组来存储的,因为可能会导致大量的空间浪费。而完全二叉树更适合使用顺序结构存储。
堆的概念及结构 堆的概念
堆:如果有一个关键码的集合K={k0,k1,k2,…,kn-1}，把它的所有元素按完全二叉树的顺序存储方式存储在一个一维数组中，并满足ki&lt;=k2i+1且ki&lt;=k2i+2（或满足ki&gt;=k2i+1且ki&gt;=k2i+2）,其中i=0,1,2...,则称该集合为堆。
小堆:将根节点最小的堆叫做小堆，也叫作最小堆或小根堆。
大堆:将根节点最大的堆叫做大堆，也叫最大堆或大跟堆。
堆的性质:
堆中某个节点的值总是不大于或不小于其父节点的值。
堆总是一颗完全二叉树。
堆的结构
堆的向下调整算法 现在我们给出一个数组，逻辑上可以看作是一颗完全二叉树。我们通过从根节点开始的向下调整算法可以把它调整成一个小堆。
但是，使用向下调整算法需要满足一个前提:
若将其调整成小堆，那么根节点的左右子树必须都为小堆。
若将其调整成大堆，那么根结点的左右子树必须都为大堆。 向下调整算法的基本思想(这里以小堆为例):
1.从根节点处开始，选出左右孩子中值较小的孩子。
2.让小的孩子与其父亲进行比较。
若小的孩子比父亲还小，则该孩子与其父亲的位置进行交换。并将原来小的孩子的位置当成父亲继续向下进行调整，知道调整到叶子节点为止。
若小的孩子比父亲大，则不需处理了，调整完成，整个树已经是小堆了。
//交换函数 void Swap(int* x, int* y) { int tmp = *x; *x = *y; *y = tmp; } //堆的向下调整（小堆） void AdjustDown(int* a, int n, int parent) { //child记录左右孩子中值较小的孩子的下标 int child = 2 * parent + 1;//先默认其左孩子的值较小 while (child &lt; n) { if (child + 1 &lt; n&amp;&amp;a[child + 1] &lt; a[child])//右孩子存在并且右孩子比左孩子还小 { child++;//较小的孩子改为右孩子 } if (a[child] &lt; a[parent])//左右孩子中较小孩子的值比父结点还小 { //将父结点与较小的子结点交换 Swap(&amp;a[child], &amp;a[parent]); //继续向下进行调整 parent = child; child = 2 * parent + 1; } else//已成堆 { break; } } } 使用堆的向下调整算法，最坏的情况下就是一直交换，需要循环的次数为:h-1(h为树的高度)，而 h = log2(N+1)（N为树的总结点数）.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba3744c8ba8aef10f2333e05a5fee88a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22de4498e8497957d04f4c894f945b3e/" rel="bookmark">
			VHD、VHDX
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是VHD(X)，如何创建VHD(X) VHD（Virtual Hard Disk） - 虚拟硬盘 虚拟磁盘VHD是一款软件，传统意义上来说，在物理机上安装一个先行版的操作系统（OS），就意味着要格式化硬盘，然后如同安装其他任何Windows Server操作系统一样进行安装。这种方式当然可以用于安装Windows Server 10，但是若用虚拟磁盘VHD功能启动会更有优势。因为虚拟磁盘VHD启动在当每个操作系统都存在于单独的虚拟磁盘VHD时候更容易创建多重引导环境。那样，你就可以测试多种虚拟磁盘VHD配置，而不必担心多个操作系统安装在同一个虚拟磁盘VHD上的复杂性。
正如虚拟机是假装有一个单独的电脑，虚拟硬盘就是假装有一块单独的硬盘
VHD技术其实是非常古老的技术了，甚至微软几年前就已经有了新的解决方案-VHDX
正类似MBR与GPT，VHD最大只能支持2T的硬盘容量，VHDX不被Win7支持(但是VHD可以把硬盘分区表设为GPT格式)。
类似于水管，VHD与VHDX是上半段，GPT与MBR是下半段，上游水管最多只过2L，下面的水管修的再宽再大也就那点水。
####
虚拟机可以模拟单独的电脑进行开关机，增减硬件
|---------------------D盘-----------------| |-----------------------------------------| |--数据---||----单独的电脑---||----数据------| ​ ​ 虚拟硬盘：
虚拟硬盘可以模拟单独的硬盘进行分区，格式化
|------------------D盘--------------------| |-----------------------------------------| |--数据---||----单独的硬盘---||----数据------| 如何创建VHD、VHDX 创建VHD分为两种方式 : 用户界面 与 命令行 ​ 我们可以通过磁盘管理器按照向导轻松创建VHD，也可以通过diskpart工具快速地创建VHD。(在Windows2008 R2中则必须先安装Hyper-V后才能创建VHD)
磁盘管理创建vhd、vhdx
1 .同时按 Win +X键 打开磁盘管理
2.等加载完毕之后，在上方点 操作 - 创建VHD（虽然是创建“VHD”，但创建VHDX时也是这项）
3填入相应的信息，什么是VHD(X)，如何创建VHD(X)这里为了演示，只选了比较小的容量，其实可以选大一点，因为硬盘是可以分区的，可以按区分配卷标（也是就C:\ D:\ 中的字母） ​ 使用后可以对卷进行格式化，不用再等文件删除不用担心只是删到回收站，非常方便
4.虽然系统很恶心的不给任何提示，但是它会自动加载上去，在下方的硬盘或者打开硬盘编辑软件都可以看到新多了一块硬盘
5.接下来按照正常的磁盘操作就可以了
通过命令创建创建vhd
1.右键 开始菜单 的 Windows图标 ， 选择 命令行（管理员）/PowerShell（管理员）
2.输入diskpart 进入工具
输入：
create vdisk file=D:\Demo2.vhd maximum=3072 type=fixed*file=D:\Demo2.vhd 就是之后的文件路径 maximum=3072 是以MB算的容量也就是3GB，type=fixed也就是固定大小
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22de4498e8497957d04f4c894f945b3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f21e601314cf845f676baf2cb00c746/" rel="bookmark">
			Matlab 保存指定像素大小的图片， 为什么保存图的实际大小与设置的不一致？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matlab使用getframe函数保存指定像素大小的图片。
使用 set(gcf, 'position', [124,124,800,800]);设置图片位置和大小，可将图片保存为256x256大小。
（代码第3行）
仅把'position'参数从124改成125时，不能保存为期望的256x256大小，反而是320x320大小，这是为什么？？（代码第4行）
试试其他几组position参数，也会出现保存尺寸不对的情况，这是为什么？ 对position有什么要求吗？不解
figure ppp=rand(256,256); FigurePos=[124,124]; % FigurePos=[125,125]; set(gcf, 'position', [FigurePos(1),FigurePos(2),800,800]);	% 设置当前图窗的位置，屏幕左下方为原点， set(gcf, 'color', 'w'); % 背景颜色为白色 set(gca, 'units', 'pixels');	% 设定单位为像素 set(gcf, 'units', 'pixels'); imagesc(ppp); set(gca, 'position',[5, 5,256,256]); % 确定画图区域的位置，即指定的分辨率 set(gca,'xtick',[],'ytick',[],'xcolor','w','ycolor','w') ax = gca; ax.Units = 'pixels'; pos = ax.Position; img = getframe(gcf, pos); imgSize=size(img.cdata); imgSize=imgSize(1:2) % imwrite(img.cdata,'thisFigure.png'); % close % FigurePos-&gt;imgSize % (121,121) -&gt;(320x320) % (122,122) -&gt;(320x320) % (123,123) -&gt;(256x256) % (124,124) -&gt;(256x256) % (125,125) -&gt;(320x320) % (126,126) -&gt;(320x320) % (127,127) -&gt;(256x256) % (128,128) -&gt;(256x256) % (129,129) -&gt;(320x320) % (130,130) -&gt;(320x320) 解决方法1：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f21e601314cf845f676baf2cb00c746/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b8c633b5857e120e264d56b0229aaf7/" rel="bookmark">
			字符串流stringstream--＜sstream＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串流stringstream流详解 一.stringstream是C++提供的一个字符串流，与iostream和fstream的操作方法类似，只是功能不同。要使用字符串流必须包含其头文件&lt;sstream&gt;。
#include&lt;sstream&gt; 二.stringstream字符串流通常用来做数据转换，用于字符串与其他变量类型的转换，相较于c库的转换，更加安全、自动和直接。
三.&lt;sstream&gt;库定义了三种类：istringstream、ostringstream、stringstream
①.istringstream：负责流的输入，将字符串数据转换回其实际类型。
istringstream iss; cout &lt;&lt; typeid(iss).name() &lt;&lt; endl; ②.ostringstream：负责流的的输出，将不同类型的数据转换为字符串类型数据。
ostringstream oss; cout &lt;&lt; typeid(oss).name() &lt;&lt; endl; ③.stringstream：同时负责流的输入和输出(类似于fstream相较于ifstream和ofstream)
stringstream ss; cout &lt;&lt; typeid(ss).name() &lt;&lt; endl; 三种类的内置名称：
四. 通过插入器"&lt;&lt;"和析取器"&gt;&gt;"这两个运算符可以直接对stringstream上的数据进行输入和输出，而将stringstream中的全部数据输出则是使用成员函数str()，有两种形式：
①.void str()：无参数形式，用于将stringstream中的数据以string字符串的形式输出
②.void str(const string&amp;s1)：以字符串为参数，覆盖stringstream流中的数据
C++代码示例：
ostringstream oss; oss &lt;&lt; "GodFishhh and AFish" &lt;&lt; " " &lt;&lt; 20030331 &lt;&lt; endl; //成员函数str()的无参数形式 cout &lt;&lt; oss.str() &lt;&lt; endl; //成员函数str()的有参数形式 oss.str("with parameter"); cout &lt;&lt; oss.str() &lt;&lt; endl; 程序运行结果：
可知oss.str("with parameter")用参数with parameter覆盖了先前oss流中的内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b8c633b5857e120e264d56b0229aaf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60e74920eaeefd8ac1da8be23068118d/" rel="bookmark">
			kettle入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言 一、kettle是什么
二、kettle 安装与基本使用
2.1 kettle 安装
2.2 kettle的基础使用
2.21 做一个简单的转换样例
2.2.2 小技巧
三、转换常用组件使用
3.1 输入模块
3.1.1 生成记录
3.1.2 表输入
3.2 输出模块
3.2.1表输出
3.3.2 插入/更新
3.3.3 更新
3.3 转换模块
3.3.1 字符串操作
3.3.2 字符串替换
3.3.3 字段选择
3.3.4 设置字段值
3.3.5 计算器
3.3.6 去除重复记录
3.3.7 值映射
3.4 应用模块
3.4.1 替换NULL值
3.5 流程模块
3.6 脚本模块
3.6.1 java 代码
3.7 连接模块
3.7.1 记录集连接
3.7.2 合并记录
3.8 统计模块
3.8.1 聚合
3.9 作业模块
3.9.1 设置变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60e74920eaeefd8ac1da8be23068118d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7522499e1e03cb4833917d7d44459e7/" rel="bookmark">
			（05）VUE/JS 保留小数方法合集 (保留两位为例)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分别从四舍五入和是否自动补0这两个方面进行入手。
会四舍五入 1、toFixed()函数
注意：此方法将数值类型的数据改变成了字符串类型
// 四舍五入 var num = 1.6492; num = num.toFixed(2); console.log(num); //1.65 console.log(typeof num); //string 不会四舍五入 1.Math.floor()和Math.ceil()函数
注意：此方法不改变数据类型
var number = 1.7332; var Test1 = Math.floor(number * 100) / 100;//保留两位小数， var Test2 = Math.ceil(number * 100) / 100;//保留两位小数 console.dir(Test1); //1.73 console.dir(typeof(Test1)); // number console.dir(Test2); //1.74 console.dir(typeof(Test2)); // number 2、字符串匹配
注意：此方法先将数据转换为字符串，最后再转为数值类型，不会四舍五入，字符串匹配再转换
var num = 1.6492; // 写法一： num = Number(num.toString().match(/^\d+(?:\.\d{0,2})?/)); console.log(num); //1.64 console.log(typeof num); // number // 写法二： let a = 12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7522499e1e03cb4833917d7d44459e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c1d3196022a153809c4616e6e4c232c/" rel="bookmark">
			Python 实用脚本 实现文件重复去重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、模块说明二、代码部分1.添加文件到列表中2.文件进行判断删除3.完整代码 总结 前言 如果文件夹中有着重复的文件内容，就会白白占用许多空间，所有可以自制一个清除重复文件的脚本。
一、模块说明 import os import glob import filecmp #os模块：提供的就是各种 Python 程序与操作系统进行交互的接口 #glob模块：用来查找文件目录和文件，并将搜索的到的结果返回到一个列表中（通配符） #filecmp模块：python内置的模块，用于比较文件及文件夹的内容 二、代码部分 1.添加文件到列表中 代码如下（示例）：
将文件逐个添加到列表file_list中
file_list=[] for i in glob.glob(dir_path +'/**/*',recursive=True): if os.path.isfile(i): file_list.append(i) 2.文件进行判断删除 代码如下（示例）：
通过filecmp.cmp()进行文件之间的比较，如果相同就删除，删除之前要判断文件是否存在
for x in file_list: for y in file_list: if x!=y and os.path.exists(x) and os.path.exists(y): if(filecmp.cmp(x,y)): os.remove(y) 3.完整代码 代码如下（示例）：
import os import glob import filecmp dir_path=r'D:\文件去重' file_list=[] count=0 for i in glob.glob(dir_path +'/**/*',recursive=True): if os.path.isfile(i): file_list.append(i) for x in file_list: for y in file_list: if x!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c1d3196022a153809c4616e6e4c232c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbd289790f24965e5c212205eefa13f4/" rel="bookmark">
			Python 实用脚本 实现文件自动分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、模块说明二、代码部分1.选择要分类的文件夹2.进行分类3.完整代码 总结 前言 文件夹的文件很杂乱，我们应该怎么去自动整理并且分类呢？
写个简单的python脚本进行整理吧！
一、模块说明 import os import shutil import glob #os模块：提供的就是各种 Python 程序与操作系统进行交互的接口 #shutil模块：它作为os模块的补充，提供了复制、移动、删除、压缩、解压等操作 #glob模块：用来查找文件目录和文件，并将搜索的到的结果返回到一个列表中（通配符） 二、代码部分 1.选择要分类的文件夹 代码如下（示例）：
#设置建立分类总文件夹路径 mkdir_path=r'D:\文件夹分类' #设置需要遍历整理的文件夹路径，可以依据自己的实际需求修改 goal_dir =r'D:\乱七八糟的文件' if not os.path.exists(mkdir_path): os.mkdir(mkdir_path) 2.进行分类 代码如下（示例）：
for file in glob.glob(f'{goal_dir}/**/*',recursive=True): if os.path.isfile(file): filename = os.path.basename(file) if '.' in filename: suffix = filename.split('.')[-1] else: suffix = 'others' if not os.path.exists(f'{mkdir_path}/{suffix}'): os.mkdir(f'{mkdir_path}/{suffix}') shutil.copy(file,f'{mkdir_path}/{suffix}') os.path.isfile()主要就是判断文件是否为常规文件 。
os.path.basename()用来获取路径最后一部分内容 如：D:\乱七八糟的文件\123.txt 获取的就是123.txt
split(‘.’)[-1]就是通过点分割字符串，去字符串切割后的最后一部分 。
剩下的代码主要就是一些文件存在判断。
3.完整代码 代码如下（示例）：
import os #操作系统操作 import shutil #文件复制、移动等 import glob #通配符进行文件的搜索获取 #设置建立分类总文件夹路径 mkdir_path=r'D:\文件夹分类' #设置需要遍历整理的文件夹路径，可以依据自己的实际需求修改 goal_dir =r'D:\乱七八糟的文件' if not os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbd289790f24965e5c212205eefa13f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4765449fec92a2963ae295c1cf2b3318/" rel="bookmark">
			mybatis插入后返回主键id的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种：在xml文件，insert标签属性中，添加useGeneratedKeys和keyProperty，如图
第二种：在xml文件，添加selectKey标签属性，各个属性值含义：resultType:查询结果的类型；keyProperty：把查询的值赋给谁；order：在插入前还是后执行，id在insert语句插入之后才会生成id，所以要在插入之后执行，所以此处order=after；
第三种：在dao层用注解的方式，用@SelectKey注解，里面属性含义：resultType:查询结果的类型，keyProperty：把查询的值赋给谁； statement:查找最后一个插入的id； keyColumn：查询的是哪一列； before：是否在插入之前执行， id在insert语句插入之后才会生成id，所以要在插入之后执行，所以此处before=false；
最后解释一下“select last_insert_id()”这条语句，它是配合插入语句一块只用的，在insert语句执行成功后可以返回新增数据的id，如图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a6d6c4dd73104842cad13c009624429/" rel="bookmark">
			JS 中 reduce()方法及使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		reduce()方法可以搞定的东西特别多，就是循环遍历能做的，reduce都可以做，比如数组求和、数组求积、统计数组中元素出现的次数、数组去重等等。
reduce() 方法对数组中的每个元素执行一个由您提供的reduce函数(依次执行)，将其结果汇总为单个返回值。
1、语法介绍 // arr.reduce(callback,[initialValue]) array.reduce((prev, cur, index, arr)=&gt; { /***/ }, initialValue) reduce 为数组中的每一个元素依次执行回调函数，接受四个参数：初始值 initialValue（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。
参数： 参数一： callback 函数（执行数组中每个值的函数，包含四个参数）：
prev 必需 （上一次调用回调返回的值，或者是提供的初始值（initialValue）） cur 必需（数组中当前被处理的元素） index 可选 （当前元素在数组中的索引） arr 可选 （调用 reduce 的数组） 参数二：initialValue 可选 （表示初始值，作为第一次调用 callback 的第一个参数。）
提供初始值，cur 从数组第一项开始，若不提供初始值，则 cur 从第二项开始执行，对应的第一次 prev 是数组第一项的值 2、实例解析 initialValue 参数 示例一： 没有设置函数的初始迭代值 &lt;script&gt; let arr = [1, 2, 3, 4, 5]; let sum = arr.reduce(function (prev, cur, index, arr) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a6d6c4dd73104842cad13c009624429/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c13498fa57eb28612fb6541f1df63d75/" rel="bookmark">
			【SimpleITK】CT数据的3D space归一化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导入依赖库 import SimpleITK as sitk import matplotlib.pyplot as plt 示例数据 exaple_file = '1.nii.gz' 使用sampleITK读取数据,注意SimpleITK 加载数据是channel_first。 ds = sitk.ReadImage(exaple_file) img_array = sitk.GetArrayFromImage(ds) print(np.shape(img_array)) (150, 986, 512)
即 channel为150。
查看图像的原点Origin，大小Size，间距Spacing和方向Direction。 print(ds.GetOrigin()) print(ds.GetSize()) print(ds.GetSpacing()) print(ds.GetDirection()) (-454.462890625, 274.462890625, -1387.0)
(512, 986, 150)
(1.07421875, 1.07421875, 0.699999988079071)
(-1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0)
查看图像相关的纬度信息 print(ds.GetDimension()) print(ds.GetWidth()) print(ds.GetHeight()) print(ds.GetDepth()) 3
512
986
150
体素类型查询 print(ds.GetPixelIDValue()) print(ds.GetPixelIDTypeAsString()) print(ds.GetNumberOfComponentsPerPixel()) 2
16-bit signed integer
1
查看某一个横断面和冠状面 fig, (ax1, ax2, ax3) = plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c13498fa57eb28612fb6541f1df63d75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f9dcb35736324a03ca7d4a46e4467b1/" rel="bookmark">
			Failed to start apt-news.service Failed to start esm-cache.service
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 luozw@luozw-vpc:/etc/apt/apt.conf.d$ sudo apt-get update Failed to start apt-news.service: Unit apt-news.service not found. Failed to start esm-cache.service: Unit esm-cache.service not found. 命中:1 http://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic InRelease 命中:2 http://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic-updates InRelease 命中:3 http://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic-backports InRelease 命中:4 http://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic-security InRelease 正在读取软件包列表... 完成 cd /etc/apt/apt.conf.d sudo mkdir off sudo mv 20apt-esm-hook.conf off 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b78a43b78a6ad0010114aa88404443ca/" rel="bookmark">
			vue&#43;Springboot项目报：Not allowed to load local resource
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 很久没写vue项目，再次写报了这个错误
其实就是浏览器的保护，不让直接获取本地磁盘的文件
第一步：后端创建配置类，实现 WebMvcConfigurer 接口 package Router.common; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class MyConfigurer implements WebMvcConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler("/image/**").addResourceLocations("file:D:/img/"); } } 第一个 addResourceHandler 方法里面填写你想要设置的虚拟路径，下面
addResourceLocations 方法填写资源的绝对路径。配置完成后，虚拟路径为
http://localhost:配置类端口号/doctor/图片名称。
第二步：前端配置路径 data() { return { rodeList:[], radio:false, checked:[], typeList:[], url:"http://localhost:8080/image/" } }, ``` &lt;td&gt;&lt;img :src="url+router.position" alt="" &gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19513e3e4ec7a5fe95e7bfd911587a92/" rel="bookmark">
			windows10 的rocketMQ安装并测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、RocketMQ是什么？二、准备工作1.环境要求2.下载与解压3.启动MQ4. 测试是否成功启动 三、安装管理端1. 代码下载2. 修改配置文件3. 启动MQ客户端jar包 四、rocketMQ代码的使用入门五、问题记录1. 启动mqbroker.cmd没有反应2.消费者重复消费消息 前言 提示：这里可以添加本文要记录的大概内容：
例如：随着人工智能的不断发展，机器学习这门技术也越来越重要，很多人都开启了学习机器学习，本文就介绍了机器学习的基础内容。
提示：以下是本篇文章正文内容，下面案例可供参考
一、RocketMQ是什么？ RocketMQ是阿里开源的一款非常优秀中间件产品，脱胎于阿里的另一款队列技术MetaQ，后捐赠给Apache基金
会作为一款孵化技术，仅仅经历了一年多的时间就成为Apache基金会的顶级项目。并且它现在已经在阿里内部被
广泛的应用，并且经受住了多次双十一的这种极致场景的压力。（2017年的双十一，RocketMQ流转的消息量达
到了万亿级，峰值TPS达到5600万）。并且其内部通过Java语言开发，便于阅读与修改。
二、准备工作 1.环境要求 64位JDK 1.8+;
Maven 3.2.x;
64位操作系统系统，本文档在Windows上安装
2.下载与解压 下载地址：https://archive.apache.org/dist/rocketmq/4.5.1/
解压到一个无中文无空格的目录下，解压后目录如下：
3.启动MQ 3.1 更改配置
java的默认启动参数中，启动时堆内存的大小为2g，太大了，调整一下
切换路径到D:\rocketmq-all-4.5.1-bin-release\bin
打开runserver.cmd
把-Xms、-Xmx、-Xmn都设置成512m，将%CLASSPATH%增加""，不然启动时会找不到jdk
同理设置 runbroker.cmd
3.2 启动NameServer
双击mqnamesrv.cmd启动，如下显示则启动成功
3.3 启动broker
进入cmd命令窗口，切换到D:\rocketmq-all-4.5.1-bin-release\bin
执行
mqbroker.cmd -n localhost:9876 autoCreateTopicEnable=true 如下显示则启动成功
4. 测试是否成功启动 4.1 监听消息
进入cmd命令窗口，切换到D:\rocketmq-all-4.5.1-bin-release\bin
执行：
set NAMESRV_ADDR=127.0.0.1:9876 tools.cmd org.apache.rocketmq.example.quickstart.Producer 4.2 发送消息
进入cmd命令窗口，切换到D:\rocketmq-all-4.5.1-bin-release\bin
执行：
set NAMESRV_ADDR=127.0.0.1:9876 tools.cmd org.apache.rocketmq.example.quickstart.Producer 三、安装管理端 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19513e3e4ec7a5fe95e7bfd911587a92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e78e6d7726237fd63ca51acb1447bf1/" rel="bookmark">
			习题5-5 使用函数统计指定数字的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浙大版《C语言程序设计（第4版）》题目集参考答案 本题要求实现一个统计整数中指定数字的个数的简单函数。
函数接口定义： int CountDigit( int number, int digit ); 其中number是不超过长整型的整数，digit为[0, 9]区间内的整数。函数CountDigit应返回number中digit出现的次数。
裁判测试程序样例： #include &lt;stdio.h&gt; int CountDigit( int number, int digit ); int main() { int number, digit; scanf("%d %d", &amp;number, &amp;digit); printf("Number of digit %d in %d: %d\n", digit, number, CountDigit(number, digit)); return 0; } /* 你的代码将被嵌在这里 */ 输入样例： -21252 2 输出样例： Number of digit 2 in -21252: 3 提交结果： 基本思路： ***函数递归：&gt;函数自己调用自己***
***整数除以10结果取整，去掉整位的最低位，整数取10的余，余数是整数的最低位***
***负数取余的（非0）余数都是负数***
***缺陷：&gt;整数为全零时无论指定位数是任何一个数，只有记为一，都可以跑对***
1.创建变量统计指定数字的个数
2.给出的整数是负数，可以先转为正数，也可以不转正数而是在判断尾数的值时，增加一个逻辑或余数等于负指定位数，也可以直接函数递归。
3.返回结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e78e6d7726237fd63ca51acb1447bf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e90ba96ecfcfe322f9e7215e8391779/" rel="bookmark">
			mybatis-递归实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mybatis-实现递归 使用场景：当业务中有类似如多级菜单等场景时，可以使用mybatis实现递归。
如果一个属性存的是以逗号分隔的ids数据，另一个属性是分别对应该id数据的数组，可以使用foreach标签实现。
ids:"44,69,70,71,72,73"
list:[{id:44,name:xxx},{id:69,name:xxx},{id:70,name:xxx},...]
1.前端要求格式 { id: xxx, ids: "44,69,70,71,72,73", category_arr: [ { id: 44, name: xxx, children: [ { id: 45, name: xxx, children: [ { id: 55, name: xxx }, ... ] } ] }, { id: 69, name: xxx, children: [] }, ... ] } 2. 实体类 public class TemplateCategoryTabsVo { private Integer id; private String ids; private List&lt;TemplateCategoryTabsDetails&gt; category_arr; } public class TemplateCategoryTabsDetailsVo { private Integer id; private String name; /**父ID*/ private Integer pid; private List&lt;TemplateCategoryTabsDetailsVo&gt; children; } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e90ba96ecfcfe322f9e7215e8391779/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6146a1a7601f5a4c9e9b3def36181873/" rel="bookmark">
			USART_IT与USART_FLAG，USART_GetITStatus与 USART_GetFlagStatus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT) ： 不仅会判断标志位是否置1，同时还会判断是否使能了相应的中断。所以在串口中断函数中，如果要获取中断标志位，通常使用该函数。
FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)：该函数只判断标志位。在没有使能相应的中断函数时，通常使用该函数来判断标志位是否置1
从固件库资料中可以看出，USART_FLAG_RXNE是接收数据寄存器非空标志位，USART_IT_RXNE为接收中断标志位，也就是说，串口一接收到数据，这两个标志位都会被置位。
引用自：USART_FLAG_RXNE与USART_IT_RXNE区别_今天也迟到的博客-CSDN博客_usart_it_rxne
USART_GetITStatus与 USART_GetFlagStatus的区别_辣条boy的博客-CSDN博客
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/185/">«</a>
	<span class="pagination__item pagination__item--current">186/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/187/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>