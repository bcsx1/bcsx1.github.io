<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4d103a3c860b388f9557729f0fdf951/" rel="bookmark">
			RabbitMQ安装教程(Windows版本)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ安装教程(Windows版本) 简介:
RabbitMQ是流行的开源消息队列系统，用erlang语言开发。RabbitMQ是AMQP（高级消息队列协议）的标准实现。
如果不熟悉AMQP，直接看RabbitMQ的文档会比较困难。不过它也只有几个关键概念，这里简单介绍。
安装:
首先需要安装 Erlang环境
官网:
http://www.erlang.org/
Windows版下载地址: http://www.erlang.org/download/otp_win64_17.3.exe
一、安装 Erlang: 首先需要安装 Erlang环境，我这边安装的版本是:otp_win64_24.1.7
点击NEXT按钮，选择安装路径，可以默认。
点击install安装，
中间会弹出安装C++库类，确认安装
安装完成，关闭窗口。
这样 就安装完了 Erlang
然后就可以安装RabbitMQ了
二、安装Rabbitmq 首先下载RabbitMQ 的Windows版本
下载地址:
http://www.rabbitmq.com/
我这边安装的版本是:rabbitmq-server-3.9.11
打开安装程序 按照下面步骤安装:
点击NEXT按钮，选择安装路径，可以默认。
点击Install，
安装完成，点击下一步
点击Finish，安装完成。
安装成功后再开始菜单中可以找到所有安装的应用以及插件。见开始菜单的RabitMQ Server
在开始菜单中，点击RabbitMQ Service Start开启服务，可以到服务管理器中去确认是否开启成功。也可以看控制台输出的状态（图2-6）表示开启成功。
RabbitMQ服务搭建并启动后，需要对RabbitMQ就行进一步的配置，此次安装的版本提供rabbitmq_management插件，此插件通过15672端口来提供对当前RabbitMQ服务的管理以及监控服务。
配置RabbitMQ
在开始菜单中找到RabbitMQ Command Promt，打开控制台
输入命令
rabbitmq-plugins enable rabbitmq_management
在启用插件成功后回看到一些提示信息，重启服务
然后就可以通过 http://server-name:15672（http://ip:15672）访问了，默认用户名称和密码为guest,guest，进入管理页面后
配置允许远程访问 添加账号
由于guest这个用户,只能在本地访问,所以我们要新增一个用户admin，选择超级管理员权限
添加权限（使admin用户对虚拟主机“/” 具有所有权限）:
配置之后，然后就可以远程访问了，然后可直接配置用户权限等信息，到此,就可以通过http://ip:15672
使用admin 进行登陆了。
此时就可以使用账号远程登录了：
说明 RabbitMQ安装的时候会占用几个端口，防火墙和其他安全工具可能会阻止RabbitMQ绑定到端口。当这种情况发生时，RabbitMQ将无法启动。确保可以打开以下端口,当然也可以安装好后自己通过修改配置文件来修改占用的端口，然后开启服务。
如开启了windows版的防火墙，把以下的端口开放（关闭了windows防火墙的可以略过）
4369：epmd，RabbitMQ节点和CLI工具使用的对等发现服务
5672,5671：由AMQP 0-9-1和1.0客户端使用，不带TLS和TLS
25672：Erlang分发用于节点间和CLI工具通信，并从动态范围分配（默认情况下限制为单个端口，计算为AMQP端口+ 20000）。有关详细信息，请参阅网络指南。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4d103a3c860b388f9557729f0fdf951/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a057a14a0b88e92c31f47fea197629b/" rel="bookmark">
			RabbitMQ安装配置教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ是用Erlang编程语言进行开发，所以先要安装Erlang语言开发包
Erlang官网下载地址：Downloads - Erlang/OTP
RabbitMQ官网下载址：Installing on Windows — RabbitMQ
（一）首先安装Erlang
安装Erlang，选进入官网下载适合系统版本
（1）安装开始，直接next
（2）选择安装目录 （3）选择启动文件安装
（4）安装完成直接Close （5）新建一个系统变量,名称为ERLANG_HOME，值为本机中的安装目录，然后在系统变量的PATH中添加%ERLANG_HOME%\bin;
（6）查看安装是否成功：cmd然后erl -version,安装成功有对应版本号
（二）安装RabbitMQ
（1）官网下载安装程序
（2）直接next安装
（3）选择安装目录
（4）RabbitMQ安装好后接下来安装RabbitMQ-Plugins，打开命令进入RabbitMQ的安装目录，我的是F:\Software\RabbitMQ Server\rabbitmq_server-3.8.9\sbin，在执行命令rabbitmq-plugins enable rabbitmq_management进行安装
（5）打开命令行命令行,进入RabbitMQ的安装目录: sbin,输入 rabbitmqctl status , 如果出现以下的图，说明安装是成功的，并且说明现在RabbitMQ Server已经启动了,运行正常
（6）打开sbin目录，双击rabbitmq-server.bat
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b5c646546716612bd23bb05c5ea0180/" rel="bookmark">
			点云处理算法整理（超详细教程）十大点云数据处理技术梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		研究点云数据时，感觉无从下手？
看看这十大点云数据处理技术，换个思路学点云。
点云 · 定义
简言之，在获取物体表面每个采样点的空间坐标后，得到的是一个点的集合，称之为“点云”。包括三维坐标（XYZ）、激光反射强度（Intensity）和颜色信息（RGB）。
点云·数据处理技术
目前，点云处理涉及的技术主要为以下十个：
点云滤波（数据预处理）点云关键点特征和特征描述点云配准点云分割与分类SLAM图优化目标识别检索变化检测三维重建点云数据管理 1、点云滤波（数据预处理）
点云滤波，顾名思义，即滤掉噪声。原始采集的点云数据往往包含大量散列点、孤立点，下图为滤波前后的点云效果对比。
点云滤波的主要方法有：双边滤波、高斯滤波、条件滤波、直通滤波、随机采样一致滤波、VoxelGrid滤波等，这些算法都被封装在了PCL点云库中。
2、点云关键点
在二维图像上，有Harris、SIFT、SURF、KAZE这样的关键点提取算法，这种特征点的思想可以推广到三维空间。从技术上来说，关键点的数量相比于原始点云或图像的数据量减小很多，与局部特征描述子结合在一起，组成关键点描述子常用来形成原始数据的表示，而且不失代表性和描述性，从而加快了后续的识别，追踪等对数据的处理速度，故而，关键点技术成为在2D和3D 信息处理中非常关键的技术。
常见的三维点云关键点提取算法有一下几种：ISS3D、Harris3D、NARF、SIFT3D，
这些算法在PCL库中都有实现，其中NARF算法是比较常见的。
3、特征和特征描述
如果要对一个三维点云进行描述，光有点云的位置是不够的，常常需要计算一些额外的参数，比如法线方向、曲率、文理特征等等。如同图像的特征一样，我们需要使用类似的方式来描述三维点云的特征。
常用的特征描述算法有：法线和曲率计算、特征值分析、PFH、FPFH、3D Shape Context、Spin Image等。
PFH：点特征直方图描述子；
FPFH：跨苏点特征直方图描述子，FPFH是PFH的简化形式。
4、点云配准
点云配准的概念类比于二维图像中的配准，只不过二维图像配准获取得到的是x，y，alpha，beta等放射变化参数，二三维点云配准可以模拟三维点云的移动和对齐，也就是会获得一个旋转矩阵和一个平移向量，通常表达为一个4×3的矩阵，其中3×3是旋转矩阵，1*3是平移向量。严格说来是6个参数，因为旋转矩阵也可以通过罗格里德斯变换转变成1*3的旋转向量。
常用的点云配准算法有两种：正太分布变换和著名的ICP点云配准，此外还有许多其它算法，列举如下：
ICP：稳健ICP、point to plane ICP、point to line ICP、MBICP、GICP
NDT 3D、Multil-Layer NDT
FPCS、KFPSC、SAC-IA
Line Segment Matching、ICL
5、点云分割与分类
点云分割又分为区域提取、线面提取、语义分割与聚类等。一般说来，点云分割是目标识别的基础。
分割：区域声场、Ransac线面提取、NDT-RANSAC、K-Means、Normalize Cut、3D Hough Transform(线面提取)、连通分析
分类：基于点的分类，基于分割的分类，监督分类与非监督分类
6、SLAM图优化
SLAM技术中，在图像前端主要获取点云数据，而在后端优化主要就是依靠图优化工具。而SLAM技术近年来的发展也已经改变了这种技术策略。在过去的经典策略中，为了求解LandMark和Location，将它转化为一个稀疏图的优化，常常使用g2o工具来进行图优化。
下面是一些常用的工具和方法：
g2o、LUM、ELCH、Toro、SPA
SLAM方法：ICP、MBICP、IDC、likehood Field、 Cross Correlation、NDT
7、目标识别检索
这是点云数据处理中一个偏应用层面的问题，简单说来就是Hausdorff距离常被用来进行深度图的目标识别和检索，现在很多三维人脸识别都是采用这种技术。
8、变化检测
当无序点云在连续变化中，八叉树算法常常被用于检测变化，这种算法需要和关键点提取技术结合起来，八叉树算法也算是经典中的经典了。
9、三维重建
我们获取到的点云数据都是一个个孤立的点，如何从一个个孤立的点得到整个曲面呢，这就是三维重建。
在玩kinectFusion时候，如果我们不懂，会发现曲面渐渐变平缓，这就是重建算法不断迭代的效果。我们采集到的点云是充满噪声和孤立点的，三维重建算法为了重构出曲面，常常要应对这种噪声，获得看上去很舒服的曲面。
常用的三维重建算法和技术有：
泊松重建、Delauary triangulatoins表面重建，人体重建，建筑物重建，输入重建实时重建：重建纸杯或者龙作物4D生长台式，人体姿势识别，表情识别 10、点云数据管理
主要包含以下几方面：点云压缩，点云索引（KDtree、Octree），点云LOD（金字塔），海量点云的渲染。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b5c646546716612bd23bb05c5ea0180/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82226ad3707b3282ee7c0fca0f0232a5/" rel="bookmark">
			pip安装python第三方库的四种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、无镜像安装二、镜像安装三、一劳永逸式镜像安装四、批量安装总结 一、无镜像安装 pip install 库名
打开命令提示符【win + r】,输入cmd，在命令提示窗口输入pip install 库名， 再点击回车键【Enter】，就可以安装。当安装成功时，会提示successfully。例如，安装pytest库
使用该方法会存在由于网络不稳定时就无法安装成功的情况，遇到此情况时，可以多尝试几次，若还是不成功，可以使用国内源安装。 二、镜像安装 pip install 库名 -i 源地址
例如使用清华大学镜像源：
国内镜像源，部分例举如下：
清华大学： http://pypi.tuna.tsinghua.edu.cn/simple
豆瓣：http://pypi.douban.com/simple/
阿里云：http://mirrors.aliyun.com/pypi/simple/
使用该方法最好将镜像源保存到本地，不然每次安装第三方库都要网上找到。尽管网上查找很快就能够找到，但是总觉得还是不够快捷，因此有另一种方法可以更加便捷快速安装，详情查看第三章。
三、一劳永逸式镜像安装 第一步：【win + r】打开运行窗口，再输入%appdata%打开到appdata文件夹
第二步：新建pip文件夹，并在文件夹中新建pip.ini配置文件，在pip.ini配置文件添加以下信息：
[global]
timeout = 6000
index-url = https://pypi.tuna.tsinghua.edu.cn/simple
trusted-host = pypi.tuna.tsinghua.edu.cn
配置信息中的超时时间可以自定义，上面的镜像源使用的清华大学的。
第三步：在命令提示符窗口，直接使用 pip install 库名，安装时会自动链接使用镜像源。
通过一次全局配置镜像源，后续只需要在命令提示符窗口使用 pip install 库名即可。
四、批量安装 批量安装是通过使用pycharm来进行的，操作步骤如下：
第一步：在工程文件的根目录新建txt文件，如product.txt（文件名可自定义），填写需要安装的库名。
下面是我在学习自动化测试需要安装的第三方库。
第二步：在终端terminal中输入：pip install -r product.txt。
product.txt为自定义的名字。
【注】一劳永逸式的镜像安装和批量安装不会冲突，当全部配置使用镜像安装后，在pycharm中批量安装库也能链接镜像源。
总结 1、建议使用一劳永逸式镜像安装的方法，通过全局配置镜像源，然后使用pip install 库名。
2、一般是在已知需要安装多个库的情况下使用批量安装方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56d45146b8b123eddc97f4f9ce7bf289/" rel="bookmark">
			关于Guid的规律
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 根据代码看规律Guid与Int互相转换一、未混淆二、增加混淆二、混淆复杂化 根据代码看规律 如果是代码，可以看到Guid是非常有规律的
byte[] bytes; bytes = new byte[16] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; Console.WriteLine(new Guid(bytes)); // 00000000-0000-0000-0000-000000000000 bytes = new byte[16] { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }; Console.WriteLine(new Guid(bytes)); // ffffffff-ffff-ffff-ffff-ffffffffffff bytes = new byte[16] { 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56d45146b8b123eddc97f4f9ce7bf289/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5db2387f470d36789dc441c26a85c81f/" rel="bookmark">
			在Linux上利用python获取本机ip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面介绍在Linux上利用python获取本机ip的方法.
经过网上调查, 发现大致有两种方法, 一种是调用shell脚本,另一种是利用python中的socket等模块来得到,下面是这两种方法的源码:
#!/usr/bin/env python #encoding: utf-8 #description: get local ip address import os import socket, fcntl, struct def get_ip(): #注意外围使用双引号而非单引号,并且假设默认是第一个网卡,特殊环境请适当修改代码 out = os.popen("ifconfig | grep 'inet addr:' | grep -v '127.0.0.1' | cut -d: -f2 | awk '{print $1}' | head -1").read() print out #另一种方法, 只需要指定网卡接口, 我更倾向于这个方法 def get_ip2(ifname): s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) return socket.inet_ntoa(fcntl.ioctl(s.fileno(), 0x8915, struct.pack('256s', ifname[:15]))[20:24]) if __name__ == '__main__': get_ip() print get_ip2('eth0') print get_ip2('lo') 下面是运行截图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5db2387f470d36789dc441c26a85c81f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26838029ef4252621065fde59eaf860b/" rel="bookmark">
			网络抓包工具使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，c类地址划分 子网掩码子网数ip地址个数可用主机数252128 126
26464622783230281616142932 86306442 2，wireshark 捕获过滤器和应用显示过滤
time捕获时间 source源ip地址 desination 目的ip protocol 协议
length包含包头长度 info信息 len 数据长度
流量抓取工具 (wireshark)
网卡
wireshark是对主机网卡上的数据流量进行抓取
1、网卡模式 混杂模式:不管目的是否是自己，都接收
非混杂模式;默认情况下，主机的网卡处于此模式，不会接收目的非自己的数据
2、两种过滤器 捕获过滤:在抓包之前先进行过滤(只抓某种类型的包或者不抓某些类型的包)
显示过滤器:抓包前后抓包后都可以进行过滤，但是不会影响抓取的包(会抓取所有的包，只不过在查看的时候只显示某些包)
3、过滤器 捕获过滤器 语法类型: host net port方向: src dst协议: ether ip tcp udp http ftp.........逻辑运算符: &amp;&amp;与 ||或 not（!）非举例 1.#抓取源地址为192.168.1.1，目的端口为80的流量
src host 192.168.1.1 &amp;&amp; dst port 80
2.#抓取192.168.1.1和192.168.1.2的流量
host 192.168.1.1 host 192.168.1.2
3.#不要抓广播包
! broadcast
4.#抓取目的UDP端门为4569的封包
udp dst port 4569
5.#抓取目的或来源IP地址为192.168.4.7的封包
host 192.168.4.7
6.#抓取来源为TCP或UDP，并且端口在2000~5000范围内的封包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26838029ef4252621065fde59eaf860b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/382d74a082551a275466efa1f823b411/" rel="bookmark">
			KY271 加法等式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 KY271 加法等式 for a in range(1,10): for b in range(1,10): for c in range(10): if 100*a+110*b+12*c==532: print(a,b,c) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5833004db457907a182cb4056e2e9add/" rel="bookmark">
			Kafka系列 - 06 Kafka 集群环境搭建（三台服务器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 克隆虚拟机2. Zookeeper 集群搭建3. Kafka 集群搭建4. 测试消息发送和消费1. 主题操作2. 生产者生产消息3. 消费者消费消息 1. 克隆虚拟机 kafka集群搭建，需要3台虚拟机环境，但是我目前只安装了一台虚拟机，因此还需要准备两台虚拟机环境，正常情况下应该再安装2台虚拟机，这里为了方便直接克隆出3台虚拟机。
① 选中 CentOs7 右键—&gt; 管理—&gt; 克隆—&gt; 执行克隆操作：
② 下一页，选择创建完整克隆:
③ 填入虚拟机名称和安装位置：
④ 按照上面的步骤创建3台虚拟机环境，先不要开机不然会ip地址冲突：
⑤ 修改每台虚拟机的IP地址：vi /etc/sysconfig/network-scripts/ifcfg-ens33
hadoop-101 虚拟机的 IPADDR 的地址改为：192.168.38.23；hadoop-102 的改为192.168.38.24；hadoop-103 虚拟机的 IPADDR 的地址改为：192.168.38.25；
⑥ 修改每台虚拟机的主机名称 hostname：vi /etc/hostname
hadoop-101 虚拟机的 hostname 改为：hadoop101；hadoop-102 虚拟机的改为：hadoop102；hadoop-103 虚拟机的 hostname 的地址改为：hadoop103；
⑦ 将每台虚拟机的 hostname 和 ip 绑定，添加下面三行：vi /etc/hosts
⑧ 执行 reboot 命令重启每台虚拟机，然后使用 mobaxterm/xshell工具连接每台虚拟机。
2. Zookeeper 集群搭建 在前面文章 Kafka - 03 Kafka安装 | 单机环境搭建 | 伪集群环境搭建 (一台虚拟机) 中，我使用一台虚拟机环境搭建了kafka伪集群，而我们现在的3台虚拟机是基于这台虚拟机克隆的，因此 jdk 、 zookeeper 、kafka 已经安装了，我们只需要修改一些配置文件就行了，他们的安装目录如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5833004db457907a182cb4056e2e9add/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/504d90d7c4207c5750e4e9a3e1c3489f/" rel="bookmark">
			查找的知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
思维导图：
一.基本概念：
二、查找方式：
a.顺序查找
b.二分查找
c.二叉排序树
d.哈希表
前言：
查找：就是在数据集合中寻找满足某种条件的数据对象。
思维导图： 一.基本概念： 查找：就是在数据集合中寻找满足某种条件的数据对象。
关键码：在每个对象中有若干属性，其中有一个属性，其值可唯一地标识这个对象，称为关键码。
静态搜索：搜索结构在插入和删除等操作的前后不发生改变。
动态搜索：为保持高的搜索效率，搜索结构在执行插入和删除等操作的前后将自动进行调整，结构可能发生变化。
静态：有序查找、折半查找
动态：非线性-树
ASL(平均查找长度):衡量查找算法的好坏
ASL=∑(i=1-&gt;n)PiCi
Pi为查找概率 Ci为查找次数
二、查找方式： 注：下面代码只给算法代码，源码可在GitHub搜索Lookdrama中的Loodrama-s-daily-firy下查询
a.顺序查找 操作过程：从表中的第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查索引；如果知道最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。
平均查找长度：(n+1)/2
时间复杂度：O(n)
代码：
int search(List* list,int key) { for(int i=0;i&lt;list-&gt;num;i++) { if(list-&gt;data[i]==key) { return i;	//查找成功 } } return -1;	//查找失败 } //改进顺序查找算法 int search(List* list,int key) { int i; list-&gt;data[0]=key; //设置一个哨兵 for(i=(list-&gt;num)-1;list-&gt;data[i]!=key;i--)	//倒着查找 { ; } return i; } 改进之后的算法：可以少一次判断list是否会超出链表长度 b.二分查找 操作过程：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/504d90d7c4207c5750e4e9a3e1c3489f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2df766a89520d3c8ef0b6f1b34f94f6e/" rel="bookmark">
			关于python numpy中元素个数和值的求和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在数组统计中，有数组元素值的求和，数组元素个数的求和。 aa=np.array([-3, -2, -1, 0, 1, 2, 3, 4]) bb=np.array([-7, -6, -5, 0, 5, 6, 7, 8]) b=((bb &gt; 6) | (bb&lt;-6)) * aa # 比如bb为aa的显著性，6为显著性阈值，求aa中显著的元素。 a1=np.sum(aa) #整个数组值的求和。 a2=np.sum(aa &gt; 0) #大于0的元素个数求和。 a3=np.sum(aa[aa&gt;0]) #大于0的元素值求和。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd2c55c3fc6f01940811d7fa1bec74c3/" rel="bookmark">
			MySQL查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、查询语句关键字 distinct：去重，去掉表中重复的字段 例：select distinct name from student;
order by … asc：按从小到大排序分组
order by … desc：按从大到小分组
order by：分组排序，默认按照升序对记录进行排序
asc,desc：排序
group by：用于结合合计函数，根据一个或多个列对结果集进行分组
Having：where关键字无法与合计函数一起使用，所以having常常合group by一起使用
union操作符用于合并两个或多个select语句的结果集
count()：返回数值匹配指定条件的函数
min()：返回一列中最小的值，null值不包含在计算中
max()：返回一列中最大的值，null值不包含在计算中
avg()：avg函数返回数值列的平均值。Null值不包含在计算中
sum()：返回数值列的总数
between and :寻找在…之间的值
not between and:寻找不在…之间的值
(not) Like 模糊查询， like’%11’:查询含有11的值
not like’%11’：查询不含11的值
in(val1,val2)：在where语句中查询列中包含的值
not in(val1,val2)：在where语句中查询列中不包含的值
is null：查询列值为空的行
is(not) null：查询某列值不为空的行
all()：满足子查询中所有值的记录
any()/some()：满足集合中任意一值
in()：字段内容是否是结果集合或者子查询中的内容
exists()：当子查询结果不为空集（存在）时，返回逻辑真，否则返回逻辑假
=、&lt;、&gt;、&lt;=、&gt;=、
查询当前的年月日：select year(curdate()),month(curdate()),day(curdate())
1.join...on...实现连接查询
select s.sno,sname,cname,grade from s join sc on sc.sno=s.sno join c on sc.cno=c.cno;
2.嵌套查询 in/not in
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd2c55c3fc6f01940811d7fa1bec74c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73cdaccfd30ba6b7b1a91ade431092e1/" rel="bookmark">
			ARM64页表映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.ARMv8-A架构 基于ARMv8-A架构的处理器最大可以支持到48根地址线，也就是寻址2的48次方的虚拟地址空间，即虚拟地址空间范围为0x0000_0000_0000_0000～0x0000_FFFF_FFFF_FFFF，共256TB。一个是从0x0000_0000_0000_0000到0x0000_FFFF_FFFF_FFFF，另外一个是从0xFFFF_0000_0000_0000到0xFFFF_FFFF_FFFF_FFFF。基于ARMv8-A架构的处理器支持的页面大小可以是4KB、16KB或者64KB。映射的层级可以是3级或者4级（地址范围是不一样的）。 下面是页面大小为4KB，地址宽度为48位，4级映射的内存分布图：
下面是页面大小为4KB，地址宽度为48位，3级映射的内存分布图：
2.示例4KB大小页面，48位地址宽度，4级映射 如果输入的虚拟地址最高位bit[63]为1，那么这个地址是用于内核空间的，页表的基地址寄存器用TTBR1_EL1(Translation Table Base Register 1)。如果bit[63]等于0，那么这个虚拟地址属于用户空间，页表基地址寄存器用TTBR0。TTBRx寄存器保存了第0级页表的基地址（L0 Table base address, Linux内核中称为PGD）, L0页表中有512个表项（Table Descriptor），以虚拟地址的bit[47:39]作为索引值在L0页表中查找相应的表项。每个表项的内容含有下一级页表的基地址，即L1页表（Linux内核中称为PUD）的基地址。PUD页表中有512个表项，以虚拟地址的bit[38:30]为索引值在PUD表中查找相应的表项，每个表项的内容含有下一级页表的基地址，即L2页表（Linux内核中称为PMD）的基地址。PMD页表中有512个表项，以虚拟地址的bit[29:21]为索引值在PMD表中查找相应的表项，每个表项的内容含有下一级页表的基地址，即L3页表（Linux内核中称为PTE）的基地址。在PTE页表中，以虚拟地址的bit[20:12]为索引值在PTE表中查找相应的表项，每个PTE表项中含有最终的物理地址的bit[47:12]，和虚拟地址中bit[11:0]合并成最终的物理地址，完成地址翻译过程。 3.示例39位有效位，4KB大小页面，3级页表 当CONFIG_PGTABLE_LEVELS=4时：pgd--&gt;pud--&gt;pmd--&gt;pte;当CONFIG_PGTABLE_LEVELS=3时，没有PUD页表：pgd(pud)--&gt;pmd--&gt;pte; 4.pgd_offset_k函数 通过pgd_offset_k()宏来得到具体的PGD页面目录项的表项。首先通过init_mm数据结构的pgd成员来获取PGD页表的基地址，然后通过pgd_index()来计算PGD页表中的偏移量offset。
/* to find an entry in a kernel page-table-directory */ #define pgd_offset_k(addr) pgd_offset(&amp;init_mm, addr) #define pgd_offset(mm, addr) ((mm)-&gt;pgd+pgd_index(addr)) /* to find an entry in a page-table-directory */ #define pgd index(addr) (((addr) &gt;&gt; PGDIR SHIFT) &amp; (PTRS PER PGD - 1)) 通过计算可以得到PGDIR_SHIFT等于39, PUD_SHIFT等于30, PMD_SHIFT等于21。每级页表的页表项数目分别用PTRS_PER_PGD、PTRS_PER_PUD、PTRS_PER_PMD和PTRS_PER_PTE来表示，都等于512。PGDIR_SIZE宏表示一个PGD页表项能覆盖的内存范围大小为512GB。PUD_SIZE等于1GB, PMD_SIZE等于2MB, PAGE_SIZE等于4KB。 5.create_mapping函数 通过init_mm数据结构的pgd成员来获取， swapper_pg_dir全局变量指向PGD页表基地址。
[arch/arm64/kernel/vmlinux.lds.S] idmap_pg_dir = .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73cdaccfd30ba6b7b1a91ade431092e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/755d41bf7c8d7c61454cd435a7a0cebd/" rel="bookmark">
			OceanBase-安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 部署规划机器准备统一配置hosts设置设置机器名和静态ip关闭大页配置信息查看时钟源ntp配置（需要所有机器root）磁盘规划创建用户配置limits.conf配置sysctl.conf关闭防火墙关闭SELinux 克隆虚拟机差异化配置中控机设置无密码SSH登录目标机器时钟源ntp配置（需要所有机器root） 部署下载&amp;解压安装OBD安装数据库 部署规划 本文主要是安装部署oceanbase4.0.
按照官方的要求，测试环境要求最低2C8G（实测可用内存最少10g，虚拟机设置12g采购）我准备了几台centos7.9的虚拟机，配置如下
机器名ip地址配置说明dev3192.168.1.1534C12G 磁盘80g/app/observer 部署OceanBase ,/data作为数据目录dev4192.168.1.1544C12G 磁盘80g/app/observer 部署OceanBase ,/data作为数据目录dev5192.168.1.1554C12G磁盘80g/app/observer 部署OceanBase ,/data作为数据目录dev6192.168.1.1564C12G中控机、OBD、OBProxy、OCP、NTP服务器 名词解析
中控机：存储Oceanbase数据库安装包和集群配置信息的机器目标机器：安装OceanBase数据库的机器OBD：Oceanbase Deployer，Oceanbase 开源软件的安装部署工具，简称OBDOBProxy：Oceanbase Database Proxy, OceanBase高性能反向代理服务器，简称OBProxyOCP: OceanBase cloud Platform OceanBase运维管理工具，简称OCP note: 1，ob数据库的安装需要至少50g的磁盘，如果你计划将ob安装到指定目录，必须保证磁盘空间大于50g，我使用虚拟机，手动分区；2，部署ob虚拟机设置内存最少12g（可用内存得10g，cache不算进去）；
机器准备 说明几点：
我物理机48G内存，使用VMware虚拟机；
服务统一使用centos 7.9;
虚拟机创建时，最大磁盘填写100g，将虚拟机磁盘存储为单个文件
内存设置12g，11g内存ob在操作时只识别到5.7，最低要求可用8g内存(4.0应该是至少10G内存)；
通过echo 3 &gt; /proc/sys/vm/drop_caches 释放缓存 cpu设置为2个处理器，每个处理器2核
网络模式为桥接模式
特别提醒：安装操作系统时磁盘要选手动设置，如果不选手动设置，自动分区，会平分，导致不够50g，手动分区如下：
统一配置 note: 先在一个虚拟机里把所有的配置都配置好，等配置完成后，再复制出来3台，个性化的修改下，省的一个个的配置了。
hosts设置 [root@dev ~]# vim /etc/hosts # 添加的内容 192.168.1.153 dev3 192.168.1.154 dev4 192.168.1.155 dev5 192.168.1.156 dev6 # 保存并退出 设置机器名和静态ip #修改主机名,先统一为dev [root@dev ~]# vim /etc/hostname # 修改为静态ip [root@dev ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens33 #替换为以下内容 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=no IPV6_AUTOCONF=no IPV6_DEFROUTE=no IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 UUID=7ab82905-739a-4a1a-8784-57f62d25ef32 DEVICE=ens33 ONBOOT=yes IPADDR=192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/755d41bf7c8d7c61454cd435a7a0cebd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5150db95f993fa6439060f08cc490266/" rel="bookmark">
			Python练习之缺失值处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(1)构造如图1所示的数据框，并在此基础上构建如图2所示的含缺失值的数据框。
import pandas as pd import numpy as np #运用元组创建一个panda data = { "A": [0,4,8,12,16,20], "B": [1,5,9,13,17,21], "C": [2,6,10,14,18,22], "D": [3,7,11,15,19,23], } df = pd.DataFrame(data, index=["2022-12-20", "2022-12-21", "2022-12-22", "2022-12-23","2022-12-24","2022-12-25"]) print(df) #修改数据，出现None print() print("构建如图2所示的含缺失值的数据框:") df.iloc[0,1] = np.nan df.iloc[1,2] = np.nan print(df) #删除含None的行，注意axis的值，此处形成的是新对象，不改变df print() print("删除掉有NaN的行:") #df1 = df.dropna(axis=0,how='any') #print(df1) print(df.dropna(axis=0,how='any')) #删除含None的列，注意axis的值，此处形成的是新对象，不改变df print() print("删除掉有NaN的列:") #df2 = df.dropna(axis=0,how='any') #print(df2) print(df.dropna(axis=1,how='any')) #替换None的值 print() print("替换NaN值为0:") #df3 = df.fillna(0) #print(df3) print(df.fillna(0)) #检测数据中是否存在None print() print("检测数据中是否存在None:") #df4 = df.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5150db95f993fa6439060f08cc490266/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94f60b1c9e8704de6ec412aa11230d4b/" rel="bookmark">
			SuperMap iDesktopX 11i 工作空间迁移插件使用说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 概述2. 环境准备达梦客户端环境配置 3. 安装工作空间迁移插件4. 迁移工作空间5. 注意事项 1. 概述 SuperMap iDesktopX 11i 扩展插件，主要用于对数据库型工作空间进行整体迁移，包括：工作空间、数据源、数据集、地图、场景、图表、模型、视频地图、大屏、表格 以及 资源 等。
2. 环境准备 软件版本下载地址说明SuperMap iDesktopX11iSuperMap iDesktopX 11i 下载地址目前该插件仅支持 iDesktopX 11i 版本，不建议在之前的版本使用DM 管理工具V8达梦数据库镜像下载地址DM管理工具无单独下载地址，下载完整的达梦数据库镜像后安装时选择只安装 DM管理工具 达梦客户端环境配置 达梦 V7 和 V8 的客户端并不通用，目前该工作空间迁移插件暂时仅支持 DM V8 版本；安装达梦客户端后，需要在将其安装路径配置到系统环境变量中（如：C:\dmdbms\bin）。 3. 安装工作空间迁移插件 启动 SuperMap iDesktopX 11i 桌面端，进入 视图 》 自定义 》 插件管理；
在 插件管理 对话框中选择 在线插件，找到 工作空间迁移 插件，点击 一键安装；
若未从 在线插件 页面找到 工作空间迁移 插件，则可以从 工作空间迁移插件下载地址 中下载该扩展插件包，通过 本地插件》导入安装 的方式进行安装；
在 插件管理 对话框中选择 本地插件 》 导入安装，选择下载的 SuperMap iDesktopX 11i 工作空间迁移插件.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94f60b1c9e8704de6ec412aa11230d4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cd3ed74bf8fffcf35c6c21b3b68cafb/" rel="bookmark">
			scannet数据集简介和下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期打算复现pointcontrast这个模型做语义分割，一直卡在数据集的下载上，觉得有必要搞明白这个数据集是怎么回事。这里要非常感谢两个博主，下面有他们博文的连接，写的很好，我这里整理一下思路。
数据集简介 数据集的github地址
ScanNet 是一个 RGB-D 视频数据集，包含 1500 多次扫描中的 250 万个视图，并使用 3D 相机姿势、表面重建和实例级语义分割进行注释 。 ScanNet V2数据集一共1.2T 。（但其实不用全下载，按照对应的任务有选择的下载）
RGB-D 传感器是一种特定类型的深度感应设备，与RGB（红色、绿色和蓝色）传感器相机配合使用。 它通过在每个像素的基础上使用深度信息（与传感器的距离相关）来增强传统图像，即RGBD = RGB + Depth Map。
数据集怎么制作的呢？
斯坦福的博士团队收集3D重建数据，用有效的方式对数据进行标注，来收集更多数据。团队通过收集RGB-D的视频序列，通过ipad应用加深传感器收集，然后视频会被上传到服务器，并被自动重建。 然后，视频会被给到亚马逊 Mechanical Turk，将标注工作众包出去。
2.数据怎么标注的呢？
​ 在一个给定的3D场景中，绘制出物体，可以是椅子、桌子或者计算机，从而了解每个物体，以及对应的 所在位置。每个图像通常需要5个人来标注。所得数据可以在做物体分类这样的训练任务。主要的任务就是 给3D数据赋予语义解释，这样有利于机器人更好的理解世界。
数据集介绍
一共1513个采集场景数据（每个场景中点云数量都不一样，如果要用到端到端可能需要采样，使每一个场景的点都相同），共21个类别的对象，其中，1201个场景用于训练，312个场景用于测试 。
ScanNet 中的数据按 RGB-D 序列组织。每个序列都存储在名为 scene &lt; spaceId &gt; &lt; scanId &gt; 或 scene%04d_%02d 的目录下，其中每个空间对应一个唯一位置（从 0 开始索引）。扫描期间捕获的原始数据、相机姿势和表面网格重建以及注释元数据都针对给定序列存储在一起。该目录具有以下结构：
数据集目录结构：虽然解释了但还是没太看懂。。。。。但大概知道里面是2D和3D数据，如果点云的话不需要2D的数据。
&lt;scanId&gt; |-- &lt;scanId&gt;.sens 包含颜色帧、深度帧、相机姿势和其他数据的 RGB-D 传感器流 RGB-D传感器流（*sens）：压缩二进制格式， 包含每帧的颜色、深度、相机姿势和其他数据。 其中RGB图像大小为1296×968，深度图像大小为640×480 |-- &lt;scanId&gt;_vh_clean.ply High quality reconstructed mesh 高质量重建网格 |-- &lt;scanId&gt;_vh_clean_2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cd3ed74bf8fffcf35c6c21b3b68cafb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fab00d0180c670630852fe3c91666350/" rel="bookmark">
			【Docker】从零开始将自己的应用打包到docker镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景是这样：
有一个python写的web服务，希望打包到容器中，通过容器去启动。
参考了网上各种文档，都感到说的不清不楚，实际操作过程中，又遇到了不少的坑，这里摸索OK后记录一下。
docker的安装和部署此处不再赘述。以下从docker安装完成后开始讲。 首先，我们写一个demo，使用了python的flask框架，文件名为 app.py 。
我们的目的是，将这个代码以服务的形式，打包到docker镜像中。
from flask import Flask app=Flask(__name__) @app.route('/') def hello(): return 'hello world' if __name__=='__main__': app.run(host='0.0.0.0',debug=True,port='7777') 本地路径如下图
可以看到，最外层目录是 mydocker ，内部是bdtools，app.py就放置在最内层。
首先，requirements.txt的内容如下图，这为了安装python依赖包：
然后我们开始编写Dockerfile
FROM python:3.8 # 拉取一个基础镜像，基于python3.8 MAINTAINER BH8ANK　# 维护者信息 ADD ./bdtools/ /code/bdtools/ # 将你的项目文件放到docker容器中的/code/bdtools文件夹，这里code是在根目录的，与/root /opt等在一个目录 # 这里的路径，可以自定义设置，主要是为了方便对项目进行管理 RUN cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; echo 'Asia/Shanghai' &gt;/etc/timezone # 设置容器时间，有的容器时区与我们的时区不同，可能会带来麻烦 ENV LANG C.UTF-8　# 设置语言为utf-8 WORKDIR /code/bdtools　# 设置工作目录，也就是下面执行 ENTRYPOINT 后面命令的路径 RUN /usr/local/bin/pip3 install -r requirements.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fab00d0180c670630852fe3c91666350/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85ceda95b6cdd9494c21f77e57da13ac/" rel="bookmark">
			OpenCV读取某个文件夹下的所有图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以使用cv::glob()函数；
函数原型如下：
void cv::glob(cv::String pattern, std::vector&lt;cv::String&gt;&amp; result, bool recursive = false)
函数参数如下：
pattern：图像路径名称；result：路径下所有图片的路径名称集合；recursive：是否包含子文件夹下的图片； 函数封装及测试代码如下：
bool ReadImage(std::string str_imgs_folder, std::vector&lt;cv::Mat&gt;&amp; vec_mat_imgs) { std::vector&lt;std::string&gt; vec_imgs_name; cv::glob(str_imgs_folder, vec_imgs_name, false); size_t i_imgs_num = vec_imgs_name.size(); if (i_imgs_num &lt; 1) { return false; } vec_mat_imgs.resize(i_imgs_num); for (size_t i = 0; i &lt; i_imgs_num; ++i) { cv::Mat image = cv::imread(vec_imgs_name[i], cv::IMREAD_GRAYSCALE); if (image.empty()) { return false; } vec_mat_imgs[i] = image; } return true; } int main() { std::string str_imgs_folder = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85ceda95b6cdd9494c21f77e57da13ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/772ad24567c5fcc7760116921ca38084/" rel="bookmark">
			Linux安装Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 安装依赖
2.下载安装包
3.解压安装包并安装
4.启动Redis服务
Redis约定次版本号（即第一个小数点后的数字）为偶数的版本是稳定版（如2.8版、3.0版），奇数版本是非稳定版（如2.7版、2.9版），生产环境下一般需要使用稳定版本。
1. 安装依赖 redis是由C语言开发，因此安装之前必须要确保服务器已经安装了gcc，可以通过如下命令查看机器是否安装：
[root@localhost ~]# gcc -v 如果没有安装则通过以下命令安装：
[root@localhost ~]# yum install -y gcc 2.下载安装包 访问查看需要的版本：Index of /releases/
安装包统一存放到/opt/software目录下，没有则进入/opt目录执行创建mkdir software创建
[root@localhost ~]# cd /opt/software [root@localhost software]# wget http://download.redis.io/releases/redis-6.2.6.tar.gz 如果提示wget找不到通过一下命令安装：
[root@localhost software]# yum -y install wget 3.解压安装包并安装 解压安装包
[root@localhost software]# tar xzf redis-6.2.6.tar.gz -C /usr/local 进入解压目录并编译
#进入解压目录 [root@localhost software]# cd /usr/local/redis-6.2.6 #编译 [root@localhost redis-6.2.6]# make #指定安装目录并进行安装 [root@localhost redis-6.2.6]# make install PREFIX=/usr/local/redis-6.2.6 4.启动Redis服务 通过守护进程方式启动（redis默认不是以守护进程方式运行的，也就是说当你启动redis的窗口关闭的时候，redis链接会关闭，如果改为守护进程模式的话，他会把进程号写入你配置文件中配置的进程文件中，他不会因为你启动窗口的关闭而关闭redis服务端）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/772ad24567c5fcc7760116921ca38084/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5b11be3478a02ab6b30c20f94ff13fb/" rel="bookmark">
			Linux安装Maven
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.下载安装包
2.解压Maven
3.添加环境变量
4.检测Maven是否搭建成功
5. 编辑 Maven的settings.xml文件
5.1设置本地仓库
5.2添加阿里云镜像
1.下载安装包 访问查看需要的版本：Index of /dist/maven (apache.org)
安装包统一存放到/opt/software目录下，没有则进入/opt目录执行创建mkdir software创建
[root@localhost ~]# cd /opt/software [root@localhost software]# wget https://archive.apache.org/dist/maven/maven-3/3.8.1/binaries/apache-maven-3.8.1-bin.tar.gz --no-check-certificate 2.解压Maven 个人开发工具和环境一般都解压到了/usr/local目录下，因此输入：
[root@localhost software]# tar -zxvf apache-maven-3.6.1-bin.tar.gz -C /usr/local 3.添加环境变量 首先打开环境变量，输入：
[root@localhost software]# vim /etc/profile 然后在末尾添加：（路径视情况而定)
export MAVEN_HOME=/usr/local/apache-maven-3.8.1 export PATH=$MAVEN_HOME/bin:$PATH 使用ESC键，保存并退出输入
:wq 然后输入：source /etc/profile 使环境变量生效
[root@localhost software]# source /etc/profile 4.检测Maven是否搭建成功 执行命令：
[root@localhost software]# mvn -v 如图所示配置成功。但是配置还没有结束
5. 编辑 Maven的settings.xml文件 5.1设置本地仓库 执行命令：
[root@localhost software]# vi /usr/local/apache-maven-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5b11be3478a02ab6b30c20f94ff13fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e55ca1abea89eac2bf228f33e142fc5/" rel="bookmark">
			Linux安装Nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
安装包下载
1.安装Nginx
2.配置环境变量
3.开机启动配置
4.配置HTTPS
安装包下载 nginx: download
1.安装Nginx 1.1 安装依赖：压缩包一般放在/opt/software目录下，没有则创建
[root@localhost software]# yum -y install gcc zlib zlib-devel pcre pcre-devel openssl openssl-devel make 1.2 解压安装包并切换到文件夹中：
[root@localhost software]# tar -zxvf /opt/software/nginx-1.22.0.tar.gz [root@localhost spftware]# cd nginx-1.22.0 1.3 开始执行编译、安装(一并安装SSL模块)：
[root@localhost nginx-1.22.0]# ./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module [root@localhost nginx-1.22.0]# make &amp;&amp; make install 1.4 查看是否安装成功
[root@localhost nginx-1.22.0]# /usr/local/nginx/sbin [root@localhost nginx-1.22.0]# ./nginx -V 显示如下：
nginx version: nginx/1.22.0 built by gcc 4.8.5 20150623 (Red Hat 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e55ca1abea89eac2bf228f33e142fc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00d20185b364c9f6bc3c5fb215ee10dd/" rel="bookmark">
			5种CSS3鼠标悬停图片显示文字信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载地址
5种CSS3鼠标悬停图片显示文字信息是一款鼠标悬停特效，含5种不同风格的鼠标悬停图片显示文字信息。
dd:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c15b6911ae5b042e9f070310b0f5bb0/" rel="bookmark">
			Mysql(下载、安装、环境配置详细图文)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：安装之前需要先确认好自己需要哪个版本的mysql，避免浪费时间。
文章目录 一、Mysql下载二、Mysql安装三、验证Mysql安装是否成功总结 一、Mysql下载 官网下载
https://www.mysql.com/
百度云盘下载
链接：https://pan.baidu.com/s/1ef5ZbxiXA9U19V86JDRQeg
提取码：rpkc
官网下载教程
1.先打开https://www.mysql.com/，点击DOWNLOADS。
2.选择MySQL Community(GPL) Downloads。
3.选择MySQL Community Server社区服务进行下载，或者直接选择MySQL Installer for Windows里面也可以进行下载，建议选择第一种。
4.这里选择可以选择.MSI文件或者直接选择.ZIP文件下载，博主使用最新版本通过.MSI去安装。
MySQL二进制分发版（.msi安装文件）和免安装版（.zip压缩文件）。.MSI版本提供了图形化界面安装向导过程，而.ZIP版本下载后需要通过指令的方式去安装设置，会麻烦一点。
5.可以选择当前版本或者通过Archives选择其他版本之后最终下载。
6.下载完成后就能得到.msi文件，进行下面的安装操作。
二、Mysql安装 1.双击下载好的.msi文件，如果需要用户账户控制，选择是。
2.这里选择No，暂时不需要升级。
3.选择安装的类型，一般默认就好，然后点击Next。
4.安装是否满足条件，不满足的条件机会显示出来，选择Next之后选择yes安装一下就行了。
5.选择Execute安装一下不满足条件的内容,等待安装完成后选择Next。
6.选择Next。
7.默认配置，选择Next。
8.默认配置，选择Next。
9.设置数据库登录密码。
10.默认配置，选择Next。
11.默认配置，选择Execute。
12.完成后选择Finish。
13.默认配置，继续选择Next。
14.默认配置，继续选择Finish。
15.默认配置，继续选择Next。
16.连接服务器测试，成功后选择Next。
17.默认配置，选择Execute。
18.默认配置，选择Finish。
19.默认配置，选择Next。
20.默认配置，选择Finish，就会弹出这两个界面，可以先关闭不用管。
21.打开win+r，输入cmd，然后回车确定，输入services.msc，然后回车确定。
22.弹出服务后找到MySQL80看服务状态是否在启动，如果未启动就右键选择启动一下。
23.找到系统左下角选择开始，找到MySQL的客户端命令行工具并打开。
24.输入安装过程中自己设置的登录密码。
25.登录成功，就是启动MySQL服务成功。
26.右键我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量
27.新建环境变量，变量名输入MYSQL_HOME，变量值输入C:\Program Files\MySQL\MySQL Server 8.0，这里是Mysql的安装路径，我是默认的安装路径。
28.点击Path中，然后点击新建，添加环境变量%MYSQL_HOME%\bin，最后确定，确定，确定就好了。
三、验证Mysql安装是否成功 1.打开win+R，输入cmd，然后ctrl+shift+Enter，用管理员运行。
2.输入mysql -u root -p，然后回车，输入密码，最后看到Welcome…就是安装成功了。
总结 1.Mysql下载安装过程中都比较顺利，暂时没有遇到其他问题，后续如果有其他的问题欢迎前来探讨。
能够帮助你们解决问题是博主的荣幸，你们的支持是我创作的最大动力！:)欢迎关注点赞
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/134da2cd8b1997187f64753a6ac321ff/" rel="bookmark">
			音视频学习（十五）——ffmpeg&#43;sdl实现视频播放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		音视频播放的流程 音视频数据播放的流程主要分为以下步骤：
数据解封装数据解码数据采样和同步 处理流程如图所示：
ffmpeg视频播放流程 注册容器格式和解码器 — av_register_all()将打开的文件解封装 — av_open_input_file()从文件中获取音视频信息 — av_find_stream_info()获取视频流中编解码上下文 — AVCodecContext根据编解码上下文中的编码id查找对应的解码器 — avcodec_find_diecoder()打开编码器 — avcodec_open2()从码流中读取帧数据 — av_read_frame()视频帧解码 — avcodec_decode_video2()对解码数据进行像素格式和分辨率转换 — sws_scale()释放解码器 — avcodec_close()关闭输入文件 — av_close_input_file() SDL 简介 sdl是一个跨平台的媒体开发库，主要用于对音视频、键盘、鼠标、操纵杠等操作。SDL主要用于将ffmpeg解码后的音视频数据进行播放。
流程 SDL_init()：接口初始化；SDL CreateWindow()：创建播放窗口；SDL_ CreateRenderer() ：创建渲染器；SDL_ CreateTexture()：创建纹理；SDL_ UpdateTexture()：更新纹理参数；SDL_ RenderClear()：清除上一帧渲染;SDL_ RenderCopy()：复制渲染器； 主要处理流程如图所示：
补充说明：
SDL_Window：使用SDL的时候弹出的播放窗口。 SDL_Texture：用于YUV的纹理数据显示的区域。一个SDL_Texture对应一帧YUV数据。 SDL_Renderer：用于渲染SDL_Texture纹理至SDL_Window播放窗口。 SDL_Rect：用于确定SDL_Texture显示的位置区域。注意：一个SDL_Texture可以指定多个不同的SDL_Rect，这样就可以在SDL_Window不同位置显示相同的内容（使用SDL_RenderCopy()函数）。 示例 工程配置 1）添加依赖头文件
2）添加依赖库目录
3）添加依赖库
需要添加的依赖库如下所示：
libavcodec.lib libavdevice.lib libavfilter.lib libavformat.lib libavutil.lib libswscale.lib postproc.lib swresample.lib swscale.lib SDL2.lib SDL2main.lib 需要注意的是：由于是在windows下测试，使用的库均是x64-release。
sdl库的下载地址：https://github.com/libsdl-org/SDL/releases/tag/release-2.26.1
代码示例 #include &lt;iostream&gt; #include &lt;SDL.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/134da2cd8b1997187f64753a6ac321ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c04ea5e96370a3b5bac6e268f236963/" rel="bookmark">
			IDEA切换分支时，提示：Git Checkout Problem
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Git Checkout Problem 使用 Git 进行版本管理时,当我们切换分支时会出现如上的提示，出现上述界面的原因是我们在当前分支的代码没有 commit,当我们需要切换到其它分支的时候,Git 就会提示我们要进行哪些操作
下面有三个选项 Smart checkout、Force checkout、don`t checkout
这三个选项的作用是什么
Smart checkout：当前分支未提交的代码会被带到你要切换的那个分支上去Force Checkout：当前分支未提交的代码不会带到你要切换的那个分支上去,还是保留在当前分支don`t checkout：不进行分支切换,还是留在当前分支 使用 Force Checkout，一定要记得commit当前分支的代码; 否则的话，切换过去后，再切换回来时，这时候的分支上，之前的代码是不会保存的 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbd3ea30cce88e501d844b6cd3a43d92/" rel="bookmark">
			[Java] HashMap是如何实现的？扩容机制是什么？树化机制知道吗？结合源码带你理解HashMap的原理。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言HashMap是什么？Map接口散列表（HashTable） HashMap的扩容机制扩容机制？扩谁的容？HashMap的容量（Capacity）属性HashMap的扩容因子（load factor）属性 HashMap的树化机制触发树化机制的条件反树化机制 HashMap是如何实现扩容的？为什么HashMap的容量一定是2的N次方？ 结语 前言 HashMap可以说是一个经常被谈论到的集合类了，笔者也一度考虑是否要写这篇文章。毕竟做源码分析、谈论过HashMap实现的人也很多了。不过为了在未来的文章中更好的讲解ConcurrentHashMap，笔者还是决定为其写一篇基础性的前置知识文章。
HashMap是什么？ 万变不离其宗，要理解HashMap的原理和实现，我们必须要知道HashMap是个什么东西。
HashMap是jdk java.util包下的一个集合类。主要是利用散列表（HashTable） 这个 数据结构 来实现 Map接口。
和ArrayList与LinkedList一样，都是用某种特定的技术去实现某个接口，比如这里的List接口前者用数组实现，后者用链表实现。同样实现了Map接口的兄弟类也是存在的，那就是利用 平衡二叉搜索树（BBST） 来实现的 Map接口的 java.util.TreeMap。
所以不难看出，HashMap有两个关键词：散列表 和 Map接，那么我们分别来讲解一下这两个概念。
Map接口 Map接口大家应该都不陌生，大部分编程语言里都提供Map或Dictionary功能，其核心功能是提供键值对（Key-Value Pair）的增删改查。下面截图截取了部分Map接口的方法，其中核心方法有：
get(Object) : 数据查询put(K, V)：数据增改remove(Object)：数据删除 散列表（HashTable） HashMap的Hash和ArrayList的Array一样，是取自其依赖的底层技术：散列表（HashTable）。散列表的基本思想是把不同Key的哈希值通过取模给放到不同的哈希槽（Hash Slot）里存放。这样下次查询的时候可以再通过哈希值取模快速找到存放数据的哈希槽。这样能大大加快查找和插入数据的效率。
试想一下，假设你有100万条数据，1万个哈希槽，运气很好每个哈希槽平均分到100个数据。这样如果你通过哈希值取模只需要O（1）的时间复杂度就能找到对应的哈希槽，而最坏的遍历整个哈希槽也不过花费O（n）的时间，这里n是100。当然JDK对哈希槽的存储查询还做了优化，肯定不是O（n）的复杂度，提一个关键词：树化，这个我们后面的章节再讨论。
这里笔者也只是简单的介绍了以下散列表是什么。如果想详细了解散料表的，可以看笔者之前写的这篇文章：《数据结构之 - 散列表（Hash table）》
HashMap的扩容机制 HashMap作为一个容器类，绕不开的就是如何进行扩容。那么如何进行扩容这个事儿呢，也就是我们一直提到的扩容机制，亦或是可以理解为扩容策略。
扩容机制？扩谁的容？ 对于HashMap这个容器类来说，我们前面也提到了，其内部依赖的数据结构是散列表（HashTable）。散列表本本质是一个数组（一堆哈希槽）。所以其实扩容的中心思想也很简单，对于HashMap来说，扩容的本质就是增加散列表的大小（增加哈希槽数量）。
HashMap的容量（Capacity）属性 既然涉及到扩容（扩展容量），就不得不提HashMap的容量（Capacity）这个属性了。
在HashMap中，容量这个属性是由table这个Node数组来保持的。如下图所示，如果想获取容量信息那么直接通过table.length 获取即可，但也因为table这个数组是懒汉初始化的，有可能为null，需要做null判定。
前面我们提到table是懒汉初始化的，意味着在HashMap构造方法里是不会直接去申请table所需内存的。
那么如果我们通过HashMap的构造方法指定了 初始容量（initialCapacity） 会发生什么呢？
可以看到我们的构造方法利用 tableSizeFor(int) 这个方法去计算了一个容量值存放到了threshold属性里。
而这个属性呢，一般是代表触发下一次扩容的阈值（the next size value at which to resize），这个值一般是容器 x 扩容因子（capacity * load factor）。但因为懒汉初始化，在第一次申请table数组内存之前，被临时征用用于存储初始化容量信息，也就是第一次申请table数组的大小。
而tableSizeFor(int)方法，作为计算容量的方法，一定会返回一个2的N次方的容量值（Returns a power of two size for the given target capacity）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbd3ea30cce88e501d844b6cd3a43d92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e2ffb0e4a84834b22193bf149fb3f79/" rel="bookmark">
			Shell脚本基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是shell Shell概述： shell是一个命令的解释器
![image.png](https://img-blog.csdnimg.cn/img_convert/b5ca5ab48c3b7f381310120d6ba1ec26.png#averageHue=#eec096&amp;clientId=u307a07a9-7d1b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=502&amp;id=uf4fc102b&amp;margin=[object Object]&amp;name=image.png&amp;originHeight=628&amp;originWidth=1026&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=445122&amp;status=done&amp;style=none&amp;taskId=ue01813f8-9e08-49d4-bd39-cc5a49aaf52&amp;title=&amp;width=820.8)
shell是一门功能强大的脚本语言，易编写，易调试，灵活性强。需要注意的是shell是一门解释执行的脚本语言，并且可以使用shell调用Linux命令。
Shell的分类,主要分为两个家族，这两个家族的语法互不兼容：
Bourne Shell：从1979年开始Unix使用Bourne Shell，Bourne Shell的主文件名为sh。主要包括sh，zsh，psh，ksh，Bash
C Shell：主要运用在BSD版本的Unix中，其语法与C语言类似所以叫做C
shell主要包括csh和tcsh
查看当前的系统支持的Shell类型：
//查看当前系统中支持的shell vi /etc/shell //切换当前系统中的shell 直接输入shell的名字就可以切换，使用exit可以退出 shell编写Hello World //①创建一个.sh文件，这里需要后缀名，目的是在使用vim编辑器的时候告诉它我们编写的是一个shell脚本，可以给一些提示 vi hello.sh //正式开始编写一个shell #②在shell的开头如下的声明，声明这是一个shell脚本 #!/bin/bash //③正式开始编写自己的shell脚本 #在shell中可以直接调用Linux命令 echo "Hello World" //④执行一个shell脚本有两种方式，方式一是给文件一定的权限并且使用绝对路劲或者相对路劲去执行，第二种方式是使用bash 方式一： #给定权限 chmod 755 hello.sh 接着就可以执行了 方式二： bash hello.sh Bash的基本功能 历史命令以及命令补全 历史命令：
history：用于查看历史执行的命令
参数w用于将缓存中的命令写道~/bash_history中去
参数c用于删除缓存中的历史命令以及~/bash_history中的历史命令
history中保存的命令条数可以在/etc/profile中的history参数中进行配置
一些好用的功能：
关于历史命令的：
！！：用于执行上一条命令 ！n：用于执行指定编号的命令 ！字符串：用于执行以相关字符开头的历史命令 上下键用于选中历史命令 关于命令补全：
使用tab可以进行命令和路径的补全 别名和快捷键 LInux执行命令的优先级：
![image.png](https://img-blog.csdnimg.cn/img_convert/d52ef32d949b5c88032f4e6ce11751c0.png#averageHue=#eaeae9&amp;clientId=u427e0ab6-bd05-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=351&amp;id=u9f159e91&amp;margin=[object Object]&amp;name=image.png&amp;originHeight=439&amp;originWidth=1021&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=217089&amp;status=done&amp;style=none&amp;taskId=u7ddba4d9-37d9-4893-a6cc-d3526823e75&amp;title=&amp;width=816.8)
可以使用如下命令来定义一个命令的别名，但是只要退出登录了就会失效 alias 别名 = '元命令' 去除别名： unalias 别名 别名永久保存： /用户/bashrc Linux中常用的快捷键：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e2ffb0e4a84834b22193bf149fb3f79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27da470ead26de48932a0c8e4a8fe2f5/" rel="bookmark">
			两种方式实现Kepware与PLC之间的心跳检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在物联网开发中，上下位交互，如RFID信息交互时，下位有一个心跳检测的机制，超过指定时间心跳未触发，则认为通信不畅，从而触发下位报警逻辑
实现的方式有很多，这里介绍两种方式做参考，可能不是最优。
1 OPC UA + IOT方式 这是通过上位程序来触发心跳的一种机制，在Java中，可以利用OPC UA+Milo的方式，实现对kepware的读写订阅等，同时kepware结合IOT，如：REST，MQTT等可以实现监听，并在Java程序中监听MQTT消息或接收REST请求，进而执行相应的逻辑。
此方式缺点比较明显，需要上位程序通过MQTT监听或REST接收并不断的写kepware，依赖于iot gateway组件外加上位编程。
当然，这里只是Java的实现方式。
2 Kepware Advanced Tag 这是直接利用Kepware中的高级标签（Advanced Tag），利用 link tag来实现心跳检测，这种方式完全由kepware来支持。
此种方式只需要在kepware上即可完成相关操作，不过插件需要授权（或者想其他办法搞定）。
以上两种方式，都需要相应的插件授权
3 相关插件 ADVACED TAG插件，包含LINK TAG功能
以上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee08ce988117da2db1c552865ceb7cca/" rel="bookmark">
			Akka 学习（七）Actor的生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章
Gitter Chat，Akka 在线交流平台Akka Forums，Akka 论坛Akka in GitHub，Akka 开源项目仓库Akka Official Website，Akka 官网Akka Java API，Akka 应用程序编程接口《Akka入门与实践》 [加]Jason Goodwin（贾森·古德温） 文章系列
Akka 学习（一）Actor 初步认识与环境搭建 已完成 Akka 学习（二）第一个入门程序 已完成 Akka 学习（三）Actor的基本使用 已完成 Akka 学习（四）Remote Actor 已完成 Akka 学习（五）消息传递的方式 已完成 Akka 学习（六）Actor的监督机制 已完成 Akka 学习（七）Actor的生命周期 已完成 Akka 学习（八）路由与Dispatcher 已完成 Akka 学习（九）Akka Cluster 已完成 Akka 基础篇就此结束了，Akka基础篇主要介绍Akka的基本概念与一些基本术语，使用方式
代码：https://github.com/Eason-shu/Akka
在Actor的生命周期中会调用几个方法，我们在需要时可以重写这些方法。
● prestart()：在构造函数之后调用。
● postStop()：在重启之前调用。
● preRestart(reason, message)：默认情况下会调用postStop()。
● postRestart()：默认情况下会调用preStart()。
一 生命周期 1.1 基本介绍 package com.shu; import akka.actor.AbstractActor; import scala.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee08ce988117da2db1c552865ceb7cca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab5b81277c7ce8c55c2cf12efdb77c65/" rel="bookmark">
			VUE父子组件动态显示或隐藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 VUE父子组件动态显示或隐藏 父组件子组件 父组件 代码：
&lt;ArchivesInfo :form="form" :req-data="reqData" :disabled="disabled" :showEl="false"/&gt; 子组件 代码：
&lt;el-form-item label="品牌/车系/车型：" :span="6" id="ShowOrHide" v-mode="showEl" v-if="showEl==true"&gt; &lt;el-cascader ref="cascader" :options="form.options" :props="{ checkStrictly: true ,multiple: true}" filterable @change="handleChange" clearable :disabled=disabled&gt;&lt;/el-cascader&gt; &lt;/el-form-item&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06312a5ba48d62314827ffd7fc775879/" rel="bookmark">
			java中静态代码块详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考博客：https://blog.csdn.net/qq_36792191/article/details/103988565
1.静态代码块基本知识
**（1）静态代码块：**执行优先级高于非静态的初始化块，它会在类初始化的时候执行一次，执行完成便销毁，它仅能初始化类变量，即static修饰的数据成员。
静态代码块写法：
static{
…
}
（2）非静态代码块：执行的时候如果有静态初始化块，先执行静态初始化块再执行非静态初始化块，在每个对象生成时都会被执行一次，它可以初始化类的实例变量。非静态初始化块会在构造函数执行时，在构造函数主体代码执行之前被运行。
写法： {
…
}
（3）扩展：静态代码块的执行顺序：静态代码块-----&gt;非静态代码块--------&gt;构造函数
总结：1.静态代码块，随着类的加载而执行，且只执行一次。
2.非静态代码块，实例化类的时候执行，且实例化一次执行一次。顺序，后于静态代码块，先于构造函数。
3.执行main类的父类静态代码块——执行main类静态代码块——其他方法*——(存在实例化)
父类的非静态代码块+父类的构造方法——(该实例化类的)非静态代码块+构造方法——其他方法*
2.加载执行 static和@PostConstruct的区别
当class被加载之后，会执行static中的代码。
当你的component组件的依赖初始化之后，执行@PostConstruct内的代码。
3、
单例类(Spring中的@Service就是单例模式)：使用private final
其他：使用private static final
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee6b11d47c75425992a2a7794135898b/" rel="bookmark">
			Linux——详解共享内存shared memory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.共享内存介绍
（一）.什么是共享内存
（二）.共享内存优点
（三）.共享内存缺点
二.共享内存使用
（一）.创建—shmget
①key
②size
③shmflg
④返回值
（二）.连接—shmat
（三）.分离—shmdt
（四）.销毁—shmctl
（五）.查看—ipcs
（六）.删除—ipcrm
（七）.读取与写入 三.共享内存与访问控制
（一）.添加访问控制
（二）.可能的陷阱
一.共享内存介绍 （一）.什么是共享内存 共享内存本质上就是内存中的一块区域，用于进程间通信使用。该内存空间由操作系统分配与管理。与文件系统类似的是，操作系统在管理共享内存时，不仅仅有内存数据块，同时还会创建相应结构体来记录该共享内存属性，以便于管理。
因此，共享内存不只有一份，可以根据需求申请多个。
进程之间进行通信的时候，会获取 到共享内存的地址，写端进程写入数据，读端进程通过直接访问内存完成数据读取。
（二）.共享内存优点 相比于管道而言，共享内存不仅能够用于非父子进程之间的通信，而且访问数据的速度也比管道要快。这得益于通信直接访问内存，而管道则需要先通过操作系统访问文件再获得内存数据。
（三）.共享内存缺点 用于进程间通信时，共享内存本身不支持阻塞等待操作。这是因为当读端读取数据后，数据并不会在内存中清空。因此读端和写端可以同时访问内存空间，即全双工。因为共享内存本质是进程直接访问内存，无法主动停止读取，如果读端不加以限制，那么将持续读取数据。同理，写端也会持续写入数据。换句话说，共享内存本身没有访问控制。 二.共享内存使用 （一）.创建—shmget 想要使用共享内存首先要建立共享内存。
①key shmget会根据key值创建一个共享内存，因此当创建多个共享内存时，每一个key值要独一无二。
获得key值可以使用库函数ftok专门获取一个独一无二的key_t类型值。
参数pathname为路径，必须是真实存在且可以访问的路径。
参数proj_id是int类型数字，且必须传入非零值。
成功返回key_t值，失败返回-1。
ftok函数内部会根据路径和proj_id通过算法生成一个独一无二的key_t返回值。
多进程通信时，需要通信双方使用同一个key值，因此双方使用的ftok参数应该一致。 ②size 该参数用于确定共享内存大小。
一般而言是4096的整数倍，因为内存的块的大小就是4KB即4096B。因此即便我们需要的空间大小不是块大小的整数倍，操作系统实际上也还是分配块的倍数个。但在使用时，那些超过size大小的多余分配空间不能访问。 ③shmflg 该参数用于确定共享内存属性。
使用上为：标志位 | 内存权限
标志位参数有两种：IPC_CREAT、IPC_EXCL
常用使用方式有两种：
方式含义shmget(..., IPC_CREAT | 权限)创建失败不报错返回已有shmidshmget(..., IPC_CREAT | IPC_EXCL | 权限)创建失败报错返回-1 值得注意PC_EXCL无法单独使用。
通常情况下在多进程通信时，创建方使用IPC_CREAT | IPC_EXCL，接收方使用0即可。
④返回值 返回值为int类型，称为shmid。每一个共享内存都会有一个shmid，用于连接与分离时传递参数。 （二）.连接—shmat 创建共享内存后还不能直接使用，需要找到内存地址后才能使用，即连接。 shmid即shmget返回值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee6b11d47c75425992a2a7794135898b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b21e643a8df035a48921394de180b87a/" rel="bookmark">
			Flutter和iOS互相调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flutter调用ios并有返回值：
BXTestChannel.shared.initEventChannel(context); String a = await BXTestChannel.shared.getIosString(); dlog(a); flutter中的channel类：
import 'dart:io'; import 'package:flutter/cupertino.dart'; import 'dart:async'; import 'package:flutter/material.dart'; import 'package:flutter/services.dart'; import 'package:wiki_flu/providers.dart'; import 'package:wiki_flu/wiki_flu.dart'; const String channelName_wikifxsaveLaunage = 'com.wikifx.BXTestChannel'; const String method_BXTestChannel = 'method_BXTestChannel'; class BXTestChannel { static final BXTestChannel shared = BXTestChannel._(); BXTestChannel._(); factory BXTestChannel() =&gt; shared; static final _channel = const MethodChannel(channelName_wikifxsaveLaunage); ///flutter调ios Future&lt;String&gt; getIosString() async { var a = await _channel.invokeMethod(method_BXTestChannel, { "test": "bx", }); return a; } ///ios调flutter 注册监听 安卓调用 initEventChannel(BuildContext context) { _channel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b21e643a8df035a48921394de180b87a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e019a4506cfff53aac858bbde425a36a/" rel="bookmark">
			frp内网穿透SSH
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考博客:
博客1(推荐): https://sspai.com/post/52523
博客2: https://blog.csdn.net/qq_36981760/article/details/115713179
博客3: https://blog.csdn.net/qq_36981760/article/details/115713179
参考视频
(推荐，比较详细): https://www.bilibili.com/video/BV1p94y1y7ft/
背景 由于寒假放假回家， 回家之后就不能连接学校的服务器了(可以不用，但是不能没有)，所以最近了解frp内网穿透技术通过连接公网ip就可以连接学校的服务器。但是查阅博客中有一些细节我感觉没有讲清楚(可能是我比较菜， 配了挺久)， 所以特此缝合一篇博客供大家使用。
frp介绍 frp可以通过利用公网IP的的主机(frp服务端)将内网的主机(frp客户端)暴露给互联网，从而实现通过外网能直接访问到内网主机；frp有服务端和客户端，服务端需要装在有公网ip的主机上，客户端装在内网主机上(重点!!!)。
frp案例: 情况1. 电脑在学校: 连接学校网的主机 --------&gt; 学校服务器 (属于同一个局域网中可以直接连)
情况2. 电脑在家(和服务器不在一个局域网中): 家里面的主机 --------&gt; 公网ip --------&gt; 学校服务器 (需要使用frp)
如果你是情况1， 那么恭喜你不需要使用内网穿透，
如果你是情况2， 我们的目的是通过内网穿透(frp)技术，本地主机通过访问公网主机ip(106.55.xxx.xxx)即可访问服务器主机。 举例我在家连接学校服务器
准备工作 (frp服务端) 一台公网主机，一般是云服务器(阿里云、腾讯云等都行) 注意: 不能是192.168.xxx.xxx 这种ip地址开头的本地虚拟机主机，这样满足公网条件 (假设本案例使用的公网ip为 106.55.123.123)(frp客户端)一台私网主机，一般是局域网里面服务器 注意: 可以是192.168这种ip地址开头的虚拟机主机 (假设服务器ip为 222.200.123.123)一台想要使用服务器的主机(ip理论上任意，可以访问公网即可) 环境说明: frp服务端, frp客户端都是Linux系统
1. frp服务端设置 说明: 内网穿透需要先配置frp服务端然后再配置frp客户端
1.1 frp的下载 官网下载地址: https://github.com/fatedier/frp/releases
选择适合的版本下载(以v0.33.0版本为例)
查看Linux主机版本为
arch 查看结果，如果是“X86_64“即可选择”frp_0.33.0_linux_amd64.tar.gz”
创建vpns目录用于存放frp服务端的安装包:(目录名称可以自定以)
mkdir vpns 切换到vpns目录下载frp服务端
cd vpns 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e019a4506cfff53aac858bbde425a36a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1824f9bc270844a901c366f17e382203/" rel="bookmark">
			「Redis数据结构」哈希对象（Hash）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		「Redis数据结构」哈希对象（Hash） 文章目录 「Redis数据结构」哈希对象（Hash）一、概述二、编码ZipListHashTable 三、编码转换 一、概述 Redis中hash对象是一个string类型的field和value的映射表，hash特别适合用于存储对象。作为哈希对象的编码，有二种一是ziplist编码, 二是hashtable编码。在不同情况下编码是可以转换的。在Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。
Hash结构与Redis中的Zset非常类似：
都是键值存储都需求根据键获取值键必须唯一 区别
zset的键是member，值是score；hash的键和值都是任意值zset要根据score排序；hash则无需排序 因此，Hash底层采用的编码与Zset也基本一致，只需要把排序有关的SkipList去掉。
二、编码 哈希对象的编码可以是 ziplist 或者 hashtable 。
ZipList ziplist 编码的哈希对象使用压缩列表作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾， 因此：
保存了同一键值对的两个节点总是紧挨在一起， 保存键的节点在前， 保存值的节点在后；先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。 如果我们执行以下 HSET 命令， 那么服务器将创建一个列表对象作为 profile 键的值：
redis&gt; HSET profile name "Tom" (integer) 1 redis&gt; HSET profile age 25 (integer) 1 redis&gt; HSET profile career "Programmer" (integer) 1 如果 profile 键的值对象使用的是 ziplist 编码， 那么这个值对象将会是如图所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1824f9bc270844a901c366f17e382203/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98b2ee7e7455df05652c0d6e6fd67452/" rel="bookmark">
			什么是async，什么是await，async和await的区别，async和await的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES6 作为多年来 JavaScript 的重大版本变革，受到 JavaScript 开发者们的普遍欢迎，也正是从 ES6 (ES2015) 开始，JavaScript 版本发布变为年更，即每年发布一个新版本，以年号标识版本
随着async/await正式纳入ES7标准，据说是异步编程终级解决方案的 async/await。
async 是“异步”的意思，而 await 是等待的意思，await 用于等待一个异步任务执行完成的结果。
async/await 是一种编写异步代码的新方法（以前是采用回调和 promise）。
async/await 是建立在 promise 的基础上。
async/await 像 promise 一样，也是非阻塞的。
async/await 让异步代码看起来、表现起来更像同步代码。
一、Async
1、async
async修饰的函数就是异步函数，该函数的返回值是promise对象。
async function f1(){
return "hello f1";
}
var t = f1();
console.log(t);// promise对象。
f1().then(function(str){
console.log("str:"+str); //str:hello f1
});
2、async和promise的对比
async function f1(){
return "hello f1";
}
function f2(){
return new Promise((resolve, reject) =&gt; {
resolve('hello f2');
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98b2ee7e7455df05652c0d6e6fd67452/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd3713ab98b1a13f23a85bea482dc5d6/" rel="bookmark">
			通过修改history.pushState来完成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		history模式会给后端发请求（如果刷新当前页面的话），一旦，后端和前端提供了同样的路径，那么，浏览器的请求结果就会有问题，到底是后端的资源还是前端的资源（不同的后端处理思路不停），还好，我们一般在后端apiserver的请求路径的前面习惯性的有个 /api。
所以，由于不同服务端的处理思路不同。所以，需要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面（单页面），这个页面就是你 app 依赖的页面。否则，就会返回404。
你可以改成history的模式，测试一下，如果刷新当前页面，那么，浏览器会朝后端发送请求（给当前路径）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbd8af443891c0b0a0788f3dab0de343/" rel="bookmark">
			更新文件缓存的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每次打包好文件给后端更新的时候，用户手机上总会留下，上次版本的信息，而且每次都得清下缓存，才会显示最新版本的数据。解决办法：让后端返回一个更新版本的接口，前端每次更新版本的时候，都会给后端传入时间戳，然后后端接收后判断和库里的时间戳是否相同，相同的返回不需要更新，不相同的话，返回要更新，然后前端这边的处理方法是：需要更新的话，清除掉缓存，刷新页面即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b09360293f60e9ef1f3481f8d45035cc/" rel="bookmark">
			HTTP请求响应系列02_响应报文的详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		响应报文
1、响应报文的详解
上篇文字讲的“请求报文”，本篇主要解释响应报文包括的内容。
响应报文的内容也包括三部分，分别是： 响应行， 响应头， 响应体。这三部分放的都是信息。是S端发给B端的信息，道理是一样的。
响应：就是请求后的结果。
栗子（接上篇文字的栗子）：
“我今天去火车站接女朋友”，这句话核心表达的意思（经过缩句）：我接女朋友。
响应行：会总体说响应的结果。如：接到了还是没有接到
响应头：对结果的描述。如：几点接到了（有可能晚到噢），这次女朋友和上次有没有变化（如：头发是不是烫了，化了新的妆…………………………），
响应体：那就是女朋友本人了，说不定还有惊喜（给了你一个么么哒）
1）、响应行
响应行包括：HTTP协议的版本，响应的状态码和描述。
如： HTTP/1.1 200 OK 表示响应时使用的是http协议的1.1版本；响应的状态码是200；表示OK。
响应状态码
和请求报文相比，响应报文多了一个“响应状态码”，它以“清晰明确”的语言告诉客户端本次请求的处理结果。
HTTP的响应状态码包括：
1xx ：告诉浏览器端，服务器已经收到请求了，正在处理，请稍等……。1xx的响应一般不用理会
2xx：告诉浏览器端处理成功，常见的有200。
3xx：告诉浏览器端要重定向到其它地方。它让客户端再发起一个请求以完成整个处理。常见的有：303，304。但是304却不是重定向。后面的详情里描述
4xx：告诉浏览器端，你错了，你找到东西不存在。如：客户端的请求一个不存在的资源（地址不对，请求方式不对，Content-type不匹配等等），客户端未被授权，禁止访问等。常见的有：404，400
5xx：告诉浏览器端，我服务器端错了，如：服务端抛出异常，路由出错，HTTP版本不支持等。常见的有500
附：HTTP状态码的描述：
建议大家只看我上面提到的常用的状态码（200，304，400，404，500）就行，不常用的先不用看，因为，很多状态码可能一辈子都用不到。你可以在你“临走”时，回忆一下，这辈子是不是还有很多的状态码还没有用过。
1）、2xx 处理成功
200
200对应的信息是OK，表示请求响应已成功，并且响应的结果没有问题。看到200，你应该开心。恭喜你，没有问题。
201 Created
201表示请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。
202 Accepted
202表示服务器接受了请求，但是还没有处理。但是该请求会不会被执行就不一定了。在异步操作的场合下，没有比发送这个状态码更方便的做法了。
203 Non-Authoritative Information
203表示服务器接收并成功处理了请求，但返回的实体头部信息来自本地或者第三方的拷贝。
204 No Content
204表示服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息（ 元信息是用来描述服务器发送数据的信息，如：发的是什么信息，是否接收完整，过程中是否出错 ）。由于204响应里不能包含任何消息体，因此它始终以消息头后的第一个空行结尾。
205 Reset Content
205表示服务器成功处理了请求，但没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图（如：表单）。以便用户能够轻松地开始另一次输入。
2）、3xx 重定向到其它地方
这类状态码是用来重定向的，重定向目标在本次响应的 Location 属性中。
300 Multiple Choices
300表示被请求的资源有多个可供选择的回馈信息，每个可供选择的回馈信息都有自己的地址和浏览器驱动的商议信息。
301 Moved Permanently
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b09360293f60e9ef1f3481f8d45035cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0058d8e617e4ac97537f686aae847310/" rel="bookmark">
			何时需要使用beforeDestroy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总体来说，需要清除的是：当前组件不会自动销毁的数据（不属于当前组件的数据），并且该数据只是在当前组件里使用。
1）、清除定时器（定时器是window对象的，不主动清除，是不会清除的）
2）、$on方法，那需要在组件销毁前解绑。（$on虽然属于Vue的实例方法，但是，这个实例很有可能不是当前vue组件（如：事件总线中的用法））
3）、解除事件的绑定 scroll mousemove （这些事件是绑定在window对象或者document对象上的）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55cb54805b75041893cb41d84948fe1f/" rel="bookmark">
			python统计，计数的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		统计 统计用什么数据格式 统计的方法： 1. 字典法 2. 哈希表法 3. collections.counter()方法 总结 1. 我们先来说说统计用什么格式： 我们知道python有列表，字典，元组等等等数据格式，究竟哪种格式比较适合用作统计呢？
现在给出一句诗句： 鹅鹅鹅，曲项向天歌，白毛浮绿水，红掌拨清波。
# 先看看列表如果用列表，统计大概就是这个样子： [['鹅', 3],['曲', 1]...] 能看但是不好看。
# 再看看元组，元组的话大概是这样： （'鹅', 3, '曲', 1...） 这样就不是我们正常人想看的了，会显得很乱，而且元组只能看不能改。
# 我们再看看字典格式： {'鹅': 3, '曲', 1...} 这个格式是可以的，字典是能够明了的看到key 和 value 的对应，所以我们在给一篇文章做统计的时候，我们总是考虑使用字典.
2.统计的方法： 在我们知道用字典的时候，我们该怎样操作呢？
这时候，就有很多方法了，我刚学的时候就是纯字典手写，后来知道哈希表之后，觉得哈希表也可以，之后看到collections有个counter方法（数数的方法）然后感觉这三种方法都可以。
（1） 字典 # Author:xueling # 先打开一篇我们要统计的文章，并读取内容 f = open(r'文件地址+文件名', 'r', encoding='utf-8') article = f.read() # 建立一个空字典来存储统计结果 d = {} # 遍历整篇文章 for i in article: d[i] = d.get(i,0) + 1 # 字频统计 # 在此基础上我们还可以做一个排序： ls = sorted(list(d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55cb54805b75041893cb41d84948fe1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ff56eedbe45cfedc6db61c5c75bb279/" rel="bookmark">
			Anaconda or Miniconda windows下 cmd命令行模式创建、激活、关闭、删除虚拟环境方法步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Conda创建虚拟环境1、创建虚拟环境：1.1 命令：1.2 实例：1.2.1 创建一个名字是py383的虚拟环境变量1.2.2 输出结果： 2、在创建好的虚拟环境中安装第三方库：2.1 安装第三方库是使用pip install和conda install的区别2.1.1 安装路径不同2.1.2 在创建多个虚拟环境的情况下，安装python包的数量不同2.1.3 当需要使用国内镜像源(以清华大学镜像源为例)的时候，语法方式不同2.1.4 常用国内镜像源网址如下： 2.2 实例：2.2.1 安装pandas包(以pip install这种方式为例)2.2.2 输出结果： 二、Conda激活虚拟环境1.命令（以一、中的虚拟环境py383为例）：2.输出结果： 三、Conda关闭虚拟环境1.命令（以一、中的虚拟环境py383为例）：2.输出结果： 四、Conda删除虚拟环境1.命令（以一、中的虚拟环境py383为例）：2.输出结果： 五、获取当前conda和pip版本号1.conda1.1 命令1.2 输出结果： 2.pip2.1 命令2.2输出结果： 六、Conda查看所有的虚拟环境1.命令2.输出结果： 七、用conda和pip查看已安装的python包1.conda1.1 系统默认环境下和虚拟环境下查看命令是一样的1.2 输出结果： 2.pip2.1 系统默认环境下和虚拟环境下查看命令是一样的2.2 输出结果： 八、总结 前言 在实际Python项目开发中，不同的项目可能需要导入的第三方库不一样，所以我们对每个不同需求的项目都建立一个对应的虚拟环境很有必要。而且如果每个项目都有自己的环境，我们在用Pyinstaller把项目脚本打包成.exe可执行文件时可以大大缩小.exe文件的占用内存大小，同时也便于我们管理各个环境，使它们之间相互不受影响，不至于我们反复重装Anaconda和配置环境变量。
一、Conda创建虚拟环境 1、创建虚拟环境： 1.1 命令： #创建名为env_name的虚拟环境，不指定Python版本（默认安装最新版本的Python）
conda create -n env_name
#创建名为env_name的虚拟环境，并指定Python版本为3.6.5
conda create -n env_name python=3.6.5
1.2 实例： 1.2.1 创建一个名字是py383的虚拟环境变量 conda create -n py383 python=3.8.3
1.2.2 输出结果： win + R，输入cmd，并按Enter
在打开的命令行窗口中输入conda create -n py383 python=3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ff56eedbe45cfedc6db61c5c75bb279/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/768d1fb5d49a565237d26c0aaef661c9/" rel="bookmark">
			Android逆向工具 - jadx 安装使用 和 --show-bad-code查找未成功解析代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 jadx是个人比较喜欢的一款反编译利器，同时支持命令行和图形界面，能以最简便的方式完成apk的反编译操作。
下载地址：
https://github.com/skylot/jadx
若你已经安装JRE（若还没安装，可以从这里下载https://www.java.com/zh-CN/download/)，则只需下载 jadx-gui-1.2.0-no-jre-win.exe 即可。
使用 双击打开工具，点击file-openfile，选择你想要分析的文件，就可以直接使用。
工具支持apk、dex、jar、aar等格式的文件，可以通用File - Open file选择文件或者直接将文件拖进窗口中，可以算得上一键反编译了，非常简单易用，对比dex2jar &amp; jd-gui组合，这也太省事了吧。
-show-bad-code查找未成功解析代码 如果再使用过程中，发现有重要代码为成功解析，不要放弃，jadx还支持show bad code功能。
这里的ExcuteCmd未未成功解析。
可以尝试使用jadx命令
jadx --show-bad-code E:\work\*.apk -d D:\softwaretmp\out
如果有JAVA_HOME路径的报错，则需要根据自己的jre目录修改文件jadx-gui.bat。
修改完bat文件后，再次执行。虽然有报错，但是毕竟执行完成了。
查看生成的out目录下的文件，从任一编辑器打开相关*.jar，发现之前未成功解析的ExcuteCmd已经显示出来了。注意，如果用上一章节“使用”里的图形界面打开依然不会看到这次的显示。
jadx的show bad code功能使用取得了成功，获得了我们想要的代码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16bbe74ea876a98be9229a389df7c85f/" rel="bookmark">
			VS Code 中文配置不显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天在windows 11上安装Visual Studio Code 下载中文包后重启仍然显示英文。相信自此往后仍有和我一样的小白会出现该问题，因此希望能给大家节约一下时间。
安装中文扩展包（已安装请跳过） 步骤一 1、点击扩展（如图），或 Ctrl + Shift + X 进入扩展界面。
步骤二 2、在搜索栏输入 Chinese 。
步骤三 3、选择Chinese 简体中文，安装。
配置中文（解决不显示问题） 步骤一 1、Ctrl + Shift + P 打开命令命令面板 ，输入 configure display language （不区分大小）
步骤二 2、选择中文简体（zh-cn）
步骤三 3、重启即可。
官方链接 以下为Visual Studio Code 官方配置文档：
https://code.visualstudio.com/docs/getstarted/locales
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5958043c1efea8b3ba6843722849dccb/" rel="bookmark">
			二，mybatis简单连接数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，安装MyBatisX插件 安装插件MyBatisX。
在setting-plugins里面
二，创建UserMapper 在UserMapper里面输入我们的第一个数据库操作方法
List&lt;User&gt;selectAllUser(); 三，创建sql语句 之后在resources里面的mapper里面创建对应的实现方法
&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.chenchao.mybatis.mapper.UserMapper"&gt; &lt;select id="selectAllUser" resultType="user"&gt; select * from t_user &lt;/select&gt; &lt;insert id="insertOnePersonToUser"&gt; &lt;/insert&gt; &lt;/mapper 这里我们可以看到id="selectAllUser"和我们之前创建的ListselectAllUser();的方法名是一样的，这样我们才可以找到对应的方法。我们的这两个User Mapper由resources里面的User Mapper找到的，我们可以看到这个namespace的信息就是我们对应的Mapper
点击蓝鸟和红鸟可以快速移动
四，写启动类 名字是ParameterTest
内容是
import com.chenchao.mybatis.mapper.UserMapper; import com.chenchao.mybatis.pojo.User; import com.chenchao.mybatis.utils.SqlSessionUtil; import org.apache.ibatis.session.SqlSession; import org.junit.Test; import java.io.IOException; import java.util.HashMap; import java.util.List; import java.util.Map; public class ParameterTest { @Test public void testForSelectAllUser () throws IOException { SqlSession sqlSession= SqlSessionUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5958043c1efea8b3ba6843722849dccb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcf17add3ed51a283a6b339879befe92/" rel="bookmark">
			树莓派4b学习笔记三--基于Ubuntu搭建Docker 和portainer,基于Docker 搭建Homeassistant、EMQX
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、基于Ubuntu搭建Docker和portainer1.Docker简介2.Ubuntu20.04安装Docker-ce3.Ubuntu20.04安装Docker图形化界面portainer4.Docker的常用命令和portainer使用 二、基于Docker搭建homeassistant1.homeassistant简介2.homeassistant不同版本的安装3.hacs插件商店的安装 三、基于Docker搭建EMQX1.MQTT协议和EMQX简介2.Docker搭建EMQX 一、基于Ubuntu搭建Docker和portainer 1.Docker简介 相信接触过Linux系统和虚拟机的小伙伴都或多或少听说过Docker和Docker图形化工具portainer。
Docker 是一个开源的应用容器引擎，基于Go语言并遵循Apache2.0开源。Docker的容器是完全使用沙箱机制，相互之间不会有任何接口，所以不同容器运行互不影响。开发人员可以通过Docker将App变成一种标准的、可移植的、自管理的组件，我们可以在任何主流的操作系统中开发、调试和运行。
从概念上来看，Docker和传统的虚拟机比较类似，只是更轻量级，更方便使用。Docker和虚拟机最主要的区别有以下几点：
1.虚拟化技术依赖的是物理CPU和内存，是硬件级别的；Docker是构建在操作系统层面的，复用操作系统的容器化技术，所以Docker同样可以运行在虚拟机上面。
2.虚拟机中的操作系统是一个完整的操作系统镜像，比较复杂；而Docker比较轻量级，我们可以用Docker部署一个独立的redis，就类似于在虚拟机当中安装一个redis应用，但Docker部署的应用是完全隔离的。
3.传统的虚拟机技术是通过快照来保存状态的；而Docker引入了类似于源码管理的机制，将容器历史版本一一记录下来，切换成本非常之低。
4.传统的虚拟化技术在构建系统的时候非常复杂；而Docker可以通过一个简单的Dockerfile文件来构建整个容器，更重要的是Dockerfile可以手动编写，这样应用程序开发都可以通过发布Dockerfile来定义应用的环境和依赖，对于持续交付非常有利。
2.Ubuntu20.04安装Docker-ce 首先先卸载旧版本的Docker,旧版本的 Docker 被称为 docker、docker.io 或 docker-engine，新版本的是Docker-ce.
sudo apt-get remove docker docker-engine docker.io containerd runc 通过apt方式来卸载Ubuntu原有的旧版Docker
Docker相关依赖安装包
在链接里面下载 docker-ce 、docker-ce-cli、 containerd.io 三个不同的最新的安装包，我这里是ARM架构aarch64位的系统。
sudo curl -O https://mirrors.aliyun.com/docker-ce/linux/ubuntu/dists/bionic/pool/stable/arm64/containerd.io\_1.2.6-3\_arm64.deb sudo curl -O https://mirrors.aliyun.com/docker-ce/linux/ubuntu/dists/bionic/pool/stable/arm64/docker-ce-cli\_19.03.9~3-0~ubuntu-bionic\_arm64.deb sudo curl -O https://mirrors.aliyun.com/docker-ce/linux/ubuntu/dists/bionic/pool/stable/arm64/docker-ce\_19.03.9~3-0~ubuntu-bionic\_arm64.deb 或者直接通过curl命令下载
sudo dpkg -i ./docker-ce-cli_20.10.2_3-0_ubuntu-bionic_arm64.deb sudo dpkg -i ./containerd.io_1.4.3-1_arm64.deb sudo dpkg -i ./docker-ce_20.10.2_3-0_ubuntu-bionic_arm64.deb cd到三个安装包的目录下，deb文件我们用dpkg命令解压并安装，zip文件我们用unzip命令解压，gz文件我们用tar命令解压并安装。注意三条指令是有顺序的，因为另外两个会安装第三个docker-ce安装的依赖项，如果下载顺序出错就会报错。
然后在etc目录下创建一个docker的文件夹用于配置镜像源地址，etc目录下是用来存放Linux系统主要的配置文件，例如用户的账号密码文件、各种服务的起始文件等.
sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcf17add3ed51a283a6b339879befe92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3630d06f45556a6ca8e034f5db1946b1/" rel="bookmark">
			进程间通信详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.进程间通信介绍
1.进程间通信的目的
2.进程间通信的本质 3.进程间通信分类
二.什么是管道
三.匿名管道 1. 匿名管道只能用于具有亲缘关系的进程之间进行通信，常用于父子。
2.pipe函数
3. 匿名管道的使用
4.管道的读写规则
5.管道的特点，
6.管道的4中特殊情况 7.验证管道的大小
四.命名管道
1. 基本概念
2.创建命名管道
3.命名管道的打开规则
4.命名管道的四个使用示例 5. 命名管道和匿名管道的区别
6.命令行中的管道理解
五.system V进程间通信
六.system V共享内存
1.共享内存示意图
2.共享内存数据结构
3.共享内存的主体使用逻辑
4.共享内存的创建
5.共享内存的释放
6.共享内存进行关联
7.共享内存去关联
8.client 和 serve进行共享内存通信
七.共享内存和管道的比较
1.通信速度比较
2.管道的数据拷贝过程
3.共享内存的数据拷贝过程
4.为什么共享内存是速度最快的IPC方法？
5.为什么共享内存的拷贝次数少？
八.System V消息队列 九.System V信号量
1.理解信号量的相关概念
2.同步和互斥
一.进程间通信介绍 1.进程间通信的目的 数据传输：一个进程需要将它的数据发送给另一个进程(cat log.txt | grep hello)资源共享：多个进程之间共享同样的资源。 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。 进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变 2.进程间通信的本质 进程间通信的本质是让 不同的进程看到同一份资源(内存 ， 文件，内核缓冲等)
资源由谁（OS的哪些模块）提供 ， 就有了不同的进程间通信方式！ 这里的模块可以是: (文件–管道) , (OS内核IPC提供- SystemV IPC) , (网络–套接字)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3630d06f45556a6ca8e034f5db1946b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1ff8c61f090ed1f844d085dd7d477d5/" rel="bookmark">
			解决pip安装torch库出现问题(本人自己安装心路历程，希望对你有用)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人刚开始使用的python 3.11.0 博主按照以前下载库的方法一样，输入
pip install torch
然后系统报错为:
ERROR:Could not find a version that satisfies the requirement torch
解决方法一:更新pip 当我输入更新指令:
python -m pip install --upgrade pip
再次输入pip install torch
解决方法二: cmd命令栏中输入:
pip install torch -i https://pypi.douban.com/simple --trust -host=pypi.douban.com
解决方法三: 卸载当前python版本，重新下载python 3.10.9
官网地址:https://www.python.org/
下载安装后，打开控制面板输入
python -V
显示 Python 3.10.9 则安装成功。
再次输入 python -m ensurepip --default-pip
安装pip成功！
接下来就 pip install torch 安装torch库成功！
其中，方法三本人自己亲测有用，这些方法都是我自己试过的，希望能对你们有帮助，如果本文存在问题，还请多多指教。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3317b3786d50d249a69209ea64febd23/" rel="bookmark">
			【数学】欧拉函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
欧 拉 函 数 欧拉函数 欧拉函数 对正整数n，欧拉函数是小于或等于n的数中与n互质的数的数目
欧 拉 函 数 通 常 用 φ ( n ) 表 示 欧拉函数通常用\varphi (n) 表示 欧拉函数通常用φ(n)表示
∀ x ∈ Z + , 先 分 解 成 质 因 数 相 乘 的 格 式 \forall x \in Z _+ , 先分解成质因数相乘的格式 ∀x∈Z+​,先分解成质因数相乘的格式
x = P _ 1 c 1 × P _ 2 c 2 × . . . × P n c n x = P\_1^{c1} \times P\_2^{c2} \times .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3317b3786d50d249a69209ea64febd23/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/199/">«</a>
	<span class="pagination__item pagination__item--current">200/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/201/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>