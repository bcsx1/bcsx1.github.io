<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e7c144d676d4c4927b266d5a431244a/" rel="bookmark">
			MySQL-多表设计-一对多
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多表的设计-概述 项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：
一对多（多对一）多对多一对一 一对多 需求 根据页面原型及需求文档，完成部门（1：父表）及员工（n：子表）模块的表结构设计
由于部门与员工的对应关系为一对多，所以在创建员工表时，设置一个属性指定当前员工属于哪一个部门具体代码如下 -- 创建员工表 create table tb_emp ( id int unsigned primary key auto_increment comment '主键ID', username varchar(20) not null comment '用户名', password varchar(32) default '123456' null comment '密码', name varchar(10) not null comment '姓名', gender tinyint unsigned not null comment '性别, 1 男, 2 女', image varchar(300) null comment '图像url', job tinyint unsigned null comment '职位, 1 班主任 , 2 讲师 , 3 学工主管, 4 教研主管', entrydate date null comment '入职日期', dept_id int unsigned comment '归属部门的部门ID', create_time datetime not null comment '创建时间', update_time datetime not null comment '修改时间' ) comment '员工表'; -- 创建部门 create table tb_dept ( id int primary key auto_increment comment '部门ID', name varchar(10) not null unique comment '部门名称', create_time datetime not null comment '创建时间', update_time datetime not null comment '更新时间' ) 由上述代码可知在员工表与部门表通过部门ID联系起来
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e7c144d676d4c4927b266d5a431244a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75b49e1918fc1c5e7f41e6f3c1d9af59/" rel="bookmark">
			IDEA2023.1.3创建Java Web项目并配置Tomcat（傻瓜式教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇教程只针对IDEA2023.1.3版的Java Web项目创建以及配置Tomcat，不包含Tomcat下载教程
1.选择New Project，设置好项目名和JDK，点击Create
2.打开Project Structure
3.在Modules里点击加号选择Web，这样IDEA会帮我们创建好webapp文件夹和web.xml配置文件
4. 为项目创建一个web应用artifacts，IDEA在这里会提示，直接点击Create Artifact就可以自动配置
5.创建好的页面是这样的，点击Apply、OK就可以了
现在的文件结构
6.点击这里的Edit Configuration，导航栏的Run选项卡里也有，一样的
7.点击＋号，添加一个Tomcat Server，注意选择Local，Remote远程用的
8.添加上是这样的，里面的设置看不懂就不要乱改，这里不一一说明，注意我用的80端口，默认是8080，不需要改成和我一样的。我们需要将刚建的Web Artifact部署到Tomcat中，你可以点击右下角Fix让IDEA自动配置
也可以在Deployment选项卡中手动配置，＋号，Artifact
这样就OK了
大家刚刚应该发现了JRE是空的，注意这里的JRE会自动跟随部署的项目，所以我刚才没讲，现在点击Apply，OK，就可以了
9.最后还需要导入相关的依赖，这里有两种方式，在Project Structure的Libraries里导入，点击＋号，Java，然后选择要添加的jar包或目录，IDEA会把目录下所有的jar包导入，我一般直接选择Tomcat下的lib目录，里面有大部分基本jar包，比如我们要用到的servlet-api等。
也可以把jar包放在webapp目录下，右键点击Add as Library，OK就行
10.现在一切就绪，我们终于可以使用Servlet了，写一个Servlet，测试一下
Tomcat，启动！
毫无悬念的成功 看一下效果
完全符合预期，到这里一个使用Tomcat的JavaWeb项目就创建完毕可以使用了。对了，WEB-INF目录下的资源是无法访问的，不要把东西乱放，所以刚那个jar包在浏览器是可以访问下载的
最后附上Apache Tomcat官网的版本对照表，版本不兼容很有可能出错！ 演示中使用的的是Web4.0，Tomcat9.0.78，JDK1.8 ，可以看到和表中正确对应
觉得有用的朋友们可以点赞收藏一下，谢谢各位。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe433a7fc8bd346f7e068ddaa2cf4322/" rel="bookmark">
			c&#43;&#43; 字符串与数字相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考 C++ 数字与字符串之间相互转换(多种方法)
参考 c++ 字符串与数字相互转换
1. 字符串转数字 C函数 atoi()、atof()2. 字符串转数字 C++(1)stoi()、stol()、stof()(3)、使用 sscanf() 映射(4)、自己写一个简单的 3.数字转字符串(1)、使用c++里的to_string()(2)、使用itoa()(3)、使用sprintf() 映射(4)、自己写一个简单的 1. 字符串转数字 C函数 atoi()、atof() atoi() (表示 ascii to integer)把字符串转换成整型数的一个函数，，头文件为&lt;stdlib.h&gt;。
int atoi(const char *nptr) 函数会扫描参数 nptr字符串，会跳过前面的空白字符（例如空格，tab缩进）等。
如果 nptr不能转换成 int 或者 nptr为空字符串，那么将返回 0 。
atof() 把字符串转换成浮点数，头文件为&lt;stdlib.h&gt;。
该函数名是 “ascii to floating point numbers” 的缩写。
语法格式为：double atof(const char *nptr)。
atoi, atof,atol函数，均在stdlib.h中进行了声明，在头文件中，其声明的函数原型为
double	atof(const char *); int	atoi(const char *); long	atol(const char *); 不难看出，上面这些方法的输入均为const char *，即字符串，得到的输出为转化以后的各种数值类型。
实例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe433a7fc8bd346f7e068ddaa2cf4322/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0642c39e3abda311f22785cf79bf75f4/" rel="bookmark">
			阿里云OSS的使用----上传文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言 前言 文件上传，是指将本地图片、视频、音频等文件上传到服务器上，可以供其他用户浏览或下载的过程。文件上传在项目中应用非常广泛，我们经常发抖音、发朋友圈都用到了文件上传功能。
实现文件上传服务，需要有存储的支持，那么我们的解决方案将以下几种：
直接将图片保存到服务的硬盘（springmvc中的文件上传） 优点：开发便捷，成本低缺点：扩容困难 使用分布式文件系统进行存储 优点：容易实现扩容缺点：开发复杂度稍大（有成熟的产品可以使用，比如：FastDFS,MinIO） 使用第三方的存储服务（例如OSS） 优点：开发简单，拥有强大功能，免维护缺点：付费 实现步骤：
1). 定义OSS相关配置
application-dev.yml
alioss: endpoint: oss-cn-hangzhou.aliyuncs.com access-key-id: 你的服务器id access-key-secret: 服务器私密 bucket-name: 项目名 2). 读取OSS配置
@Component @ConfigurationProperties(prefix = "alioss") @Data public class AliOssProperties { private String endpoint; private String accessKeyId; private String accessKeySecret; private String bucketName; } 3). 生成OSS工具类对象
@Configuration @Slf4j public class OssConfiguration { @Bean @ConditionalOnMissingBean public AliOssUtil aliOssUtil(AliOssProperties aliOssProperties){ log.info("开始创建阿里云文件上传工具类对象：{}",aliOssProperties); return new AliOssUtil(aliOssProperties.getEndpoint(), aliOssProperties.getAccessKeyId(), aliOssProperties.getAccessKeySecret(), aliOssProperties.getBucketName()); } } AliOssUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0642c39e3abda311f22785cf79bf75f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c0f86fcd079e5f4685ea7c1a1e2555f/" rel="bookmark">
			【数字图像处理】常用知识点以及OpenCv实现的总结！更新中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、基本概念1.1、距离度量1.2、常见的插值方法1.2.1、最近邻插值1.2.2、双线性插值 二、形态学操作2.1、腐蚀2.2、膨胀2.3、开运算 + cv2.morphologyEx()实现更复杂的形态学操作2.4、闭运算2.5、形态学梯度运算2.6、顶帽2.7、黑帽2.8、击中击不中 三、图像增强3.1、图像增强和图像恢复的区别3.2、空域灰度变换3.2.1、线性变换/分段线性变换3.2.2、非线性变换3.2.3、直方图均衡化/规定化 3.3、空域滤波3.3.1、空域平滑3.3.1.1、均值滤波3.3.1.2、中值滤波3.3.1.3、高斯滤波 3.3.2、空域锐化3.3.2.1、一阶微分算子3.3.2.2、二阶微分算子 3.4、频域增强 四、图像恢复五、边缘检测5.1、边缘检测5.2、一阶微分算子5.2.1、Roberts算子5.2.2、Prewitt算子5.2.3、Sobel算子 5.3、二阶微分算子5.3.1、Laplacian算子5.3.2、Canny算子 六、图像分割6.1、阈值分割6.2、区域生长法6.3、分裂合并法6.4、分水岭分割6.5、聚类分割算法6.6、水平集分割6.7、Graph Cut分割 七、图像表达与描述7.1、全局特征：LBP7.2、简单局部特征：HOG7.2.1、梯度幅度和方向计算7.2.2、计算grid cell中的方向梯度直方图7.2.3、block归一化 7.3、基于关键点检测的局部特征：Harris角点、块检测(DoG, MSER)、SIFT7.3.1、SIFT特征1）构建高斯差分金字塔（Difference of Gaussian，DoG）并进行尺度空间极值检测2）特征点/关键点定位3）特征点/关键点方向的确定4）计算特征描述子5）OpenCv的实现6）旋转不变性、尺度不变性、亮度不变性 八、图像识别8.1、Hough变换8.1.1、算法原理8.1.2、检测直线、圆、椭圆8.1.3、广义hough变换 8.2、距离变换 一、基本概念 1.1、距离度量 下面以两点 a = ( i , j ) a=(i, j) a=(i,j)和 b = ( k , l ) b=(k, l) b=(k,l)为例介绍距离度量。
欧氏距离：是最常用的距离定义，是指在n维空间中，两个点（其实如果是n维空间，点也可以看作n维向量）之间的真实距离：
曼哈顿距离/街区距离：名字由来就是，在曼哈顿街区从一个十字路口到另一个十字路口所走过的距离，此时不是直线距离，而是如下的 D 4 D_4 D4​。也就是说：如果在二维图像中来看，像素点之间只允许横向或纵向移动，像素点之间是4邻接的。
切比雪夫/棋盘距离：在国际象棋中，可以横向、纵向或者斜向移动，那么二维图像中，像素点之间就是8邻接的，即每个点只与它的上、下、左、右、四个对角线方向相邻的8个点之间的距离为1。于棋盘距离为：
余弦相似度：通过计算两个向量之间夹角的余弦值来评估二者之间的相似度：
参考链接：https://blog.csdn.net/yishuihanq/article/details/120283648
1.2、常见的插值方法 1.2.1、最近邻插值 最简单的插值方法：在相邻的四个像素点中，取最近的像素点的值作为输出值(u, v)为待插值点
1.2.2、双线性插值 顾名思义，进行两次线性插值（线性插值就是两个像素点按比例加权即可）：先在x方向上插值，再在y方向上插值
二、形态学操作 形态学操作最基本的运算是腐蚀与膨胀。基于腐蚀与膨胀操作可以实现更复杂的运算：开运算、闭运算、形态学梯度运算、顶帽运算、黑帽运算、击中击不中运算。
2.1、腐蚀 腐蚀最简单理解就是不断消除掉边界区域，即腐蚀操作可以收缩/细化二值图像（最常用的就是二值图像，灰度/彩色图像也可以作为输入）中的前景部分，或者直接去除掉某些小于指定结构体元素的前景区域（也就是说消除掉噪声）。
腐蚀操作的运算过程：假设有图像A和结构体元素B，类似卷积操作，结构体元素B在图像A上移动，其中定义B的中心为锚点，计算B覆盖A的区域中最小值的像素值用来替代锚点的像素，其中B可以是矩形，圆，椭圆等任意形状，需要注意腐蚀膨胀操作的图像一般是二值图（最好保持前景区域为1，背景区域为0）作用：1）消除小颗粒噪声；2）消除目标区域之间的粘连，但同时目标区域的边界也会向内收缩
OpenCv的实现：首先通过cv2.getStructuringElement创建结构体元素或者自定义生成结构体元素，再调用cv2.erode()实现腐蚀操作。 cv2.getStructuringElement(shape, ksize[, anchor]) -&gt; retval "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c0f86fcd079e5f4685ea7c1a1e2555f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0b786c7048826c9ab892f31009bb94b/" rel="bookmark">
			FPGA学习--蜂鸣器播放音乐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简单介绍音频介绍代码内容结束 简单介绍 本来是需要介绍蜂鸣器的，这里就不多做介绍了，因为我也不知道怎么解释，这里只是加入了自己的理解。
蜂鸣器在Verilog语言里面一般用beep来写，高电平表示关闭，而低电平表示触发。只是让蜂鸣器响这些就够了，但是我们今天需要播放音乐，需要播放不同的音频，所以这里有一些新的理解。
音频介绍 一般能够找到的简谱频率都是偏低音，也就是262hz开始的，但是这些低音在蜂鸣器上发音不太准，（也许占空比低点会好点，但是我没试过）这里选择了钢琴的高音区，如下图。
这里直接使用的白键的音，我们使用50MHz/音阶频率得到的结果，表示我们要在相应的位置计数并改变蜂鸣器的状态，可让蜂鸣器发出一秒内相应的音节频率。
今天我们直接写一个明日香处刑曲，也就是马来西亚民谣RASA SAYANGE（乐）。
代码内容 module beep_play( input wire clk , input wire rst_n , output wire beep ); //各个音节代码，方便使用 localparam G1 = 5'd01 , G2 = 5'd02 , G3 = 5'd03 , G4 = 5'd04 , G5 = 5'd05 , G6 = 5'd06 , G7 = 5'd07 ; localparam M1 = 5'd08 , M2 = 5'd09 , M3 = 5'd10 , M4 = 5'd11 , M5 = 5'd12 , M6 = 5'd13 , M7 = 5'd14 ; localparam D1 = 5'd15 , D2 = 5'd16 , D3 = 5'd17 , D4 = 5'd18 , D5 = 5'd19 , D6 = 5'd20 , D7 = 5'd21 ; //计数器，用于计时和记录音节位置 parameter MAX_0_3s = 24'd15_000_000; parameter MAX_FLAG = 8'd147; reg beep_r;//控制蜂鸣器 reg [7:0] flag;//记录蜂鸣器的音节位置 reg [4:0] music_r;//记录音节的内容 reg [23:0] cnt;//时间计数器 reg [17:0] MAX_music;//用于记录音节频率 reg [17:0] cnt_music;//记录单个音节的震荡计数 //记录单个音节的长度 always @(posedge clk or negedge rst_n) begin if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0b786c7048826c9ab892f31009bb94b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/933759b5ca7db09c4adbbf788b5ec322/" rel="bookmark">
			Arduino控制蜂鸣器、实现PWM调节光亮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.蜂鸣器输出实验 1.源代码 int buzzer=2;//设置控制蜂鸣器的数字口对应板子上2口 void setup() { pinMode(buzzer,OUTPUT);//设置对应的输出模式 } void loop() { unsigned char i,j;//定义变量 while(1) { for(i=0;i&lt;50;i++)//输出一个频率的声音 { digitalWrite(buzzer,HIGH);//高电平打开蜂鸣器发声 delay(1);//延时1ms 通过这个延时可以改变声音的频率不同 digitalWrite(buzzer,LOW);//低电平关闭蜂鸣器不发声音 delay(1);//延时ms 通过这个延时可以改变声音的频率不同 } for(i=0;i&lt;50;i++)//输出另一个频率癿声音 { digitalWrite(buzzer,HIGH);//高电平打开蜂鸣器发声 delay(5);//延时2ms 通过这个延时可以改变声音的频率不同 digitalWrite(buzzer,LOW);//低电平关闭蜂鸣器不发声音 delay(5);//延时2ms 通过这个延时可以改变声音的频率不同 } } } 2.定义数字引脚 int buzzer=2;//设置控制蜂鸣器的数字口对应板子上2口 int redLed=2;//定义板子上数字口2 int yellowLed=3;//定义板子上数字口3 int greenLed=4;//定义板子上数字口4 在 Arduino 中，数字引脚可以使用 int 或 uint8_t 来定义。int 是有符号整数类型，通常用于表示更大的数字范围，而 uint8_t 是无符号的 8 位整数类型（相当于C语言中的long），可以表示 0-255 的数字范围，这对于表示数字引脚非常方便。在实际应用中，两种类型都可以使用，具体取决于你的需求和个人喜好。
3.unsigned char 在 C/C++ 中，char 类型数据可以被看作是整数类型。unsigned char 表示无符号的 8 位整数类型，其表示范围为 0-255。当你使用 unsigned char i,j; 定义变量 i 和 j 后，它们就被分配了 1 个字节（8 位）的内存空间，可以用来存储整数值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/933759b5ca7db09c4adbbf788b5ec322/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0162417f1ed609a45867d8f15c09483a/" rel="bookmark">
			安卓通过adb pull和adb push 手机与电脑之间传输文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.可以参考这篇文章
https://www.cnblogs.com/hhddcpp/p/4247923.html 2.根据上面的文章，我做了如下修改
//设置/system为可读写： adb remount //复制手机中的文件到电脑中。需要在电脑中新建一个文件夹，我新建的文件夹为ce文件夹 adb pull /system/etc/hosts E:\ce //然后你会发现ce文件夹中多了一个hosts文件，是的，复制成功了 //这个时候，修改hosts文件中的内容。修改完以后，执行下一条指令，也就是上传电脑中的文件到手机 //现在是上传电脑中的文件到手机中 adb push E:\ce\hosts /system/etc/hosts //这时候你去手机中看hosts文件会发现修改成功了 3.看图片
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d0f60fc46d4eeef9cee87869f04fa59/" rel="bookmark">
			URL中加号（&#43;）转义问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		URL中加号（+）转义问题 前端通过URL传入一个参数，在后台日志中发现参数中的加号变成了空格。
前端传入a+b
后台日志a b
可以看到，+ 变成了空格。
先说结论 HTTP为了避免歧义，一些字符传入后台需要做转义，例如：
" - %22 # - %23 % - %25 &amp; - %26 + - %2B 也就是说，+ 从前台传到后台，应该转换为 %2B。
但是 + 作为 URL 参数时，会被浏览器自动转换为空格（转换机制不明，不知道浏览器为什么这么做）。
我们要做的很简单，提前转换一下，保证 + 被转义成 %2B，这样的话无论是通过 URL 传，还是用 AJAX 传值，都不可能出错。
使用 encodeURIComponent 转义的 js 代码：
var s = encodeURIComponent('1+1'); console.log(s); 打开控制台查看输出，+ 处理正确
1%2B1 顺便一提，不要使用 encodeURI 函数，它不能正确转义。
GET POST 表单提交的转义 使用表单提交，无论是 GET 还是 POST，都会自动帮我们作出正确的转义。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/588fe731ba6de845b35c70d592de8c82/" rel="bookmark">
			ORB-SLAM2自己的数据集制作(mono)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 准备工作：一段视频mp4 &amp; 标定好的相机参数
第一步： 把视频转换为图片序列。
工具ffmpeg：
ffmpeg -i {视频位置} -r 30{帧率] -f image2 {保存文件夹位置}/%05d.jpg 第二步：将图片名称批量写入txt文件。
python脚本
import os txt_path=".../1.txt" imagedir_path="..../kitti" files=os.listdir(imagedir_path) files.sort() with open(txt_path,mode='a') as f: for file in files: if not os.path.isdir(file): f.write(file[0:-4]+' rgb/'+file+'\n') f.close() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a89da71eff0bdf7c4f3cb74916be41e0/" rel="bookmark">
			echarts——柱状图&#43;折线图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var myChart = echarts.init(document.getElementById('myChart')); var option = { title: { text: 'XX增速', textStyle: { color: '#2bffff', fontSize: 14, fontWeight: '100', fontFamily: "fontStyle" }, left: '0', top: '0', }, tooltip: { show: true, backgroundColor: 'rgba(38,39,40,0.6)', borderColor: 'rgba(38,39,40,0.6)', textStyle: { color: '#fff', }, formatter: function (params) { return params.seriesName + ':' + params.value + '%' } }, grid: { top: '40%', left: '1%', right: '4%', bottom: '20%', containLabel: true }, yAxis: [{ type: 'category', name: '单位：%', nameTextStyle: { color: '#afb7be', align: 'left', }, axisTick: { show: false, alignWithLabel: true }, axisLine: { show: false, lineStyle: { color: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a89da71eff0bdf7c4f3cb74916be41e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27208c913884f89d3c3f45d197d53b56/" rel="bookmark">
			echarts——环形图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		const value_ze = 60 const value2_ze = 30 var myChart = echarts.init(document.getElementById('myChart')); var option = { title: { text: `目标完成率`, subtext: [`{a|${value_ze}}`, '{b|%}'].join(''), itemGap: 10, textStyle: { fontSize: '14', color: '#fff', fontWeight: 500 }, subtextStyle: { rich: { a: { fontSize: '32', color: '#fff', fontWeight: 500, fontFamily: "numStyle" }, b: { fontSize: '14', color: '#fff', padding: [8, 0, 0, 6] }, } }, left: 'center', top: '35%', }, grid: { top: '0%', left: '0%', right: '0%', bottom: '0%', containLabel: true }, visualMap: { show: false, }, series: [ { name: '', type: 'pie', radius: ['94%', '96%'], center: ['50%', '50%'], itemStyle: { label: { show: false, }, }, hoverAnimation: false, data: [ { value: 100, label: { show: false, }, itemStyle: { normal: { color: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27208c913884f89d3c3f45d197d53b56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af8a5351cf847f6c05381b873f914932/" rel="bookmark">
			Visual Studio 快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 快捷键功能CTRL+K+C多行注释CTRL+K+U多行注释快CTRL+X剪切整行代码CTRL+L删除整行代码CTRL+C，再粘贴CTRL+V复制整行代码CTRL+Shift+Enter在光标所在行的下面插入一行CTRL+Enter在光标所在行的上面插入一行F12跳转到定义Shift+F12查找所有引用F9设置断点调试：断点行不执行F5调试(启动)Ctrl+F5运行程序（不进行调试）F10逐过程调试F11逐语句调试按住alt+向上或向下的箭头代码上下移动Home跳到一行的开始End跳到一行的结尾 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e1675286ba7cfc1f5e03c3d0628370e/" rel="bookmark">
			史上最全Java面试题（带全部答案）2023年最新版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天要谈的主题是关于求职，求职是在每个技术人员的生涯中都要经历多次。对于我们大部分人而言，在进入自己心仪的公司之前少不了准备工作，有一份全面细致面试题将帮助我们减少许多麻烦。在跳槽季来临之前,特地做这个系列的文章，一方面帮助自己巩固下基础，另一方面也希望帮助想要换工作的朋友。
相关概念 面向对象的三个特征 封装，继承，多态，这个应该是人人皆知，有时候也会加上抽象。
多态的好处 允许不同类对象对同一消息做出响应，即同一消息可以根据发送对象的不同而采用多种不同的行为方式(发送消息就是函数调用)。主要有以下优点：
可替换性：多态对已存在代码具有可替换性可扩充性：增加新的子类不影响已经存在的类结构接口性：多态是超类通过方法签名,向子类提供一个公共接口,由子类来完善或者重写它来实现的。灵活性简化性 代码中如何实现多态 实现多态主要有以下三种方式：
1. 接口实现
2. 继承父类重写方法
3. 同一类中进行方法重载
虚拟机是如何实现多态的 动态绑定技术(dynamic binding)，执行期间判断所引用对象的实际类型，根据实际类型调用对应的方法。
接口的意义 接口的意义用三个词就可以概括：规范，扩展，回调。
抽象类的意义 抽象类的意义可以用三句话来概括：
为其他子类提供一个公共的类型封装子类中重复定义的内容定义抽象方法,子类虽然有不同的实现，但是定义时一致的 接口和抽象类的区别 比较
抽象类
接口
默认方法
抽象类可以有默认的方法实现
java 8之前,接口中不存在方法的实现.
实现方式
子类使用extends关键字来继承抽象类.如果子类不是抽象类,子类需要提供抽象类中所声明方法的实现.
子类使用implements来实现接口,需要提供接口中所有声明的实现.
构造器
抽象类中可以有构造器,
接口中不能
和正常类区别
抽象类不能被实例化
接口则是完全不同的类型
访问修饰符
抽象方法可以有public,protected和default等修饰
接口默认是public,不能使用其他修饰符
多继承
一个子类只能存在一个父类
一个子类可以存在多个接口
添加新方法
想抽象类中添加新方法,可以提供默认的实现,因此可以不修改子类现有的代码
如果往接口中添加新方法,则子类中需要实现该方法.
父类的静态方法能否被子类重写 不能。重写只适用于实例方法,不能用于静态方法，而子类当中含有和父类相同签名的静态方法，我们一般称之为隐藏。
什么是不可变对象 不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。
静态变量和实例变量的区别? 静态变量存储在方法区，属于类所有。实例变量存储在堆当中，其引用存在当前线程栈。
能否创建一个包含可变对象的不可变对象? 当然可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用。
java 创建对象的几种方式 采用new通过反射采用clone通过序列化机制 前2者都需要显式地调用构造方法。造成耦合性最高的恰好是第一种，因此你发现无论什么框架，只要涉及到解耦必先减少new的使用。
switch中能否使用string做参数 在idk 1.7之前，switch只能支持byte, short, char, int或者其对应的封装类以及Enum类型。从idk 1.7之后switch开始支持String。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e1675286ba7cfc1f5e03c3d0628370e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/062fd49862bb0e40a770041f070f3aaa/" rel="bookmark">
			MySQL命令行下载安装配置——详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装尽量装在C盘，因为某些因素装在别的盘可能不好使
此教程下载的是8.0.33，之前的版本与此教程不同（我在23年7月份发现MySQL版本安装有所改动）
文章目录 免安装版的MySQLMySQL命令行下载1、打开官网下载2、点击 MySQL Community Server3、选择适合的版本 MySQL的配置一、配置初始化文件my.ini二、初始化MySQL三、安装mysql服务并启动+设置密码四、配置环境变量五、MySQL连接可视化工具（Navicat、VS Code） 注意：**Windows启动 MySQL 的几种方式**一：bin目录下启动mysql：参考命令参考博文 二：服务启动命令参考： 免安装版的MySQL 提示：这里可以添加本文要记录的大概内容：
MySQL关是一种关系数据库管理系统，所使用的 SQL 语言是用于访问数据库的最常用的标准化语言，其特点为体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，在 Web应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。
在本博文里，我主要以MySQL免安装版为例，帮助大家解决配置MySQL。
提示：以下是本篇文章正文内容，下面案例可供参考
MySQL命令行下载 如果之前下载过MySQL，不知道删没删干净，请点击看这篇文章
这篇文章讲解MySQL命令行(压缩版 .zip)的安装与配置
1、打开官网下载 MySQL官网下载　下滑找到 MySQL Community (GPL) Downloads
2、点击 MySQL Community Server 3、选择适合的版本 在General Availability(GA) Releases中选择适合的版本
Windows平台下提供两种安装文件：
MySQL二进制分发版（.msi安装文件）和免安装版（.zip压缩文件）。
一般来讲，应当使用二进制分发版，因为该版本提供了图形化的安装向导过程，比其他的分发版使用起来要简单，不再需要其他工具启动就可以运行MySQL。
这里在Windows 系统下推荐下载 ZIP安装程序；
点击Go to Download Page进行下载即可
然后根据自己系统版本(32还是64位系统)选择下载
如果安装MySQL其他版本的话，选择Archives，接着选择MySQL的相应版本即可。
本人偏爱上面的压缩版
一般选择最新版本，直接点击【No thanks, just start my download.】下载即可
如果喜欢软件版的话，可以点击下方链接
MySQL软件下载安装配置——详细教程
MySQL的配置 一、配置初始化文件my.ini 下载完成后解压到某一个文件夹 （记住这个路径，一会要用到）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/062fd49862bb0e40a770041f070f3aaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e943f6ef8d6834fc9b2dac2c48343e1a/" rel="bookmark">
			补码表示的算术运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		补码表示的算术运算是指使用补码来进行带符号整数的加法、减法和乘法运算。
补码加法：
补码加法是将两个补码表示的带符号整数进行相加的操作。它的基本步骤如下：
将两个补码的对应位进行相加，包括符号位。忽略最高位的进位。如果最高位产生了进位，表示结果发生了溢出。 补码减法：
补码减法是将一个补码表示的带符号整数减去另一个补码表示的带符号整数的操作。它的基本步骤如下：
将被减数的补码表示取反（按位取反）。将取反后的被减数与减数进行补码加法。 补码乘法：
补码乘法是将两个补码表示的带符号整数进行相乘的操作。它的基本步骤如下：
将两个补码的绝对值进行乘法运算，得到结果的绝对值。确定结果的符号位，根据乘法运算得出的正负情况确定符号位。 补码表示的算术运算具有简洁性和唯一性，能够对带符号整数进行准确的加减乘运算。在计算机系统中，大多数处理器使用补码表示带符号整数，因为它方便处理溢出和简化运算。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38fc58eddb3c15ca3a32790cbb7fa41f/" rel="bookmark">
			JS高级进阶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript 进阶 - 第1节 学习作用域、变量提升、闭包等语言特征，加深对 JavaScript 的理解，掌握变量赋值、函数声明的简洁语法，降低代码的冗余度。
理解作用域对程序执行的影响能够分析程序执行的作用域范围理解闭包本质，利用闭包创建隔离作用域了解什么变量提升及函数提升掌握箭头函数、解析剩余参数等简洁语法 作用域 了解作用域对程序执行的影响及作用域链的查找机制，使用闭包函数创建隔离作用域避免全局变量污染。
作用域（scope）规定了变量能够被访问的“范围”，离开了这个“范围”变量便不能被访问，作用域分为全局作用域和局部作用域。
局部作用域 局部作用域分为函数作用域和块作用域。
函数作用域 在函数内部声明的变量只能在函数内部被访问，外部无法直接访问。
&lt;script&gt; // 声明 counter 函数 function counter(x, y) { // 函数内部声明的变量 const s = x + y console.log(s) // 18 } // 设用 counter 函数 counter(10, 8) // 访问变量 s console.log(s)// 报错 &lt;/script&gt; 总结：
函数内部声明的变量，在函数外部无法被访问函数的参数也是函数内部的局部变量不同函数内部声明的变量无法互相访问函数执行完毕后，函数内部的变量实际被清空了 块作用域 在 JavaScript 中使用 {} 包裹的代码称为代码块，代码块内部声明的变量外部将【有可能】无法被访问。
&lt;script&gt; { // age 只能在该代码块中被访问 let age = 18; console.log(age); // 正常 } // 超出了 age 的作用域 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38fc58eddb3c15ca3a32790cbb7fa41f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d467be5c3e0da26f9065afe7b7e4494/" rel="bookmark">
			flask项目中内部接口调用其他内部接口操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、requests 在 Flask 框架项目中，可以通过使用 requests 模块来进行内部接口调用。requests 模块是 Python 中常用的 HTTP 请求库，可以用于发送 HTTP 请求和处理响应。
示例代码：
from flask import Flask import requests app = Flask(__name__) @app.route('/api1') def api1(): # 调用内部接口api2 response = requests.get('http://localhost:5000/api2') # 指定接口的URL if response.status_code == 200: return "API1:" + response.text else: return "API1: Failed to call API2!" @app.route('/api2') def api2(): return "API2: Hello from API2" if __name__ == '__main__': app.run(debug=True) 在上面的示例中，api1 和 api2 分别是两个内部接口。api1 中调用了 api2，并通过 requests.get() 方法发送 GET 请求到 http://localhost:5000/api2，并处理响应。可以根据实际情况设置接口的 URL 和请求参数、请求头等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d467be5c3e0da26f9065afe7b7e4494/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8304f144d2b04c80f5721a7bd79335a/" rel="bookmark">
			华为机试（JAVA）真题Od【A卷&#43;B卷】2023最新版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、机考攻略二、机考重要性三、下面，哪吒将华为OD机试真题归归类，让大家一目而了然。四、下面分享一道**“2022Q4 100分的路灯照明问题”**，提前体验一下华为OD机试的**“恐怖如斯”**。1、题目描述2、输入描述3、输出描述4、解题思路特别鸣谢：感谢fly晨发现这个问题，并提供更优质的算法。解题思路如下：5、Java算法源码6、效果展示1、输入2、输出3、思路 五、还没过瘾？那再分享几道，可以自己跳转刷刷刷~，让你过瘾为止。六、Spring Cloud Alibaba核心技术与实战案例1、内容简介2、作者简介3、书籍链接 大家好，我是哪吒。
本专栏收录于《华为OD机试（JAVA）真题（A卷+B卷）》。
刷的越多，抽中的概率越大，每一题都有详细的答题思路、详细的代码注释、样例测试，订阅后，专栏内的文章都可看，可加入华为OD刷题群（私信即可），发现新题目，随时更新，全天CSDN在线答疑。
专栏福利：限时订阅49.9，订阅后可加入华为OD刷题群，获得哪吒优先答疑机会（华为OD刷题指导，远程代码调试），群里大佬众多可以抱团取暖，群友刷题经验分享，考试经验分享。 一、机考攻略 三道中等难度题目，总分400分，前两道均为100分，后一道为200分，每道题的时间限制为1S（慎用暴力方法，实在没办法，也可！）。
机考分数是按照题目用例的通过数量的比例算分数，若有的题做不出来，可尽力去写，一些用例通过就有分数。
机考时长2个半小时，若以冲刺机考最高分为目的，则做题时间分配前两道题40分钟，最后一题70分钟（平时练习可以按照40分钟的时限）。
机考分数线根据招聘目标院校和非目标院校有不同，不同华为招聘部门也会有差异，比如前者机考通过线为150分，后者机考通过线为320分。
若以通过机考线为目的，根据自身情况来进行做题时长配置。
机考全程需要打开摄像头，摄像头中不能出现其他人或者宠物，带个小狗和你去考试，这有点过分了吧？机考全程保证网络稳定；若机考遇到刷到过的题目，不能照搬网上公开的代码，系统会对代码的相似度进行评估，会被系统判定作弊，建议代码相似度在80%以内；可以通过修改变量名，拆分算法步骤，提取公共方法等手法解决，你懂的~ 二、机考重要性 OD招聘过程中，机考和性格测试是由系统判定，第二轮技术面试中会现场写代码的；OD机考分数越高，有助于申请更高的定级或者薪酬；若后续性格测试没通过，机考分数高的话，还可以据此作为申请性格测试重测的依据之一； 三、下面，哪吒将华为OD机试真题归归类，让大家一目而了然。 关于订阅华为OD机试真题的后续问题
订阅专栏后，专栏内的文章都可看，以后还会继续更新新题；每道题都包含题目、解题思路、代码详解（关键行包含详细注释）、代码运行截图（保证代码100%正确，通过率100%）；已经订阅的小伙伴，推荐新人订阅可享 8 折优惠，私信我即可； 在考试的时候，最好不要用CSDN专栏里的源码去答题，因为华为OD机试是有查重的，这个一定要注意！最好是改一改变量名称，加一加注释，改一改逻辑顺序，掌握答题思路才是关键，下面的题中我都加了详细的答题思路，代码中也有详细的注释说明，代码运行是100%正确无误的，每一题都有样例测试，全网独一份。
如果你刚刚参加完机试考试，欢迎提供真题到哪吒这里，直接红包转账收题。
很多考过的小伙伴，总结了宝贵的经验，多刷题，先易后难，前期积累自信，后期逐一突破，效果最佳。
四、下面分享一道**“2022Q4 100分的路灯照明问题”，提前体验一下华为OD机试的“恐怖如斯”**。 1、题目描述 在一条笔直的公路上安装了N个路灯，从位置0开始安装，路灯之间间距固定为100米。
每个路灯都有自己的照明半径，请计算第一个路灯和最后一个路灯之间，无法照明的区间的长度和。
2、输入描述 第一行为一个数N，表示路灯个数，1&lt;=N&lt;=100000。
第二行为N个空格分隔的数，表示路径的照明半径，1&lt;=照明半径&lt;=100000*100。
3、输出描述 第一个路灯和最后一个路灯之间，无法照明的区间的长度和。
4、解题思路 题目要求计算第一个路灯和最后一个路灯之间无法照明的区间的长度和。
例如：
3
20 70 30
路灯1 覆盖0-20
路灯2 覆盖30-170
路灯3 覆盖170-230
没被覆盖的区间只有20~30。
所以输出10。
但是，如果路灯的照明范围大于100，怎么办？
特别鸣谢：感谢fly晨发现这个问题，并提供更优质的算法。 解题思路如下： 获取输入的灯数量；通过Java8 Steam加载n个路灯的照明半径；定义allResList，存储每个灯的照明范围；定义maxRight，计算第一个灯和最后一个灯的距离；将每个灯的照明范围放入一个集合中（左起点，右终点）；将每个灯的照明范围按照左起点进行升序排序； 先按左边最小距离排序；如果左边距离相等的情况下 按照右边距离最小的排序； 当前节点和下一个节点做比较； 用当前节点的右边照明范围和下一个节点的左边照明范围比较；大于的情况下 需要将下一个节点的右边距离取两个节点的最大值；说明两个节点之间存在黑暗距离； 输出黑暗距离之和totalBlack； 5、Java算法源码 public static void main(String[] args) { Scanner sc = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8304f144d2b04c80f5721a7bd79335a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26e0a33c462e44ba380212b5fa0db3dc/" rel="bookmark">
			51单片机学习--数码管显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先实现静态数码管显示 SMG表示共阴极 ，要让第三位显示数字6，需要LED6端口接0，即Y5=0，5的二进制为101，按P2_4 到 P2_2 的顺序接，则CBA分别接101
然后在数码管另一端，需要点亮的接上1，根据原理图一一对应即可
得到P0_0 到 P0_7 依次为1011 1110
所以P0的十六进制为0111 1101 == 7D
功能：使第三位显示数字6 #include &lt;REGX52.H&gt; #include &lt;INTRINS.H&gt; void main() { P2_4 = 1; //C P2_3 = 0; //B P2_2 = 1; //A P0 = 0x7D; while(1) { } } 将这个功能封装成函数，指定位置显示指定数字 #include &lt;REGX52.H&gt; #include &lt;INTRINS.H&gt; unsigned char NixieTable[] = {0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F}; void Nixie(unsigned char Location, Number) { switch(Location) { case 1: P2_4 = 1; P2_3 = 1; P2_2 = 1; break; case 2: P2_4 = 1; P2_3 = 1; P2_2 = 0; break; case 3: P2_4 = 1; P2_3 = 0; P2_2 = 1; break; case 4: P2_4 = 1; P2_3 = 0; P2_2 = 0; break; case 5: P2_4 = 0; P2_3 = 1; P2_2 = 1; break; case 6: P2_4 = 0; P2_3 = 1; P2_2 = 0; break; case 7: P2_4 = 0; P2_3 = 0; P2_2 = 1; break; case 8: P2_4 = 0; P2_3 = 0; P2_2 = 0; break; } P0 = NixieTable[Number]; } void main() { Nixie(7, 2); while(1) { } } 在点亮某位数码管后，因为切换的太快会产生错位重影，所以每次都要将P0归零来消影，在极快的速度下依次显示123，视觉上得到同时亮起的123，这就是动态数码管显示 #include &lt;REGX52.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26e0a33c462e44ba380212b5fa0db3dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f970dcb0812179d433bd84ca04cc79e5/" rel="bookmark">
			初学者必看！PLC转型C#上位机编程学习路线和方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.通过线上学习C#，机器视觉，运动控制卡，工程案例，我迈向工控软件开发的转型之路
大家好，我是华山编程培训中心的学员——李工，今天分享下我是如何从电气工程师成功转型上位机开发的经历，希望我的经历能鼓舞更多的自动化工程师往上位机发展。
在锂电行业从事电气工程师工作一年多，我渴望在C#上位机运动控制和视觉软件开发方向发展。通过X音、X度等网络平台，我发现了华山编程培训中心朱老师的工控行业C#,机器视觉，运动控制卡，工程案例全套学习课程，决定报名参加。
在2023年初，我完成了这门线上课程的学习，为我的工控软件开发之路奠定了基础。
线上学习方法： 为了在学习过程中获得最佳的经济效益，我选择了线上和线下相结合的学习方案。为了更好地同时观看视频和编写代码，我购买了一个价格适中的液晶显示器，作为笔记本的副屏。硬件问题得以解决后，我采取了以下学习方法：
1.按照C#、固高运动控制卡、雷赛运动控制卡、视觉（Halcon）、工程实例的顺序进行学习。
2.对于每个内容节点，我先观看视频，然后做笔记并编写相关代码，以便更好地理解和吸收内容。
3.进行代码调试时，遇到问题我会向老师请教，并详细记录问题点以及解决问题的思路和方法（通过一对一的技术辅导群进行交流）。通过这种不断积累的过程，我逐渐实现了由量变到质变的学习进步。
我清楚地认识到，C#作为上位机软件开发的基础知识至关重要。因此，在学习过程中，我充分利用自己的热情，尽可能多地吸收课程内容。通过聆听、观看、记录笔记和验证代码的过程，我能够对每个知识点有更深入的理解和消化能力，从而达到更好的学习效果。即使在以后对某些知识点变得生疏时，我可以通过查看笔记快速复习。
尽管这种学习方法需要投入大量时间和精力，但它被证明是最有效的。只有在基础知识足够丰富的基础上，我才能更轻松地理解和消化后续的内容。因此，对于一个小时的视频，我可能需要花费两个多小时的时间来进行学习和实践。只有通过付出足够的时间和精力，我才能达到甚至超过自己预期的学习效果。
二.从线上到线下学习：我选择踏入全职学习的新阶段
导言： 在线上学习C#的过程中，我意识到自己的本职工作压力和加班频繁使得无法专心学习，无法达到预期的效果。因此，我决定转向线下学习模式，并向原公司提交辞呈，迈入全职学习的新阶段。
以下是我转向线下学习的决策理由和好处。
1.全职学习：转向线下学习模式让我能够摆脱工作压力，全心投入学习，提高学习效果。
2.热爱和激情：我对上位机软件开发充满热爱和激情，相信能够保质保量地完成线下课程学习。
3.全日制上课：线下学习采用上午上课、下午进行视频学习的模式，给予我更大的发挥空间。我可以提前预习课程内容，让自己在老师上课之前就有一定的理解和消化，并能更好地参与课堂互动。
4.老师指导：线下学习中，老师将亲自指导我们，随时解答我们遇到的问题，提供及时的帮助和指导。
5.同学交流：与同班同学进行交流学习，创造良好的学习氛围，相互促进和激励。
6.优越硬件条件：线下学习提供了运动控制卡、相机、工控机等良好的硬件条件，可以进行实物验证等实践操作。
7.实际项目经验：朱老师提供适合的项目，我们有机会参与软件开发，积累实际项目经验。
综合考虑，我决定转向线下学习，并向原公司提交辞呈，为自己全心投入学习做好准备。这个决策将使我能够更好地专注于学习，迅速提升我的技能水平，为未来在工控软件开发领域取得更大的成功奠定基础。我期待着与朱老师和同班同学们一起，共同探索学习的道路，并为自己的梦想努力前行。
三.全情投入，坚定信念：线下学习C#上位机课程的实践之路
导言： 我在深圳华山编程培训中心开始了为期两个多月的C#上位机线下课程学习，带着坚定的信念和对知识的渴望，我决心在有限的时间内尽可能多地学习知识，将时间、精力和资金的投入发挥到最好的效果。在学习的过程中，我采用了一系列的学习方法和策略，始终将学习视作自己的责任。
学习方法和策略：
1.走在老师前面：提前对课程知识进行自我理解和消化，对不了解的知识点做好笔记。在课堂上遇到问题时，积极请教老师并寻找解决方法，进一步理解和消化知识。
2.认真听讲：在课堂上，我认真听讲，并将主要的知识点做好笔记。课后将预习的笔记和课堂笔记进行融合，以更好地理解和消化本章节的知识点。
3.自我经历问题：在预习过程中，我亲身经历了很多问题。通过自己的努力，我解决了这些问题，对知识点的理解更加深刻。同时，这也避免了在课堂上跟不上老师的节奏的情况。
4.硬件熟悉：提前熟悉教室中的所有硬件设备，有助于在学习硬件方面的知识时更加顺利。
5.帮助同学解决问题：走在老师和同学们的前面，不仅解决了自己的问题，还可以帮助同学解决他们的问题。这既提高了自己解决问题的能力，也得到了同学和老师的认可，激发了更大的学习激情。
6.全身心投入：我每天早出晚归，抽出尽可能多的时间来学习，全身心地投入其中，专心致志地学习。有时甚至连周末也不例外。
各个模块的重要知识点：
1.C#：重点学习线程和任务、数据库操作等基本知识和操作。
2.运动控制：学会阅读手册，封装Axis类、motor抽象类，应用多线程进行学习。
3.机器视觉：学习Halcon图像处理的算子和操作步骤，将Halcon程序转化为C#程序并实现功能。
4.工程案例：将C#、运动控制和视觉综合运用于实际工程案例中。学习使用SDK采集图像、进行模板匹配、坐标修正、自动流程逻辑和书写、实时运行轨迹绘制、历史报警记录、软件加密、软件期限管理等技术。通过多线程的方式将这些知识点融会贯通，达到较好的效果。
自我成长的关键： 在学习过程中，自我成长的关键在于坚定的信念和意志力。必须设定明确的学习目标并坚持执行，选择适合自己的学习方法，并愿意为之付出努力。学习是一项艰苦的过程，但经过一段时间的努力，成果将会显现。当我们感受到进步带来的快乐时，就会更加激发学习的激情和自信心，继续努力学习下去。
信念的重要性： 在学习和掌握技术的道路上，自己必须拥有坚定的信念。就像中国志愿军在朝鲜战争中，面对强大的敌人，凭借着钢铁般的意志坚持斗争一样，我们也要在工控领域的学习中具备这样的信念和决心。学习技术是为了自己的成长和未来的发展，无论其他人是否能够夺走我们的知识，我们都要努力学习。我们来到华山编程培训中心，学习C#上位机软件开发，最终目的是为了从事C#软件开发，获得更好的待遇和工作环境。我们必须在有限的时间内，尽可能多地、扎实地、快速地提升自己在C#软件开发领域的技术水平。
结语： 在C#上位机线下学习的实践中，我坚持全情投入，按照自己制定的学习方法和策略进行学习。通过掌握C#、运动控制和视觉等重要知识点，我努力提升自己的技术水平。在这个过程中，自我成长的关键是坚定的信念和意志力，只有坚持不懈地，努力学习，才能取得技术上的突破和进步。通过每天早出晚归的付出，我不仅充分利用了有限的时间，还获得了教室的钥匙，让我更加自由地学习。这种全身心的投入和不懈努力，使我更加专注和有动力去面对学习的挑战。
然而，学习不仅仅是在课堂上进行的，它需要我们不断地与实践相结合。在工程案例的学习中，我将所学的C#、运动控制和视觉知识综合运用，通过多线程的方式将各个模块的技术融会贯通。这样的实践让我更加深入地理解和掌握所学的知识，并提升了解决实际问题的能力。
四.学完找工作
完成培训后，你开始准备找工作。朱老师在培训结束后帮助你编写简历，并提供面试指导。每次面试后，你可以向朱老师请教面试问题，并得到专业的建议和反馈。如果你没有找到理想的工作，朱老师会不断推荐适合你的工作机会，直到你找到满意的职位为止。
、
此外，朱老师还会在课程结束后，根据学生的兴趣讲解一些C#知识，例如委托、事件注册、特征和序列化、MES数据传输等。通过朱老师的指导和工作推荐，你将能够快速找到满意的工作机会。
点击领取上位机编程全套入门教程+工具https://s.pdb2.com/pages/20230307/CnORDNt9HimMjNS.html
一旦进入新的工作岗位，你将全力以赴地投入工作，并进入项目实践阶段。通过不断努力和积累经验，经过一年半载的时间，你的技术水平和工作经验将得到提升，使你在任何地方的薪资都不会低于15K。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09d7e9dec1859dc12862027e9b7c271c/" rel="bookmark">
			C语言--break，continue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		break：结束循环
continue：结束本次循环
break：
在全系1000个学生当中，征集慈善募捐，当总数达到10w元时结束，统计此时捐款人数，以及平均每人捐款的数目。
#include &lt;stdio.h&gt; int main() { int money = 0; int people = 1; int sumMoney = 0; for (;people &lt;= 1000;people++){ printf("请输入捐款的数目：\n"); scanf("%d",&amp;money); sumMoney = sumMoney + money; if(sumMoney &gt;= 100000){ printf("捐款总数已到10万"); break; } } printf("捐款的人数为：%d\n",people); printf("平均每人捐款 %.2f 元 \n",(float)sumMoney/people); return 0; } continue：
输出100-200间不能被3整除的数
#include &lt;stdio.h&gt; int main() { int a; int b = 3; for (a = 100;a &lt;= 200;a++){ if(a / b == 0){ continue; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09d7e9dec1859dc12862027e9b7c271c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a84f42131d7ab44b26845594a8e28ab/" rel="bookmark">
			Vue3 – 高级语法补充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Vue中自定义指令
2 Vue内置组件Teleport
3 Vue内置组件Suspense
4 Vue中安装插件的方式
5 Vue中渲染函数的使用
6 Vue中编写jsx的语法
Vue中自定义指令 自定义指令的绑定方法有两种，一种是局部的，一种是全局的。
指令可以将部分js代码转换成指令的方式来使用，js功能的代码可以分成直接在单独页面设置使用，还可以抽取成hooks函数调用。下面这个js代码的功能是进入这个页面的时候马上获取输入框焦点。
直接在页面创建的方法：
&lt;template&gt; &lt;div class="app"&gt; &lt;!-- &lt;input type="text" ref="inputRef"&gt; --&gt; &lt;input type="text" v-focus&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; import { ref, onMounted } from 'vue'; function useInput() { const inputRef = ref() onMounted(() =&gt; { inputRef.value?.focus() }) } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 抽取成hooks：放在了./hooks/useInput里面
import { ref, onMounted } from 'vue'; export default function useInput() { const inputRef = ref() onMounted(() =&gt; { inputRef.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a84f42131d7ab44b26845594a8e28ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/247be8553a54b90b2dbcd7c05668e23c/" rel="bookmark">
			MySQL 优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、服务器配置优化 1. 增加内存容量 内存容量是影响MySQL性能的重要因素之一。在MySQL中，有一个名为“缓冲池”的内存区域，用于缓存数据和索引。如果缓冲池太小，MySQL将频繁地从磁盘中读取数据，从而导致性能下降。因此，增加内存容量可以提高缓冲池的大小，从而提高MySQL的性能。
2、使用SSD硬盘 即固态硬盘 传统的机械硬盘的读写速度较慢，在高并发的情况下容易成为MySQL性能的瓶颈。使用SSD硬盘可以显著提高MySQL的性能。SSD硬盘的读写速度较快，可以减少磁盘I/O操作的时间，从而提高MySQL的响应速度。
3. 增加CPU数量 CPU是MySQL性能的另一个重要因素。如果CPU数量不足，可能会导致MySQL的性能下降。因此，增加CPU数量可以提高MySQL的性能。当然，CPU的性能也很重要，因此选择高性能的CPU也可以提高MySQL的性能。
4. 配置RAID RAID是一种数据存储技术，可以将多个硬盘组合成一个逻辑卷。RAID可以提高数据的可靠性和读写速度。在MySQL中，使用RAID可以将数据和索引分布在多个硬盘上，从而提高MySQL的性能。
5. 配置缓存 cached 优化MySQL硬件配置可以显著提高数据库的性能。通过增加内存容量、使用SSD硬盘、增加CPU数量、配置RAID和缓存等方法，可以提高MySQL的响应速度和吞吐量，从而提高应用程序的性能。
二、软件配置 包括MySQL的参数设置和调整，如缓存大小、连接数、并发处理数等，以适应不同的负载和访问模式。
设置参数的三种方式 （1）set [session] 参数名 = 参数值; 设置当前会话(连接)参数（回话断开，配置失效）
（2）set global 参数名 = 参数值; 设置全局参数（MySQL实例重启，配置失效）
（3）设置应用配置文件，每次启动MySQL实例时加载配置
Window 存放到将my.ini应用程序安装的根目录
Linux保存在/etc/my.cnf
注意：命令的优先级比配置文件高，相同配置命令执行后会覆盖配置值，但是只是在会话或MySQL实例中生效，不同步到配置文件中。 1、max_connections：指MySql的最大连接数 如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，当然这建立在机器能支撑的情况下，因为如果连接数越多，介于MySQL会为每个连接提供连接缓冲区，就会开销越多的内存，所以要适当调整该值，不能盲目提高设值。
如果max_used_connections跟max_connections相同,那么就是max_connections设置过低或者超过服务器的负载上限了，低于10%则设置过大.
查看MySql的最大连接数： mysql&gt; show variables like 'max_connections'; +-----------------+-------+ | Variable_name | Value | +-----------------+-------+ | max_connections | 151 | +-----------------+-------+ 查看当前连接数： mysql&gt; show status like 'Max_used_connections'; +----------------------+-------+ | Variable_name | Value | +----------------------+-------+ | Max_used_connections | 4 | +----------------------+-------+ 修改最大连接数： #临时修改为最大连接数为1024个 mysql&gt; set global max_connections=1024; #永久修改为最大连接数为1024个 [root@mysql ~]# vim /usr/local/mysql/conf/my.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/247be8553a54b90b2dbcd7c05668e23c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93425accc47d31a20eb82f33626a42b2/" rel="bookmark">
			再次解释Spring中一个bean的注入过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. 前置知识学习Spring中对bean的分类1. BeanDefinition2. BeanFactoryPostProcess3. BeanDefinitionRegistryPostProcessor4. BeanPostProcessors 后置处理器5. Aware 接口6. BeanFactory 与 ApplicationContext有什么区别7. BeanFactory 与 FactoryBean 有什么区别8. 重点:预习Spring中创建不同类型bean的先后顺序 二. 由SpringBoot启动run()源码引出ApplicationContext上线文的创建与基于注解的BeanDefinition读取器AnnotatedBeanDefinitionReader和基于ClassPath路径下的BeanDefinition扫描器ClassPathBeanDefinitionScanner1. AnnotatedBeanDefinitionReader引出一系列BeanFactoryPostProcessor,BeanPostProcessor的注册2. ClassPathBeanDefinitionScanner扫描beanfindCandidateComponents()将扫描到的class转换为转换为BeanDefinitionregisterBeanDefinition() 注册 BeanDefinition 到 BeanFactory 中 三. refresh()方法执行到BeanFactory的创建---&gt;BeanFactoryPostProcessor---&gt;BeanPostProcessor---&gt;其它单利bean的创建1. refresh()创建bean工厂,加载并实例化bean方法概述2. refresh---&gt;obtainFreshBeanFactory() bean工厂BeanFactory或BeanDefinitionRegistry与BeanDefinition xml解析器 XmlBeanDefinitionReade相关3. refresh()---&gt;invokeBeanFactoryPostProcessors() bean工厂后置处理器BeanFactoryPostProcessor的创建与执行4. refresh()---&gt;registerBeanPostProcessors() bean后置处理器的创建5. refresh()---&gt;initApplicationEventMulticaster() 初始化事件派发器,多播器6. refresh()---&gt; this.onRefresh() 用来初始化子容器中的bean,默认是空方法7. refresh()---&gt;this.registerListeners() 注册监听器8. refresh()---&gt;finishBeanFactoryInitialization()与beanFactory.getBean()引出bean的创建,是怎么由BeanDefinition实例化为bean的9. refresh()---&gt;this.finishRefresh() 完成ben的创建初始化工作,完成 IOC 容器的创建,发布容器刷新完成事件10. 概述 Spring 启动refresh()方法执行bean的状态流转过程11. Bean的生产顺序是由什么决定的,BeanDefinition的注册顺序是由什么决定的12. 怎么给Spring做扩展Spring IOC过程中有哪些扩展点如何在所有BeanDefinition注册完成后做扩展如何在所有的bean创建完成后做扩展 四. 其它问题总结1. BeanDefinitionRegistry的注册2. Spring 实例化bean有几种方式3. Spring有哪几种配置方式4. bean的配置方式5. @ComponentScan不设置basePackage为什么也会包扫描6. javaConfig如何代替spring.xml的7. @Component,@Controller,@Repository,@Service有什么区别8. @Import有几种使用方式9. @Configuration的作用及原理解析10. @Bean修饰的方法的调用是怎么保证单例的11. 如何将一个三方的类配置为Bean12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93425accc47d31a20eb82f33626a42b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d315d0493a0d510cb008145498b6a73/" rel="bookmark">
			vue跳转页面常用的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. router-link跳转 1.不带参数 &lt;router-link :to="{name:'home'}"&gt; &lt;router-link :to="{path:'/home'}"&gt; //name,path都行, 建议用name // 注意：router-link中链接如果是'/'开始就是从根路由开始；如果不带'/'，则从当前路由开始。 2.带params参数 &lt;router-link :to="{name:'home', params: {id:10001}}"&gt; // params传参数 (类似post) // 路由配置 path: "/home/:id" 或者 path: "/home:id" // 不配置path ,第一次可请求,刷新页面id会消失；配置path,刷新页面id会保留。 // html 取参 $route.params.id script 取参 this.$route.params.id 3.带query参数 &lt;router-link :to="{name:'home', query: {id:10001}}"&gt; // query传参数 (类似get,url后面会显示参数) // 路由可不配置 // html 取参 $route.query.id script 取参 this.$route.query.id 2. this.$router.push() 1. 不带参数 this.$router.push('/home') this.$router.push({name:'home'}) this.$router.push({path:'/home'}) 2. query传参 this.$router.push({name:'home',query: {id:'10001'}}) this.$router.push({path:'/home',query: {id:'10001'}}) // html 取参 $route.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d315d0493a0d510cb008145498b6a73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5ff0c6c5043d8591c51a61db100f077/" rel="bookmark">
			ElasticSearch跨集群离线同步实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ElasticSearch跨集群离线同步实战 需求 有个ES集群,每天按日期生成一批索引,需要定时同步到另一个集群。目前有两种同步方式:
reIndex快照 1. reIndex方式 reIndex方式无需安装任何插件,目标集群只需简单配置。100万条数据大约1分钟内同步完成。
1.1 前置条件 在目标集群的elasticsearch.yml配置文件中设置源集群的白名单:
reindex.remote.whitelist: "&lt;es_ip&gt;:9022" 1.2 同步实践 使用reindex API进行同步:
POST _reindex?slices=auto { "source": { "remote": { "host": "http://&lt;es_ip&gt;:9022" }, "index": "test_data", "size": 10000 }, "dest": { "index": "test_data_from_reindex" } } size:默认1000条,这里设置为10000条,加快同步速度。
slices:按分片数自动切分任务,提高并行度。
1.3 实际应用 利用脚本查询需要同步的索引列表逐个调用reindex API同步对应索引使用crontab执行定时同步任务 2. 快照方式 快照方式需要安装NFS或其他共享存储。同步极快,100万数据约1秒完成。
2.1 前置条件 集群安装NFS,确保源和目标集群可以访问
源集群和目标集群在elasticsearch.yml中配置共享快照库路径:
path.repo: ["/data/share/"] 源集群重启后注册快照库:
PUT /_snapshot/my_backup { "type": "fs", "settings": { "location": "/data/share", "max_snapshot_bytes_per_sec": "50mb", "max_restore_bytes_per_ser": "50mb" } } 2.2 备份快照 源集群执行备份命令:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5ff0c6c5043d8591c51a61db100f077/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e5f63f49e5a6085bd69b3cb34815e8c/" rel="bookmark">
			GTSAM的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装包 安装链接: link
注意事项 一定要在home下面的文件夹下安装，如果在自己的电脑连接的固态硬盘上安装，就会报错，会遇到权限不足的错误，就算用sudo，或者切换到root账户下面，仍然会报权限不足的问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa06b403a38e645cd992d2ce2e438eee/" rel="bookmark">
			移动端H5实现拍照功能的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		移动端H5实现拍照功能的两种方法
下面是实现移动端 H5 拍照功能的几种方法：
1、使用 &lt;input type="file"&gt; 通过 HTML5 规范中的 &lt;input type="file"&gt; 调用系统摄像头，并选择拍摄的照片。但这种方式可能会导致页面刷新。
实现移动端 H5 拍照功能的代码：
1，在 HTML 中创建一个 &lt;input type="file"&gt;：
1
&lt;input type="file" accept="image/*" capture="camera"&gt;
2，在 JavaScript 中为该元素绑定 change 事件，并读取选择的图片文件：
1
2
3
4
5
6
7
8
9
10
var input = document.querySelector("input[type=file]");
input.addEventListener("change", function(e) {
var file = e.target.files[0];
var reader = new FileReader();
reader.onload = function(e) {
var dataURL = e.target.result;
// 在此处对 dataURL 进行操作，例如显示图片
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa06b403a38e645cd992d2ce2e438eee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dfe6915a25fac73ac34d4ff14513c77/" rel="bookmark">
			ESP32（MicroPython） 串口控制五自由度机械臂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本程序使用PCA9685作为舵机驱动，库文件可在adafruit/micropython-adafruit-pca9685: Micropython driver for 16-channel, 12-bit PWM chip the pca9685 (github.com)下载。输入数值时一次输入5个舵机的角度，每个舵机的角度占3位，适合作为下位机程序。
代码如下
import time from machine import SoftI2C,Pin from servo import Servos i2c=SoftI2C(sda=Pin(26),scl=Pin(27),freq=10000) servos=Servos(i2c,address=0x40) servos.position(0,90) servos.position(1,90) servos.position(2,90) servos.position(3,90) servos.position(4,90) #while循环下面操作 while True: try: receive=int(input('input')) #从前到后输入5个舵机的角度，每个舵机的角度占3位 a=receive//1000000000000 servos.position(0,a) b=receive%1000000000000 b=b//1000000000 servos.position(1,b) c=receive%1000000000 c=c//1000000 servos.position(2,c) d=receive%1000000 d=d//1000 servos.position(3,d) e=receive%1000 servos.position(4,e) except: pass 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05f2ca4bd6286f0447cd1b2bc107e25d/" rel="bookmark">
			微信小程序获取手机号详细过程（新版本2.21.2）（旧版本兼容）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序获取手机号最新方法 新版本2.21.2以后获取微信小程序手机号老版本兼容获取手机号 新版本2.21.2以后获取微信小程序手机号 首先你要确保自己的基础库版本是2.21.2，我选择的是当前最新的
在button的文档描述
在代码开始前给大家讲讲注意事项（不需要直接往下看）
然后接下来是项目代码
WXML
&lt;button open-type="getPhoneNumber" bindgetphonenumber="getPhoneNumber"&gt;获取手机号&lt;/button&gt; 样式的话自己按需要设置
通过微信小程序官方api获得回调内容
已经会出现这个页面了
注意如果是个人小程序是不会出现回调的，但是依旧会弹出这个允许拒绝页面下面是回调内容
长这个样子
JS
//点击获取手机号码按钮 getPhoneNumber(e) { wx.request({ url: 'url', data:{ code:e.detail.code, }, success: (res)=&gt;{ this.setData({ mobilePhone: res.data.purePhoneNumber, }) } }) }, 不需要做wx.login的处理，只需要将code传给后端即可
老版本兼容获取手机号 WXML
&lt;button open-type="getPhoneNumber" bindgetphonenumber="getPhoneNumber"&gt;获取手机号&lt;/button&gt; 首先我们需要调用wx.login获取到code码
用于调用后端接口获取session_key
JS
//获取js_code wx.login({ success (res) { console.log(res.code); } }) wx.login一般用于onshow或者onload的生命周期里面，因为如果放在调用函数里面，获取手机号的过程会有稍稍顿挫的缓慢感，所以需要提前调用wx.login，你也可以放在app.js里面的onlanuch
sessionkey的有效期是三天，我们需要后端接口去获取，提交code给后端，返回sessionkey
onLoad(options) { wx.login({ success: (res) =&gt; { wx.request({ url: '后端提供api url', data: { code: res.code }, success: function (res) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05f2ca4bd6286f0447cd1b2bc107e25d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0785e1f6ef3ec0f43fd12a721b43e55f/" rel="bookmark">
			JVM源码剖析之-Xms和-Xmx参数最小的设置值是多少
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM是一个运行在操作系统上的虚拟机。因为是一台虚拟的机器，所以对于内存肯定是可以控制的，恰好JVM提供了众多个参数控制内部运行时，而Xms和Xmx两个参数是用来控制Java堆内存的最小内存和最大内存。可能不少读者会好奇Xms和Xmx两个参数能够设置的最小值是多少，所以笔者借助源码来简单论述～
答案先放在这里
JDK8
-Xms &gt;= 1MB
-Xmx &gt;= -Xms
JDK12
-Xms &gt;= 1MB
-Xmx &gt;= 2MB
版本信息：
jdk版本：jdk8u40 jdk版本：jdk12u JDK8版本源码 为什么会写两个JDK版本呢，因为笔者认为JDK8版本写的很乱，逻辑很差，而在JDK12版本及时改正。
因为Xms和Xmx是两个JVM参数，所以第一步需要看到JVM如何解析参数。/src/share/vm/runtime/arguments.cpp 文件中
// -Xms else if (match_option(option, "-Xms", &amp;tail)) { julong long_initial_heap_size = 0; // 解析-Xms参数 // 不能小于0 // 如果等于0，代表交给JVM自动分配 ArgsRange errcode = parse_memory_size(tail, &amp;long_initial_heap_size, 0); // 设置最小大小 set_min_heap_size((uintx)long_initial_heap_size); // 如果没有设置-XX:InitialHeapSize参数的话，堆的初始值就为最小值。 // 相反，如果设置了-XX:InitialHeapSize参数的话，堆的初始值就发生改变。 FLAG_SET_CMDLINE(uintx, InitialHeapSize, (uintx)long_initial_heap_size); // -Xmx } else if (match_option(option, "-Xmx", &amp;tail) || match_option(option, "-XX:MaxHeapSize=", &amp;tail)) { julong long_max_heap_size = 0; // 解析-Xmx参数 // 不能小于1，当然，这里可以理解为仅仅是解析出用户设置的大小。 ArgsRange errcode = parse_memory_size(tail, &amp;long_max_heap_size, 1); FLAG_SET_CMDLINE(uintx, MaxHeapSize, (uintx)long_max_heap_size); } 代码非常的简单，解析参数，然后设置参数，而解析参数都是调用的parse_memory_size方法，所以略微的看一下解析过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0785e1f6ef3ec0f43fd12a721b43e55f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fc41785e827518858cdcea8c8efd0e0/" rel="bookmark">
			vue3和gin框架实现简单的断点续传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3和gin框架实现简单的断点续传 前端代码 Test.vue &lt;template&gt; &lt;div&gt; &lt;input type="file" ref="uploadRef" @change="upload" multiple /&gt; &lt;template v-for="item in fileList" :key="item.key" &gt; &lt;br&gt; &lt;button @click="changeStauts(item.key)"&gt;{{item.name}}{{ item.status ? '暂停':'开始' }} {{ ((1 - item.requestFn.length / item.total)*100).toFixed(0) }}%&lt;/button&gt; &lt;/template&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; import { reactive } from "vue"; import axios from "axios"; import "./spark-md5.min.js"; // 触发上传 (1) function upload() { let files = event.target.files; for (let i = 0; i &lt; files.length; i++) { setFileBuffer(files[i], i); } } let fileList = reactive([]); // 创建切片相关信息 (2) function setFileBuffer(file, i) { const reader = new FileReader(); reader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fc41785e827518858cdcea8c8efd0e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34e2201e4af34fe1044487879c5c0a47/" rel="bookmark">
			VMWare安装统信UOS虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单击 创建新的虚拟机 按钮，然后选择 自定义， 然后 下一步
硬件兼容性 选择 Workstation16.x ，然后 下一步
选择“稍后安装操作系统”， 然后 下一步 选择 Linux ， 再选 版本 CentOS 8 64位/ Ubuntu 均可，然后 下一步
修改名称、位置（最好不要安装到C盘）建议改为D、E盘，然后 下一步
修改处理器数量，如图，然后 下一步
修改内存为2048MB，然后 下一步
网络类型默认，不用修改，然后 下一步
I/O控制器 默认即可，不用修改，然后 下一步
磁盘类型 默认即可，不用修改，然后 下一步
（Ubuntu默认类型为SCSI，CentOS默认为NVME 二者均可）
选择磁盘 默认即可，不用修改，然后 下一步
磁盘容量，修改为64G（建议容量设置为64G及以上，后续可支持系统全盘安装）然后 下一步
指定磁盘文件 默认即可，不用修改，然后 下一步
单击 完成 统信系统安装步骤就没啥好说的了，直接下一步 下一步
傻瓜操作就行
想自定义分区就手动安装。
不会分区啥的就直接全盘安装。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb95e4cea8c685e8bee2d41de8d2e3dc/" rel="bookmark">
			CTFShow-WEB入门篇文件上传详细Wp(151-170)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WEB入门篇--命令执行详细Wp 文件上传：Web151：Web152：Web153：Web154：Web155：Web156：Web157：Web158：Web159：Web160：Web161：Web162：Web167：Web169：Web170： CTFShow 平台：https://ctf.show/
文件上传： Web151： 考点：前端绕过
F12修改源代码 exts后面png改为php 这样就可以上传php的文件了，然后蚁剑直接连接
可以使用插件进行post获取flag。
ctfshow{ec07a689-3422-439f-aeda-25e174588e7e}
Web152： 考点：后端不能单一校验
就是要传图片格式，抓个包传个png的图片 然后bp抓包修改php后缀解析 然后放包 显示上传成功 蚁剑连即可。
ctfshow{3129d70b-491d-411e-811f-b2eafca203c9}
Web153： 考点：后端不能单一校验（黑名单绕过）
.htaccess在绕过文件上传的限制中，通常在 Apache 全局配置文件 httpd.conf 中
有这样一条配置：AddType application/x-httpd-php .php .phtml或者
SetHandler application/x-httpd-php 将所有文件都解析为 php 文件
这里我们尝试.htaccess（因为它只适用于Apache）所以不行，这里要使用.user.ini
php.ini 是 php 的一个全局配置文件，对整个 web 服务起作用；而.user.ini 和.htaccess 一样是目录的配置文件，.user.ini 就是用户自定义的一个 php.ini，通常用这个文件来构造后门和隐藏后门。
这里先上传一个内容为：auto_prepend_file=1.png得png，然后在正常传一个带图片得一句话木马即可。
这里如果不懂可以参考：.htaccess 和.user.ini 配置文件妙用
ctfshow{dcea4490-2c26-45a6-8027-3c19c8467554}
Web154： 考点：php关键字过滤
这里方法和上面一样传一个1.png（带一句话木马的文件）然后在上传.user.ini 文件即可
&lt;?=eval($_POST[a]);?&gt;## &lt;?=相当于&lt;?php echo ctfshow{503e93c8-c013-4509-9551-5431a3b5a5ef}
Web155： 这里的方法和上一题一样，ok在做一遍 老样子先上传.user.ini.png 和1.png然后直接访问/upload/index.php/即可。
ctfshow{25d0b333-d5f2-4761-85a0-bed828314b6d}
Web156： 考点：过滤字符[]，[]可以可以使用{}代替。
这里也很简单 段标签的基础上改成{}即可 &lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb95e4cea8c685e8bee2d41de8d2e3dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcfef5e48c1818d0743b4ffd60ad0956/" rel="bookmark">
			Latex常用语法及符号整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在word里的公式打到头秃，遂转向Latex，现在网上的大部分语法和符号整理似乎都不是非常全面，每次需要打开多个网页寻找。因此记录Latex使用过程中的一些常见语法结构及常用的数学符号，便于查阅~ ('&gt;A&lt;')
本文配置环境为MacTex+Texpad，结果示例以截图形式表示。
一、语法结构 1. 文件组织 一个latex的文件语言大概是一堆看上去是酱紫的代码：
%导言区 \documentclass[a4paper,12pt]{article} % documentclass中article 文档适合较短的文章，比如期刊文章和短篇报告。其他文档类型包括 % report（适用于更长的多章节的文档），proc（会议论文集），book 和 beamer。也可设置纸张 % 大小和主要文字大小。 %\usepackage[UTF8]{ctex} 中文加上这一行 %文件部分 \begin{document} ... \end{document} 2. 主题 \title{Lucky day} \author{Khan} %\date{\today} %如果你想使用今天的时间 \date{2022年12月12日} \maketitle 3. 章节 \chapter{...} %report 和 book \section{...} \subsection{...} \subsubsection{...} \paragraph{...} \subparagraph{...} 4. 目录 在章节的基础上可以使用以下代码生成
\pagenumbering{roman} \tableofcontents \newpage \pagenumbering{arabic} 5.字体 一些常用的字体：
%代码最前端加入包 \usepackage{color} \textit{words in italics} %斜体 \textsl{words slanted} %斜体 \textsc{words in smallcaps} %小写单词 \textbf{words in bold} %黑体 \texttt{words in teletype} %电传字 \textsf{sans serif words} %无衬线词 \textrm{roman words} %罗马字 常用字体效果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcfef5e48c1818d0743b4ffd60ad0956/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f8bd498ec6a5728405247bd6e7b8223/" rel="bookmark">
			git 报错The requested URL returned error: 403
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
修改git 配置信息用户名和邮箱（无效）
修改当前项目下的git文件夹中的config（无效）
清除缓存（有效）
优化：每次拉取代码都要输入用户名和密码
今日更换电脑，从云效平台拉取代码报错。
原因：自己的账号和电脑上之前的Git账户有冲突，需清除缓存
修改git 配置信息用户名和邮箱（无效） 主要参考：解决：The requested URL returned error: 403_Data-Mining的博客-CSDN博客
git config --global user.name "zmt" //修改用户名 git config --global user.email "abc@163.com" //修改邮箱 git config --list //查看配置信息 修改当前项目下的git文件夹中的config（无效） 主要参考：Git 报错:The requested URL returned error: 403 – 源码巴士
清除缓存（有效） 主要参考：idea提交代码到gitee报错：The requested URL returned error: 403 - 码农教程
git config --system --unset credential.helper 输入云效平台https用户账号及密码
拉取成功!
优化：每次拉取代码都要输入用户名和密码 主要参考：git pull 时每次都要输入用户名和密码的解决办法_51CTO博客_git pull需要输入用户密码
git config --global credential.helper store 然后你会在你本地生成一个文本，上边记录你的账号和密码。当使用上述的命令配置好之后，再操作一次git pull，然后它会提示你输入账号密码，这一次之后就不需要再次输入密码了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40aa0cebf24f2561a769057f54db50aa/" rel="bookmark">
			目标追踪篇---yolov8_tracking复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 目标追踪篇---yolov8_tracking复现1、下载源代码2、下载权重3、运行代码3.1、运行以下命令：3.2、结果如下3.3、视频结果 目标追踪篇—yolov8_tracking复现 本人的另一篇博客，本博客主要是源代码更新产生的新博客，比较过后两者还是有点差异
目标追踪篇—Yolov5_DeepSort_Pytorch复现
1、下载源代码 mikel-brostrom/yolov8_tracking
克隆代码
git clone --recurse-submodules https://github.com/mikel-brostrom/yolov8_tracking.git # clone recursively cd yolov8_tracking pip install -r requirements.txt # install dependencies 之前可以新建一个python环境
2、下载权重 (1) yolov8n.pt (2) yolov8s-set.pt (3) osnet_x0_25_msmt17.pt
链接: https://pan.baidu.com/s/1PebNdObbNUDho3f0DZRIDA 提取码: fxyv
3、运行代码 3.1、运行以下命令： # 注意--yolo-weights 和 --reid-weights路径，需要修改 python track.py --source yolov8/mp4/streetscope.mp4 --save-vid --visualize --yolo-weights weights/yolov8n.pt --reid-weights weights/osnet_x0_25_msmt17.pt 3.2、结果如下 3.3、视频结果 街景识别
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4677b9ad09f13009a378cd87cdf93cc/" rel="bookmark">
			常用的rsync使用方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发送文件夹并保持文件属性不变
rsync -avr path xxx@192.168.x.x:~/path
关于rsync的说明：
rsync is a file transfer program capable of efficient remote update
via a fast differencing algorithm.
Usage: rsync [OPTION]... SRC [SRC]... DEST
or rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST
or rsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST
or rsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DEST
or rsync [OPTION]... [USER@]HOST:SRC [DEST]
or rsync [OPTION]... [USER@]HOST::SRC [DEST]
or rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]
The ':' usages connect via remote shell, while '::' &amp; 'rsync://' usages connect
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4677b9ad09f13009a378cd87cdf93cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4be147f3f85d43ebb287360f2d85b975/" rel="bookmark">
			java - List 对于 stream 的简单操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		stream 流侧重于数据的计算操作，提供很多对于数据操作的api。 @Data public class User { private Integer id; private String name; private Integer age; private String address; public User(Integer id, String name, Integer age, String address) { this.id = id; this.name = name; this.age = age; this.address = address; } } private static List&lt;User&gt; getUserList() { List&lt;User&gt; userList = new ArrayList&lt;&gt;(); userList.add(new User(1, "张三", 18, "上海")); userList.add(new User(2, "王五", 16, "上海")); userList.add(new User(3, "李四", 20, "上海")); userList.add(new User(4, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4be147f3f85d43ebb287360f2d85b975/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/708cf114eb2b896d34374ef1dd1b87b8/" rel="bookmark">
			防抖、节流、深拷贝事件总线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 认识防抖和节流
2 underscore使用
3 防抖函数实现优化
4 节流函数实现优化
5 深拷贝函数的实现
6 事件总线工具实现
简而言之，防抖就是一直触发事件就一直往后拖延再执行。
节流就是一段时间就执行一次，不管中间你触发多少次。
防抖-认识防抖操作 &lt;body&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;input type="text"&gt; &lt;!-- CDN引入: 网络的js文件 --&gt; &lt;!-- &lt;script src="https://cdn.jsdelivr.net/npm/underscore@1.13.4/underscore-umd-min.js"&gt;&lt;/script&gt; --&gt; &lt;!-- 本地引入: 下载js文件, 并且本地引入 --&gt; &lt;script src="./js/underscore.js"&gt;&lt;/script&gt; &lt;script&gt; // 1.获取input元素 const inputEl = document.querySelector("input") // 2.监听input元素的输入 // let counter = 1 // inputEl.oninput = function() { // console.log(`发送网络请求${counter++}:`, this.value) // } // 3.防抖处理代码 let counter = 1 inputEl.oninput = _.debounce(function() { console.log(`发送网络请求${counter++}:`, this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/708cf114eb2b896d34374ef1dd1b87b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98415e73c2182e915df9e6029c271703/" rel="bookmark">
			分享100多个面向开发人员的免费现代化网站模板，总有一款适合你
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这篇文章中，我们将介绍一些最受欢迎的HTML、React、NextJS和Tailwind CSS模板。使用模板来进行项目开发的一个很大的优势是，你可以避免从头开始创建项目，而是使用模板并进行一些微小的调整以适应你的需求。这样可以节省时间，你可以利用这些时间来增强项目的功能。
此外，借助这些模板，你还可以更快地完成工作。让我们现在开始，不再拖延！
原生HTML、CSS 、JavaScript 模板 HTML5 UP
https://html5up.net/
提供了一系列免费的响应式HTML模板。这些模板都具有现代化的设计风格和优雅的布局，适用于各种类型的网站和项目。每个模板都提供了丰富的功能和定制选项，使你能够轻松地创建出令人印象深刻的网站。
你可以在网站上浏览不同的模板，每个模板都有预览图和详细的描述，展示了它的特色和用途。你可以选择一个你喜欢的模板，并下载相应的文件。下载后，你可以根据自己的需求进行修改和定制，以适应你的项目。
无论你是初学者还是有经验的开发者，这些模板都是一个很好的起点。它们提供了一个快速且可靠的方法，让你在项目中使用现成的设计和布局，并根据需要进行个性化调整。
Free HTML web themes
https://www.graphberry.com/category/free-html-web-templates
这个网站提供了一系列免费的HTML网页模板。这些模板经过精心设计，涵盖了各种不同类型的网页需求，包括企业网站、个人简历、博客、电子商务等。
在该网站上，你可以浏览不同的模板分类，并点击查看每个模板的详细信息和预览图。每个模板都提供了下载链接，你可以免费下载所需的文件。这些模板通常包括HTML、CSS和JavaScript等文件，你可以根据自己的需求进行修改和定制。
这些模板的设计风格各不相同，但都注重美观和用户体验。它们提供了一个快速启动网页项目的方式，让你节省时间和精力，无需从头开始构建网页。你可以根据模板进行一些微调和定制，以满足你的具体需求。
对于那些刚刚开始学习前端开发或者需要快速建立网页项目的人来说，这些免费HTML网页模板是一个很好的资源。它们为你提供了一个基础结构，使你能够快速创建出具有吸引力和功能性的网页。
React +Tailwind 模板 每个需求都有免费的现代化React和Tailwind模板
https://treact.owaiskhan.me/
这个合集真是令人惊叹。在这里，你可以找到用TailwindCSS构建的现代化React UI模板和组件，它们不仅轻量、安装迅速，而且易于适应。所有组件都完全响应式，品牌颜色也可以完全自定义。无论是商业用途还是个人使用，都可以免费使用。
React落地页
这是一个简单的落地页，使用Reactjs构建，包含了产品、特点、价格、关于等几个部分。
https://react-landing-page-template-2021.vercel.app/
Nextjs 模板 4+ 免费的 Nextjs 模板
https://www.creative-tim.com/templates/nextjs
36个免费的 Nextjs 模板
这也是一个不错的Next主题、起始模板和模板合集。
https://jamstackthemes.dev/ssg/next/
10个免费的Nextjs模板
https://www.wrappixel.com/templates/category/nextjs-templates/?product_orderby=freebies
Nextjs 模板集合
https://vercel.com/templates
在这些可用选项中搜索你的模板，以加快应用程序的开发速度。这是来自Vercel的一份精彩的Next.js模板合集。在这里，你可以从各种各样的分类中进行选择。
最佳的免费13+个Tailwind CSS模板 https://www.creative-tim.com/templates/tailwind-free
这个Tailwind CSS模板合集非常棒。它们提供了免费的Tailwind CSS UI套件和管理仪表板。你应该去看看。
免费响应式的Tailwind CSS模板 https://themewagon.com/theme-framework/tailwind-css/
这是一个令人惊叹的资源，你可以在这里找到免费的响应式Tailwind CSS组件。通过查看下载这些模板的人数统计，你可以发现它们拥有顶级的管理仪表板和落地页模板。如果你愿意付费，它们也提供付费选项。
20个以上的免费和付费Tailwind CSS模板 https://tailwindtemplates.co/templates
发现并下载2023年最佳的免费和付费Tailwind CSS模板！无论你需要一个落地页、管理仪表板还是一个完整的网页模板，我们都为你提供了高质量且易于使用的设计。Tailwind CSS是一个广受欢迎的基于实用主义的CSS框架，以其模块化和可伸缩的架构脱颖而出。通过遵循样式的自然顺序，它能够避免传统CSS中的混乱代码。使用Tailwind，你不再需要担心浏览器兼容性或错误，它为你简化了编码和设计过程。通过我们的Tailwind CSS模板，将你的网站提升到新的水平！
Tailwind组件 在你的项目或落地页中使用这些内置的开源Tailwind UI模板和组件，可以节省时间。现有超过600个免费的模板和组件可供使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98415e73c2182e915df9e6029c271703/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f86c295964c75ab1a6b109d796b5d91a/" rel="bookmark">
			Rust 数据类型 之 结构体（Struct）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
结构体（Struct）
定义与声明
结构体定义
结构体实例
结构体分类
单元结构体（Unit Struct）
元组结构体（Tuple Struct）
具名结构体（Named Struct）
结构体嵌套
结构体方法
例1：结构体转换为字符串描述
例2：矩形的周长和面积
例3：结构体字段的更新与输出
关联函数
结构体方法与关联函数的区别
参数传递方式的区别
使用方式的区别
结构体的trait
#[derive(Debug)]
例1：
例2：
自定义打印宏 1. impl fmt::Debug for Student
2. impl fmt::Display for Student
#[derive(PartialEq)]
例1：
例2：
#[derive(Default)]
例1：
例2：
#[derive(Clone)]
其他相关内容
模式匹配
例1：
例2：
结构体大小
1. std::mem::size_of
2. std::mem::size_of_val
本文总结
结构体（Struct） 是一种自定义数据类型，允许将多个相关的值组合在一起，形成一个更复杂的数据结构。结构体被广泛应用于组织和管理数据，具有灵活性和强大的表达能力。
定义与声明 结构体定义 在Rust中，定义和声明结构体的语法如下：
struct Name { field1: Type1, field2: Type2, // ... fieldN: TypeN, } 其中，Name是结构体的名称，每个数据名及其对应的数据类型组成一个字段，field1到fieldN是结构体的字段名称，Type1到TypeN是字段的数据类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f86c295964c75ab1a6b109d796b5d91a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29d7ab977f317fffce954f41bf62f17f/" rel="bookmark">
			【【51单片机的蜂鸣器实现小星星】】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用单片机的蜂鸣，实现简单小星星 我们在设置板子的时候要翻转
翻转IO口是因为使用了步进电机的多余的芯片管脚
我们翻转之后还想让它保持一段时间
就是先翻转500次 Delay(1）之后 就是最小的单位每隔1ms 周期就是2ms 频率就是500HZ
蜂鸣器播放音乐
我们首先在前面到现在必须明白一个道理 就是我们的蜂鸣器发声是因为蜂鸣器的
我们可以不停的反转的电平，而且随着电平翻转频率的变化，它的音调也会变化，依据此原理可以用蜂鸣器来播放音乐。我们可以控制电平的时序，传递合适的周期以便于控制音调的高低。
我们可以这么想 ，就像一个鼓，我们如果不敲动，那么就不会发声。我们必须给他一个扰动 也就是翻转 。就像是我们控制
举例
void Timer0_Routine() interrupt 1 { TL0 = 64580%256; //设置定时初值 TH0 = 64580%256; //设置定时初值 Buzzer=!Buzzer; //蜂鸣器的频率 } 当我们在实现音乐控制的时候还会出现一个问题就是我们的数组前两个数字是一样的那该怎么办
这样听声音就会有一种顿挫感
unsigned char Music[]={12,12,19,19,21,21,19,17,17,16,16,14,14,12}; 例如这是最经典的小星星的一段
我们最好在中间插入一点东西使得能够听出不一样的感觉
FreqSelect=Music[MusicSelect]; MusicSelect++; Delay(500); TR0=0; Delay(5); TR0=1; 做到这里我们会发现还有问题 我们看乐谱的时候就会发现有些音他是延长 而又有些音是两个音的组合成一个
那么在这里我们是否再提供一个数组用来确定
这时候我们想到上面的music 是一维数组的形式 我们可以将其改写为二维数组的形式
but 用一个数组也行 最好是二维更加清晰一点吧
FreqSelect=Music[MusicSelect]; MusicSelect++; Delay(125*Music[MusicSelect]); MusicSelect++; TR0=0; Delay(5); TR0=1; } 另外 我们拿到乐谱并不能很好的取一个基准 有很多16分 8分 4分频 我们按照男人的思维 用数学的逻辑 取最小的记为1 哪个最小就用哪个
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29d7ab977f317fffce954f41bf62f17f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40c834ecb367d9c0dd94a7d986ded52a/" rel="bookmark">
			JVM 运行流程、类加载、垃圾回收
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、JVM 简介 1、JVM JVM 是 Java Virtual Machine 的简称，意为 Java 虚拟机。
虚拟机是指通过软件模拟的具有完整硬件功能的、运行在一个完全隔离的环境中的完整计算机系统。
常见的虚拟机：JVM、VMwave、Virtual Box。
JVM 和其他两个虚拟机的区别：
VMwave 与 VirtualBox 是通过软件模拟物理 CPU 的指令集，物理系统中会有很多的寄存器；JVM 则是通过软件模拟 Java 字节码的指令集，JVM 中只是主要保留了 PC 寄存器，其他的寄存器都进行了裁剪。 JVM 是一台被定制过的现实当中不存在的计算机
每个 jvm 就是一个 java 进程。如果有两个 java 进程，就是两个 jvm 了!!!
为什么要在程序和操作系统中间添加一个 JVM：Java 是一门抽象程度特别高的语言，提供了自动内存管理等一系列的特性。这些特性直接在操作系统上实现是不太可能的，所以就需要 JVM 进行一番转换。
从图中可以看到，有了 JVM 这个抽象层之后，Java 就可以实现跨平台了。JVM 只需要保证能够正确执行 .class 文件，就可以运行在诸如 Linux、Windows、MacOS等平台上了。
Java如何实现跨平台：windows系统，实现了一个windows 版本的JVM，Linux系统,实现了Linux版本的JVM，Mac系统实现了Mac 版本的JVM
随便某个系统，也实现了对应版本的 JVM，跨平台是靠无数个不同版本的 JVM 支持的!! 这些不同的JVM内部封装了，不同系统的API，对上都是执行同样规则的字节码
C, C++,Go, Rust 都是把代码编译成 native code，也就是 cpu 能识别的机器指令，不需要虚拟机。——针对不同系统 / cpu 生成的机器指令是不一样 (编译出来的可执行程序不一样)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40c834ecb367d9c0dd94a7d986ded52a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58590fb855fd6fcb41fd531fe8383ca4/" rel="bookmark">
			Windows下修改Git Bash 默认路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://baijiahao.baidu.com/s?id=1552327395620319&amp;wfr=spider&amp;for=pc
将此行添加到您的.bashrc文件中:
cd C:/xampp/htdocs/;
如果.bashrc文件不存在,请在根文件夹中创建一个.对我来说是:C:\Users\tapas\
保存.bashrc并打开Git Bash.而已!
https://qa.1r1g.com/sf/ask/537002301/
原始配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/946d463ff9d3a6b231ffa74f14a7dd90/" rel="bookmark">
			java 通过Json -schema完成对数据的效验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Json -schema 1.对象的效验2.数组套对象的效验3. 字符串的效验长度效验(minLength)(maxLength)正则效验日期和时间 4.对象套对象效验5.对象套数组6. 其他参数required(必须要填）enum(范围之内）not（不）anyOf 和allOf（双方为真，有一个为真）format 7. $ref 的使用（定义全局枚举） 参考文档 https://json-schema.org/understanding-json-schema/index.html JSON Schema是什么？
根据JSON Schema 规范的定义,JSON模式是一种JSON媒体类型,用于定义JSON数据的结构。JSON模式旨在定义JSON数据的验证、文档、超链接导航和交互控制
首先是添加pom &lt;!-- json格式效验测试--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.everit-org.json-schema&lt;/groupId&gt; &lt;artifactId&gt;org.everit.json.schema&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;20180130&lt;/version&gt; &lt;/dependency&gt; 先从最简单的对象的校验开始先了解其他语法在进一步逐一渗透 1.对象的效验 接口测试这里说一下粗略的流程 1. 首先需要有一个需要进行效验的实体类 2. 通过JSON.toJSONString将其转为实体类 3. getClass().getResourceAsStream是获取到json的配置文件 4. 将其变为new org.json.JSONObjec对象类型的数据， 5. 将我们 上面转为json的实体类变为 new JSONObjec 6. 通过schema.validate（）去进行文件的效验，如果正确返回true,否则直接抛异常 7. 后面就是将异常翻译一下传给前端，让用户知道是哪个格式出错了 import com.alibaba.fastjson.JSON; import com.bj.cy.Service.bradnApiService; import com.bj.cy.enity.brand; import com.bj.cy.utils.CheckAnalysisList; import com.bj.cy.utils.CheckRowVo; import com.bj.cy.utils.nety.test1; import io.swagger.annotations.Api; import io.swagger.annotations.ApiOperation; import lombok.extern.slf4j.Slf4j; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/946d463ff9d3a6b231ffa74f14a7dd90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec91c62b39b3e94e4beecd6c98d3574f/" rel="bookmark">
			libbpf-bootstrap开发指南：socket 监测与过滤 - sockfilter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
代码分析
comm 数据部分
BPF 代码部分
功能说明
rb 结构分析
ip_is_fragment 函数分析
bpf_skb_load_bytes函数分析
GRE协议说明
用户代码部分
功能说明
open_raw_sock&amp; 原始套接字
setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, sizeof(prog_fd))
执行效果
分片与不分片的处理难度说明
代码分析 comm 数据部分 // SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause /* Copyright (c) 2022 Jacky Yin */ #ifndef __SOCKFILTER_H #define __SOCKFILTER_H struct so_event { __be32 src_addr; __be32 dst_addr; union { __be32 ports; __be16 port16[2]; }; __u32 ip_proto; __u32 pkt_type; __u32 ifindex; }; #endif /* __SOCKFILTER_H */ BPF 代码部分 // SPDX-License-Identifier: GPL-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec91c62b39b3e94e4beecd6c98d3574f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d3f1196c283c67573df86bd6ea3218f/" rel="bookmark">
			libbpf-bootstrap开发指南：网络包监测-tc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前置知识
代码分析
BPF部分
功能说明
struct __sk_buff 说明
bpf_htons &amp; bpf_ntohs
为什么有l2 + 1、l3+1
data 数据的排布
用户部分
功能说明
DECLARE_LIBBPF_OPTS
执行效果
前置知识 IP数据包的总长度指的是整个IP数据包的长度，包括IP头部和数据部分的总和，以字节为单位。IP数据包在传输过程中可能会被分片，每个分片都会有自己的IP头部和数据部分，但是所有分片的IP头部的总长度应该是相同的。
生存时间（TTL）是一个8位字段，它表示IP数据包在网络中可以被路由器转发的最大次数。当一个路由器接收到一个IP数据包时，它会将TTL减1，然后将数据包转发到下一个路由器。当TTL的值减少到0时，路由器会丢弃该数据包，并向源主机发送ICMP“生存时间超时”消息。TTL的主要作用是防止IP数据包在网络中不断循环，因为如果数据包被无限转发，它可能会占用网络资源并导致网络拥塞。通过限制数据包的生存时间，TTL可以确保数据包在网络中得到及时处理并在合理的时间内达到目的地。
代码分析 BPF部分 // SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) /* Copyright (c) 2022 Hengqi Chen */ #include &lt;vmlinux.h&gt; #include &lt;bpf/bpf_endian.h&gt; #include &lt;bpf/bpf_helpers.h&gt; #include &lt;bpf/bpf_tracing.h&gt; #define TC_ACT_OK 0 #define ETH_P_IP 0x0800 /* Internet Protocol packet	*/ #define IPPROTO_TCP 6 SEC("tc") int tc_ingress(struct __sk_buff *ctx) { void *data_end = (void *)(__u64)ctx-&gt;data_end; void *data = (void *)(__u64)ctx-&gt;data; struct ethhdr *l2; struct iphdr *l3; struct tcphdr *l4; if (ctx-&gt;protocol !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d3f1196c283c67573df86bd6ea3218f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5a619e5870693517e0df689dc8d668c/" rel="bookmark">
			Zookeeper（Kafka内置）单独添加SASL认证及ACL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这里写自定义目录标题 前言Zookeeper（Kafka内置）单独添加SASL认证及ACL创建zk.jaas文件修改zookeeper.properties修改kafka-run-class.sh修改server.properties重启zk登录zk客户端，设置ACL重启Kafka验证zk的sasl是否配置成功 前言 通常，我们会给Kafka增加SASL以加强对kafka的安全访问，以满足漏扫对于kafka的访问安全漏扫要求。但漏扫的时候也会同样会对Kafka集群中的zk集群进行扫描。所以zk集群同样涉及到要配置kafka的安全认证。
Zookeeper（Kafka内置）单独添加SASL认证及ACL 创建zk.jaas文件 以此路径/opt/soft/kafka/kafka_2.12-2.5.1/config/zk.jaas为例：
Server { org.apache.kafka.common.security.plain.PlainLoginModule required user_super="adminsecret" user_zkclient="12345678"; }; Client { org.apache.kafka.common.security.plain.PlainLoginModule required username="zkclient" password="12345678"; }; 修改zookeeper.properties 增加以下配置
authProvider.1=org.apache.zookeeper.server.auth.SASLAuthenticationProvider requireClientAuthScheme=sasl 修改kafka-run-class.sh 添加以下内容（# Launch mode上一行添加）：
export KAFKA_OPTS="-Djava.security.auth.login.config=/opt/soft/kafka/kafka_2.12-2.5.1/config/zk.jaas" 修改server.properties 增加以下配置
zookeeper.client.sasl=true 重启zk 登录zk客户端，设置ACL 进入bin目录，执行：
./zookeeper-shell.sh &lt;本机IP&gt;:2181 输入：
setAcl / ip:&lt;希望有权限访问的IP&gt;:cdrwa 重启Kafka 验证zk的sasl是否配置成功 使用一台非集群内的zk节点上的zk软件，来模拟入侵。也就说这个节点的ip并没有被设置getAcl
执行zkCli.sh工具连接Zookeeper:
zkCli.sh -server &lt;想要入侵的zk节点ip&gt;:2181 ls / Insufficient permission : 出现“Insufficient permission :”表明没有权限访问。
也可以使用内置的zk命令尝试：
zookeeper-shell.sh &lt;想要入侵的zk节点ip&gt;:2181 ls / Insufficient permission : ```bash 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/112/">«</a>
	<span class="pagination__item pagination__item--current">113/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/114/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>