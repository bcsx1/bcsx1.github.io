<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72f740a073cc1bc84c3e8c1bbf209c1b/" rel="bookmark">
			【3】原型Prototype（创建型）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 用原型实例指定创建对象的种类，并通过复制这些原型创建新的对象；
克隆羊问题，通过 Object 类的 clone 实现实例的复制；
Spring 的 bean 创建，当 bean 类型为原型时，每次都会生成一个 bean，scope=“prototype”；
原型模式的浅拷贝和深拷贝。深拷贝实现方式：序列化，通过文件流实现；重写引用类型的 clone 方法；
优缺点 优点 通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，用 clone 创建对象可以极大的节约时间；
缺点 如果需要对老的类实现拷贝，则需要修改源码，违反了 ocp 原则；
示例 package com.firechou.prototype; import lombok.Data; /** * @Author firechou * @Date 2023/6/2 15:12 * @Version 1.0 * @Description 简历类 */ @Data public class Resume implements Cloneable { // 需要实现Cloneable接口，否则即使实现了clone方法，运行时会报错 /** * 用户名 */ private String userName; /** * 工作经历 */ private WorkExpression workExpression; @Override protected Resume clone() throws CloneNotSupportedException { Resume resume = (Resume)super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72f740a073cc1bc84c3e8c1bbf209c1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f48521ff75ea383a52568cdc5823ad8/" rel="bookmark">
			java freemarker 动态生成excel文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好久木有更新啦
抓住2023的小尾巴
浅浅更新一下吧~
最近做了一个动态生成excel的功能，这里记录下部分功能，主要用到的是freemarker框架，spring就有带，我起的demo载入了一下freemarker的jar包
一、创建模板 首先可以创建一个excel，编辑自己想要的模板，这里举个简单的例子
编写好后可以保存一下，然后再保存为.xml格式的文件，就能得到模板雏形
大概是长这样
然后根据ftl文件的语法，我们可以对模板进行改造，加入自己需要的字段
这里列举一些常见的方式
1、普通字段填充
&lt;Cell ss:StyleID="s17"&gt;&lt;Data ss:Type="String"&gt;姓名&lt;/Data&gt;&lt;/Cell&gt; &lt;Cell ss:StyleID="s17"&gt;&lt;Data ss:Type="String"&gt;${(name)!}&lt;/Data&gt;&lt;/Cell&gt; 2、日期填充，java传入的参数类型为Date
&lt;Cell ss:Index="2" ss:StyleID="s17"&gt;&lt;Data ss:Type="String"&gt;出生年月&lt;/Data&gt;&lt;/Cell&gt; &lt;Cell ss:StyleID="s17"&gt; &lt;#if birth??&gt;&lt;Data ss:Type="String"&gt;${birth?string("yyyy-MM-dd")}&lt;/Data&gt;&lt;/#if&gt; &lt;/Cell&gt; 3、switch case选择用法
&lt;Cell ss:StyleID="s17"&gt;&lt;Data ss:Type="String"&gt;国籍&lt;/Data&gt;&lt;/Cell&gt; &lt;Cell ss:StyleID="s17"&gt; &lt;#if certType??&gt; &lt;#switch certType&gt; &lt;#case "A"&gt; &lt;Data ss:Type="String"&gt;■身份证 □外籍护照 □港澳居民来往内地通行证&lt;/Data&gt; &lt;#break&gt; &lt;#case "B"&gt; &lt;Data ss:Type="String"&gt;□身份证 ■外籍护照 □港澳居民来往内地通行证&lt;/Data&gt; &lt;#break&gt; &lt;#case "C"&gt; &lt;Data ss:Type="String"&gt;□身份证 □外籍护照 ■港澳居民来往内地通行证&lt;/Data&gt; &lt;#break&gt; &lt;#default&gt; &lt;/#switch&gt; &lt;#else&gt; &lt;Data ss:Type="String"&gt;□身份证 □外籍护照 □港澳居民来往内地通行证&lt;/Data&gt; &lt;/#if&gt; &lt;/Cell&gt; 4、数组对象展示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f48521ff75ea383a52568cdc5823ad8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e510e40d097dfdb41198ff5ce3718fbf/" rel="bookmark">
			32阵元 MVDR和DREC DOA估计波束方向图对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		32阵元 MVDR和DREC DOA估计波束方向图对比 一、原理 MVDR原理：https://zhuanlan.zhihu.com/p/457528114
DREC原理（无失真响应特征干扰相消器）：http://radarst.ijournal.cn/html/2019/3/201903018.html
主要参数：
阵元：32个阵元，可以设置。
期望信号：1个，角度、信噪比可以设置。
干扰信号：2个，角度、信噪比可以设置。
二、效果 波束方向图效果：
三、代码 部分代码：
clc; clear all; close all; %% v=2; %波长为2 d =v/2; %阵元间距 N=32; %阵元个数 theta_3db = 2/N*180/pi; %-3db波束宽度 for ix=1:1:N A(ix,1)=(ix-1)*d;%阵元间距向量 end %% 接收信号模型 fs=10; %信号频率 fj1=1; %干扰1频率 fj2=2; %干扰2频率 SNR= -10; %信噪比 JNR1=20; %干噪比1 JNR2=20; %干噪比2 theta_s=10*pi/180; %信号入射方向 theta_j1=20*pi/180; %干扰1，间距大于主瓣宽度 theta_j2=25*pi/180; %干扰2，间距大于主瓣宽度 A0=sqrt(10^(SNR/10)); %信号幅度 A1=sqrt(10^(JNR1/10));%干扰1幅度 A2=sqrt(10^(JNR2/10));%干扰2幅度 for k=1:1:N as(k,1)=exp(j*2*pi*sin(theta_s)*A(k,1)/v); %信号方向导向矢量 aj1(k,1)=exp(j*2*pi*sin(theta_j1)*A(k,1)/v);%干扰1方向导向矢量 aj2(k,1)=exp(j*2*pi*sin(theta_j2)*A(k,1)/v);%干扰2方向导向矢量 end M =1000;%快拍数 t=0:1/(4*fs):(M-1)/(4*fs);%快拍时间 T=length(t);%快拍时间长度 S0=A0*exp(sqrt(-1)*(2*pi*fs*t+pi*rand(1,T))); %构造信号 J1=A1*exp(sqrt(-1)*(2*pi*fj1*t+pi*rand(1,T))); %构造干扰信号1 J2=A2*exp(sqrt(-1)*(2*pi*fj2*t+pi*rand(1,T))); %构造干扰信号2 S=as*S0; %信号乘以信号方向导向矢量 I1=aj1*J1;%干扰1乘以干扰1方向导向矢量 I2=aj2*J2;%干扰2乘以干扰2方向导向矢量 Noise=zeros(N,T);%构造归一化高斯噪声 for k=1:1:N Noise(k,:)=(randn(1,T)+sqrt(-1)*randn(1,T))/sqrt(2); end X=S+I1+I2+Noise; % 叠加两个干扰信号和噪声，得到新的信号X R=X*X'/T; % 干扰和噪声的协方差矩阵 %% 图形绘制 figure(1); Fa=20*log10(abs(F_s).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e510e40d097dfdb41198ff5ce3718fbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8739f9fca207f9c84a753e319eb1f97/" rel="bookmark">
			react 之 美团案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.案例展示 2.环境搭建 克隆项目到本地（内置了基础静态组件和模版） git clone http://git.itcast.cn/heimaqianduan/redux-meituan.git 安装所有依赖 npm i 启动mock服务（内置了json-server） npm run serve 启动前端服务 npm run start 3.分类和商品列表渲染 1.store modules 下 takeaway.js文件
// 编写store import { createSlice } from "@reduxjs/toolkit" import axios from "axios" const foodsStore = createSlice({ name: 'foods', initialState: { // 商品列表 foodsList: [],a }, reducers: { // 更改商品列表 setFoodsList (state, action) { state.foodsList = action.payload } } }) // 异步获取部分 const { setFoodsList} = foodsStore.actions const fetchFoodsList = () =&gt; { return async (dispatch) =&gt; { // 编写异步逻辑 const res = await axios.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8739f9fca207f9c84a753e319eb1f97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/755347c0a3d4136184ac0b2e3b6cf972/" rel="bookmark">
			基于鸿蒙OS开发一个前端应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建JS工程：做鸿蒙应用开发到底学习些啥？ 若首次打开DevEco Studio，请点击Create Project创建工程。如果已经打开了一个工程，请在菜单栏选择File &gt; New &gt; Create Project来创建一个新工程。选择HarmonyOS模板库，选择模板“Empty Ability”，点击Next进行下一步配置。
进入配置工程界面，Compile SDK选择“3.0.0(API 8)”(Compile SDK选择“3.1.0(API 9)”时注意同步选择 Model 为“FA”，此处以选择“3.0.0(API 8)”为例)Language选择“JS”，其他参数保持默认设置即可
说明 DevEco Studio V2.2 Beta1及更高版本支持使用JS低代码开发方式。
低代码开发方式具有丰富的UI界面编辑功能，通过可视化界面开发方式快速构建布局，可有效降低开发者的上手成本并提升开发者构建UI界面的效率。
如需使用低代码开发方式，请打开上图中的Enable Super Visual开关。
点击Finish，工具会自动生成示例代码和相关资源，等待工程创建完成。
entry：HarmonyOS工程模块，编译构建生成一个HAP包。
src &gt; main &gt; js：用于存放js源码。
src &gt; main &gt; js &gt; MainAbility：应用/服务的入口。
src &gt; main &gt; js &gt; MainAbility &gt; i18n：用于配置不同语言场景资源内容，比如应用文本词条、图片路径等资源。
src &gt; main &gt; js &gt; MainAbility &gt; pages：MainAbility包含的页面。
src &gt; main &gt; js &gt; MainAbility &gt; app.js：承载Ability生命周期。
src &gt; main &gt; resources：用于存放应用/服务所用到的资源文件，如图形、多媒体、字符串、布局文件等。关于资源文件的详细说明请参考资源限定与访问。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/755347c0a3d4136184ac0b2e3b6cf972/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08f1f2360ae1fa0fb2dae0ae4abe848d/" rel="bookmark">
			【CISSP学习笔记】5. 安全架构和工程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该知识领域涉及如下考点，具体内容分布于如下各个子章节：
使用安全设计原理来研究、实施与管理工程过程理解安全模型的基本概念（例如 Biba、Star Model、Bell-LaPadula 等模型）基于系统安全要求选择控制措施理解信息系统 (IS) 的安全功能（例如：内存保护、可信赖平台模块 (TPM)、加密/解密）评估并降低安全架构、设计和解决方案方面的漏洞选择和确定加密解决方案理解密码分析攻击方法将安全原理运用到场所与设施的设计上设计场所和设施安全控制措施 5.1. 密码学 5.1.1. 密码学的历史里程碑 5.1.1.1. 凯撒密码 加密消息时将字母表上的每个字母右移三位，所以凯撒密码也称为ROT3（Rotate 3）。例如A变成D，B变成E。
在凯撒密码中，密钥就是字母表平移的位数。所以密钥只有26中（排除0的，只能25种），可以通过暴力破解来破译密文。
散密码虽然使于使用，但Z颇丰起来也轻而易举。面对一种叫作"频率分析"的攻击类型时，它会非常脆弱，英文中使用最频繁的字母是E、T、A、O、N、R、I、 S 和 H。只需要在被加密的文本中找出最常用的字母，然后尝试替换这些常用字母，便可确定文本模式。
5.1.1.2. 美国南北战争 文字替换+移位
替换密码的密钥为替换表。
5.1.1.3. Ultra和Enigma Enigma是一种由键盘、齿轮、电池和灯泡组成的机器，可以完成加密和解密。发送者和接收者都必须使用相同的密钥，因此发送者和接收者会事先收到一份叫国防军密码本的册子。
密钥：每个轮子的旋转位置。
5.1.2. 密码学基本知识 基本术语
P：明文C: 密文K：密钥 5.1.2.1. 目标 保密性完整性身份验证不可否认性：由公钥系统提供。 私密密钥或对称密钥密码系统不可提供不可否认性保障。因为通信双方都知道密钥。
5.1.2.2. 密码数学 逻辑运算
AND(^) 只有在X和Y都为真时，输出值才为真OR(v) X和Y中有一个为真则为真，两个都为假时才为假NOT（~或!）Exclusive OR(⊕) 只有当一个输入值为真时才返回真值，如果两个值都为假或真时，输出值为假。 MOD
单向函数
Nonce 如IV
0知识证明
你向某个第三方证明，你确实知道一个事实，但同时不把这个事实本身披露给该第三方。通常通过口令和其他秘密鉴别符实现。
分割知识
当执行某项操作所要求的信息或权限被分散到多名用户手中时，任何一个人都不会具有足够的权限来破坏环境的安全。这种把职责分离和双人控制融于一个解决方案的做法叫"分割知识"。
N分之M控制 要求操办人总数N中至少要有 M 个操办人同时在场才能执行高安全级任务。因此，八分之三控制要求，在被指派可执行密钥托管恢复任务的8 个操办人中，要有 3 个同时在场才能从密钥托管数据库中提取一个密钥。
代价函数
你可用代价函数或代价因子从耗费成本和/或时间的角度测量破解一个密码系统需要付出的努力，以此来衡量密码系统的强度。对一个加密系统实施一次完整蛮力攻击所需付出的时间和精力，通常是代价函数所代表的内容。
代价函数的大小应该与受保护资产的价值匹配，代价函数只需要略大于该资产的时间值即可。
5.1.2.3. 密码 代码作用于单词和短语，而密码作用于字符和位。
移位密码 通过一种加密算法（通过密钥建立矩阵）重新安排明文消息的字母，形成官方消息。解密时只需要逆向执行加密转换便可恢复原始消息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08f1f2360ae1fa0fb2dae0ae4abe848d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d345a067590c07d369b9bb545c347d83/" rel="bookmark">
			【第十二课】KMP算法(acwing-831 / c&#43;&#43;代码 / 思路 / 视频&#43;博客讲解推荐)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
暴力做法
代码如下 KMP算法
不同的next求法-----视频讲解/博客推荐
视频推荐
博客推荐
课本上的方法-
prefix的方法-
求next数组思路---next数组存放前缀表的方式
s和p匹配思路
代码如下
暴力做法 遍历s主串中每一个元素，如果该元素等于模板串p中的第一个元素，就进入内层遍历模板串p中的每一个字符，看该元素及其后面几个元素是否都与模式串p完全一致。避免起初 i 下标丢失，需要定义几个变量，代替 i 作为下标索引。如果发现有不同的，说明这个起始元素并不是我们想要的答案，执行内层循环的if语句，start是我们判断的标记，如果执行了if语句start赋值为-1，说明不必将原本的start放进答案数组。
由此得出答案。
需要注意定义ans答案数组为vector动态数组，其添加元素直接调用push_back()函数。(问就是我刚开始写错了[点手指]...)
代码如下 #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main() { int n,m; string p,s; cin&gt;&gt;n; cin&gt;&gt;p;//模板串 子串 cin&gt;&gt;m; cin&gt;&gt;s;//模式串 主串 int k=0; int start=-1; vector&lt;int&gt; ans; int v=0; for(int i=0;i&lt;m;i++) { if(s[i]==p[0]){ start=i; k=start; for(int j=0;j&lt;n;j++,k++) { if(s[k]!=p[j]) { k=0; start=-1; break; } } if(start!=-1)ans.push_back(start); } } for(int i=0;i&lt;ans.size();i++) { cout&lt;&lt;ans[i]&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d345a067590c07d369b9bb545c347d83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7c334b2113dd243c4a981bc42f89171/" rel="bookmark">
			vue 面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是 Vue 的 MVVM 模式？它是如何工作的？
答案：MVVM 是 Model-View-ViewModel 的缩写。在 Vue 中，Model 表示数据模型，View 表示 UI 组件，ViewModel 是 Vue 的实例，它连接 View 和 Model。ViewModel 通过数据绑定将 View 和 Model 进行关联，当 Model 发生改变时，ViewModel 会自动更新 View，反之亦然。
Vue 中的 v-if 和 v-show 指令有什么区别？
答案：v-if 和 v-show 都可以根据条件控制元素的显示与隐藏。区别在于 v-if 是动态地创建或销毁元素，当条件为 false 时，元素将从 DOM 中移除；而 v-show 则是通过 CSS 控制元素的显示与隐藏，当条件为 false 时，元素仍然存在于 DOM 中，只是通过 CSS 的 display 属性进行控制。
Vue 中的路由是如何实现的？
答案：Vue 使用 Vue Router 来实现前端路由。Vue Router 是 Vue.js 官方的路由管理器，通过定义路由表和对应的组件，可以实现单页面应用的路由功能。Vue Router 使用了浏览器的 History API 或哈希模式来实现前端路由，并提供了丰富的导航守卫和动态路由等功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7c334b2113dd243c4a981bc42f89171/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a16ab8a717427fc71e5662f05cfbb300/" rel="bookmark">
			WEB 3D技术 three.js 设置环境贴图 高光贴图 场景设置 光照贴图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上文WEB 3D技术 three.js 基础网格材质演示几何体贴图 ao贴图效果我们简单构建了一个贴图和ao贴图的几何体材质
我们接下来 来看一下透明度贴图
我们还是官网搜索 MeshBasicMaterial
然后 是我们的 alphaMap 属性
这里 黑色为完全透明 白色 完全不透明
黑白之间还有灰色 这个灰色的灰值 就是透明度
这里 我们直接用 alphaMap 上贴图
这样 图形就明显有些透明效果了 但是会上面也说了 他会开始转变为黑白灰色
然后 是我们的光照贴图
我们这里加一下
然后 我们图片的光照效果 就会在内部微微的显现出我们设置的 public/background.jpg
然后 我们来看环境贴图
这里 我们需要一个HDR图片
如果没有 可以下载我的资源
HDR格式文件 WEB 3D学习工具
这里 我将它 放入项目的 public目录下
那么 我们需要一个hdrl的加载器
import { RGBELoader } from "three/examples/jsm/loaders/RGBELoader.js"; 然后 找一个位置写入代码
let rgbeloader = new RGBELoader(); rgbeloader.load("./public/page.hdr",(texture) =&gt;{ scene.background = texture; }) 这里 我们函数 向public目录下导入 page.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a16ab8a717427fc71e5662f05cfbb300/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0443ea0423979b382f8ca2ed389b604a/" rel="bookmark">
			Kubernetes快速实战与核心原理剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		K8S 概览 K8S 是什么 K8S 官网文档：https://kubernetes.io/zh/docs/home/
K8S 是 Kubernetes 的全称，源于希腊语，意为“舵手”或“飞行员”。Kubernetes 是用于自动部署、扩缩和管理容器化应用程序的开源系统。 Kubernetes 源自 Google 15 年生产环境的运维经验，同时凝聚了社区的最佳创意和实践。
Docker 作为开源的应用容器引擎，可以把应用程序和其相关依赖打包生成一个 Image 镜像文件，是一个标准的运行环境，提供可持续交付的能力；
Kubernetes 作为开源的容器编排引擎，用来对容器化应用进行自动化部署、扩缩和管理；
K8S 核心特性 服务发现与负载均衡 无需修改你的应用程序即可使用陌生的服务发现机制。
存储编排 自动挂载所选存储系统，包括本地存储。
Secret 和配置管理 部署更新 Secrets 和应用程序的配置时不必重新构建容器镜像，且不必将软件堆栈配置中的秘密信息暴露出来。
批量执行 除了服务之外，Kubernetes 还可以管理你的批处理和 CI 工作负载，在期望时替换掉失效的容器。
水平扩缩 使用一个简单的命令、一个 UI 或基于 CPU 使用情况自动对应用程序进行扩缩。
自动化上线和回滚 Kubernetes 会分步骤地将针对应用或其配置的更改上线，同时监视应用程序运行状况以确保你不会同时终止所有实例。
自动装箱 根据资源需求和其他约束自动放置容器，同时避免影响可用性。
自我修复 重新启动失败的容器，在节点死亡时替换并重新调度容器，杀死不响应用户定义的健康检查的容器。
K8S 核心架构 我们已经知道了 K8S 的核心功能：自动化运维管理多个容器化程序。那么 K8S 怎么做到的呢？这里，我们从宏观架构上来学习 K8S 的设计思想。
K8S 是属于 Master-Worker 架构，即有 Master 节点负责核心的调度、管理和运维，Worker 节点则执行用户的程序。但是在 K8S 中，主节点一般被称为 Master Node ，而从节点则被称为 Worker Node 或者 Node。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0443ea0423979b382f8ca2ed389b604a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/238f488ed6413f9c983e3c8d0c4795a2/" rel="bookmark">
			群晖Synology Office如何多人同时远程编辑同个文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 本教程解决的问题是：1. 本地环境配置2. 制作本地分享链接3. 制作公网访问链接4. 公网ip地址访问您的分享相册5. 制作固定公网访问链接 本教程解决的问题是： 1.Word，PPT，Excel等重要文件存在本地环境，如何在编辑后方便地共享给领导检查？
2.临时需要改方案，同事之间如何线上协作修改文档？
按照本教程方法操作后，达到的效果
可以使用自己编辑的二级域名（相比各种复杂随机链接更加容易分辨用途）或在域名供应商处购买域名将办公文档/文件夹以固定链接的形式分享给同事，且能设置访问密码和公开时间并**配置权限（**只读、编辑 等）。
2 给同事编辑权限后，可以直接使用浏览器访问和编辑并记录编辑历史。
效果如下：
浏览器输入分享链接：
输入分享人给的密码后，进入表格可以几个人一起协作编辑：
举个例子演示一下
如果遇到周末紧急需要改方案，同事都在各家，公网访问这个文档，可以一起讨论修改：
在设备1登陆修改：
在设备2就会立即同步显示：
可以查看编辑日志：
使用群晖生态软件，需要使用群晖系统，点击链接获取群晖虚拟机。
已经拥有群晖nas的朋友们，可直接按照本教程操作！
1. 本地环境配置 打开群晖套件中心：
搜索并安装 群晖 Synology Office 和 **群晖 ** Synology Drive Server：
打开web文件夹：
创建一个文件夹用于分享办公文档：
接下来我们来分享文件：
2. 制作本地分享链接 打开晖 群晖Synology Drive中的表格文件:
复制本地局域网地址如下：
http://192.168.50.178:5000/d/s/vkOQIcnSrN7iO0OOuEjLIh8f33LMcLR8/0NZw-qBxV7Z6iCiOhvjD5nt1Qk8mH8o1-j7EgS69P2Qo
链接的前半部分为nas的局域网ip地址：
http://192.168.50.178:5000
链接的后半部分为此表格文件的路径。
接下来，我们使用cpolar将您的 局域网ip地址映射为公网ip地址 再加上 表格文件的路径组成分享表格文件的的公网ip地址。
右键表格——公开链接——需要密码，设置一个公开分享密码。
此时我们复制公开链接并打开，显示如下：
群晖 Synology Office 还可以上传文件后进行分享和协作更改：
我们上传一个 .xlsx ecxel 文件：
显示上传成功
打开后还是以链接的形式，设置公开的方法同上。
3. 制作公网访问链接 想要在户外访问本地资源，就需要内网穿透软件，这里我们可以使用免费不限流量的cpolar，如何安装cpolar请参考：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/238f488ed6413f9c983e3c8d0c4795a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e9ec7beee32079fab5fc541d3faeac3/" rel="bookmark">
			labuladong日常刷题-双指针 | LeetCode 83删除排序链表中的重复元素 5最长回文子串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双指针操作链表与字符串 LeetCode 83 删除排序链表中的重复元素 2023.12.28 题目链接labuladong讲解[链接]
ListNode* deleteDuplicates(ListNode* head) { /*暴力求解 ListNode* cur = new ListNode(); ListNode* prenode = cur; cur-&gt;next = head; cur = cur-&gt;next; while(cur &amp;&amp; cur-&gt;next) { if(cur-&gt;val == cur-&gt;next-&gt;val) { if(cur-&gt;next-&gt;next) cur-&gt;next = cur-&gt;next-&gt;next; else cur-&gt;next = NULL; } else cur = cur-&gt;next; } return prenode-&gt;next; */ //双指针求解 //左右指针初始化均指向头节点，用右指针来遍历，左指针来存储 ListNode* left = head; ListNode* right = head; //当右指针且右指针的next指针不为空时 while(right &amp;&amp; right-&gt;next) { //如果右指针与右指针的next节点值相同， //则如果右指针next节点的next节点存在时，左指针的next节点=右指针next节点的next节点，然后继续遍历 //否则如果右指针next节点的next节点不存在时，说明走到头了，则给左指针的next节点指向NULL if(right-&gt;val == right-&gt;next-&gt;val) { if(right-&gt;next-&gt;next) left-&gt;next = right-&gt;next-&gt;next; else left-&gt;next = NULL; } //如果右指针与右指针的next节点值不相同，那么左右指针都继续遍历 //实际上，左右指针都是保持同步的 else { right = right-&gt;next; left = left-&gt;next; } } //返回头指针 return head; } LeetCode 5 最长回文子串 2023.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e9ec7beee32079fab5fc541d3faeac3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c8de109d0a2e40da9a9c8580b65164b/" rel="bookmark">
			100000000！文心一言披露最新用户规模
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“文心一言用户规模突破1亿。”12月28日，百度首席技术官、深度学习技术及应用国家工程研究中心主任王海峰在第十届WAVE SUMMIT深度学习开发者大会上宣布。会上，王海峰以《文心加飞桨，翩然赴星河》为题作了主旨演讲，分享了飞桨和文心的最新成果。
飞桨开发者已达1070万 WAVE SUMMIT深度学习开发者大会始于2019年4月，每年两次与开发者相聚，如今已是五载十届。
回顾五年，大会一路见证了百度对人工智能技术和产业趋势的前瞻判断，指引了技术创新和产业实践的方向。2019年王海峰在首届大会上提出，深度学习框架是智能时代的操作系统。深度学习的通用性特点，以及深度学习框架及平台的发展，推动人工智能标准化、自动化和模块化，进入工业大生产阶段。2020年，王海峰提出了打造AI新型基础设施，云智一体加速产业智能化，将AI大生产平台升级为云智一体的新型基础设施，为产业智能化奠定坚实的基础。2021年，王海峰表示，人工智能呈现出“融合创新”和“降低门槛”的特点：一方面，AI技术及产业的融合创新越来越多；另一方面，虽然AI技术越来越复杂，但AI开发与应用的门槛却越来越低。2022年，王海峰进一步提出，深度学习平台加上大模型，贯通了从硬件适配、模型训练、推理部署，到场景应用的AI全产业链，夯实了产业智能化基座。今年，大语言模型的出现，为通用人工智能带来曙光。
五年来，在持续技术创新和赋能产业的发展历程中，飞桨自身也在不断升级，从深度学习框架，到平台生态，发展成为技术领先、功能丰富的产业级深度学习开源开放平台。飞桨集核心框架、基础模型库、开发套件、工具组件，以及助力开发者成长的星河社区于一体，具有动静统一的深度学习框架、端到端自适应大规模分布式训练、云边端全场景高性能推理等关键核心技术。
飞桨生态愈加繁荣，2019年，凝聚在飞桨平台的开发者规模150万，到今年8月的Wave Summit，已经达到800万，服务的企业数量、基于飞桨创建的模型数量，也都高速增长。王海峰现场公布了飞桨生态最新成果，截至2023年12月底，飞桨已凝聚1070万开发者，服务23.5万家企事业单位，基于飞桨创建了86万个模型。
文心一言用户规模破亿 据了解，百度自2019年起深耕预训练模型研发，发布了文心大模型1.0。经过近四年积累，百度于今年3月在全球科技大厂中率先发布了知识增强大语言模型文心一言。10月，文心一言的基础模型升级到4.0，理解、生成、逻辑和记忆四大人工智能基础能力全面提升。文心大模型4.0过去两个多月整体效果又提升了32%。
王海峰现场披露，文心一言用户规模已突破1亿，自8月31日获准开放对公众提供服务以来，文心一言的用户提问量一路上扬，基本与文心大模型的效果提升同步。越来越多的用户在信任和使用文心一言。
王海峰最后表示：“五载十届，我们与所有开发者一起，踔厉奋发，笃行不怠。愿继续与所有开发者携手并肩，在飞桨和文心的支持下，共赴通用人工智能的星辰大海！”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2dd1ab57b4ada4426995350907103e0/" rel="bookmark">
			Android---Kotlin 学习013
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		互操作性和可空性
Java 世界里所有对象都可能是 null，而 kotlin 里面不能随便给一个变量赋空值的。所有，kotlin 取调用 java 的代码就很容易出现返回一个 null，而 Kotlin 的接收对象不能为空，你不能想当然地认为 java 的返回值就能符合 kotlin 关于空值的规定。
此时，因为不知道返回的是否是 null，所以可以使用空安全操作符。如果为空，则不执行后面的函数。 类型映射
代码运行时，所有的映射类型都会重新映射回对应的 Java 类型。
示例：
在 java 里声明一个 int 类型变量
public int score; 在 kotlin 里面调用这个属性，查看其类型
// 类型映射 println(StudentInfo.score.javaClass) 属性访问
kotlin 访问 java 的属性时，不需要调用相关 get() 方法。给 java 属性赋值时，也可以使用赋值语法来设置一个 Java 字段值。
@JvmName
可以使用 @JvmName 注解指定编译类的名字
示例：在 java 中调用 kotlin 的函数。
可以看到，java 里使用 kotlin 文件里的函数时，会在函数名后加Kt（xxxKt）形成接收者。如果我们想要原来的名，而不加 Kt，那么就可以使用 @JvmName 来指定类名。
@JvmField
在 Java 里，不能直接访问 kotlin 的属性，例如 spells 属性，必须调用 getSpells() 方法。然而，你可以给 Kotlin 属性添加 @JvmField 注解，暴露它的支持字段给 Java 调用者，从而避免使用 get() 方法。与 kotlin 里直接访问 java 属性一样。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2dd1ab57b4ada4426995350907103e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed8375e3bf7dc84aa165a684f3beb62e/" rel="bookmark">
			day3--Shell
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.shell语法 概论 概论 shell是我们通过命令行与操作系统沟通的语言。 shell脚本可以直接在命令行中执行，也可以将一套逻辑组织成一个文件，方便复用。 AC Terminal中的命令行可以看成是一个“shell脚本在逐行执行”。 Linux中常见的shell脚本有很多种，常见的有： Bourne Shell(/usr/bin/sh或/bin/sh) Bourne Again Shell(/bin/bash) C Shell(/usr/bin/csh) K Shell(/usr/bin/ksh) zsh … Linux系统中一般默认使用bash，所以接下来讲解bash中的语法。 文件开头需要写#! /bin/bash，指明bash为脚本解释器。 学习技巧 不要死记硬背，遇到含糊不清的地方，可以在AC Terminal里实际运行一遍。 脚本示例 新建一个test.sh文件，内容如下： #! /bin/bash echo "Hello World!" 运行方式 作为可执行文件 acs@9e0ebfcd82d7:~$ chmod +x test.sh # 使脚本具有可执行权限 acs@9e0ebfcd82d7:~$ ./test.sh # 当前路径下执行 Hello World! # 脚本输出 acs@9e0ebfcd82d7:~$ /home/acs/test.sh # 绝对路径下执行 Hello World! # 脚本输出 acs@9e0ebfcd82d7:~$ ~/test.sh # 家目录路径下执行 Hello World! # 脚本输出 用解释器执行 acs@9e0ebfcd82d7:~$ bash test.sh Hello World!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed8375e3bf7dc84aa165a684f3beb62e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd50350c76a8fcdcf7f8f0c9fd25132/" rel="bookmark">
			霹雳吧啦Wz《pytorch图像分类》-p2AlexNet网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《pytorch图像分类》p2AlexNet网络基础及代码 一、零碎知识点1.过拟合2.使用dropout后的正向传播3.正则化regularization4.代码中所用的知识点 二、总体架构分析1.ReLU激活函数2.手算3.模型代码 三、训练花分类课程代码1.model.py2.train.py3.predict.py 一、零碎知识点 1.过拟合 模型假设过于复杂，参数过多，训练数据过少，噪声过多，导致拟合的函数完美的预测训练集，但对新数据的测试集预测结果差。 过度的拟合了训练数据，而没有考虑到泛化能力。
举个栗子：当我们在学习一门新的学科时会做一些例题，我们把这些例题完完整整背下来，但是一旦给出新的题目，还是不会做，这就是学习没有泛化能力，只记住了例题的细节而忽视了更普遍的规律。
2.使用dropout后的正向传播 dropout会在每一层当中随机失活一部分神经元，从而减少了神经元之间的共适应性，防止过拟合。
nn.Dropout(p= )p代表的是随机失活的比例，默认p=0.5
3.正则化regularization 是一种通过添加额外的约束或惩罚项来控制模型的复杂度的技术，其目的也是防止过拟合。
假设我们的模型是一个二次多项式，我们的目标是最小化损失函数（均方误差MSE），让预测的曲线与真实值尽可能接近。
L2正则化将惩罚项加到损失函数中，使用权重的平方和乘以一个正则化系数λ。
带正则化的损失函数为：
L o s s = M S E + λ ∗ ∣ ∣ w ∣ ∣ 2 Loss = MSE + λ * ||w||^2 Loss=MSE+λ∗∣∣w∣∣2
很抽象，以后再深入学习。
4.代码中所用的知识点 设备设置
如果有可以使用的gpu设备，默认使用第一个，没有的话即使用cpu。 device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu") RandomResizedCrop随机裁剪
将裁剪后的图像调整为指定的大小（224x224） transforms.RandomResizedCrop(224) root=“. ./. .”
返回上上层目录
CrossEntropyLoss交叉熵损失函数
它是PyTorch中的一个损失函数，常用于多分类问题的训练中。它结合了Softmax激活函数和负对数似然损失(NLLLoss)
详情请见我之前写的博客：多分类问题
net.train( )和net.eval( )
当调用net.train()时，模型将被设置为训练模式。在训练模式下，模型会启用一些特定的操作，如Batch Normalization归一化处理和Dropout随机失活一些神经元，防止过拟合。而调用net.eval()时，模型将被设置为评估（evaluate）模式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfd50350c76a8fcdcf7f8f0c9fd25132/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/726c12f0c330b1db80ef32184043740a/" rel="bookmark">
			【C&#43;&#43; 策略设计模式 】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		策略设计模式
定义一组算法，将每个算法都封装起来，并且使它们之间可以互换
StartegyMode.cpp
#include &lt;iostream&gt; using namespace std; class IStrategy { public: IStrategy() {} virtual ~IStrategy() {} virtual void Discountsfun() = 0; }; class qxj : public IStrategy { public: qxj() {} ~qxj() {} void Discountsfun() { cout &lt;&lt; "run qxj 20'%' off" &lt;&lt; endl; } }; class gqj : public IStrategy { public: gqj() {} ~gqj() {} void Discountsfun() { cout &lt;&lt; "run gqj 10'%' off " &lt;&lt; endl; } }; class Context { public: Context(IStrategy *IStrategy) { pIStrategy = IStrategy; } ~Context() { delete pIStrategy; } void run() { pIStrategy-&gt;Discountsfun(); } private: IStrategy *pIStrategy; }; // g++ StartegyMode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/726c12f0c330b1db80ef32184043740a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62468a1fee61613b4977d8d94c34aeff/" rel="bookmark">
			排序算法-冒泡排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 排序算法-冒泡排序从小到大排序C#代码运行结果 从大到小排序C#代码运行结果 排序算法-冒泡排序 从小到大排序 C#代码 /// &lt;summary&gt; /// 冒泡排序【从小到大排序】 /// Krystal 2023-11-08 11:21:45 /// i是趟数，j是元素的位置，每一趟完毕，最大的元素都在正确的位置上 /// 如： 7 5 8 6 3 /// 结果：3 5 6 7 8 /// &lt;/summary&gt; /// &lt;param name="array"&gt;&lt;/param&gt; private void bubbleSort(int[] array) { int t; for (int i = 0; i &lt; array.Length - 1; i++) { for (int j = 0; j &lt; array.Length - 1 - i; j++) { if (array[j] &gt; array[j + 1]) { t = array[j]; array[j] = array[j + 1]; array[j + 1] = t; } } } } 运行结果 从大到小排序 C#代码 /// &lt;summary&gt; /// 冒泡排序【从大到小排序】 /// Krystal 2023-11-08 11:59:35 /// i是趟数，j是元素的位置，每一趟完毕，最小的元素都在正确的位置上，在右边都是排好的，比如第i趟时，第i+1小的数在位置array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62468a1fee61613b4977d8d94c34aeff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7a6a3b2bdbe6465e91157e60fd463d4/" rel="bookmark">
			牛客网SQL训练5—SQL大厂真题面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、某音短视频1.各个视频的平均完播率2.平均播放进度大于60%的视频类别3.每类视频近一个月的转发量/率4.每个创作者每月的涨粉率及截止当前的总粉丝量5.国庆期间每类视频点赞量和转发量6.近一个月发布的视频中热度最高的top3视频 二、用户增长场景（某度信息流）1.2021年11月每天的人均浏览文章时长2.每篇文章同一时刻最大在看人数3.2021年11月每天新用户的次日留存率4.统计活跃间隔对用户分级结果5.每天的日活数及新用户占比6.连续签到领金币 三、电商场景（某东商城）1.计算商城中2021年每月的GMV2.统计2021年10月每个退货率不大于0.5的商品各项指标3.某店铺的各商品毛利率及店铺整体毛利率4.零食类商品中复购率top3高的商品5.10月的新户客单价和获客成本6.店铺901国庆期间的7日动销率和滞销率 四、出行场景（某滴打车）1.2021年国庆在北京接单3次及以上的司机统计信息2.有取消订单记录的司机平均评分3.每个城市中评分最高的司机信息4.国庆期间近7日日均取消订单量5.工作日各时段叫车量、等待接单时间和调度时间6.各城市最大同时等车人数 五、某宝店铺分析（电商模式）1.某宝店铺的SPU数量2.某宝店铺的实际销售额与客单价3.某宝店铺折扣率4.某宝店铺动销率与售罄率5.某宝店铺连续2天及以上购物的用户及其对应的天数 六、牛客直播课分析（在线教育行业）1.牛客直播转换率2.牛客直播开始时各直播间在线人数3.牛客直播各科目平均观看时长4.牛客直播各科目出勤率5.牛客直播各科目同时在线人数 七、某乎问答（内容行业）1.某乎问答11月份日人均回答量2.某乎问答高质量的回答中用户属于各级别的数量3.某乎问答单日回答问题数大于等于3个的所有用户4.某乎问答回答过教育类问题的用户里有多少用户回答5.某乎问答最大连续回答问题天数大于等于3天的用户 一、某音短视频 1.各个视频的平均完播率 题目：计算2021年里有播放记录的每个视频的完播率(结果保留三位小数)，并按完播率降序排序
--输入： DROP TABLE IF EXISTS tb_user_video_log, tb_video_info; CREATE TABLE tb_user_video_log ( id INT PRIMARY KEY AUTO_INCREMENT COMMENT '自增ID', uid INT NOT NULL COMMENT '用户ID', video_id INT NOT NULL COMMENT '视频ID', start_time datetime COMMENT '开始观看时间', end_time datetime COMMENT '结束观看时间', if_follow TINYINT COMMENT '是否关注', if_like TINYINT COMMENT '是否点赞', if_retweet TINYINT COMMENT '是否转发', comment_id INT COMMENT '评论ID' ) CHARACTER SET utf8 COLLATE utf8_bin; CREATE TABLE tb_video_info ( id INT PRIMARY KEY AUTO_INCREMENT COMMENT '自增ID', video_id INT UNIQUE NOT NULL COMMENT '视频ID', author INT NOT NULL COMMENT '创作者ID', tag VARCHAR(16) NOT NULL COMMENT '类别标签', duration INT NOT NULL COMMENT '视频时长(秒数)', release_time datetime NOT NULL COMMENT '发布时间' )CHARACTER SET utf8 COLLATE utf8_bin; INSERT INTO tb_user_video_log(uid, video_id, start_time, end_time, if_follow, if_like, if_retweet, comment_id) VALUES (101, 2001, '2021-10-01 10:00:00', '2021-10-01 10:00:30', 0, 1, 1, null), (102, 2001, '2021-10-01 10:00:00', '2021-10-01 10:00:24', 0, 0, 1, null), (103, 2001, '2021-10-01 11:00:00', '2021-10-01 11:00:34', 0, 1, 0, 1732526), (101, 2002, '2021-09-01 10:00:00', '2021-09-01 10:00:42', 1, 0, 1, null), (102, 2002, '2021-10-01 11:00:00', '2021-10-01 11:00:30', 1, 0, 1, null); INSERT INTO tb_video_info(video_id, author, tag, duration, release_time) VALUES (2001, 901, '影视', 30, '2021-01-01 7:00:00'), (2002, 901, '美食', 60, '2021-01-01 7:00:00'), (2003, 902, '旅游', 90, '2021-01-01 7:00:00'); select a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7a6a3b2bdbe6465e91157e60fd463d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3185cabe83a5c1d7bd55a7da99653b6f/" rel="bookmark">
			简单工厂设计模式（计算器实例优化）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单工厂设计模式（计算器实例优化） 介绍为什么采用面向对象编程而不是面向过程呢？实例讲解业务层划分出来逻辑层继承简单工厂：（多态）业务层：（解耦合）主控制台 总结 介绍 本文内容引用自《大话这设计模式》这本书第一章节简单工厂设计模式，供自己提高代码水平使用。
案例也同样采用计算器功能实现方式展开
实现功能----&gt;封装----&gt;继承----&gt;多态----&gt;面向对象
为什么采用面向对象编程而不是面向过程呢？ 在当今互联网开发的大型企业中你会发现，当你接到一个功能模块的时候不会给你完整的项目源码，特别是核心的东西，为什么呢？
仔细想一下，如果公司把员工薪资分发系统让你修改，这时你动了一下坏心思，做了一层 If 判断，如果名字是自己的话薪资*2，是不是公司就赔了？况且公司也不会这么傻，把这种核心的功能让新手做修改，这就引入代码的面向对象，将代码分为逻辑层和业务层分开处理，这样不仅逻辑清晰方便后期的修改，也方便了公司为自身的保护。
实例讲解 我们创建一个主控制台,先用一个面向过程的编程方式去写一个计算器功能，代码如下
while (true) { try { Console.WriteLine("请输入第一个数字一"); double number1 = double.Parse(Console.ReadLine()); Console.WriteLine("请输入运算符"); string symbol = Console.ReadLine(); Console.WriteLine("请输入第一个数字二"); double number2 = double.Parse(Console.ReadLine()); switch (symbol) { case "+": Console.WriteLine(number1 + number2); break; case "-": Console.WriteLine(number1 - number2); break; case "*": Console.WriteLine(number1 * number2); break; case "/": if (number2 == 0d) { Console.WriteLine("被除数不能为0"); break; } Console.WriteLine(number1 / number2); break; default: break; } } catch (Exception ex) { Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3185cabe83a5c1d7bd55a7da99653b6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ef33cb8fd6b75b76a2c9d968949d102/" rel="bookmark">
			Unity Shader UVLightReveal （紫外线显示，验钞效果）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity Shader UVLightReveal （紫外线显示，验钞效果） UVLight Reveal 实现验钞机的效果实现方案操作实现1.Light2.将另一个图形加入3.加上图形效果4.加上灯光的颜色自定义判定 源码 UVLight Reveal 实现验钞机的效果 大家应该都有见过验钞机验100块钱的经历吧，而且在很多光感游戏中也会出现这种效果，当指定颜色的光线照射到对应的物体上物体就会呈现出隐藏的效果，在我理解的游戏中很多密室类型的游戏会有这种需求，况且我们把这种效果加在某些类型的游戏中作为一个彩蛋也是不错之选。
下面先看下效果，今天带大家做一个UVLight Reveal的效果
这里用到的插件Amplify Shader Editor 1.6.1，这个效果在原有包中是存在的，这里我结合了另外一种效果合并来说一下。
实现方案 Light Attenuation Node
光衰减节点包含统一的光和影信息。使用方向灯返回对象被直接照亮或处于阴影中的白色和黑色区域，这些区域将根据您的方向灯设置进行相应的更改。对于点光源和聚光灯，它还包含光的平滑衰减信息，该信息会随着范围设置的变化而变化。在这两种情况下都不包含光强或颜色信息，所以通常与同时包含光强和颜色信息的light color节点一起使用时，它会变得更有用。只有在执行某种自定义照明时才有用，因此，只有当将灯光模型设置为自定义照明时，节点才在available nodes菜单中可见，如果它恰好位于自定义照明之外，则会显示警告。
注1:为简便起见，当光强为零时，衰减也为零。
注2:此节点只应在与来自表面输出节点的自定义照明输入端口连接时使用。
Light Color Node
浅色节点输出浅色信息。RGB通道不包含光色，而是光色和光强相乘的结果。
| 输出端口 | 描述 | 类型
| RGBA | 返回原始的浅色矢量 | 颜色
| Color | 返回光色乘以光强 ， 对应于光色矢量的RGB通道 | Vector3
| Intensity | 返回光强，光强对应于光色矢量的Alpha通道 | Float
World Space Light Pos Node
世界空间光Pos节点根据当前的光类型输出归一化的光方向向量或世界空间坐标中的光位置。
对于方向灯，Dir/Pos输出将指定一个世界空间方向，并将类型设置为0。对于其他轻类型，Dir/Pos输出将指定一个世界空间位置，类型将被设置为1。
Dir/ pos | 根据当前的光类型返回光的方向或在世界空间坐标中的位置 | Float3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ef33cb8fd6b75b76a2c9d968949d102/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18607b9734fba989e3aab3c2eb8b11bc/" rel="bookmark">
			Unity Shader-真实下雨路面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity Shader-真实下雨路面 简介素材1.准备插件Amplify Shader Editor（这里我使用的是1.6.4最新版）2.贴纸和切图d 一、创建一个Shader Surface，实现气泡播放效果二、叠加一次气泡播放效果，使其看起来更多，更无序三、小波浪，无序四、将做好的三替换二中的Scale五、添加实物Albedo和Normal六、最终连线七、代码如下 简介 根据YouToBe =&gt; PolyToots实现
效果：
素材 1.准备插件Amplify Shader Editor（这里我使用的是1.6.4最新版） 2.贴纸和切图d 水波纹法线切图
地板法线切图
地板贴图
一、创建一个Shader Surface，实现气泡播放效果 Time的Scale值为1
Flipbook UV Animation（插件自带方法循环播放区域材质）值设置如图
效果如下：动态气泡循环播放
二、叠加一次气泡播放效果，使其看起来更多，更无序 其中的Divide的B值为0.6，无序效果
Scale为波纹大小0为无波纹，加大波纹加深
Blend Normals将两次效果叠加
三、小波浪，无序 上下两层方向分别不同，上层Panner为1,1 下层Panner为-1，-1
Ripple Mask Speed为波浪遮罩的播放速度
四、将做好的三替换二中的Scale 如图所示
五、添加实物Albedo和Normal Albedo
Tiling 文理大小
Normal（使其发现文理进行移动：波纹）
Puddle Speed是速度
Puddle Strength波纹深度
六、最终连线 七、代码如下 如果不适用插件，可以将下述注释删除
// Made with Amplify Shader Editor
// Available at the Unity Asset Store - http://u3d.as/y3X
Shader “Rain/Test”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18607b9734fba989e3aab3c2eb8b11bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6f9be632a4eaf96c6e8013cfb6011c8/" rel="bookmark">
			留言板（Mybatis连接数据库版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.添加Mybatis和SQL的依赖
2.建立数据库和需要的表
3.对应表中的字段，补充Java对象
4.对代码进行逻辑分层
5.后端逻辑代码
之前的项目实例【基于Spring MVC的前后端交互案例及应用分层的实现】https://blog.csdn.net/weixin_67793092/article/details/134613210?utm_source=app&amp;app_version=6.1.7中有关对于留言板的介绍，现在使用Mybatis完成连接数据库，这样以便刷新浏览器页面后，之前输入的信息仍然能够保存在硬盘中。
之前的前端页面实现：
1.添加Mybatis和SQL的依赖 在pom.xml文件中右键
2.建立数据库和需要的表 DROP TABLE IF EXISTS message_info; CREATE TABLE `message_info` ( `id` INT ( 11 ) NOT NULL AUTO_INCREMENT, `from` VARCHAR ( 127 ) NOT NULL, `to` VARCHAR ( 127 ) NOT NULL, `message` VARCHAR ( 256 ) NOT NULL, `delete_flag` TINYINT ( 4 ) DEFAULT 0 COMMENT '0-正常, 1-删除', `create_time` DATETIME DEFAULT now(), `update_time` DATETIME DEFAULT now() ON UPDATE now(), PRIMARY KEY ( `id` ) ) ENGINE = INNODB DEFAULT CHARSET = utf8mb4; 配置连接数据库application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6f9be632a4eaf96c6e8013cfb6011c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f68caa8209fab6006d5ab0cd310d9c1/" rel="bookmark">
			牛客网SQL训练4—SQL进阶挑战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、增删改操作1. 插入记录2. 更新记录3. 删除记录 二、表与索引操作1. 表的创建、修改与删除2. 索引的创建、删除 三、聚合分组查询1. 聚合函数2. 分组查询 四、多表查询1. 嵌套子查询2. 合并查询3. 连接查询 五、窗口函数1. 专用窗口函数2. 聚合窗口函数 六、其他常用操作1. 空值处理2. 高级条件语句3. 限量查询4. 文本转换函数 一、增删改操作 1. 插入记录 【题目1：插入记录 (一)】
--输入： drop table if EXISTS exam_record; CREATE TABLE IF NOT EXISTS exam_record ( id int PRIMARY KEY AUTO_INCREMENT COMMENT '自增ID', uid int NOT NULL COMMENT '用户ID', exam_id int NOT NULL COMMENT '试卷ID', start_time datetime NOT NULL COMMENT '开始时间', submit_time datetime COMMENT '提交时间', score tinyint COMMENT '得分' )CHARACTER SET utf8 COLLATE utf8_general_ci; TRUNCATE exam_record; 插入记录的方式汇总：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f68caa8209fab6006d5ab0cd310d9c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea4d6d3e40140232182ee85d11e7b6f1/" rel="bookmark">
			C&#43;&#43;面向对象（OOP）编程-多线程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几乎所有的编程语言都会支持多线程、多线程是现代操作系统提高系统运行效率的一个重要的手段，在算力有限的情况下，多线程在编程方面有着重要的地位。在一般的编程语言面试中少不了对多线程的考察。本文希望能够全面的介绍并实现C++中的多线程，为C++多线程提供指导。
🎬个人简介：一个全栈工程师的升级之路！
📋个人专栏：C/C++精进之路
🎀CSDN主页 发狂的小花
🌄人生秘诀：学习的本质就是极致重复!
目录
1 多线程介绍
1.1 线程与进程的区别
1.2 并行和并发的区别
1.3 多线程实例
1.3.1 无参线程的创建
1.3.2 有参线程的创建
1.3.3 线程的结束方式
1.4 互斥量(mutex)
1.4.1 互斥量类型
1.4.2 lock类
1.4.3 lock和unlock函数
1.4.4 std::mutex和lock、unlock的使用
1.4.5 lock_guard的使用
1.4.6 unique_lock 的使用
1.5 条件变量(condition_variable)
1.6 异步线程
1.6.1 std::future
1.6.2 std::shared_future
1.6.3 future 和 shared_future区别
1.7 原子操作（atomic）
1.8 线程池
1.8.1 线程池的优势
1 多线程介绍 要理解多线程需要理解线程和进程的区别。应用由程序和数据组成，程序中包括多个或者一个进程，进程中包括多个或者一个线程。进程的范围大于线程。
1.1 线程与进程的区别 进程是资源分配的最小单位，而线程是程序执行的最小单位。
也就是说，进程是系统中独立存在的程序关于某段时间内的动态变化过程，它拥有自己独立的地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段。
而线程则是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源。
进程和线程的生命周期也不同。进程的生命周期通常比线程长，因为线程是隶属于进程的，当进程被销毁时，线程也会随之被销毁。相反，线程可以被创建和销毁多次，只要进程还存在。
进程和线程分别属于不同的执行单元，所以他们之间的通信也有所差异。同一进程内的线程之间通信更加容易和高效，因为共享相同的地址空间和全局变量等资源。而不同进程之间的通信则通常需要借助特定的机制，如管道、信号量等。
1.2 并行和并发的区别 并发是指两个或更多的事件在同一时间段内发生，这些事件可能涉及到同一个实体，比如一个处理器。这意味着处理器在某一时刻会处理多个任务，但这些任务并不是真正同时运行的，而是通过快速切换来实现“同时执行”的效果。
并行则是指两个或者多个事件在同一时刻发生，这通常涉及到不同的实体，如多个处理器或多核的处理器。这意味着每个处理器或核心都在独立地执行不同的任务，而这些任务是真正同时运行的。
简单来说，并发关注的是任务的抽象调度，即多个任务如何分配到处理器并快速切换以实现“同时执行”的效果；而并行关注的是任务的实际执行，即多个任务如何在多个处理器上真正同时运行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea4d6d3e40140232182ee85d11e7b6f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cac61b4e389de8b7506e9c1f6144dfb3/" rel="bookmark">
			【新版Hi3559AV100 旗舰8K30 AI摄像机芯片】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新版Hi3559AV100 旗舰8K30 AI摄像机芯片
一、总体介绍
Hi3559AV100是专业的8K Ultra-HD Camera SOC，它提供了8K30/4K120广播级图像质量的数字视频录制，支持8路Sensor输入，支持H.265编码输出或影视级的RAW数据输出，并集成高性能ISP处理，同时采用先进低功耗工艺和低功耗架构设计，为用户提供了卓越的图像处理能力。Hi3559AV100支持业界领先的多路4K Sensor输入，多路ISP图像处理，支持HDR10高动态范围技术标准，并支持8路全景硬件拼接。在支持8K30/4K120视频录制下，Hi3559AV100提供硬化的6-DoF 数字防抖，减少了对机械云台的依赖。Hi3559AV100提供了高效且丰富的计算资源，支撑客户消费类应用和行业类应用。Hi3559AV100集成了双核 A73和双核A53，大小核架构和双操作系统，使得功耗和启动时间达到均衡。采用先进的12nm低功耗工艺和小型化封装，同时支持 DDR4/LPDDR4，使得Hi3559AV100可支撑产品小型化设计。Hi3559AV100配套海思提供的稳定、易用的SDK设计，能够支撑客户快速产品量产。
二、关键特性
2.1处理器内核
• 双核 ARM Cortex A73@1.6GHz，32KB I-Cache， 64KB D-Cache /512KB L2 cache
• 双核 ARM Cortex A53@1.2GHz，32KB I-Cache， 32KB D-Cache /256KB L2 cache
• 单核 ARM Cortex A53@1.2GHz，32KB I-Cache， 32KB D-Cache /128KB L2 cache
• 支持 Neon 加速，集成 FPU 处理单元
2.2GPU
• 双核 ARM Mali G71@900MHz，256KB cache
• 支持 OpenCL 1.1/1.2/2.0
• 支持 OpenGL ES 3.0/3.1/3.2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cac61b4e389de8b7506e9c1f6144dfb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d3a785e3c56121f8b38e3ebd607bff6/" rel="bookmark">
			【新版Hi3536AV100性能果真强悍】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hi3536AV100是针对多路高清/超高清（1080p/4M/5M/4K）智能NVR产品应用开发的新一代专业高端SoC芯片。
Hi3536AV100集成了ARM Cortex-A55八核处理器和性能强大的神经网络处理器，支持多种智能算法应用。
Hi3536AV100支持32路1080p多协议解码及4路1080p H.265/H.264编码，还支持双HDMI 4K显示能力及鱼眼矫正、动态对比度增强等多种图像处理功能。同时，Hi3536AV100还支持完整的安全解决方案，结合丰富的外围设备及高速接口，该SoC芯片为客户产品提供了高性能、安全、高集成度、易于开发的嵌入式高清智能NVR解决方案。
芯片开发SDK型号SS626V100。
关键特性
一、处理器内核
• ARM Cortex A55 八核@1.6GHz
−32KB L1 I-Cache，32KB L1 D-Cache
−1MB L3 Cache
−支持NEON/FPU
• 支持 TrustZone
二、多协议视频编解码
• H.265 Main Profile, Level 5.0 编码
• H.265 Main Profile, Level 5.1 解码
• H.264 Baseline/Main/High Profile，Level 5.2 解码
• MPEG-4 ASP, Level 0~3 解码
• MJPEG/JPEG Baseline 编解码
三、视频编解码处理
• H.265/H.264/MPEG-4 解码性能：
−32x1080p@30fps
−8x4K(38402160)@30fps
• H.265/H.264 编码性能：4K(38402160)@30fps
• JPEG 解码性能：1080p@240fps
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d3a785e3c56121f8b38e3ebd607bff6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0944a1cdcf129c69db0fc92fa32fc31e/" rel="bookmark">
			Linux中的gcc\g&#43;&#43;使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 gcc\g++的使用预处理编译汇编链接函数库gcc选项 gcc\g++的使用 这里我们需要知道gcc和g++实际上是对应的c语言和c++编译器，而其他的Java（半解释型），PHP，Python等语言实际上是解释型语言，因此我们经常能听到c语言是偏向底层的语言
我们这里就以c语言为例，进行基础的讲解
我们知道计算机只能处理二进制代码，而在计算机发展的过程中，将二进制代码是用类似打孔纸带的东西承载的，再之后发展就是由汇编语言，将众多常用的二进制代码用助记符来表示，之后再由汇编语言发展而来的各类底层语言，也就是c语言
那我们把上面的过程反过来，就是电脑能够理解我们所写代码含义的过程了，也就称之为编译
在编译的过程中实际上分为四个阶段
那我们能否将编译的过程分段查看呢，其实在Linux中是可以做到的，只需要用一些指令即可
预处理 在这个阶段中，主要做一些准备工作，例如头文件展开，删除注释，条件编译，宏替换，这些工作都是在预处理阶段完成的，例如
我们首先使用vim创建一个c语言文件
vim test.c #include&lt;stdio.h&gt; int main() { int i = 0; int sum = 0; for(; i &lt;= 10; i++) { sum += i; } printf("%d\n", sum); return 0; } 我们使用gcc进行编译就可以直接产生一个可执行文件，这里我们可以用选项使他只进行预处理阶段的内容
gcc -E test.c -o test.i 这里的-E选项代表只进行预处理阶段的处理，-o表示生成文件的名称，我们一般把后缀名命名为i
可以使用vim可以看到里面的内容
这里我们可以看到内容还是很多的，直接生成了八百多行的内容，因为他把stdio的内容全都转移到这个文件中了
但是我们还是可以看懂其中的内容的，说明他还是处于c语言阶段，并没有到汇编的内容
编译 实际上这一阶段就会将程序翻译成汇编语言，我们同样可以使用选项来查看内容
例如
gcc -S test.i -o test.s 这里的代码对于没有学过汇编语言的人来说已经读不懂了，只能大概看懂里面的一些单词
汇编 这一过程就是将汇编转成可重定位的二进制文件，目前就只需要知道他是不可执行的即可
gcc -c test.s -o test.o 链接 链接实际上就是字面意思，但是链接的是什么东西呢，实际上是对于函数库链接
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0944a1cdcf129c69db0fc92fa32fc31e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daccbbdf06e153bef6cdc844c5606379/" rel="bookmark">
			uniapp 相关知识点总结整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 单位 1. 换算规则：
1 px = 2 rpx 1 px = 0.75 pt = 3 / 4 pt 1 pt = 1.33 px = 4 / 3 px = 8 / 3 rpx 1 em = 16 px 1 em = 12 pt 1px = 1pt * 图像分辨率/72 1. rpx是基于 当前屏幕宽度与750的比值 算出来的，属于动态的。会根据不同屏幕进行换算。所以做响应式比较好用。
2. 1px 与框架样式 1rpx 转换公式 设计稿 1px / 设计稿基准宽度 = 框架样式 1rpx / 750rpx。
3. 页面元素宽度在 uni-app 中的宽度计算公式 750rpx * 元素在设计稿中的宽度 / 设计稿基准宽度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daccbbdf06e153bef6cdc844c5606379/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba049b9245f74f2a0f50b0e652154096/" rel="bookmark">
			积极拥抱信创，思迈特软件与麒麟软件NeoCertify完成认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日，思迈特软件与麒麟软件有限公司进行了联合测试，并顺利完成产品兼容性测试。经评测，思迈特软件一站式大数据分析平台（Smartbi Insight V11）与银河麒麟高级服务器操作系统（飞腾版）V10、（鲲鹏版）V10，能够达到通用兼容性要求及性能、可靠性要求，满足用户的关键性应用需求，荣获麒麟软件NeoCertify认证证书。
近来，各产业纷纷加速推进软件和芯片的本土化，将“自主可控”列为关键战略目标。国家层面的政策，包括《“十四五”数字经济发展规划》，反复强调了自主研发操作系统的紧迫性和重要性。麒麟软件紧随潮流，以安全可信的操作系统技术为核心，推出了基于CMMI 5级标准研发的银河麒麟操作系统V10，荣获国内操作系统最高安全等级认证。该新一代操作系统产品专为国产软硬件平台量身定制，以其简便易用、稳定高效、安全创新等特点脱颖而出。
麒麟软件NeoCertify认证是国家工信部和麒麟软件双认证的专项技术证书。麒麟软件是国产操作系统龙头企业，旗下银河麒麟高级服务器操作系统V10具备国内最高安全等级测评认证，广泛应用于政府、国防、金融、教育、财税、公安、审计、交通、医疗、制造等多个领域。
思迈特软件积极响应信创号召，坚持国产化的基础上持续迭代升级Smartbi Insight V11，为客户的智能决策提供了保障。并且积极参与了与银河麒麟高级服务器操作系统（飞腾版）V10和(鲲鹏版)V10的兼容性测试工作,并成功通过了测试。这也进一步验证了Smartbi Insight V11在可靠性、安全性和兼容性等多个方面已经获得权威机构的认可。
截止目前，思迈特软件已经跟海光、兆芯、鲲鹏、飞腾等国产芯片，银河麒麟、中标麒麟等国产操作系统，东方通、金蝶天燕等国产中间件，华为Gaussdb、人大金仓、南大通用等国产数据库适配，并获得了相应的互认证明。确保从平台的部署，到系统的稳定高效运行得以专业的保障，在客户复杂多样的选型下都能轻松胜任。
Smartbi Insight V11是思迈特在今年8月对外发布的一个重磅产品，作为一站式ABI平台，Smartbi Insight V11进一步强化了数据模型和指标模型核心能力，真正让“引擎”能力实现进阶。与此同时，通过电子表格、自助分析工具集、对话式分析、数据挖掘等一系列功能，从产品的广度和深度上大幅降低数据消费与使用的门槛。
思迈特一站式ABI平台Smartbi Insight V11的功能经过全面升级，如同企业数字化转型的引擎，为数字化转型提供源源不断的动力，助力企业充分释放数据的价值。特别是随着AI技术不断发展以及LLM（大语言模型）的出现，一站式ABI平台有望成为Data+AI融合的理想平台，使数据流动、实时分析和业务决策变得更加高效。对企业未来的数据分析、数据消费、使用交互和使用体验将带来颠覆性的影响。
在信创产业的加速发展背景下，只有加速纵向产业联动，才能更好地满足用户不同场景下多样的信息安全和业务连续性需求，实现与产业上下游的“兼容适配”，不仅可以让用户的业务系统更加容易与信创软硬件结合，提升自主产品的使用效率，同时可以极大地促进信创生态的建设。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baecc9b97e864c6154678593fe695588/" rel="bookmark">
			Smartbi获工信部旗下赛迪网“2023行业信息技术应用创新产品”奖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日，由工信部旗下的赛迪网、《数字经济》杂志共同主办的2023行业信息技术应用创新大会上，“信息技术应用创新成果名单”重磅揭晓，思迈特软件凭借“Smartbi 自然语言分析引擎”斩获“2023行业信息技术应用创新产品”大奖。
据了解，本次行业信息技术应用创新成果评选，旨在评选出能够引领行业信息技术创新发展的优秀企业、个人，以及代表信息化发展趋势最新技术、数字化创新发展最新成果、数实融合应用最佳方案，为企业数字化转型提供重要参考和借鉴。
作为国产BI产业领导者，Smartbi一直走在技术创新的前沿，从2019年起，Smartbi就开始将人工智能AI技术和BI融合，自主研发了自然语言分析NLA，并凭此获得多项发明专利。
思迈特软件率先将机器学习和自然语言分析等AI技术实现了与BI的深度融合，正如年初爆火出圈的ChatGPT人机交互方式一样，仅靠一点点示例提示，就能让AI大幅提升表现，用人类所喜欢的方式回答。Smatbi 对话式分析能让用户通过说话的方式，即可随时随地得到想要的数据，辅助经验决策。
目前，Smartbi对话式分析已应用在国内多个大型企业项目中，例如在对某制造企业上万业务目标的应用中，以前该企业大概只有20%的业务人员会使用拖拉拽的方式进行探索性分析，完成一轮分析至少要10分钟；现在90%以上的业务人员都使用对话式分析，推荐的问句和热门问句让业务人员可以找到分析的方向，这样的分析只需要2-3分钟即可完成一轮，使用范围和效率提升了5倍以上。 在BI这条赛道上，思迈特软件坚守着推动企业数字化转型的使命，始终坚持自主研发和不断开拓创新，始终处于行业的前沿地位。目前，Smartbi产品已广泛应用于金融、政府、制造、医疗、政府、教育等60多个行业领域，为5000多家行业领军企业提供服务，并获得市场和用户的一致认可。
数字化、智能化现已成为引领经济高质量发展的重要引擎，各行各业都在转型升级的路上砥砺前行。未来，思迈特将继续在BI领域深耕，为客户提供更优质的产品服务，在助力企业数字化转型升级过程中贡献更多的力量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7e1617ae31a85b5f8d9772bea55639d/" rel="bookmark">
			20231228在Firefly的AIO-3399J开发板的Android11使用Firefly的DTS配置单前后摄像头ov13850
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		20231228在Firefly的AIO-3399J开发板的Android11使用Firefly的DTS配置单前后摄像头ov13850
2023/12/28 19:20
缘起，突然发现只能打开前置的ov13850，或者后置的ov13850。
但是不能切换！
【SDK：rk3399-android-11-r20211216.tar.xz】
开发板：Firefly的AIO-3399J【RK3399】
SDK：rk3399-android-11-r20211216.tar.xz【Android11】
Android11.0.tar.bz2.aa【ToyBrick】
Android11.0.tar.bz2.ab
Android11.0.tar.bz2.ac
https://wiki.t-firefly.com/AIO-3399J/prepare_compile_android.html
AIO-3399J产品规格书 立即购买
AIO-3399J 采用 RK3399 六核(A72x2+A53x4) 64 位处理器，主频高达1.8GHz，集成了四核 Mali-T860 GPU，性能优异。
1、简略步骤：
rootroot@rootroot-X99-Turbo:~/3TB$ cat Android11.0.tar.bz2.a* &gt; Android11.0.tar.bz2
rootroot@rootroot-X99-Turbo:~/3TB$ tar jxvf Android11.0.tar.bz2 rootroot@rootroot-X99-Turbo:~/3TB$ mv Android11.0 61Android11.0
rootroot@rootroot-X99-Turbo:~/3TB$ cd 61Android11.0
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0$ cd u-boot
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0/u-boot$ ./make.sh rk3399
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0/u-boot$ cd ..
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0$ cd kernel/
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0/kernel$ make ARCH=arm64 rockchip_defconfig android-11.config -j36
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0/kernel$ make ARCH=arm64 BOOT_IMG=../rockdev/Image-rk3399_Android11/boot.img rk3399-sapphire-excavator-edp-avb.img -j36
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0$ source build/envsetup.sh rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0$ lunch
42. rk3399_Android11-userdebug
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7e1617ae31a85b5f8d9772bea55639d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79ef7fc6dc98c21786acd2cca68809d3/" rel="bookmark">
			CodeWhisperer--手把手教你使用一个十分强大的工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CodeWhisperer 简介 Amazon CodeWhisperer 是一款能够帮助我们智能生成代码的工具。经过数十亿行代码的训练，可以根据提示和现有代码实时生成从片段到完整功能的代码建议。类似 Cursor 和Github Copilot编码工具。目前，CodeWhisperer 兼容 Python、Java 和 JavaScript，支持各种 IDE，包括 JetBrains、Visual Studio Code、AWS Cloud9 和 AWS Lambda 控制台。
想要体验亚马逊这款最新的代码完成工具的开发者可以提交请求表单进行注册，并进入等待队列。亚马逊还推出了供所有开发人员免费使用的个人版（CodeWhisperer Individual）开发者可以安装AWS IDE工具包，激活 CodeWhisperer 功能，并在收到预览访问代码后开始使用该工具。
在编写代码时，它会自动根据您现有的代码和注释生成建议。从单行代码建议到完整的函数，它可为您提供各种大小和范围的个性化建议。CodeWhisperer 还可以扫描您的代码以突出显示和定义安全问题。
CodeWhisperer目前已支持近15种变种语言：Python、Java、JavaScript、TypeScript、C#、Go、Rust、PHP、Ruby、 Kotlin、C、C++、Shell 脚本、SQL 和 Scala，以及主流的IDE开发工具：包括 VS Code、IntelliJ IDEA 和 AWS Cloud9。
安装步骤：
1.在搜索栏输入“AWS TOOKIT”，点击安装 2.点击start 然后点击“Use a personal email to sign in with AWSBuilder ID” 3.在弹出页面里选择“copy code and proceed” 注意这里是自带 code 的，注册时要填，直接粘贴就可以了。
4.在弹出的页面里点击“open” 5.点击后弹出一个页面，将code粘贴过来，点击“next” 6.输入自己的邮箱 7.打开自己的邮箱找到验证码 8.在弹出的页面点击“allow” 9.然后会出现下面的页面，就说明已经成功了！ 个人认为CodeWhisperer是一款非常强大的工具，反应很快，强烈推荐!!! CodeWhisperer插件给了我一个强大又智能的编码助手。它的智能建议、自动补全和语法检查功能都很棒，大大提高了我的编码效率和代码质量。希望它能给您带来便利，减轻您的负担！
我在使用CodeWhisperer时，我发现CodeWhisperer比我想象的反应要快的多得多的多，体现了其人工智能的发展已经到了令人惊叹的高度，在我使用它时，它会非常智能的给我生成代码，若我自己编写代码，它会精准的检查错误并且尽可能告诉我如何进行改正并提出个性化建议。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79ef7fc6dc98c21786acd2cca68809d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d181ad823caedb62911c49439e307c85/" rel="bookmark">
			Visual Studio使用——自定义代码片段 &amp; 像使用IDEA一样能快捷输入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引出Visual Studio使用自定义代码片段 Idea安装和使用0.Java下载 和 IDEA工具1.首次新建项目2.隐藏文件不必要显示文件3.目录层级设置4.Settings设置选择idea的场景提示代码不区分大小写 取消git的代码作者显示 总结 引出 Visual Studio使用——自定义代码片段 &amp; 像使用IDEA一样能快捷输入
Visual Studio使用 自定义代码片段 选择工具，选择代码片段管理
获得存储文件的路径
自己建一个目录，用于存放自定义的.snippet文件，自定义的该文件就可以实现快捷输入代码块
输入图示的代码片段，定义一个主程序main的片段，注意后面尝试发现需要改成mmain，可能main是个关键字吧
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;CodeSnippets xmlns="http://schemas.microsoft.com/VisualStudio/2005/CodeSnippet"&gt; &lt;CodeSnippet Format="1.0.0"&gt; &lt;Header&gt; &lt;Title&gt;main&lt;/Title&gt; &lt;Shortcut&gt;main&lt;/Shortcut&gt; &lt;Description&gt;主程序代码片段&lt;/Description&gt; &lt;Author&gt;Microsoft Corporation&lt;/Author&gt; &lt;SnippetTypes&gt; &lt;SnippetType&gt;Expansion&lt;/SnippetType&gt; &lt;SnippetType&gt;SurroundsWith&lt;/SnippetType&gt; &lt;/SnippetTypes&gt; &lt;/Header&gt; &lt;Snippet&gt; &lt;Code Language="cpp"&gt;&lt;![CDATA[#define _CRT_SECURE_NO_WARNINGS #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; int main() { system("pause"); return 0; }]]&gt; &lt;/Code&gt; &lt;/Snippet&gt; &lt;/CodeSnippet&gt; &lt;/CodeSnippets&gt; 然后导入该代码片段
进行使用测试
如图所示，就能够快速填充好代码片段，方便进行开发。
参考博客：
https://blog.csdn.net/weixin_51369645/article/details/126891221
Idea安装和使用 0.Java下载 和 IDEA工具 Arya小科普 | 硬件软件基础知识 &amp; Java语言的前世今生 &amp; James Gosling老爷子的小故事 &amp; Java下载 和 IDEA工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d181ad823caedb62911c49439e307c85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cca0e3f392127bd8d371f83068e618b/" rel="bookmark">
			SQL面试题挑战11：访问会话切割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 问题：SQL解答： 问题： 如下为某电商公司用户访问网站的数据，包括用户id和访问时间两个字段。现有如下规则：如果某个用户的连续的访问记录时间间隔小于60秒，则属于同一个会话，现在需要计算每个用户有多少个会话。比如A用户在第1秒，60秒，200秒，230秒有三次访问记录，则该用户有2个会话，其中第一个会话是第1秒和第60秒的记录，第二个会话是第200秒和230秒的记录。
user_id ts 1001 16920000000 1001 16920000050 1002 16920000065 1002 16920000080 1001 16920000150 1002 16920000160 SQL解答： 先按用户分组、时间排序后取每行数据的前一行的时间，然后判断当前行的时间与前一行时间的差值，看是否在给定的范围内，然后再做开窗累加就可以得到每个用户不同的会话编号了。思路如下图：
user_idts判断与上一行差值是否小于60开窗累加当做会话编号A100A6000A20011A23001 with tmp as ( select 1001 as user_id,16920000000 as ts union all select 1001 as user_id,16920000050 as ts union all select 1002 as user_id,16920000065 as ts union all select 1002 as user_id,16920000080 as ts union all select 1001 as user_id,16920000150 as ts union all select 1002 as user_id,16920000160 as ts ) select user_id ,count(distinct user_group) as user_group_cnt from ( select user_id ,ts -- 开窗做累加 ,sum(flag) over(partition by user_id order by ts) as user_group from ( select user_id ,ts -- 判断当前行的时间与上一行的差值 ,if(ts-last_ts&lt;60,0,1) as flag from ( select user_id ,ts -- 取当前行的上一个时间，没有上一行就给自身的时间 ,lag(ts,1,ts) over(partition by user_id order by ts) as last_ts from tmp )t1 )t1 )t1 group by user_id; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60fd42df0c812c747a5f1e26eccefecf/" rel="bookmark">
			C#中创建包含括号的数据表字段的处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C#中创建数据表时，有时我们会遇到需要在字段名称中包含括号的情况。这种需求可能出现在字段名称包含特殊字符、关键字或空格的情况下。本文将探讨如何处理这种情况，并介绍一些常用的方法。
一、为什么需要处理包含括号的数据表字段
1. 避免与C#语言保留关键字冲突
在C#中，某些单词是保留关键字，具有特殊含义。如果我们将这些单词作为字段名称使用，编译器将会报错。通过使用括号将字段名称括起来，可以避免与保留关键字冲突，使代码能够正常编译。
2. 处理特殊字符和空格
字段名称中可能包含一些特殊字符或空格。这些字符在C#中具有特殊含义，可能导致语法错误或解析问题。通过使用括号将字段名称括起来，可以使编译器正确解析这些字段，确保代码的正确性。
二、处理包含括号的数据表字段的方法
1. 使用方括号将字段名称括起来
C#中使用反引号(``)将字段名称括起来可解决包含括号的字段问题。例如，可以使用`Field1`来表示一个字段名为"Field1"的字段。 1. 使用方括号将字段名称括起来
C#中使用方括号([])将字段名称括起来可解决包含括号的字段问题。例如，可以使用`[Field1]`来表示一个字段名为"Field1"的字段。
2. 注意命名规范和约定
在设置字段名称时，应遵循命名规范和约定。尽量避免使用特殊字符、关键字和空格。良好的命名规范可以减少出现包含括号字段的情况，提高代码的可读性和可维护性。
3. 使用别名
如果字段名称中包含括号，但又不希望在代码中一直使用括号来引用字段，可以考虑使用别名。通过给字段设置一个别名，可以简化代码，并提高可读性。 4. 数据库脚本处理
如果在数据库中创建数据表时需要使用包含括号的字段名称，可以在数据库脚本中进行处理。根据数据库的不同，可以使用不同的语法来处理包含括号的字段。例如，在SQL Server中，可以使用方括号将字段名称括起来。
5. 数据库迁移工具
对于大型项目或需要频繁进行数据库迁移的情况，可以考虑使用数据库迁移工具（如Entity Framework、FluentMigrator等）。这些工具提供了灵活的迁移方式，可以在迁移过程中处理包含括号的字段。
6. 使用正则表达式替换
如果已经存在包含括号的字段，并且需要进行批量处理，可以使用正则表达式替换来修改字段名称。通过正则表达式匹配需要修改的字段，并将括号替换为其他字符或移除括号。
7. 与数据库管理员协商
如果在特定的数据库系统中无法直接处理包含括号的字段，可以与数据库管理员协商解决方案。他们可能会提供一些定制化的解决方案或建议。
结论：
在C#中创建数据表时，如果需要在字段名称中包含括号，可以使用反引号或者方括号将字段名称括起来。此外，还可以考虑使用别名、数据库脚本处理、数据库迁移工具、正则表达式替换等方法来处理包含括号的字段。根据具体情况选择合适的方法，并与团队成员或数据库管理员协商解决方案。通过合适的处理方法，可以确保代码的可读性和可维护性，并避免与C#语言保留关键字冲突或引发语法错误。
上位机plc工控资料入门及工具包https://s.pdb2.com/pages/20230307/CnORDNt9HimMjNS.html
部分项目图片：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ef74abb4262bfa48d06e692ec838be3/" rel="bookmark">
			地震烈度速报与预警工程成功案例的经验分享 | TDengine 技术培训班第一期成功落地
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日，涛思数据在成都开设了“国家地震烈度速报与预警工程数据库 TDengine、消息中间件 TMQ 技术培训班”，这次培训活动共分为三期，而本次活动是第一期。其目标是帮助参与者深入了解 TDengine 和 TMQ 的技术特点和应用场景，并学习如何将其更好地应用于地震烈度速报与预警工程中。
在这次培训活动中，涛思数据联合创始人侯江燚首先为与会者带来了“时序数据库 TDengine、消息中间件 TMQ 介绍”的分享，他总结了 TDengine 的特点和优势，以及 TMQ 在大规模数据传输和处理中的重要作用。接着，为了让大家了解更多 TDengine 在地震烈度速报与预警工程中的成功案例，台网中心研究员马延路和江苏地震局研究员缪发军分别分享了各自机构在使用 TDengine 方面的案例经验，介绍了如何利用 TDengine 高效地存储和分析地震数据，为地震预警和烈度速报提供可靠的支持。最后，涛思数据交付工程师杨晨为现场参会者进行了 TDengine 产品培训和定制模块运维培训，并展示了全托管的物联网、工业大数据云服务平台 TDengine Cloud 的实操演示。
此前，为满足地震预警数据存储、检索和处理的建设与集成需求，以及响应国家国产软件自主可控的号召，中国地震台网中心决定选用国产数据库来存储和处理地震波形数，通过竞标最终由 TDengine 承担该项目。目前，该项目使用 TDengine 3.0.6.0 版本 5 节点集群进行部署，接入的原始数据包每天约 900GB，每秒大概接入超过 5 万个地震数据包，每天总数据量约 5000 亿条。在压缩方面，对于常规的 INT 类型数据，TDengine 压缩比可达到 5%-10% 之间，对于 VARCHAR 类型的数据，压缩比可达到 15-20%，极大程度地节约存储成本。在集群日常负载上，单台数据库服务端 CPU 使用率 40%～50%，内存占用 14%～20%，运行平稳。部署详情和落地效果可见《单日 5000 亿行 / 900G 数据接入，TDengine 3.0 在中国地震台网中心的大型应用》一文。
TDengine 在中国地震台网中心的成功应用也为本次活动提供了重要的铺垫。通过此次活动，与会者在了解到 TDengine 和 TMQ 技术特点的同时，还学习到了实际应用的经验和技巧，为他们在地震烈度速报与预警工程中的工作提供了有力的支持。这次活动的成功举办不仅为与会者提供了宝贵的学习机会，也为 TDengine 进一步扩大在地震烈度速报与预警工程领域的影响力打下了坚实的基础。
了解更多 TDengine Database的具体细节，可在GitHub上查看相关源代码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39a69dbdf6b8a9aef5b2743fdcacd5dd/" rel="bookmark">
			WPF 结合 MVVM模式下SqlSugar ORM框架的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WPF 结合 MVVM模式以及 SQLSugar 是一个强大的应用程序架构，可以用来创建具有良好分层和可维护性的应用程序。以下是一个简单的指导，介绍如何在 WPF MVVM 中使用 SQLSugar 访问 MySQL 数据库。
使用 WPF MVVM 框架结合 MySQL 数据库和 SqlSugar ORM 工具的详细步骤：
1、首先需要安装 SqlSugar 和 MySql.Data 两个 NuGet 包。打开 Visual Studio，右键点击项目 -&gt; NuGet 包管理器 -&gt; 管理解决方案的 NuGet 包，然后搜索 SqlSugar 和 MySql.Data，并安装它们。
2、创建一个名为 Models 的文件夹，在这个文件夹里创建一个名为 DatabaseContext.cs 的类，这个类用于连接到你的 MySQL 数据库。代码如下：
using System; using SqlSugar; namespace [your project name].Models { public class DatabaseContext { private static readonly Lazy&lt;SqlSugarClient&gt; _db = new Lazy&lt;SqlSugarClient&gt;(() =&gt; { var db = new SqlSugarClient(new ConnectionConfig() { //参ConnectionString 根据自己项目需求组合 ConnectionString = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39a69dbdf6b8a9aef5b2743fdcacd5dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5d80aeb8242d287eede485f03cdd41f/" rel="bookmark">
			Azure 学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. Azure Function1.1 Azure Function 概念1.2 Azure Function 实现原理1.3 Azure Function 本地调试1.4 Azure Function 云部署 2. Azure API Managment 概念 以及使用2.1 Azure API 概念2.2 Azure API 基本使用 3. Service Bus 应用场景及相关特性3.1 Service Bus 基本简介与特性3.2 Service Bus 消息队列 4. Azure Monitor相关内容，了解可观测性相关配置与查询操作 1. Azure Function 参考资料：Microsoft Azure
参考资料(快速入门)：使用Visual studio在Azure中创建第一个c#函数
参考资料：AZ-900
1.1 Azure Function 概念 Azure Function: 1. 可以直接编写重要代码，不需要关心基础结构的维护，可以直接上传到云服务当中. 1.2 Azure Function 实现原理 1. 利用提供的触发器和绑定进行连接服务，例如绑定的Web API(HTTP触发器服务)，当发生HTTP请求 时，Azure 云服务就可以对这个请求做出响应 代码分析：
效果图：
1.3 Azure Function 本地调试 ### 本地调试 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5d80aeb8242d287eede485f03cdd41f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81ea64be3410d31422f31e33b5cc600f/" rel="bookmark">
			代码随想录算法训练营第一天|704. 二分查找、27. 移除元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LeetCode.704 二分查找 题目链接:704. 二分查找 - 力扣（LeetCode）
视频链接:二分查找法
文章链接:我写了首诗，让你闭着眼睛也能写对二分搜索 | labuladong 的算法笔记
代码随想录 (programmercarl.com)
相关练习:35. 搜索插入位置 - 力扣（LeetCode）
34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）
69. x 的平方根 - 力扣（LeetCode）
367. 有效的完全平方数 - 力扣（LeetCode）
思路: 首先看到这个题目,会重点关注的是有序整型数组和所有元素是不重复的字眼。那我们就很容易想到寻找一个数的基本二分查找,了解过的都知道逻辑很简单,就是有点细节把控不好.以至于出错。例如到底是 while(left &lt; right) 还是 while(left &lt;= right)，到底是right = middle呢，还是要right = middle - 1呢？上面的问题就是区间定义没有分清楚，写二分法一般就是左闭右闭[left,right]和左闭右开[left,right)两种，接下来和大家一起讨论，用这两种方法如何解题。
整数二分法 指定的数字(binary_search) 第一种:左闭右闭[left,right]
class Solution { public: int search(vector&lt;int&gt;&amp; nums, int target) { int left=0,right=nums.size()-1; while(left&lt;=right) { int mid=left+((right-left)&gt;&gt;1);//避免溢出 if(nums[mid]==target) return mid;//找到target，返回mid else if(nums[mid]&gt;target) right=mid-1;//往左区间[left,mid-1]查找 else left=mid+1; //往右区间[mid+1,right]查找 } return -1;//查找失败返回-1 } }; 时间复杂度:O(logn)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81ea64be3410d31422f31e33b5cc600f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1048b5637001a892a116d574184818b/" rel="bookmark">
			kubeSphere集群部署ElasticSearch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kubeSphere集群部署ElasticSearch 根据docker启动文件来配置修改max_map_count添加配置文件创建工作负载测试 根据docker启动文件来配置 docker run -d \ --name es \ -e "ES_JAVA_OPTS=-Xms512m -Xmx512m" \ -e "discovery.type=single-node" \ -v es-data:/usr/share/elasticsearch/data \ -v es-config:/usr/share/elasticsearch/config \ --privileged \ --network es-net \ -p 9200:9200 \ -p 9300:9300 \ elasticsearch:7.12.1 文件分析
需要绑定数据卷 es-config:/usr/share/elasticsearch/configes-data:/usr/share/elasticsearch/data 需要添加两个环境变量 ES_JAVA_OPTS=-Xms512m -Xmx512mdiscovery.type=single-node (我们是集群模式不需要添加) 网络情况不需要处理,我在k8s已经状态网络组件下载镜像,绑定端口 修改max_map_count max_map_count文件包含限制一个进程可以拥有的VMA(虚拟内存区域)的数量。虚拟内存区域是一个连续的虚拟地址空间区域。在进程的生命周期中，每当程序尝试在内存中映射文件，链接到共享内存段，或者分配堆空间的时候，这些区域将被创建。调优这个值将限制进程可拥有VMA的数量。限制一个进程拥有VMA的总数可能导致应用程序出错，因为当进程达到了VMA上线但又只能释放少量的内存给其他的内核进程使用时，操作系统会抛出内存不足的错误。如果你的操作系统在NORMAL区域仅占用少量的内存，那么调低这个值可以帮助释放内存给内核用。
# 检查系统vm.max_map_count设置值 sysctl -a | grep vm.max_map_count # 更改系统vm.max_map_count设置值 sysctl -w vm.max_map_count=262144 添加配置文件 文件内容
#集群名称 cluster.name: cluster-es #节点名称，每个节点的名称不能重复，这里不指定，使用当前主机的名称 #node.name: #ip 地址，每个节点的地址不能重复 network.host: 0.0.0.0 #节点角色，7.9版本之后的配置方法 node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1048b5637001a892a116d574184818b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a307df4008e42bd3306464f93423a5b/" rel="bookmark">
			CSS中表格介绍，表格相关的样式以及长表格的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表格在日常生活中使用的非常的多，比如excel就是专门用来创建表格的工具，表格就是用来表示一些格式化的数据的，比如：课程表、银行对账单，在网页中也可以来创建出不同的表格
一：创建表格 在HTML中，使用table标签来创建一个表格，在table标签中使用tr来表示表格中的一行，有几行就有几个tr，在tr中需要使用td来创建一个单元格，有几个单元格就有几个td
rowspan用来设置纵向的合并单元格
colspan横向的合并单元格
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border="1" width="40%" align="center"&gt; &lt;td&gt;A1&lt;/td&gt; &lt;td&gt;A2&lt;/td&gt; &lt;td&gt;A3&lt;/td&gt; &lt;td&gt;a4&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;B1&lt;/td&gt; &lt;td&gt;B2&lt;/td&gt; &lt;td&gt;B3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;B1&lt;/td&gt; &lt;td&gt;B2&lt;/td&gt; &lt;td&gt;B3&lt;/td&gt; &lt;!-- rowspan用来设置纵向的合并单元格--&gt;	&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;C1&lt;/td&gt; &lt;td&gt;C2&lt;/td&gt; &lt;td&gt;C3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;!-- colspan横向的合并单元格--&gt; &lt;td colspan="4"&gt;D1&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 二、设置表格样式 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt;	/*设置表格的宽度 */	table{ width: 300px; /*居中*/ margin: 0 auto; /*边框*/ border:1px solid black; /*table和td边框之间默认有一个距离 通过border-spacing属性可以设置这个距离 */ /* 需求一： 设置表格的边框，要单线边框 */ /* 方法一 */ /* border-spacing:0px ; */	/* 方法二 border-collapse [kə'læps] 可以用来设置表格的边框合并 如果设置了边框合并，则border-spacing自动失效 */ border-collapse:collapse; /*需求二：设置背景色样式*/ /* background-color: #bfa; */ } /* 设置边框 */ td , th{ border: 1px solid black; } /* 需求三： 设置隔行变色*/ tr:nth-child(even){ background-color: #bfa; } /* 需求四： 鼠标移入到tr以后，改变颜色 */ tr:hover{ background-color: #ff0; } /* 需求五：调整td文字在表格中的位置 */ td{ height: 50px; vertical-align: top; /* 可选值：top,bottom,middle */ text-align: center; /* 可选值：left，center，bottom */ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a307df4008e42bd3306464f93423a5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18258cdb2e939c4c92da626e97db3c91/" rel="bookmark">
			CSS中背景设置——渐变色和放射渐变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		渐变：通过渐变可以设置一些复杂的背景颜色，可以从实现一个颜色向其他颜色过渡的效果
渐变是图片，通过 background-image设置
一、渐变色 可选值
1： linear-gradient ['ɡreidiənt]，线性渐变，颜色沿着一条直线发生变化
语法：linear-gradient(方位,颜色1,颜色2)
参数1:表示方位，（可选值，不写默认是to bottom）
(1)to left，to right, to bottom, to top
(2)xxxdeg 表示角度，度数，会更灵活
(3)turn 表示圈 .5turn
参数2:颜色1
参数3:颜色2
注意：可以写多个颜色，默认情况下，颜色是均分占比的，也可以手动的指定渐变的分布情况，例如：background-image:linear-gradient(red 50px,yellow) ，颜色后直接跟占比
2:repeating-linear-gradient() 可以平铺的线性渐变
background-image: repeating-linear-gradient(yellow 0px, red 50px);
参数跟linear-gradient是一样的
参数2-参数1，中间部分是渐变的颜色，拿总高度/差值，就是颜色重复出现的次数
二、放射渐变 —经向渐变（放射性的效果） radial-gradient() ['reidiəl] ['ɡreidiənt]
语法：background-image: radial-gradient();
默认情况下，圆心是根据元素的形状来计算的
正方形--&gt;圆形
长方形--&gt;椭圆型
参数1:圆心的形状
（1）circle圆形，ellipse椭圆，
（2）设置的大小 at 位置==&gt;像素1 像素2 at 0px 0px
参数2:颜色1
参数3:颜色2
······
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18258cdb2e939c4c92da626e97db3c91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc1ae95a68de9f8f1a3317234658c5bb/" rel="bookmark">
			TDengine 公布 2023 年发展“成绩”，六大亮点引人瞩目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天，我们进行了 2023 年重大成就和发展成绩盘点，主要归纳为产品创新、市场发展、开源社区、生态建设、活动布道与奖项荣誉六大维度。在元旦前夕，我们也想把这份“2023 年成绩单”分享给所有关注 TDengine 的朋友们。
在今年，最值得一提的大事件就是伴随着六月的网站改版，TDengine 正式升级为高性能、分布式的物联网、工业大数据平台，提供可私有化部署的 TDengine Enterprise 以及全托管的物联网、工业大数据云服务平台 TDengine Cloud 两大版本，在开源、云原生的时序数据库（Time Series Database） TDengine OSS 基础上增加了企业必需的大数据处理功能。经历此次优化后，无论是个人开发者、中小企业还是大企业，都可根据自身业务体量和需求进行版本选择，轻松体验 TDengine 的强大功能。
在产品创新上，TDengine 3.0 自去年 8 月发布以来，已经被大量开发者下载使用，针对其中的一些反馈，TDengine 团队持续对产品进行了优化调整。2023 全年，TDengine 3.0 经历了 7 次版本迭代，共在 13 个方向上增加了新功能，包括“索引”“流计算”“数据订阅”“梳理权限”“数据接入平台”和“可视化管理”等，极大地便利了用户的使用；在产品性能和稳定性方面，TDengine 在“三副本稳定”“客户端占用缓存大小可控”“多级存储故障恢复”“Schemaless 写入”“snapshot 传输效率提升”“高基数场景下的查询性能提升”等 14 个维度进行了功能加强，助力用户更高效地进行数据管理和查询。
为了验证 TDengine 3.0 的性能，TDengine 利用第三方性能基准测试平台 Time Series Benchmark Suite (TSBS) 对 TDengine、InfluxDB、TimescaleDB 进行了性能测试。测试分别针对 DevOps 场景和 IoT 场景进行，从数据写入、数据查询、数据存储和资源消耗四个维度进行了对比，并输出了测试结果。测试结果显示，不管是在 DevOps 场景还是在 IoT 场景下，TDengine 性能均远超另外两大数据库，这项测试也进一步验证了 TDengine 3.0 在性能方面的优势。
除 TDengine 3.0 的优化外，去年 9 月发布的 TDengine Cloud 在今年也获得了进一步发展。在继 Microsoft Azure、AWS、Google Cloud 三大公有云之后，TDengine Cloud 今年正式上线了第四个公有云平台——阿里云，实现了更全面的云服务网络覆盖。据了解，TDengine Cloud 目前在全球已经发展了千余家企业，为了便于更多用户的订购使用，其在今年不仅上线了阿里云 Marketplace，还入驻了 AWS Marketplace（海外版），为国内有数字化转型和数据安全需求的企业提供了全新的数据解决方案。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc1ae95a68de9f8f1a3317234658c5bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bcf40ce95a2bafed78d5479d9202afe/" rel="bookmark">
			动态内存管理（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
4. 几个经典的笔试题
4.1 题目1：
4.2 题目2：
4.3 题目3：
4.4 题目4：
5. C/C++程序的内存开辟
6. 柔性数组
6.1 柔性数组的特点：
6.2 柔性数组的使用
6.3 柔性数组的优势
4. 几个经典的笔试题 4.1 题目1： void GetMemory(char *p) { p = (char *)malloc(100); } void Test(void) { char *str = NULL; GetMemory(str); strcpy(str, "hello world"); printf(str); } 请问运行Test 函数会有什么样的结果？ 报错
正确代码如下
void GetMemory(char** p) { *p = (char*)malloc(100); } void Test(void) { char* str = NULL; GetMemory(&amp;str); strcpy(str, "hello world\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bcf40ce95a2bafed78d5479d9202afe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/632a56d5ca9884cb87f3f6958f9692c6/" rel="bookmark">
			H5向微信小程序发送信息(小程序web-view打开H5)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 引入weixin-js-sdk
npm i weixin-js-sdk 页面引入
// 引入wxjs import wx from "weixin-js-sdk"; 点击触发方法
methods: { goweap(id){ console.log(wx); // H5传递数据 （navigateBack） wx.miniProgram.navigateBack({delta: 1}); wx.miniProgram.postMessage({ data: { id: id } }); }, } 小程序接收信息
&lt;web-view bindmessage="getMessage" src="http://localhost:8080" /&gt; getMessage(e:any){ console.log("\(^o^)/~",e); }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a417f0e5de9d999b9950deffedac592/" rel="bookmark">
			Graph Transformer2023最新研究成果汇总，附15篇必看论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图Transformer是一种结合了Transformer模型和图神经网络（GNN）的框架，用于在图形结构数据上执行预测任务。在图Transformer中，Transformer的自注意力机制被用来学习节点之间的关系，而GNN则被用来生成节点的嵌入表示。通过这种方式，图Transformer能够捕捉到图中节点的远程依赖关系，从而有效地对大规模图数据进行建模和预测。这种设计避免了引入中间层的任何结构化偏置，从而显著增强了图数据的表达能力。
今天我就帮同学们整理了Graph Transformer今年以及以往的一些值得一看的研究成果，目前共有15篇，想在这个方向发论文找创新点的同学们建议收藏。
论文和代码需要的看文末
1.Are More Layers Beneficial to Graph Transformers 更多的层对图Transformer有益吗？
「简述：」论文研究了图Transformer的深度问题，发现现有的图Transformer相对较浅。作者发现增加层数并不能提高性能，因为深图Transformer受到全局注意力的限制。为了解决这个问题，作者提出了一种名为DeepGraph的新模型，它使用子结构令牌和局部注意力来增强表示的表达能力。实验表明，作者的方法解除了图Transformer的深度限制，并在各种基准测试中取得了最先进的性能。
2.Graph Inductive Biases in Transformers without Message Passing 不使用消息传递的Transformer中的图归纳偏置
「简述：」图数据的Transformer越来越受欢迎，并在许多学习任务中取得了成功。先前的工作通过消息传递模块和/或位置编码来引入图的归纳偏差。但是，使用消息传递的图Transformer存在已知的问题，并且与其他领域的Transformer有显著差异，这使得研究进展的转移更加困难。另一方面，没有消息传递的图Transformer在较小的数据集上通常表现不佳，而在这样的数据集中，归纳偏差更为重要。为了填补这一空白，作者提出了一种新的图Transformer——图归纳偏差Transformer（GRIT），它不需要使用消息传递就可以引入图的归纳偏差。GRIT具有表达能力，可以表达最短路径距离和各种图传播矩阵。它在各种图形数据集上实现了最先进的实证性能，从而展示了不使用消息传递的图变换器所能提供的强大功能。
3.Exphormer: Sparse Transformers for Graphs 用于图形的稀疏Transformer
「简述：」图Transformer是一种有前途的架构，用于各种图形学习和表示任务。本文介绍了一个名为EXPHORMER的框架，用于构建强大和可扩展的图Transformer。它基于虚拟全局节点和扩展器图的稀疏注意力机制，具有线性复杂度和理想的理论性质。将EXPHORMER集成到GraphGPS框架中，可以在广泛的图形数据集上获得有竞争力的结果，包括在三个数据集上取得最先进的结果。此外，EXPHORMER还可以扩展到更大的图形数据集上。
4.Simplifying and Empowering Transformers for Large-Graph Representations 简化和增强大型图表示的Transformer
「简述：」学习大型图的表示是一个长期存在的挑战，因为涉及大量数据点的相互依存性质。本文介绍了一种名为SGFormer的简化图形Transformer，它使用一个简单的注意力模型来高效地在不同节点之间传播信息，成本仅为一层传播层和与节点数量线性复杂度相比极小的计算量。SGFormer不需要位置编码、特征/图预处理或额外的损失。在实证上，SGFormer成功地扩展到了网页规模的ogbn-papers100M图，并在中等规模图上比SOTA Transformers实现了高达141倍的推理加速。
5.DIFFormer: Scalable (Graph) Transformers Induced by Energy Constrained Diffusion 能量约束扩散引起的可扩展（图）Transformer
「简述：」现实世界的数据生成通常涉及实例之间的复杂相互依赖关系，违反了标准学习范式的IID数据假设。为了解决这个问题，作者提出了一种能量受限扩散模型，将数据集中的一批实例编码为逐渐包含其他实例信息进化状态。扩散过程受到关于实例表示在潜在结构上的全局一致性的原理能量函数的约束。作者提出了一种新的神经网络编码器类别，称为DIFFORMER（基于扩散的Transformer），包括两个实例：一个具有线性复杂度的简单版本，适用于数量庞大的实例；另一个用于学习复杂结构的版本。实验表明，该模型作为通用编码器骨干具有广泛的应用性，并在各种任务中表现出优越的性能。
6.GraphGPS: General Powerful Scalable Graph Transformers 通用的强大可扩展图Transformer
「简述：」论文提出了一种新的图形Transformer架构，名为GPS，它具有线性复杂性和在各种基准测试中的最先进结果。以前的图形Transformer受限于小型图形，而作者提出的架构对大型图形也有效。该架构由三个主要部分组成：位置/结构编码、局部消息传递机制和全局注意力机制。作者提供了一个模块化框架，支持多种类型的编码，并在小型和大型图形中都高效且可扩展。
7.Structure-Aware Transformer for Graph Representation Learning 用于图表示学习的结构感知Transformer
「简述：」论文提出了Structure-Aware Transformer，用于图表示学习。该方法通过从每个节点提取子图表示并将其纳入自注意力机制中来捕捉结构信息。作者提出了几种自动生成子图表示的方法，并证明所得表示具有表现力。在实验上，该方法在五个图预测基准测试中实现了最先进的性能。作者的结构感知框架可以与现有的GNN结合使用，从而系统地提高性能。
8.NodeFormer: A Scalable Graph Structure Learning Transformer for Node Classification 用于节点分类的可扩展图结构学习Transformer
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a417f0e5de9d999b9950deffedac592/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f1303679e737d57077429d8c1f43ebb/" rel="bookmark">
			GoLang学习之路，对Elasticsearch的使用，一文足以（包括泛型使用思想）（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		书写上回，上回讲到，Elasticsearch的使用前提即：语法，表结构，使用类型结构等。要学这个必须要看前面这个：GoLang学习之路，对Elasticsearch的使用，一文足以（包括泛型使用思想）（一），因为这篇是基础！！！！！！！
文章目录 使用ElasticSearch`使用前提`使用API实现对Elasticsearch的增删改查创建客户端创建yaml文件创建客户端将配置文件加载到客户端对象中 创建索引结构定义客户端结构体定义创建索引结构的方法写一个测试方法插入一条数据的方法判断是否存在索引，不存在就创建一个批量处理方式一测试 方法二方式三 查询 使用ElasticSearch 使用前提 必须要有一个ElasticSearch服务器必须要有一个可视化工具安装API包，"github.com/elastic/go-elasticsearch/v8" import "github.com/elastic/go-elasticsearch/v8" 但是这个包下面其实还有一些包，这些包非常的重要。当时我在使用的时候，根本不知道，走了不少的弯路的，找了官网的文档，又找了一些博客，都没有详细的说明情况和要点。要不就少些，要不就只把部分给列出来。但是现在我将这些无私的奉献给各位。
因为这个v8的包非常的多，所以很难将所有的放进去。这里我做一些解释：
客户端： 调用NewDefaultClient()和NewClient(cfg Config)方法会返回一个普通客户端 NewDefaultClient() 不需要去配置链接时的配置参数，默认参数链接，并返回一个普通客户端NewClient(cfg Config)需要按照总共需要的配置需求去配置参数，并返回一个普通客户端 调用NewTypedClient(cfg Config)会返回一个属性客户端（相比普通客户端强大，但是有局限，后面再说） 工具包： 这个工具包主要是普通客户端进行调用的，使用的范围是对于批量处理数据的情况 参数类型包： 我们在对ElasticSearch进行处理的时候会有很多中情况： 首先是对于语法的选择，ElasticSearch有独属于他自己的一套语法。查询时会有很多选择，比如对于字段是模糊查询，还是精确查询，还是对地图进行查询。这些参数都有，也有对于AI进行处理的参数。（建议下一个翻译软件，去看看。那个参数太多了。。。也就是说功能非常齐全） …很多内容在GoLang学习之路，对Elasticsearch的使用，一文足以（包括泛型使用思想）（一）
接下来正式开始
使用API实现对Elasticsearch的增删改查 为了实现这些CRUD，我总结了几个基本的使用步骤。（可以不按我这个创建客户端）
创建客户端 生成yaml配置文件读取配置文件信息，并保存到客户端上 创建索引结构插入数据然后调用API 创建客户端 根据上面所说，客户端在创建的时候，分为两种，一种为普通客户端，一种是属性客户端。而后者的功能更为强大。但是前者的某些功能，属性客户端是没办法的。比如批量处理数据（bulk）
在实际的生产中我们需要创建两个客户端，以便我们在需求变化中获取主动权。
创建yaml文件 文件名： config.yaml
文件中的参数按自己配，千万别一样，你们是连不上 的。
es: adders: - http://8.210.237.26:9200 username: elastic password: +Svn3a*I*b2xxbCe9 yaml 中为何要实现数组结构，其本质是，Elasticsearch为了给以后分布式扩展提供渠道。到时候只要将IP地址，填充到配置文件就可以了
创建客户端 建议可以看看配置方法中的源码。
import ( myElasticSearch "elasticsearch/common/esll" "github.com/elastic/go-elasticsearch/v8" "net" "net/http" "time" ) type ESConfig struct { Adders []string `mapstructure:"adders" json:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f1303679e737d57077429d8c1f43ebb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2778f5defb267ea9e41f0900081ea629/" rel="bookmark">
			Java系列-HTTP和HTTPS 的实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP（Hypertext Transfer Protocol）和HTTPS（Hypertext Transfer Protocol Secure）是用于在网络上传输数据的两种协议，它们在实现原理和安全性上有一些关键的区别。
HTTP 的实现原理： 1. 无连接性：HTTP 是一种无连接协议，每个请求都是独立的，服务器不会保留客户端的任何信息。这导致每个请求都需要重新建立连接，可能会增加延迟。
2. 无状态性：HTTP 是一种无状态协议，即每个请求之间没有关联，服务器不会保存客户端的状态信息。每个请求都是独立的，服务器无法识别两个请求是否来自同一用户。
3. 明文传输：HTTP 数据是以明文形式传输的，可能会被中间人窃听，存在安全隐患。
HTTPS 的实现原理： 1. 加密通信：HTTPS 在HTTP 的基础上加入了 SSL/TLS 协议，通过使用加密算法保护数据的传输过程，使得中间人无法轻易窃听和篡改数据。SSL/TLS 使用公钥和私钥进行加密和解密，确保通信的机密性。
2. 数字证书：HTTPS 使用数字证书来验证服务器的身份，确保客户端连接的是真实的服务器而不是恶意伪装的服务器。证书是由可信任的证书颁发机构（CA）签发的，客户端会保存一组信任的 CA 证书，用于验证服务器提供的数字证书的合法性。
3. 握手过程：在建立连接时，HTTPS 还需要进行握手过程，包括协商加密算法、生成临时密钥等。这个过程确保了通信的安全性。
4. 端口：HTTP 默认使用端口80，而 HTTPS 默认使用端口443。
5. 性能影响： 由于加密和握手的过程会增加通信的开销，HTTPS 在性能上可能相对于 HTTP 有一些影响。然而，随着硬件和协议的改进，这种影响逐渐减小。
总的来说，HTTPS 在HTTP 的基础上引入了加密、身份验证和数据完整性保护等机制，使得数据传输更加安全可靠。它适用于需要保护用户隐私和防止信息泄露的场景，例如网上购物、银行交易等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e44410158b71a34e84afc709603ced09/" rel="bookmark">
			计网_05IP地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、IP地址　１、IP地址基本概念 用于标识网络中的某一台主机或某一个网络接口，主机的唯一标识，保证主机间的正常通信（主机之间要想通信就必须配置相应的IP地址）
一种网络编码，用来确定网络中的一个节点或一个网络接口
IP地址由32位二进制组成，为方便记忆，8位为一组，以点进行分割，转换为十进制。
192.168.2.34 1100000.10101000.0000 0010.0010 0010 2、IP地址的组成 网络部分：用于标识网络的范围主机部分：用于标识网络范围中的一个节点 网络部分越长，表示网络范围越小；网络部分越短，表示网络范围越大
二、IP地址分类 1、公有IP地址分类 A类 ：网络地址8位，主机地址24位 A类地址以0开头
A类地址的第一个8位组范围0-127（0000 0001 ~ 0111 1111）
由于0代表本地网络，127一般用于回路检测，最终范围1.0.0.0 ~ 126.255.255.255
在A类地址中网络数有126个，主机数2^24个B类：网络地址16位，主机地址16位 B类地址以10开头
B类地址的第一个8位组范围128~191（1000 0000~1011 1111）
B类地址的范围：128.0.0.0 ~ 191.255.255.255
网络部分范围：128.255~191.255
主机部分个数：2^16C类：网络地址24位，主机地址8位 C类地址以110开头
C类地址的第一个8位组范围192~223（1100 0000 ~ 1101 1111）
C类地址的范围：192.0.0.0 ~ 223.255.255.255
网络部分：192.0.0~223.255.255
主机部分个数：2^8 2、私有IP地址分类 A类：10.0.0.0~10.255.255.255B类：172.16.0.0~172.31.255.255C类：192.168.0.0~192.168.255.255私网地址是不能够在公网上 直接路由的，需要网络地址转换将私网的地址转换为公网地址后才能访问公网上面的内容。 三、子网掩码 1、概念 什么是子网掩码 子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在外网上。子网掩码有什么用？ 子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。子网掩码不能单独存在，它必须结合IP地址一起使用。IP地址是计算机在网络内的唯一标识，而子网掩码是用于划分子网的。 2、主机地址和网络地址 根据子网掩码来得出网络部分和主机部分 子网掩码由连续的1和0组成，连续的1表示网络地址部分，连续的0表示主机地址部分通过0的个数可以计算出子网的容量（子网中主机的IP地址范围）IP地址172.16.20.222子网掩码255.255.0.0 子网掩码由16个1和16个0组成，16个0表示子网掩码划分出的子网为2的16次方个，也就是172.16.0.0-172.16.255.255都在同一子网中；其中网络地址是172.16.0.0，广播地址是172.16.255.255，可用地址的范围是172.16.0.1-172.16.255.254，因为规定每个子网的第一个地址是网络地址，最后一个IP地址是广播地址，都不可用。即对于网段172.16.0.0，如果子网掩码设置255.255.0.0,172.16.0.1-172.16.255.254位可用地址，设置这个范围内的IP地址，计算机之间能正常联网。​​​​​​​IP地址和子网掩码进行逻辑运算 逻辑与运算规则：全1为1，有0得0。网络地址：将32位的子网掩码与IP地址进行二进制形式的按位逻辑“与”运算主机地址：将子网掩码二进制按位取反，然后与IP地址二进制进行逻辑“与”运算 3、子网掩码分类 默认子网掩码 A 255.0.0.0B 255.255.0.0C 255.255.255.0不规则的子网掩码 IP地址192.168.100.233子网掩码为255.255.224.0
255.255.224.0对应的二进制位1111 1111.1111 1111.1110 0000.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e44410158b71a34e84afc709603ced09/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/5/">«</a>
	<span class="pagination__item pagination__item--current">6/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/7/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>