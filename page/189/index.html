<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/114a17ec5056de0273dbaf375949d639/" rel="bookmark">
			基于Power BI的终端产品销售ABC分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、原理
ABC分析，是由帕累托法则演化而来，一般认为A类产品带来70%的收入，B类产品带来20%的收入，C类产品带来10%的收入，所以ABC分析又称70/20/10分析。
二、数据源
某终端《8~10月商品月台帐》
问题：
1、8~10月产品销售金额ABC分析
2、8~10月月度销售金额ABC分析
三、步骤
步骤一：数据获取与数据整理
步骤二：8~10月产品销售ABC分析
表：商品销售汇总表
1、新建表，商品销售汇总表 = SUMMARIZE('商品月台帐','商品月台帐'[商品名称],'商品月台帐'[商品条码],"销售金额",SUM('商品月台帐'[金额]))
2、新建列，累积销售金额 = SUMX(FILTER('商品销售汇总表','商品销售汇总表'[销售金额]&gt;=EARLIER('商品销售汇总表'[销售金额])),'商品销售汇总表'[销售金额])
3、新建列，销售总金额 = SUM('商品销售汇总表'[销售金额])
4、新建列，累积占比 = DIVIDE('商品销售汇总表'[累积销售金额],'商品销售汇总表'[销售总金额])
5、新建列，ABC分类 = SWITCH(TRUE(),'商品销售汇总表'[累积占比]&lt;=0.7,"A",'商品销售汇总表'[累积占比]&lt;=0.9,"B","C")
6、生成可视化图表-折线图和堆积柱形图
步骤三：8~10月月度销售金额ABC分析
表：月度商品销售汇总
1、新建表，月度商品销售汇总 = SUMMARIZE('商品月台帐','商品月台帐'[月份],'商品月台帐'[月份编号],'商品月台帐'[商品名称],'商品月台帐'[商品条码],"销售金额",SUM('商品月台帐'[金额]))
2、新建列，月度累积销售金额 = SUMX(FILTER('月度商品销售汇总','月度商品销售汇总'[月份]=EARLIER('月度商品销售汇总'[月份]) &amp;&amp; '月度商品销售汇总'[销售金额]&gt;=EARLIER('月度商品销售汇总'[销售金额])),'月度商品销售汇总'[销售金额])
3、新建列，月度销售总金额 = SUMX(FILTER('月度商品销售汇总','月度商品销售汇总'[月份]=EARLIER('月度商品销售汇总'[月份])),'月度商品销售汇总'[销售金额])
4、新建列，月度累积占比 = DIVIDE('月度商品销售汇总'[月度累积销售金额],'月度商品销售汇总'[月度销售总金额])
5、新建列，ABC分类 = SWITCH(TRUE(),'月度商品销售汇总'[月度累积占比]&lt;=0.7,"A",'月度商品销售汇总'[月度累积占比]&lt;=0.9,"B","C")
6、生成可视化图表-折线和堆积柱形图、切片器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2158276483e57a5519dfbae280b5edd0/" rel="bookmark">
			openpilot 项目解析及 xgnpilot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是openpilot Openpilot 是L2.5级的自动驾驶辅助系统，由 comma.ai 公司研发并开源，它主要使用 Python/C++ 语言开发，地址：https://github.com/commaai
项目结构 ├── cereal # 消息队列，各个组件通过它相互通信 ├── common # 公共库 ├── docs # 项目文档 ├── opendbc # 汽车can数据解析文件 ├── panda # 接收和发送can信号 ├── third_party # 项目使用到的三方库 ├── pyextra # 扩展python包 └── selfdrive # 辅助驾驶核心实现代码 ├── assets # 控制UI使用到的资源文件 ├── athena # app通信(上传、通信) ├── boardd # 与panda通信(接收与发送车辆、控车数据) ├── camerad # 通过摄像头器件捕获图像用于模型使用 ├── car # 车辆特有实现代码，获取车辆状态和发送控车指令 ├── common # 公共库 ├── controls # 路径规划和执行(核心辅助逻辑实现) ├── debug # 帮助调试 ├── locationd # 坐标定位和车辆参数估测 ├── logcatd # 系统日志获取并发送 ├── loggerd # 记录并上传车辆行驶记录 ├── modeld # 行驶和驾驶员监控模型执行 ├── proclogd # 进程状态获取 ├── sensord # IMU interface code ├── test # 系统测试 └── ui # 辅助控制系统UI 大概在2022年10月份了解到这个开源项目，经过一段时间的学习，大致了解了openpilot(简称op)运作原理并基于openpilot-0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2158276483e57a5519dfbae280b5edd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ef245babd8d517c67fa04816949a302/" rel="bookmark">
			【MySQL基础】MySQL介绍及安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 第1篇：【MySQL基础】MySQL介绍及安装
第2篇：【MySQL基础】MySQL基本操作详解
文章目录
✍1，数据库相关概念
✍2，MySQL数据库
🔍2.1,版本
🔍2.2,下载
🔍2.3,安装
🔍2.4,配置
🔍2.5,启动停止
🔍2.6,客户端连接
✍3，数据模型
🔍3.1,关系型数据库
🔍3.2,数据模型
前言 大家好，我是小杨！今天我将给大家讲解一下MySQL的基本知识并详细的为大家介绍MySQL数据库的详细安装过程，希望大家能够从中收获多多！
MySQL概述 1，数据库相关概念 名称全称说明数据库DataBase（DB）存储数据的仓库，数据是有组织地进行存储数据库管理系统DataBase Management System(DBMS)操纵和管理数据库的大型软件SQLStructured Query Language (SQL)操作关系型数据库的编程语言，定义了一套操作关系型数据库统一 标准。 而目前主流的关系型数据库管理系统的市场占有率排名如下：
Oracle：大型的收费数据库，Oracle公司产品，价格昂贵。
MySQL：开源免费的中小型数据库，后来Sun公司收购了MySQL，而Oracle又收购了Sun公司。
目前Oracle推出了收费版本的MySQL，也提供了免费的社区版本。SQL Server：Microsoft 公司推出的收费的中型数据库，C#、.net等语言常用。
PostgreSQL：开源免费的中小型数据库。
DB2：IBM公司的大型收费数据库产品。
SQLLite：嵌入式的微型数据库。Android内置的数据库采用的就是该数据库。
MariaDB：开源免费的中小型数据库。是MySQL数据库的另外一个分支、另外一个衍生产品，与MySQL数据库有很好的兼容性。
注意：不论我们使用的是上面的哪一个关系型数据库，最终在操作时，都是使用SQL语言来进行统一操作，因为我们前面讲到SQL语言，是操作关系型数据库的 统一标准 。所以即使我们现在学习的是MySQL，假如我们以后到了公司，使用的是别的关系型数据库，如：Oracle、DB2、SQLServer，也完全不用担心，因为操作的方式都是一致的。
2，MySQL数据库 2.1，版本 MySQL官网：MySQL
MySQL官方提供了两种不同的版本：
社区版本（MySQL Community Server）
免费， MySQL不提供任何技术支持
商业版本（MySQL Enterprise Edition）
收费，可以使用30天，官方提供技术支持
2.2，下载 MySQL下载地址：MySQL
1，点击GPL
2，下载window版本MySQL
3，选择下载方式
第一个是在线安装，安装时需要连接网络第二个是离线安装，我们直接选择离线安装 4，直接开始下载
2.3，安装 要想使用MySQL，我们首先先得将MySQL安装好，我们可以根据下面的步骤，一步一步的完成MySQL的安装。
1). 双击官方下来的安装包文件
2). 根据安装提示进行安装
选择设置类型 ​ 双击运行mysql-installer-community-8.0.26.0.msi，这里选择是自定义安装，所以直接选择“Custom”，点击“Next”
“Developer Default”是开发者默认
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ef245babd8d517c67fa04816949a302/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fffa35ec08886a77863066612474035/" rel="bookmark">
			【MySQL基础】MySQL基本操作详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 第1篇：【MySQL基础】MySQL介绍及安装
第2篇：【MySQL基础】MySQL基本操作详解
文章目录
✍1，数据库操作
🔍1.1,查看数据库
🔍1.2,创建数据库
🔍1.3,选择数据库
🔍1.4,删除数据库
✍2，数据表操作
🔍2.1,创建数据表
🔍2.2,查看数据表
🔍2.3,查看表结构
🔍2.4,修改数据表
🔍2.5,修改表结构
🔍2.6,删除数据库
✍3，数据操作
🔍3.1,增加数据
🔍3.2,查询数据
🔍3.3,修改数据
🔍3.4,删除数据
✍4，其他操作
🔍4.1,安装目录位置显示
🔍4.2,数据目录位置显示
🔍4.3,错误日志目录查询
前言 大家好，我是小杨！今天我将详细的为大家介绍MySQL数据库的基本操作，希望大家能够从中收获多多！
MySQL基本操作 1，数据库操作 1.1，查看数据库 1）查看MySQL服务器下所有数据库
SHOW DATABASES; 具体SQL语句操作：
information_schema数据库是MySQL服务器的数据字典（保存所有数据表和库的结构信息）performance_schema数据库是MySQL服务器的性能字典（保存全局变量等的设置）mysql 主要负责MySQL服务器自己需要使用的控制和管理信息（用户的权限关系等）sys是系统数据库，包括了存储过程，自定义函数等信息 切记：这4个数据库是MySQL安装时自动创建的，建议不要随意的删除和修改这些数据库，避免造成服务器故障。
2）查看指定数据库的创建信息
SHOW CREATE DATABASE 数据库名称; 若想查看sys数据库的信息：
显示sys数据库的SQL语句，以及数据库的默认字符集 3）查看当前数据库
SELECT DATABASE(); 具体SQL语句操作：
切记：在输入当前数据库查询的SQL语句前，必须先选择数据库。
1.2，创建数据库 CREATE DATABASE [IF NOT EXISTS] 数据库名称[库选项]; 切记：
语法内使用’[ ]'括起来的选项表示可选参数。
数据库名称是由字母，数字和下划线组成的任意字符串。
库选项用于数据库的相关特性，例如字符集CHARSET，校对集COLLATE。
创建的数据库的默认字符集为latinl，校对集为latinl_swedish_ci。
不可重复创建相同的数据库，如果创建的数据库已存在，则程序会报错。
为了防止上述情况，在创建数据库时在数据库名称前添加IF NOT EXISTS,表示当指定的数据库不存在时执行创建操作,否则忽略此操作。
具体SQL语句操作：
1.3，选择数据库 USE 数据库名称; 具体SQL语句操作：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fffa35ec08886a77863066612474035/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da1f6f11a70c11c86e6c8e6ec7cf6ea9/" rel="bookmark">
			Vue实现顶部的历史记录标签栏（后续新增标签栏右击快速关闭的效果）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速关闭功能见此页
https://blog.csdn.net/m0_74149462/article/details/128742833?spm=1001.2014.3001.5502
默认展示首页，且首页一直固定在左侧
store/module/historyModule.js（注意文件路径，根据实际情况修改代码）
const SET_TABSVIEW = 'SET_TABSVIEW' const DEL_TABSVIEW = 'DEL_TABSVIEW' export default { state: { visitedTabsView: [ { name: "首页", path: "/home" } ], // 保证每次刷新都能有最原始的一个首页的标签 }, mutations: { [SET_TABSVIEW](state: any, view: any) { if (state.visitedTabsView.find((n: any) =&gt; n.path === view.path)) { return } state.visitedTabsView.push({name: view.meta.title, path: view.path}) }, [DEL_TABSVIEW](state: any, view: any) { state.visitedTabsView.forEach((item: any, index: any) =&gt; { if (item.name === view.name &amp;&amp; item.path === view.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da1f6f11a70c11c86e6c8e6ec7cf6ea9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22247042d0c914b4c72cef1c956eae21/" rel="bookmark">
			加密图片本地解密后使用blod文件打开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常开发中，我们常常需要对一些文件进行加密，例如：图片等资源。例如: 某书就对一些资源进行了加密，然后通过对应的密钥解密后，然后通过blod打开（blod路径少，base64的路径太长了）。当然，我们在这里也不会对其加密解密进行分析。我们可以学习下加密图片本地解密后转为blod本地路径。 话不多说，直接上思路 发送请求拉取加密数据 this.$axios({ url: this.fileUrl, method: "GET" }).then(function(e) { // 这里对加密的数据进行解密，具体实现看自己的业务设计 const base64 = decryptFn(e); //decryptFn这里就是解密的函数,这里我们可以将其转为base64 }).catch(function(t) {}) base64转为Blob // 这里用的参数 就是上面解密后的base64文件 dataURLtoBlob(base64) { var base64Arr = base64.split(","); var imgtype = ""; var base64String = ""; if (base64Arr.length &gt; 1) { //如果是图片base64，去掉头信息 base64String = base64Arr[1]; imgtype = base64Arr[0].substring( base64Arr[0].indexOf(":") + 1, base64Arr[0].indexOf(";") ); } // 将base64解码 var bytes = atob(base64String); //var bytes = base64; var bytesCode = new ArrayBuffer(bytes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22247042d0c914b4c72cef1c956eae21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdfd7378b52ac3325a77fa9a9a3a3e70/" rel="bookmark">
			查看本地SVN的帐号和密码（附免费查看软件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.下载查看密码软件
2.寻找svn账号密码文件夹
3.复制查看密码软件到svn账号密码文件夹,并运行exe
先看效果
1.下载查看密码软件 1.访问下载
https://dyy1.jb51.net/202007/tools/TSvnPwd_jb51.rar
2.寻找svn账号密码文件夹 1.默认路径C:\Users\Administrator\AppData\Roaming\Subversion\auth\svn.simple
Administrator是需要查看的电脑用户，每个人的电脑用户名不一致
2.当你发现路径上的文件夹不存在时，点击查看隐藏文件
3.复制查看密码软件到svn账号密码文件夹,并运行exe 出现命令窗口，其中有账号及密码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2805451e82a4e8c67c898ac4491bdcce/" rel="bookmark">
			OpenCV中线段、矩形、圆形、多边形的讲解与绘制实战（附Python源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要源码请点赞关注收藏后评论区留言私信~~~
OpenCV提供了许多绘制图形的方法，包括绘制线段的line()方法、绘制矩形的rectangle()方法、绘制圆形的circle()方法、绘制多边形的polylines()方法和绘制文字的putText()方法。下面将依次对上述各个方法进行讲解，并使用上述方法绘制相应的图形
一、线段的绘制 OpenCV提供了用于绘制线段的line方法，使用这个方法即可绘制长短不一，粗细各异，五颜六色的线段 语法格式如下
img=cv2.line(img,pt1,pt2,color,thickness)
img画布
pt1 线段的起点坐标
pt2 线段的终点坐标
color 绘制线段时的线条颜色
thickness 绘制线段时的线条宽度
下面绘制线段并且拼成一个王字 效果如下
代码如下 import numpy as np # 导入Python中的numpy模块 import cv2 # np.zeros()：创建了一个画布 # (300, 300, 3)：一个300 x 300，具有3个颜色空间（即Red、Green和Blue）的画布 # np.uint8：OpenCV中的灰度图像和RGB图像都是以uint8存储的，因此这里的类型也是uint8 canvas = np.zeros((300, 300, 3), np.uint8) # 在画布上，绘制一条起点坐标为(50, 50)、终点坐标为(250, 50)，蓝色的，线条宽度为5的线段 canvas = cv2.line(canvas, (50, 50), (250, 50), (255, 0, 0), 5) # 在画布上，绘制一条起点坐标为(50, 150)、终点坐标为(250, 150)，绿色的，线条宽度为10的线段 canvas = cv2.line(canvas, (50, 150), (250, 150), (0, 255, 0), 10) # 在画布上，绘制一条起点坐标为(50, 250)、终点坐标为(250, 250)，红色的，线条宽度为15的线段 canvas = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2805451e82a4e8c67c898ac4491bdcce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a196d19d03b863cd570e335a4bd5f1ee/" rel="bookmark">
			C# WPF后台代码动态添加控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在wpf开发中，虽然可以通过XMAL编写炫酷的界面，但是有时候需要动态定义控件即：前台界面控件数量或者类型需要解析的数据或者其它条件确认再生成，这时候我们就需要通过后台cs中编写代码实现这一功能。
01
—
功能演示
02
—
功能说明
以上演示部分我们可以看到我前台的部分界面在窗体加载后并没有显示，而是选择文件解析后自动产生的，这种场景有时候也挺常用，特别是有大量同类型的数据显示到同类型的控件中时，我们就可以通过导入txt、Xml等文件的形式然后自动生成. 本地主要是举例演示实现这一功能，使用场景造得可能并不恰当，大家忍受下。
03
—
源码实现
前台代码：
&lt;UserControl x:Class="Caliburn.Micro.Hello.DynamicalView" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:local="clr-namespace:Caliburn.Micro.Hello" xmlns:cal="http://www.caliburnproject.org" xmlns:dxlc="http://schemas.devexpress.com/winfx/2008/xaml/layoutcontrol" mc:Ignorable="d" d:DesignHeight="450" d:DesignWidth="800"&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height="1.5*" /&gt; &lt;RowDefinition Height="8.5*" /&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width="*" /&gt; &lt;ColumnDefinition Width="*" /&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;StackPanel Orientation="Horizontal" VerticalAlignment="Center" Grid.Row="0" Grid.ColumnSpan="2"&gt; &lt;TextBox Width="500" Height="30" Margin="3" Text="{Binding FilePath}" FontSize="14" FontStyle="Normal" IsReadOnly="True" /&gt; &lt;Button Content="..." Margin="3" MinWidth="50" cal:Message.Attach="[Event Click] = [Action SelectFile()]" /&gt; &lt;/StackPanel&gt; &lt;GroupBox Grid.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a196d19d03b863cd570e335a4bd5f1ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdcb98785b57dcd99c6a30d46d3384ac/" rel="bookmark">
			对比Java,Kotlin的优点和缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简要介绍 Kotlin近来发展迅速,使得许多Java开发者转向了Kotlin,那两种语言到底对比如何呢?
下面Kotlin的优点,大部分已经在《为什么Kotlin比Java能大量减少代码》介绍了,但是为了本文的完整性,再次完整展示.
Kotlin优点 1. 简化空对象的处理(防止空指针) val userName = a?.b?.c?.d ?: ""
详细文档,可参考:《利用Kotlin优雅的解决Java的空指针问题》
2. 属性访问,代替Get/Set方法 Kotlin代码 class User { var name :String?=null } Java代码 public class User { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } 查看为什么Kotlin属性访问方式比Java的Get/Set方式好了解更多
3. 默认构造函数 Kotlin代码 class User(var name: String) Java代码 public class User { private String name; public User(String name) { this.name = name; } public String getName() { return name.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdcb98785b57dcd99c6a30d46d3384ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2583eeb68a746e67f1b672d176513dd/" rel="bookmark">
			请使用C&#43;&#43;编写程序，可以使用Eigen以及PCL相关库，写出一个使用最小二乘法对点云中的散点进行曲线拟合，最后输出拟合出曲线的三维坐标的程序...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是一个使用 C 语言和 Eigen 库对点云中的散点进行曲线拟合，最后输出拟合出曲线的三维坐标的程序示例:
#include &lt;iostream&gt; #include &lt;Eigen/Dense&gt; using namespace Eigen; int main() { // 定义点云数据 MatrixXd points(100, 3); // 在此处填充点云数据 // 最小二乘曲线拟合 VectorXd coefficients = (points.transpose() * points).ldlt().solve(points.transpose() * VectorXd::Ones(points.rows())); // 输出拟合出的曲线的三维坐标 std::cout &lt;&lt; "x = " &lt;&lt; coefficients(0) &lt;&lt; "y = " &lt;&lt; coefficients(1) &lt;&lt; "z = " &lt;&lt; coefficients(2) &lt;&lt; std::endl; return 0; } 这份代码没有使用 PCL 库，如果需要使用 PCL 请自行添加相应库的头文件。
注意：如果使用的是Eigen3，需要把Eigen::VectorXd 换成Eigen::MatrixXd。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e1eed1855774d1dec845d76634b59bf/" rel="bookmark">
			离散数学-图论-欧拉图、哈密顿图、二部图、平面图（14）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欧拉图、哈密顿图、二部图、平面图 1 欧拉图 无向图G是欧拉图 ⇔ \Leftrightarrow ⇔G连通,且无奇度点。无向图G是半欧拉图 ⇔ \Leftrightarrow ⇔G连通,且仅有两个奇度点。有向图G是欧拉图 ⇔ \Leftrightarrow ⇔G强连通,且所有顶点的入度=出度。有向图G是半欧拉图 ⇔ \Leftrightarrow ⇔G单向连通,且仅有两个奇度点，其中一个顶点的出度-人度=1,另一个顶点的入度-出度=1,其余顶点的入度=出度。 2 哈密顿图 定义：
设G=&lt;V，E&gt;是哈密顿图，则对V的每个非空子集 V 1 V_1 V1​,均有下式成立: p ( G − V 1 ) ≤ ∣ V 1 ∣ p(G-V_1) \le|V_1| p(G−V1​)≤∣V1​∣设G=&lt;V，E&gt;是半哈密顿图，则对V的每个非空子集 V 1 V_1 V1​,均有下式成立: p ( G − V 1 ) ≤ ∣ V 1 ∣ + 1 p(G-V_1) \le|V_1|+1 p(G−V1​)≤∣V1​∣+1 判断方法：
（1）定义判断
（2）G中存在哈密顿回路，是哈密顿图。（注意是哈密顿回路，不是哈密顿通路）G中存在哈密顿通路路，是半哈密顿图。
最中间的图存在哈密顿回路，则为哈密顿图，其他两边的只有哈密顿通路，则为半哈密顿图。
3 二部图 判断二部图： 无向图G=&lt;V,E&gt;是二部图 ⇔ \Leftrightarrow ⇔G中 无奇圈。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e1eed1855774d1dec845d76634b59bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/066fac5eb001ed67a1b8d706b3fa8c74/" rel="bookmark">
			python将字符串转为字典（将str类型还原为dict字典类型）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有三种方法：
eval(字符串)yaml.load(字符串, Loader=yaml.FullLoader)ast.literal_eval(字符串) 但是要注意，转换之前，原始的字典中key与value必须是python原生支持的类型，不能是datetime，pandas这种类型
示例代码 import yaml import ast dict_string = str({ "name": "小明", "age": 12, "成绩": 59.99, "入学时间": "2021-01-01", }) print(dict_string) 得到字符串dict_string的结果：
'{\'name\': \'小明\', \'age\': 12, \'成绩\': 59.99, \'入学时间\': \'2021-01-01\'}' 使用如下方法将 string字符串 -&gt; dict字典
eval(dict_string) # 方法1 yaml.load(dict_string, Loader=yaml.FullLoader) # 方法2 ast.literal_eval(dict_string) # 方法3 都可以得到想要的结果：
{'name': '小明', 'age': 12, '成绩': 59.99, '入学时间': '2021-01-01'} 但是，如果将dict_string改为：
from datetime import datetime dict_string = str({ "name": "小明", "age": 12, "成绩": 59.99, "入学时间": datetime(2021, 1, 1), }) 则结果都会出错！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4a685ce551e33e94043f6b7f4376c3a/" rel="bookmark">
			使用canvas实现前端图片裁剪功能，以vue为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天和大家分享一下我个人使用canvas实现前端图片裁剪功能的方法，canvas算是前端进阶的一个必修课了，不太了解的同学可以先去找点资料打点基础，个人对canvas的理解就是把他类比成一个画图工具，在画图工具中我们是使用可视化的界面去画图，而在canvas里则是使用代码去实现我们在可视化界面的操作进而去画图
基础实现 基础的布局和功能就不说了，相信各位都会，无非就是图片上面加一层蒙版，细节会在最后面给大家总结。图片的生成可以直接用img标签或者canvas里的drawImage方法，我这里使用的是canvas
img.src = props.imgSrc scale = props.width / img.width img.onload = function () { ctx?.drawImage(img, 0, 0, props.width * r, scale * img.height * r) } img是img标签的dom。
后两个0是生成的图片在canvas画布里的坐标，(0,0)表示左上的端点
scale是原图的宽度和你所需图片的宽度比例，在这里用于转换高度，不然你的图会被拉伸
r变量是倍率用于让canvas变清晰的，会在最后面总结
drawImage的详细api说明：https://www.w3school.com.cn/tags/canvas_drawimage.asp
后续裁剪的实现也是使用到这个drawImage方法,不熟悉的同学可以先熟悉一下
选择框的实现 先上效果图，我们需要在蒙版挖出来一个口，让底层的图片清楚的显示出来
一开始想的方法是通过设置背景颜色来达到这一效果，但发现不行，因为我的蒙版只是简单的覆盖在上面，并设置背景颜色而已，想要这样‘简单’地实现就要不简单地对蒙版进行处理，这里欢迎各位大佬想个好方法
既然挖去不行，那就可以换个思路，用裁剪的图放入选择框里面
&lt;div v-show="showBorder" class="select-content"&gt;&lt;/div&gt; // 蒙板 &lt;img v-show="isShowSelect" :src="imgSrc" class="select-img" //覆盖在蒙板上的图 :style="{ width: width + 'px', 'clip-path': clipPath }" draggable="false" /&gt; 图片的裁剪也是有两种办法：
使用上述的drawImage方法
使用css里面的clip-path属性
我这里使用的是clip-path，文档：https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7，菜鸟和w3c里的文档对这个属性的记录并不是很详细，至少我们需要的polygon这个属性没有
先来讲一下polygon：
clip-path: polygon(134px 161px, 268px 161px, 268px 236px, 134px 236px); polygon里面有四个值，分别对应左上、右上、右下、左下四个点的坐标，将图片裁剪成四个点内的内容，值得注意的是他不会改变img元素的大小，只是保留下裁剪的内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4a685ce551e33e94043f6b7f4376c3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19a11dfef9b7ac06cf87765d4ea3c8fc/" rel="bookmark">
			Error-State Kalman filter (ESKF)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卡尔曼滤波器在1960年被卡尔曼发明之后，被广泛应用在动态系统预测。在自动驾驶、机器人、AR领域等应用广泛。卡尔曼滤波器使用类似马尔可夫链的性质，假设系统状态只与上一时刻的系统状态有关。基础的卡尔曼滤波器使用线型方程对系统状态进行建模。为了能够应用到非线性系统，扩展卡尔曼滤波器利用泰勒展开，并只保留一次项，抛弃高次项，将非线性关系近似为线性关系。 1. 原理 1.1. 变量定义 1.2. 名义量预测 1.3. 误差量预测 1.4. 更新 1.5. 重置 2. 主要优点 The orientation error-state is minimal (i.e., it has the same number of parameters as degrees of freedom), avoiding issues related to over-parametrization (or redundancy) and the consequent risk of singularity of the involved covariances matrices, resulting typically from enforcing constraints.The error-state system is always operating close to the origin, and therefore far from possible parameter singularities, gimbal lock issues, or the like, providing a guarantee that the linearization validity holds at all times.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19a11dfef9b7ac06cf87765d4ea3c8fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65a4e13d21dc2fc4deded095a275f223/" rel="bookmark">
			Docker学习一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker简介 Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的Linux或Windows操作系统的机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。
一个完整的Docker有以下几个部分组成：
DockerClient客户端
Docker Daemon守护进程
Docker Image镜像
DockerContainer容器
Docker特性 在docker的网站上提到了docker的典型场景：
Automating the packaging and deployment of applications（使应用的打包与部署自动化）
Creation of lightweight, private PAAS environments（创建轻量、私密的PAAS环境）
Automated testing and continuous integration/deployment（实现自动化测试和持续的集成/部署）
Deploying and scaling web apps, databases and backend services（部署与扩展webapp、数据库和后台服务）
由于其基于LXC的轻量级虚拟化的特点，docker相比KVM之类最明显的特点就是启动快，资源占用小。因此对于构建隔离的标准化的运行环境，轻量级的PaaS(如dokku), 构建自动化测试和持续集成环境，以及一切可以横向扩展的应用(尤其是需要快速启停来应对峰谷的web应用)。
构建标准化的运行环境，现有的方案大多是在一个baseOS上运行一套puppet/chef，或者一个image文件，其缺点是前者需要base OS许多前提条件，后者几乎不可以修改(因为copy on write 的文件格式在运行时rootfs是read only的)。并且后者文件体积大，环境管理和版本控制本身也是一个问题。
PaaS环境是不言而喻的，其设计之初和dotcloud的案例都是将其作为PaaS产品的环境基础
因为其标准化构建方法(buildfile)和良好的REST API，自动化测试和持续集成/部署能够很好的集成进来
因为LXC轻量级的特点，其启动快，而且docker能够只加载每个container变化的部分，这样资源占用小，能够在单机环境下与KVM之类的虚拟化方案相比能够更加快速和占用更少资源
局限
Docker并不是全能的，设计之初也不是KVM之类虚拟化手段的替代品，简单总结几点：
Docker是基于Linux 64bit的，无法在32bit的linux/Windows/unix环境下使用
LXC是基于cgroup等linux kernel功能的，因此container的guest系统只能是linux base的
隔离性相比KVM之类的虚拟化方案还是有些欠缺，所有container公用一部分的运行库
网络管理相对简单，主要是基于namespace隔离
cgroup的cpu和cpuset提供的cpu功能相比KVM的等虚拟化方案相比难以度量(所以dotcloud主要是按内存收费)
Docker对disk的管理比较有限
container随着用户进程的停止而销毁，container中的log等用户数据不便收集
针对1-2，有windows base应用的需求的基本可以pass了; 3-5主要是看用户的需求，到底是需要一个container还是一个VM, 同时也决定了docker作为 IaaS 不太可行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65a4e13d21dc2fc4deded095a275f223/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f7b577b1ec3ee4413444a45f3cd9181/" rel="bookmark">
			Python：统计数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
题目描述
输入描述
输出描述
输入输出样例
参考代码：
sort ()与 sorted() 区别：
题目描述 某次科研调查时得到了 n 个自然数，每个数均不超过 1.5≤10^9。已知不相同的数不超过 10^4个，现在需要统计这些自然数各自出现的次数，并按照自然数从小到大的顺序输出统计结果。
输入描述 第 1 行是整数 n，表示自然数的个数。
第 2 ~ n+1行每行一个自然数。
其中，每个数均不超过 1≤n≤2×10^5，每个数均不超过1.5≤109。
输出描述 输出 m 行（ m 为 n 个自然数中不相同数的个数），按照自然数从小到大的顺序输出。每行输出两个整数，分别是自然数和该数出现的次数，其间用一个空格隔开。
输入输出样例 示例 1
输入
8 2 4 2 4 5 100 2 100 输出
2 3 4 2 5 1 100 2 参考代码： 方法1：
n = int(input()) d = {} for i in range(n): p = int(input()) #每循环一次输入一次 d[p] = d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f7b577b1ec3ee4413444a45f3cd9181/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5178323df833efe8af752182d454bbb4/" rel="bookmark">
			确定有限状态自动机（Deterministic Finite Automation）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		确定优先状态自动机（Deterministic Finite Automation, DFA）是一种计算模型。它包含一系列状态，这些状态中：
有一个特殊的状态，被称作初始状态还有一系列状态被称为接受状态，它们组成了一个特殊的集合。其中，一个状态可能既是初始状态，也是接受状态。 起初，这个自动机处于初始状态。随后，它顺序地读取字符串中的每一个字符，并根据当前状态和读入的字符，按照某个事先约定好的转移规则，从当前状态转移到下一个状态；当状态转移完成后，它就读取下一个字符。当字符串全部读取完毕后，如果自动机处于某个接受状态，则判定该字符串被接受；否则，判定该字符串被拒绝。
如果输入的过程中某一步转移失败了，即不存在对应的转移规则，此时计算将提前中止。在这种情况下我们也判定该字符串被拒绝。
确定有限状态自动机总是能够回答某种形式的**对于给定的输入字符串S，判断其是否满足条件P**的问题。
确定有限状态自动机驱动的编程，可以被看做一种暴力枚举方法的延伸：它穷尽了在任何一种情况下，对应任何的输入，需要做的事情。
自动机在计算机科学领域有着广泛的应用。在算法领域，它与大名鼎鼎的字符串查找算法KMP算法有着密切的关联；在工程领域，它是实现正则表达式的基础。
以剑指 Offer 20. 表示数值的字符串为例：
class Solution { public boolean isNumber(String s) { Map&lt;State, Map&lt;CharType, State&gt;&gt; transfer = new HashMap&lt;&gt;(); transfer.put(State.STATE_INITIAL, new HashMap&lt;CharType, State&gt;() {{ put(CharType.CHAR_SPACE, State.STATE_INITIAL); put(CharType.CHAR_NUMBER, State.STATE_INTEGER); put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT); put(CharType.CHAR_SIGN, State.STATE_INT_SIGN); }} ); transfer.put(State.STATE_INT_SIGN, new HashMap&lt;CharType, State&gt;() {{ put(CharType.CHAR_NUMBER, State.STATE_INTEGER); put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT); }} ); transfer.put(State.STATE_INTEGER, new HashMap&lt;CharType, State&gt;() {{ put(CharType.CHAR_NUMBER, State.STATE_INTEGER); put(CharType.CHAR_EXP, State.STATE_EXP); put(CharType.CHAR_POINT, State.STATE_POINT); put(CharType.CHAR_SPACE, State.STATE_END); }} ); transfer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5178323df833efe8af752182d454bbb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf7bb842799270194fc4ea7aeb24caff/" rel="bookmark">
			用ifconfig命令，只有lo，没有eth0的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
视频中输入ifconfig命令，显示eth0和lo，但是自己在虚拟机中并非得到这样的结果，而是只有lo，即网卡未启动，也没有ip，无法用Xshell远程连接。
解决方案：
1. 进入/etc/sysconfig/network-scripts 目录，发现有ifcfg-eth0，即网卡（驱动）存在但未启用。
2. 输入ifconfig -a命令，可显示eth0和lo。
3. 输入ifconfig eth0 up，启用网卡。此时用ifconfig，只能看到inet6（ipv6?）的地址，没有inet的地址（即Xshell连接输入的ip）。
4. 修改/etc/sysconfig/network-scripts/ifcfg-eth0 文件， 把ONBOOT=no 改为 ONBOOT=yes，但ifconfig的结果没有任何改变。（省略该步骤不知道是否有效）
5. service network restart，重启。出现shutdown eth0 OK，bring up eth0 OK，determine ip for eth0 OK。
6. 输入ifconfig，出现eth0的inet地址。用Xshell连接成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89b1dff70a06261e82b22c42baaedfe7/" rel="bookmark">
			《Flink入门与实战》简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《Flink入门与实战》，ApacheFlink是一个框架和分布式处理引擎，用于对无界和有界数据流进行有状态的计算，广泛应用于大数据相关的实际业务场景中。本书是一本从零开始讲解Flink的入门教材，定价89元，配套示例源码、PPT课件。
本书背景
随着物联网、5G以及大数据技术的发展，人类已经进入大数据时代，毫不夸张地说，未来IT相关的职位，一项必备技能就是大数据处理能力。当前，人类基于大数据和人工智能等技术，在特定领域中可以大大提升业务系统的智能化水平。
人类对于计算速度的追求从未停止，即使面对海量的数据，我们也希望大数据框架可以在非常低的延迟下进行响应，从而提升用户的体验。
主流的分布式大数据计算框架有Storm、Spark和Flink，由于阿里对Flink的收购以及改进，目前Flink社区非常活跃，社区一直致力于统一流处理和批处理API，并逐步增强Flink SQL相关功能，即期望通过SQL来满足大部分的大数据ETL处理场景。另外，随着Flink SQL功能的增强和发展，也大大降低了Flink学习的难度。
目前，Flink在百度、阿里、字节跳动、小米和腾讯等商业巨头中有成熟的应用，每日可以处理万亿的事件，且可以维护TB级别的状态信息。Flink支持多种编程语言，可以用Java、Scala以及Python进行大数据业务处理。与此同时，Flink支持灵活的窗口计算以及乱序数据处理，这相对于其他大数据计算框架来说，有比较强的优势。
关于本书
如果你对实时大数据处理感兴趣，致力于构建分布式大数据处理应用程序，并且有一点Java编程基础，那么本书适合你。本书作为Flink的入门教材，由浅入深地对Flink大数据处理方法进行介绍，特别对常用的DataStream API和DataSet API、Table API 和SQL进行了详细的说明，最后结合实战项目，将各个知识点有机整合，做到理论联系实际。
本书共分10章，内容包括Flink开发环境搭建、Flink架构和原理、时间和窗口、状态管理和容错机制、数据类型与序列化、DataStreamAPI和DataSet API、Table API和SQL、Flink并行、Flink部署与应用。最后以一个Flink实战项目为例，对Flink相关知识进行综合实践，其中涉及Web页面展示、WebSocket协议和Node.js服务等技术。
本书读者
本书内容详尽、示例丰富，适合作为Flink初学者必备的参考书，也非常适合作为高等院校和培训机构大数据及相关专业的师生教学参考。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/920dd8b95e75d95210ae6952e8cdf2de/" rel="bookmark">
			JAVA获取json中的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先是需要 先导入json格式化的依赖
&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.28&lt;/version&gt; &lt;/dependency&gt; 一段JSON如下所示：
String a="{'code':100,'data':{'grdbl':100.0,'bxl':646,'fwl':0,'mytsl':0}}"; 获取json值代码如下：
String a="{'code':100,'data':{'grdbl':100.0,'bxl':646,'fwl':0,'mytsl':0}}"; //先把String对象转换成json对象 JSONObject object= JSONObject.parseObject(a); System.out.println(object.getJSONObject("data").get("grdbl")); System.out.println(object.getJSONObject("data").get("bxl")); System.out.println(object.getJSONObject("data").get("fwl")); System.out.println(object.getJSONObject("data").get("mytsl")); 显示效果如下：
100.0 646 0 0 保存记录一下，，，以免下次找不到，，，搞得我脑阔痛 php转java中
————————————————
版权声明：本文为CSDN博主「怪只怪满眼尽是人间烟火」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_38959210/article/details/83515840
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13657d1390db2ead510bc18c66aa9fcf/" rel="bookmark">
			帮助有一定计算机基础的人 快速复习并重新拾起C语言基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 1.C语言程序举例2.详解C语言程序结构1）#include2）main 函数：3）{} 括号，程序体和代码块4）注释5）print 函数6）return 语句 3 C程序的编译步骤是怎样？4.数据的表现形式1.常量2.标识符3.变量4.常变量5.sizeof运算符的使用 1.C语言程序举例 #include &lt;stdio.h&gt; //编译预处理指令 int main() //主程序的入口 { //这是第一个 C 语言代码 这是注释 printf("hello world\n"); //标准输出语句 return 0; //函数执行完毕时的返回值 } 2.详解C语言程序结构 一个源文件程序中包含以下三个部分：
①预处理指令。如#include&lt;stdio.h&gt;,C 编译系统对程序进行编译前，首先由预处理器
对预处理指令进行预处理操作，对于#include&lt;stdio.h&gt;来说就是将 stdio.h 文件的内容读取
进来，替代#include&lt;stdio.h&gt;。
②全局声明。即在函数外声明数据。
③函数的定义。即函数具体实现的功能。
代码分析：
1）#include #include 的意思是头文件包使用 C 语言库函数需要提前包含库函数对应的头文件，如
这里使用了 printf()函数，需要包含 stdio.h 头文件,#include&lt;stdion.h&gt;代表包含这个头文件。
使用 C 语言库函数需要提前包含库函数对应的头文件，如这里使用了 printf()函数，需要包含 stdio.h 头文件 。
注意：****#include&lt;&gt;和#include “”的区别：
&lt;&gt;通常是包含系统的头文件(标准头文件)，””通常是包含自定义头文件。
2）main 函数： main 函数是 C 语言程序的入口，程序是从 main 函数开始执行
一个完整的 C 语言程序，是有且只能有一个 main()函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13657d1390db2ead510bc18c66aa9fcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab6b5de6ddceced9e4efcfd5d46942eb/" rel="bookmark">
			汉诺塔（河内塔）问题解析（函数递归经典问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 题目描述
2. 题目目标
3. 题目分析
1. 题目描述 在一块铜板装置上，有三根杆（编号A、B、C），在A杆自上而下、由大到下按顺序放置n个盘子。
2. 题目目标 把A杆上的盘子全部转移到C杆上，并且保持原有的顺序叠好。每次只能移动一个盘子，并且在移动中三根杆子上始终保持大盘在下，小盘在上，操作过程中盘子可以放置于A、B、C任一杆上。
3. 题目分析 对于一个新的问题摆在我们的面前，我们往往会利用最简单的方式来思考并且尝试深入理解它的原理，所以我们就从最简单的模型看起。
我将演示当n分别等于2和3（n=1情况很简单就不讲解了喔！）时的情况，下面是我自己画的图解： n=2：
n=3：
通过这两个图解，我们可以总结出无论n增加到多少，其实本质上B杆始终扮演这中转站的角色。那么我们可以这样理解： A杆：起始位置 B杆：中转位置吗 C杆：目标终点位置
汉诺塔问题中的递归思想
面对这样的问题，数值较小的时候使用枚举法当然有用，但是无休止的穷举就是繁琐的、没有意义的。那么我们如何结合递归的大事化小的思维方式呢？
其实我们不难发现当我们有n个盘子的时候，我们只需要将n-1个盘子从A杆（起始位置）转移到B杆（中转位置）， 再把最大的盘子从A杆（起始位置）转移到C杆（目标终点位置），
这个时候只剩下将n-1个盘子从B杆（中转位置）转移到C杆（目标终点位置）。这样的解决问题的方式实际上将原问题转化为解决移动n-1、n-2........3、2，直到移动到最后最小的盘子。
这样有繁化简的方法就是递归。
有了这样更加深层的理解，我们就来看看代码的实现：
//汉诺塔问题递归实现 #define _CRT_SECURE_NO_WARNINGS #include&lt;stdio.h&gt; void move(char pos1, char pos2)//实现盘子的移动步骤的打印 { printf("%c-&gt;%c ", pos1, pos2); } void Hanoi(int n, char pos1, char pos2, char pos3) { if (n == 1) { move(pos1, pos2); } else { Hanoi(n - 1, pos1, pos3, pos2);//将n-1个盘子从A杆（起始位置）转移到B杆（中转位置） move(pos1, pos3);//把最大的盘子从A杆（起始位置）转移到C杆（目标终点位置） Hanoi(n - 1, pos2, pos1, pos3);//此时对于n-1个盘子B杆变成起始位置，A杆为中转位置，转移到C杆（目标终点位置） } } int main() { int n = 0; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab6b5de6ddceced9e4efcfd5d46942eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eb154c84a68ac372c602b457dfa89fc/" rel="bookmark">
			时间序列——指数平滑法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 理论知识参考自时间序列分析预测实战之指数平滑法 - 知乎 (zhihu.com)
SPSS操作可以对照我之前的博客(3条消息) 时间序列ARIMA模型_m0_52124992的博客-CSDN博客
一、理论知识 1、指数平滑法的基本公式： ，其中
St--第t期的预测值（或指数平滑值）；
yt--第t期的实际值；
St − 1--第t-1期的预测值（或指数平滑值）；
a--平滑常数，其取值范围为[0,1]；
简单来说就是：任一期的指数平滑值都是本期实际观察值与前一期指数平滑值的加权平均，也可以理解为下一期数据的预测值与本期的实际值和上一期的预测值相关. 2、一次指数平滑： 当时间序列无明显的趋势变化，可用一次指数平滑预测。 3、二次指数平滑： 对一次指数平滑的再平滑，它适用于具线性趋势的时间序列。 4、三次指数平滑： 在二次平滑基础上的再平滑。 二、SPSS操作步骤 1、收集数据（并补全缺失值） 如果有缺失数据，按照下面步骤（一般使用“序列均值”进行补全）
2、时序图和检验平稳性 首先，定义好日期：
此时会新生成一列数据，如下
然后创建时间序列：
3、创建模型与模型分析 选择分析预测——创建模型——指数平滑法
Ⅰ、holt线性趋势指数平滑模型 结果分析
R方是874（没有ARIMA模型的高），说明拟合效果没有ARIMA模型的好 显著性小于0.05说明这个模型的序列可能存在一定的自相关问题 预测结果也还可以 看一看选“平方根”的效果：
看到R方并没有什么显著提高，实际上这里在指数平滑中，用“自然对数”的方式更合适一些 Ⅱ、简单非线性指数平滑模型 Ⅲ、Brown线性趋势指数平滑模型 Ⅳ、阻尼趋势指数平滑模型 阻尼趋势指数平滑模型预测效果和holt线性趋势指数平滑模型效果一致 放在最后： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/414ef704d4352ba70f0ee25fce886322/" rel="bookmark">
			ramparser
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ramparser 1 理解概念 1.1 ramdump ramdump是内存转储文件，简单来说，就是当系统发生致命错误无法恢复的时候，把整个DRAM抓下来，写到多个固定大小的.bin文件当中(文件尺寸相加就是当前DRAM的大小)。
1.2 ramparser ramparser是解析ramdump的工具
1.3 debugpolicy secure boot: 为了安全,凡是开了secure boot的机器, 会禁用相当一部分的debug功能. 但是很多打开了secure boot的手机出现问题的时候也需要调试. 需要临时打开这些debug feature, 比如tzlog, full ramdump, 以及subsystem restart ramdump.
debugpolicy: 在8994以及之前的平台,想干这件事比较麻烦,需要修改签名的配置文件,重新签名xbl.elf以及mba.mbn才能enable. 在8996以及之后的平台上,高通引入了debugpolicy. 本质上, 它是一个被签名的配置文件, 会被刷到apdp和msadp分区(通常情况下这两个分区是空的),当xbl以及tz在启动阶段发现有这个文件,并且能通过签名校验的时候,就会临时开启相应的debug功能.
2 抓取ramdump 2.1 触发crash dump # 检查debugpolicy(0x0b有效) adb shell getprop ro.boot.d # 刷入debugpolicy python ./vendor/xiaomi/securebootsigner/Qualcomm/common/debugpolicy.py # 检查debugpolicy(0x0b有效) adb shell getprop ro.boot.d # 触发crash dump; 或手动按音量+-和power键4s左右进入dump adb root adb shell "echo c &gt; /proc/sysrq-trigger" lsusb 2.2 使用QPST configuration 此时进入crash dump模式，端口识别为900e。使用工具自动获取dump信息。Ports标签页查看，查看dump文件: Help --&gt; Open Log File Directory
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/414ef704d4352ba70f0ee25fce886322/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9567fdc07208d29d3239d8d7bcf9820/" rel="bookmark">
			微信小程序中安全区域计算和适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 自从iphoneX问世之后，因为iphoneX、iphoneXR和后续全面屏手机设备，因为物理Home键被底部小黑条代替了，这时候很多前端小伙伴在开发的过程都会遇到 “全面屏”和“非全面屏”的兼容性问题，普遍问题就是底部按钮或者选项卡与底部黑线重叠
解释 根据官方解释：
安全区域指的是一个可视窗口范围，处于安全区域的内容不受圆角(corners)、齐刘海(sensor housing)、小黑条(Home Indicator)的影响。 具体区域如图展示
适配方案 当前有效的解决方式有几种
使用已知底部小黑条高度34px/68rpx来适配
使用苹果官方推出的css函数env()、constant()适配
使用微信官方API，getSystemInfo()中的safeArea对象进行适配
使用已知底部小黑条高度34px/68rpx来适配 这种方式是根据实践得出，通过物理方式测出iPhone底部的小黑条（Home Indicator）高度是34px，实际在开发者工具选中真机获取到高度也是34px，所以直接根据该值，设置margin-bottom、padding-bottom、height也能实现。同时这样做要有一个前提，需要判断当前机型是需要适配安全区域的机型。
但是这种方案相对来说是不推荐使用的。比较是一个比较古老原始的方案
使用苹果官方推出的css函数env()、constant()适配 这种方案是苹果官方推荐使用env()，constant()来适配，开发者不需要管数值具体是多少。
env和constant是IOS11新增特性，有4个预定义变量：
safe-area-inset-left：安全区域距离左边边界的距离
safe-area-inset-right：安全区域距离右边边界的距离
safe-area-inset-top：安全区域距离顶部边界的距离
safe-area-inset-bottom ：安全距离底部边界的距离
具体用法如下：
Tips: constant和env不能调换位置 padding-bottom: constant(safe-area-inset-bottom); /*兼容 IOS&lt;11.2*/ padding-bottom: env(safe-area-inset-bottom); /*兼容 IOS&gt;11.2*/ 其实利用这个能解决大部分的适配场景了，但是有时候开发需要自定义头部信息，这时候就没办法使用css来解决了
使用微信官方API，getSystemInfo()中的safeArea对象进行适配 通过 wx.getSystemInfo获取到各种安全区域信息，解析出具体的设备类型，通过设备类型做宽高自适应，话不多说，直接上代码
代码实现 const res = wx.getSystemInfoSync() const result = { ...res, bottomSafeHeight: 0, isIphoneX: false, isMi: false, isIphone: false, isIpad: false, isIOS: false, isHeightPhone: false, } const modelmes = result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9567fdc07208d29d3239d8d7bcf9820/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f3399b6fac86eaf9f54af9a18807513/" rel="bookmark">
			octomap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AbstractOccupancyOcTree.h关键的定义
判断一个节点是否是占据，使用的是occupancyNode-&gt;getLogOdds() &gt;= this-&gt;occ_prob_thres_log，也就是occ_prob_thres_log这个阈值控制着这个标准，在最终更新中，调用的是这个函数
void OcTreeNode::addValue(const float&amp; logOdds) {
value += logOdds;
}
实验，当不停调用：
int count = 10;
for (int i = 0; i &lt; count; i++) {
tree.updateNode(pt, 1.0f, false);
PrintNodeVal(tree, pt);
}
PrintNodeVal(tree, pt);
会输出：0，1， 2，3，3.51
最大值就是3.51，在octomap_utils.h中有定义从log到概率的计算方式，将tree的基本参数打印出来如下：
getClampingThresMax 0.971
getClampingThresMaxLog 3.51103
getClampingThresMin 0.1192
getClampingThresMinLog -2.00003
getOccupancyThres 0.5
getOccupancyThresLog 0
getProbHit 0.7
getProbHitLog 0.847298
getProbMiss 0.4
getProbMissLog -0.405465
当我们想把概率调到90，那需要的log数是多少呢？
1 - 1.0/(1+math.exp(2.198)) = 0.9000
当然我们可以调低probHit的阈值，以此增加达到0.90的次数。 假设需要观测num次才设置占用，则可以按照如下：
2.198 = proHit_log * num
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f3399b6fac86eaf9f54af9a18807513/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32c8b9d08474675b9b411221b0894d8a/" rel="bookmark">
			ES6ES6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES8-ES8 新特性 4.1.async 和 await
async和await 两种语法结合可以让异步代码像同步代码一样
4.1.1.async函数
async函数的返回值为 promise 对象，
2.promise 对象的结果由 asynt函数执行的返回值决定
4.1.2await表达式awaity必须写在 async 函数中
2.await 右侧的表达式一般为 promise 对象await 返回的是 promise 成功的值await 的 promise 失败了，就会抛出异常，需要通过 try…catch 捕获处理 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //发送AJAX请求，返回的结果是promise对象 function sendAJAX(url) { return new Promise((resolve, reject) =&gt; { //1.创建对象 const x = new XMLHttpRequest() //2.初始化 x.open('GET', url) //3.发送 x.send() //4.事件绑定 x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32c8b9d08474675b9b411221b0894d8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaa87a24532f7556620ab171158e71da/" rel="bookmark">
			语义分割&amp;实例分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
语义分割（像素级分类）
FCN（Fully Convolutional Networks 全卷积网络）
SegNet
PSPNet（Pyramid Scene Parsing Network 金字塔场景解析网络）
DeepLab
实例分割（可区分同一类别的不同主体）
FCIS(Fully Convolutional Instance-aware Semantic Segmentation 全卷积语义实例分割网络)
MASK R-CNN（2018）
Masklab
PANet（用于实例分割的路径聚合网络）
SOLOv1: Segmenting Objects by Locations（2020）
SOLOv2（2020）
Mask2Former（2022 可以做语义、实例、全景分割 Masked-attention Mask Transformer for Universal Image Segmentation）
四个层次：物体分割（普通分割）、语义分割、实例分割、全景分割
物体分割（利用灰度值的不连续性及相似性，做前景、背景的分割，不区分主体）比如psenet等用分割的方法检测文字
全景分割（对图中的所有物体包括背景都要进行检测和分割）
语义分割（像素级分类） 包含：FCN、SegNet、DeepLab、RefineNet、PSPNet
常用数据集如下：
FCN（Fully Convolutional Networks 全卷积网络） FCN的学习及理解（Fully Convolutional Networks for Semantic Segmentation）_moonuke的博客-CSDN博客_fcn
1）虚线以上是全卷积提取特征，最后2层用卷积替代了分类网络（如vgg）的全连接，蓝色为卷积，绿色为池化
2）batch_size 为1，当输入图像大小为H*W*C，输出大小为H*W*（1+CLASS），加了一个背景类。此图H*W*C=500*500*C，CLASS=20。不包含全连接层的全连接网络，可以适应任意尺寸的输入
3）虚线以下：
crop（灰色）：裁剪成同样尺寸
eltwise（黄色）：融合两个层
反卷积｜上采样（橙色）：为获得与原图同样的HW
4）SKIP跨层连接（类似resnet）操作。skip融合3层信息，结果更精细
5）这个网络并不好训练，需要分4步分阶段训练，详见链接
扩展阅读：
Concat层和Eltwise层对比解析
caffe | Concat层和Eltwise层对比解析_努力努力再努力tq的博客-CSDN博客_eltwise
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aaa87a24532f7556620ab171158e71da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bccea20e858c2cbe19641eac8c7938de/" rel="bookmark">
			MySql索引常见面试题及分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面试 1）问题：数据库中最常见的慢查询优化方式是什么？
回答：加索引
2）问题：为什么加索引能优化慢查询？
回答：因为索引是一种优化查询的数据结构，比如MySQL中的索引是B+树实现的，而B+树就是一种数据结构，可以优化查询速度，可以利用索引快速查找数据，所以能优化查询！
3）你知道哪些数据结构可以提高查询速度？
回答：哈希表、完全平衡二叉搜索树、B树、B+树等等；
4）那这些数据结构既然都能优化查询速度，那MySQL为何选择使用B+树？
（1）哈希表的特点
假设有这么一张表，表名为：users
![在这里插入图片描述](https://img-blog.csdnimg.cn/68d3a040c207434d8ea4d3e3950817c6.png#pic_center) 现在对name字段建立hash索引
注意字段值所对应的数组下标是哈希算法随机计算出来的，所以可能会出现哈希冲突。那么对于这样的一个索引结构，现在来执行下面的SQL语句：
select * from users where name = ‘周瑜’;
可以直接对 ‘周瑜’ 按哈希算法算出一个数组下标，然后可以直接从数据中取出数据并拿到锁对应的那一行数据的地址，进而在数据表文件中查询那一行数据。
那么如果现在执行下面的SQL语句：
select * from users where name &gt; ‘周瑜’;
此时则无能为力，因为哈希表的特点就是可以快速的精确查询，但是不支持范围查询！
（2）完全平衡二叉搜索树
还是上面的表数据用完全平衡二叉树表示如下图（为了简单，数据对应的地址就不画在图中）
图中的每一个节点实际上应该有四部分：
1. 左指针，指向左子树
2. 键值（key）
3.键值所对应数据的存储地址（data域中的值）
4. 右指针，指向右子树
需注意：完全平衡二叉搜索树是有序的，简单的说就是 “左边的小于右边的”，假如我们现在来查找 ‘周瑜’ ，需要查找2次（第一次操作，第二次周瑜），比哈希表要多一次。而且由于完全平衡二叉搜索树是有序的，所以支持范围查找。
（3）B树
还是上面的表示数据用B树表示如下图（为了简单，数据对应的地址就不画在图中了）
可以发现同样的元素，B树表示的要比完全平衡二叉搜索树要 “矮”,原因在于B树中的一个节点可以存储多个元素！
（4）B+树
还是上面的表示数据用B+树表示如下图（为了简单，数据对应的地址就不画在图中了）
我们可以发现同样的元素，B+树的表示要比B树要 “胖”，原因在于B+树中的非叶子节点会冗余一份在叶子节点中，并且叶子节点之间用指针相连！
B+树作为索引的优势
这里我们用“反证法”，假如我们现在就用完全平衡二叉搜索树作为索引的数据结构，我们来看一下有什么不妥的地方。实际上，索引也是很“大”的，因为索引也是存储元素的，我们的一个表的数据行数越多，那么对应的索引文件其实也是会很大的，实际上也是需要存储在磁盘中的，而不能全部都放在内存中，所以我们在考虑选用哪种数据结构时，我们可以换一个角度思考，哪个数据结构更适合从磁盘中读取数据，或者哪个数据结构能够提高磁盘的IO效率。回头看一下完全平衡二叉搜索树，当我们需要查询“张飞”时，需要以下步骤
从磁盘中取出“曹操”到内存，CPU从内存取出数据进行笔记，“张飞”&lt;“曹操”，取左子树（产生了一次磁盘IO） 从磁盘中取出“周瑜”到内存，CPU从内存取出数据进行笔记，“张飞”&gt;“周瑜”，取右子树（产生了一次磁盘IO） 从磁盘中取出“孙权”到内存，CPU从内存取出数据进行笔记，“张飞”&gt;“孙权”，取右子树（产生了一次磁盘IO） 从磁盘中取出“黄忠”到内存，CPU从内存取出数据进行笔记，“张飞”=“张飞”，找到结果（产生了一次磁盘IO） 同理，回头看一下B树，我们发现只发送三次磁盘IO就可以找到“张飞”了，这就是B树的优点：一个节点可以存储多个元素，相对于完全平衡二叉树所以整棵树的高度就降低了，磁盘IO效率提高了。而B+树是B树的升级版，只是把非叶子节点冗余一下，这么做的好处是 为了提高范围查找的效率。
到这里可以总结出来，Mysql选用B+树这种数据结构作为索引，可以提高查询索引时的磁盘IO效率，并且可以提高范围查询的效率，并且B+树里的元素也是有序的。 5）问题：一个B+树的节点中到底存储多少个元素合适呢？
回答：B+树中一个节点为一页或页的倍数最为合适。因为如果一个节点的大小小于1页，那么读取这个节点的时候其实也会读出1页，会造成资源的浪费；如果一个节点的大小大于1页，比如1.2页，那么读取这个节点的时候会读出2页，也会造成资源的浪费；所以为了不造成资源的浪费，最后把一个节点的大小控制在1页、2页、3页、4页等倍数页大小最为合适！
6）MySQL中B+树的一个节点大小为多大？
回答：一页，这里说的 “页” 是MySQL自定义的单位（其实和操作系统类似），MySQL的Innodb引擎中一页的默认大小是16K（如果操作系统中一页大小是4K，那么MySQL中1页 = 操作系统中的4页），这样存取数据的时候都是一页一页的获取索引文件中节点数据的！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bccea20e858c2cbe19641eac8c7938de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c559ba979b1d95e0ff4f198e45a46dba/" rel="bookmark">
			二分查找（Binary Search）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二分查找也叫作折半查找。二分查找有两个要求，一个是数列有序，另一个是数列使用顺序存储结构。他的思想很简单，但是在书写过程中如果边界条件无法正确的确定，很容易陷入到循环中无法跳出。
二段性 二段性是集合中的元素有存在分界线，给定条件可以将集合中元素分为两部分，一部分满足条件，一部分不满足条件。
分界线之前的第一个元素，也就是最后一个满足条件的值，我们称为ML(Meeting Condition Last)分界线之后的第一个元素，也就是第一个不满足该条件的值，我们称为NB(Not Meeting Condition Begining) 区间问题 此节主要讲二分查找的细节处理，如果要看二分的查找过程不建议看这篇，文中所讲的二分伪代码为：
l = -1,r = N + 1 while l + 1 != r m = l + (r - l &gt;&gt; 1) if judge(m) // 根据题目修改judge l = m else r = m return l/r // 最终返回时根据需求进行返回 对于一个给定的数组 0 1 2 3 ⋯ ( N − 4 ) ( N − 3 ) ( N − 2 ) ( N − 1 ) N 0\ \ 1\ \ 2\ \ 3\ \ \cdots\ \ (N-4)\ \ (N-3)\ \ (N-2)\ \ (N-1)\ \ N 0 1 2 3 ⋯ (N−4) (N−3) (N−2) (N−1) N进行二分查找时，需考虑以下步骤
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c559ba979b1d95e0ff4f198e45a46dba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2de5909e1f893c2e362c1c81c16df989/" rel="bookmark">
			二叉搜索树（Binary Search Tree）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于二叉树中的点到底用“结点”还是“结点”。结点被认为是一个有处理能力的实体，比如网络上的一台计算机；而结点则只是一个交叉点，像“结绳记事”，打个结做个标记，仅此而已。还有就是，要记住：一般算法中点的都是结点。
二叉搜索树又叫二叉排序树、二叉查找树，支持多种操作，包括Search、Minimum、Maximum、Predecessor、Successor、Insert和Delete等操作，且其基本操作所花费的时间与这棵树的高度成正比。
完全二叉树的最坏运行时间为： O ( l o g n ) O({\bf log}\ n) O(log n)，树如果由 n n n个结点的组成的线性链，则最好运行时间为： O ( n ) O(n) O(n)。
二叉搜索树的定义 二叉搜索树又称为做二叉排序树、二叉查找树。其要么是一课空树，要么是一个满足以下性质的二叉树：
若它的左子树不空，则左子树上所有结点的关键字均小于根结点关键字若它的右子树不空，则右子树上所有结点的关键字均大于根结点关键字它的左右子树依旧是二叉搜索树没右关键字相等的结点 算法导论中指出，左右子树均可以包含和根结点大小相等的元素
二叉搜索树具有的特点：
按中序遍历二叉搜索树所得的中序序列是一个递增的有序序列。统一个数据集合可构造的二叉搜索树不唯一，但中序序列相同。 Search 二叉搜索树在搜索某个关键字遇到结点x时，将关键字k与x.key比较：
如果k==x.key，查找终止并返回x。如果k&lt;x.key，继续在x的左子树中查找，如果左子树为空则返回null。如果k&gt;x.key，继续在x的右子树中查找，如果左子树为空则返回null。 上述过程所需的运行时间为 O ( h ) O(h) O(h)，其中 h h h表示树的高度。其代码为：
public TreeNode search(TreeNode node, int key) { while (node != null) { if (node.val == key) return node; else if (node.val &gt; key) node = node.left; else node = node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2de5909e1f893c2e362c1c81c16df989/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/090fbfff477a9286ae8a5841a00fca6a/" rel="bookmark">
			组合数的计算方法（Combinatorial Number）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组合数：从 n n n个不同元素中取出 m ( m ≤ n ) m(m≤n) m(m≤n)个元素的所有组合的个数，叫做从 n n n个不同元素中取出 m m m个元素的组合数。计算公式为：
C ( n , m ) = n ! / ( ( n − m ) ! × m ! ) , where m ≤ n C(n,m)=n!/((n-m)!\times m!), \text{where}\ m\leq n C(n,m)=n!/((n−m)!×m!),where m≤n
性质1： C ( n , m ) = C ( n , n − m ) C(n,m)= C(n,n-m) C(n,m)=C(n,n−m)性质2： C ( n , m ) = C ( n − 1 , m − 1 ) + C ( n − 1 , m ) C(n,m)=C(n-1,m-1)+C(n-1,m) C(n,m)=C(n−1,m−1)+C(n−1,m) 第一种方法：打表 根据性质2直接构建一个 n × n n\times n n×n的矩阵进行计算：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/090fbfff477a9286ae8a5841a00fca6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16cd136fa35f418524e0e9c2b2031101/" rel="bookmark">
			单调队列（Monotonic Queue）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单调队列是一种主要用于解决滑动窗口类问题的数据结构，即在长度为 n n n的序列中，求每个长度为 m m m的区间的区间最值。他的时间复杂度为 O ( n ) O(n) O(n)。
基本思想 单调队列的基本思想是维护一个双向队列，遍历序列，仅当一个元素称为某一个区间最值时保留它。
案例 举个例子，寻找 [ i − 3 , i ] [i-3,i] [i−3,i]窗口的最小值为：
数组双向队列说明7 6 8 12 9 10 3初始状态7 6 8 12 9 10 37从 i = 0 i=0 i=0时，只有一个元素，其就是最小值，直接进入队列7 6 8 12 9 10 36在 i = 1 i=1 i=1时，因为6小于7，所以7出队列，6进队列7 6 8 12 9 10 36 8在 i = 2 i=2 i=2时，因为8大于6，所以8进队列7 6 8 12 9 10 36 8 12在 i = 3 i=3 i=3时，因为12大于8，所以12进队列7 6 8 12 9 10 36 8 9在 i = 4 i=4 i=4时，因为9 小于12，所以12出队列；因为9大于8，所以8进队列7 6 8 12 9 10 38 9 10在 i = 5 i=5 i=5时，因为6不在 [ 3 , 6 ] [3,6] [3,6]区间之内，所以6出队列；因为10大于9，所以10进队列7 6 8 12 9 10 33在 i = 6 i=6 i=6时，因为3小于10，所以10出队列；因为3大于9，所以9出队列；因为3大于8，所以8出队列 代码实现 其的核心代码为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16cd136fa35f418524e0e9c2b2031101/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d693241763649b5feb6ab9661e54adf/" rel="bookmark">
			iptables只允许指定网段ip访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以使用 iptables 规则限制指定网段的 IP 地址访问。示例如下：
iptables -A INPUT -s 192.168.0.0/24 -j ACCEPT iptables -A INPUT -j DROP 第一行允许来自 192.168.0.0/24 网段的 IP 地址访问。第二行拒绝其他所有 IP 地址的访问。
注意：此规则应在其他规则之前执行，以确保其生效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3fd63de6ef85fa152175d0c89d7660b/" rel="bookmark">
			汽车CAN总线硬件电路原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据ISO 11898的定义，物理层被细分成3 个子层，它们分别是物理信令（位编码定时和同步）、物理媒体连接（驱动器和接收器特性）和媒体相关接口（总线连接器）。
物理信令子层和数据链路层之间的连接是通过集成的协议控制器实现的，而媒体相关接口（CAN收发器）是协议控制器和物理传输线路之间的接口。
高速的ISO 11898-2 CAN标准定义了一个单线结构的网络拓扑结构。
CAN总线不支持星形或甚至多星形拓扑结构。节点是通过未端接的落地线连接到主总线上。总线在最远的两端用一个终止电阻（特性线阻抗）终止。
如图所示，总线线在最远的两端用一个终端电阻（特性线阻抗）终止。否则信号反射将在总线上发生，导致严重的振铃和错误率。总线拓扑结构必须选择这样的拓扑结构，使反射最小化。
图 2‑1基本的CAN总线拓扑结构
CAN总线拓补结构 CAN总线应用模块在搭建上一般有两种方案：
(1)微控制器+CAN控制器+CAN收发器。
(2)集成CAN控制器的微控制器+CAN收发器
第一种方案优点是可以与多种类型的单片机、微型计算机的各类标准总线进行接口组合，这种设计比较灵活，成本较低，缺点是电路设计稍微复杂。
第二种方案优点是电路设计简化和紧凑，缺点是成本高。单个CAN节点可以通过总线或星形拓扑结构连接到通信网络上。
图 2‑2 连接模型：带有存根线的总线结构
图 2‑3 连接模型：星点结构
CAN收发器电路 最常见的CAN收发器新芯片厂家有恩智浦（NXP）-荷兰、英飞凌（Infineon）-德国、德州仪器（TI）-美国、微芯（Microchip ）-美国、意法半导体（ST）-意大利、安森美半导体（ON Semi）-美国。
ISO 11898[1]是一个使用 CAN 总线协议的汽车内高速通讯国际标准 这个标准的基本作用是定义了通讯链路的数据链路层和物理层 如图 1.1 所示 物理层被细分成 3 个子层 它们分别是
1.物理信令 位编码 定时和同步
2.物理媒体连接 驱动器和接收器特性
3. 媒体相关接口 总线连接器
物理信令子层和数据链路层通常是由协议控制器来实现 像用 Philips 的 SJA1000[2] 协议控制器和物理传输媒体之间使用物理媒体连接子层接口 产品有像Philips的TJA1050[3]或PCA82C250[4]等收发器，本节着重介绍如何使用收发器 TJA1050 实现物理连接子层。
跟 PCA82C250 一样 TJA1050 符合 ISO 11898 标准 因此 它可以和其他遵从 ISO 11898 标准的收发器产品协同操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3fd63de6ef85fa152175d0c89d7660b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/037f6d49e4e11d4f8c9752e4cc3081d7/" rel="bookmark">
			【STM32CubeMX&#43;HAL库】I2C详解&#43;读写EEPROM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在之前的标准库中，STM32的硬件IIC非常复杂，更重要的是它并不稳定，所以都不推荐使用。但是在我们的HAL库中，对硬件IIC做了全新的优化，使得之前软件IIC几百行代码，在HAL库中，只需要寥寥几行就可以完成 那么这篇文章将带你去感受下它的优异之处。
本文将详细地讲解I2C协议，并基于I2C 来读写EEPROM模块以达到练习的目的 通过本篇博客您将学到：
I2C的基本原理STM32CubeMX创建I2C例程I2C函数库（HAL）AT24C256芯片原理及读写方法 I2C简介 IIC(Inter－Integrated Circuit)总线是一种由NXP（原PHILIPS）公司开发的两线式串行总线，用于连接微控制器及其外围设备。多用于主控制器和从器件间的主从通信。
I2C特性
半双工没有严格的波特率要求小数据量场合使用传输距离短、传输速率不如SPI任何时刻只能有一个主机，但任何设备都可成为主机 只需要两条总线——SDA与SCL IIC一共有只有两个总线： 一条是双向的数据线ＳＤＡ，一条是串行时钟线ＳＣＬ
所有接到I2C总线设备上的串行数据SDA都接到总线的SDA上，各设备的时钟线SCL接到总线的SCL上。I2C总线上的每一个设备都对应一个唯一的地址。
I2C起始信号与终止信号（代码段为软件I2C）
1、起始信号：SCL为高电平时，SDA由高-&gt;低
void I2C_Start() { SDA=1; //确保SDA为高电平 HAL_Delay(1); SCL=1; //确保SCL为高电平 HAL_Delay(1); SDA=0; //SCL为高时拉低SDA线 HAL_Delay(1); SCL=0; //钳住I2C总线，准备数据的发送与接收 } 2、终止信号：SCL为高电平时，SDA由低-&gt;高
void I2C_Stop() { SCL=0; SDA=0; HAL_Delay(1); SCL=1; //确保SCL为高电平 HAL_Delay(1); SDA=1; //SCL为高时拉高SDA } I2C应答信号与非应答信号 （代码段为软件I2C）
每当主机向从机发送完一个字节的数据，主机总是需要等待从机给出一个应答信号，以确认从机是否成功接收到了数据。
应答信号为低电平时，规定为有效应答位（ACK，简称应答位），表示接收器已经成功地接收了该字节；应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成功。
1、应答信号‘0’：SCL高时SDA低
void I2C_Ack() //产生应答信号 { SCL=0; SDA=0; HAL_Delay(1); SCL=1; //确保SCL为高时SDA为低 HAL_Delay(1); SCL=0; } 2、非应答信号‘1’：SCL高时SDA高
void I2C_NAck() //不产生应答信号 { SCL=0; SDA=1; HAL_Delay(1); SCL=1; //SCL高时SDA高 HAL_Delay(1); SCL=0; } I2C数据有效性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/037f6d49e4e11d4f8c9752e4cc3081d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac3647e3cf72539c3c823684cb83e5b5/" rel="bookmark">
			关于结构体数组怎么定义和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先要定义你说需要结构体的数据类型
2、定义结构体数组，直接初始化数据
3、也可以只定义，使用的时候再进行数据填充
4、这样定义和使用的目的
情况，这边使用会通过其他接口，获取到按键值，但我需要做的是显示对应字符串，和按照一定顺序匹配保存特定字符串，所以列了一个这样的结构体数组，做索引值和字符串的查找对比。
关于顺序保存，则有额外定义了一个相同的结构体数组，先从这个列表中查找对应数组，再按照从0开始顺序一次写入到额外定义的这个相同的结构体数组中，这个后面数据，就可以直接有顺序的从这个结构体数组中获取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f45fd18e0ff2c3bb629e3f7587982051/" rel="bookmark">
			负电压是怎么产生的原理分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		负电压的意义：
1、人为规定。例如电话系统里是用-48V来供电的，这样可以避免电话线被电化学腐蚀。当然了，反着接电话也是可以工作的，无非是电压参考点变动而已。
2、通讯接口需要。例如RS232接口，就必须用到负电压。-3V～-15V表示1，+3～+15V表示0。这个是当初设计通讯接口时的协议，只能遵守咯。PS:MAX232之类的接口芯片自带电荷泵，可以自己产生负电压。
3、为（非轨到轨）运放提供电源轨。老式的运放是没有轨到轨输入/输出能力的，例如OP07，输入电压范围总是比电源电压范围分别小1V，输出分别小2V。这样如果VEE用0V，那么输入端电压必须超过1V，输出电压不会低于2V。这样的话可能会不满足某些电路的设计要求。为了能在接近0V的输入/输出条件下工作，就需要给运放提供负电压，例如-5V，这样才能使运放在0V附近正常工作。不过随着轨到轨运放的普及，这种情况也越来越少见了。
4、自毁电路。一般来说芯片内部的保护电路对于负电压是不设防的，所以只要有电流稍大，电压不用很高的负电压加到芯片上，就能成功摧毁芯片。
电压的定义：电压（voltage），也称作电势差或电位差，是衡量单位电荷在静电场中由于电势不同所产生的能量差的物理量。其大小等于单位正电荷因受电场力作用从A点移动到B点所做的功，电压的方向规定为从高电位指向低电位的方向。说白了就是：某个点的电压就是相对于一个参考点的电势之间的差值。V某=E某-E参。一般我们把供电电源负极当作参考点。电源电压就是Vcc=E电源正-E电源负。想产生负电压，就让他相对于电源负极的电势更低即可。要想更低，必须有另一个电源的介入，根本原理都是利用两个电源的串联。电源2正极串联在参考电源1的负极后。电源2负极就是负电压了。
在电子电路中我们常常需要使用负的电压，比如说我们在使用运放的时候常常需要建立一个负的电压。下面就简单的以正5V电压到负电压5V为例说一下电路。通常需要使用负电压时一般会选择使用专用的负压产生芯片，但这些芯片都比较贵比如ICL7600、LT1054等等，以及使用最多的MC34063芯片。下面介绍在单片机电子电路中常用的两种负压产生电路。现在的单片机有很多都带有了PWM输出，我们在使用单片机的时候PWM很多时候是没有用到的，用他辅助产生负压是不错的选择。一个负电压产生电路：利用电容充电等效出一个新电源，电容串联在GND后，等效为电源2，则产生负电压。
电容充电：当PWM为低电平时，Q2打开，Q1关闭，VCC通过Q2给C1充电，充电回路是VCC-Q2-C1-D2-GND，C1上左正右负。
电容C1充满电，电容C1作为电源，C1高电势极串联在参考点。C1放电，从C2续流，产生负电压。
当PWM为高电平时，Q2关闭，Q1打开，C1开始放电，放电回路是C1-C2-D1，这实际上也是对C2进行充电的过程。C2充好电后，下正上负，如果VCC的电势为5点几伏，就可以输出-5V的电压了。
上面的电路是一个最简单的负压产生电路了。他使用的原件是最少的了我们只需要给他提供1kHZ左右的方波就可以了，相当的简单。这里需要注意这个电路的代负载能力是很弱的，同时在加上负载后电压的降落也比较大。由于上面的原因产生了下面的这个电路：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bab5db44837ca4f8428c7ddf12106350/" rel="bookmark">
			8个必须掌握的Blender拓扑技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组合 3D 模型的过程对后续过程影响很大 - 稍后编辑的难易程度、应用光照和着色器时的外观效果如何、动画时变形的难易程度等等。 一个好的模型对于 CG 管道的所有其他部分的良好运行至关重要。
另一方面，凌乱的拓扑结构会使流程的其余部分成为一场灾难。
你能做些什么来防止这种情况发生？ 这里有 8 个技巧，你可以立即使用。
点击这里访问3D场景编辑器，快速搭建可编程的3D数字孪生场景。
1、了解常用的网格工具 这是一个显而易见的技巧，但每个尝试在 Blender 中进行 3D 建模的人都需要精通这一技巧。
建模时，了解如何正确添加/删除/修改网格是最重要的方面。 毕竟，3d 建模要做的 就是利用一致的面/边/顶点以形成视觉上令人愉悦的形状。
因此，让我们来看看在建模时使用的一些最常见的工具类型。 请注意，大多数这些工具只能在 Blender 的编辑模式下访问。
1.1 添加边循环 添加边循环（Edge Loops）是你通常会做的事情，以支持网格的边缘以创建清晰的边缘，或者只是非常快速地提供额外的几何体。
快捷方式是 Ctrl + R。
启用此功能后，你需要将鼠标悬停在网格本身上，然后会显示一条黄线以投射边缘循环将放置的位置。 要增加边循环数，请使用鼠标滚轮或使用数字键盘输入所需的循环数。
1.2 插入 插入（Inset） 允许你创建窗口之类的东西。 如果我单击一个面并在选中面的情况下按 I，就可以移动鼠标以在其中创建这个面的较小版本。 这对于在网格的特定部分周围创建框架或边缘之类的东西非常有用。 请注意，这会在与所选面相同的表面上创建面，并且不会更改其形状。
1.3 挤压 与 Inset 类似，挤压（Extrude） 也会创建额外的几何体，但与 Inset 不同的是，它允许你通过获取额外的几何体并将其四处移动来更改其形状。
要挤出一个面，请按 E，然后将鼠标移动到想要挤出的方向。 通常，这将默认为该面所指向的轴，但你可以沿任何所需方向移动拉伸。 再次左键单击以停止移动。
除了基本的挤出之外，还有许多不同的挤出需求。 要访问更多挤出选项，请按快捷键 Alt + E，这将打开挤出菜单。 如果你启用了顶点选择模式，将看到所有可用于挤出的选项。
1.4 顶点/边滑动 很多时候你需要重新对齐顶点以符合适当的形状，虽然可以尝试推拉顶点，但这可能会导致尝试使顶点正确对齐的过程令人沮丧。 顶点滑动（Vertex Slide） 允许你移动顶点使其与它们连接的边一致。 可以将其视为连接到轨道 — 也就是边。 为了启用此功能，你可以在选定顶点的情况下按两次 G。 如果不小心滑动了一个顶点，可以右击取消移动。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bab5db44837ca4f8428c7ddf12106350/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2573b6952d45808b4c38580c2c370ec7/" rel="bookmark">
			迁移wsl到D后无法正常启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		wsl2 迁移到D盘启动wsl 的时候抛出错误如下 无法将磁盘'D:\WSL\Ubuntu20.4\ext4.vhdx'附加到 WSL2： 拒绝访问。 Error code: Bash/Service/CreateInstance/MountVhd/E_ACCESSDENIED 解决方案 在迁移的目录中授权 即可解决如下图 成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66ac3384b7e20995b32de4a48005ebc1/" rel="bookmark">
			什么是块级作用域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		块级作用域是指变量或函数在一个代码块内有效，在代码块外无效的作用域。常见的代码块如if语句、for循环等。在 JavaScript 中，使用大括号 {} 定义块级作用域。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f4ce442405017d53e0bee914fc4b602/" rel="bookmark">
			git 提交代码 到 gitee 或 github仓库指定文件夹中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建一个空文件夹 二、将gitee仓库地址复制下来 三、在刚刚新建的空文件夹真打开 Git Bash Here 四、克隆 gitee 仓库 五、提交代码 将想要提交的拖到克隆下来的目录下面 六、执行指令 1. 执行 git add 文件名 （如果是git add . 表示当前目录下的所有内容），注意，add后要一个空格
git add 文件名 可能会出现如下报错，
则需要输入 git init 然后回车就好了
git init 然后再重新执行添加文件就可以了（注意，一定要将目录切换到仓库目录，负责执行命令时会报fatal: pathspec 'hotel-demo' did not match any files）
2. 执行git commit -m “注释的内容” （ 提交到本地仓库）
​git commit -m "注释的内容" 3. 提交代码到 gitee
执行命令: git remote add origin 远程项目的 Https 地址
git remote add origin 远程项目的 Https 地址 可能有人会报如下错误（没有的话可以忽略） 解决：执行 git remote rm origin 删除关联的origin的远程库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f4ce442405017d53e0bee914fc4b602/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67d22f7f286cf4f7276e203a171da378/" rel="bookmark">
			Vue接口请求取消（AbortController 和 CancelToken）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先上Axios官网文档：https://www.axios-http.cn/docs/cancellation 使用场景：页面切换时，取消掉未调用完成的接口；流程中主动取消某些接口。
目前有两种取消接口请求的方式：
AbortControllerCancelToken 这里只写一种实际使用方式： 接口： // 接口文件用了项目中封装过的请求函数，主要关注关键代码。 import request from '@/utils/request' import { dataToFormData } from '@/utils' import axios from 'axios' const CancelToken = axios.CancelToken // 额外传入一个 that export function getList(data, that) { return request({ url: '/test/list', method: 'post', data: dataToFormData(data), // 关键代码 cancelToken cancelToken: new CancelToken((c) =&gt; { that.cancel = c }) }) } 使用： // 调用接口时，除了本身的传参，额外传一个this getList(this.listQuery, this) .then((res) =&gt; {}) .catch((err) =&gt; {}) // 在需要取消的位置执行以下代码即可 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67d22f7f286cf4f7276e203a171da378/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/056a8e58a19e93f0698b7515a794e4d2/" rel="bookmark">
			2022-CSDN的一年
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 马上要到兔年的春节，年前最后一个版本顺利上线，闲下来两天，可以对过往一年进行一下总结，说起来这是入职CSDN之后第一次自己将自己所思所想以以博客的形式发布在CSDN网站上，也是比较奇特的体验。语言表达能力不强，就想到哪里写到哪里了。
工作 2021年11月进入公司，现在我还清楚记得当时的想法：这不就是我每天看博客准备面试的公司吗？
当时是抱着极大的热情入职的，还曾经想过我可能做博客相关的业务，自己要入职的公司开发出了自己每天使用的网站，这种感觉很奇特，用我现在的想法就是：以后做的东西是真的会有人去使用了，而不是之前做的一些项目，用户群体固定，简单说就是会有成就感。
入职后发现自己所做的跟一开始想的还是有区别的，整个2022年一年的时间，其实就做了两个项目，一个PUDN，一个课程学院。
PUDN 这个项目现在应该也可以明确的说了，PUDN，对，这个网站因为各种原因现在到了公司手里，直到2022年8月份，我都是全力在这个项目里面的，从最开始的重构开站到最后的增加新功能（打卡、金币商城等），应该每个功能模块里面都有我留下的代码吧。直到现在这个网址都是我打开次数相当高的网站了，甚至高于CSDN。
作为公司对类似竞品的一个重构，项目是成功的，我们五个人的团队，花费了一两个月的时间，把php的老项目改造为Java，并且相对来说，新项目可以说是公司最没有历史包袱的项目了，一切都是新的、简洁的，就像首页一样，干净，没有镶嵌在内部的各种“杂质”。既然开篇说了想到哪里写道哪里，不看代码，不看文档，就靠我现在的回忆想一下网站的功能。
1、资源 pudn安身立命的功能，也是我们看重的，这些是宝贵的财富。做了资源迁移、压缩包解析目录树、内容预览、预下载、新的会员积分体系等等，功能都是好功能，可惜用户流失，历史原因关站期间流失了太多用户，不复往日荣光。
2、咨询 其实就是文章，通过文章引流，提高网站整体seo流量，简单粗暴，当时做也就做了，毕竟一片欣欣向荣。可惜的是这个功能好像并没有带来预想的很好的效果，反而还带来了一些损害。这个功能现在看就是根本没有想明白，完全没有想清楚收获与代价。深刻总结，以后不能出现这种盲目做需求的事情了。
3、会员 要生存，要赚钱，会员系统必不可少，这没得说，不管外界反馈的好坏，在没有探索出新的盈利模式前提下，会员体系没有问题。
4、其他 打卡、任务、金币商城，一堆的小功能，想要吸引用户，提高用户使用网站的频率，出发点是好的，但是用户量太少了啊，这些都没有真正用到，所带来的正向改变没有足量的数据支撑都是空的。
5、总结 现在就想到了上述几个，发现所做的功能都是没有亮点的功能，甚至大多数其实都是功能上线之后就没有了后续的迭代，可能这也是网站没有像预期一样发展，反而走向下坡路，直到现在只进行维护，而且也不归我负责了，上半年项目上面算是小失败了。
学院 课程首页，下半年直到现在负责的就是它了，学院课程，看起来还可以，视频学习网站。2022年最有成就感的项目就是这个了。作为一个曾经辉煌过的网站，以前的销量收入非常可观，接手的时候可以说是低谷了，最开始做这个业务的时候，有一个很明显的感觉就是每天再解决问题，有处理不完的客诉，有各种bug，也算是度过了一段非常痛苦的时光，还好总会迎来光明。
客诉 学院客诉极多，甚至最基础的权益下发都有问题。其实逃避不了的是业务线的不统一。一个项目，单课、套餐课、讲师卡、捆绑课、大课、直播课...，总共9个课程类型，看过代码才会发现是多么复杂。以前php项目的重构，可以说是以前只重构了一部分吧，导致一些功能跑在Java上面、一些功能跑在php系统。个人原因，php在我手中并不能进行有效的维护。所以第一件事，砍掉功能。在保证业务正常使用的前提下，砍掉了业务线，只剩下单课、套餐课、讲师卡三种。然后就清晰了，客诉减少，直到现在权益下发、讲师分润的客诉一个月的量也只有之前一天的量了。
客诉这个问题，算是基本解决，直到现在，都可以很自豪的说，今年最大的成就感就是将学院用户的客诉极大的降低。
重做 可能大家对看不顺眼的东西都想要重做，我们选取的是首页。
左右旧新对比，很明显，新首页会好很多，起码如果我第一次来到学院，新的首页我会想要去翻着看一下这个网站的内容，右边旧的网站，我可能只想去搜索了。但是事实证明，用户还是更喜欢搜索，来你首页看的人还是少数。
网页的重做，必然带来代码的重写，此处我只有一个想法，代码一定要写注释啊。体验过翻译无注释代码的人肯定可以理解。
改变 出于一些保密原因，不能贴图展示，但是学院在10月份之后的收入是明显的上涨趋势，当时最喜欢的就是每天查一遍收入，生成一个折线图看看，乐此不疲（能看到自己做的功能收入上涨是一件很开心的事情）。但是不得不说，收入的偶然爆发不具有稳定性，可能是当天的营销活动，可能是某个公众号推广，可能学生放假了。受太多因素的影响了。
学院一直在改变，用表格展示一下。
功能是否正向备注删减业务、减少客诉正向极大减少我解决客诉的次数，好好好首页重构、增加灵活性正向虽然正向但是效果暂时不理想视频优化、转码优化、帧率优化正向各种针对视频的优化，我感觉是提升用户体验目前最好的也是急需的手段学院社区化待定配合社区化运营，整个学习渠道统一，我感觉还是有搞头的。详情可以查看帖子 不是弄虚作假，确实是想到哪里写哪里，还有很多待改变得，比如php剩余功能得改造，后台系统得迁移、播放页性能得优化，这些有的做了有的没做，暂时也不列举了，但是确实想到的看到得都是正向得发展。这是个好兆头，跟上半年做的事情完全不同了。
期望 也给自己定个目标吧，2022年做好得继续坚持，没做好的2023年加油。
热爱生活，认真工作坚持跑步、骑车、羽毛球，强健体魄学习新技能，在公司网站发表博客文章提升自己的价值，提高自己的不可替代性 后记 并没有进行系统性得总结，总结自己做的每个功能，总结自己在每件事上面得得失。得失只是暂时得，未来发展还有很远，只希望自己明年再回头看到这个文章得时候，可以看得懂，可以跟现在进行对比，明年如何就明年见了。
祝大家都能大展宏“兔”，“钱”“兔”似锦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29f432e23f56803115f7d6d52916c7f1/" rel="bookmark">
			MySQL基础——查看triggers表中触发器信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看triggers表中触发器信息
在MySQL中，所有触发器的定义都存在该数据库的triggers表中。读者可以通过查询triggers表来查看数据库中所有触发器的详细信息。查询语句如下所示。
SELECT * FROM information_schema.triggers;
其中，information_schema是MySQL中默认存在的库，而information_schema是数据库中用于记录触发器信息的数据表。通过SELECT语句查看触发器信息。其运行结果与图15.6相同。但是如果用户想要查看某个指定触发器的内容，可以通过WHERE子句应用TRIGGER字段作为查询条件。其代码如下所示。
SELECT * FROM information_schema.triggers WHERE TRIGGER_NAME= '触发器名称';
其中，“触发器名称”这一参数为用户指定要查看的触发器名称，和其他SELECT查询语句相同，该名称内容需要用一对“''”（单引号）引用指定的文字内容。
说明
如果数据库中存在数量较多的触发器，建议读者使用第二种查看触发器的方式。这样会在查找指定触发器过程中避免很多麻烦。
https://www.bilibili.com/video/BV1eW4y177VH/?spm_id_from=333.999.0.0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a24460d3643f84532d18c6e85635b09/" rel="bookmark">
			python------线程池的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在python中经常会使用异步,线程池,进程池,解决io操作,在爬虫中并不建议使用进程池(消耗过大)
目标:会使用线程池
1:导入
import time def demo1(): for i in range(3): print(f"我饿了{i}") time.sleep(1) def demo2(): for i in range(3): print(f"开饭了{i}") time.sleep(1) if __name__ == "__main__": start=time.time() demo1() demo2() end=time.time() print(end-start) #结果为 我饿了0 我饿了1 我饿了2 开饭了0 开饭了1 开饭了2 6.034951686859131 我们可以看到了只有在demo1完全运行完毕才会运行demo2,这个时候是单任务
2:基本使用方法
#1:导入threading模块 import threading #2:使用threading模块中的Thread创建一个对象 t1=threading.Thread(target=xx)#xx为函数的名字 #3:调用这个实例对象的start方法让这个线程开始运行 t1.start() import time import threading def demo1(): for i in range(3): print(f"我饿了{i}") time.sleep(1) def demo2(): for i in range(3): print(f"开饭了{i}") time.sleep(1) if __name__ == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a24460d3643f84532d18c6e85635b09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3f0e45f555012e8008837c44a11fbf1/" rel="bookmark">
			【面试题】2023年前端最新面试题-http篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文见：语雀（https://www.yuque.com/deepstates/interview/bo2kpn）
● HTTP报文
● HTTP连接管理
○ HTTP的连接性能优化
■ 持久连接
● 队头阻塞
■ 管道化
● 和HTTP相关的web服务器
○ 通信数据转发程序：HTTP代理、隧道
● 版本
HTTP 的特点和缺点?
一、特点：无连接、无状态、灵活、简单快速
● 无连接（http1.0）：每一次请求都要连接一次，请求结束就会断掉，不会保持连接
● 无状态：每一次请求都是独立的，请求结束不会记录连接的任何信息，减少了网络开销，这是优点也是缺点
● 灵活：通过http协议中头部的Content-Type标记，可以传输任意数据类型的数据对象(文本、图片、视频等等)，非常灵活
● 简单快速：发送请求访问某个资源时，只需传送请求方法和URL就可以了，使用简单，正由于http协议简单，使得http服务器的程序规模小，因而通信速度很快
二、缺点：无状态、明文传输、不安全
● 无状态：请求不会记录任何连接信息，没有记忆，就无法区分多个请求发起者身份是不是同一个客户端的，意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大
● 明文传输：报文(header部分)使用的是明文，直接将信息暴露给了外界，WIFI陷阱就是复用明文传输的特点，诱导你连上热点，然后疯狂抓取你的流量，从而拿到你的敏感信息
● 不安全：明文传输可能被窃听不安全，缺少身份认证也可能遭遇伪装，还有缺少报文完整性验证可能遭到篡改
http的理解？（恒生）
一、定义
超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。
二、特点（如上文）
三、优缺点（如上文）
HTTP报文 / HTTP消息
HTTP 报文组成部分?
一、http报文：由请求报文和响应报文组成
二、请求报文：由请求行、请求头、空行、请求体四部分组成
三、响应报文：由状态行、响应头、空行、响应体四部分组成
● 请求行：包含http方法，请求地址，http协议以及版本
● 请求头/响应头：就是一些key:value来告诉服务端我要哪些内容，要注意什么类型等
● 空行：用来区分首部与实体，因为请求头都是key:value的格式，当解析遇到空行时，服务端就知道下一个不再是请求头部分，就该当作请求体来解析了
● 主体
○ 请求体：请求的参数
○ 响应体：服务端返回的数据
● 状态行：包含http协议及版本、数字状态码、状态码英文名称
http请求方式
http方法？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3f0e45f555012e8008837c44a11fbf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a674cda4c0e5f438897ccac66cdbf30/" rel="bookmark">
			【面试题】2023年前端最新面试题，JS最新面试题-JS篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文见：语雀（https://www.yuque.com/deepstates/interview/bkbydt）
● js基础
● 现代模式
● 数据类型：
○ 数据类型
■ 基础数据类型
■ 引用数据类型
● 普通对象
● Array 数组
● Funciton（函数/类）
● Error对象
● 数字和日期对象
● 文本处理（正则表达式)
● 结构化数据（json)
● 控制抽象化
● 元编程/反射
○ 数据类型的判断
相关知识点：https://www.yuque.com/webfront/js
js基础
对js的理解？
js是一种基于对象和事件驱动，并具有安全性的脚本语言。
说几条写JavaScript的基本规范？
不要在同一行声明多个变量。请使用 ===/!==来比较true/false或者数值使用对象字面量替代new Array这种形式不要使用全局函数。Switch语句必须带有default分支函数不应该有时候有返回值，有时候没有返回值。For循环必须使用大括号If语句必须使用大括号for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。 js延迟加载的方式有哪些？
defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack。用得最多）、按需异步载入js
js对渲染影响？（数字马力）
现代模式，‘use strict’
javascript 代码中的"use strict";是什么意思 ? 使用它区别是什么？
一、use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,
二、区别
● 使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。 默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值; 全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用； 消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同;
● 提高编译器效率，增加运行速度； 为未来新版本的Javascript标准化做铺垫。
数据类型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a674cda4c0e5f438897ccac66cdbf30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/238c6bc9fa504e2bc00d4267f425c745/" rel="bookmark">
			dhu 码蹄集 oj赛（第三十二周）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是只会写黄金题的笨蛋
吃蛋糕 吃蛋糕
难度:黄金时间限制:1秒巴占用内存:128 M
小码哥很喜欢吃蛋糕。某一天，他来到了一条神奇的街上，这里依次开了 n家蛋糕店，每家蛋糕店只售卖一种类型的蛋糕。第 i家蛋糕店售卖的蛋糕拥有ai的饱腹值和bi的美味值。
小码哥从第一家蛋糕店开始向前行走。当他到达一个蛋糕店时，若他当前未处于饱腹状态，则会考虑是否吃这家店的蛋糕。若他在第﹔家店吃了一个拥有ai;饱腹值的蛋糕，则接下来从第 i＋1到第 i＋ai;家店他都不会吃任何东西。特别地，若i＋ai大于 n ，则他之后将会一直处于饱腹状态。
小码哥想知道，在满足上述要求的情况下，他能够吃到的蛋糕的美味值之和最大可以是多少。
解题 简单的dp动态规划
#include&lt;iostream&gt; #include&lt;math.h&gt; using namespace std; int choose(int n, int* dp, int* shop,int* b) {//dp存储到每个店时的最优值 int Max = 0 ; for (int i = 1; i &lt;= n; i++) { if (shop[i] + i +1&lt;= n) Max = max(dp[i] + b[i], Max); } return Max; } int choose_(int n, int dp[], int shop[],int b[]) {//最后一次判断条件不同 int Max = 0 ; for (int i = 1; i &lt;= n; i++) { if (shop[i] + i +1&gt;= n)//判断条件变化 Max = max(dp[i] + b[i], Max); } return Max; } int main() { int n = 0, shop[2001] = { 0 }, dp[2001] = { 0 }, b[2001] = { 0 }; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; shop[i]; for (int k = 1; k &lt;= n; k++) { cin &gt;&gt; b[k]; dp[k] = b[k]; } for (int i = 1; i &lt;= n ; i++) { dp[i] = choose(i, dp, shop,b); } dp[n] = choose_(n, dp, shop,b); cout &lt;&lt; dp[n]; return 0; } 传送阵 在泰拉大陆的某个角落，坐落着n 个传送门。这 n 个传送门排列方式非常特别，它们排布在一条直线上，相邻传送门的间隔相等，且每个传送门都能够向某个方向传送一定的距离。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/238c6bc9fa504e2bc00d4267f425c745/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/188/">«</a>
	<span class="pagination__item pagination__item--current">189/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/190/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>