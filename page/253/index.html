<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4374f1282440a39824d64bf2e8c2c010/" rel="bookmark">
			java代码中如何在hashMap中使用value找出对应的key值呢?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自:
java代码中如何使用value找出对应的key值呢?
HashMap简介:
基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 此实现假定哈希函数将元素适当地分布在各桶之间，可为基本操作（get 和 put）提供稳定的性能。迭代 collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。所以，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）
下文笔者讲述使用value找出对应key的方法分享，如下所示:
实现思路: 使用jdk8的stream流中的filter方法 对元素进行查找，并找出符合条件的元素 例:
package com.java265.other; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Map.Entry; import java.util.Optional; import java.util.stream.Collectors; public class Test16 { /** * java265.com 示例程序 * * @throws Exception */ public static void main(String[] args) throws Exception { Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put("k1", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4374f1282440a39824d64bf2e8c2c010/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cfd75739b3a0ba59d334a2f7c3dce1f/" rel="bookmark">
			Linux常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.查看目录命令 ls 查看当前路径下的目录信息
tree 以树状方式显示目录
pwd 查看当前露露路径
clear 清除终端内容 可用 唱跳rap篮球键+L替代
唱跳rap篮球 + shift + “ + ” 放大窗口字体
唱跳rap篮球 + “-” 缩小窗口字体
2.切换目标命令 cd 目录 切换到指定目录
cd ~ 切换到当前用户的主目录
cd .. 切换到上一级目录
cd. 切换到当前目录
cd- 切换到上一次目录
3 创建、删除文件和目录命令 touch 文件名 创建指定文件
mkdir 目录名 创建目录（文件夹）
rm 文件名 删除指定文件 删除非空目录： rm 非空目录 -r （-r 递归删除目录与其内容）
rmdir 目录名 删除空目录
4 复制、移动文件和目录命令 cp 复制（拷贝）文件、拷贝目录 复制目录要加上 -r
mv 移动文件、移动目录、重命名 移动目录不需要加选项 可以重命名文件与目录
5 终端命令格式组成 command [-options][parameter]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cfd75739b3a0ba59d334a2f7c3dce1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df96fb9cd8b3ba538fd9d76dce975572/" rel="bookmark">
			Centos8 环境下安装nginx 1.22，了解Nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一. 下载安装
二. 了解目录结构
三. 一些简单命令
四. Nginx配置文件（conf/nginx.conf）结构
五. Nginx具体应用
1. 部署静态资源
2. 反向代理
- 正向代理
- 反向代理
- 配置反向代理
3. 负载均衡
负载均衡策略
前言 Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，
Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。
一. 下载安装 1. 下载nginx安装包，网址：nginx: download
linux下安装：
wegt https://nginx.org/download/nginx-1.22.0.tar.gz 2. 下载nginx依赖包：
yum -y install gcc pcre-devel zlib-devel openssl openssl-devel 3. 解压 cd /usr/local tar -zxvf nginx-1.22.0.tar.gz 4. 指定安装路径
cd nginx-1.22.0/ ./configure --prefix=/usr/local/nginx 5. 编译安装
make &amp;&amp; make install 二.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df96fb9cd8b3ba538fd9d76dce975572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61f751033b18d4939996fa8c26a46239/" rel="bookmark">
			Excel文件读写(创建与解析)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
可以进行Excel文件处理的主流技术包括：
① Apache POI ( 基于DOM方式进行解析，将文件直接加载内存，速度较快，适合Excel文件数据量不大的应用场景)
② JXL (适合Excel文件数据量不大的应用场景)
③ Alibaba EasyExcel (采用逐行读取的解析模式，将每一行的解析结果以观察者的模式通知处理(AnalysisEventListener),所以比较适合数据量较大的Excel文件解析)
(其中常用的是Apache POI，Alibaba EasyExcel。)
一.Apache POI POI提供了对不同格式文件的解析：
HSSF用于解析旧版本的Excel文件(.xls)，由于旧版本的Excel文件只能存在65535行数据，所以已经不常用，目前常用XSSF解析Excel文件(.xlsx)。
首先添加jjar包依赖：
1. Workbook
Workbook接口代表一个Excel文件，通常创建它的实现类对象来创建(/加载)Excel文件，常用实现类是XSSFWorkbook。
(1).创建Excel文件
try (Workbook workbook = new XSSFWorkbook(); FileOutputStream out = new FileOutputStream("E:\\猿\\demo.xlsx")) { // 将 workbook 对象中包含的数据，通过输出流，写入至Excel文件 workbook.write(out); } catch (IOException e) { e.printStackTrace(); } (2).加载(解析)Excel文件
// 通过输入流，读取excel文件 FileInputStream in = new FileInputStream("E:\\成绩.xlsx"); // 将输入流传入Workbook Workbook workbook = new XSSFWorkbook(in); 注意还要关闭输入流，可以调用 in.close()，我们通常使用 try catch块来自动关闭：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61f751033b18d4939996fa8c26a46239/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea7d80653533598a4608739962efb673/" rel="bookmark">
			欢迎进入夜色的繁星博客导航一站式搜索(所有博客的汇总帖)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不辜负每个朝阳，不荒废每个深夜，因平凡而奋斗，因奋斗而不平凡。
--------夜色的繁星
目录
一、树莓派学习笔记整理。
二、python opencv笔记整理 三、建立网站 四、 pyqt5教程
五、linux命令 六、python零基础教学笔记
七、关于错误问题解决 八、pid控制笔记 九、51单片机 十、机智云 十一、有趣的外挂黑科技
十二、安卓开发
十三、作品制作笔记
十四、电子模块
十五、python视频教程代码 十六、esp8266
十七、零基础pcb设计教程 一、树莓派学习笔记整理。 树莓派优质网站汇总
超声波程序修改
windows 远程连接登录树莓派桌面
Raspberry Pi球跟踪机器人使用处理
树莓派自动跟随机器人
树莓派智能小车资料整理
关于树莓派大神博客的整理
命令行下查看python和numpy的版本和安装位置
树莓派笔记整理
整理一下这些天的树莓派笔记
windows 远程连接登录树莓派桌面
树莓派安装opencv教程
树莓派opencv调用摄像头
命令行下查看python和numpy的版本和安装位置
linux 1.命令行更改颜色.......
【树莓派】树莓派系统给python安装PyQt5的方法
python+pyqt5识别程序（第一版）
二、python opencv笔记整理 python3+opencv3.3环境搭建教程
python+opencv图像处理网易云课程笔记
基于神经网络的智能RC小车（Python+OpenCV）
OpenCV-Python 中文教程——OpenCV官方教程中文版（For Python）笔记加pdf
python3+opencv3.3环境搭建教程
Raspberry Pi球跟踪机器人使用处理
opencv识别图片颜色（1）
opencv颜色识别，含有蓝色像素
opencv 颜色识别（3）
蓝色识别成功
小车第一步（识别成功）
opencv-----平移
使用OpenCV和Python进行对象检测和跟踪
使用PIL和OpenCV在PC上模拟动画OLED / LCD显示器
改变图片每个像素点每个通道的灰度值
一位opencv大神的博客
python opencv入门必看
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea7d80653533598a4608739962efb673/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e919d4960e748460a3e376bf92ea086/" rel="bookmark">
			ASP.NET CORE的ActionFilter过滤器详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ActionFilter是ASP.NET CORE提供的一种方法过滤器或拦截器
一般用来在方法执行前或方法执行后来进行某些操作（AOP）
功能有点类似于Spring的Interceptor和AspectJ提供的AOP功能，
但实现的方法有好几种，下面我来介绍一下
1.实现IAcionFilter接口，重写其中方法 IActionFilter需要实现两个方法OnActionExecuting，OnActionExecuted
它们分别代表方法执行前，和方法执行后。
public class TestFilter : IActionFilter { //方法执行后调用 public void OnActionExecuted(ActionExecutedContext context) { throw new NotImplementedException(); } //方法执行前调用 public void OnActionExecuting(ActionExecutingContext context) { throw new NotImplementedException(); } } 这里测试一下
public class TheFirstFilter : IActionFilter { private readonly ILogger&lt;TheFirstFilter&gt; logger; public TheFirstFilter(ILogger&lt;TheFirstFilter&gt; logger) { this.logger = logger; } public void OnActionExecuted(ActionExecutedContext context) { logger.LogInformation("Do something After Action"); } public void OnActionExecuting(ActionExecutingContext context) { logger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e919d4960e748460a3e376bf92ea086/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2104563defaf6f01cc5cea4dbcdcad2/" rel="bookmark">
			STM32——定时器系列（二）通用定时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本篇中，小编主要给大家介绍如何使用通用定时器来产生PWM输出。
一、通用定时器的介绍 通用定时器是一个通过可编程预分频器驱动的16 位自动装载计数器构成。它适用于多种场合，包括测量输入信号的脉冲长度(输入采集)或者产生输出波形(输出比较和 PWM)。在使用定时器预分频器和RCC时钟控制器预分频器时，脉冲长度和波形周期可以在几个微秒到几个毫秒间调整。
二、通用定时器的功能 通用TIMx (TIM2、 TIM3、 TIM4和TIM5)定时器功能包括：
■ 16位向上、向下、向上/向下自动装载计数器。
■ 16位可编程(可以实时修改)预分频器。
■ 4个独立通道：
◆ 输入捕获◆ 输出比较◆ PWM生成◆ 单脉冲模式输出
■ 使用外部信号控制定时器和定时器互连的同步电路。
■ 如下事件发生时产生中断/DMA：
◆ 更新：◆ 触发事件◆ 输入捕获◆ 输出比较
■ 支持针对定位的增量(正交)编码器和霍尔传感器电路。
■ 触发输入作为外部时钟或者按周期的电流管理。
三、PWM的介绍 PWM控制即脉冲宽度调制技术，就是通过对一系列脉冲的宽度进行调制，来等效地获得所需要的波形（含形状和幅值）， PWM控制技术在逆变电路中应用最广，应用的逆变电路绝大部分是PWM型，广泛应用在从测量、通信到功率控制与变换的许多领域中。
四、PWM的实现方法 实现PWM的方法主要有传统的数字电路、微控制器普通I/O模拟和微控制器的PWM直接输出等。
■ 传统的数字电路方式：用传统的数字电路实现PWM（如555定时器）。
■ 微控制器普通I/O模拟方式：对于微控制器中无PWM输出功能情况（如51单片机），可以通过CPU操控普通I/O口来实现PWM输出。
■ 微控制器的PWM直接输出方式：对于具有PWM输出功能的微控制器，在进行简单的配置后即可在微控制器的指定引脚上输出PWM脉冲。
五、示例 某一天，小明突然想做一个基于STM32F103ZE开发板上的LED6、LED7的呼吸灯，那应该怎么做呢？下面请看小编的实现方法。
1、模块分析 在小明的呼吸灯项目中，我们需要用到的模块不多，仅仅使用LED模块与通用定时器模块就够了。利用LED模块可以控制LED灯状态，利用通用定时器模块来在定长时间后利用LED模块改变LED灯的状态。
2、实现代码 （1）主函数 int main(void) { u8 flag = 1; u32 count = 0; TIM3_PWMInit(); while(1){ dealy_ms(10); if(flag==1)	{ count++; if(count&gt;300)	flag=0;	}else{ count--; if(count==0) flag=1;	} //TIM_SetCompare1函数的参数2 Duty 将TIM3的时间段分成了两个部分，在Duty的时间之前与Duty时间之后两部分的高低电平是不一样的 TIM_SetCompare1(TIM3,count);//设置TIMx捕获比较1寄存器值 TIM_SetCompare2(TIM3,count);//设置TIMx捕获比较2寄存器值	}	} （2）、通用定时器函数 /* * @brif intialization of generic Timer3 which is used to PAM(初始化用于PWM的通用定时器定时器3) * @para none * @reval none */ void TIM3_PWMInit(void) { /* 定义初始化变量 */ GPIO_InitTypeDef GPIO_InitStructure; //声明一个结构体变量，用来初始化GPIO TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;//声明一个结构体变量，用来初始化定时器 TIM_OCInitTypeDef TIM_OCInitStructure;//根据TIM_OCInitStruct中指定的参数初始化外设TIMx /* 开启时钟 */ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); /* 配置GPIO的模式和IO口 */ GPIO_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2104563defaf6f01cc5cea4dbcdcad2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f7b229220d5ba0640adaa703c1750db/" rel="bookmark">
			合并两个有序链表（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解题思路：
第一步：先设置一个虚拟节点（傀儡节点）newNode，不做任何的数据处理。它的作用就是把两个链表中最小的节点放到它之后。
第二步：设置两个链表的头结点分别为head1和head2。然后比较这俩谁小，把小的往newNode后串。
第三步：当其中一个链表走完后，就把另一个链表剩下的节点直接串上，使其tmp.next=head1/head2。
图解：
完整代码如下：
//合并两个有序链表 public static Node mergeTwoLists(Node head1,Node head2){ Node newNode=new Node(-1); //虚拟节点，数据不具备意义 Node tmp=newNode; while (head1!=null&amp;&amp;head2!=null){ if (head1.val&lt; head2.val){ tmp.next=head1; tmp=tmp.next; head1=head1.next; }else{ tmp.next=head2; tmp=tmp.next; head2=head2.next; } } if (head1!=null){ tmp.next=head1; } if (head2!=null){ tmp.next=head2; } return newNode.next; } public static void main(String[] args) { SingleLinkedList singleLinkedList1=new SingleLinkedList(); singleLinkedList1.addLast(2); singleLinkedList1.addLast(7); singleLinkedList1.addLast(8); SingleLinkedList singleLinkedList2=new SingleLinkedList(); singleLinkedList2.addLast(1); singleLinkedList2.addLast(5); singleLinkedList2.addLast(9); singleLinkedList2.addLast(12); singleLinkedList2.addLast(21); Node ret=mergeTwoLists(singleLinkedList1.head,singleLinkedList2.head); singleLinkedList1.myToString(ret); 代码里用到的尾插法、打印链表在前面的实现一个简单的单向链表 里有提到，但是打印链表需要重载一个方法，原来的打印链表是从头结点开始的，但是在这里我们设置了一个傀儡节点，新节点。我们需要从新节点开始打印，重载的打印链表代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f7b229220d5ba0640adaa703c1750db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb32dca9b15b7bec84333469d6a65aa8/" rel="bookmark">
			MPLAB X IDE使用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MPLAB X使用技巧 1、Ctrl+空格：自动填充变量和函数名 2、文件版本控制 3、refactor（重构）重命名，替换所用使用到的文件 4、粘贴历史Edit-&gt;Paste from History 5、快速复制代码行 CTRL +SHIFT + 上/下箭头键复制行 6、交换/移动代码行 ALT + SHIFT +UP/DOWN 7、自动格式化和缩进 ALT + SHIFT +F 或 source -&gt; Format 8、注释 CTRL + / 9、ctrl + 左键跳转 10、变量用法列表Find Usages 11、使用CTRL + SHIFT + A在源文件和头文件之间切换 12、函数调用图 右键点击CALL + GRAPH 13、alt+ 滚轮调节字体大小 MPLAB添加头文件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6085690ad03bf49a0631d536d9b8bd2c/" rel="bookmark">
			HC-05蓝牙模块配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 1、连接蓝牙模块a.蓝牙模块通过USB转TTL连接电脑b.打开串口助手，波特率设置为38400c.检验是否连接成功 2、配置波特率3、修改密码4、设置主从模式5、设置蓝牙连接模式6、查询自身地址7、添加配对蓝牙地址8、测试 1、连接蓝牙模块 a.蓝牙模块通过USB转TTL连接电脑 按下按键，插上电脑USB，等待1-2秒再放开，当指示灯以2秒间隔闪烁时即为连接成功，此时已经成功进入参数设置模式。
b.打开串口助手，波特率设置为38400 c.检验是否连接成功 指令：AT+回车
返回：OK
2、配置波特率 指令：AT+UART=波特率,停止位,校验位+回车
返回：OK
停止位：0表示1位停止位，1表示2位停止位
校验位：0表示没有校验位，1表示奇数检验，2表示偶数检验
3、修改密码 指令：AT+PSWD=密码+回车
返回：OK
配对的两个蓝牙密码需要配置成一致的
4、设置主从模式 指令：AT+ROLE=模式代号+回车
返回：OK
模式代号：0表示从机，1表示主机
配对的两个蓝牙模块模式需要配置成一主一从的
5、设置蓝牙连接模式 指令：AT+CMODE=0+回车
返回：OK
配对的两个蓝牙模块模式使用0即可
6、查询自身地址 指令：AT+ADDR?+回车
返回：+ADDR：蓝牙地址 OK
7、添加配对蓝牙地址 指令：AT+BIND=配对对方蓝牙的地址（地址间的分号使用英文逗号代替才行）+回车
返回：OK
至此，配置完成，拔掉USB重新上电即可通信
8、测试 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ee4c7e48af9ca0a0e5ce2f7c75a6567/" rel="bookmark">
			机器学习Machine Learning学习笔记——反向传播
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 梯度下降 链式法则 二、反向传播 损失函数(Loss function)是定义在单个训练样本上的，也就是就算一个样本的误差，比如我们想要分类，就是预测的类别和实际类别的区别，是一个样本的，用L表示。代价函数(Cost function)是定义在整个训练集上面的，也就是所有样本的误差的总和的平均，也就是损失函数的总和的平均，有没有这个平均其实不会影响最后的参数的求解结果。总体损失函数(Total loss function)是定义在整个训练集上面的，也就是所有样本的误差的总和。也就是平时我们反向传播需要最小化的值。 对于L(θ)就是所有l^n的损失之和，所以如果要算每个L(θ)的偏微分，我们只要算每个l^n的偏微分，再把所有l^n偏微分的结果加起来就是L(θ)的偏微分，所以等下我们只计算每个l^n​的偏微分
取一个Neuron分析
梯度分散为：
计算∂z\∂w​（Forward pass的部分）计算∂l\∂z​​ ( Backward pass的部分 Forward Pass Backward Pass 递归的思想：
三、总结 目的：计算∂z\∂w​（Forward pass的部分）和计算∂l\∂z ( Backward pass的部分 )，然后把∂z\∂w​和∂l\∂z​相乘，我们就可以得到∂l\∂w。更新参数，梯度下降更新，得到最小损失函数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/612199c479b69865bed4e608edb0cb41/" rel="bookmark">
			Flink入门到实战-阶段三(DataStreamAPI)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 一个 Flink 程序，其实就是对 DataStream 的各种转换。具体来说，代码基本上都由以下几部分构成 ⚫ 获取执行环境（ execution environment ） ⚫ 读取数据源（ source ） ⚫ 定义基于数据的转换操作（ transformations ） ⚫ 定义计算结果的输出位置（ sink ） ⚫ 触发程序执行（ execute ） Execution Environment 创建执行环境 具体有以下三种 getExecutionEnvironment 最简单的方式，就是直接调用 getExecutionEnvironment 方法。它会根据当前运行的上下文 直接得到正确的结果：如果程序是独立运行的，就返回一个本地执行环境；如果是创建了 jar 包，然后从命令行调用它并提交到集群执行，那么就返回集群的执行环境。也就是说，这个方 法会根据当前运行的方式，自行决定该返回什么样的运行环境。 StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); createLocalEnvironment 这个方法返回一个本地执行环境。可以在调用时传入一个参数，指定默认的并行度；如果 不传入，则默认并行度就是本地的 CPU 核心数。 StreamExecutionEnvironment localEnv = StreamExecutionEnvironment.createLocalEnvironment(); createRemoteEnvironment 这个方法返回集群执行环境。需要在调用时指定 JobManager 的主机名和端口号，并指定 要在集群中运行的 Jar 包。 StreamExecutionEnvironment remoteEnv = StreamExecutionEnvironment .createRemoteEnvironment( "host", // JobManager 主机名 1234, // JobManager 进程端口号 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/612199c479b69865bed4e608edb0cb41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6df69e243a5945a171bc161e9ff4fe17/" rel="bookmark">
			最简操作系统内核HelloOS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最简操作系统内核HelloOS 文章目录 最简操作系统内核HelloOS1.Hello OS的引导流程2.HelloOS的引导汇编代码3.HelloOS的主函数4.控制计算机屏幕5.编译和安装6.操作过程图解6.1下载源码后解压6.2打开终端，执行命令make -f Makefile6.3将生成的HelloOS.bin文件拷贝到/boot文件夹下6.4在/boot/grub/grub.cfg中添加menuentry6.5进入GRUB引导界面，运行HelloOS 源码下载：HelloOS.zip-OS文档类资源-CSDN文库
运行环境：VMware+Ubuntu20（虚拟机的安装和配置问题请参考：VMware虚拟机安装 Linux（Ubuntu）教程_一顿吃不饱的博客-CSDN博客）
Hello OS的引导程序用的是GRUB（多重操作系统启动管理器），当Ubuntu安装好以后，GRUB就已经存在了。
1.Hello OS的引导流程 ​ 简单解释一下，PC 机 BIOS 固件是固化在 PC 机主板上的 ROM 芯片中的，掉电也能保存，PC 机上电后的第一条指令就是 BIOS 固件中的，它负责检测和初始化 CPU、内存及主板平台，然后加载引导设备（大概率是硬盘）中的第一个扇区数据，到 0x7c00 地址开始的内存空间，再接着跳转到 0x7c00 处执行指令，在我们这里的情况下就是 GRUB 引导程序。
2.HelloOS的引导汇编代码 ​ c是高级语言，它不能直接操作特定的硬件，所以我们用汇编代码处理c语言的工作环境。
MBT_HDR_FLAGS EQU 0x00010003 MBT_HDR_MAGIC EQU 0x1BADB002 ;多引导协议头魔数 MBT_HDR2_MAGIC EQU 0xe85250d6 ;第二版多引导协议头魔数 global _start ;导出_start符号 extern main ;导入外部的main函数符号 [section .start.text] ;定义.start.text代码节 [bits 32] ;汇编成32位代码 _start: jmp _entry ALIGN 8 mbt_hdr: dd MBT_HDR_MAGIC dd MBT_HDR_FLAGS dd -(MBT_HDR_MAGIC+MBT_HDR_FLAGS) dd mbt_hdr dd _start dd 0 dd 0 dd _entry ;以上是GRUB所需要的头 ALIGN 8 mbt2_hdr: DD MBT_HDR2_MAGIC DD 0 DD mbt2_hdr_end - mbt2_hdr DD -(MBT_HDR2_MAGIC + 0 + (mbt2_hdr_end - mbt2_hdr)) DW 2, 0 DD 24 DD mbt2_hdr DD _start DD 0 DD 0 DW 3, 0 DD 12 DD _entry DD 0 DW 0, 0 DD 8 mbt2_hdr_end: ;以上是GRUB2所需要的头 ;包含两个头是为了同时兼容GRUB、GRUB2 ALIGN 8 _entry: ;关中断 cli ;关不可屏蔽中断 in al, 0x70 or al, 0x80 out 0x70,al ;重新加载GDT lgdt [GDT_PTR] jmp dword 0x8 :_32bits_mode _32bits_mode: ;下面初始化C语言可能会用到的寄存器 mov ax, 0x10 mov ds, ax mov ss, ax mov es, ax mov fs, ax mov gs, ax xor eax,eax xor ebx,ebx xor ecx,ecx xor edx,edx xor edi,edi xor esi,esi xor ebp,ebp xor esp,esp ;初始化栈，C语言需要栈才能工作 mov esp,0x9000 ;调用C语言函数main call main ;让CPU停止执行指令 halt_step: halt jmp halt_step GDT_START: knull_dsc: dq 0 kcode_dsc: dq 0x00cf9e000000ffff kdata_dsc: dq 0x00cf92000000ffff k16cd_dsc: dq 0x00009e000000ffff k16da_dsc: dq 0x000092000000ffff GDT_END: GDT_PTR: GDTLEN dw GDT_END-GDT_START-1 GDTBASE dd GDT_START 以上的汇编代码分为 4 个部分：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6df69e243a5945a171bc161e9ff4fe17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac87cd9dca19734ab5db413c1e3d794c/" rel="bookmark">
			【Matlab】提取txt文件中的数据（逗号间隔），画二维折线图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 在日常数据分析时，将数据保存为txt的格式进行存储，本文利用textscan函数对文本文件数据进行提取，并利用其数据进行二维图像的绘制。
2. txt文件内容格式 3. 代码 clc; clear; %提取文件数据 filename = "data.txt"; fileID = fopen(filename); C = textscan(fileID, '%d %d',... 'Delimiter',','); x = C{1}; y = C{2}; %画图 plot(x, y); 4. 效果 希望各位读者细心阅读本文，一定会有所收获。
本人能力有限，若有错误，请评论区留言，及时改正，最后别忘了点赞、收藏及关注博主，后期会更新更多相关的文章哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77cd8a0a0b34e1bafc461288e1d77b1a/" rel="bookmark">
			【操作系统】调度算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🏫基本概念
🏥先来先服务（FCFS, First Come First Serve)
🏩短作业优先（SJF, Shortest Job First)
🍆细节
⛪️高响应比优先（HRRN,Highest Response Ratio Next）
🌇时间片轮转（RR,Round-Robin)
🏰时间片大小的影响
🗼优先级调度算法
🌄多级反馈队列调度算法
🌈实例 🗽多级队列调度
🏫基本概念 非剥夺调度方式，又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。
剥夺调度方式，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。
饥饿：某进程/作业长期得不到服务。
等待时间：指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。
周转时间：作业完成时间 - 作业提交时间
带权周转时间：作业周转时间 / 作业实际运行的时间
🏥先来先服务（FCFS, First Come First Serve) 🏩短作业优先（SJF, Shortest Job First) 短作业/进程优先调度算法：每次调度时选择当前已到达且运行时间最短的作业/进程。严格来说，用于进程调度应该称为短进程优先调度算法(SPF)抢占式的短作业优先算法又称“最短剩余时间优先算法”(SRTN)：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度。 🍆细节 ⛪️高响应比优先（HRRN,Highest Response Ratio Next） 高响应比优先算法：非抢占式的调度算法，只有当前运行的进程主动放弃CPU时（正常/异常完成，或主动阻塞），才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机。
以上三种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算法一般适合用于早期的批处理系统，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。
🌇时间片轮转（RR,Round-Robin) 时间片轮转调度算法：轮流让就绪队列中的进程依次执行一个时间片（每次选择的都是排在就绪队列队头的进程)
🏰时间片大小的影响 如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。 🗼优先级调度算法 非抢占式的优先级调度算法：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。抢占式的优先级调度算法：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。另外，当就绪队列发生改变时也需要检查是会发生抢占。 🌄多级反馈队列调度算法 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经在最下级的队列，则重新放回最下级队列队尾 只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片 被抢占处理机的进程重新放回原队列队尾 🌈实例 进程1在第1级队列执行一个时间片，进程1未结束，进入第2级队列 进程2在第1级队列执行一个时间片，进程2未结束，进入第2级队列 进程1在第2级队列执行两个时间片，进程1未结束，进入第3级队列 进程2在第2级队列执行一个时间片，由于此时进程3进入第1级队列，故执行优先级更高的进程3一个时间片，进程3执行完毕。第1级队列为空，为第2级队列分配时间片，此时只有进程2，进程2在第2级队列执行两个时间片，进程2执行完毕。 进入第3级队列，进程1在第3级队列执行四个时间片，进程1尚未结束，但是进程1已经处于最后一个队列，则重新放回最下级队列队尾，执行最后一个时间片，结束进程1。 比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而后三种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于交互式系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77cd8a0a0b34e1bafc461288e1d77b1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13bd6039b5623ee9f8bcec141a7f6183/" rel="bookmark">
			排序算法——堆排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1️⃣概念回顾
二叉树
完全二叉树
大根堆
小根堆
2️⃣堆排序
基本介绍：
算法思想：
实例：
思路步骤：
代码实现：
算法性能分析：
学习堆排序之前，先回顾以下概念：
1️⃣概念回顾 二叉树： 二叉树是指树中节点的度不大于2的有序树。
（节点的度：一个节点拥有子树的数目称为节点的度）
（分枝结点： 度不为0的结点）
完全二叉树： 完全二叉树是指：二叉树上每一层都是满的，或者最后一层没填满并且最后一层的叶子节点集中在树的左部。
例如：
（需要注意的是，满二叉树肯定是完全二叉树，而完全二叉树不一定是满二叉树。）
大根堆 每个结点的值都大于等于其左、右孩子的值。
小根堆 每个结点的值都小于等于其左、右孩子的值。
2️⃣堆排序 堆排序使用的是二叉堆的概念，二叉堆是一颗完全二叉树。
思考：从逻辑层面，如何将需要排序的数组转换成完全二叉树的形式？
根据观察规律，可以得出节点与其左右孩子下标之间的关系：
当前节点下标左孩子下标右孩子下标012134256378i2*i+12*i+2 基本介绍： 堆排序是利用堆这种数据结构所设计的一种排序算法。
堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。
升序采用大顶堆，降序采用小顶堆。
大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]
小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]
算法思想： 1、将无序序列构建成一个堆，根据升序降序需求选择大根堆或小根堆
2、将调整后的堆顶元素与末尾元素进行交换，将最大元素“沉”到数组末端。
3、将剩下元素重新构造成一个堆，继续进行调整，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。
⭐将堆调整成大根堆，调整思路：
从最后一个非叶子节点开始 寻找最后一个非叶子节点：不一定有右孩子，所以直接用左孩子节点来求：2*i+1=arr.length-1,则i=(arr.length-1-1)/2 选择左、右孩子中的较大值将较大值与其父节点相比较，将最大者调整为父节点从下至上，从右至左，依次进行调整 实例： 对数组[7,4,3,2,8,0,1,6,9]进行堆排序，升序排序。
思路步骤： 1、先将数组构建成一个堆
2、调整为大根堆的形式：
找最后一个非叶子节点：(arr.length-1-1)/2=7/2=3，下标为3 的节点为2
故先将[2,6,9]调整为大根堆形式：
3、接下来该调整节点3 ，发现已经是大根堆形式；所以，开始调节节点4。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13bd6039b5623ee9f8bcec141a7f6183/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f859cb321bccb9dac7247952f1f63d6c/" rel="bookmark">
			django基于python的旅游网站--python-计算机毕业设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目介绍 旅游网站系统的用户分管理员和用户两个角色的权限子模块。
管理员所能使用的功能主要有：首页、个人中心、用户管理、景点分类管理、景点信息管理、门票预订管理、酒店信息管理、客房信息管理、客房预订管理、美食信息管理、用户分享、系统管理等。
用户可以实现首页、景点信息、客房信息、美食信息、用户分享、公告信息、个人中心、后台管理、帮助中心等功能。
开发环境 开发语言：Python
框架：django
Python版本：python3.7.7
数据库：mysql 5.7（一定要5.7版本）
数据库工具：Navicat11
开发软件：PyCharm
浏览器：谷歌浏览器
功能介绍 这个系统的功能结构设计如图4-1所示。
4.1 系统功能模块图
前端 后端 目 录
目 录 III
第一章 概述 1
1.1 研究背景 1
1.2 开发意义 1
1.3 研究现状 1
1.4 研究内容 2
1.5 论文结构 2
第二章 开发技术介绍 1
2.2.1 django技术 1
2.2.2 mysql数据库介绍 1
2.2.3 MySQL环境配置 1
2.2.4 B/S架构 2
2.2.5 Vue框架 2
第三章 系统分析 1
3.1 可行性分析 1
3.1.1 技术可行性 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f859cb321bccb9dac7247952f1f63d6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ada53ffab85855db9a1ed0387f02d795/" rel="bookmark">
			django基于python的图书馆管理系统--python-计算机毕业设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目介绍 随着信息技术和网络技术的飞速发展，人类已进入全新信息化时代，传统管理技术已无法高效，便捷地管理信息。为了迎合时代需求，优化管理效率，各种各样的管理系统应运而生，各行各业相继进入信息管理时代，图书馆管理系统就是信息时代变革中的产物之一。
任何系统都要遵循系统设计的基本流程，本系统也不例外，同样需要经过市场进行调研，论文需求进行分析，概要设计，系统详细设计，测试和编码等步骤，设计并实现了图书馆管理系统。系统选用B/S模式，应用Python技术， MySQL为后台数据库。系统主要包括首页，个人中心，用户管理，图书馆管理，图书信息管理，图书类型管理，借阅信息管理，归还信息管理，续借信息管理，罚金信息管理，留言板管理，系统管理等功能模块。
开发环境 开发语言：Python
框架：django
Python版本：python3.7.7
数据库：mysql 5.7（一定要5.7版本）
数据库工具：Navicat11
开发软件：PyCharm
浏览器：谷歌浏览器
功能介绍 这个系统的功能结构设计如图4-1所示。
4.1 系统功能模块图
前端 后端 目 录
目 录 III
第一章 概述 1
1.1 研究背景 1
1.2 开发意义 1
1.3 研究现状 1
1.4 研究内容 2
1.5 论文结构 2
第二章 开发技术介绍 1
2.2.1 django技术 1
2.2.2 mysql数据库介绍 1
2.2.3 MySQL环境配置 1
2.2.4 B/S架构 2
2.2.5 Vue框架 2
第三章 系统分析 1
3.1 可行性分析 1
3.1.1 技术可行性 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ada53ffab85855db9a1ed0387f02d795/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad052320b05a2acb2bc9601d101fa5e0/" rel="bookmark">
			Quarkus 实战二：开发REST ful 服务实现简单的curd功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Quarkus 实战二：开发REST ful 服务实现简单的curd 概述 Quarkus集成了RESTEasy，这是一种用于定义REST API的JAX-RS实现
参考文档：
Quarkus 文档
JAVA JAX-RS文档
创建服务端点 JAX-RS是Quarkus 用来定义 RESTEasy默认的框架，你需要使用 Path GET,POST,PUT等动词注解来定义执行的方法
例如：
@Path("/hello") public class ExampleResource { /** * GET 请求方式 Produces(MediaType.TEXT_PLAIN) 定义返回的媒体类型 */ @GET @Produces(MediaType.TEXT_PLAIN) public String hello() { return "Hello from RESTEasy Reactive"; } } 以上实现的就是一个 GET 请求方法，用于请求查询数据的方法，
Produces 注解 用于定义返回的数据类型。
有效的HTTP动词注解： @GET、@POST、@PUT、@DELETE、@PATCH、@HEAD和@OPTIONS
获取请求参数 如何在方法中获取请求的参数，JAX-RS 规范中提供了一些内置的注解可以帮助我们获取参数：
@QueryParam 获取 url 请求参数 例如： name=12456 @QueryParam(“name”)
@HeaderParam 获取 Header 中的参数，常用来获取authorization 认证授权
@Context 定义一个对象，常用来获取 body中的数据，例如 post put方法使用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad052320b05a2acb2bc9601d101fa5e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a29e35f483c09ca72e7587066b1109a4/" rel="bookmark">
			Power BI----到底什么是度量值？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搞清楚什么是度量值很重要 一、度量值介绍二、度量值兄弟----快速度量值1.快速度量值的创建方法：2.快速度量值演示 三、度量值的管理和格式设置格式设定管理 四、度量值和新建列、新建表的区别 都说度量值是 Power BI 数据建模的灵魂，我们之前的内容中也是一直提到度量值，那到底什么是度量值？它有什么用？这一节，我们将仔细讲解到底什么是度量值。 一、度量值介绍 简单来说，度量值是用DAX公式创建一个虚拟字段的数据值，它不改变源数据，也不改变数据模型，如果你不在报表上使用它，甚至不知道它是什么样子的，而一旦被拖拽到报表上，便会随着各种筛选和维度展现不同的数据，所以度量值一般在报表交互时使用。
上面说了一大堆，说了又好像没说，直接看例子。
先建一个度量值【国内货物成本占比】：
国内货物成本占比 = DIVIDE(-SUM(fba_profit_data_processing_result[国内货物成本]),sum(‘fba_profit_data_processing_result’[总销售额]))
它是个什么，它是个值，从公式就知道，它是两个数据的比值。它在bi中存在样子如下：
它的存在不影响原始数据，也不影响原始数据的模型结构。
接着，我们把度量值放在报表上看看：
你以为就这？接着看
看到没，当给不同的维度（轴）时，展现的计算结果都是基于维度本身的，是不是很奇妙？
现在，回过头看它的定义说明，首先，它是一个计算的值，然后它可以根据给定的维度，展现基于维度上的计算结果，另外它的特点是，不占内存，不改变原始数据，还可以嵌套（一个度量值可以引用另一个度量值。
这里需要提一句，上面说的轴也就时常说的上下文，关于上下文的说明，之前讲解DAX的时候讲解过，大家可以回头看看，这个概念很重要。
二、度量值兄弟----快速度量值 对于刚接触读者，可能编写度量值有点头大，那怎么办呢？别慌，让它兄弟----快速度量值来帮你。顾名思义，快速度量值就是快速的建立度量值，不需要你写，只通过拖拽字段即可实现。老样子，看图看例子。
快速度量计算类型目前有六组，比如聚合、筛选器、时间智能、文本等，每组均包含一系列计算。
1.快速度量值的创建方法： 主页上的计算选项卡：
建模下的计算选项卡：
任意字段右键：
2.快速度量值演示 如下图，构建一个国内销售额相较于10组的其他组的差异
让我们看看DAX公式：
说实话，这公式我看着都头皮发麻，所以这也反映了快速度量值的强大，关于快速度量值，大家要多使用，毕竟比自己写方便快捷的多，当然如果你是大神，当我啥也没说哈！
我们也可以通过看快速度量值的代码，学习我们自己写代码的能力。
三、度量值的管理和格式设置 格式设定 大家应该发现了，建好度量值后，很多时候，并不是我们想要的格式，比如我们最开始建立的那个【国内货物成本占比】度量值，按理来说应该是百分比，但是却是数字，所以，需要我们调整数据格式。度量值格式调整有两种：
格式设定修改：
使用FORMAT函数修改：
国内货物成本占比 = FORMAT(
DIVIDE(
-SUM(fba_profit_data_processing_result[国内货物成本]),
sum(‘fba_profit_data_processing_result’[总销售额])
),
“0.00%”
)
关于更多的关于FORMAT函数的使用，请查看之前的文章【DAX讲解】学习，另外要注意的是，format函数修改过的度量值是文本格式，只能用于显示，不能进行计算。
管理 当我们创建的度量值很多时，会显得很乱，而且我们找起来也很不方便，所以我们通过给不同类的度量值放置不同文件夹，更好管理。效果如下：
通过上面的方式，我们可以很容易找到我们需要的度量值，具体的分类你可以是一页报表放一起，也可以一种数据类型放一起，看个人。具体设置方法如下：
点击模型窗口选择度量值给定文件夹名称，相同文件夹的度量值就会在一起。
四、度量值和新建列、新建表的区别 看这里，处理度量值外，还有个新建列和新建表，那是不是一样呢？当然不是。
项目说明特点度量值一个dax创建的计算值不占内存，不影响原始数据，可以根据上下文展现不同数据新建列数据中新增的一列占内存，影响原始数据，它的上下文是原始表的每一行新建表新建的一个内存表很占内存，相当于一个临时表，通过原表创建要提取指定上下文 所以，说白了，所有的区别在于上下文的差异，这也侧面说明了上下文的重要性。一般来说，为了性能考虑，能用度量值解决的问题就尽量不用计算列和新建表，当然如果度量值很复杂时，可以使用新建列和新建表，因为后两者是提前计算好的，不像度量值是每次用的时候计算的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a26429c10ebf8bf6077a39c831b7ca5/" rel="bookmark">
			Error:The storage permission application is abnormal或是给存储权限后仍然不能读写存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The storage permission application is abnormal. If you have adapted the scope storage, please register the &lt;meta-data android:name="ScopedStorage" android:value="true" /&gt; attribute in the AndroidManifest.xml file. If there is no adaptation scope storage, please use MANAGE_EXTERNAL_STORAGE to apply for permission
当compileSdkVersion 大于29后，需要在Manifest中添加
android:requestLegacyExternalStorage="true" 和
&lt;meta-data android:name="ScopedStorage" android:value="true" /&gt; 从我个人项目遇到的问题来看，需要这两段都添加才不会报错并且可以操作存储读写，具体添加位置如下
&lt;application android:requestLegacyExternalStorage="true" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;!-- 表示当前项目已经适配了分区存储特性 --&gt; &lt;meta-data android:name="ScopedStorage" android:value="true" /&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a26429c10ebf8bf6077a39c831b7ca5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8983b39aaeb2b089bd74da4a91e66ba6/" rel="bookmark">
			使用kubeadm部署 kubernetes v1.23.1 高可用集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境准备 使用服务器 Centos 8.4 镜像，默认操作系统版本 4.18.0-305.3.1.el8.x86_64。
注意：由于云服务器，无法使用VIP，没有办法使用keepalive+nginx使用三节点VIP，这里在kubeadm init初始化配置文件中指定了一个master01节点的IP。
主机名IP操作系统版本安装组件etcd01192.168.79.104.18.0-305.3.1.el8.x86_64https://github.com/etcd-io/etcd/releases/download/v3.5.1/etcd-v3.5.1-linux-amd64.tar.gzetcd02192.168.79.114.18.0-305.3.1.el8.x86_64etcd03192.168.79.124.18.0-305.3.1.el8.x86_64master01192.168.86.404.18.0-305.3.1.el8.x86_64docker-ce/kubeadm/kubelet/kubectlmaster02192.168.86.414.18.0-305.3.1.el8.x86_64master03192.168.86.424.18.0-305.3.1.el8.x86_64node01192.168.86.434.18.0-305.3.1.el8.x86_64docker-ce/kubeadm/kubeletnode02192.168.79.134.18.0-305.3.1.el8.x86_64 二、服务器初始化 所有服务器进行初始化，只需要对master和node节点就可以，脚本内容在Centos 8 已经得到验证。
1、主要做了以下操作，安装一些必要依赖包、禁用ipv6、启用时间同步、加载ipvs模块、修改内核参数、禁用swap、关闭防火墙等；
[root@node01 k8s_install]# cat 1_init_all_host.sh #!/bin/bash # 1. install common tools,these commands are not required. source /etc/profile yum -y install chrony bridge-utils chrony ipvsadm ipset sysstat conntrack libseccomp wget tcpdump screen vim nfs-utils bind-utils wget socat telnet sshpass net-tools sysstat lrzsz yum-utils device-mapper-persistent-data lvm2 tree nc lsof strace nmon iptraf iftop rpcbind mlocate # 2. disable IPv6 if [ $(cat /etc/default/grub |grep 'ipv6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8983b39aaeb2b089bd74da4a91e66ba6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76abd6c6a7af41a912cdf00237751762/" rel="bookmark">
			三维点云课程（三）——聚类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 聚类简介
2. 数学基础
2.1 谱定理与瑞利熵
2.2 概率论基础
2.2.1 联合概率
2.2.2 边缘分布
2.2.3 条件概率
2.3 图论
2.3.1 有向图
2.3.2 无向图
2.4 拉格朗日优化
3 K-Means算法
3.1 算法步骤
3.2 K-Medoids
3.3 K-Mean的缺陷
4 高斯GMM模型
4.1 概述
5 Spectral Clustering 谱聚类
5.1 概述
5.2 步骤
5.3 总结
1. 聚类简介 把相似的放在一起
2. 数学基础 2.1 谱定理与瑞利熵 谱定理：一个对称矩阵拆成两个旋转矩阵和一个缩放矩阵，缩放矩阵是对角矩阵。
瑞利熵：一个向量取值范围取决于缩放矩阵
2.2 概率论基础 2.2.1 联合概率 2.2.2 边缘分布 把其中一个变量直接去掉，通过联合分布得到单独的x，y分布
2.2.3 条件概率 指定y为某一个值的x的分布
贝叶斯公式
2.3 图论 2.3.1 有向图 由一系列的节点和一系列的边组成，节点代表随机变量，边代表随机变量之间的联系。z代表年龄，x代表发色。变量之间一定要有关联才能连线。有父子关系
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76abd6c6a7af41a912cdf00237751762/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9037ae622e0e95770000afae20ab54be/" rel="bookmark">
			MySQL七种日志总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、MySQL 日志分类 日志类别说明备注错误日志错误日志记录了当MySQL启动、停止或者服务器运行过程中发生任何严重错误时的相关信息，当数据库出现任何故障导致无法正常使用时，可以首先查看此日志；默认开启二进制日志（binlog日志）记录了所有的DDL和DML语句，但不包括数据查询语句，此日志对于灾难恢复时非常重要，并且MySQL的主从复制、增量恢复，也是通过该binlog 实现的。默认未开启，需要手动开启查询日志它记录了客户端的所有操作语句，包括增删改查所有语句；默认未开启，需要手动开启，注意，高并发场景企业里普通查询日志一般是关闭的（默认也是关闭的），主要是因为IO性能问题；慢查询日志它是用来记录查询效率较低的SQL语句的日志，慢查询日志记录所有执行时间超过参数long_query_time设置值，默认值为10s，默认未开启，需要手动开启审计日志根据国家等保审计合规要求，数据库要开启审计功能，它主要记录用户登录，对数据库的操作管理，对数据库受到的风险行为进行告警，对攻击行为及时阻断，通过审计日志可以对用户访问数据库行为进行记录、分析和汇报，用来帮助用户事后生成合规报告、事故追根溯源，同时加强内外部数据库网络行为记录，提高数据资产安全。MySQL企业版有此功能，属于收费组件，此测试社会版使用第三方开源插件。redo log重做日志，提供前滚操作，通常是物理日志，记录的是数据页的物理修改，而不是某一行或者某几行修改成怎样，它用来恢复提交后的物理数据页，数据数据页，并且只能恢复到最后一次提交的位置；undo log不是redo log的逆向过程，他们都是用来恢复的日志；undo log回滚日志，提供回滚操作，用来回滚到某个版本，undo log一般是逻辑日志，根据每行记录进行回滚； 2、错误日志 记录mysqld启动和停止时，以及服务器在运行过程中发生的任何严重错误时的相关信息。
1）查看错误日志
2）配置文件说明
。。。。 log-error=/data/mysql/3306/data/k8svip.err log_error_verbosity=3 log-error：开启错误日志，并记录到日志文件中；
log_error_verbosity：从MySQL 5.7.2开始，首选 log_error_verbosity 系统变量，而不是使用 log_warnings 系统变量，这个参数从MySQL 8.0.3开始被移除了，它分别对应：1 错误信息；2 错误信息和告警信息；3：错误信息、告警信息和通知信息；
log_warnings：5.7.2 之前的版本可以使用，0： 表示不记录告警信息；1： 表示告警信息写入错误日志，大于1， 表示各类告警信息，例如有关网络故障的信息和重新连接信息写入错误日志，注意不同的版本中，默认值不一样。
3）错误日志样例
3、二进制日志 二进制日志只记录了所有DDL与DML语句，不包括查询语句。
1）查看二进制日志配置
2）配置文件说明 log_bin=ON 表示开启binlog日志；log_bin_basename：binlog文件前缀log_bin_index：log_bin日志索引文件；log_bin_trust_function_creators：因为二进制日志的一个重要功能是用于主从复制，而存储函数有可能导致主从的数据不一致，所以当开启二进制日志后，参数log_bin_trust_function_creators就会生效，限制存储函数的创建、修改、调用；log_bin_use_v1_row_events：binlog版本信息，从mysql 5.6 开始，默认为 version2，默认值为OFF，ON的话，为使用binlog 版本v1；binlog_cache_size：默认是32K，建议设置大一些比如1M或者4M，在一个事务中 binlog 为了记录 sql 状态所持有的 cache 大小，如果你经常使用大的事务，可以增加此值来获取更大的性能，所有从事务中来的状态都会被缓冲在 binlog 缓冲中，然后待提交后一次性写入到 binlog 中，如果事务比此值大，会使用磁盘上的临时文件来替代，此缓冲在每个链接的事务第一次更新状态时被创建；max_binlog_cache_size：最大的二进制 Cache 日志缓冲尺寸；max_binlog_size：二进制日志文件的最大长度(默认设置1GB)，一个二进制文件信息超过1G前，MySQL服务器会自动提供一个新的二进制日志文件接续上；expire_logs_days：超过7天的binlog,mysql程序自动删除(如果数据重要,建议不要开启该选项)；sync_binlog：即每提交一次事务同步写到磁盘中；innodb_flush_log_at_trx_commit：即每提交一次事务都写到磁盘中； 3）日志文件格式
binlog日志格式格式说明备注STATEMENT日志文件中记录的是SQL语句，每一条对数据进行修改的SQL都会记录在日志文件中，通过MySQL提供的mysqlbinlog工具，可以清晰的查看每条语句的文本，主从复制时，从库会将日志解析为原文本，然后在从库重新执行一次；不记录每行数据变行，日志量少，节约IO，提高性能；由于它是记录的执行语句，所以为了让这些语句在slave端也能正确执行，那么它还必须记录每条语句在执行的时候的一些相关信息，也就是上下文信息，以保证所有语句在slave端执行的时候得到和master端执行时候相同的结果；手动配置ROW它在日志中记录的是每一行的数据变更，而不是记录SQL语句。例如：update test4 set name="aa"; 如果是STATEMENT，在日志中会记录一行SQL语句，如果是ROW，由于是对全表更新，也就是每一行记录都会发生变更，ROW格式的日志中会记录每一行数据的变更，这样可以会产生大量的日志内容，影响IO，但不记录上下文信息。手动配置MIXED兼容上面两种格式，默认情况下采用STATEMENT，但是在一些特殊情况下采用ROW来进行记录。MIXED格式量利用两种模式的优点，避开他们的缺点。默认开启 4）日志文件读取
可以使用mysqlbinlog 工作进行日志查看，但如果是ROW格式的日志，可以使用-v或-vv参数进行读取。
5）日志删除
方式备注命令行reset master;将所有Binlog日志进行删除，新日志编号从000001开始；purge master logs to 'mysql-bin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9037ae622e0e95770000afae20ab54be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/281bf49d7539b04c5cfe1fedc597eabf/" rel="bookmark">
			算法学习笔记——动态规划：概述（动态规划的要素、动态规划与DFS/BFS/贪心算法的区别）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态规划Dynamic Programming，DP问题 动态规划问题一般形式就是求最值（最长递增子序列、最小编辑距离）其本质就是穷举，但不是暴力穷举，其思想源于暴力穷举，但使用了“备忘录”或DP Table进行优化，此外再无奥妙可言（思考如何穷举-&gt;追求聪明地穷举） ps. 以后看到求最值问题，养成条件反射：首先思考如何穷举所有可能结果
动态规划与暴力穷举的区别 回溯（DFS）/BFS 都是暴力穷举所有可能结果，而如果问题具有最优子结构时，可以用以前计算的重叠子问题来求解更大的问题，此时就产生了动态规划因此，动态规划的核心是记忆：
①可以记忆，即最优子结构，问题可以被“分治”，用拆分的子问题来解决大问题
②需要记忆，即重叠子问题。（这是DP与回溯/DFS的主要区别，也是是能够使用动态规划的前提。像八皇后问题，没有重叠子问题，用 dp 也不能优化，反而浪费空间） 动态规划三要素 动态规划三要素：重叠子问题、最优子结构、状态转移方程
①有重叠子问题决定了动态规划与暴力穷举的不同，动态规划能使用“备忘录”或DP Table进行优化 [这是能够使用动态规划的前提]
子问题：将问题拆分为子问题，先解决子问题，再利用子问题解决大问题
②具备最优子结构，子问题相互独立，互不影响，才能保证通过子问题的最优解得到全局最优解
③列出正确的状态转移方程，是动态规划的核心ps. 何为最优子结构：子问题相互独立，互不影响
例如，要考出最高总分，那么每门课都要尽量考最高分，各门课互不干扰
反之，如果加条件：语文考得高数学就会考得低，子问题相互制约不独立，语文数学成绩不能同时达到最优，就不是最优子结构一般递归问题是“自顶向下”求解，需不断调用递归函数，引发重叠子问题
DP问题中，多使用“自底向上”求解，从而脱离了递归，由循环完成计算(利用DP Table避免重复计算子问题) 如何列出状态转移方程 核心问题就是状态、选择、DP数组的定义
思考问题的base case（最简单情况）是什么思考问题有什么“状态”，即子问题中的变量思考对于每个状态，有什么“选择”使状态改变
ps. 技巧：类比数学归纳思想，假定已知dp[0]...dp[i-1]，问自己怎么通过这些结果算出dp[i]，最后将这个模式套入所有dp的推导即可思考如何用DP数组/函数的含义来表现“状态”和“选择”，一般DP数组保存的变量（或DP函数的参数）就是2中的“状态” 最终，DP问题的整体框架就是
# 初始化base case dp[0][0][...] = base case # 状态转移 for 状态1 in 其所有可能取值: for 状态2 in 其所有可能取值: for ...: dp[状态1][状态2][...] = 求最值(选择1, 选择2, ...) 展开说明动态规划的思路 总体而言，就是思考如何穷举-&gt;追求聪明地穷举，即确定状态转移方程，然后通过状态转移方程写出暴力递归解，然后优化递归树，消除重叠子问题
暴力递归，递归过程中有大量重叠子问题利用备忘录的递归，自顶向下，避免重复计算利用DP Table的非递归解法，自底向上，本质同上优化：状态压缩 求斐波那契数列
暴力递归 def fib(N): if N == 0: return 0 if N == 1 or N == 2: return 1 return fib(N - 1) + fib(N - 2) 凡是递归问题，画出递归树，由助于分析算法复杂度和算法低效的原因
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/281bf49d7539b04c5cfe1fedc597eabf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9932fb9214629bdb531f8495bcb522df/" rel="bookmark">
			SQL优化小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在应用开发的早期，数据量少，开发人员开发功能时更重视功能上的实现，随着生产数据的增长，很多SQL语句开始暴露出性能问题，对生产的影响也越来越大，有时可能这些有问题的SQL就是整个系统性能的瓶颈。
SQL优化一般步骤 1、通过慢查日志等定位那些执行效率较低的SQL语句 2、explain 分析SQL的执行计划 需要重点关注type、rows、filtered、Extra。
type由上至下，效率越来越高。
ALL 全表扫描；index 索引全扫描；range 索引范围扫描，常用语&lt;,&lt;=,&gt;=,between,in等操作；ref 使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中；eq_ref 类似ref，区别在于使用的是唯一索引，使用主键的关联查询；const/system 单条记录，系统会把匹配行中的其他列作为常数处理，如主键或唯一索引查询；null MySQL不访问任何表或索引，直接返回结果；虽然上至下，效率越来越高，但是根据cost模型，假设有两个索引idx1(a, b, c),idx2(a, c)，SQL为"select * from t where a = 1 and b in (1, 2) order by c";如果走idx1，那么是type为range，如果走idx2，那么type是ref；当需要扫描的行数，使用idx2大约是idx1的5倍以上时，会用idx1，否则会用idx2。 Extra：
Using filesort：MySQL需要额外的一次传递，以找出如何按排序顺序检索行。通过根据联接类型浏览所有行并为所有匹配WHERE子句的行保存排序关键字和行的指针来完成排序。然后关键字被排序，并按排序顺序检索行；Using temporary：使用了临时表保存中间结果，性能特别差，需要重点优化；Using index：表示相应的 select 操作中使用了覆盖索引（Coveing Index）,避免访问了表的数据行，效率不错！如果同时出现 using where，意味着无法直接通过索引查找来查询到符合条件的数据；Using index condition：MySQL5.6之后新增的ICP，using index condtion就是使用了ICP（索引下推），在存储引擎层进行数据过滤，而不是在服务层过滤，利用索引现有的数据减少回表的数据。 3、show profile 分析 了解SQL执行的线程的状态及消耗的时间。
默认是关闭的，开启语句“set profiling = 1;”
SHOW PROFILES ;SHOW PROFILE FOR QUERY #{id}; 4、trace trace分析优化器如何选择执行计划，通过trace文件能够进一步了解为什么优惠券选择A执行计划而不选择B执行计划。
set optimizer_trace="enabled=on";set optimizer_trace_max_mem_size=1000000;select * from information_schema.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9932fb9214629bdb531f8495bcb522df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/197b13ef80a401b831507d1990fb4478/" rel="bookmark">
			三年工作经验java面试宝典（个人总结，现分享）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库 1.mysql的隔离级别有哪些，解读下脏读幻读
①Read Uncommitted（读未提交）
所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。
②Read Committed（读已提交）
这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。
③Repeatable Read（可重读）
这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。
④Serializable[ˈsɪərɪəlaɪzəbl]（可串行化）
这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。
这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：
脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。
在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示：
2.mysql和orcale的区别
①本质区别：orcale数据库是收费的，mysql数据库不收费
②安全性出发：orcale数据库安全性比mysql高
MySQL使用三个参数来验证用户，即用户名，密码和位置；Oracle使用了许多安全功能，如用户名，密码，配置文件，本地身份验证，外部身份验证，高级安全增强功能等。
③语法区别 :Orcale语法更为灵活，例如分页mysql用的是limit关键字，orcale用的是rownum关键字
④存储上的区别 :与Oracle相比，MySQL没有表空间，角色管理，快照，同义词和包以及自动存储管理。
⑤字符类型不同 mysql:CHAR和VARCHAR orcale:CHAR，NCHAR，VARCHAR2和NVARCHAR2;
⑥事务提交: MySQL默认是自动提交，而Oracle默认不自动提交，需要用户手动提交，需要在写commit;指令或者点击commit按钮
3.数据库优化之索引*
1、在表中建立索引，优先考虑where、group by使用到的字段。
2、尽量避免使用select *，返回无用的字段会降低查询效率。
3、尽量避免使用not exists 和not in，会导致数据库引擎放弃索引进行全表扫描。
4、尽量避免使用or，会导致数据库引擎放弃索引进行全表扫描。
5、尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描。
6、尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。
7. 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。 8、避免使用函数
4.sql优化实现
1.SQL语句尽量用大写的：因为oracle总是先解析SQL语句，把小写的字母转换成大写的再执行。
2.使用表的别名 ：当在SQL语句中连接多个表时, 尽量使用表的别名并把别名前缀于每个列上。这样一来,就可以减少解析的时间并减少那些由列歧义引起的语法错误。
5.索引
主键索引 PRIMARY KEY 它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引。注意：一个表只能有一个主键
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/197b13ef80a401b831507d1990fb4478/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5581f7e0013f63d443342a1d60690f08/" rel="bookmark">
			关闭拼写错误检查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Preferences -&gt; Inspections -&gt; typo
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecb309d41040e113a2684c15adc64cc1/" rel="bookmark">
			机器学习-决策树概述及对鸢尾花数据分类python实现利用graphviz模块画出决策树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 决策树概述2. 理论分析2.1 特征选择2.1 1 熵&amp;条件熵2.1.2 信息增益2.1.3 信息增益比 2.2 决策树的生成2.2.1 ID3算法2.2.2 C4.5算法2.2.3 决策树的修剪 3. python实现3.1 数据集3.2 python代码3.3 运行结果 1. 决策树概述 决策树（decision tree）是一种基本的分类与回归方法，在分类问题中，表示基于特征对实例进行分类的过程。学习时，利用训练数据，根据损失函数最小化的原则建立决策树模型；预测时，对新的数据，利用决策树模型进行分类。决策树的学习通常包括3个步骤：特征选择、决策树的生成和决策树的修剪。
决策树算法的基本思想：递归地选择最优特征，并根据该特征对训练数据进行分割，使得各个子数据集有一个最好的分类的过程。这个过程就是特征空间的划分，也是决策树的构建。
2. 理论分析 2.1 特征选择 通过信息增益或信息增益比，选择对数据分类影响最大的特征，即在这个最有特征的选择下，子集合有着最好的分类。信息增益和信息增益比涉及熵的概念。
2.1 1 熵&amp;条件熵 在信息论、概率统计、通信原理中，熵（entropy）是表示随机变量不确定性的度量。设是一个取有限个值得离散随机变量，其分布概率 P ( X = x i ) = p i P(X=x_{i})=p_{i} P(X=xi​)=pi​，随机变量 X X X的熵定义为：
H ( X ) = − ∑ i = 1 n p i log ⁡ p i ⋯ ⋯ i = 1 , 2 , … , n H(X)=-\sum_{i=1}^{n} p_{i} \log p_{i} \cdots \cdots i=1,2, \ldots, n H(X)=−i=1∑n​pi​logpi​⋯⋯i=1,2,…,n
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecb309d41040e113a2684c15adc64cc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8036f080a0eb8ab14b55bedd2d31fb46/" rel="bookmark">
			iOS中需要避免的内存泄漏总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、从AFNetWorking说起 对于AFNetWorking的使用我们通常会对通用参数、网址环境切换、网络状态监测、请求错误信息等进行封装。在封装网络请求类时需注意的是需要将请求队列管理者AFHTTPSessionManager声明为单例创建形式，使用者在相同配置下保证AFHTTPSessionManager只有一个，进行全局管理，因此我们可以通过单例形式进行解决。下方展示部分核心代码：
+ (AFHTTPSessionManager*)defaultNetManager { static AFHTTPSessionManager *manager; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ manager = [[AFHTTPSessionManager alloc]init]; manager.responseSerializer = [AFHTTPResponseSerializer serializer]; }); returnmanager; } 二、Block循环引用 Block循环引用的问题总结一句话防止Block循环引用就是要防止对象之间引用的闭环出现。 项目中代码为例：
[self CreateBaseRefesh:self.tableView type:ENT_RefreshHeader successRefesh:^(MJRefreshComponent *refreshView) { [self loadRefesh:refreshView];//会造成循环引用 }]; 应该改为：
__weak FloorViewController *weakSelf=self; [self CreateBaseRefesh:self.tableView type:ENT_RefreshHeader successRefesh:^(MJRefreshComponent *refreshView) { [weakSelf loadRefesh:refreshView]; }]; 三、delegate循环引用问题 delegate循环引用问题只需注意将代理属性修饰为weak即可 1@property (nonatomic, weak) id delegate; 下图比较形象的说明了使用weak修饰就是为了防止ViewController和UITableView相互强引用内存无法释放的问题：
四、NSTimer循环引用
当我们使用 _timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(timeRefresh:) userInfo:nil repeats:YES];时候 只要注意把计时器清除：
[_timer invalidate]; _timer = nil; 五、非OC对象内存处理 对于一些非OC对象，使用完毕后其内存仍需要我们手动释放。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8036f080a0eb8ab14b55bedd2d31fb46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d291c3dabb3c160585d0ef732991cfdb/" rel="bookmark">
			PyQt5的笔记（中-1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyQt5的笔记（上）连接：
(1条消息) PyQt5的笔记（上）_我行我素，向往自由的博客-CSDN博客
目录
3.QObject
3.1 继承的父类 3.2 对象的名称和属性设置-API
3.2.1 API
3.2.2 案例
3.3 父子对象的操作
3.3.1 API 3.3.2 Qt内存管理机制
3.3.3 应用场景与案例
3.4 信号与槽机制
3.4.1 API
3.4.2 案例
3.5 类型判定
3.5.1 API 3.5.2 案例
3.6 对象删除
3.7 事件处理
3.8 定时器
3.8.1 API
3.8.2 案例
4.QAbstractButton
4.1 子类化抽象类
4.2 文本设置
4.3 图标相关
4.4 设置快捷键 4.5 自动重复
4.6 状态读取
4.7 排他性
4.8 模拟点击
4.8.1 代码模拟鼠标点击 4.8.2 设置点击有效区域
4.9 可用信号
5.QPushButton 5.1 构造函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d291c3dabb3c160585d0ef732991cfdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/110e7366732d7cc3aa5940c2d029042f/" rel="bookmark">
			关于双符号数溢出的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用双符号数进行浮点数补码加减运算的过程中，一般会碰到如下几种情况：
1. 正数加正数：
如00，1111➕00，1000，此时的运算结果就为01，0111。
很明显，这发生了正溢出，因为在数值位只有4位，能表示的最大数值为1111，而运算结果显然超出了该范围，于是产生了像符号位的进位，造成上溢出。
2. 负数加负数：
如11，1111➕11，1000，此时的运算结果就为11，0111。
显然，这没有发生了溢出，其原因是在负数补码中，高位的1相当于原码的0，于是如果两个操作数的数值位最高位都是1的话，是一定不会引起操作数溢出的，与正数两个最高位为0相加，不会发生溢出是一样的。如果，有其中一个为0的话，如果次高位传来进位，依旧可以保证对符号位的进位，也就是保证符号位不会发生变化，从而避免了溢出。
所以在负数补码的运算当中，如果数值位最终产生了进位，则表明不会溢出，如果没有，则表明会溢出。
3. 正数和负数的运算不会引起溢出，此处不再赘述。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/054dc0b7e7252a4167db582ca1ceeae0/" rel="bookmark">
			k8s权限配置（ServiceAccount、Role、ClusterRole）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、在RBAC中的几个概念： 1、什么是RBAC RBAC全称Role-Based Access Control，是Kubernetes集群基于角色的访问控制，实现授权决策，允许通过Kubernetes API动态配置策略。
2、什么是Role Role是一组权限的集合，例如Role可以包含列出Pod权限及列出Deployment权限，Role用于给某个NameSpace中的资源进行鉴权。
3、什么是ClusterRole ClusterRole是一组权限的集合，但与Role不同的是，ClusterRole可以在包括所有NameSpace和集群级别的资源或非资源类型进行鉴权。
4、什么是Subject Subject：有三种Subjects，分别是Service Account、User Account、Groups，参照官方文档主要区别是User Account针对人，Service Accounts针对运行在Pods中运行的进程。
5、什么是RoleBinding与ClusterRoleBinding RoleBinding与ClusterRoleBindin：将Subject绑定到Role或ClusterRole。其区别在于：RoleBinding将使规则在命名空间内生效，而ClusterRoleBinding将使规则在所有命名空间中生效。
二、创建一个sa，并绑定Role和ClusterRole： 1、创建ServiceAccount apiVersion: v1 kind: ServiceAccount metadata: namespace: minio name: service-minio [root@app01 k8s-user]# vim service-account.yaml [root@app01 k8s-user]# kubectl apply -f service-account.yaml serviceaccount/service-minio created [root@app01 k8s-user]# kubectl get sa -n minio -owide NAME SECRETS AGE default 1 17m service-minio 1 14m [root@app01 k8s-user]# kubectl get serviceaccount -n minio -owide NAME SECRETS AGE default 1 18m service-minio 1 14m [root@app01 k8s-user]# 2、查找ServiceAccount的token用以登录 [root@app01 k8s-user]# kubectl describe sa service-minio -n minio Name: service-minio Namespace: minio Labels: &lt;none&gt; Annotations: kubectl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/054dc0b7e7252a4167db582ca1ceeae0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3376783c560cb5959df8f138829c009e/" rel="bookmark">
			IDEA解决内存不足 low memory(亲测好用)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1问题描述 今天使用IDEA右下角提示内存不足
Low Memory
The IDE is running low on memory and this might affect performance. Please consider increasing available heap.
如下图所示
2 分析问题 这是因为提示Java内存不足了,我们去增加内存即可
3 解决步骤 这里以IDEA2022版本为例
在IDE中 帮助(help)–&gt;change memory setting(改变内存设置)
默认应该是1024,我们改成2048
保存并重启即可
这种方式是我实践后觉得最快,最简单的方式,推荐给大家,当然解决办法不止这一个
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/343e784ac60aa33acc6e99367ed557f2/" rel="bookmark">
			Qt软件缩放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景
Windows 外接两个分辨率不同的显示器，4K和1K，保证软件在4K屏上显示与1K屏上显示大小一致，并且软件在两个屏上拖动软件布局显示不会有问题
此时需要把4k软件显示放大一倍，1k屏上软件正常显示
1.
SetProcessDPIAware(); qputenv("QT_SCALE_FACTOR", "1.0");
保证软件全局处于一致缩放比，防止软件在不同屏幕拖动获取不同的缩放因子导致软件界面出现问题
2.
QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
使软件自动适应高分辨率屏幕
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74d2601eaf9fc2aaf80831f9bf615783/" rel="bookmark">
			flutter 生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考
一、生命周期阶段 flutter生命周期大体上可以分为三个阶段：初始化、状态变化、销毁。 1、初始化阶段 对应执行构造方法和initState时候 2、状态变化阶段 开新的widget或者调用setState方法的时候 3、销毁阶段 deactivate 和 dispose 二、生命周期阶段执行的函数 1、initState 调用次数：1次 插入渲染树时调用，只调用一次，widget创建执行的第一个方法，这里可以做一些初始化工作，比如初始化State的变量。 2、didChangeDependencies 调用次数：多次 初始化时，在initState()之后立刻调用 当依赖的InheritedWidget rebuild,会触发此接口被调用 实测在组件可见状态变化的时候会调用 3、build 调用次数：多次 初始化之后开始绘制界面 setState触发的时候会 4、didUpdateWidget 调用次数：多次 组件状态改变时候调用 5、deactivate 当State对象从树中被移除时，会调用此回调，会在dispose之前调用。 页面销毁的时候会依次执行：deactivate &gt; dispose 6、dispose 调用次数：1次 当State对象从树中被永久移除时调用；通常在此回调中释放资源。 7、reassemble 在热重载(hot reload)时会被调用，此回调在Release模式下永远不会被调用 三、App生命周期 通过WidgetsBindingObserver的didChangeAppLifecycleState 来获取。通过该接口可以获取是生命周期在AppLifecycleState类中。 1、resumed 可见并能响应用户的输入，同安卓的onResume 2、inactive 处在并不活动状态，无法处理用户响应，同安卓的onPause 3、paused 不可见并不能响应用户的输入，但是在后台继续活动中，同安卓的onStop 下面是生命周期： 初次打开widget时，不执行AppLifecycleState的回调； 按home键或Power键， AppLifecycleState inactive----&gt;AppLifecycleState pause 从后台到前台：AppLifecycleState inactive---&gt;ApplifecycleState resumed back键退出应用： AppLifecycleState inactive---&gt;AppLifecycleState paused ———————————————— 版权声明：本文为CSDN博主「一杯清泉」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/yoonerloop/article/details/121003373 生命周期详情
Flutter 中的生命周期，包含以下几个阶段： createState ，该函数为 StatefulWidget 中创建 State 的方法，当 StatefulWidget 被调用时会立即执行 createState 。 initState ，该函数为 State 初始化调用，因此可以在此期间执行 State 各变量的初始赋值，同时也可以在此期间与服务端交互，获取服务端数据后调用 setState 来设置 State。 didChangeDependencies ，该函数是在该组件依赖的 State 发生变化时，这里说的 State 为全局 State ，例如语言或者主题等，类似于前端 Redux 存储的 State 。 build ，主要是返回需要渲染的 Widget ，由于 build 会被调用多次，因此在该函数中只能做返回 Widget 相关逻辑，避免因为执行多次导致状态异常。 reassemble ，主要是提供开发阶段使用，在 debug 模式下，每次热重载都会调用该函数，因此在 debug 阶段可以在此期间增加一些 debug 代码，来检查代码问题。 didUpdateWidget ，该函数主要是在组件重新构建，比如说热重载，父组件发生 build 的情况下，子组件该方法才会被调用，其次该方法调用之后一定会再调用本组件中的 build 方法。 deactivate ，在组件被移除节点后会被调用，如果该组件被移除节点，然后未被插入到其他节点时，则会继续调用 dispose 永久移除。 dispose ，永久移除组件，并释放组件资源。 整个过程分为四个阶段： 初始化阶段，包括两个生命周期函数 createState 和 initState； 组件创建阶段，也可以称组件出生阶段，包括 didChangeDependencies 和 build； 触发组件多次 build ，这个阶段有可能是因为 didChangeDependencies、setState 或者 didUpdateWidget 而引发的组件重新 build ，在组件运行过程中会多次被触发，这也是优化过程中需要着重需要注意的点； 最后是组件销毁阶段，deactivate 和 dispose。 import 'package:flutter/material.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74d2601eaf9fc2aaf80831f9bf615783/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/203159f959b3791fd8b389f3aedef178/" rel="bookmark">
			OpenHarmony工具集之字符串工具·让代码更精简
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 字符串处理是应用程序中最常见的，比如用户账号输入是否为空，用户账号是否数字、字母组合，用户password是否数字、字母、特殊符号组合等。如果每个字符串验证的地方都去写，代码量大且不易维护，将共用性强的抽离成方法，统一调用则会使代码更健壮。
准备知识 replace() 替换字符串中的字符为其他字符substr() 从指定开始位置截取字符串到指定结束位置正则表达式 封装方法 isEmpty(str: string) 是否为空isNotEmpty(str: string) 不为空isAnyEmpty(...strArr: any) 存在空isNoneEmpty(...strArr: any) 所有值不为空isBlank(str: string) 是否为真空（和isEmpty区别在于空格的判断）isNotBlank(str: string)不为真空isAnyBlank(...strArr: any) 存在真空isNoneBlank(...strArr: any) 所有值不为真空isAlpha(str: string) 只包含字母isAlphaSpace(str: string) 只包含字母、空格isAlphanumeric(str: string) 只包含字母、数字isAlphanumericSpace(str: string) 只包含字母、数字和空格isNumeric(str: string)数字isSpecialCharacterAlphanumeric(str: string) 只包含特殊字符、数字和字母removePrefix(str: string, prefix: string)移除指定前缀removeSuffix(str: string) 移除文件后缀 使用方法 在具体页面引入StrUtil
import str from '@ohos/tecore/src/main/ets/utils/StrUtil'; 需要调用字符串处理方法的地方，调用需要的方法即可。如下代码实现移除文件后缀名：
@Entry @Component struct StrUtil { @State text: string = ""; @State realStr: string = ""; controller: TextInputController = new TextInputController(); build() { Flex({direction: FlexDirection.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/203159f959b3791fd8b389f3aedef178/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c14bd4c2b2c8a458bbcfaa0b2399629a/" rel="bookmark">
			C&#43;&#43;生成随机数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#1.rand
##1.语法：rand();
##2.单独写一个rand（）;,会生成随机数，但范围我不知道捏
##3.常用格式：rand（）% 100 +1 ;可生成1~100的随机数（但这个随机数好像开机以后就是这个ll）,再来看看rand（）%a + b 这种，范围为b~a-1+b，a表示范围 （0~a），b就不说辣
##4.若要生成0~1小数（精确两位），可以除100
##5.生成的随机数一样也会便于调试
#2.srand
#include&lt;iostream&gt; using namespace std; int main() { srand(time(NULL)); int num = rand(); cout &lt;&lt; num &lt;&lt; endl; return 0; } 根据系统时间出的值（连续运行的话出的值还是有点规律的感觉滴）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/292cf0d3e172e52839a83eed8a6eed26/" rel="bookmark">
			Flowable 查询当前用户的待办任务方法报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在查询当前用户的待办任务，包括本人就是处理人的或者还是候选人状态的任务时，方法为：
List&lt;Task&gt; list = taskService.createTaskQuery().taskCandidateOrAssigned(userId). orderByTaskCreateTime().desc().list(); 执行出现以下错误：
复制出来的完整sql为：
SELECT RES.*, VAR.ID_ as VAR_ID_, VAR.NAME_ as VAR_NAME_, VAR.TYPE_ as VAR_TYPE_, VAR.REV_ as VAR_REV_, VAR.PROC_INST_ID_ as VAR_PROC_INST_ID_, VAR.EXECUTION_ID_ as VAR_EXECUTION_ID_, VAR.TASK_ID_ as VAR_TASK_ID_, VAR.BYTEARRAY_ID_ as VAR_BYTEARRAY_ID_, VAR.DOUBLE_ as VAR_DOUBLE_, VAR.TEXT_ as VAR_TEXT_, VAR.TEXT2_ as VAR_TEXT2_, VAR.LONG_ as VAR_LONG_ FROM ( SELECT RES.* from ACT_RU_TASK RES WHERE (RES.ASSIGNEE_ = ? or ( RES.ASSIGNEE_ is null and exists(select LINK.ID_ from ACT_RU_IDENTITYLINK LINK where LINK.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/292cf0d3e172e52839a83eed8a6eed26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb851cdef4b683d1453fb106f39773c8/" rel="bookmark">
			解决VM虚拟机中ubuntu系统上不了网的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最简单的方式 关闭虚拟机在对应的虚拟机上右键，点击设置，找到网络适配器，点击移除，再次点击添加，将网络适配器再次添加回来，点击确定重启虚拟机 如果第一种方式解决不了问题，请使用第二种方式
第二种方式 打开终端，(1) 输入sudo service network-manager stop(2) sudo rm /var/lib/NetworkManager/NetworkManager.state(3) sudo service network-manager start(4) sudo vim /etc/NetWorkManager/NetworkManager.conf，将其中的managed=false改为managed=true 或者使用gedit，采用图形化界面的方式更改(5) sudo service network-manager restart 第三种方式 不是很管用 最管用，当第一种方式无法解决的时候，启用这种方式参考链接 VMware虚拟机Ubuntu16.04联网问题解决方案 - SegmentFault 思否首先关闭ubuntu系统点击编辑，虚拟网络编辑器出现如下界面，点击编辑，选中VMnet8的Nat模式，点击还原默认设置，就会卸载先前的所有虚拟网卡，重新配置新的虚拟网卡 ubuntu 虚拟机选着 NAT模式不变 第四种方式 成功了 参考链接VMware Ubuntu虚拟机挂起休眠，唤醒后连不上网的问题解决方案 - 掘金1 将虚拟机网络适配器改为主机模式；2 在Ubuntu指令窗口中依次输入以下指令： sudo service network-manager stop sudo rm /var/lib/NetworkManager/NetworkManager.state sudo service network-manager start 3 将网络适配器换回NAT/桥接/其他模式纪念一下 花费了我近两个小时的时光 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ad854c08b0df7512b68faec6c3619bf/" rel="bookmark">
			c和c&#43;&#43;静态库之间如何相互调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍c语言写的项目如何调用c++实现的库和c++如何调用c语言实现的库
文章目录 一、c++项目如何调用c的库(以静态库为例）1.将栈的源文件和头文件拷贝一份到Stack_c.lib这个项目的路径下2.打包成静态库3.建立一个c++项目（TestStacklib) 引入c项目中的头文件4.设置附加库和附属关系 二、c项目如何调用c++的库（静态库为例）1.建立c++项目（Stack_cpp) 并且将栈的源文件和头文件包含在该目录 将其打包为cpp的静态库2.建立c项目3.包含静态库的头文件4 .添加打包的cpp动态库到附加库目录 设置依赖项 一、c++项目如何调用c的库(以静态库为例） ⛄️示例：建立一个项目Stack_c.lib，将该项目中的栈的实现的代码打包为一个静态库，再建立另一个c++的项目,并调用打包好的c实现的静态库里的栈的相关函数
1.将栈的源文件和头文件拷贝一份到Stack_c.lib这个项目的路径下 2.打包成静态库 ⛄️应用好之后就点击生成解决方案 ，之后就会生成一个Stack_c.lib的静态库了 （与项目名重名了，问题不大 不要在意）
生成后我们可以点开项目的所在目录下 找到debug目录 可以看到里面多了一个Stack_c.lib的静态库文件 表示打包成功！
⛄️至此，静态库就打包好了，当然是编译器帮我们打包的，后续会更新如何自己亲手打包一个库（动静态库的知识）！
3.建立一个c++项目（TestStacklib) 引入c项目中的头文件 🎸注意：这里的引入头文件的路径可以是相对路径 其中…是代表的上级目录 只需找到自己创建的动态库的头文件的路径并在新建的c++项目中包含即可
本文中的test.cpp是一段关于括号匹配的算法代码 可以用建的静态库里的栈的特性来解决
bool isValid(const char* s) { const char* cur = s; stack stack; StackInit(&amp;stack); while (*cur != '\0') { if (*cur == '(' || *cur == '{' || *cur == '[')//如果是左括号就进栈 { StackPush(&amp;stack, *cur); } else { if (StackEmpty(&amp;stack))//考虑到开始是右括号，那么就是栈为空，就不可能有效，直接返回FALSE { return false; } char top = StackTop(&amp;stack); if (*cur == ')' &amp;&amp; top == '(' || *cur == '}' &amp;&amp; top == '{' || *cur == ']' &amp;&amp; top == '[') { StackPop(&amp;stack); } else { return false; } } cur++; } if (StackEmpty(&amp;stack))//有可能只有一个左括号，进栈就没了，有效还有判断栈是否为空，为空才是有效括号 return true; else return false; } int main() { cout &lt;&lt; isValid("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ad854c08b0df7512b68faec6c3619bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4606ab3c97a4a786a342ae68c659396a/" rel="bookmark">
			大乐透双色球生成代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大乐透双色球生成 代码如下：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box { display: flex; justify-content: space-around; align-items: center; } .ball { width: 30px; height: 30px; border-radius: 50%; background-color: #fff; text-align: center; line-height: 30px; margin: 0 5px; /* float: left; */ color: #fff; } .red-ball { background-color: red; } .blue-ball { background-color: blue; } .btn-box { display: flex; flex-wrap: wrap; justify-content: space-around; align-items: center; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4606ab3c97a4a786a342ae68c659396a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50de9e2feee1e2643727cebf9cafcc05/" rel="bookmark">
			ArcGIS中shp矢量图层多台电脑共同编辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ArcGIS中shp矢量图层多台电脑共同编辑 文章目录 ArcGIS中shp矢量图层多台电脑共同编辑前言一、安装软件二、创建SDE空间数据库实现数据共享1.组建局域网2.创建空间数据库3.在ArcGIS中创建空间地理数据库4.子电脑连接数据库 总结 前言 作为测绘人员，使用ArcGIS处理shp矢量数据是非常频繁的事情。然而，对于特别大的矢量数据处理必然会是多人合作完成，那么在处理完矢量数据之后就会存在一个合图的问题，需要将多个人完成后的矢量数据合并到一幅图中。这种合图方式必然会出现某几人接边区域出现重合、交叉等问题。
下面介绍一种方法可以完美解决合图的问题，并且可以实现多人同时编辑同一图层。
一、安装软件 这一方法所需要用到的软件：ArcGIS 10.2、SQL Server以及ArcgisServer10.2授权文件
二、创建SDE空间数据库实现数据共享 1.组建局域网 根据本人亲身实践，当时使用的是：使用交换机通过网线连接多台电脑，交换机在某一口中接入网络，或者使用路由器也可以。如果多台使用的是相同的无线网也是局域网，但是这样会造成卡顿。
2.创建空间数据库 选择一台性能好的电脑作为服务器，用该电脑在局域网中创建数据库。
查看局域网地址 在控制面板——&gt;网络和 Internet——&gt;网络和共享中心——&gt;以太网——&gt;详细信息，查看IPv4地址，在这个地址上建立空间数据库。
或者，“win+R”在命令行输入“cmd”，之后输入“ipconfig/all”也可以查看局域网地址
3.在ArcGIS中创建空间地理数据库 打开Arcmap，点击工具箱中“创建企业级地理数据库”
此时已经在局域网中搭建好共享的空间地理数据库。（数据库取名时以sde开头）
4.子电脑连接数据库 除服务器以外的其他电脑在Arcmap中连接服务器建立的空间地理数据库。每台子电脑必须配备ArcGIS10.2的软件。如果在下面的连接操作过程中出现以下错误提示，那么可以尝试安装SQL Server数据库（无需完整安装）解决，可参考此链接。
一般提示这种错误的是arcgis服务区和SQL server服务器不在同一台电脑上，但在同一个局域网。遇到这种问题是arcgis 服务器客户端连接SQL server数据库有问题，要么是客户端没有安装，要么是安装客户端但连接有问题。SQL server数据库仅安装以下部分即可。
打开Arcmap，在目录树点击“数据库连接”——&gt;“添加数据库连接”
或者，在ArcCatalog中打开目录树进行操作（纯属个人习惯）
2.在数据库中的数据右击“管理”——&gt;“注册版本”
在”编辑器“的”选项“按钮中注意以下红框位置要勾选上（一般默认勾选）
总结 虽然这个方法会省去合图的麻烦，但是也存在一些问题。例如，
对于充当服务器的电脑配置有一定的要求，性能越好画图时出现的卡顿越少；即使性能已经非常好的电脑，多人共同编辑同一图层时也会出现卡顿，这可能是Arcgis的这一操作功能仍然存在一些问题。本人在工作中遇到这个问题时发现了，如果某一台电脑出现卡顿、转圈、无法操作时，其他电脑点击“保存编辑内容”之后出现卡顿的电脑就会恢复正常。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d446478d66b1c9f57ab5713e9a10c7b/" rel="bookmark">
			地形图测量中的等高线裁剪方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		地形图测量中的等高线裁剪方法 提示：写完文章后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 地形图测量中的等高线裁剪方法前言一、操作步骤1.shp面数据导出2.Arcmap与CAD间操作3.等高线赋属性 总结 前言 对于等高线的裁剪，一般我们采用两种方法：一种是在cass中使用裁剪工具进行裁剪，另一种是在eps中裁剪等高线，因为eps中的裁剪工具可以画线裁剪，会比cass要好用一些。不过在进行这一操作之前可以使用ArcGIS对等高线进行面擦除，这样对于闭合的坡、房屋和水系来说，横穿的等高线就会被擦除，对于大型地形图测量会节省大量时间。
下面介绍一下，对于在eps中测完的数据（这些数据是有属性的，具有对应地物的编码），如何按面裁剪等高线
一、操作步骤 1.shp面数据导出 在eps软件中，选中所有的斜坡、房屋面和水系面等不能存在等高线的面数据，之后点击“数据转换”，选择“shp输出”，保存到某一路径下（对于导入的dwg文件数据，需要对其进行转码，然后再shp输出）；
2.Arcmap与CAD间操作 打开Arcmap软件，将第一步导出的shp数据加载到图层中（只需要加载面数据），然后在最上面的图层右击选择“属性”，给图层附上坐标系：CGCS2000-3度带-41。（这一步可以试试不操作，或许也可以，没试过）
在导入的面数据右击“导出数据”——&gt;“导出至CAD”（由于使用的是CAD2006软件，所以导出时版本记得选择2004版）
原理：eps导出的shp数据已经是面数据了（房屋面、水系面、为加固斜坡等本身就是面数据，陡坎不是面数据！），在Arcmap中导入再导出CAD是为了在CAD中查看面数据是否闭合
在cass中检查各个面数据是否闭合（存在有的面不是闭合面的情况）
检查好的dwg格式面数据再导入到Arcmap中，然后右键”数据导出“成shp数据，完成后加载到地图上
在Arcmap中导入dwg格式等高线，在等高线右击数据导出成shp，将等高线转换成shp数据，完成后加载到地图上
在工具箱中找到“擦除”工具（“分析工具”——&gt;“叠加分析”——&gt;“擦除”），其中输入要素为等高线
3.等高线赋属性 擦除完成后的等高线数据导出到CAD，目的是将等高线转成dwg格式，方便eps调入。
在eps中调入外部数据，选择上述dwg格式等高线，在eps中全选等高线转码成首曲线（全部转成首曲线）选择“处理”——“线”——“等高线检查、着色、自动修复”，然后将计曲线改成绿色，首曲线改成黄色（计曲线是少的，首曲线是多的）过滤——选中绿色计曲线导出
注：1. CAD中计曲线为蓝色，首曲线40色号；
2.如果在最开始cass生成等高线的时候新建计曲线和首曲线两个图层，那么最后裁完的等高线就只需要转码即可，不需要进行以上等高线赋属性的操作 总结 现对以上步骤做一个总结：
1.在cass中利用总图的高程点生成等高线，新建计曲线和首曲线两个图层，将少的绿色线放入计曲线图层，多的黄线放入首曲线图层；
2.在eps中将居民地面、地貌面、水系面和房屋面等面图层（对于其中含有的dwg面数据要提前进行转码）导出成shp数据（总图的shp面数据）；
3.打开Arcmap，将总图的shp面数据用Arcmap数据导出成dwg文件，这一步骤目的是将总图的shp面数据转成CAD可以打开的dwg格式数据；
4.打开dwg格式总图面数据检查各个图层中面数据是否闭合，不闭合的变闭合，然后保存；
5.将检查完后的dwg总图面数据重新导入Arcmap，然后利用数据导出功能，将其变为shp数据，之后再加载到地图中；（如此操作省去了shp图层合并这一步。shp图层合并是为了将所有人画的面数据合并为一个总的shp面数据，目的是等高线按面一次性裁剪）
6.在Arcmap导入等高线，利用数据导出功能将其变为shp数据。然后使用工具箱内擦除工具裁剪等高线，将裁完的等高线导出CAD；
7.最后将裁完的等高线调入到eps中，为其计曲线和首曲线转码刷属性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0494adca3501c5d3d1bdaaed0568390c/" rel="bookmark">
			运放的虚短与虚断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚断 理想情况下，运放的同向反向输入端等效电阻无穷大；而实际情况下，输入电阻Ri也达到兆欧（M）级别，例如OP07：7-31MΩ
因此，输入端电流很小--微安级别（uA），可以将同相输入端与反相输入端的电流近似为0。
输入阻抗无穷大，电流近似为零，所以说相当于断路（但实际是连通的）-----即虚断。
（虚断是运放本身的特性，在任何电路都有该特性）
虚短 在特定条件下，运放的同相输入端与反相输入端近似为短路，即两者电压相等。
特定条件：
1.开环（无反馈）条件下，运放处于线性放大区。
2.运放处于深度负反馈
①开环条件下：运放的开环增益很大，一般是100dB--100000倍,（20lg放大倍数=增益dB），而输出电压限制在供电电压（VCC~VEE），那么输入的差模电压就很小了，只有微伏级别uV，可以忽略不计，即同向反向端电压差相等，近似为零，即短路--虚短。
（而且运放工作在线性区间的要求是：差模电压很小，也是uV级别）
（图片来源：b站up--小鱼教你学模数电） ②运放引入深度负反馈，也工作在线性区，也满足虚短。
深度负反馈：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf9c9d5c1f1e8f4dc028bb939dcd2537/" rel="bookmark">
			【docker】docker介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是docker 1.1、docker起源 Docker是一个开源的应用容器引擎，基于Go语言 ，诞生于2013年初。 最初发起者是DotCloud公司（（Platform-as-a-Service, PaaS）提供商）开源的一个基于 LXC 的高级容器引擎。 功能Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux机器；实现虚拟化。 主要工作如拉取镜像、编译镜像、运行容器、发布容器等。
1.2、docker的版本 Docker从1.13.x（2017.3.2）版本开始，版本分为企业版EE和社区版
CE EE（Enterprise Edition: 企业版）：2017 年 3 月 2 日发布17.03；大公司（含自研）CE（Community Edition: 社区版）：2017 年 3 月 2 日发布17.03； 中小企业使用居多 从 17.03开始基于时间线进行版本发布， 17.03 代表17年3月，说明这个是个稳定版。
CE:"Edge"与"Stable"两个版本发行 Edge（边界）版本每月发布，提供一个月支持。Stable（稳定）版本每季度发布，提供4个月支持EE :每个季度发布一次 季度版本, 也就是说每年会发布4个季度版本 1.3、docker解决了什么问题 docker解决了软件环境部署复杂的问题。对于一个传统的软件工程，开发人员把写好的代码放到服务器上去运行是一件很头疼的事情，因为常常会出现环境不兼容而导致各种各样的bug。
比如说，开发是windows系统下编写的代码，放到linux服务器上可能会出问题，开发在本地依赖了一个系统自带的驱动，服务器上却没有这个驱动，开发在本地设置了很多环境变量，服务器上又得重新设置。
在软件部署的时候，经常会发生在这台机器上可以跑，但是在另一台机器上却运行失败的情况。运维人员需要不断在开发环境和服务器环境之间调试。
有了docker，只需要简单的几行命令，就可以做到所有运行环境都一致。
1.4、docker和虚拟机的关系 说到docker，那就必须要和虚拟机做一下比较，其实docker是和虚拟机是类似的东西，我们应该知道虚拟机就是在我们的操作系统上虚拟出来一个电脑，然后里边可以安装、运行各种各样的软件，和我们真的电脑是差不多的，我们可以拿着这个虚拟好的电脑（其实是一个文件）在按了虚拟机的其他电脑上可以直接运行，里边的东西就不用我们来回安装和配置了，也是很方便的。
docker其实提供的也是这么一种的技术，只不过它比虚拟机效率更加的高，启动快，占用资源小等一系列的优点，而且虚拟机比较笨重，这是因为虚拟机和docker来实现思想上有本质的区别，我们可以通过下边的图对比一下：
虚拟机的运作原理：是虚拟电脑的硬件资源，把硬件资源分配出来，然后虚拟出来多个操作系统，虚拟出来的是一个完整的电脑。
特性容器虚拟机启动秒级分钟级硬盘使用一般为MB一般为GB性能接近原生弱于系统支持量单机支持上千个容器一般几十个 相同点：
容器和虚拟机一样，都会对物理硬件资源进行共享使用。容器和虚拟机的生命周期比较相似（创建、运行、暂停、关闭等等）。容器中或虚拟机中都可以安装各种应用，如redis、mysql、nginx等。也就是说，在容器中的操作，如同在一个虚拟机(操作系统)中操作一样。同虚拟机一样，容器创建后，会存储在宿主机上：linux上位于/var/lib/docker/containers下 不同点：
虚拟机的创建、启动和关闭都是基于一个完整的操作系统。一个虚拟机就是一个完整的操作系统。而容器直接运行在宿主机的内核上，其本质上以一系列进程的结合。容器是轻量级的，虚拟机是重量级的。首先容器不需要额外的资源来管理(不需要Hypervisor、Guest OS)，虚拟机额外更多的性能消耗；其次创建、启动或关闭容器，如同创建、启动或者关闭进程那么轻松，而创建、启动、关闭一个操作系统就没那么方便了。也因此，意味着在给定的硬件上能运行更多数量的容器，甚至可以直接把Docker运行在虚拟机上。 二、docker的核心概念 2.1、Docker镜像(Image) 镜像到底是个什么东西呢，很多人在学习docker的时候都是一头雾水的，可是是歪果仁对镜像情有独钟吧，好多东西都有镜像的概念。比如我们安装系统的.iso文件，其实就是镜像，这里你就可以把镜像认为是一种模板。我们可以使用docker根据这个模板创建容器来运行，其实更可以理解为镜像是好比github上的仓库一样，我们可以克隆下来源代码然后运行，运行起来的代码可以是一个网站、一个应用程序啥的，这就可以叫做容器。说白了，镜像就是一堆静态的模板，运行起来的镜像就是容器。镜像一般需要我们拉取下来，是只读的，这个我们克隆github上的仓库是一样一样的。
docker镜像中有分层的概念，就是一个镜像可能基于好几个镜像，比如一个web运行环境可能需要操作系统ubuntu、数据库mysql、.net core runtime运行时，那我们拉取的这个镜像就会包好这好几个镜像，这就好像我们前边说的打包好的运行环境一样，直接就拉下来一个小电脑一样。
总结起来就是docker镜像就是我们事先做好的一套版本，里面装载着我们所需要的东西和流程，模板之间还可以嵌套。
2.2、容器(Container) 当我们拉取了一个镜像，然后run一下，就会根据这个镜像运行出来一个容器，运行的容器就好像我们的应用程序一样，可以访问可以停止，我们运用多次run命令，就运行了很多很多容器，也可以说是镜像的实例。从这个角度来看，我们可以把镜像看作是类，容器看作new出来的实例，也是很合适的。
2.3、仓库(Repository) 存放镜像的地方就是仓库，就好比存放代码的地方是github一样，我们就把github称为代码的仓库，github算是最大的仓库。那么存放docker镜像的地方我们叫做dockerhub，是docker的中央仓库。其实已经有dockerhub这个网站了（https://hub.docker.com/），这就是 存放docker镜像的官方仓库，好多官方的也保存在这里，保证了镜像的安全性和可靠性，我们可以从上边拉取一下镜像来运行我们的软件。当然我们也可以制作好我们自己镜像推送上去，不过这些肯定是要官方审核的，防止有些人写入一些恶意代码。不过我们可以推到我们自己的dockerhub上去，供我们自己使用，这个就好我们的github账号一样了，属于私有镜像了。
2.4、数据卷(Volumn) 实际上我们的容器就好像是一个简易版的操作系统，只不过系统中只安装了我们的程序运行所需要的环境，前边说到我们的容器是new出来的实例，既然是new出来的实例那就会销毁，那如果销毁了我们的程序产生出的需要持久化的数据怎么办呢，容器运行的时候我们可以进容器去查看，容器一旦销毁就什么都没有了。所以数据卷就是来解决这个问题的，是用来做数据持久化到我们的宿主机上容器间的数据共享，简单的说就是将宿主机的目录映射到容器中的目录，应用程序在容器中的目录读写数据会同步到宿主机上，这样容器产生的数据就可以持久化了，比如我们的数据库容器，就可以把数据存到我们宿主机上的真实磁盘上了。
2.5、docker镜像、容器、仓库、数据卷关系示意图 三、docker的底层原理 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf9c9d5c1f1e8f4dc028bb939dcd2537/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04e5de35f3be1ced336cee4c70a599e1/" rel="bookmark">
			浅谈1394总线的那点事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 随着航空电子技术发展，总线技术已经成为航空电子系统最重要的组成部分。由于航空及航天电子系统的构造变的更加复杂，整个系统的数字化信息量急剧增加，所以传统的RS232、ARINC429、CAN等总线已经不能满足现在新型航空和航天电子系统的需求。
1394总线技术是目前较为先进的航空电子总线技术之一，它是在IEEE-1394b协议的基础上进行了修改和约束，提出了AS5643协议。该协议通过数据传输、总线同步和容错等关键技术实现了机载电子系统关于传输实时性、可靠性和确定性等功能要求，使得1394总线能够在军事和飞行器中的关键系统得到应用。
1394总线是以节点为单位组成通信网络，如下图所示，一个简单的1394总线系统是由总线控制（CC）节点、远程（RN）节点和总线监控（BM）节点组成，各个节点之间通过1394线缆连接。
1394总线CC节点作为1394总线的节点控制器，按照周期发送帧起始包（STOF）消息，通知总线上的所有节点新一帧的开始，通过STOF消息完成同步节点。RN节点作为远程终端，在收到STOF包后，确认新的一帧开始，并按照设置的时间偏移来发送数据。BM节点作为总线监控节点，能够监控总线上发出的数据消息。
1394总线通信基于固定帧速率和预分配带宽实现节点消息的周期定时发送机制。通过STOF包来进行总线同步，使用异步流包进行通信，同时通过对异步流包格式的进一步定义增加总线管理和故障监控功能。一个完整的异步流包由1394包头、负载数据区和1394CRC组成，其中1394包头和1394数据CRC由链路层进行校验。STOF包是特殊的异步流包，用于通知总线上的各个节点发送数据包，并广播约定的消息。
1394总线基于其传输速度快、传输距离长、高可靠性等优点，已广泛应用于航空系统。我司提供货架式PXIe 1394板卡产品可支持地面仿真环境的网络构建，该板卡可以提供2路1394B通信节点，每个节点提供2个端口，满足AS5643协议，每块1394板卡既可以单独作为CC或RN节点，也可以同时在一块板卡上实现CC和RN节点。在某项目中使用了多张1394板卡模拟5个RN节点接收被测产品发出的数据，并同时向被测产品发送数据，对其整个系统的收发通信进行测试验证。线路通讯存在问题时，可以利用BM节点监控整个1394总线上的数据信息，协助定位被测产品的问题所在。
目前1394总线主要向航电系统提供高安全、高可靠、强实时的数据通信服务，但在当今电磁环境和电子对抗更加激烈的情况下，1394总线抗干扰能力的能力需要提升。而解决这一问题最直接的办法就是发展光纤技术，用光纤实现机载总线的信号传输。因此采用光纤作为1394总线的传输介质，已经成为1394总线未来的发展方向。
另外，为了更好的服务于广大的用户朋友们，我司单张板卡3路1394B通信节点，每个节点提供3个端口，共计9个端口的产品即将上市，支持的100Mbit/s，200Mbit/s，400Mbit/s，800Mbit/s的通信速率，可以按需支持CC节点、RN节点、BM节点的功能，敬请期待！
—访问官网获取更多详情— 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11d8335a4feb6dab92174e4ad0a6164a/" rel="bookmark">
			如何修改SVN客户端的用户名和密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、在任何文件夹里面右键，找到TortoiseSVN，然后选择里面的“Settings”，如图：
对应的中文 2、进入“Settings”之后，找到左面菜单中的“Saved Data”，该功能就是你以前保存过得所有数据，如图：
对应的中文 3、进入“Saved Data”之后，找到“Authentication data”，点击后面的“Clear...”按钮，如图：
对应的中文 4、这里会弹出一个对话框，里面是你以前保存的SVN地址，找到你想修改用户名密码的SVN地址，选中之后点击ok，如图：
对应的中文 5、页面关闭后，点击下面的“确定”，如图：
对应的中文 6、下次你再想更新或者提交的时候，就会让你重新输入账号密码了，只要输入你新的用户名和密码就可以了，如图：
对应的中文 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d9d771cd1a953069e9f44426f6c08ea/" rel="bookmark">
			光度立体（一）- 基于先验信息的快速表面法向量求解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于先验信息的快速表面法向量求解 一.光度立体法简介二.经典光度立体法求解法向量三.基于先验信息快速求解法向量 一.光度立体法简介 光度立体法（Photometric Stereo）是一种使用多个光源方向估计表面几何形状的方法，可以根据二维纹理信息提取出三维模型。最早是由当时在MIT的人工智能实验室的Robert J. Woodham教授在1978年左右提出。近些年来，随着相关学者的研究拓展，大致可划分为经典的光度立体、未标定的光度立体、基于参照物的光度立体、基于深度学习的光度立体、基于反射模型的光度立体、基于多视角的光度立体六类。
二.经典光度立体法求解法向量 经典光度立体法前提假设物体表面具有lambertian(朗伯)反射特性，即它对入射光产生漫反射，在每个方向上反射的光强都是一致的。
其中：
t:是测量到的像素的强度（像素值）
l:是光源强度（辐射强度）
ρ:是郎伯表面的漫反射率
L:是3维的单位光源位置向量
N:是3维的表面法向量
像素值可根据图像已知，如果光源单位向量和光源强度也已知的话（光源单位向量和光源强度求解可关注见后续的文章），那么上述方程只有反射率ρ和法向量x分量p，y分量q共三个未知数。因此至少需要三个方程，即至少需要不共面的三个光源去照射物体才可以进行求解。结果如下：
该方法通过矩阵方程求解法向量，可以在matlab或者C++调用eigen库中来计算，但当图片像素尺寸较大时，计算的耗时将指数增加，无疑降低了实际运用的效率。
三.基于先验信息快速求解法向量 为了提高运算效率，我们可以通过合理搭建采集环境，通过利用实验参数和朗伯公式快速求解法向量。以四光源为例，采集环境如下：
相机工件为正交投影采集，四个光源等高均匀布置在0度，90度，180度，270度方位，入射光的倾角为θ，偏角为𝜑。
将该四个特殊角度值带入朗伯公式可分别求得每个光源下对应关系式为：
为求解法向量的p，q，可将上式两边累加，用0度位置与180度位置，90度位置与270位置相减除以累加量以简化计算，同样前提光强已知且同步消元。
p，q即为法向量x，y分量，z分量已知为1，该方法直接将矩阵方程求解转换为常规的加减乘除数值运算，极大的提高运算效率。
总的来说，该方法相比于经典方法，计算耗时缩短了十倍以上，但前提是光源需要合理布置在四个特殊的方位角，对采集环境要求较高。在计算得到法向量后，还可以继续深入计算表面梯度信息、高度信息，曲率信息等。
更多的相关光度立体知识可见后续文章。
代码和测试图片可访问：link
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faa9b73338ac6b8b443761666538a484/" rel="bookmark">
			【维度建模】维度模型设计详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.需求调研2.数据探查3.高层模型设计4.开发详细的维度模型4.1 确定维度及其属性4.2 确定事实4.3确定缓慢变化维度技术4.4 建立详细的表设计文档4.5 对模型出现的问题进行追踪4.6 维护并更新总线矩阵 5.审查验证模型6.完成设计文档 1.需求调研 （1）作为维度建模人员要与数据需求发起方、所涉及的源系统业务方进行需求评审，一般通过访谈或者联合会议的方式进行。
（2）将访谈和会议的结果记录并进行汇总。最终形成的需求文档要以业务过程为中心。对每个过程，要描述为什么业务用户期望分析过程指标度量，他们需要得到何种能力，当前他们所受到的限制，可能存在的好处或影响是什么。处理每个过程的可行性评价也是非常重要的内容。
（3）在需要文档中要体现需求的优先级，一般优先级根据两方面进行衡量：业务的潜在影响和价值；可行性
（4）根据需求文档中涉及的业务，确定业务过程，并形成企业的总线矩阵
2.数据探查 （1）源系统的存储类型
（2）数据量大小，每日新增大小
（3）是否有物理删除
（4）是否有增量时间戳
（5）列属性检查
（6）结构性检查
（7）业务规则检查
3.高层模型设计 高层模型设计是总线架构获取的图形化模型，并确定设计范围和所设计的事实表以及相关的维度表的粒度，声明粒度即在这一步完成。
高层图图形化地表示了业务过程的维度和事实表，如下图所示。
粒度描述需要建模人员考虑满足业务需求需要什么样的数据以及现有的物理数据源可以提供什么样的数据，气泡图必须根据物理数据设计。总线矩阵的一行可能会用多个气泡图表示，每个气泡图对应于具有特定粒度的特定事实表。
大多数主要的维度在确定了事实表可以自然而然的获得。清楚地事实表粒度声明的重要影响是可以精确的以图示化的方法表示有关的维度。
4.开发详细的维度模型 有了高层模型，就要设计维度和度量，维度和度量清单不仅仅是业务用户所关心，还要从业务过程触发，自上而下的设计所设计的维度和度量。防止业务用户的需求变化带来的冲击。
在高层气泡图设计完成后，就要开始关注细节了。最有效的方法先开始设计维度表，然后考虑设计事实表。在开始细节设计过程中要已经具备明确的维度表。日期维度一般作为首选开始，这样能够及早的理解建模过程，确保建模工作更早的获取成功。
维度建模确定每个维度内有趣且有用的属性，并确定每个事实表应该具有的适当的度量。要不断获取源、定义以及如何获得这些属性和度量的基本业务规则。在详细设计过程中持续不断的加深对源系统和系统化数据概要的分析，这将更有助于建模人员更好的理解其拥有的源数据实际情况。
在详细设计之前，为数据仓库系统指定规范，主要包含源系统、主题、业务术语、报表、物理设计命名、调度任务、文档方面的规范。
4.1 确定维度及其属性 再详细设计阶段，将定义关键的一致性维度（当不同的维度表的属性具有相同的列名和领域内容时，称维度表具有一致性）。数据建模人员要获取组织一致认同的表和属性命名、描述和定义的关键资源。
4.2 确定事实 声明粒度是对事实表度量的讨论成果，因为事实表都必须与粒度保持一致。
4.3确定缓慢变化维度技术 针对维度表的每个属性，需要定义在源系统数据发生变化时会对维度表产生何种影响，并针对该影响选择合适的处理SCD（缓慢变化维度）方案
4.4 建立详细的表设计文档 详细设计文档包括从源系统到维度模型的每个数据层的物理映射文件
详细建模阶段的关键交付品是设计工作单。应该为每个维度表和事实表建立不同的工作单。支持信息至少应该包括属性/事实的名称、描述、示例值、每个维度属性的缓慢变化维度类型标识。此外，详细的事实表设计应该确认每个外键关系、适当的退化维度，以及表明每个事实是可加、半可加还是不可加的相关规则。
4.5 对模型出现的问题进行追踪 在设计过程中发现的所有问题、定义、转换规则和数据质量挑战必须记录到问题追踪日志中，并跟踪解决相关问题。
4.6 维护并更新总线矩阵 在详细的建模过程中，通常对建模的业务过程会有新的发现。常见的情况是，这些新发现可能会引入新的事实表以支持业务过程，可能会出现新的维度，也可能需要重新规划或合并维度。在整个设计过程中，必须保持对总线矩阵的更新，因为详细的总线矩阵是关键的交流和规划工具。
5.审查验证模型 详细设计文档出来后，要和业务用户和团队成员进行评审，记录下来评审过程中的问题，形成问题清单
6.完成设计文档 在模型稳定后，应该对模型涉及过程中的工作文件进行编制，形成设计文档。该文档包括：
（1）项目的简短描述；
（2）高级的数据模型图；
（3）详细的针对每个事实和维度表的维度设计工作单；
（4）开放的问题
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/252/">«</a>
	<span class="pagination__item pagination__item--current">253/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/254/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>