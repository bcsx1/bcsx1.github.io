<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7ef9bafd23864b597353940f261f564/" rel="bookmark">
			STM32--DHT11温湿度传感器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍基于STM32F103实现的DHT11温湿度传感器数据采集及显示，完整代码见文末链接
一、DHT11传感器简介 DHT11数字温湿度传感器是一款含有已校准数字信号输出的温湿度复合传感器。它应用专用的数字模块采集技术和温湿度传感技术，确保产品具有极高的可靠性与卓越的长期稳定性。
传感器包括一个电阻式感湿元件和一个NTC测温元件，并与一个高性能8位单片机相连接。因此该产品具有品质卓越、超快响应、抗干扰能力强、性价比极高等优点。每个DHT11传感器都在极为精确的湿度校验室中进行校准。校准系数以程序的形式储存在OTP内存中，传感器内部在检测信号的处理过程中要调用这些校准系数。单线制串行接口，使系统集成变得简易快捷，超小的体积、极低的功耗，信号传输距离可达20米以上，使其成为各类应用甚至最为苛刻的应用场合的最佳选则，数字量输出，适用于简单的温湿度测量场景。
传感器测量精度
传感器的测量精度如下图表所示，其精度比较有限，测量分辨率分别为 8bit（温度）、8bit（湿度） 。
传感器原理图
模块电路图如下所示，其中Data管脚使用4.7K上拉电阻，当实际传输距离大于20米时需要根据实际情况来选用合适的上拉电阻。
各引脚说明
DHT11各引脚说明如下
电气特性
单线双向串行接口
DATA 用于微处理器与 DHT11之间的通讯和同步，采用单总线数据格式，一次通讯时间4ms左右，数据分小数部分和整数部分，具体格式在下面说明。当前小数部分用于以后扩展，现读出为零。
操作流程如下：
一次完整的数据传输为40bit，高位先出。
数据格式：8bit湿度整数数据+8bit湿度小数数据+8bit温度整数数据+8bit温度小数数据+8bit校验和
数据传送正确时，校验和数据等于“ 8bit 湿度整数数据 +8bit 湿度小数数据+8bit温度整数数据 +8bit 温度小数数据 ”所得结果的末8位。
用户MCU发送一次开始信号后，DHT11从低功耗模式转换到高速模式，等待主机开始信号结束后，DHT11发送响应信号，送出40bit的数据，并触发一次信号采集，用户可选择读取部分数据。从模式下，DHT11接收到开始信号触发一次温湿度采集，如果没有接收到主机发送开始信号，DHT11不会主动进行温湿度采集，采集数据后转换到低速模式。
通讯过程如下图所示
总线空闲状态为高电平，主机把总线拉低等待DHT11响应，主机把总线拉低必须大于18毫秒，保证DHT11能检测到起始信号。DHT11接收到主机的开始信号后，等待主机开始信号结束，然后发送80us低电平响应信号。主机发送开始信号结束后，延时等待20-40us后， 读取DHT11的响应信号，主机发送开始信号后,可以切换到输入模式或者输出高电平均可，总线由上拉电阻拉高。
总线为低电平说明DHT11发送响应信号，DHT11发送响应信号后，再把总线拉高80us，准备发送数据，每一bit数据都以50us低电平时隙开始，高电平的长短定了数据位是0还是1。如果读取响应信号为高电平，则DHT11没有响应，请检查线路是否连接正常。当最后一bit数据传送完毕后，DHT11拉低总线50us，随后总线由上拉电阻拉高进入空闲状态。
其他信息
（1）手动焊接，在最高260 ℃ 的温度条件下接触时间须少于10秒。
（2）避免结露情况下使用。
（3）长期保存条件：温度10－40 ℃ ，湿度60％以下。
（4）DATA信号线材质量会影响通讯距离和通讯质量,推荐使用高质量屏蔽线
二、接线方式 本文主要基于STM32F103C8T6实现DHT11温湿度传感器数据采集并显示在0.96寸OLED液晶屏幕上，具体接线方式如下
DHT11接线方式
STM32F103C8T6DHT113V3VCCGNDGNDA8IO OLED液晶接线方式
STM32F103C8T6OLED3V3VCCGNDGNDB8SCLB9SDA 三、程序例程及注释（完整见文末链接） 主函数如下：
int main (void) { delay_init();	//延时函数初始化 OLED_Init();	//初始化OLED OLED_Clear(0); //清除屏幕 OLED_ShowString(2, 0, "Temp:",16);	OLED_ShowString(2, 2, "Hum:",16);	while (1) { //不能保证你每次发出去的数据传感器都能正确响应(可能传感器解析时时间不对等原因)，所以要多发几次，有响应回来就行 if(dht11_read_data(buf)==0){ hum = buf[0] + buf[1] / 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7ef9bafd23864b597353940f261f564/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f06b1ef3ac753243af18a8e812b239f/" rel="bookmark">
			算法笔记(DFS求解简单迷宫问题)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）DFS遍历邻接矩阵： #include&lt;iostream&gt; using namespace std; #define MAXV 100//最大节点数 int visited[MAXV]; typedef struct{ char vex[MAXV];//顶点表 int edge[MAXV][MAXV];//邻接矩阵表 int Vnum;//节点数 int Enum;//边数 }MGraph;//无向图邻接矩阵结构 void CreateMG(MGraph *MG){ int i,j,k; char v; cout&lt;&lt;"请依次输入顶点数和边数:"; cin&gt;&gt;MG-&gt;Vnum&gt;&gt;MG-&gt;Enum; cout&lt;&lt;"请依次输入顶点:"; for(i=0;i&lt;MG-&gt;Vnum;i++) cin&gt;&gt;MG-&gt;vex[i]; for(i=0;i&lt;MG-&gt;Vnum;i++)//初始化邻接矩阵 for(j=0;j&lt;MG-&gt;Vnum;j++) MG-&gt;edge[i][j]=0; cout&lt;&lt;"请输入每条边对应的两个顶点下标(i,j):\n"; for(k=0;k&lt;MG-&gt;Enum;k++){ cin&gt;&gt;i&gt;&gt;j; MG-&gt;edge[i][j]=1; MG-&gt;edge[j][i]=1; } }//创建无向图邻接矩阵 void DisplayMG(MGraph MG){ int i,j; for(i=0;i&lt;MG.Vnum;i++){ for(j=0;j&lt;MG.Vnum;j++) cout&lt;&lt;MG.edge[i][j]&lt;&lt;' '; cout&lt;&lt;'\n'; } }//邻接矩阵输出无向图 void DfsMG(MGraph *MG,int v){ int w; cout&lt;&lt;v&lt;&lt;' ';//输出被访问顶点 visited[v]=1;//将当前顶点设为已访问状态 for(w=0;w&lt;MG-&gt;Vnum;w++) if(MG-&gt;edge[v][w]==1&amp;&amp;visited[w]==0) DfsMG(MG,w);//查找顶点v的未访问的相邻点 } int main(){ MGraph g; CreateMG(&amp;g); DisplayMG(g); cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f06b1ef3ac753243af18a8e812b239f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83da56b3a0e0d5ffc4df7f3a11844110/" rel="bookmark">
			C语言简单小游戏——扫雷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.扫雷游戏分析 创建9*9的数组
9*9棋盘
上面布置10个雷
排查雷
1.如果这个位置不是雷，就计算这个位置的周围8个坐标有几个雷，并显示雷的个数
2.如果这个位置是雷，就炸死了，游戏结束了
3.如果把不是雷的位置都找出来了，那游戏也结束
用数字0和1表示，1表示雷 便于统计雷的个数
‘0’=48，‘1’=49.....以此类推 字符‘0’-‘0’=0（数字）即为48-48=0
字符‘1’-‘0’=1（数字）49-48=1
2.最终实现结果 3.代码实现及其注释 1.game.h头文件部分 #pragma once #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #define ROW 9 #define COL 9 #define ROWS ROW+2 #define COLS COL+2 #define EASY_COUNT 10//定义有10个雷 //初始化棋盘 void InitBoard(char board[ROWS][COLS], int rows, int cols, char set); //显示棋盘 void DisplayBoard(char board[ROWS][COLS], int row, int col); //布置雷 void SetMine(char mine[ROWS][COLS], int row, int col); //排查雷 void FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col); 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83da56b3a0e0d5ffc4df7f3a11844110/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08b049ce7b27cd7ae730142d429f41e7/" rel="bookmark">
			计算机毕设ssm基于JavaWeb民宿管理系统的设计与实现89x8t9(源码&#43;数据库&#43;LW)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
ssm + mybatis + Maven +mysql5.7或8.0等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 4G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目
6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末) 功能需求分析 民宿管理系统综合网络空间开发设计要求。目的是将民宿管理通过网络平台将传统预定方式转换为在网上下单，完成民宿租赁。线上民宿租赁的方便快捷、安全性高、交易规范做了保障，目标明确。民宿管理系统可以将功能划分为用户的使用功能和管理员功能。
（1）、用户关键功能包含用户登录注册、浏览首页、民宿信息、服务信息、公告信息、后台管理、个人中心等有关功能。用户用户用例如下：
图3-1 用户用例图
（2）、管理员的功能是最高的，可以对系统所在功能进行查看，修改和删除。管理员用例如下：
图3-2管理员用例图
功能模块设计 民宿管理系统根据权限类型进行分类，主要可分为用户和管理员三大模块。用户模块主要实现了修改个人信息，民宿租赁等操作，加强了用户的操作体验。管理员模块主要根据管理员对整个系统的管理进行设计，提高了管理的效率和规范。系统总体模块设计如下图所示：
图4-1 系统总体模块设计
4.2 系统数据库设计 4.2.1 数据库系统 本系统采用MySQL来进行数据库的管理。基于WEB的MySQL体积小、速度快、成本低，能够及时处理上千万条记录，初步满足和支持大型的数据库高并发的读写和高效率读写等要求[9]。
4.2.2 数据库概念设计 概念模型用于对信息世界建模，并与指定的数据库管理系统分离。它有助于将真实世界的事物抽象为适合于数据库管理系统的数据库模型。人们往往把现实世界抽象成信息世界，再把信息世界变成机器世界。也就是说，将现实世界的目标抽象成独立于专用计算机软件和专用数据库管理系统的信息结构的数据模型，然后将物理模型转化为适合电子计算机的数据库管理系统。事实上，数据模型是从现实世界到机器世界的中间层。
信息世界的基本要素包括实体和关联。实体（entity) 客观存在并可相互区别的事物称为实体[13]。实体可以是实际的人、事或物，还可以是抽象化的概念或联络。以下是对部分主要的关键实体E-R如下：
用户信息实体E-R图如下图4-2所示。
图4-2用户信息实体E-R图
服务信息实体E-R图如下图4-3所示。
图4-3服务信息实体E-R图
民宿信息实体E-R图如下图4-4所示。
图4-4民宿信息实体E-R图
系统功能实现 当人们打开系统的网址后，首先看到的就是首页界面。在这里，人们能够看到登录/注册的按钮，可以浏览首页、民宿信息、服务信息、公告信息、后台管理等内容，如果用户需要进行民宿租赁等操作，则需要进行注册、登录的操作。系统首页界面如图5-1所示：
图5-1 系统首页界面
用户注册时，通过输入用户账号、密码、用户姓名、性别、年龄、邮箱、手机号、身份证等信息进行注册的操作，用户注册、登录界面如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08b049ce7b27cd7ae730142d429f41e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19bc64a6321f431a9bc0700a3b8b60ef/" rel="bookmark">
			CentOS7安装Oracle XE记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅是CentOS7安装Oracle XE记录，供参考
1、下载安装包 oracle-xe-11.2.0-1.0.x86_64.rpm.zip
2、安装 （1）第一次安装
[root@node1 opt]# cd Disk1/ [root@node1 Disk1]# ll 总用量 309884 -rw-r--r-- 1 root root 317320273 9月 28 09:41 oracle-xe-11.2.0-1.0.x86_64.rpm drwxr-xr-x 2 root root 20 9月 28 09:41 response drwxr-xr-x 2 root root 26 9月 28 09:41 upgrade [root@node1 Disk1]# ll 总用量 309884 -rw-r--r-- 1 root root 317320273 6月 28 04:43 oracle-xe-11.2.0-1.0.x86_64.rpm drwxr-xr-x 2 root root 20 6月 28 04:43 response drwxr-xr-x 2 root root 26 6月 28 04:43 upgrade [root@node1 Disk1]# rpm -ivh oracle-xe-11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19bc64a6321f431a9bc0700a3b8b60ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c480954ad28d671cc4caffcc79254795/" rel="bookmark">
			爬取全国天气网，天气信息不用愁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍一个爬取全国天气网，天气信息不用愁的案例，以期阐明网络爬虫的基本方法，加深对网络爬虫的理解。
一、数据网站介绍 中央气象台网站提供了1-7天的各要素天气预报和分时段天气预报、生活指数预报信息。该网站通过气象观测数据和数值模型分析，提供了全国范围内各地区未来几天的天气预报和生活指数。用户可以通过该网站获取准确的天气预报，以便做出相应的气象决策和安排。无论是个人还是专业人士，都可以在中央气象台网站上获取可靠的天气预报信息，以帮助其日常生活或工作中的气象需求。
武汉7天天气预报和分时段天气预报
武汉7天天气预报和生活指数
二、天气预报信息爬虫的基本流程 首先对网站发起请求，获取相应内容，对返回的内容进行解析，最后就保存数据。
爬虫的基本流程图
三、爬虫相关模块安装 本案例涉及到下面几个模块，安装命令如下：
pip install requests pip install bs4 也可以使用mamba install package安装，有不明白的地方，可以参考本人已经发表的文章。
四、实现过程 第一步：导入库 import requests from bs4 import BeautifulSoup 第二步：获取网页源代码 # 2 获取网页内容 # 发送请求，获取响应 url = 'http://www.weather.com.cn/weather/101200101.shtml' response = requests.get(url) # 从响应中获取数据 page = response.content.decode() 第三步：解析网页 1.查找天气预报信息的节点 通过分析网站返回的内容，天气预报有效信息都在 id="7d"，天气预报信息的节点内。如图所示：
2.html5lib方式解析天气信息 我们使用BeautifulSoup模块对网页内容，进行html5lib方式的解析。（BeautifulSoup模块具体使用，后面有时间整理出来分享给粉丝）
查找标签：id='7d'，获取标签内容，forecast_text就包含了7天天气预报和分时段天气预报）。
# 2 提取天气预报信息 # 构建bs对象 soup = BeautifulSoup(page, 'html5lib') # print(soup) # 查找标签 id_text = soup.find(id='7d') # 获取标签内容 forecast_text = id_text.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c480954ad28d671cc4caffcc79254795/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e5c12e86738b525e690d2241ac10656/" rel="bookmark">
			【网络安全---ICMP报文分析】Wireshark教程----Wireshark 分析ICMP报文数据试验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，试验环境搭建 1-1 试验环境示例图 1-2 环境准备 两台kali主机（虚拟机） kali2022 192.168.220.129/24
kali2022 192.168.220.3/27
1-2-1 网关配置： 编辑-------- 虚拟网路编辑器 更改设置进来以后 ，先选择NAT模式，然后是NAT设置
网关配置好确定
1-2-2 IP地址配置 首选更改网络连接模式为NAT模式
两个主机都设置成NAT模式以后开机 ，打开终端修改A主机的配置，指令如下：
nmcli connection edit Wired\ connection\ 1 goto ipv4.addresses change 192.168.220.129/24 back goto gateway change 192.168.220.2 back back save activate quit 截图如下：
这样主机A的IP地址设置完成 以同样的方法设置主机B的IP地址
nmcli connection edit Wired\ connection\ 1 goto ipv4.addresses change 192.168.220.3/27 back goto gateway change 192.168.220.2 back back save activate quit 1-2-3 Mac地址配置 修改A主机的mac地址，修改为00:aa:aa:aa:aa:aa
macchanger --mac=00:aa:aa:aa:aa:aa eth0 修改好了查看A主机的网络配置 ip addr show 修改B主机的mac地址，修改为00:bb:bb:bb:bb:bb macchanger --mac=00:bb:bb:bb:bb:bb eth0 修改好了查看一下B主机的网络配置 ip addr show 试验环境准备好了，接下来就开始抓包，开始分许 二，详细试验步骤 为了避免物理机网络的干扰，最好是物理机断网进行试验
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e5c12e86738b525e690d2241ac10656/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cec0a2880b459c886894fa34bacb2a8/" rel="bookmark">
			ARM汇编与C言语的混合编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. C言语如何与汇编进行交互 有些时候，我们需要在汇编代码中调用C代码，或者说C代码中调用汇编代码。
那么，汇编调用C代码，或者C代码调用汇编函数，他们的函数参数、返回值是如何传递的？
对应ARM架构来说，有一个 ATPCS （ARM-Thumb Produce Call Standard），ARM-Thumb过程调用标准。ATPCS 标准规定了下面几个方面：
1、函数调用过程中的寄存器用法。比如说 R4-R11 、 R13(SP) 、R14(LR) 这些寄存器的值，应该由子程序保证不改变。也就是说在执行子程序时，如果这些寄存器需要被修改的话，那么应该先压栈，然后才能再去调用子程序。2、规定函数参数和返回值的传递。一般来说 R0-R3 这4个寄存器用于函数的输入参数，然后函数的返回值是放在 R0 寄存器的。当然，如果输入参数大于 4 个参数是，寄存器就不够用了，那么这时需要使用到栈。3、规定栈对齐。如果汇编代码调用C函数，就要确保当前的栈指针指向了双字对齐的地址（如0x20000000、0x20000008、0x20002010 等）。 对于在函数调用时的参数传递过程，可归纳为如下表格：
寄存器输入参数返回值R0第 1 个输入参数函数返回值R1第 2 个输入参数不使用，或者返回值（返回值是64位时）R2第 3 个输入参数不使用R3第 4 个输入参数不使用 函数调用过程中，寄存器的用法如下表：
2. 汇编调用C函数 汇编调用C函数，是汇编与C语言混合编程遇见最多的场合了。
前面说过了，ATPCS标准，函数调用时，使用 R0-R3 传递参数，R0 作为返回值。
比如，下面的一个C函数：
int my_add_c(int x1, int x2, int x3, int x4) { return (x1 + x2 + x3 + x4); } 根据ATPCS标准，x1=R0, x2=R1, x3=R2, x4=R3, 然后返回值是存放在 R0 寄存器的。另外，还需要注意调用者保存的寄存器（R0-R3, R12）这些寄存器可能会被C函数修改。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cec0a2880b459c886894fa34bacb2a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23a40cf59ce7dd503b6f39692440eeec/" rel="bookmark">
			基于Android的英语学习软件/英语学习系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要 随着信息技术和网络技术的飞速发展，人类已进入全新信息化时代，传统管理技术已无法高效，便捷地管理信息。为了迎合时代需求，优化管理效率，各种各样的APP应运而生，各行各业相继进入信息管理时代，英语学习软件就是信息时代变革中的产物之一。
任何APP都要遵循系统设计的基本流程，本APP也不例外，同样需要经过市场调研，需求分析，概要设计，详细设计，编码，测试这些步骤，基于java语言设计并实现了英语学习软件。该APP基于B/S即所谓浏览器/服务器模式，应用SSM框架与Android技术，选择MySQL作为后台数据库。系统主要包括学生、教师、英语资料、学习视频、英语词库、背词信息、学习签到等功能模块。
本文首先介绍了英语学习软件的技术发展背景与发展现状，然后遵循软件常规开发流程，首先针对系统选取适用的语言和开发平台，根据需求分析制定模块并设计数据库结构，再根据系统总体功能模块的设计绘制系统的功能模块图，流程图以及E-R图。然后，设计框架并根据设计的框架编写代码以实现系统的各个功能模块。最后，对初步完成的系统进行测试，主要是功能测试、单元测试和性能测试。测试结果表明，该系统能够实现所需的功能，运行状况尚可并无明显缺点。
关键词：英语学习软件；java语言；MySQL数据库；SSM框架
Abstract With the rapid development of information technology and network technology, mankind has entered a new information age. Traditional management technology has been unable to manage information efficiently and conveniently. In order to meet the needs of the times and optimize management efficiency, a variety of apps came into being. All walks of life have entered the era of information management. English learning software is one of the products of the reform of the information age.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23a40cf59ce7dd503b6f39692440eeec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d2621ba29be17771803b08f449943eb/" rel="bookmark">
			基于MDK-Keil环境如何把STM32程序直接下载到SRAM运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 对于 Cortex-M 内核的微控制器，它们都可以支持在 RAM 中执行程序，有些非 ARM 的微控制器是不支持的。
在内部 SRAM 执行程序，有基于以下几方面的原因：
1、所使用的设备可能具有OTP（One-time Programmable，一次性可编程）ROM区域，还没有确定最终代码之前，还不会把程序编程到芯片中；2、有些MCU内部内部可能没有Flash，可能会使用到外部的存储器。但是在软件开发阶段可以下载到SRAM进行开发测试；3、对于特定的测试场合，Flash已经烧录了程序，但是不想擦除。这时可以把测试程序下载到SRAM运行；4、对于有些Flash被锁定的芯片，可以把代码下载到SRAM，然后进行解锁；5、Flash写入需要先擦除，所以SRAM的写入速度要比Flash快很多，如果程序很大的话，在开发阶段直接在SRAM运行可以提高效率。 对于程序下载到内部SRAM运行，有多种方法：
1、配置boot引脚，然后下载代码到SRAM，使程序从SRAM启动2、不修改boot引脚启动模式，借助仿真器，进入仿真模式，然后强制更改 PC SP 指针，从SRAM位置取值开始运行3、程序下载到内部Flash或者外部的SD卡、SPI Flash等存储设备，然后上电之后把代码搬运到SRAM运行（类似代码的重定位） 下面只介绍前面两种方式。
首先在修改程序在SRAM运行之前，要先准备好一份可以正常在Flash运行的程序。
2. 修改散列文件 散列文件，就是链接脚本，指导链接器如何对程序进行链接的。
我们要让代码在SRAM运行，首先就要修改散列文件，让程序链接地址修改在内部SRAM空间。
我们打开Keil的配置界面，然后使用我们自己修改的散列文件。
修改后的散列文件内容如下：
; ************************************************************* ; *** Scatter-Loading Description File generated by uVision *** ; ************************************************************* LR_IROM1 0x20000000 0x00010000 { ; load region size_region ER_IROM1 0x20000000 0x00010000 { ; load address = execution address *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) .ANY (+XO) } RW_IRAM1 0x20010000 0x00010000 { ; RW data .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d2621ba29be17771803b08f449943eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c823458ddcf11e2927147cf63e31cd3/" rel="bookmark">
			jeecgboot 可编辑表格弹窗富文本框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近使用jeecgboot框架的JEditableTable做一个数据维护，有一个需求是用户要录入SQL语句，帮他顺序执行SQL，由于SQL又臭又长，小小的input框没办法显示全，导致每次需要在txt里编辑好了再贴进去，修改也是一样。
如图，只能显示几个字，多了就看不到了。
于是乎，测试的胖子提出需求，需要点击弹出一个框，完全显示编辑内容。
实现步骤：
给可编辑表格特定类型的框添加事件监听，不能影响可编辑表格现有的功能做一个模态框组件，用于显示和编辑完善父页面和模态框组件之间的数据通信 直接上代码：
源码里没有点击事件，需要自己加
源码里增加一个处理函数，用于父子组件传值
父组件中的column，增加使能点击事件的属性
父组件监听子组件的事件
父组件处理子组件传过来的数据
最后再新建一个弹窗页面即可
这里使用了compute，用于防止子组件直接修改父组件的值
&lt;template&gt; &lt;j-modal :title="title" :width="width" :visible="visible" switchFullscreen @ok="handleOk" :okButtonProps="{ class:{'jee-hidden': disableSubmit} }" @cancel="handleCancel" cancelText="关闭"&gt; &lt;div&gt; &lt;j-editor v-model="paramCopy"/&gt; &lt;!-- &lt;a-textarea v-model="paramCopy" rows="20" placeholder="SQL编辑处" /&gt; --&gt; &lt;/div&gt; &lt;/j-modal&gt; &lt;/template&gt; &lt;script&gt; import store from '@/store' import { mapGetters } from 'vuex' import { getAction, postAction, getFileAccessHttpUrl } from '@/api/manage' import moment from 'moment' export default { name: 'FckEditerDialog', components: {}, props: { paramData: { type: String, default: '' }, }, computed: { paramCopy: { get() { return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c823458ddcf11e2927147cf63e31cd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b747edf14695c628cd5212bb727fde88/" rel="bookmark">
			NullPointerException:com.sun.tools.javac.api.JavacTool
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误信息 在Linux 环境部署的spring boot 应用使用到 JavaCompiler ,需要使用 com.sun.tools.javac.api.JavacTool,结果在运行时出现以下错误
NullPointerException: com.sun.tools.javac.api.JavacTool 错误原因 执行java -version,发现是有jdk的,但是javac 确无法执行,而且在/etc/profile 没有发现环境变量的配置,所以怀疑是JDK的安装版本或者是库有问题,当前的JDK不是由我安装的,所以决定自己安装一个jdk
[root@test etc]# java -version openjdk version "1.8.0_332" OpenJDK Runtime Environment (build 1.8.0_332-b09) OpenJDK 64-Bit Server VM (build 25.332-b09, mixed mode) 解决方案 我安装使用的是 jdk-8u381-linux-x64.tar.gz
下载链接 https://www.oracle.com/cn/java/technologies/downloads/
# 修改配置文件,添加对应的环境变量 vim /etc/profile # 设置环境变量 export JAVA_HOME=/opt/soft/jdk export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH 检查是否安装成功 [root@test etc]# java -version java version "1.8.0_201" Java(TM) SE Runtime Environment (build 1.8.0_201-b09) Java HotSpot(TM) 64-Bit Server VM (build 25.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b747edf14695c628cd5212bb727fde88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5ee1f9783be92f3c39533f2bf85b8c8/" rel="bookmark">
			【Ubuntu18.04】Autoware安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Autoware安装 引言1 ROS安装2 Ubuntu18.04安装Qt5.14.23 安装GCC、G++4 Autoware-1.14.0安装与编译4.1 源码的编译4.1.1 使用python2.7环境4.1.2 针对Ubuntu 18.04 / Melodic的依赖包安装4.1.3 先安装一些缺的ros依赖4.1.4 安装eigen3.3.74.1.5 安装opencv 3.4.164.1.6 编译4.1.7 运行4.1.8 一些报错修改 4.2 Docker Autoware环境搭建4.2.1 安装docker4.2.2 安装docker-nvidia4.2.3 安装autoware的docker版本4.2.4 编译（在docker下的容器中进行）4.2.5 运行4.2.6 关掉终端之后再次启动autoware容器 5 Autoware.ai 安装6 运行 Autoware7 ROSBAG Demo 引言 Autoware是世界上第一个自动驾驶all-in-one的开源软件，基于Apache2协议，在ROS机器人操作系统基础上开发而来。主要有Autoware.ai、Autoware.Auto、Autoware.Universe三个版本
Autoware的三个版本简介
AI版本是基于ROS1.0实现的，十分适合于自动驾驶初学者，也适合有快速验证科研需求的高校实验室，因此本文主要介绍Autoware.ai的安装。
1 ROS安装 参考笔者的博客即可：【ROS】Ubuntu18.04安装Ros
2 Ubuntu18.04安装Qt5.14.2 QT官网下载qt-opensource-linux-x64-5.14.2.run
执行如下的安装步骤：
sudo chmod -R 777 qt-opensource-linux-x64-5.14.2.run sudo ./qt-opensource-linux-x64-5.14.2.run //将Qt安装在/opt目录 # 配置环境：Qt 安装完成后，先别打开，因为还需要安装其他工具以及库文件 sudo apt-get install gcc g++ //安装 linux 下编程的编译器 sudo apt-get install libqt4-dev //不然编译时会出现错误“cannot find -lgl sudo apt-get install build-essential //它可以使得我们的程序知道头文件和库函数放在哪个位置 添加环境变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5ee1f9783be92f3c39533f2bf85b8c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cd59c2b6cd00059ac1b1fe4f136656b/" rel="bookmark">
			LESS的叶绿素荧光模拟实现与操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LESS的叶绿素荧光模拟实现与操作 前情提要FLUSPECT模型荧光的三维面元冠层辐射传输过程日光诱导叶绿素荧光模拟 前情提要 本文默认您对LESS (LargE-Scale remote sensing data and image Simulation framework) 模型和叶绿素荧光(Sun-Induced chlorophyll Fluorescence, SIF)有一定的了解。当然，您也可以在这里下载中文的简明手册，了解更多关于三维辐射模型的原理及LESS操作。
此文适用于LESS version 2.1.4-2023-08-19
FLUSPECT模型 LESS在FLUSPECT基础上，模拟了多角度、多成像模式的冠层叶绿素荧光模拟。
FLUSPECT在PROSPECT的基础上，除了模拟叶片的反射率和透射率，还可模拟叶片正向和背向激发的叶绿素荧光。模型考虑了荧光在叶片中的再吸收。使用一种快速层加倍算法，快速求解12。
FLUSPECT通过荧光激发矩阵（ E F 211 × 351 EF_{211\times 351} EF211×351​将400 – 750 nm的激发光谱（ E 351 × 1 E_{351\times 1} E351×1​）转化为640 – 850 nm的荧光光谱（ F 211 × 1 F_{211\times 1} F211×1​），光谱间隔为1 nm。受限于 E F 211 × 351 EF_{211\times 351} EF211×351​的光谱采样间隔，在LESS中，模拟荧光时规定，激发光谱与荧光光谱的光谱间隔相等且固定，并且为整数个nm。 E F 211 × 351 EF_{211\times 351} EF211×351​重采样到其他光谱间隔的方式比较特殊，需要考虑激发光谱的累乘相加如何在其他光谱间隔上实现。这里不加推导地给出重采样方法： E F u , v ~ = ∑ ∑ E F i , j i n c , i n c ∈ N + \widetilde{EF_{u,v}}=\frac{\sum\sum EF_{i,j}}{inc},inc\in\mathbb{N}^{+} EFu,v​ ​=inc∑∑EFi,j​​,inc∈N+其中， E F i , j EF_{i,j} EFi,j​为边缘补0后，与重采样的 E F ~ \widetilde{EF} EF 对齐的原始矩阵，inc为采样后波长间隔。下图展示了重采样带来的偏差，以5 nm间隔采样，能够较好地平衡模拟耗时与精度需求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cd59c2b6cd00059ac1b1fe4f136656b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5117605a782a3c80c5c715302b3830aa/" rel="bookmark">
			如何实现矩阵的重采样问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、问题描述二、回答 前言 记录知乎的自问自答。
一、问题描述 我的问题是这样的，有两个列向量E和F，需要注意的是，E和F是连续的，可任意插值，得到包含其中的子向量。E和F通过一个m×n的矩阵联系起来，如下： M m × n × E n × 1 = F m × 1 M_{m\times n}\times E_{n\times 1}=F_{m\times 1} Mm×n​×En×1​=Fm×1​现在，我通过线性插值的方式，得到了E和F的子向量，它们长度分别为v和u，那么请问，我该如何求得矩阵M’，使得： M u × v ′ × E v × 1 = F u × 1 M'_{u\times v}\times E_{v\times 1}=F_{u\times 1} Mu×v′​×Ev×1​=Fu×1​
二、回答 可能是我表述不明白？或者这个问题比较简单？思考了两天，找到了在一定假设下能够实现我需求的方法，这里记录一下。
对于这种要采样的矩阵来说，最麻烦的是，每行的采样方式，因为这是一个相乘再求和的过程，在这个基础上，对结果进行插值，再求矩阵，不可避免地会产生问题。好在我这里的实际问题能够在有效的假设下，规避这个问题。
既然说，E和F都是连续的，不妨设存在函数E(x)和F(x)来描述这两个向量。我们从简单的地方出发，看看会遇到什么问题，先在行方向上采用，再处理列方向的采样。
首先，我们来计算F的第一行， F 1 = M 1 , 1 × E 1 + M 1 , 2 × E 2 + .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5117605a782a3c80c5c715302b3830aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ba853e233733dddb06c34dfa40c7c9d/" rel="bookmark">
			python——Django框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本介绍 Django 是一个由 Python 编写的一个开放源代码的 Web 应用框架。
使用 Django，只要很少的代码，Python 的程序开发人员就可以轻松地完成一个正式网站所需要的大部分内容，并进一步开发出全功能的 Web 服务 Django 本身基于 MVC 模型，即 Model（模型）+ View（视图）+ Controller（控制器）设计模式，MVC 模式使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。
Django框架有以下主要特点：
强大的ORM（对象关系映射）：Django提供了一个强大的ORM，它允许开发人员使用Python代码来操作数据库，而无需编写复杂的SQL语句。ORM提供了简洁的API，使数据库操作变得更加简单和高效。
自带的管理后台：Django提供了一个内置的管理后台，使开发人员可以轻松地创建、编辑和管理数据库中的数据。开发人员只需定义模型类，Django就会自动为其生成对应的管理界面。
URL分发和视图处理：Django使用URL分发机制来将请求映射到相应的视图函数或类。开发人员可以根据需要定义不同的URL模式，并将它们与相应的视图函数或类关联起来。这种分发机制使开发人员能够轻松处理不同URL的请求。
模板引擎：Django内置了一个强大的模板引擎，使开发人员可以将HTML页面与Python代码进行分离。模板引擎提供了丰富的模板标签和过滤器，使开发人员能够轻松地生成动态的HTML页面。
安全性：Django提供了一系列的安全机制，包括防止跨站点请求伪造（CSRF）、防止SQL注入等。它还提供了用户认证和权限管理的功能，使开发人员能够轻松地构建安全可靠的Web应用。
可扩展性：Django框架非常灵活，允许开发人员根据需要进行扩展。它提供了一系列的插件和扩展，使开发人员能够轻松地添加新的功能或修改现有功能。
二、MTV模式 Django 的 MTV 模式本质上和 MVC 是一样的，也是为了各组件间保持松耦合关系，只是定义上有些许不同，Django 的 MTV 分别是指：
M 表示模型（Model）：编写程序应有的功能，负责业务对象与数据库的映射(ORM)。T 表示模板 (Template)：负责如何把页面(html)展示给用户。V 表示视图（View）：负责业务逻辑，并在适当时候调用 Model和 Template。 除了以上三层之外，还需要一个 URL 分发器，它的作用是将一个个 URL 的页面请求分发给不同的 View 处理，View 再调用相应的 Model 和 Template。
MTV流程图（取自bing图库）
三、安装Django框架并创建一个简易的项目 3.1 安装Django 3.1.1、pip安装 pip install django 3.1.2、 官网下载安装 要从官网下载Django，可以按照以下步骤进行操作：
打开Django的官方网站：The web framework for perfectionists with deadlines | Django在主页上找到并点击"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ba853e233733dddb06c34dfa40c7c9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bafec04a11ca72c734f96c166883714/" rel="bookmark">
			鱼眼相机去畸变（图像拉直/展开/矫正）算法及实战总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍两种方法 1、经纬度矫正法 2、棋盘格矫正法 一、经纬度矫正法 1、算法说明 经纬度矫正法， 可以把鱼眼图想象成半个地球， 然后将地球展开成地图，经纬度矫正法主要是利用几何原理， 对图像进行展开矫正。
经过P点的入射光线没有透镜的话，本应交于相机成像平面的e点。然而，经过鱼眼相机的折射，光线会交于相机成像平面的d点，就产生了畸变，因此畸变图像整体上呈现出像素朝图像中心点聚集的态势。
而去畸变，就是将折射到d点的点，重新映射回到e点，因此去畸变之后的图像与原始的鱼眼图像相比，仿佛是把向心聚集的像素又重新向四周铺展开来。
详细的推导流程及公式见地址：AVM环视系统——鱼眼相机去畸变算法 - 知乎
2、 代码 import math from PIL import Image im = Image.open("/Users/Fisheye_photo-600x600.jpg") im.show() width, high = im.size sqrt_len = min(width, high) im = im.transform((sqrt_len, sqrt_len), Image.EXTENT, ((width-sqrt_len)/2, (high-sqrt_len)/2, sqrt_len+(width-sqrt_len)/2, sqrt_len+(high-sqrt_len)/2) ) width = high = sqrt_len idata = im.getdata() odata = [] alpha = math.pi/2 out_high = round(high * math.tan(alpha/2)) out_width = round(width * math.tan(alpha/2)) out_radius = round(high * math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bafec04a11ca72c734f96c166883714/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dc420e2319e328a07d10543a7c67bc6/" rel="bookmark">
			java生成json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们用sql查出来一些值，想要把它打包成一个JSON格式，例如我们查出的数据如下
班级 姓名 年龄 性别 身高 1班 AAA 11 男 296cm 1班 BBB 11 男 296cm 2班 CCC 11 男 296cm 2班 DDD 11 男 296cm 2班 EEE 11 男 296cm 3班 FFF 11 男 296cm 要将他变成JSON格式
{ "school": [{ "班级": "1班", "student": [{ "姓名": "AAA", "年龄": "11", "性别": "男", "身高": "296cm" }, { "姓名": "BBB", "年龄": "11", "性别": "男", "身高": "296cm" }] },{ "班级": "2班", "student": [{ "姓名": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dc420e2319e328a07d10543a7c67bc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8b51d6373675bdc096ae6ccf05191a3/" rel="bookmark">
			Android学习之路(19) ListView详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.ListView简介 在Android开发中，ListView是一个比较常用的控件。它以列表的形式 展示具体数据内容，并且能够根据数据的长度自适应屏幕显示。
二.ListView简单用法 代码部分
1.布局界面 activity_main.xml 代码：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;ListView android:id="@+id/list_view" android:layout_width="match_parent" android:layout_height="match_parent"/&gt; &lt;/LinearLayout&gt; 2.类文件 MainActivity.java 代码：
package com.example.listview1; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.view.View; import android.widget.AdapterView; import android.widget.ArrayAdapter; import android.widget.ListView; import android.widget.TextView; import android.widget.Toast; public class MainActivity extends AppCompatActivity { //1、定义对象 ListView listView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //2、绑定控件 listView=(ListView) findViewById(R.id.list_view); //3、准备数据 String[] data={"菠萝","芒果","石榴","葡萄", "苹果", "橙子", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8b51d6373675bdc096ae6ccf05191a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dd546c6476883e636d4b933cc106486/" rel="bookmark">
			【设计模式】——策略模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		策略模式的思想 策略模式（Strategy Pattern）是一种行为型设计模式，它允许在运行时选择算法的行为。策略模式的核心思想是将不同的算法封装成独立的策略类，并使这些策略类可以互相替换，从而使客户端代码不依赖于具体的算法，增加了代码的灵活性和可维护性
策略模式的组成部份 策略接口（Strategy Interface）：定义一组算法的通用接口，通常包含一个或多个方法，这些方法表示不同策略所执行的操作。
具体策略类（Concrete Strategies）：实现策略接口，提供具体的算法实现。每个具体策略类代表一种算法或策略的具体实现。
环境类（Context）：持有一个策略对象的引用，并提供方法来执行算法。环境类通常包含一个设置策略的方法，以及使用策略来执行操作的方法
策略模式的优点 通过动态切换策略对象，可以在运行时适应不同的需求，提高了代码的灵活性策略模式有助于减少代码重复，因为多个算法可以共享相同的接口和通用行为可以轻松添加新的算法或策略，无需修改现有的客户端代码，符合开放封闭原则。提高了代码的可维护性，因为每个算法都有自己的类，易于理解和维护 例子： 以支付为例，不同人进行的支付方式可能不同，定义一个策略类，并将pay接口定义为虚函数如果想要扩展支付方式，直接定义新的类，并继承策略类，重写pay函数即可 #include &lt;iostream&gt; // 策略接口 class PaymentStrategy { public: virtual void pay(int amount) = 0; }; // 具体策略类1：信用卡支付 class CreditCardPayment : public PaymentStrategy { private: std::string cardNumber; std::string name; public: CreditCardPayment(const std::string&amp; cardNumber, const std::string&amp; name) : cardNumber(cardNumber), name(name) {} void pay(int amount) override { std::cout &lt;&lt; amount &lt;&lt; " paid using credit card." &lt;&lt; std::endl; // 具体的支付逻辑 } }; // 具体策略类2：PayPal支付 class PayPalPayment : public PaymentStrategy { private: std::string email; public: PayPalPayment(const std::string&amp; email) : email(email) {} void pay(int amount) override { std::cout &lt;&lt; amount &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dd546c6476883e636d4b933cc106486/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/467203d0182f28acad214a5b5b5e3c7d/" rel="bookmark">
			ensp 防火墙双机热备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拓扑图 &lt;USG6000V1&gt;u t m &lt;USG6000V1&gt;sys [USG6000V1]sys FW [FW1]int g0/0/0 [FW1-GigabitEthernet0/0/0]ip add 192.168.153.100 24 # 根据自己的网卡来 [FW1-GigabitEthernet0/0/0]service-manage enable #开启管理服务 [FW1-GigabitEthernet0/0/0]service-manage ping permit #允许ping [FW1-GigabitEthernet0/0/0]service-manage http permit [FW1-GigabitEthernet0/0/0]service-manage https permit [FW1]web-manager timeout 1440 #设置web界面的超时时间 [FW1]user-interface console 0 [FW1-ui-console0]idle-timeout 0 #设置console超时时间 #说明：开机防火墙远程管理时，如果需要开启多个服 务：http、https、telnet、ssh等，可以执行命令：Service-manage all permit web访问 https://192.168.153.100:8443/ # https://ip地址:8843 FW1 FW2 配置相同 接口ip不同 FW2 [USG6000V1]sysname FW2 [FW2]int g0/0/0 [FW2-GigabitEthernet0/0/0]ip add 192.168.206.100 24 [FW2-GigabitEthernet0/0/0]service-manage enable [FW2-GigabitEthernet0/0/0]service-manage all permit [FW2]web-manager timeout 1440 #设置web界面的超时时间 R1配置接口地址 配置接口地址和安全区域
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/467203d0182f28acad214a5b5b5e3c7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c5c466b1993d20c5730982537b9854c/" rel="bookmark">
			C# 登录功能（优雅且详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、需求描述二、功能设计1.登录界面设计2.数据库3.登录4.记住账号5.验证码 三、程序实现1.创建一个SqlHelper的工具类，用于查询数据2.验证登录信息功能的函数3.实现验证码功能写一个用于创建验证码的工具类更新验证码的方法验证验证码是否正确 4.保存账号及密码功能的实现在APP.config中先创建键值对用于储存复选框状态以及记录账号信息记录账号信息的函数在窗体加载的同时写入储存的登录信息 5.登录功能进入系统功能点击按钮 四、登录页面完整代码：五、运行效果后记 前言 此系列文章是有关贵州省第一届商务软件解决方案技能大赛试题的求解，下附试题以及项目源码。
试题
项目源码
一、需求描述 制作一个登陆界面，包含验证码，记住密码以及根据登录用户类型（RoleID）加载不同界面的功能。用户使用账号与密码登录系统。本系统的用户包括 3 种类型若用户的登录失败次数达到 3 次，那么系统应显示并且同时包含字母与数字的4位验证码，验证码字符输入正确方可登录。若选择记住密码，下次登录时直接显示上次输入的账号和密码 二、功能设计 1.登录界面设计 2.数据库 获取登录id和password需要连接SQL server数据库，则需要创建一个用于链接数据库的类，在登录界面代码中调用。
SQLserver数据表结构：
3.登录 验证登录账号和密码获取登录账号的类型（以数字代表类型，一共有三种类型，分别是1，2，3）若验证错误次数超过三次，则生成验证码 4.记住账号 将账号信息储存到appconfig文件中
5.验证码 达到条件时创建验证码生成验证码图片验证码输入不正确或点击更新验证码 三、程序实现 1.创建一个SqlHelper的工具类，用于查询数据 有关数据库连接详细解析见下附链接
.Net连接SQL Server数据库的优雅方式（巨详细）
namespace OlympicManagementSystem.Util { public class SqlHelper { public static string ConStr { get; set; }//数据库连接字符串 public static DataTable ExecuteTable(string cmdStr)//获取数据表的方法，返回一个DataTable { using (SqlConnection con = new SqlConnection(ConStr)) { con.Open(); SqlCommand cmd = new SqlCommand(cmdStr, con); SqlDataAdapter adapter = new SqlDataAdapter(cmd); DataSet ds = new DataSet(); adapter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c5c466b1993d20c5730982537b9854c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cd9a1d3d25382cff17e6503f4fb5567/" rel="bookmark">
			小米note 9 4GV12.0.50 深度精简系统内置APP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		echo ====================打印服务================== adb shell pm uninstall --user 0 com.android.printspooler echo ====================HTML查看================== adb shell pm uninstall --user 0 com.android.htmlviewer echo ====================动态壁纸================== adb shell pm uninstall --user 0 com.android.wallpaper.livepicker echo ====================基本互动屏保================== adb shell pm uninstall --user 0 com.android.dreams.basic echo ====================悬浮球================== adb shell pm uninstall --user 0 com.miui.touchassistant echo ====================MSA================== adb shell pm uninstall --user 0 com.miui.systemAdSolution echo ====================SIM卡应用================== adb shell pm uninstall --user 0 com.android.stk echo ====================小爱同学================== adb shell pm uninstall --user 0 com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cd9a1d3d25382cff17e6503f4fb5567/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce5b5943b85eeecd15eb82567d63b948/" rel="bookmark">
			向量，矩阵，时间序列数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用在数字信号处理算法计算时窗的向量，矩阵，时间序列数据结构array_mem。
1 头文件 #include "qs_config.h" #define QS_ARRAY_MEM_LIST_SIZE 40 #define QS_ARRAY_MEM_SIZE	2100 + 10 typedef struct { Type _data[QS_ARRAY_MEM_SIZE]; /**&lt; points to the data of the array. */ int16_t id; int16_t next; } qs_array_mem_t; /** * @brief Instance structure for the array structure. */ typedef struct { uint16_t N; /**&lt; number of columns of the array. */ qs_array_mem_t *_x; /**&lt; points to the data of the array. */ } qs_array_inst; typedef struct { uint16_t N; /**&lt; number of columns of the array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce5b5943b85eeecd15eb82567d63b948/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47d729b549a578c6a00986e6eabc88cc/" rel="bookmark">
			15-自动化测试——理论知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1.什么是自动化测试？
2.常见的自动化测试分类
2.1.单元测试（Java、Python）
2.2.接口测试（Java、Python）
2.3.UI测试（移动端、网站）
3.如何实施自动化测试？
4.自动化测试需要了解的技能
1.什么是自动化测试？ 自动化测试指软件测试的自动化，在预设状态下运行应用程序或者系统，预设条件包括正常和异常，最后评估运行结果。将人为驱动的测试行为转化为机器执行的过程。
2.常见的自动化测试分类 自动化测试包括UI自动化，接口自动化，单元测试自动化。
按照这个金字塔模型来进行自动化测试规划，可以产生最佳的自贡话测试产出投入比（ROI），可以用较少的投入获得很好的收益。
2.1.单元测试（Java、Python） 最大的投入应该在单元测试上，单元测试运行的频率也更加高。 java的单元测试框架是Junit。
2.2.接口测试（Java、Python） 接口测试就是API测试，相对于UI自动化，API自动化更加容易实现，执行起来也更稳定。
接口自动化的特点：
可在产品前期，接口完成后介入。用例维护量小。适合接口变动较小，界面变动频繁的项目。 常见的接口自动化测试工具有：
RobotFramework，JMeter，SoapUI，TestNG+HttpClient，Postman 等。
2.3.UI测试（移动端、网站） 虽然测试金字塔告诉我们尽量多做API层的自动化测试，但是UI层的自动化测试更加贴近用户的需求和软件系统的实际业务。并且有时候我们不得不进行UI层的测试。
UI自动化的特点：
用例维护量大。页面相关性强，必须后期项目页面开发完成后介入。UI测试适合于界面变动较小的项目。 UI自动化测试的好处：
降低大型系统的由于变更或者多期开发引起的大量的回归测试的人力投入，这可能是自动化测试最主要的任务，特别是在程序修改比较频繁时，效果是非常明显的。自动化测试前期人力投入较多，但后期进入维护期后，可节省大量人力；而手工测试后期需要增加大量人力用于回归测试。减少重复测试的时间，实现快速回归测试。创建优良可靠的测试过程，减少人为错误。可以运行更多更繁琐的测试。可以执行一些手工测试困难或不可能进行的测试。更好地利用资源。测试脚本的重用性。 UI自动化测试的框架：
UI层的测试框架比较多，比如Windows客户端测试的AutoIT，web测试的selenium以及TestPlant eggPlant，Robot framework，QTP等。
这里主要以Web UI自动化测试框架Selenium为例进行详细介绍。
selenium有以下优点：
免费，也不用再为破解软件而大伤脑筋。小巧，对于不同的语言它只是一个包而已，而QTP 需要下载安装1个多G 的程序。这也是最重要的一点，不管以前更熟悉C、java、ruby、python、或都是C# ，都可以通过 selenium 完成自动化测试，而QTP 只支持VBS。支持多平台：windows、linux、MAC。支持多浏览器：ie、ff、safari、opera、chrome。支持分布式测试用例的执行，可以把测试用例分布到不同的测试机器执行，相当于分发机的功 能。 UI自动化测试的适用对象：
实施自动化测试的前提条件：需求变动不频繁、项目周期足够长、自动化测试脚本可重复使用。
适合做自动化的项目： ①产品型项目，新版本是在旧版本的基础上进行改进，功能变动不大的项目，但项目的新老功能都必须重复地进行回归测试。回归测试是自动化测试的强项，它能够很好地验证是否引入了新的缺陷，老的缺陷是否修改过来了。在某种程度上可以把自动化测试工具叫做回归测试工具。
②机械并频繁的测试，每次需要输入相同、大量的一些数据，并且在一个项目中运行的周期比较长。 比如兼容性测试。
不适合做自动化的项目： ①需求变动频繁的项目，自动化脚本不能重复使用，维护成本太大，性价比低。
②项目周期短，自动化脚本编制完成后使用次数不多，性价比低。
③交互型较强的项目，需要人工干预的项目，自动化无法实施。
3.如何实施自动化测试？ 单纯的讲，自动化测试的具体实现，包含下面七个过程：
分析：总体把握系统逻辑，分析出系统的核心体系架构。设计：设计测试用例，测试用例要足够明确和清晰，覆盖面广而精。实现：实现脚本，有两个要求：一是断言，二是合理运用参数化。执行：执行脚本远远没有想象中那么简单。脚本执行过程中的异常需要仔细去分析原因。 总结：测试结果的分析和测试过程的总结是自动化测试的关键。 维护：自动化测试脚本的维护是一个难以解决但又必须要解决的问题。 分析：在自动化测试过程中深刻的分析自动化用例的覆盖风险和脚本维护的成本。 4.自动化测试需要了解的技能 了解被测试系统的基本业务了解业务的技术框架懂得功能测试懂得一种编程语言懂数据库、操作系统了解常见的测试框架...... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06fe944090bfa2be7cb5562fff165c82/" rel="bookmark">
			将C&#43;&#43;字符串转换为数字时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当将C++字符串转换为数字时，可以使用以下几种方法：使用标准库函数 stoi()、stol()、stoll()、stof()、stod()、stold()：
#include &lt;iostream&gt; #include &lt;string&gt; int main() { std::string str = "12345"; int num = std::stoi(str); std::cout &lt;&lt; num &lt;&lt; std::endl; return 0; } 使用字符串流 stringstream：
#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;sstream&gt;int main() { std::string str = "12345"; std::stringstream ss(str); int num; ss &gt;&gt; num; std::cout &lt;&lt; num &lt;&lt; std::endl; return 0; } 使用 C 语言函数 sscanf()：
#include &lt;iostream&gt; #include &lt;string&gt; int main() { std::string str = "12345"; int num; sscanf(str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06fe944090bfa2be7cb5562fff165c82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8950e954437c5e9e0622193318879d7/" rel="bookmark">
			16-自动化测试——selenium介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.selenium是什么？
2.selenium特点
3.selenium工作原理
1.selenium是什么？ selenium是web应用中基于UI的自动化测试框架。
2.selenium特点 支持多平台多浏览器多语言（Java、Python、C#、JS、Ruby......）有丰富的API 3.selenium工作原理 1）自动化脚本代码
通过IDEA编写的代码。
2）WebDriver浏览器驱动
需要下载的。
3）浏览器
Edge浏览器、Chrome浏览器......
早期的Selenium RC已经被现在的WebDriver所替代，可以简单的理解为Selenium1.0+WebDriver构成现在的Selenium2.0。
现在说起selenium，一般指的是Selenium2.0。它由Selenium IDE， WebDriver，Selenium Grid组成。
分别做一下介绍：
①Selenium IDE Selenium IDE是一个用于selenium测试的完成集成开发环境，可以直接录制在浏览器的用户操作，并且能回放、编辑和调试测试脚本。调试过程中可以逐步进行或调整执行的速度，并且可以在底部浏览日志出错信息。 录制的测试脚本可以以多种语言导出，比如java，C#，Python，Ruby等，方便掌握不同语言的测试人员操作。
②WebDriver
Selenium RC 在浏览器中运行 JavaScript 应用，会存在环境沙箱问题，而 WebDriver 可以跳出 JavaScript 的沙箱，针对不同的浏览器创建更健壮的、分布式的、跨平台的自动化测试脚本。基于特定语言（Java，C#，Python，Ruby，Perl，JavaScript等）绑定来驱动浏览器对 Web 元素进行操作和验证。
WebDriver的工作原理： 启动浏览器后，selenium-webdriver 会将目标浏览器绑定到特定的端口，启动后的浏览器则作为 webdriver 的 remote server。客户端(也就是测试脚本)，借助 ComandExecutor 发送 HTTP 请求给 sever 端（通信协议：The WebDriver Wire Protocol，在 HTTP request 的 body 中，会以 WebDriver Wire 协议规定的 JSON 格式的字符串来告诉 Selenium 我们希望浏览器接下来做什么事情）。Sever 端需要依赖原生的浏览器组件，转化 Web Service 的命令为浏览器 native 的调用来完成操作。 ③Selenium Grid Selenium Grid 是一个服务器，提供对浏览器实例访问的服务器列表，管理各个节点的注册和状态信息。可以实现在同一时刻不同服务器上执行不同的测试脚本。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e91f62de48a2aa22b625d11f60c56ea/" rel="bookmark">
			【考研数据结构题型分类讲解练习】1-2线性表--选择题--答案讲解篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写这么高价格，就是为了让你们别在csdn订阅，这个平台过于恶心
别在csdn订阅，看readme，加群私聊我订阅。
别在csdn订阅，看readme，加群私聊我订阅。
别在csdn订阅，看readme，加群私聊我订阅。
别在csdn订阅，看readme，加群私聊我订阅。
别在csdn订阅，看readme，加群私聊我订阅。
更新日期：2022年9月18日
试看
【考研数据结构题型分类讲解练习】1-1线性表--选择题--习题篇_Anthony_4926-CSDN博客
【考研数据结构题型分类讲解练习】1-2线性表--选择题--答案讲解篇_Anthony_4926-CSDN博客
【考研数据结构题型分类讲解练习】3-3 树和二叉树--应用题_Anthony_4926-CSDN博客
目录
一、选择判断
题型一：选择合理的随机存取结构
题型二：根据插入删除选择合理的存储结构
题型三：插入删除移动次数及时间复杂度
题型四：链表插入删除执行的操作
题型五：静态链表
题型六：指针头结点
题型七：线性表与链表的比较及其各自特点
一、选择判断 题型一：选择合理的随机存取结构 线性表的顺序存储可以理解成数组，它是可以随机存储的结构。所谓随机存储就是存取第i个元素的时间复杂度是O(1)，花费的时间最少。
线性表与随机存取密不可分
1-1. 线性表的顺序存储结构是一种(）【北京理工大学2006五、3 (1分)】
A.随机存取的存储结构
B.顺序存取的存储结构
C.索引存取的存储结构
D. Hash存取的存储结构
1-2.能在0(1)时间内访问线性表的第i个元素的结构是( ) 。【电子科技大学2011一、2(2分)】
A.顺序表
B.单链表
C.单向循环链表
D.双向链表
1-3.若某线性表最常用的操作是存取任一指定序号的元素和在最后进行插入和删除运算,则利用( )存储方式最节省时间。【哈尔滨工业大学2001二、1 (2分) 【烟台大学2007一、3 (25)
A.顺序表
B.双链表
C.带头结点的双循环链表
D.单循环链表
解析：题中说“存取任意指定序号”，这就是随机存取，对应的是顺序表
1-4.对于一个线性表，既要求存储结构能够反应数据元素之间的逻辑关系，又要求能够较快进行插入和删除，则应采用_______存储结构。【安徽大学 834 2014】
A.顺序
B.散列
C.链式
D.索引
解析：快速插入删除是链式存储结构的特性，其元素间的逻辑关系是通过指针来保持的。
1-5.若线性表最常用的操作是存取第Ⅰ个元素及其前驱和后继元素的值，为节省时间应采用的存储方式（ ）。【北京理工大学 2004 一、3（1分）】
A.单链表
D.顺序表
B.双向链表
C.单循环链表
解析：随机存取第i个元素，时间还最少，就是顺序表
1-6.链表不具有的特点是（）。【电子科技大学 2012 一、3（2分）】【福州大学 1998 一、 8（2分）】【南京理工大学 2005 一、13 （1分）】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e91f62de48a2aa22b625d11f60c56ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1278adb1b346dcaf5356cff2c7c7d6d0/" rel="bookmark">
			【考研数据结构题型分类讲解练习】1-1线性表--选择题--习题篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写这么高价格，就是为了让你们别在csdn订阅，这个平台过于恶心
别在csdn订阅，看readme，加群私聊我订阅。
别在csdn订阅，看readme，加群私聊我订阅。
别在csdn订阅，看readme，加群私聊我订阅。
别在csdn订阅，看readme，加群私聊我订阅。
别在csdn订阅，看readme，加群私聊我订阅。
更新日期：2021年11月19日
目录
一、选择判断
题型一：选择合理的随机存取结构
题型二：根据插入删除选择合理的存储结构
题型三：插入删除移动次数及时间复杂度
题型四：链表插入删除执行的操作
题型五：静态链表
题型六：指针头结点
题型七：线性表与链表的比较及其各自特点
一、选择判断 题型一：选择合理的随机存取结构 1-1. 线性表的顺序存储结构是一种(）【北京理工大学2006五、3 (1分)】
A.随机存取的存储结构
B.顺序存取的存储结构
C.索引存取的存储结构
D. Hash存取的存储结构
1-2.能在0(1)时间内访问线性表的第i个元素的结构是( ) 。【电子科技大学2011一、2(2分)】
A.顺序表
B.单链表
C.单向循环链表
D.双向链表
1-3.·若某线性表最常用的操作是存取任一指定序号的元素和在最后进行插入和删除运算,则利用( )存储方式最节省时间。【哈尔滨工业大学2001二、1 (2分) 【烟台大学2007一、3 (25)
A.顺序表
B.双链表
C.带头结点的双循环链表
D.单循环链表
1-4.对于一个线性表，既要求存储结构能够反应数据元素之间的逻辑关系，又要求能够较快进行插入和删除，则应采用_______存储结构。【安徽大学 834 2014】
A.顺序
B.散列
C.链式
D.索引
1-5.若线性表最常用的操作是存取第Ⅰ个元素及其前驱和后继元素的值，为节省时间应采用的存储方式（ ）。【北京理工大学 2004 一、3（1分）】
A.单链表
D.顺序表
B.双向链表
C.单循环链表
1-6.链表不具有的特点是（）。【电子科技大学 2012 一、3（2分）】【福州大学 1998 一、 8（2分）】【南京理工大学 2005 一、13 （1分）】
A.插入、删除不需要移动元素
B.可随机访问任一元素
C.不必事先估计存储空间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1278adb1b346dcaf5356cff2c7c7d6d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/095a4ea20023bb9ce3ed825b54d80a26/" rel="bookmark">
			【大模型和智能问答系统】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大模型和智能问答系统 大模型前的智能问答系统传统管道式架构存在的问题 大模型在任务型问答系统中应用NLU应用DM如何使用大模型NLG应用 大模型前的智能问答系统 大模型统一代指以ChatGPT为代表的，参数量相比以前模型有明显量级变化的生成模型。
智能问答系统，按照应用可以划分任务型和 非任务型。
目前智能对话落地较多的为任务型智能对话。而任务型智能对话的一个最基本的要求就是准！！！而目前大模型经常会出现看似正确的错误，这种错误不可控且难以修正。
任务型问答系统，按照技术实现方式可以划分为，管道式（pipeline)和端到端（end-to-end)。
任务型问答系统，多基于管道式方案进行。
如：Rasa的 NLU+Core模块，对应管道架构中的自然语言理解（NLU）+对话管理（DM）;
科大讯飞的AIUI平台,需要对意图和槽位进行设置；
思必驰的整体交互逻辑，也把NLU和DM进行了区分。
管道式问答系统的具体架构如下图：
ASR:将音频识别成文本；
NLU:识别文本的意图和槽位信息，供系统决策使用；
DST:追踪和存储历史的对话状态，供决策使用；
DPL:基于历史信息（意图/槽位/系统回复），做决策；
NLG:生成回复文本；
TTS:将文本转化为语音；
传统管道式架构存在的问题 1.NLU基于上下文的理解：多数意图识别是基于本轮文本进行识别。但存在部分需要基于上轮文本进行识别的情况，如：
一轮：今天天气怎么样？
二轮：明天呐？
二轮是基于一轮的省略。
还有那种仅参考本轮为意图A,参考上轮信息为意图B的情况。
2.对话管理模块（DM)，一直没有找到成熟的解决方案。
DM就是存储历史信息，并基于历史和当前轮数信息，决定下一步的动作（action）。这相当于人类的大脑的决策过程。
该模块，从开始的基于规则做特定的逻辑处理，到基于状态机转移，到基于深度学习模型（如rasa的ted模型），一直都不能做到通用和智能。
3.自然语言生成（NLG)本身就是一种生成。 前期通过将回复答案提前预制，通过分类模型选择哪个预制回复的方式，缺乏通用性和智能化。
且*以Bert为代表的自编码式的深度学习模型，其更适合做分类任务。*而想要做好智能问答系统（通用/友好），NLG应该是一种生成模型。
大模型在任务型问答系统中应用 大模型的相关应用，也是当下探索的热点。下面也是本人的一点理解，勿喷
大模型在传统智能问答系统的基础上，辅助解决一些具体问题，我认为是现在切实可行的落地方案。而通过大模型完全替代现在的传统方案，是一个可以探索的方向，但该方案的落地，还存在很多的问题。
上图为大模型在智能问答系统中的一些应用点。
NLU应用 在NLU中，通过前置数据预处理模块，将用户的问题处理成系统可以解析的数据。其中，基于上下文的语义理解，可以将用户的上文信息和本文信息通过大模型重新生成一句完整的信息。该方案中，大模型扮演的角色为，通过上文文本和本文文本，重新生成一句完成的文本。执行的任务相对单一，因此在提示词设计时，可以有很强的针对性。
但生成新文本的任务，对于Bert为代表的分类模型来讲，确实很难做到；
2.根据实际业务情况，前处理可以包含冗余句过滤，长难句处理等一系列问题。在处理原来句子生成新句子的各项任务中， 大模型先天比分类模型具有更好的效果。
DM如何使用大模型 对话管理本质就是在利用历史信息和当前信息进行决策。决策的过程是整合各种历史信息，而决策的结果为生成一个对应动作。最早方案通过规则 状态机把信息分解分析，然后通过分类得到最终结果，将结果和实际的动作做映射。该方案在处理历史信息时，定制性比较强，不同的业务需要写不同的逻辑处理。而通过深度学习模型的方案，如rasa 提出的TED模型，其分类的结果相对于规则较低。
目前的大模型，其Token数量从几千到几万，对于短距离的上下文问答，已经可以做到很好的支持。对于长距离的问答，可以把历史信息，通过文件的形式存储下俩，在用户出现新问题时，通过将新问题和历史信息文件做embedding相似度检索，找到最相似的一段历史信息，将该历史信息添加到提示词中。
而针对不同的答案来源，可以按照不同的方式使用大模型。
如果回复信息，需要从数据库中查找，可用通过使用大模型的text2sql能力。
回复信息在文本中检索，在需要利用大模型的文本检索embedding方案。
回复为具体动作时，则需要使用大模型的函数调用能力。
针对不同的资源，目前有很多的解决方案，但用大模型做对话决策，如何保证结果的准确率？ 当出现错误时，如何修正？
NLG应用 NLG–自然语言生成。从字面上理解，该模块就是在做生成任务。
大模型做NLG的方向可以从两个方面入手。第一，直接用大模型生成对应回复文本。第二，按照传统方式生成回复文本后，通过大模型二次加工润色，生成不同的回复风格。
第一种方案的最大问题还是不可控。
第二种方案，可以作为提升整个系统智能化的小功能点，但不解决最关键的问题。
#大模型智能问答系统
langchain架构，如果将agent引擎使用大模型，基本上就是大模型智能对话的架构了，个人理解，后续有时间补充
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62b648f21ed2d55856f11e7a85468020/" rel="bookmark">
			kali更新源更改以及常见问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.修改更新源目录 vim /etc/apt/sources.list
更新源有阿里云，清华，中科大，选一个，有时候其中一个源会在维护或者同步国外源，所以导致无法更新成功，换一个就好了，博主在更换更新源的时候，先使用了阿里的，结果403不让访问，再用清华的，结果清华在维护也无法使用，最后用了中科大的才成功。
把本源注释掉，然后选下面的更新远
1.阿里
deb https://mirrors.aliyun.com/kali kali-rolling main non-free contrib
deb-src https://mirrors.aliyun.com/kali kali-rolling main non-free contrib
2.清华
deb https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main non-free contrib
deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main non-free contrib
3.中科大
deb https://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib
deb-src https://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib
注释：
deb 行：这是用于二进制软件包的源地址。deb 行指定了从指定源下载二进制软件包的 URL。
deb-src 行：这是用于源代码软件包的源地址。deb-src 行指定了从指定源获取源代码软件包的 URL。
Kali Linux 源包括两种类型的软件包：二进制软件包和源代码软件包。二进制软件包是已经编译过的可直接安装的软件，而源代码软件包是包含软件源代码的包。
为了方便用户，Kali Linux 提供了两个不同的源地址，分别用于获取二进制软件包和源代码软件包。因此，你需要同时添加 deb 行和 deb-src 行来配置二进制软件包和源代码软件包的下载地址。
当你使用 apt-get source 命令或者其他方式获取源代码时，系统会根据 deb-src 行中的地址下载相应的源代码软件包。如果你只关心获取已编译的二进制软件包，而不需要源代码，可以忽略 deb-src 行，在配置源时只添加 deb 行.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62b648f21ed2d55856f11e7a85468020/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5abd8a8bc7c6f7befafbce8137ed68ec/" rel="bookmark">
			C语言之数组(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文适合初学者，通过本文你可以迅速了解二维数组的相关的一系列知识点。为了让读者更好的巩固理解本文所学知识，在文章末尾也是提供了多个案例以供练手，参考。
这篇文章的大体内容，是半年前就写完了，然后就一直仍在草稿箱吃灰，今天加以补充完善，但是因为时间过的太久，所以风格可以略有不同（比如编辑器的使用），还望谅解。再补充一句，现在CSDN好像引入了AI检测，要求加上前言，不然就会给我弹出改进质量这个标签。读过我往期的文章就知道我一般是直接上干货的，也许我才识浅陋，但我对写文章的态度还是很认真的，所以我不想被AI赋予这个标签。以后文章可能都会加入前言，帮助读者快速明确，本文是否匹配自己需求。
一.二维数值数组的定义 定义形式： 类型说明符 数组名[常量表达式1][常量表达式2];
二维数值数组的理解： 二维数值数组从逻辑上可理解为行-列矩阵。二维数值数组可以看成是一种特殊的一维数值数组：即它的元素又是一个一维数值数组。
例如，二维数组a[3][4]，可以看成一个一维数组，它有3个元素a[0]、a[1]、a[2]，每个元素又是一个包含4个元素的一维数组。
二.二维数值数组元素的引用 数组名[下标1][下标2];
下标可以是整型表达式，如：a[2-1][2*2-1]下标可以是已经有值的变量或数组元素，如： a[2*x-1][b[3][1]] PS：引用数组元素时，数组元素的下标应在已定义数组的大小范围内。
三.二维数值数组的存储 存放顺序：按行连续存放先顺序存放第0行的元素再存放第1行的元素。
四.二维数值数组的初始化 按行给二维数组赋初值,如:int a[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12] 按排列顺序对各元素赋初值,如：int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12}; 按行赋值，可对部分元素赋初值，其余自动取0值,如：int a[3][4]={{1},{5,6},{9}}; PS:
若对全部元素赋初值，则定义数组时可不说明第一维的长度（一对方括号不能省），第二维的长度必须指明。如:int a[ ][4]={1,2,3,4,5,6,7,8,9,10,11,12}; （2)在按行赋初值时，也可以省略第一维的长度说明。如:int a[ ][4]={{1,2,3},{0},{0,10}]; 五.二维数值数组的输入和输出 例如对int a[2][3]进行操作。
输入方法: 输入第i行第j列元素
scanf("%d",&amp;a[i][jD);
输入所有数组元素
for (i=0;i&lt;2;i++)
for(j=0;j&lt;3;j++)
scanf("%d",&amp;a[i][jD);
输出方法: 输出第i行第j列元素
printf("%d",a[i]lj]);
输出所有数组元素
for (i=0;i&lt;2;i++)
for(j=0;j&lt;3;j++)
printf("%d",a[i][j]);
原则：只能逐个对数组元素进行操作。 六.二维数值数组的应用 例1.将一个二维数组a中的行和列的元素互换，存到另一个二维数组b中（转置）后输出。 问题分析：
定义数组a为2行3列，并初始化。定义数组b为3行2列。用二重循环进行转置。b[j][i]=a[i]Lj]。输出b数组,且需要每输出两数换行一次。 代码如下：
#include&lt;stdio.h&gt;
void main()
{
int a[2][3]={1,2,3,4,5,6},b[3][2],i,j,n=0;
for(i=0;i&lt;2;i++)
for(j=0;j&lt;3;j++)
b[j][i]=a[i][j];
for(i=0;i&lt;3;i++)
for(j=0;j&lt;2;j++)
{
printf("%d",b[i][j]);
n++;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5abd8a8bc7c6f7befafbce8137ed68ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3e42ef60bfb60a27224e8bd79f437a4/" rel="bookmark">
			关于springboot传blob数据到前端并包装资源到audio实现播放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下自己在写代码时候遇到的问题
由于咱们的音频数据是以blob类型存储的mysql数据库中的，当我们将它提取到java中的时候需要用byte[]来接收，
但是要怎么发送到前端，并且前端可以使用呢？(我是小白)
下面贴出controller中的代码：
①String responseType = "audio/" + fileName.split("\\.",2)[1] + ";charset=utf-8"; 1号代码的意思是 设置响应数据的格式，因为我们的文件类型有很多种，（）这里我们以音频数据为例，音频数据有熟知的mp3、flac、wav等类型）同时也要设置编码格式，将它塞入响应头中。最后将数据返回
这是前端的一个根据选中去后台申请数据
这里用async是为了在调用getMusic()的时候要等它完成再执行后面的内容
注意：responseType要设置为blob类型
上面的代码是临时的
步骤
1.将byte[] 数据转换为blob对象类型
const blob = new Blob( [ 要转换的数据] , { type:'参数类型(如audio/flac)' })
2.将blob对象转换为URL对象
const url = URL.createObjectURL(blob)
这样就可以使用啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b3a574fca2756cb5ffd7bcc0408a402/" rel="bookmark">
			HAL库下，重定向printf函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在STM32CubeMx软件中，图形化配置打开USART外设。在Keil软件中，编辑usart.c，添加如下代码。在使用printf函数的文件中，添加引用：#include "usart.h"，即可正常使用。 /* USER CODE BEGIN 1 */ #if 1 #pragma import(__use_no_semihosting) struct __FILE { int handle; }; FILE __stdout; void _sys_exit(int x){ x = x; } // "USARTx"指定到需要的串口上 int fputc(int ch, FILE *f){ while((USART1-&gt;SR&amp;0X40)==0){}; USART1-&gt;DR = (uint8_t) ch; return ch; } #endif /* USER CODE END 1 */ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9054b11e34ba2972bea3e55c0524a51c/" rel="bookmark">
			ddddocr安装失败、安装错误、终极解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 去github下载源码(点击下载源码)
下载完成解压后是这个样子的
把dddocr文件直接复制到你的项目目录下调用即可
可能需要安装库，要不然会报一个缺少模块的错，确什么补什么就行了。我这儿安装了一个onnxruntime就ok了
# -*- coding: utf8 -*- import ddddocr import sys class DdddocrTest(object): ''' Ddddocr test : sys.argv[1] as the codeImg parameter Useage example: /usr/local/bin/python3 DdddocrTest.py codeImage.jpg ''' def ocrTest(self): ocr = ddddocr.DdddOcr() with open('1.png', 'rb') as f: img_bytes = f.read() res = ocr.classification(img_bytes) print('识别出的验证码为：' + res) if __name__ == '__main__': obj = DdddocrTest() obj.ocrTest() ####### 欢迎使用ddddocr，本项目专注带动行业内卷，个人博客:wenanzhe.com 训练数据支持来源于:http://146.56.204.113:19199/preview 爬虫框架feapder可快速一键接入，快速开启爬虫之旅：https://github.com/Boris-code/feapder 谷歌reCaptcha验证码 / hCaptcha验证码 / funCaptcha验证码商业级识别接口：https://yescaptcha.com/i/NSwk7i 识别出的验证码为：cbk0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b62957ec56d531f42491c84215be6d29/" rel="bookmark">
			stable diffusion学习笔记【2023-10-2】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		L1：界面 CFG Scale：提示词相关性
denoising：重绘幅度
L2：文生图 女性常用的负面词
nsfw,NSFW,(NSFW:2),legs apart, paintings, sketches, (worst quality:2), (low quality:2), (normal quality:2), lowres, normal quality, ((monochrome)), ((grayscale)), skin spots, acnes, skin blemishes, age spot, (outdoor:1.6), manboobs, backlight,(ugly:1.331), (duplicate:1.331), (morbid:1.21), (mutilated:1.21), (tranny:1.331), mutated hands, (poorly drawn hands:1.331), blurry, (bad anatomy:1.21), (bad proportions:1.331), extra limbs, (disfigured:1.331), (more than 2 nipples:1.331), (missing arms:1.331), (extra legs:1.331), (fused fingers:1.61051), (too many fingers:1.61051), (unclear eyes:1.331), bad hands, missing fingers, extra digit, (futa:1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b62957ec56d531f42491c84215be6d29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fccfcb8baf740b5df0c115e810efbbea/" rel="bookmark">
			C语言之数组(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.数组的基本概念 数组是按序排列的具有相同类型的数据的集合。用统一的符号 (数组名）来表示，数组中的每一个分量(元素)用下标来区分。
下标标明了元素在数组中的位置，从0开始。用数组名和下标就能惟一确定数组中的元素。 二.数组的分类 1.根据数组的维度不同，分为: 一维数组二维数组多维数组 2.根据数组元素的数据类型不同，分为: 数值数组字符数组 与其他变量相类似，数组也要先定义后使用。
三.一维数值数组的定义 定义形式： 类型说明符 数组名[常量表达式]; 类型说明符： 说明数组中各元素的数据类型
常量表达式： 说明数组的大小(即数组中元素的个数)
PS： 数组名的命名规则与变量名相同，遵循标识符命名规则，且数组名不能与程序中其他变量同名。 说明数组大小的常量表达式必须为整型，并且用方括号括起来（不能用圆括号)。 说明数组大小的常量表达式中可以包含常量和符号常量，但不能是变量。 数组定义之后，其大小不能再改变。 数组被定义后，实际是定义了若干个类型相同的有关联的变量,即数组元素的作用相当于简单变量。 四.一维数值数组的引用 形式： 数组名[下标]; PS：
下标可以是整型常量、整型表达式，或已经有值的整型变量。
定义数组时，下标表示数组的长度或元素的个数；
引用数组元素时，下标表示元素在数组中的序号或位置。
int a[5]; /*定义数组的长度为10*/
t=a[3]; /*使用数组元素a[6]*/
五.一维数值数组的存储 数组名是整个数组的首地址，用来唯一标识该数组，是一个由系统分配的常量值。 数组名+下标，表示数组中某元素的地址。 还可以用取地址运算符“&amp;”，表示数组中某元素的地址。 六.一维数值数组的赋值 1.静态赋值 数据类型 数组名[常量表达式]={初始值，初始值，……}; (1)对数组各元素均赋初值。如: int a[10]={0,1,2,3,4,5,6,7,8,9};
此时方括号中的常量表达式也可以省略,即可以写成：
int a[ ]= {0,1,2,3,4,5,6,7,8,9};
(2)可以只给数组的前若干个元素赋初值，此时后面的元素均将自动赋以初值0。如: int a[10]={0,1,2,3,4};
相当于：
int a[10]={0,1,2,3,4,0,0,0,0,0};
部分初始化时，方括号中的常量表达式不能省略。
(3)若要全部元素值为0，可以写成: int a[10]={0};
相当于：
int a[10]={0,0,0,0,0,0,0,0,0,0};
PS：若定义数组长度与提供的初值个数不相同，则数组长度不能缺省。 2.动态赋值 定义float类型数组price[4]；
可以通过scanf函数来进行赋值，例如对第三个元素赋值：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fccfcb8baf740b5df0c115e810efbbea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0971e1718c327b6a77fa81951b0846c/" rel="bookmark">
			聊天室系统原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有同学秋招面试被问到聊天室项目，于是想自己去总结一下，这里只记录设计思路。
首先有一个通信内容协议类Request，它约定了通信双方遵守的规则，包括发送消息的类型，发送者，接收者等。parameters属性是一个Map&lt;String, String&gt;，用于存放这些属性。
在网络中通信，当客户端和服务器不在同一台主机时，直接用object流传输消息不便于转换和恢复对象的状态信息和做持久化操作，同时Object流通常会比字符串更大，因为它包含了更多的元数据和状态信息，这会增加数据传输的大小和网络带宽的消耗，降低传输效率，所以还提供fromString和toString方法实现Request和String之间的转换。字符串格式key1=val1,key2=val2...。常量VK_S_01和VK_S_02是在转换成字符串前把发送内容中的 “=” 和 “,” 临时用特殊符号代替。
/** * 请求 通信的内容协议 */ public class Request { private static final String VK_01 = ","; private static final String VK_S_01 = "#vk01#"; private static final String VK_02 = "="; private static final String VK_S_02 = "#vk02#"; /** * 群聊的类型 */ public static final String MSG_TYPE_ALL = "all"; /** * 私聊的类型 */ public static final String MSG_TYPE_ONE = "one"; /** * 抖动的类型 */ public static final String MSG_TYPE_SHAKE = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0971e1718c327b6a77fa81951b0846c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af664c3ba2b2e20ad74f8cf81225cb18/" rel="bookmark">
			MySQL explain SQL分析工具详解与最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、explain工具介绍二、添加示例表和数据用于后续演示三、explain中的列3.1、id列3.2、select_type列3.3、table列3.4、partitions列3.5、type列NULLsystemconsteq_refrefrangeindexALL 3.6、possible_keys列3.7、key列3.8、key_len列3.9、ref列3.10、rows列3.11、filtered列3.12、Extra列Using indexUsing whereUsing index conditionUsing temporaryUsing filesortSelect tables optimized away 一、explain工具介绍 使用explain关键字可以模拟优化器执行SQL语句，分析你的查询语句或是结构的性能瓶颈在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询会返回执行计划的信息，而不是执行这条SQL。
通过explain执行SQL语句还能查看优化器优化之后的SQL，紧随其后通过 SHOW WARNINGS; 命令可以得到优化后的查询语句，从而看出优化器优化了什么
# 例如 EXPLAIN SELECT * FROM role; SHOW WARNINGS; 二、添加示例表和数据用于后续演示 这里会使用角色加菜单关系三张表来做演示。
DROP TABLE IF EXISTS `menu`; CREATE TABLE `menu` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '菜单ID', `menu_name` varchar(50) DEFAULT NULL COMMENT '菜单名称', `remark` varchar(255) DEFAULT NULL COMMENT '备注', `del_flag` tinyint(4) NULL DEFAULT 0 COMMENT '删除标识 0：已删除 1：未删除 默认0', `create_time` datetime(0) NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '创建时间', PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB COMMENT = '菜单表'; INSERT INTO `menu` VALUES (1, '系统管理', '管理系统用户角色菜单相关', 0, '2023-09-28 10:45:41'); INSERT INTO `menu` VALUES (2, '商品管理', '管理系统商品', 0, '2023-09-28 10:46:04'); DROP TABLE IF EXISTS `role`; CREATE TABLE `role` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '角色ID', `role_name` varchar(50) DEFAULT NULL COMMENT '角色名称', `remark` varchar(255) DEFAULT NULL COMMENT '备注', `del_flag` tinyint(4) NULL DEFAULT 0 COMMENT '删除标识 0：已删除 1：未删除 默认0', `create_time` datetime(0) NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '创建时间', PRIMARY KEY (`id`) USING BTREE, KEY `idx_roleName` (`role_name`) ) ENGINE = InnoDB COMMENT = '角色表'; INSERT INTO `role` VALUES (1, '超级管理员', '最大角色', 0, '2023-09-28 10:43:31'); INSERT INTO `role` VALUES (2, '普通人员', '小卡拉米', 0, '2023-09-28 10:45:14'); DROP TABLE IF EXISTS `role_menu`; CREATE TABLE `role_menu` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '角色菜单关联ID', `role_id` bigint(20) NOT NULL COMMENT '角色ID', `menu_id` bigint(20) NOT NULL COMMENT '菜单ID', PRIMARY KEY (`id`) USING BTREE, KEY `idx_roleId_menuId` (`role_id`,`menu_id`) ) ENGINE = InnoDB COMMENT = '角色菜单关联表'; INSERT INTO `role_menu` VALUES (1, 1, 1); INSERT INTO `role_menu` VALUES (2, 1, 2); INSERT INTO `role_menu` VALUES (3, 2, 2); 三、explain中的列 explain中有12个列分别代表不同指标，这里会举例介绍。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af664c3ba2b2e20ad74f8cf81225cb18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1af3bbb267fd4b164bef5e03bab30b0/" rel="bookmark">
			lvgl不能显示图片，但可以显示按键？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AT32F403A, IAR, ST7735S, LVGL8.3。
一、现象： 本来想着用LVGL做一个摄像头的显示功能 + 切换动态。可是死活实现不了功能。
因为移植好LVGL后，首先测试了显示按键，功能正常，以为是一切正常。在模拟器上调试效果完成后，将代码搬运到IAR工程里。却发现无法正常显示，也就是不显示。
二、分析： 一开始以为模拟器与实际项目有差别，因为以前出现过这种现象：
lv_canvas_create(lv_scr_act()); //不显示
lv_canvas_create(NULL);//显示
于是分步测试代码功能。我使用的动态显示摄像头数据的实现是：
lv_img。直接写lv_img的源.data数组，再lv_obj_invalidate来通知绘图函数重绘。
既然这样不显示，那么我就试试其它的方法。比如调用lv_img_set_src(, );、使用canvas等，都没有用，而且还发现在static void disp_flush(lv_display_t * disp_drv, const lv_area_t * area, uint8_t * px_map)里面，px_map指向的是内存，而这片内存的数据里都是0，也就是背景色。我还专门将图象的左上角设置成多种颜色，放在(0,0)位置处，同样px_map里面存的是0。
于是问题陷入了僵局，问题应该在别处而我又找不到。想到的几个方法是
1、断点跟踪问题： 在移植的绘图函数里找断点，通过callback view向上分析：
到底哪里拷贝了px_data数据，是不是那里出现了什么错误。
但这样一来就需要修改lvgl内核源码，可能会产生更多问题，更是会消耗更多时间。
2、再次移植LVGL源码： 第一次移植的是开发者版本的源码，但是运行直接卡死。没办法重下了8.3的版本，由于两者相差比较大，索性重新移植。前面的问题就是在这第二次移植的基础上出现的。
这次直接移植也只是重下后，进行文件替换。
结果编译发现出错：
LV_IMG_CF_TRUE_COLOR 、与 LV_COLOR_SIZE未定义。
LV_COLOR_SIZE可以改为LV_COLOR_DEPTH，就在lv_conf.h里定义，这个很好找。
但是LV_IMG_CF_TRUE_COLOR我一直在enum _lv_color_format_t里找到，里适合的是LV_COLOR_FORMAT_RGB565。
两者区别如下：
LV_IMG_CF_TRUE_COLOR4LV_COLOR_FORMAT_RGB5650x12 怪不得出错，第一个移植8.3的程序我是直接将缺少的定义复制到头文件里，不只是名字的区别。看来是被LV_COLOR_SIZE误导了一下。
三：原因： LV_COLOR_FORMAT_RGB565 ！= LV_IMG_CF_TRUE_COLOR
猜测可能lvgl官网的图片转换用的还是老版本的，不支持8.3。
四、解决： 解决如下：
const lv_img_dsc_t test = { .header.cf = LV_COLOR_FORMAT_RGB565, .header.always_zero = 0, .header.reserved = 0, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1af3bbb267fd4b164bef5e03bab30b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07ad94fa6608c21112083b1535e84c2f/" rel="bookmark">
			【CV | TAL】论文浅读 - - VideoMAE V2: Scaling Video Masked Autoencoders with Dual Masking
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、VideoMAE V2论文解读摘录1、研究背景动机2、改进方法分析 二、VideoMAE V2源码简析总结 前言 Masked Autoencoder (MAE) 是一种基于自编码器（Autoencoder）的无监督学习方法，用于特征学习和数据降维。它通过在训练阶段对输入数据施加掩码（mask），强制模型只能使用部分输入信息进行重构，从而促使模型学习到更有意义的表示。
自编码器是一种神经网络模型，由编码器和解码器组成。编码器将输入数据映射到低维表示，解码器则将低维表示映射回重构数据。自编码器的目标是尽可能准确地重构输入数据，以便捕捉输入数据的关键特征。
通过掩码操作，MAE 可以对输入数据进行特征选择，只保留对模型重构有贡献的重要特征。这有助于减少数据维度，提高模型的泛化能力，并且可以用于异常检测、降噪、特征提取等应用场景。
MAE 的训练过程通常使用无监督的方式进行，通过最小化输入数据与重构数据之间的重构误差来优化模型参数。在训练完成后，可以使用编码器部分的模型来提取输入数据的低维表示，这些表示具有更高层次的抽象特征。
一、VideoMAE V2论文解读摘录 论文链接：
https://arxiv.org/abs/2303.16727
源码链接：
https://github.com/OpenGVLab/VideoMAEv2
1、研究背景动机 在视觉领域，有很多工作致力于发展预训练（Pretrain）模型。其中，采用掩码自编码方法预训练的 Transformer 模型正受到越来越多的关注，作为一种自监督视觉学习器，它在概念上简单却十分有效。研究人员尝试利用这种自监督范式在视频数据集上训练Video Transformer，并且提出了一种基于掩码和重建 (masking-and-reconstruction)这种代理任务的视频自监督预训练算法VideoMAE(Video Masked Autoencoder)。经过VideoMAE预训练的ViT模型能够在Kinetics-400和Something-Something V2这种较大的视频数据集，以及UCF101和HMDB51这种规模相对小的视频数据集上取得大幅优于其他方法的效果
视频数据不同于图像数据，视频有额外的时序维度和极高的时序冗余性，比如视频片段中会有很多静态背景帧，其本身并不具有很重要的时序特征。且视频特征维度高，计算开销更甚于图像，这阻滞了掩码自编码预训练方法在视频领域的可扩展性研究，所以MAE方法仍存在一些问题包括：
1）扩展会导致高昂的计算开销和显存占用，在现有硬件上难以承受；
2）掩码自编码预训练方法依然需要大量数据来减小训练大模型时的过拟合风险，但已有的公开视频数据集比较小；
3）如何充分释放十亿参数级别的预训练大模型的性能。
VideoMAE在解决视频数据集体量相对较小难以训练出性能较好的视觉大模型的问题上给出了开拓性的答案，同时它也降低了视觉大模型的训练成本，提高训练效率。但VideoMAE仍会导致高昂的计算开销和显存占用问题，论文作者运用视频数据的冗余性特点，通过VideoMAE v2的双重掩码策略在减小计算资源占用的同时也保持了VideoMAE强大的重建视频特征的能力。
2、改进方法分析 VideoMAE v2采用双重掩码方案，上一版本的VideoMAE采用对encoder掩码的方式来训练，V2提出同时对encoder和decoder进行掩码，生成两个掩码映射矩阵 M e = M e ( ρ e ) Me = M_e(ρ^e) Me=Me​(ρe) 和 M d = M d ( ρ d ) Md = M_d(ρ^d) Md=Md​(ρd)，具有两种不同的掩码生成策略和掩码比率。通过对decoder掩码来减少解码器的输入长度，可以提高效率，同时获得与完整重建相似的信息。
编码器采用管道掩码策略，取video每帧图像按固定窗口大小沿时间维度 T T T 进行延拓进行mask形成cube；解码器采用运动单元掩码策略，需要处理编码器输出的合并标记，并将剩余的可见标记置于解码器掩码，其中， Z Z Z 是来自编码器的潜表征， M i M_i Mi​ 是具有相应位置嵌入的可学习掩码标记
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07ad94fa6608c21112083b1535e84c2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5a5475856958c971802d219c92d6802/" rel="bookmark">
			【C/C&#43;&#43;笔试练习】二维数组、二维数组的访问，解引用，地址计算、计算糖果、进制转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 C/C++笔试练习1.二维数组（1）二维数组的访问（2）二维数组的初始化（3）二维数组的解引用（4）二维数组的解引用（5）多维数组的解引用（6）二维数组的地址计算（7）二维数组和数组指针 2.编程题（8）计算糖果（9）进制转换 C/C++笔试练习 1.二维数组 （1）二维数组的访问 在int p[][4] = {{1}, {3, 2}, {4, 5, 6}, {0}};中，p[1][2]的值是（）
A 1 B 0
C 6 D 2
在C++中，可以通过使用索引来访问二维数组中的元素。二维数组的索引是一个包含两个值的整数对，第一个值表示行，第二个值表示列。
以下是访问二维数组元素的一般语法：
arrayName[rowIndex][columnIndex] 其中，arrayName是二维数组的名称，rowIndex是行，columnIndex是列。索引值从0开始，因此第一行的索引是0，第一列的索引也是0。而且一般行的初始化都在 { } 中执行。
例如，考虑以下二维数组的声明和初始化：
int arr[3][4] = {{0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11}}; 要访问位于第二行第三列的元素，可以使用索引[1][2]，如下所示：
int element = arr[1][2]; // element 的值为 6 注意，行索引和列索引都是从0开始的，所以arr[1][2]访问的是第二行第三列的元素，而不是第三行第四列的元素。
所以对于上面的问题，二维数组是以行优先的方式在内存中连续存储的。对于一个声明为int p[][4]的二维数组，它表示的是一个具有未指定行数和4列的二维整型数组。
在给定的初始化列表{{1}, {3, 2}, {4, 5, 6}, {0}}中，数组的第一行只有一个元素1，第二行有两个元素3和2，第三行有三个元素4、5和6，第四行有一个元素0。而且数组是按行优先的方式存储的。
注意，对于一个部分初始化的二维数组，未被初始化的元素会被自动设置为0。 在给定的初始化列表{{1}, {3, 2}, {4, 5, 6}, {0}}中，第二行只初始化了两个元素3和2，所以第三个元素会被设置为0，所以元素在内存中的排列顺序是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5a5475856958c971802d219c92d6802/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d2d9a74fc8a76a38ca1764e0a09c020/" rel="bookmark">
			STM32CubeMX与Keil联动——看门狗IWDG
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、STM32CubeMX下的图形化配置
1、配置调试下载接口、时钟源接口
2、配置看门狗外设
3、配置GPIO
4、配置时钟树
4、工程基本设置
5、生成代码工程
二、Keil下的代码编辑
1、编辑main.c文件
三、烧录运行，观察试验现象
功能说明：芯片复位时，翻转一次LED亮灭状态，之后进入死循环进行喂狗。
一、STM32CubeMX下的图形化配置 本文以STM32F103ZET6为例。
1、配置调试下载接口、时钟源接口 开启Debug功能 开启外部时钟源​​​​​​ 2、配置看门狗外设 如图配置看门狗，定时为1秒。
时钟源 ：40KHz（在下文时钟树中可以获取到该信息）预分频系数 ：16递减为零后的重载数值 ：2499看门狗实际定时： 配置看门狗 3、配置GPIO 为了展示有无看门狗的现象，这里额外增加一颗LED的控制。
高电平 = 熄灭LED低电平 = 点亮LED 开启PB14以控制LED 4、配置时钟树 外部输入时钟频率与板卡上的晶振保持一致，依次打开图示的路径选项 4、工程基本设置 代码编辑工具设置为Keil 勾选这两个选项（只拷贝用到的外设的库文件、将代码分开成为.h和.c） 5、生成代码工程 二、Keil下的代码编辑 1、编辑main.c文件 main()中，在死循环外边添加LED翻转函数，在死循环内添加喂狗函数。
/** * @brief The application entry point. * @retval int */ int main(void) { /* USER CODE BEGIN 1 */ /* USER CODE END 1 */ /* MCU Configuration--------------------------------------------------------*/ /* Reset of all peripherals, Initializes the Flash interface and the Systick.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d2d9a74fc8a76a38ca1764e0a09c020/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b050e5b9904be81d7d778249335ec747/" rel="bookmark">
			Centos7环境下安装MySQL8详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、Xftp7下载二、MySQL8安装包的下载三、将MySQL8安装包上传至服务器四、解压mysql8安装包五、rpm包的安装六、依次安装下列文件七、对MySQL进行初始化和授权八、查看数据库初始密码九、启动MySQL服务十、使用初始密码登录MySQL关于MySQL的卸载 一、Xftp7下载 关于Xftp7的下载就不进行演示了，下载之后长这个样子：
我们需要利用Xftp7来把MySQL8的安装包上传到服务器上。
二、MySQL8安装包的下载 有两种途径可以安装MySQL8安装包：
官网：https://dev.mysql.com/downloads/mysql
C站：https://download.csdn.net/download/zp8126/20694042
下载成功之后长这个样子：
三、将MySQL8安装包上传至服务器 我们需要利用Xftp7来把MySQL8的安装包上传到服务器上。
首先打开Xshell：
然后把我们下载好的MySQL8的安装包上传至服务器上，然后等待传输完成即可：
这就算是传输成功了。
我们这里吧MySQL8的安装包安装到了opt目录下，然后在opt目录中新建了mysql8.0.26的文件夹，即把MySQL8的安装包移动到了mysql8.0.26的文件夹中，请看：
四、解压mysql8安装包 由于我们把mysql8的安装包移动到了mysql8.0.26文件夹中，所以我们先进入mysql8.0.26文件夹中，然后在此目录下进行解压
输入命令进行解压：tar -xvf mysql-8.0.26-1.el7.x86_64.rpm-bundle.tar
解压结果如下：
五、rpm包的安装 首先前往这个地址进行下载：https://developer.aliyun.com/packageSearch?word=telnet
即：
下载过程这里不进行演示了。
六、依次安装下列文件 重要的事情放前面：
注意安装的文件名，要和上面解压出来的文件名保持一致。注意要选择强制安装安装下面的命令顺序依次进行安装： 命令1:rpm -ivh mysql-community-common-8.0.26-1.el7.x86_64.rpm
命令2：rpm -ivh mysql-community-libs-8.0.26-1.el7.x86_64.rpm --nodeps --force
命令3：rpm -ivh mysql-community-client-8.0.26-1.el7.x86_64.rpm --nodeps --force
命令4：rpm -ivh mysql-community-server-8.0.26-1.el7.x86_64.rpm --nodeps --force
好了，经过以上4按照命令之后，我们检查以下是否按照成功，
输入命令：rpm -qa | grep mysql
七、对MySQL进行初始化和授权 输入命令1：mysqld --initialize;
输入命令1结束之后如果显示如下错误则需要输入命令：yum install -y libaio
然后再次执行命令1就可以啦，请看：
输入命令2：chown mysql:mysql /var/lib/mysql -R;
八、查看数据库初始密码 输入命令：cat /var/log/mysqld.log | grep password
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b050e5b9904be81d7d778249335ec747/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8012794dd78c89335103fb349be91bfd/" rel="bookmark">
			Elasticsearch基础篇(三)：Elasticsearch7.x的集群部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Elasticsearch的集群部署 1. Elasticsearch集群架构主节点数据节点客户端节点分片节点间通信集群状态 2. Elasticsearch集群部署2.1 系统配置修改2.1.1 修改文件句柄数和线程数2.1.2 修改虚拟内存2.1.3 关闭交换空间（Swap） 2.2 下载es数据库并上传到服务器2.3 修改集群配置文件2.3.1 elasticsearch.yml配置项说明2.3.2 修改node1节点配置信息2.3.2 修改node2节点配置信息2.3.3 修改node3节点配置信息 2.4 创建 Elasticsearch 用户和组2.5 设置目录权限2.6. 启动 Elasticsearch 服务2.6.1 配置启动内存（可选）2.6.2 创建启动和停止服务的脚本 2.7 开放防火墙端口CentOSUbuntu 2.8 查看es启动状态 1. Elasticsearch集群架构 Elasticsearch集群是一个强大的搜索和分析引擎，由多个节点组成，每个节点都是一个独立的Elasticsearch实例。这些节点协同工作，共同构建一个高度可用和可扩展的搜索引擎。本文将深入探讨Elasticsearch集群的架构和部署，包括主节点、数据节点、客户端节点、分片以及节点间的通信方式。
主节点 在Elasticsearch集群中，有一个节点被指定为主节点。主节点的主要任务是集群管理和协调工作。以下是主节点的一些关键职责：
维护集群状态： 主节点负责维护整个集群的状态，包括节点列表、索引元数据和分片状态等。
负责集群重平衡： 当新的节点加入或旧的节点退出集群时，主节点会负责重新平衡集群，确保分片被适当地重新分配给节点，以保持负载均衡。
执行集群级别操作： 主节点可以执行集群级别的操作，例如创建或删除索引、设置索引级别的设置等。
监控节点状态： 主节点监控集群中的各个节点的状态，及时检测节点是否正常工作。
在一个集群中，只能有一个主节点。如果主节点出现故障，Elasticsearch会自动选举一个新的主节点来接管工作，确保集群的稳定运行。
数据节点 数据节点的主要责任是存储和处理数据。当客户端向集群发起搜索请求时，数据节点会根据请求查询本地数据并返回结果。每个数据节点都负责存储集群中的一部分数据。当新的数据被索引时，数据节点会将数据分配给相应的分片，并将分片存储在本地磁盘上。如果数据节点发生故障，集群中的其他节点会接管该节点的工作，确保数据的可用性和冗余备份。
客户端节点 客户端节点不存储数据，它们的主要作用是向集群发送查询请求，并将查询结果返回给客户端应用程序。
客户端节点具有以下两个关键作用：
负载均衡： 客户端节点可以将查询请求分配给不同的数据节点，实现负载均衡，提高查询性能。
故障切换： 如果某个数据节点出现故障，客户端节点可以自动将查询请求切换到其他健康的节点，确保服务的可用性。
分片 在Elasticsearch集群中，数据被分成多个分片进行存储和管理。每个分片是一个独立的Lucene索引，包含了一部分数据和索引信息。分片可以在集群中的不同节点之间进行分配和复制，以实现高可用性和数据冗余。
每个索引都可以被分成多个主分片和多个副本分片。主分片是索引的基本单元，包含数据的一部分和索引信息。每个主分片都是独立的Lucene索引，可以在集群中的任何节点上存储。副本分片是主分片的拷贝，用于提高查询效率和可用性。
分片的数量在索引创建时指定，并且一旦创建后就不能更改。通常情况下，主分片的数量应该与集群中的数据节点数量相匹配，以确保每个节点都能存储一定数量的分片。
节点间通信 在Elasticsearch集群中，节点之间通过网络进行通信。每个节点都有一个唯一的节点名称，节点名称由Elasticsearch自动生成。节点名称通常采用以下格式：
&lt;host&gt;-&lt;uuid&gt;
其中，host是节点所在的主机名，uuid是一个唯一的标识符，用于确保节点名称的唯一性。
节点之间的通信可以通过两种方式进行：HTTP协议和Transport协议。HTTP协议是Elasticsearch的默认协议，用于处理RESTful API请求。Transport协议是Elasticsearch集群内部使用的协议，用于节点之间的直接通信。
集群状态 Elasticsearch集群的状态可以分为以下三种：
Green： 集群正常，所有主分片和副本分片都可用。
Yellow： 集群部分可用，所有主分片都可用，但一些副本分片不可用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8012794dd78c89335103fb349be91bfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1653d513355629bb915ba4ec37cc2f8/" rel="bookmark">
			uniapp实现上传文件功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UniApp是一款跨平台的开发框架，可用于开发微信小程序、H5、Android和iOS等多种平台应用。实现上传文件功能需要以下步骤：
引入uni.uploadFile API，代码如下： uni.uploadFile({ url: 'your upload url', filePath: 'your file path', name: 'your file name', header: { 'Content-Type': 'multipart/form-data' }, // 设置请求头 success: (res) =&gt; { console.log(res.data) }, fail: (err) =&gt; { console.log(err) } }) 在uni.uploadFile的回调函数中处理上传结果。 以上是实现上传文件功能的基本步骤，如果需要进一步的操作，可参考uni.uploadFile的官方文档。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97e5c344e11d4226236d3179c1abe2f1/" rel="bookmark">
			Win11-RTX4060安装 Pytorch-GPU/Anaconda 干货避坑指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、版本要和pytorch官网对应，CUDA11.8及其对应版本的cudnn2、CUDA Toolkit安装出现自动重启3、Python版本4、配置永久国内镜像源5、要在激活的虚拟环境里安装pytorch6、进入python后检查是否gpu配置成功7、在虚拟环境中启动jupyter notebook8、conda中install找不到的包9、jupyter notebook 500打不开了怎么办10、jupyter notebook 能打不开了但是内核又连接不上了怎么办11、卸载虚拟环境12、安装anaconda环境到指定路径修改默认安装路径： 13、已经安装的模块，在Pycharm中的添加的conda解释器都能运行，但在jupyter notebook中仍显示No moudle怎么办？14、训练推理时不要忘记启用GPU device15、环境克隆clone16、Anaconda里创建了新的虚拟环境，但是却没有kernel怎么办？ 1、版本要和pytorch官网对应，CUDA11.8及其对应版本的cudnn 一开始我用Nvidia sim命令查的RTX-4060本地适配版本为CUDA12.0，但到了pytorch官网上才发现稳定本最高才支持11.8，于是又卸了重下，是否能向下兼容请在评论区分享。
Nvidia官网上下载对应的深度神经网络库版本(cudnn11.8)和CUDA Toolkit11.8：
如果没有Nvidia账号的话就创建一个并登录；
CUDA安装路径最好是默认C盘，环境变量其实没那么重要，CUDA会自动生产环境变量。
2、CUDA Toolkit安装出现自动重启 只勾选安装CUDA，不要勾选Geforce Experience那些；
如果C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.8\bin下能找到nvcc.exe，说明CUDA已经安装好了。
将cudnn解压后，复制替换掉C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.8下的同名文件夹就可以了。
cmd里输入nvcc -V，可以查看CUDA是否安装成功，-V要大写没有间隔。
3、Python版本 Anaconda里我的虚拟环境是用的python 3.10版本才成功，有的博客说3.8，3.9也行，不知道对不对，反正我一开始用的3.7不行。
Anaconda安装命令：conda create -n pytorch python=3.10
4、配置永久国内镜像源 在base环境里逐行输入：
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ conda config --set show_channel_urls yes 5、要在激活的虚拟环境里安装pytorch activate 虚拟环境名 conda install pytorch torchvision torchaudio pytorch-cuda=11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97e5c344e11d4226236d3179c1abe2f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcfc1f519bac03e11ec95366f32b5f3e/" rel="bookmark">
			Python脚本整理-8个Python实用脚本，赶紧收藏备用！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.解决 linux 下 unzip 乱码的问题。
2.统计当前根目录代码行数。
3.扫描当前目录和所有子目录并显示大小。
4.将源目录240天以上的所有文件移动到目标目录。
5.扫描脚本目录，并给出不同类型脚本的计数。
6.下载Leetcode的算法题。
7.将 Markdown 转换为 HTML。
8.文本文件编码检测与转换。
脚本写的好，下班下得早！程序员的日常工作除了编写程序代码，还不可避免地需要处理相关的测试和验证工作。
例如，访问某个网站一直不通，需要确定此地址是否可访问，服务器返回什么，进而确定问题在于什么。完成这个任务，如果一味希望采用编译型语言来编写这样的代码，实践中的时间和精力是不够的，这个时候就需要发挥脚本的神奇作用！
毫不夸张的说，能否写出高效实用的脚本代码，直接影响着一个程序员的幸福生活[下班时间]。下面整理 8 个实用的 Python 脚本，需要的时候改改直接用，建议收藏！
1.解决 linux 下 unzip 乱码的问题。 import os import sys import zipfile import argparse s = '\x1b[%d;%dm%s\x1b[0m' def unzip(path): file = zipfile.ZipFile(path,"r") if args.secret: file.setpassword(args.secret) for name in file.namelist(): try: utf8name=name.decode('gbk') pathname = os.path.dirname(utf8name) except: utf8name=name pathname = os.path.dirname(utf8name) #print s % (1, 92, ' &gt;&gt; extracting:'), utf8name #pathname = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcfc1f519bac03e11ec95366f32b5f3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a20a9e71c06e90b0a7ea63d7cd5fc85/" rel="bookmark">
			ConstraintLayout（约束布局）使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文出处 标题：万字长文 - 史上最全ConstraintLayout（约束布局）使用详解
作者：Web_boom
原文链接：万字长文 - 史上最全ConstraintLayout（约束布局）使用详解-CSDN博客
前言 ConstraintLayout 是一个使用“相对定位”灵活地确定微件的位置和大小的一个布局，在 2016 年 Google I/O 中面世，它的出现是为了解决开发中过于复杂的页面层级嵌套过多的问题——层级过深会增加绘制界面需要的时间，影响用户体验，以灵活的方式定位和调整小部件。从 Android Studio 2.3起，创建layout文件就已经是默认ConstraintLayout了，但是尽管Google如此大力推这项技术，但在当时很少有人使用，近些年逐渐被大家拿起来，啊真香！（此处无图胜有图）。目前ConstraintLayout正式版已经更新至2.0.4，本文将带领大家熟悉ConstraintLayout全部内容。
一. 布局的使用 1.1 位置约束 ConstraintLayout采用方向约束的方式对控件进行定位，至少要保证水平和垂直方向都至少有一个约束才能确定控件的位置
1.1.1 基本方向约束 比如我们想实现这个位置，顶部和界面顶部对齐，左部和界面左部对齐：
代码如下：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#DAF3FE" tools:context=".MainActivity"&gt; &lt;TextView android:layout_width="100dp" android:layout_height="60dp" android:background="@drawable/tv_bg" android:gravity="center" android:text="A" android:textColor="@color/black" android:textSize="25sp" android:textStyle="bold" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" tools:ignore="HardcodedText" /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 核心代码是这两行：
app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" 这两行代码的意思就是,控件的开始方向与父容器的开始方向对齐，控件的顶部方向与父容器的顶部方向对齐，其实layout_constraintStart_toStartOf也可以使用layout_constraintLeft_toLeftOf，但是使用start和end来表示左和右是为了考虑别的国家的习惯，有的国家开始方向是右，所以使用start和end可以兼容这种情况。到这里就可以看到该控件使用layout_constraintStart_toStartOf和layout_constraintTop_toTopOf两条约束确定了自己的位置，这里有一个使用技巧，就是，该控件的？？方向在哪个控件的？？方向，记住这一点就可以了。那么下面就介绍下全部的约束属性：
&lt;!-- 基本方向约束 --&gt; &lt;!-- 我的什么位置在谁的什么位置 --&gt; app:layout_constraintTop_toTopOf="" 我的顶部和谁的顶部对齐 app:layout_constraintBottom_toBottomOf="" 我的底部和谁的底部对齐 app:layout_constraintLeft_toLeftOf="" 我的左边和谁的左边对齐 app:layout_constraintRight_toRightOf="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a20a9e71c06e90b0a7ea63d7cd5fc85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a837d3718638d17a28f918a2c2e312f3/" rel="bookmark">
			Python-Flask：编写自动化连接demo脚本：v1.0.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主函数： # _*_ Coding : UTF-8 _*_ # @Time : 13:14 # @Author : YYZ # @File : Flask # @Project : Python_Project_爬虫 import json from flask import Flask,request,jsonify import ssh api = Flask(__name__) # methods: 指定请求方式 ''' 接口解析参数 host = host_info["host"] port = host_info["port"] service = host_info["service"] user = host_info["user"] pwd = host_info["pwd"] ''' @api.route('/',methods=['POST']) def install(): # 请求方式为post时，可以使用 request.get_json()接收到JSON数据 try: #host_info = request.get_json() # 获取 POST 请求中的 JSON 数据 host_info = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a837d3718638d17a28f918a2c2e312f3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/81/">«</a>
	<span class="pagination__item pagination__item--current">82/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/83/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>