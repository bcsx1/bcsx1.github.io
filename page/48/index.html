<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f5e9ebd6efb9d7bb83e96d9ff72c231/" rel="bookmark">
			https 加密协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是https 加密协议?
HTTPS（全称：Hyper Text Transfer Protocol Secure），是以安全为目标的 HTTP 通道，在 HTTP 的基础上通过传输加密和身份认证保证了传输过程的安全性。
HTTPS 在 HTTP 的基础上加入了 SSL/TLS 协议，SSL/TLS 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。
HTTPS 的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。
因此，https 加密协议是一种安全的网络通信协议，它可以保护用户在网站上输入的敏感信息（如密码、信用卡号等）不被窃取或篡改。
HTTPS协议是一个安全通信通道，它基于HTTP开发用于在客户计算机和服务器之间交换信息。
它使用安全套接字层(SSL)进行信息交换，简单来说它是HTTP的安全版，是使用TLS/SSL加密的HTTP协议。
TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免信息窃听、信息篡改和信息劫持的风险。
TLS/SSL全称安全传输层协议Transport Layer Security，是介于TCP和HTTP之间的一层安全协议，位于传输层，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。
以上内容仅供参考，可以咨询计算机领域专业人士获取更全面准确的信息。
HTTPS（全称：Hypertext Transfer Protocol Secure）是一种网络安全协议，用于在互联网上安全地交换数据。它是HTTP（超文本传输协议）的安全版本，通过将SSL/TLS（Secure Sockets Layer/Transport Layer Security）加密层添加到HTTP通信中来提供安全性。
HTTPS的主要目标是保护敏感信息的隐私和完整性，如登录凭据、信用卡号和个人数据等。它通过以下方式实现这一目标：
身份验证： HTTPS使用数字证书来验证服务器的身份，确保用户与正确的网站进行交互。加密： HTTPS使用SSL/TLS协议对客户端和服务器之间的通信进行加密，防止数据在传输过程中被窃取或篡改。完整性： HTTPS提供了数据完整性校验，确保数据在传输过程中没有被改变。 当用户访问一个启用了HTTPS的网站时，浏览器会首先请求服务器的SSL证书。然后，浏览器会对证书的有效性进行检查，包括确认颁发机构、过期日期以及是否与正在访问的域名匹配。如果证书有效，浏览器会生成一个随机密钥，并用服务器的公钥对其进行加密，然后将其发送给服务器。服务器使用私钥解密这个密钥，之后双方就可以使用这个密钥来进行对称加密的通信了。
由于这些安全特性，HTTPS已经成为现代Web应用的标准，许多浏览器和搜索引擎都在推广HTTPS以提高整个互联网的安全性。
如何判断一个网站是否使用了https加密协议？
要判断一个网站是否使用了 HTTPS 加密协议，可以通过以下几种方法：
查看 URL：如果网站的 URL 以“https://”开头，而不是“http://”，则说明该网站使用了 HTTPS 加密协议。
查看锁形图标：在使用 HTTPS 加密的网站中，浏览器的地址栏中会显示一个锁形图标。点击锁形图标可以查看网站的证书信息，确认网站是否使用了 HTTPS 加密。
使用网络工具：可以使用一些网络工具，如 SSL 检测工具，来检测网站是否使用了 HTTPS 加密协议。
总之，使用 HTTPS 加密协议可以保护用户的隐私和数据安全，建议在进行敏感操作（如登录、支付等）时，选择使用 HTTPS 加密的网站。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f5e9ebd6efb9d7bb83e96d9ff72c231/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6e891105c289f7f470ed7a7abcf3b96/" rel="bookmark">
			CMakeLists获取文件夹——file指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CMakeLists获取文件夹——file 在 CMake 中查找当前目录及其子目录中的所有文件夹的方法有几种。以下是三种常见的方法，并附有相应的示例：
获取文件夹 方法一：使用 file(GLOB ...) 命令 cmake_minimum_required(VERSION 3.22.1) project(MyProject) # 使用 GLOB 获取所有文件夹 file(GLOB_RECURSE ALL_SUBDIRECTORIES LIST_DIRECTORIES true "*") # 输出所有文件夹 message("All subdirectories:") foreach(subdir ${ALL_SUBDIRECTORIES}) if(IS_DIRECTORY ${subdir}) message(" ${subdir}") endif() endforeach() 方法二：使用 file(GLOB ...) 结合 LIST_DIRECTORIES 选项 cmake_minimum_required(VERSION 3.22.1) project(MyProject) # 使用 GLOB 获取所有文件夹 file(GLOB ALL_SUBDIRECTORIES LIST_DIRECTORIES true "*") # 输出所有文件夹 message("All subdirectories:") foreach(subdir ${ALL_SUBDIRECTORIES}) message(" ${subdir}") endforeach() 方法三：使用 file(GLOB ...) 结合 DIRECTORY 选项 cmake_minimum_required(VERSION 3.22.1) project(MyProject) # 使用 GLOB 获取所有文件夹 file(GLOB ALL_SUBDIRECTORIES DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6e891105c289f7f470ed7a7abcf3b96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/416f43c164c0d3c8f780cc8434ee2793/" rel="bookmark">
			CH340系列介绍和STM32的BOOT模式选择烧录模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你是否在疑惑网上买的32最小系统无法串口烧录，你是否在疑惑STM32的BOOT引脚有什么作用，本篇文章将帮你解答。
目录
一、CH340系列介绍
1.CH340N、CH340G、CH340B芯片介绍
原理图
2.USB总线转串口的电路图连接与解释（以CH340N为例）
原理图连线（左图USB转串口，右图5V转3.3V模块）
3.MODEM联络信号引脚简介
二、STM32的BOOT模式介绍
三、最常用的两种烧录模式介绍
一、CH340系列介绍 CH340系列有许多芯片，这里选出了三种我认为最有代表性的三种芯片，分别是推出时间最早的CH340G,引脚数量最少的CH340N和引脚数量最多的CH340B(为什么不是CH340T，因为我不喜欢接晶振）。
1.CH340N、CH340G、CH340B芯片介绍 原理图 通过对比不难发现，有些引脚是必不可少的，UD+和UD-属于一对差分信号，是USB相关的信号输入口，RXD和TXD则是串口通讯的输入和输出，除此之外还有一些带#号的引脚，这些引脚则属于MODEM联络信号引脚。我们在使用的时候呢，只需要会用那些必不可少的就OK啦。
2.USB总线转串口的电路图连接与解释（以CH340N为例） 原理图连线（左图USB转串口，右图5V转3.3V模块） 连线是根据CH340芯片手册连的，我在这里截图截一些重点。
USB的电压为5V，CH340要在工作电压为3.3V的32上工作时则需要右图的降压模块。连线已经被博主画板贴片验证过了，串口烧录功能使用正常。值得注意的点时D+和D-与UD+和UD-直连，串口的TX和RX是发对收，收对发。
3.MODEM联络信号引脚简介 引脚名称类型引脚说明CTS# 输入
MODEM联络输入信号，清除发送，低（高）有效DSR#输入MODEM联络输入信号，数据装置就绪，低（高）有效RI#输入MODEM联络输入信号，振铃指示，低（高）有效DCD#输入MODEM联络输入信号，载波检测，低（高）有效DTR#输出MODEM联络输出信号，数据终端就绪，低（高）有效RTS#输出 MODEM联络输出信号，请求发送，低（高）有效
其中输出的两个引脚（DTR、RTS）可以与硬件电路配合实现一键ISP。
二、STM32的BOOT模式介绍 STM32有BOOT0和BOOT1脚，他们两个共同控制程序启动的区域，具体对应如下表。
BOOT1BOOT0程序启动区域X0主闪存存储器01系统存储器11内置SRAM 三、最常用的两种烧录模式介绍 1.串口烧录
串口烧录的条件：板载CH340芯片，电脑装了CH340的驱动。
满足串口烧录的条件后，可通过官方的烧录程序进行烧录。我的长这样。
烧录前，需要将BOOT1置0，BOOT0置1（一般跳帽控制），烧录完成后将BOOT0置回0复位，（实际这样操作比较繁琐，可以硬件利用CH340的DTR和RTS联络引脚设计电路，实现ISP一键下载！）这样就可以看到现象了，此时BOOT0置0,掉电后程序就不会丢失了。
2.ST_LINK烧录
一般的板子不会板载ST_LINK，不过会将ST_LINK需要的接口引出，STM32上与ST_LINK相关的接口为SWIO和SWCLK，这样只需在网上买一个ST_LINK下载器（也可以自己做一个），把线接好就能在Keil里面烧录了，更加方便。别忘了把BOOT0置0。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9014d20fa3cd3d2895aaf27297504f20/" rel="bookmark">
			【webpack】初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webpack 旧项目的问题下一代构建工具 Vite 主角 ：webpack安装webpack1，mode的选项2，使用source map 精准定位错误行数3，使用watch mode(观察模式)，自动运行4，使用webpack-dev-server工具，自动刷新 自定义webpack配置初始化代码webpack处理资源模块（asset module）asset/resourceasset/inlineasset/sourceasset 管理资源（loader）css-loader抽离style里代码，并压缩知识点补充，在css里面加载图片资源知识点补充，加载fonts字体知识点补充，加载csv,tsv,xml数据自定义JSON模块parser 使用babel-loader转换js文件regeneratorRuntime插件 旧项目的问题 作用域问题
return 抛出赋给变量 如何解决代码拆分问题
module.exports()抛出模块require()接受模块 如何让游览器支持node模块
下一代构建工具 Vite 主角 ：webpack 它可以帮助我们打包javascript的应用程序，同时支持es的模块化以及commonjs可以扩展支持很多的静态资源打包，图片，字体，样式等只能理解js和json这样的文件出色的功能：除了引入js还可以使用内置的资源模块 引用千峰教育一个图：
安装webpack 安1：npm init -y
安2：npm install webpack webpack-cli --save-dev
安3： npm install html-webpack-plugin -D
执行完前两个会产生三个文件，第三个是为了自动引入资源
1，mode的选项 mode: 'none', //不展示编译时候的警告，还可以选择'development' 2，使用source map 精准定位错误行数 当我们游览器报错，点击报错内容时，发现报错的指向不是源文件时候，不好排除错误 devtool: 'inline-source-map', //可以精准的锁定出错位置行数,并且打包出的文件不再是乱码 3，使用watch mode(观察模式)，自动运行 每次编译代码，都需要手动运行npx webpack会显得很麻烦运行 npx webpack --watch但还有点问题，现在弄完还需要游览器再刷新一下，如何自动刷新游览器！ 4，使用webpack-dev-server工具，自动刷新 安4. npm install webpack-dev-server -D配置里面添加 devServer: { static: './dist', //需要热模块更新的文件 }, 自定义webpack配置初始化代码 在本地开发环境里安装，所以加-D
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9014d20fa3cd3d2895aaf27297504f20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e368c2307a9ef0fe5603fabe20ed307a/" rel="bookmark">
			数据分析绘图之plotly
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载安装plotly pip install -i https://pypi.tuna.tsinghua.edu.cn/simple plotly 学plotly这个第三方库呢首先要明白一个是作图，一个是画布，在plotly中图表就是轨迹（trace），画布就是用来展现轨迹的一块布，没有画布的话我们作的图就不能呈现，一个画布可以显示多个轨迹。在用plotly这个库的时候我们可以用两种方式来绘图。
第一种
import plotly.graph_objs as go # 第一种 import plotly.express as px # 第二种 两种都能画图，但是我个人觉得第一种太废代码了， 如果你想要特别好看的图，第一种的方法有很多属性让你去调。 相对来说第二种适合数据分析，因为它可以直接传入DataFrame 作为数据，而且相对也好理解一些。其实第二种就是第一种简化 的接口。 如果小伙伴想学第一种，可以去看看这位博客写的文章
https://blog.csdn.net/chinesehuazhou2/article/details/130312926
接下来就进入plotly的学习吧。
线形图(line) 1.数据导入（我用的jupyter notebook软件）
import pandas as pd import numpy as np import plotly.express as px # 数据集 gapminder = px.data.gapminder() gapminder.head() # 取出数据，默认5条 前5条数据如下
2.绘图
# 线性图 # line 图 fig = px.line( gapminder, # 数据集 x="year", # 横坐标 y="lifeExp", # 纵坐标 color="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e368c2307a9ef0fe5603fabe20ed307a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1370d9da5dfe7076a63e075c5babc37c/" rel="bookmark">
			Python文件操作（txt &#43; xls &#43; json）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介1、使用with_open读取和保存：.txt + .bin（二进制文本）1.1、with open语句详解1.1、项目实战 2、使用pandas读取和保存：.xls + .xlsx2.1、pandas简介2.2、环境配置2.3、项目实战 3、 使用json.dump读取和保存：.json3.1、json格式3.2、项目实战 4、打开对话框（1）打开文件选择对话框（2）打开文件夹选择对话框（3）判断路径 / 文件夹 / 文件是否存在 5、统计时间5.1、计算运行时间5.2、获取当前时间 简介 Python文件操作是处理文件和目录的重要组成部分。文件操作允许您创建、打开、读取、写入、修改和删除文件。这是Python编程中常见的任务之一，对于处理数据、配置文件、日志记录等等非常有用。
使用Python的内置库和第三方库进行文件操作：
（1）TXT文件
（2）Excel文件
（3）JSON文件
1、使用with_open读取和保存：.txt + .bin（二进制文本） 1.1、with open语句详解 函数功能：with open语句是Python中一种处理文件的方式。通过使用with语句，可以确保在退出代码块时文件会被正确关闭，避免资源泄漏。 函数说明：with open(file_path, mode) as file: 输入参数： （1）file_path：要打开的文件路径。 （2）mode：文件模式，指定文件在打开时的操作。可以是以下之一： "r"：	读取模式。用于打开文件并读取内容。 "w"：	写入模式。用于打开文件并写入内容。 备注：如果文件已存在，会清空文件内容。如果文件不存在，则创建一个新文件。 "a"：	追加模式。用于打开文件并在文件末尾追加内容。 备注：如果文件不存在，则创建一个新文件。 "rb"：	以二进制读取模式打开文件。 "wb"：	以二进制写入模式打开文件。 "ab"：	以二进制追加模式打开文件。 1.1、项目实战 with open('file.txt', 'r') as file: content = file.read() # 读取文本文件 # 文件在这里会自动关闭 with open('file.txt', 'w') as file: file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1370d9da5dfe7076a63e075c5babc37c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/098c3ab1e51e8e3544740c672c2062e0/" rel="bookmark">
			位置式PID算法和增量式PID算法的差异
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		位置式PID算法和增量式PID算法的差异 ==============以下内容来自​​​​​​​​​​​​​​位置式PID算法和增量式PID算法的差异-电子发烧友网 (elecfans.com)==============
1、前言 控制系统通常根据有没有反馈会分为开环系统和闭环系统，在闭环系统的控制中，PID算法非常强大，其三个部分分别为；
P：比例环节；I：积分环节；D：微分环节； PID算法可以自动对控制系统进行准确且迅速的校正，因此被广泛地应用于工业控制系统。
2、开环控制 首先来看开环控制系统，如下图所示，隆哥蒙着眼，需要走到虚线旗帜所表示的目标位置，由于缺少反馈（眼睛可以感知当前距离和位置，由于眼睛被蒙上没有反馈，所以这也是一个开环系统），最终隆哥会较大概率偏离预期的目标，可能会运行到途中实线旗帜所表示的位置。
开环系统的整体结构如下所示：
这里做一个不是很恰当的比喻；
Input：告诉隆哥目标距离的直线位置（10米）；Controller：隆哥大脑中计算出到达目标所需要走多少步；Process：双腿作为执行机构，输出了相应的步数，但是最终仍然偏离了目标； 看来没有反馈的存在，很难准确到达目标位置。
3、闭环控制 所以为了准确到达目标位置，这里就需要引入反馈，具体如下图所示：
在这里继续举个不怎么恰当的比喻；隆哥重获光明之后，基本可以看到目标位置了；
第一步Input：告诉隆哥目标距离的直线位置（10米）；第二步Controller：隆哥大脑中计算出到达目标所需要走多少步；第三步Process：双腿作为执行机构，输出了相应的步数，但是最终仍然偏离了目标；第四步Feedback：通过视觉获取到目前已经前进的距离，（比如前进了2米，那么还有8米的偏差）；第五步err：根据偏差重新计算所需要的步数，然后重复上述四个步骤，最终隆哥达到最终的目标位置。 4、PID 4.1 系统架构 虽然在反馈系统下，隆哥最终到达目标位置，但是现在又来了新的任务，就是又快又准地到达目标位置。所以这里隆哥开始采用PID Controller，只要适当调整P，I和D的参数，就可以到达目标位置，具体如下图所示：
隆哥为了最短时间内到达目标位置，进行了不断的尝试，分别出现了以下几种情况；
跑得太快，最终导致冲过了目标位置还得往回跑；跑得太慢，最终导致到达目标位置所用时间太长； 经过不断的尝试，终于找到了最佳的方式，其过程大概如下图所示：
这里依然举一个不是很恰当的比喻；
第一步：得到与目标位置的距离偏差（比如最开始是10米，后面会逐渐变小）；第二步：根据误差，预估需要多少速度，如何估算呢，看下面几步； P 比例则是给定一个速度的大致范围，满足下面这个公式：
因此比例作用相当于某一时刻的偏差（err）与比例系数的乘积，具体如下所示：
比例作用
绿色线为上述例子中从初始位置到目标位置的距离变化； 红色线为上述例子中从初始位置到目标位置的偏差变化，两者为互补的关系； I积分则是误差在一定时间内的和，满足以下公式：
如下图所示：
红色曲线阴影部分面积即为积分作用的结果，其不断累积的误差，最终乘以积分系数就得到了积分部分的输出；
D微分则是误差变化曲线某处的导数，或者说是某一点的斜率，因此这里需要引入微分；
从图中可知，当偏差变化过快，微分环节会输出较大的负数，作为抑制输出继续上升，从而抑制过冲。
综上，分别增加其中一项参数会对系统造成的影响总结如下表所示：
参数上升时间超调量响应时间稳态误差稳定性Kp减少增加小变化减少降级Ki减少增加增加消除降级Kd微小的变化减少减少理论上没有影响小，稳定性会提升 4.2 理论基础 上面扯了这么多，无非是为了初步理解PID在负反馈系统中的调节作用，下面开始推导一下算法实现的具体过程；PID控制器的系统框图如下所示：
因此不难得出输入和输出的关系：
Kp是比例增益；Ki是积分增益；Kd是微分增益； 4.3 离散化 在数字系统中进行PID算法控制，需要对上述算法进行离散化；假设系统采样时间为则将输入序列化得到：
将输出序列化得到：
比例项：离散化积分项：微分项： 所以最终可以得到式①，也就是网上所说的位置式PID：
将式①再做一下简化；
最终得到增量式PID的离散公式如下：
4.4 伪算法 这里简单总结一下增量式PID实现的伪算法：
previous_error:=0//上一次偏差 integral:=0//积分和 //循环 //采样周期为dt loop: //setpoint设定值 //measured_value反馈值 error:=setpoint−measured_value//计算得到偏差 integral:=integral+error×dt//计算得到积分累加和 derivative:=(error−previous_error)/dt//计算得到微分 output:=Kp×error+Ki×integral+Kd×derivative//计算得到PID输出 previous_error:=error//保存当前偏差为下一次采样时所需要的历史偏差 wait(dt)//等待下一次采用 gotoloop 5、C++实现 这里是增量式PID算法的C语言实现；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/098c3ab1e51e8e3544740c672c2062e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86cd377e77f1050b171627cdf52e322c/" rel="bookmark">
			位置式PID与增量式PID区别浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		位置式PID与增量式PID区别浅析 ==========以下内容来自位置式PID与增量式PID区别浅析_增量式和位置式pid的优缺点-CSDN博客==========
No.1 PID控制算法 什么是PID PID 控制器以各种形式使用超过了 1 世纪，广泛应用在机械设备、气动设备 和电子设备.在工业应用中PID及其衍生算法是应用最广泛的算法之一，是当之无愧的万能算法。
PID 实指“比例 proportional”、“积分 integral”、“微分 derivative”，这三项构 成 PID 基本要素。每一项完成不同任务，对系统功能产生不同的影响。它的结构简单，参数易 于调整，是控制系统中经常采用的控制算法。
PID组成 PID：比例单元（P）、积分单元（I）和微分单元（D）组成
PID控制公式
其中：
u(t)为控制器输出的控制量；（输出）
e(t)为偏差信号，它等于给定量与输出量之差；（输入）
KP 为比例系数；（对应参数 P）
TI 为积分时间常数；（对应参数I）
TD 为微分时间常数。(对应参数 D) 数字 PID 控制算法通常分为位置式 PID 控制算法和增量式 PID 控制算法。 No.2 位置式 PID 算法 e(k): 用户设定的值（目标值） - 控制对象的当前的状态值 。
比例P : e(k)
积分I : ∑e(i) 误差的累加
微分D : e(k) - e(k-1) 这次误差-上次误差
也就是位置式PID是当前系统的实际位置，与你想要达到的预期位置的偏差，进行PID控制。
因为有误差积分 ∑e(i) 一直累加，也就是当前的输出u(k)与过去的所有状态都有关系，用到了误差的累加值；（误差e会有误差累加），输出的u(k)对应的是执行机构的实际位置，一旦控制输出出错(控制对象的当前的状态值出现问题 )，u(k)的大幅变化会引起系统的大幅变化。
并且位置式PID在积分项达到饱和时,误差仍然会在积分作用下继续累积，一旦误差开始反向变化，系统需要一定时间从饱和区退出，所以在u(k)达到最大和最小时，要停止积分作用，并且要有积分限幅和输出限幅。
所以在使用位置式PID时，一般我们直接使用PD控制，而位置式 PID 适用于执行机构不带积分部件的对象，如舵机和平衡小车的直立和温控系统的控制。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86cd377e77f1050b171627cdf52e322c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a346b526bf35f5a9c6506aeaeded5af1/" rel="bookmark">
			【加密流量A】Seeing Traffic Paths: Encrypted Traffic Classification With Path Signature Features
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 论文简介摘要存在的问题论文贡献1. 路径签名（Path Signature）2. ETC-PS3. 实验 总结疑问数据集可读的引用文献 论文简介 原文题目：Seeing Traffic Paths: Encrypted Traffic Classification With Path Signature Features
中文题目：查看流量路径:具有路径签名特征的加密流分类
发表期刊：IEEE Transactions on Information Forensics and Security
发表年份：2022
作者：Shi-Jie Xu
latex引用：
@article{xu2022seeing, title={Seeing traffic paths: encrypted traffic classification with path signature features}, author={Xu, Shi-Jie and Geng, Guang-Gang and Jin, Xiao-Bo and Liu, Dong-Jie and Weng, Jian}, journal={IEEE Transactions on Information Forensics and Security}, volume={17}, pages={2166--2181}, year={2022}, publisher={IEEE} } 摘要 虽然已经开发了许多网络流量保护方法来保护用户隐私，但加密流量仍然可以通过复杂的分析泄露敏感的用户信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a346b526bf35f5a9c6506aeaeded5af1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7892f7fd616bbe0a8f39a3250f19c734/" rel="bookmark">
			【已解决】Spring-Data-Redis中boundValueOps()和opsForValue()：boundValueOps()获取成功opsForValue()失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 示例环境搭建：可跳过正文代码1234 结论：源码 示例 环境搭建：可跳过 maven
&lt;!--Redis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--Web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--Test--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; application.properties
server.port=6012 # Redis数据库索引（默认为0） spring.redis.database=2 # Redis服务器地址 spring.redis.host= # Redis服务器连接端口 spring.redis.port=6379 # Redis服务器连接密码（默认为空） spring.redis.password= 测试用例
@SpringBootTest public class SystemApplicationTest { @Resource private RedisTemplate&lt;String, String&gt; redisTemplate; @Test void contextLoads() { redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer()); String cacheValue = redisTemplate.boundValueOps("access_token:login:token:7d792ff4-bf32-49d6-adfc-1a01649ea342").get(); System.out.println(cacheValue); String cacheValue2 = redisTemplate.opsForValue().get("access_token:login:token:7d792ff4-bf32-49d6-adfc-1a01649ea342"); System.out.println(cacheValue2); } } 正文代码 1 redisTemplate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7892f7fd616bbe0a8f39a3250f19c734/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/615b182d591ce5cfd32b6740cc99e33c/" rel="bookmark">
			Java程序员，你掌握了多线程吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：互联网的每一个角落，无论是大型电商平台的秒杀活动，社交平台的实时消息推送，还是在线视频平台的流量洪峰，背后都离不开多线程技术的支持。在数字化转型的过程中，高并发、高性能是衡量系统性能的核心指标，越来越多的公司对从业人员的多线程编程能力提出了更高的要求。
《一本书讲透Java线程：原理与实践》一书深入介绍了Java线程的并发控制实现，在描述其原理的同时，详细解读了它们在真实业务场景下的应用。例如，如何利用synchronized和CAS来解决并发冲突，如何使用Java线程池技术来优化高并发应用的性能，以及如何通过线程安全的容器来保证数据的一致性等，带领你应对日益复杂的互联网挑战。
如果你希望在Java多线程编程领域取得真正的进展，那么这本书将是鲜见的系统性学习资料，值得每一位技术爱好者细细品味。
01 、多线程对于Java的意义 1.提高程序性能： 在计算机技术日新月异的今天，多核处理器已经成为主流。通过使用多线程，我们可以充分利用这种硬件特性，将任务分配给多个线程并行执行。这样不仅可以加快程序的运行速度，而且可以显著提高程序的性能。特别是对于计算密集型任务或者需要处理大量并发请求的服务器程序来说，多线程能够明显提高程序的性能。
2 提高用户体验： 在用户界面应用中，多线程可以使程序变得更加响应式和流畅。例如，在一个图形化界面应用中，将长时间的任务（如网络请求）放在一个单独的线程中执行，可以防止界面的阻塞，使用户能够继续进行其他操作。这样不仅可以提高用户的满意度，而且可以提高应用的用户体验。
3支持并发处理： Java是一种广泛应用于服务器端开发的编程语言，而服务器程序通常需要处理大量的并发请求。使用多线程可以有效地并发处理这些请求，提高系统的吞吐量和响应能力。这样不仅可以提高系统的效率，而且可以提高系统的稳定性。
4 资源共享和同步： 多线程可以实现共享资源，比如共享内存或共享文件。通过合适的同步机制（如锁或信号量），可以确保多个线程对共享资源的访问是安全的，避免数据竞争和一致性问题。这样不仅可以保证数据的一致性和完整性，而且可以提高系统的稳定性。
5 简化编程模型： Java提供了丰富的多线程支持，包括线程创建、启动、停止、休眠、恢复等操作的API。通过使用这些API，开发人员可以更加方便地编写和管理多线程程序，提高开发效率。这样不仅可以提高开发效率，而且可以提高代码的可读性和可维护性。
02、为什么Java工程师必须掌握多线程 Java工程师必须掌握多线程技术，因为多线程是Java中最重要且最强大的部分。随着计算机硬件性能的不断提升，多核CPU成为主流，开发高并发应用已成为越来越重要的需求。无论是对于初学Java的阶段还是深入的学习阶段，多线程的理解都是非常必要的。
在实际应用中，几乎每个生产应用程序都会使用多线程来提升系统的处理效率，只有掌握了多线程的知识才能在实际工作中进行高效开发。此外，良好的多线程知识对于获取Java高级职位也至关重要，它往往是Java高级职位面试的主题。因此学习和理解多线程的核心概念，例如Thread和Runnable等，可以帮助Java工程师提升自身的技术能力和市场价值。多线程技术在Java中的应用非常广泛。
03、Java多线程使用方式 在Java中，有两种主要的多线程实现方式：继承Thread类和实现Runnable接口。继承Thread类可以通过重写run()方法来定义线程的行为，而实现Runnable接口则需要将线程的行为封装在一个Runnable对象中，并将其传递给Thread类的构造函数。除了基本的多线程概念和实现方式外，Java还提供了丰富的多线程工具和类库，如Executor框架、Callable接口、Future接口等。这些工具和类库可以帮助我们更好地管理和控制多线程的执行，提高程序的可扩展性和可靠性。
在实际应用中，我们还需要考虑多线程的同步和互斥问题。当多个线程同时访问共享资源时，可能会出现数据竞争和不一致的情况。为了解决这个问题，我们可以使用synchronized关键字或Lock接口来实现线程之间的同步和互斥。这样可以确保同一时间只有一个线程能够访问共享资源，从而避免潜在的问题。
总之，作为Java工程师，掌握多线程技术是非常重要的。通过学习和理解多线程的核心概念和实现方式，我们可以更好地应对实际开发中的并发需求，提高程序的性能和可靠性。同时，良好的多线程知识也是获取Java高级职位的关键因素之一。因此，我们应该不断学习和实践多线程技术，以提升自身的技术能力和市场竞争力。
04、如何学好Java多线程 一本书讲透Java线程：原理与实践》将打通Java、JVM、Linux的全链路技术栈，剖析Java多线程的实现原理，以便读者厘清现象与本质。同时，本书结合实际业务场景沉淀出多线程编程模型，以便读者快速获得多线程编程能力。
本书中的一些实操例子，开发工程师可直接应用于实际业务场景中；设计原理和深入分析的内容，可帮助架构师拓展解决问题的思路；工具和问题分析的内容，可帮助技术人员诊断线上环境中的系统问题。
本书适合：Java开发工程师、系统架构师、运维工程师、并发编程爱好者以及其他对Java技术感兴趣的人员阅读。
正版购买链接：京东网上商城
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85daa7bc278ffb623067919a5954d04c/" rel="bookmark">
			华为欧拉openEuler在线安装MySQL8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为欧拉openEuler在线安装MySQL8 升级系统 sudo yum -y update 安装依赖和常用工具 sudo yum -y install vim net-tools wget gcc make cmake lrzsz 将 MySQL Yum 存储库添加到系统的存储库列表中 sudo yum -y install https://repo.mysql.com//mysql80-community-release-el8-9.noarch.rpm 通过运行以下命令并检查其输出来验证是否已启用和禁用正确的子存储库 sudo yum repolist enabled | grep mysql 通过以下命令安装 MySQL sudo yum -y install mysql-community-server 启动 MySQL 服务器 使用以下命令启动 MySQL 服务器：
sudo systemctl start mysqld 您可以使用以下命令检查 MySQL 服务器的状态：
sudo systemctl status mysqld 使用以下命令开启自启动 MySQL 服务器：
sudo systemctl enable mysqld 在服务器初始启动时，假设服务器的数据目录为空，会发生以下情况：
服务器已初始化。
SSL 证书和密钥文件在数据目录中生成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85daa7bc278ffb623067919a5954d04c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dbb92deb7b7e8e29dcbf903e79e2b19/" rel="bookmark">
			【JavaScript】JS——Map数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【JavaScript】JS——Map数据类型 什么是Map?特性Map与Object的比较 map的创建map的属性map相关方法map的遍历 什么是Map? 存储键值对的对象。
能够记住键的原始插入顺序任何值（对象或原始值）都可以作为键或值。 特性 Map中的一个键只能出现一次，新的值会覆盖旧的值。
迭代方式：for…of循环，返回一个 [key，value] 的数组。
键的相等：基于零值相等比较
NaN === NaN -0 === +0 Map与Object的比较 Map默认不包含任何键。它只包含显示存入的键值对。object 有原型 let map1 = new Map() let obj1 = new Object() console.log(map1); console.log(obj1); 安全性：Map是一种独立的数据结构，不存在对象原型。而在 Object上设置用户提供的键值对可能会允许攻击者覆盖对象的原型，这可能会引发潜在的安全问题：
原型链污染：攻击者通过提供特定的键值对，污染对象的原型链。例如，攻击者可以通过设置 __proto__ 属性来修改对象的原型，从而修改或劫持对象的原型上的方法和属性。函数劫持：如果用户提供的键值对中的值是一个函数，并且该函数被直接赋值给对象的属性，攻击者可能会通过提供恶意的函数来劫持对象的属性。对象重写：如果用户提供的键值对中的键与对象的原型中的属性冲突，攻击者可能通过提供特定的键值对来覆盖对象的原型属性。访问限制绕过 const victim = {}; const attacker = { evilMethod: () =&gt; console.log('恶意方法被调用') }; victim.__proto__ = attacker; // 调用原型上的恶意方法 victim.evilMethod(); // 恶意方法被调用 键的类型：Map的键可以为任何值（函数、对象或任何原始值），Object 的键必须为 String或 Symbol
键为函数实例：缓存函数调用结果
const cache = new Map(); function createCacheKey(fn, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dbb92deb7b7e8e29dcbf903e79e2b19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a69af5a4b031ea5507326c5ecd99ef6/" rel="bookmark">
			区分Linux桌面环境是Wayland还是X11
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XDG_SESSION_TYPE
echo $XDG_SESSION_TYPE 如果是X11则会直接输出X11
如果是Wayland则会直接输出Wayland
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e2056a37d59cc023fefba567c375d0d/" rel="bookmark">
			Hadoop集群搭建(四)-虚拟机之间免密登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过ssh连接另一台虚拟机时，需要输入密码
查看是否安装OpenSSH客户端
下面开始实现免密登录
一、生成公钥和私钥
执行命令 ssh-keygen -t rsa 然后按三次回车，就会生成两个文件id_rsa（私钥）、id_rsa.pub（公钥）
二、将公钥拷贝到要免密登录的目标机器上
如在hadoop102上执行
ssh-copy-id hadoop102 ssh-copy-id hadoop103 ssh-copy-id hadoop104 在hadoop103、hadoop104中重复上述两步 ，然后验证是否实现免密登录
hadoop102连接hadoop103、hadoop104
hadoop103连接hadoop102、hadoop104
hadoop104连接hadoop102、hadoop103
至此免密登录完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0632e235e4b359f47f259477e9bc71e4/" rel="bookmark">
			【自动流量分析A】New Directions in Automated Traffic Analysis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 论文简介摘要存在的问题论文贡献1. 整体架构2. nPrint3. nPrintML4. 任务 总结论文内容工具数据集可读的引用文献笔记参考文献 论文简介 原文题目：New Directions in Automated Traffic Analysis
中文题目：自动流量分析的新方向
发表会议：CCS '21: 2021 ACM SIGSAC Conference on Computer and Communications Security
发表年份：2021-11-12
作者：Jordan Holland
latex引用：
@inproceedings{holland2021new, title={New directions in automated traffic analysis}, author={Holland, Jordan and Schmitt, Paul and Feamster, Nick and Mittal, Prateek}, booktitle={Proceedings of the 2021 ACM SIGSAC Conference on Computer and Communications Security}, pages={3366--3383}, year={2021} } 摘要 机器学习被用于安全领域的许多网络流量分析任务，从应用识别到入侵检测。然而，最终决定模型性能的机器学习管道的各个方面——特征选择和表示、模型选择和参数调优——仍然是手工和艰苦的。本文提出了一种自动化流量分析许多方面的方法，使机器学习技术更容易应用于更广泛的流量分析任务。
我们介绍了nPrint，一个生成统一的数据包表示的工具，适用于表示学习和模型训练。我们将nPrint与自动机器学习(AutoML)集成在一起，形成了nPrintML，这是一个公共系统，在很大程度上消除了各种流量分析任务的特征提取和模型调优。我们已经在8个独立的流量分析任务上对nPrintML进行了评估，并发布了nPrint和nPrintML，以使未来的工作能够扩展这些方法。
存在的问题 特征工程和模型选择是一个艰苦的过程，通常需要大量的专业领域知识来设计特征即使有专家领域的知识，特征探索和工程在很大程度上仍然是一个脆弱和不完美的过程，因为特征的选择和如何表示它们会极大地影响模型的准确性。这样的人工提取可能会忽略那些不是很明显或涉及复杂关系的特征(例如，特征之间的非线性关系)流量模式和条件总是在变化，模型和手工制作的特征会过时每一个新的网络检测或分类任务都需要重新设计系统：设计新的特征，选择合适的模型，手动调整新的参数 论文贡献 设计了一个标准的数据包表示，nPrint，它以固有的规范化二进制表示对每个数据包进行编码，同时保留每个数据包的底层语义。nPrint使机器学习模型能够自动发现不同分类任务提供的数据包的重要特征集合，无需手动提取。nPrint与AutoML(一个我们称为nPrintML的系统)的集成可以实现自动模型选择和超参数调优，从而可以使用nPrint创建完整的流量分析管道——通常不需要编写代码 论文解决上述问题的方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0632e235e4b359f47f259477e9bc71e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aafe67a90bad8b6dc4a99cb4340d4995/" rel="bookmark">
			Vue配置代理解决跨域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Network的status中报CORS error指在前端（Vue.js）发起跨域请求时，被服务器拒绝访问的错误 在本地开发环境中，Vue.js 将默认从 http://localhost:8080 启动服务器。如果浏览器访问服务器时使用的 URL 不是该地址，就可能触发 CORS 错误。 此时可以通过代理服务器将前端的请求转发到后端服务器。可以使用 http-proxy-middleware 中间件来实现代理。在 devServer 配置中添加以下代码即可
CORS 是一种安全策略，用于防止恶意网站通过跨域请求获取到用户的敏感数据。浏览器会使用 CORS 策略来检查发起的请求是否来自同源（Origin）的地址。如果请求的来源地址与目标地址不是同源，浏览器就会阻止该请求，出现 CORS 错误。
配置代理可以理解为Vue为你开了一台和你端口号相同的服务器，将浏览器和服务器之间的通话转化为服务器与服务器之间进行通话 方式一：配置代理服务器 在vue.config.js文件下配置代理服务器：
devServer: { proxy:'xxx', // 服务器端口 } 以上方法不能配置多个代理，不能灵活地控制是否走代理
方式二：如果使用该写法，就能够配置多个代理服务器，还能灵活控制是否走代理 在vue.config.js文件下配置代理服务器：
module.exports = { devServer: { proxy: { // 配置所有以 '/api1' 开头的请求路径 '/api1': { target: 'http://XXX', // 代理目标的端口路径 changeOrigin: true, // 是否更改配置代理服务器的端口号 pathRewrite: { '^/api1': '' } // 替换请求路径中的字符 } }, // 配置所有以 '/api2' 开头的请求路径 '/api2': { target: 'http://XXX', changeOrigin: true, pathRewrite: { '^/api2': '' } } }, } } 以上代码表示访问 Vue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aafe67a90bad8b6dc4a99cb4340d4995/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0345971562675775b98b9cb5fc1a569c/" rel="bookmark">
			决战排序之巅(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		决战排序之巅 插入排序直接插入排序 void InsertSort(int* arr, int n)希尔排序 void ShellSort(int* arr, int n)测试插入排序测试函数 void verify(int* arr, int n)测试 InsertSort测试 ShellSort测试速度 InsertSort &amp; ShellSort 选择排序直接选择排序 void SelectSort(int* arr,int n)堆排序 void HeapSort(int* arr,int n)堆向下调整 void HeapDown(int* arr, int father,int size)堆排序 void HeapSort(int* arr,int n) 测试选择排序测试 SelectSort测试 HeapSort测试速度 SelectSort &amp; HeapSort 希尔 VS 堆排 （Debug版本）说明1w rand( ) 数据测试10w rand( ) 数据测试10w rand( ) + i 数据测试100w rand( ) 数据测试100w rand( ) + i 数据测试1000w rand( ) 数据测试1000w rand( ) + i 数据测试测试代码如下： 结语 欢迎来到决战排序之巅栏目， 本期我们将带来 插入排序(希尔) 与 选择排序(堆排) 的实现与比较 排序要常用的Swap函数（交换两个数值）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0345971562675775b98b9cb5fc1a569c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35cc88a2f721a6bd8a3ec4c34e5f72ea/" rel="bookmark">
			1000道精心打磨的计算机考研题，408小伙伴不可错过
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：408考研人看过来，超精选计算机考研1000题！
文章目录 前言1. 为什么是1000题？2. 有什么优势？【练学结合，助力强化】【难度适中，但不刁钻】【题目新颖，独具匠心】【考题预测，提前准备】 3. 编写团队水平如何？4. 题目及解析品质如何？可以试读吗？一经上市，热度飙升推荐书单《计算机考研精炼1000题》送书啦！怎么送！ 前言 提示：这里可以添加本文要记录的大概内容：
难度高！
知识点多！
复习时间短！
不要怕，计算机考研1000题来了！
不是数学考研1000题！
也不是政治考研1000题！
而是专属计算机考研小伙伴的超精选1000题！
计算机考研专业课需要大量刷题，终于有了一本高质量的1000题！
这是计算机考研界专业教辅的一次大突破！
命运的齿轮开始转动，源于今年2月，清华大学出版社与抓码计算机考研携手合作，共同策划出版了一本专为计算机考研人打造的高品质书籍。
从书籍定位的策划、题目的设置和难度的把控，到题目及解析的精心打磨和审核，抓码团队与清华大学出版社编辑团队及专业顾问进行了无数次的沟通、修订、反馈……虽然很多考研小伙伴迫不及待地等待着，但要保证书籍的品质，专业素质必须放在第一位。
经过9月和10月的时间，书稿经过了清华大学出版社严格的审校流程。
抓码团队已经记不清勘误和修订的次数了，一次次地打磨、修订，直到通过品质审核。
从2月到11月，抓码专业团队、清华大学编辑团队和专业顾问们，从书籍定位策划到1000道题目的编写和解析……终于！这本精品力作完成了！
抓码计算机考研、清华大学出版社联袂策划的《计算机考研精炼1000题》正式出版！
《计算机考研精炼1000题》揭秘问答
提示：以下是本篇文章正文内容，下面案例可供参考
1. 为什么是1000题？ 考研小伙伴们，你们对1000题一定不陌生吧！数学、政治都有1000题。但是，对于计算机考研专业课来说，要大量刷题，却一直没有一本能够覆盖全部考纲的优质精炼题库。
计算机考研专业课即使有题目，也是厚如大部头，题目陈旧、重复、基础，缺乏适合强化冲刺阶段的、具有难度的优质精炼题目。
因此，在本书的定位策划上，抓码团队综合考虑了408最新考纲以及历年真题中各科目分值的分布情况，精心挑选了约1000道适合强化冲刺阶段的优质题目，其中包括约300道数据结构题目、约230道计算机组成原理题目，以及约170道计算机网络题目。按照章节考点及历年真题的考频合理分配了题量，总计约1000题。
2. 有什么优势？ 【练学结合，助力强化】 结合最新408考纲，按章节精炼梳理重要知识点，帮助强化冲刺的计算机考生迅速回顾复盘考点。
按历年真题考查频次、风格、题型分配精选习题，强化冲刺阶段时间紧、任务重，题目不在多而在精。
紧跟答案详解，刷题不是目的，总结复盘提分才是终极要义。练、学结合，超详细的答案解析、多种解题思路，让你刷一题吃透一题，直至举一反三。
【难度适中，但不刁钻】 1000题包括选择题和大题。
题目不简单，基础没打好，强化没成效，刷不来这些题，1000题有难度。
题目不刁钻，考查的都是经典角度，想拿高分必须掌握，不是冷门考法。
【题目新颖，独具匠心】 计算机考研人到强化冲刺阶段，有一个痛点——想找好题刷，却没得刷。各类计算机考研教辅资料，题目冗余、陈旧，题目多年不变；真题不够刷，更不敢轻易草率刷。
鉴于此，《计算机考研精炼1000题》结合历年真题风格特点，原创70%以上的新编习题，确保题目既符合真题风格又具有新意。
【考题预测，提前准备】 所有教辅，必以提分应试为要义。本书在出题时也以押题为目标，基于历年真题的全方位分析，预测24考研的真题。
3. 编写团队水平如何？ 本书由抓码计算机考研主讲师中科大睿德学长牵头，带领编写团队历时9个月完成。
编写团队成员来自北京大学、中国科学技术大学、东南大学、武汉理工大学、重庆大学、北京工业大学、杭州电子科技大学等知名院校，他们精心编写、勘误、修订，不断打磨考点、题目和解析。
有专业实力，有用心态度，抓码出品，必属精品！
4. 题目及解析品质如何？可以试读吗？ 全书分为上下两册，上册为数据结构、计组，下册为操作系统、计网。
书籍按科目章节铺排，首先梳理复盘该章节重要知识点，再按考点精选题目，包括选择题和大题，最后是超详细的答案解析。
一经上市，热度飙升 想要预定这本书的读者们争相在网络下单预定，来自全国各地的读者们翘首以待。出版社老师也在忙碌地收集信息，为各位读者们加急调货。这本书的受欢迎程度不言而喻，读者们迫不及待地预定，希望尽早获得这本书，为备考冲刺的旅程添砖加瓦！
推荐书单 《计算机考研精炼1000题》 本书根据最新《全国硕士研究生招生考试计算机学科专业基础考试大纲》编写。参考过去十多年的真题，本书精心编排了单项选择题和综合应用题，共约1000道（分为上下两册，共24章。上册（1～13章）为数据结构+计算机组成原理。下册（14～24章）为操作系统+计算机网络），对每道题做了详细的讲解和分析，并对部分知识点进行了串联和扩展。此外，本书还在每章章首对主要知识做了精炼的整理，以方便查看。
本书适合作为报考计算机类学科硕士研究生的复习参考书，尤其适用于报考专业课代码为408的学生在经过一轮复习之后的强化训练。
关注【Python学研大本营】公众号，在后台回复关键词【1000】，即可领取试读PDF，提前感受本书的精彩内容！
【新书上市，半价促销，有效期到12月底】购买链接：https://item.jd.com/13919097.html
送书啦！ 感谢各位读者关注【二哈喇子！】，本次双11特地举办送书活动，这次给大家带来两套《计算机考研精炼1000题》！
怎么送！ 评论区随意留言，我会把所有人的评论收集起来然后抽奖，随机抽两个人送书
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aea8f2c18e8c66b61a7c519bd16c6e2c/" rel="bookmark">
			Name or service not knownstname
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Name or service not knownstname Hadoop 或 Spark 集群启动时 报错 Name or service not knownstname
原因时因为 workers 文件在windows 使用图形化工具打开过
操作系统类型不对引发的
在Linux系统上删除 workers 文件 使用 vim 重新编辑后分发即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1633b1b42de5b0d7120f8cbf4e48cccc/" rel="bookmark">
			微信表情选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gitee仓库代码 #企微开发使用微信发送自定义欢迎语表情选择# 效果图
组件使用 &lt;template&gt; &lt;div id="app"&gt; &lt;emotion :width="500" :content="content" @getChildInfo="getChildInfo"&gt;&lt;/emotion&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import emotion from "./components/emotion/emotion"; export default { name: 'App', components: { emotion }, data(){ return{ content:'' } }, methods:{ //执行方法 getChildInfo(value) { this.content = value }, } } &lt;/script&gt; 封装组件
&lt;template&gt; &lt;div :style="{width: width + 'px' }"&gt; &lt;el-input style="width: 100%;" :rows="10" type="textarea" placeholder="请输入内容" v-model="contentShow" :maxlength="maxText" @blur="handleInputBlur" show-word-limit :disabled="disabled" &gt;&lt;/el-input&gt; &lt;div&gt; &lt;div class="emoji-box"&gt; &lt;div @click="handleEmoji" class="cursor emoji-box"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1633b1b42de5b0d7120f8cbf4e48cccc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98d4ae6c2f4e21d89ffe38801b276708/" rel="bookmark">
			macos安装metal 加速版 pytorch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		categories: [Python]
tags: Python MacOS 写在前面 试试 m3 的 metal 加速效果如何
Mac computers with Apple silicon or AMD GPUsmacOS 12.3 or laterPython 3.7 or laterXcode command-line tools: xcode-select --install 安装 Python: conda-forge brew install miniforge 镜像 channels: - defaults show_channel_urls: true auto_activate_base: false ssl-verify: false default_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 custom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud deepmodeling: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/ 安装 开一个新的虚拟环境, 这个是重点, 如果不开的话, 原有的环境会污染 C 库的链接, 所以这一步是必须的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98d4ae6c2f4e21d89ffe38801b276708/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c62f36eedd76132c58f6e2874004bf7/" rel="bookmark">
			Python网页爬虫爬取豆瓣Top250电影数据——Xpath数据解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python网页爬虫爬取豆瓣Top250电影数据——Xpath数据解析 将使用Python网页爬虫爬取豆瓣电影Top250的电影数据，网页解析方法使用xpath。 获取数据后会将数据保存到CSV文件中。 一、分析网页，初步获取信息 1.1 查看原页面信息 首先打开豆瓣Top250电影页面，其网址是：https://movie.douban.com/top250。
可以发现，该页面展示的电影信息有中英文电影名、导演、主演、上映年份、国籍、电影类型、评分等。
下滑到页面底部，发现第一页有25部电影的数据，并且可以点击页码数实现页面跳转翻页。
第一页的URL：https://movie.douban.com/top250
第二页的URL：https://movie.douban.com/top250?start=25&amp;filter=
第三页的URL：https://movie.douban.com/top250?start=50&amp;filter=
…
第十页的URL：https://movie.douban.com/top250?start=225&amp;filter=
URL中问号？之后的是页面参数，即页面参数有start和filter，第二页start=25，第三页start=50，相差25，而每一页刚好有25部电影。所以可以猜测start是指从第几部电影开始，我们可以令start=0(因为25-0=25)，得到URL：https://movie.douban.com/top250?start=0&amp;filter=，访问该URL，刚好是第一页。所以这些URl就有共同的两个参数start和filter，通过改变参数可以定位到任意一部电影。
由于每次只能获取到25部电影，因此我们可以通过循环，改变start参数的值，每次循环都增加25，即步长为25，依次获取每一页的电影数据。第一页start=0，最后一页start=225。
1.2 查看网页源码和响应数据包 打开网页源码，在‘网络’下查看网页响应数据包，响应数据包中包含有返回的响应数据。所以需要寻找包含响应数据的响应数据包，在top250响应数据包的“响应”中可以看到其包含了我们想要获取的数据。
查看网页响应数据包的“标头”，网页的请求方法为GET方法，响应内容的类型是text/html，编码格式是utf-8。
在响应数据包的“负载”中可以看到参数start和filter。它们俩都是URL中的参数，可以将它们封装到字典中作为GET请求方法的data参数。
二、进行网页爬虫 初步获取信息之后，我们可以对网页发起请求，获取响应，并用xpath解析网页响应数据。
2.1 准备get请求方法的参数 指定URL： url = 'https://movie.douban.com/top250' UA伪装 headers = {'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36 Edg/117.0.2045.41'} 将URL中的参数封装到字典中 # 将URL中的参数封装到字典中 data = { 'start':'0', 'filter':'', } 2.2 发起网页请求，获取响应 通过requests库的get方法对网页发起请求。
# 发起请求，获取网页响应 response = requests.get(url,headers=headers,data=data) print(response.status_code) # 查看响应状态码，200 print(response.encoding) # 查看编码格式 print(response.text) # 查看响应内容 输出的响应内容如下，其类型是txt/html，其中包含我们需要的数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c62f36eedd76132c58f6e2874004bf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e86dd80328915a9ca3e789ed07d778f/" rel="bookmark">
			Linux--文件权限与shell外壳的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.Linux的用户与用户切换，提权
二.对文件权限的理解
1.文件权限=角色的权限+文件属性
2.Linux中的三种角色
3.为什么会存在所属组这个角色
4.文件属性的意义
4.1.第一个字母的意义
4.2 第2——第10个字母的意义
4.3修改文件权限的方法
三.目录权限
四.权限的初始化与权限掩码umask
五.粘滞位
六.shell外壳
一.Linux的用户与用户切换，提权 Linux下由两种用户：超级用户（root）,普通用户
超级用户：可以再 linux 系统下做任何事情，不受限制 普通用户：在 linux 下做有限的事情。 超级用户的命令提示符是 “#” ，普通用户的命令提示符是 “$ 命令：
su [用户名] 功能：切换用户
例如，要从 root 用户切换到普通用户 user ，则使用 su user 。 要从普通用户 user 切换到 root 用户则使用 su root（ root 可以省略），此时系统会提示输入 root 用户的口令 命令： su - 功能：切换到root
su[用户名] 与su -的区别： su [用户名]：是单纯的用户切换，切换后路径不变 su - :让root账号重新登录，切换后到root的家目录 普通用户指令短暂提权至root
sudo 指令 注：使用sudo提权时，需要将当前普通用户添加到etc/sudoer中，sudo可以将后面的指令提权为root，在启动后第一次使用，需要输入当前用户的密码。接下来的几分钟再使用就不用再输密码。
为什么普通用户使用sudo提权，要输入当前用户密码，而非root密码？
我们知道，root用户可以无视一切权限，进行任意的操作。一旦root密码被非管理人员知道就可能造成一些未知的危险，因此为了让某些被信任的用户，可以执行一些需要root权限才可以做的事情，使用输入当前用户密码。同时这样也可以在遭受危险时，对人进行精准定责。
二.对文件权限的理解 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e86dd80328915a9ca3e789ed07d778f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8ab5e9928ecd3ab62f0158ccc923752/" rel="bookmark">
			git add .加错了，要删除掉加到staged（缓冲区）的文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景 写了gitignore，但是漏写了不少东西，结果很多不想加进去的东西也被git add了，此时还没有commit，想把刚刚add的东西去掉，不要让他commit进去
使用 使用 git rm。
一种是 git rm --cached “文件路径”，不删除物理文件，仅将该文件从缓存中删除；
一种是 git rm --f “文件路径”，不仅将该文件从缓存中删除，还会将物理文件删除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa653f9891efc512379d8a06c63bcc0c/" rel="bookmark">
			vscode autoDocstring使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个插件python可以用。
ctrl+shift+2，在光标处生成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8caea6f2b75adf2cf28402465a0bf189/" rel="bookmark">
			Java项目学生管理系统五删除学生
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java学生管理项目中，删除和批量删除学生是两个常见且重要的功能。通过删除学生信息，我们可以及时保持学生列表的准确性和完整性。而批量删除学生则能够提高效率，方便同时删除多个学生的信息。本篇文章将介绍如何在Java学生管理项目中实现删除和批量删除学生的功能，让你能够灵活应用这两个关键的操作。
删除 1 分析 2 后端实现 1）Service 接口
/** * 通过id删除 * @param sid * @return */ Boolean deleteById(Integer sid); 实现类
@Override public Boolean deleteById(Integer sid) { int result = studentMapper.deleteByPrimaryKey(sid); return result == 1; } 2）Controller @Resource private CourseService courseService; @DeleteMapping("/{sid}") public ResponseEntity&lt;String&gt; delete(@PathVariable("sid") Integer sid) { //校验 List&lt;Course&gt; courseList = courseService.selectAllBySid(sid); if(courseList.size() &gt; 0) { return ResponseEntity.ok(sid + "学生关联"+courseList.size()+"门课程，请先解除关联！"); } //删除 Boolean result = studentService.deleteById(sid); if(result) { return ResponseEntity.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8caea6f2b75adf2cf28402465a0bf189/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da70ba47df629aa39f4e05ca3eb2f501/" rel="bookmark">
			项目里面定时器偶然不准的原因以及解决办法：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定时器不准的原因： 代码不对导致的定时器不准那肯定不需要过多解释，比较头疼的是因为”被阻塞的任务：如果在setTimeout之前有其他的代码或任务需要执行，并且这些任务的执行时间较长，可能会导致setTimeout的延迟时间被延迟执行或完全被丢弃“这种问题导致的bug在项目里面比较难以复现，但是当大批量用户使用的时候，就会偶然存在定时器不准的问题
解决办法： 1.worker.js Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。此外，他们可以使用XMLHttpRequest执行 I/O (尽管responseXML和channel属性总是为空)。一旦创建， 一个worker 可以将消息发送到创建它的JavaScript代码, 通过将消息发布到该代码指定的事件处理程序（反之亦然）。
Web Worker 的作用就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程不会被阻塞或拖慢
// index.js let count = 0; //耗时任务 setInterval(function(){ let i = 0; while(i++ &lt; 100000000); }, 0); // worker let worker = new Worker('./worker.js') // worker.js let startTime = new Date().getTime(); let count = 0; setInterval(function(){ count++; console.log(count + ' --- ' + (new Date().getTime() - (startTime + count * 1000))); }, 1000); 这种方案体验整体上来说还是比较好的，既能较大程度修正计时器也不影响主进程任务.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da70ba47df629aa39f4e05ca3eb2f501/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/185d0ea180aa02bf7bb8cd04d0d20ab6/" rel="bookmark">
			PasteBin 一个与 github 不同只提供展示文本、代码最基本功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PasteBin.com 与 github 不同，它不提供代码托管、版本控制等复杂的功能，只提供展示文本、代码最基本功能。
这里介绍的 PasteBin，是第方客户端，完全针对 PasteBin.com你可以在本地进行文本分享。
用过 Droplr 的同学都知道 Droplr 在截图后会自动上传并将获得的地址拷贝到剪贴板中非常更于分享。而 PasteBin 也带有这个功能。
在 PasteBin 的 Paste 文本框内贴好文本、代码，右上角选择类型，比如如截图中的 css，再点击 submit，稍等片刻就会自动上传并获得分享地址，如。
非 PasteBin 注册用户也可以使用，但如果链接丢失就再也找不到了。注册用户可以很好的管理历史记录、再编辑、删除、设置过期时间、私密等等
Pastebin.com - #1 paste tool since 2002!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30eafc6a05904350359b213fdb6e2c64/" rel="bookmark">
			visionOS空间计算实战开发教程Day 9 打造“任意门”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在​​Day 8​​中演示了attachment的实现，本节的知识点是portal。portal相当于哆啦A梦里的任意门，它让我们可以打开另一个世界，这个世界独立于当前的世界，具有单独的光照系统并且由portal几何图形进行遮罩。
要创建portal，首先就需要创建一个世界（​​makeWorld​​），在其中可以添加自己的实体。接着创建portal并将其关联至刚刚创建的世界。
主要的代码如下：
import SwiftUI import RealityKit struct ContentView: View { var body: some View { RealityView { content in let world = makeWorld() let portal = makePortal(world: world) content.add(world) content.add(portal) } } func makeWorld() -&gt; Entity { let world = Entity() world.components[WorldComponent.self] = .init() let environment = try! EnvironmentResource.load(named: "Sunlight") world.components[ImageBasedLightComponent.self] = .init(source: .single(environment), intensityExponent: 12) world.components[ImageBasedLightReceiverComponent.self] = .init(imageBasedLight: world) let earth = try! ModelEntity.load(named: "Earth") earth.position = SIMD3&lt;Float&gt;(x: -0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30eafc6a05904350359b213fdb6e2c64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00c7231a2e2ffe62ab424219fa01bf0a/" rel="bookmark">
			visionOS空间计算实战开发教程Day 8 附属视图和动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本节我们开始初探在visionOS中添加动画效果，我们的入口文件和​​ContentView​​​和​​Day 6​​​中并没有什么区别，所以重点来看​​ViewModel​​​和​​ImmersiveView​​。
首先是​​ViewModel.swift​​文件：
import SwiftUI import RealityKit class ViewModel: ObservableObject { private var contentEntity = Entity() func setupContentEntity() -&gt; Entity { return contentEntity } func getTargetEntity(name: String) -&gt; Entity? { return contentEntity.children.first { $0.name == name } } func addCube(name: String, position: SIMD3&lt;Float&gt;, color: UIColor) -&gt; ModelEntity { let entity = ModelEntity( mesh: .generateBox(size: 0.5, cornerRadius: 0), materials: [SimpleMaterial(color: color, isMetallic: false)], collisionShape: .generateBox(size: SIMD3&lt;Float&gt;(repeating: 0.5)), mass: 0.0 ) entity.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00c7231a2e2ffe62ab424219fa01bf0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfe9ce84bb723cc36678b12f01f252ee/" rel="bookmark">
			Ubuntu 环境下 NFS 服务安装及配置使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：公司内部有多台物理服务器，需要A服务器上的文件让B服务器访问，也就是两台服务器共享文件，当然也可以对A服务器上的文件做权限管理，让B服务器只读或者可读可写
1、NFS 介绍 NFS 是 Network FileSystem 的缩写，顾名思义就是网络文件存储系统，它允许网络中的计算机之间通过 TCP/IP 网络共享资源。通过 NFS，我们本地 NFS 的客户端应用可以透明地读写位于服务端 NFS 服务器上的文件，就像访问本地文件一样方便。简单的理解，NFS 就是可以透过网络，让不同的主机、不同的操作系统可以共享存储的服务。
2、环境、软件准备
两台服务器都是一样的：Ubuntu 20.04.3 LTS
3、NFS 服务安装 因为是A服务提供文件给B服务访问，所以这里就用A服务当做服务器
3.1 首先，在终端使用下列命令安装nfs:
# 服务端 apt install nfs-kernel-server # 客户端 apt install nfs-common 3.2 NFS 配置及使用
我们在服务端创建一个共享目录 /data/share ，作为客户端挂载的远端入口，然后设置权限。
mkdir -p /home/recall/fileshop chmod 666 /home/recall/fileshop 然后，修改 NFS 配置文件 /etc/exports
sudo vim /etc/exports /home/recall/fileshop 192.168.1.11(rw,sync,all_squash,no_subtree_check) 说明一下，这里配置后边有很多参数，每个参数有不同的含义，具体可以参考下边。此处，我配置了将 /data/share 文件目录设置为允许 IP 为该 10.222.77.0/24 区间的客户端挂载，当然，如果客户端 IP 不在该区间也想要挂载的话，可以设置 IP 区间更大或者设置为 * 即允许所有客户端挂载，例如：/home *(ro,sync,insecure,no_root_squash) 设置 /home 目录允许所有客户端只读挂载。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfe9ce84bb723cc36678b12f01f252ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97586b1e5a97e41ae1188cb5d05234dc/" rel="bookmark">
			【持续更新】华为 OD 机试 C卷抽中题库清单（全真题库）含考点说明以及在线OJ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为OD机考:统一考试 C卷 + D卷 + B卷 +A卷 2023年11月份，华为官方已经将 华为OD机考：OD统一考试（A卷 / B卷）切换到 OD统一考试（C卷）和 OD统一考试（D卷） 。根据考友反馈：目前抽到的试卷为B卷或C卷/D卷，其中C卷居多 ，按照之前的经验C卷D卷部分考题会复用A卷/B卷题，博主正积极从考过的同学收集C卷和D卷真题，可以查看下面的真题目录。
真题目录：华为OD机考机试 真题目录（C卷 + D卷 + B卷 + A卷） + 考点说明 专栏：2023华为OD机试( B卷+C卷+D卷)（C++JavaJSPy）
华为OD面试真题精选：华为OD面试真题精选
在线OJ：点击立即刷题，模拟真实机考环境
支持的语言 题解使用C++ Java JavaScript 以及python实现。
华为od机试C卷 - 100分 序号题目链接知识点刷题所属1字符串序列判定/最后一个有效字符https://blog.csdn.net/banxia_frontend/article/details/134300229双指针立即刷题华为OD统一考试（C卷）2山脉的个数https://blog.csdn.net/banxia_frontend/article/details/134322395逻辑题立即刷题华为OD统一考试（C卷）3构成指定长度字符串的个数https://blog.csdn.net/banxia_frontend/article/details/134450378去重排列组合立即刷题华为OD统一考试（C卷）4用连续自然数之和来表达整数https://blog.csdn.net/banxia_frontend/article/details/134430737滑动窗口立即刷题华为OD统一考试（C卷）5全量和已占用字符集https://blog.csdn.net/banxia_frontend/article/details/134430918逻辑题立即刷题华为OD统一考试（C卷）6密码输入检测https://blog.csdn.net/banxia_frontend/article/details/134431388逻辑题立即刷题华为OD统一考试（C卷）7查找众数及中位数https://blog.csdn.net/banxia_frontend/article/details/134451242逻辑题立即刷题华为OD统一考试（C卷）8最长的指定瑕疵度的元音子串https://blog.csdn.net/banxia_frontend/article/details/134451414双指针立即刷题华为OD统一考试（C卷）9整数对最小和https://blog.csdn.net/banxia_frontend/article/details/134451990逻辑题立即刷题华为OD统一考试（C卷）10找出作弊的人https://blog.csdn.net/banxia_frontend/article/details/134451961排序比较立即刷题华为OD统一考试（C卷）11最长子字符串的长度/字符成环找偶数Ohttps://blog.csdn.net/banxia_frontend/article/details/134474609逻辑题立即刷题华为OD统一考试（C卷）12找座位https://blog.csdn.net/banxia_frontend/article/details/134519903逻辑题立即刷题华为OD统一考试（C卷）转盘寿司https://blog.csdn.net/banxia_frontend/article/details/134521254循环数组/栈华为OD统一考试（C卷找朋友https://blog.csdn.net/banxia_frontend/article/details/134521336栈华为OD统一考试（C卷爱吃蟠桃的孙悟空https://blog.csdn.net/banxia_frontend/article/details/134563292二分法华为OD统一考试（C卷游戏分组/英雄联盟https://blog.csdn.net/banxia_frontend/article/details/134564424DFS华为OD统一考试（C卷求满足条件的最长子串的长度https://blog.csdn.net/banxia_frontend/article/details/134564473滑动窗口华为OD统一考试（C卷分割均衡字符串https://blog.csdn.net/banxia_frontend/article/details/134588066贪心华为OD统一考试（C卷机器人仓库搬砖https://blog.csdn.net/banxia_frontend/article/details/134609013二分法华为OD统一考试（C卷出租车计费 、靠谱的车https://blog.csdn.net/banxia_frontend/article/details/134609213数学华为OD统一考试（C卷寻找最富裕的小家庭https://blog.csdn.net/banxia_frontend/article/details/134622503逻辑题华为OD统一考试（C卷开源项目热度榜单https://blog.csdn.net/banxia_frontend/article/details/134632396排序比较华为OD统一考试（C卷考勤信息https://blog.csdn.net/banxia_frontend/article/details/134632714逻辑题华为OD统一考试（C卷寻找身高相近的小朋友https://blog.csdn.net/banxia_frontend/article/details/134633446逻辑题华为OD统一考试（C卷分配土地https://blog.csdn.net/banxia_frontend/article/details/134677846数学华为OD统一考试（C卷剩余银饰的重量https://blog.csdn.net/banxia_frontend/article/details/134678720暴力模拟华为OD统一考试（C卷内存冷热标记https://blog.csdn.net/banxia_frontend/article/details/134699504排序比较华为OD统一考试（C卷字符串摘要https://blog.csdn.net/banxia_frontend/article/details/134699684逻辑题华为OD统一考试（C卷整型数组按个位值排序/最低位排序https://blog.csdn.net/banxia_frontend/article/details/134699788排序比较华为OD统一考试（C卷数组去重和排序https://blog.csdn.net/banxia_frontend/article/details/134699863排序比较华为OD统一考试（C卷学生排名/智能成绩表https://blog.csdn.net/banxia_frontend/article/details/134700891排序比较华为OD统一考试（C卷按身高和体重排队https://blog.csdn.net/banxia_frontend/article/details/134700937排序比较华为OD统一考试（C卷字符串变换最小字符串https://blog.csdn.net/banxia_frontend/article/details/134700976排序比较华为OD统一考试（C卷GPU 调度/执行时长https://blog.csdn.net/banxia_frontend/article/details/134701034逻辑题华为OD统一考试（C卷最大N个数与最小N个数的和https://blog.csdn.net/banxia_frontend/article/details/134701110逻辑题华为OD统一考试（C卷小明找位置https://blog.csdn.net/banxia_frontend/article/details/134722983华为OD统一考试（C卷 华为od机试C卷 - 200分 题目链接知识点刷题1查找接口成功率最优时间段https://blog.csdn.net/banxia_frontend/article/details/134450561前缀和立即刷题华为OD统一考试（C卷2可以组成网络的服务器https://blog.csdn.net/banxia_frontend/article/details/134450587深度优先搜索DFS立即刷题华为OD统一考试（C卷3MELON的难题https://blog.csdn.net/banxia_frontend/article/details/134450608动态规划立即刷题华为OD统一考试（C卷4最长合法表达式https://blog.csdn.net/banxia_frontend/article/details/134472024双指针华为OD统一考试（C卷5数据单元的变量替换https://blog.csdn.net/banxia_frontend/article/details/134472566逻辑题华为OD统一考试（C卷6最多几个直角三角形https://blog.csdn.net/banxia_frontend/article/details/134587216DFS /栈华为OD统一考试（C卷7欢乐的周末https://blog.csdn.net/banxia_frontend/article/details/134588123DFS华为OD统一考试（C卷 华为OD机考B卷C卷华为OD机考华为OD机考B卷华为OD机试B卷华为OD机试C卷华为OD机考C卷华为OD机考D卷题目华为OD机考C卷/D卷答案华为OD机考C卷/D卷解析华为OD机考C卷和D卷真题华为OD机考C卷和D卷题解
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1e56bcfda2f8cc28699a8c693f16240/" rel="bookmark">
			微信小程序通过web-view网页授权获取用户公众号OpenID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序中实现网页授权获取微信公众号OpenID 1.准备工作2.应用场景说明3.实现步骤结语 1.准备工作 第一步:
通过该地址 https://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&amp;t=sandbox/index
获取到微信公众号测试号AppID与appsecret （测试公众号可以测试使用，个人公众号不允许使用。微信认证服务号可以使用，微信认证订阅号不可以使用）。
接口权限查看链接:
https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Explanation_of_interface_privileges.html
测试公众号在生成测试公众号界面中按照提示微信关注即可。非测试不仅需要关注，还需要将微信公众平台中还需要将开发人员给设置一下才可以使用web-view。
同时需要修改一下网页授权接口
因为是测试，就修改成本地IPv4地址加你后端的端口号即可。注意不允许127.0.0.1。
以上是我的。正式环境下需要使用到域名，测试环境可以不需要。
第二步:
还需要弄一个微信小程序的测试号。拿到其中的AppID与appsecrt。注意:小程序的跟微信公众号的AppID不是同一个。
第三步:
我这边后端使用的是WeiXin-JAVA开发包。具体可以通过链接访问
https://github.com/Wechat-Group/WxJava
也可以自己根据自己能力自行实现。
2.应用场景说明 其他应用场景不清楚，根据我个人实际情况(不使用unionID情况下可以使用当前方法)
3.实现步骤 第一步: 下载微信开发工具
第二步: 使用微信小程序的AppId创建一个微信小程序项目，然后官方提供的简单入门Demo，你可以使用也可以不使用。很简单的程序，一下就写好了，可以不用官方的。
第三步: 编写一个按钮，通过点击按钮实现去获取微信公众号OpenID
// index.wxml &lt;button bindtap="getGzhOpenId"&gt;获取公众号OpenId&lt;/button&gt; 一个按钮一个点击事件。
点击事件中代码如下:
// index.js getGzhOpenId(){ wx.navigateTo({ url: '/pages/test/test', }) } 写过小程序的都知道，这就是一个页面跳转。但是这个跳转的不是正常页面，而是一个带有web-view的界面。
// test.wxml &lt;web-view src="{{src}}"&gt; &lt;/web-view&gt; 整个页面就两行代码，这等于是一个中转站，不需要被用户看到。src是可打开关联的公众号的文章，其它网页需登录小程序管理后台配置业务域名。
// test.js onLoad(){ let redirect_url = 'http://测试公众号网页授权的地址/后台接口地址/appid'; this.data.src = 'https://open.weixin.qq.com/connect/oauth2/authorize?appid=测试号AppID&amp;redirect_uri=' + escape(redirect_url) + '&amp;response_type=code&amp;scope=snsapi_base&amp;state=STATE#wechat_redirect'; this.setData({ src: this.data.src }) } 以上是重点。重新梳理一下:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1e56bcfda2f8cc28699a8c693f16240/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10ea50dd63722a67be03b432067df8fa/" rel="bookmark">
			Linux常用命令——as命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在线Linux命令查询工具 as 汇编语言编译器
补充说明 as命令GNU组织推出的一款汇编语言编译器，它支持多种不同类型的处理器。
语法 as(选项)(参数) 选项 -ac：忽略失败条件； -ad：忽略调试指令； -ah：包括高级源； -al：包括装配； -am：包括宏扩展； -an：忽略形式处理； -as：包括符号； =file：设置列出文件的名字； --alternate：以交互宏模式开始； -f：跳过空白和注释预处理； -g：产生调试信息； -J：对于有符号溢出不显示警告信息； -L：在符号表中保留本地符号； -o：指定要生成的目标文件； --statistics：打印汇编所用的最大空间和总时间。 参数 汇编文件：指定要汇编的源文件。
在线Linux命令查询工具 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ff73ac9e82134ff6732213db11dd83b/" rel="bookmark">
			Java读取Excel文件的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Apache POI库：POI是Java编程语言的开源库，可以读写Microsoft Office格式的文档。通过POI库，可以操作Excel文件的workbook、sheet、cell等对象，进行读取和写入操作。
使用JXL库：JXL是Java编程语言的开源库，可以读写Excel文件，同样可以操作Excel文件的workbook、sheet、cell等对象，进行读取和写入操作。
使用EasyExcel库：EasyExcel是一种基于POI封装的Java读写Excel库，提供了更加便捷快捷的API，支持读取和写入Excel文件，并且支持导出大量数据，同时还支持多线程处理。
使用OpenCSV库：OpenCSV是另一种用于读写CSV和Excel文件的开源Java库，它可以读取和写入所有格式的Excel文件，并且可以轻松地将Excel文件转换为Java对象。
使用JavaExcelApi库：JavaExcelApi是一个基于Java编程语言的简单Excel-API，可以读取和写入Excel文件，操作Excel文件的workbook、sheet、cell等对象。 早期使用DBC-ODBC Excel Driver
这种方法是将excel看成是数据库进行操作，使用SQL Select语句即可查询excel表格。优点是：不需要第三方的jar包。但是需要配置ODBC
package xuzhe;
import java.io.*;
import java.sql.*;
//java xuzhe.ExcelJDBC
public class ExcelJDBC {
public static void main(String[] args) throws SQLException{
Connection con = null;
try{
Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");
con = DriverManager.getConnection( "jdbc:odbc:ExcelJDBC" );
Statement st = con.createStatement();
ResultSet rs = st.executeQuery( "Select * from [Sheet1$]" );
ResultSetMetaData rsmd = rs.getMetaData();
int numberOfColumns = rsmd.getColumnCount();
System.out.println ("表格列数"+numberOfColumns );
System.out.println( rsmd.getColumnName(1)+ "," + rsmd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ff73ac9e82134ff6732213db11dd83b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f9b54b2e01b73c8812a7b273389403f/" rel="bookmark">
			绘图 Seaborn 10个示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		绘图 Seaborn 是什么安装使用显示中文及负号散点图箱线图小提琴图堆叠柱状图分面绘图分类散点图热力图成对关系图线图直方图 是什么 Seaborn 是一个Python数据可视化库，它基于Matplotlib。Seaborn提供了高级的绘图接口，可以用来绘制各种统计图形，如线图、热图和分布图等，使得数据的可视化变得更加简单和快速。Seaborn的一些特点包括默认的美观度和自定义主题、多种可视化类型和方便的绘图函数等。Seaborn的使用也可以通过简单的代码完成，因此是一个非常流行的数据可视化工具。
安装 确认你已经安装了 Python 和 pip (Python 的包管理工具)。
如果你没有安装，可以从官网下载安装：https:/https://www.python.org/downloads/
打开终端 (Windows 用户可以使用 PowerShell 或命令提示符)。
在终端中输入以下命令来安装 Seaborn:
pip install seaborn 等待安装完成。
安装完成后，在 Python 中导入 Seaborn：
import seaborn as sns 现在，你已经成功安装了 Seaborn。
使用 显示中文及负号 # 配置中文字体路径，替换成您的字体文件路径 plt.rcParams['font.sans-serif'] = ['SimHei'] # 解决负号显示问题 plt.rcParams['axes.unicode_minus'] = False 散点图 import seaborn as sns import matplotlib.pyplot as plt # 配置中文字体路径，替换成您的字体文件路径 plt.rcParams['font.sans-serif'] = ['SimHei'] # 解决负号显示问题 plt.rcParams['axes.unicode_minus'] = False # 创建一个示例数据集 # 这里使用Seaborn内置的数据集，你也可以使用自己的数据集 tips = sns.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f9b54b2e01b73c8812a7b273389403f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81a2f63b790766fe7559ea13a45f7276/" rel="bookmark">
			页面自适应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于最近在开发一款数据化可视化大屏项目，而这种项目需要适应大屏幕，或者说所有前端页面都应该做到适应不同屏幕尺寸，达到页面可适应的效果。
自适应方案有以下几种（具我初步了解和学习）：
1.通过设置font-size根元素的大小。通过rem单位的转化控制。
2.通过vh，vw单位，或者百分比单位进行自适应。
3.通过flex弹性布局，grid布局进行弹性的布局，达到页面元素可适应。
4.通过监听页面尺寸的大小，通过缩放（scale），对元素进行对应的缩放。
5.通过媒体查询的方式。
6.以上方式配合使用。
不过，这些方法具体使用起来还是比较复杂的。
不过以上的方法各有千秋，也各有优点和缺点。第一点和第二点的话，需要去计算对应的元素的单位，甚至需要进行单位的转化，一个个下来也挺麻烦的。通过flex布局，效果还差点火候。如果通过缩放则放到特别大的时候会失真，不过一般屏幕都不会很大，所以不必太担心，接下来的方法也是基于这个原理进行介绍。媒体查询的话，往往需要写对应的几套css代码，代码量会很多，但是可以在自己的控制范围内，只不过是工作量有亿点大。
废话不多说！我倒是发现了一个比较好且容易的方式，具体参考这位大佬的文章：
可视化大屏：autofit.js 一行搞定自适应 - 掘金 (juejin.cn)
他的文章都很有质量。这里在进行使用之后觉得不错，给予分享和一起学习。
我们使用的autofit.js这个第三方插件
安装方式如下：
npm i autofit.js 因为我使用的是vue3项目，所以需要在app.vue文件中引入，让他全局生效。
&lt;script setup&gt; import { ref, onMounted, onUnmounted } from 'vue'; import autofit from 'autofit.js' onMounted(()=&gt; { autofit.init({ designHeight: 1080, designWidth: 1920, renderDom: "#app", resize: true }) }) &lt;/script&gt; &lt;template&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/template&gt; &lt;style scoped&gt; body { box-sizing: border-box; padding: 0; margin: 0 !important; } &lt;/style&gt; designHeight：是设计稿的高度
designWidth：是设计稿的宽度
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81a2f63b790766fe7559ea13a45f7276/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6d853ca59e1a30c5802bbafc990aada/" rel="bookmark">
			mysql的备份和恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 的备份和恢复可以通过多种方式实现，以下是其中一些常见的方法：
备份：
使用 mysqldump 命令：mysqldump 是一个用于备份 MySQL 数据库的命令行工具。你可以通过在终端中运行该命令来备份指定的数据库或表。例如，要备份整个数据库，可以运行以下命令：mysqldump -u 用户名 -p 数据库名 &gt; 备份文件.sql其中，-u 参数指定 MySQL 用户名，-p 参数用于提示输入密码，数据库名是要备份的数据库名称，备份文件.sql 是保存备份数据的文件名。
使用 MySQL Workbench：MySQL Workbench 是 MySQL 的官方图形化工具，可用于管理和备份数据库。在 Workbench 中，你可以右键点击要备份的数据库或表，并选择 "导出数据" 或 "导出结构" 来备份数据或表结构。
使用第三方工具：除了官方提供的工具外，还有一些第三方工具可用于 MySQL 的备份和恢复，如 Navicat、MySQL Dumper 等。这些工具通常提供更丰富的功能和更友好的界面，可以根据个人需求选择使用。
恢复：
使用 mysql 命令：mysql 是一个用于管理 MySQL 数据库的命令行工具。你可以通过在终端中运行该命令来恢复备份的数据库。例如，要恢复名为 backup.sql 的备份文件中的数据库，可以运行以下命令：mysql -u 用户名 -p 数据库名 &lt; 备份文件.sql其中，-u 参数指定 MySQL 用户名，-p 参数用于提示输入密码，数据库名是要恢复的数据库名称，备份文件.sql 是包含备份数据的文件名。
使用 MySQL Workbench：在 MySQL Workbench 中，你可以通过导入功能来恢复备份的数据或表结构。右键点击目标数据库或表，并选择 "导入数据" 或 "导入结构"，然后选择包含备份数据的文件进行恢复。
使用第三方工具：与备份工具类似，你也可以使用第三方工具来恢复 MySQL 数据库。这些工具通常提供更方便的操作界面和更高效的恢复功能，可以根据个人需求选择使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6d853ca59e1a30c5802bbafc990aada/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47839dd07cacf5279b278906c79281ec/" rel="bookmark">
			C&#43;&#43; 中的运算符重载（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重载加法运算符+和减法运算符-，用于实现对象的加法和减法。加法运算符+和减法运算符-是两种常用的运算符，它们可以对两个操作数进行加法和减法运算，返回一个运算结果。但是，如果我们想要对自定义类型的数据进行加法和减法运算，例如类的对象，那么我们就需要重载加法运算符+和减法运算符-，以便实现对象的加法和减法，即将两个对象的对应成员变量进行加法或减法运算，返回一个新的对象。这样，我们就可以实现对象的组合和分解，提高代码的灵活性和可扩展性。例如，我们可以定义一个Vector 类来表示二维平面上的向量，然后重载加法运算符+和减法运算符-，用于实现向量的加法和减法。代码如下：
// 定义Vector 类 class Vector { public: // 构造函数，用于初始化向量对象 Vector(double x = 0, double y = 0) { this-&gt;x = x; this-&gt;y = y; } // 重载加法运算符，用于实现向量的加法 Vector operator+(const Vector&amp; v) { // 返回一个新的向量对象，其横坐标和纵坐标分别为两个向量的横坐标和纵坐标之和 return Vector(this-&gt;x + v.x, this-&gt;y + v.y); } // 重载减法运算符，用于实现向量的减法 Vector operator-(const Vector&amp; v) { // 返回一个新的向量对象，其横坐标和纵坐标分别为两个向量的横坐标和纵坐标之差 return Vector(this-&gt;x - v.x, this-&gt;y - v.y); } // 声明友元函数，用于输出向量对象 friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Vector&amp; v); private: // 私有成员变量，用于存储向量的横坐标和纵坐标 double x; double y; }; // 定义友元函数，用于输出向量对象 std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Vector&amp; v) { // 输出向量的横坐标和纵坐标，用尖括号和逗号分隔 out &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47839dd07cacf5279b278906c79281ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ca750e415bb1b4389c75778d609aabd/" rel="bookmark">
			代码生成的原理解析：从Codex、GitHub Copliot到CodeLlama、CodeGeex
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文精讲代码生成的发展史与其背后的技术原理，总计4个部分
第一部分 GitHub copilot的起源：Codex第二部分 微软GitHub copilot第三部分 Code Llama第四部分 CodeGeex 第一部分 GitHub copilot的起源：Codex 我们在这篇文章《ChatGPT技术原理解析：从RL之PPO算法、RLHF到GPT4、instructGPT》中的2.5节有提到，“2021 年7月，OpenAI发布Codex的论文《Evaluating Large Language Models Trained on Code》，其中初始的Codex是根据120亿参数的GPT-3变体进行微调的，且通过对159GB的Python代码进行代码训练，后来这个120 亿参数的模型演变成OpenAI API中的code-cushman-001，具备较强的代码/推理能力”
接下来，我们来看下Codex背后的原理到底是怎样的，即其是如何一步一步训练出来的
1.1 Codex效果的评估 1.1.1 HumanEval：评估Codex的数据集 为了准确地对Codex进行基准测试，OpenAI创建了一个包含164个原始编程问题的数据集，并进行了单元测试
这些问题评估语言理解、算法和简单的数学，这个评估框架即指的是HumanEval这164个编程问题全部是手写的，非网上公开的。每个问题包括一个函数签名、文档、函数的实现和几个单元测试，平均每个问题7.7个测试。
We evaluate functional correctness on a set of 164 handwritten programming problems, which we call the HumanEval dataset. Each problem includes a function signature,docstring, body, and several unit tests, with an average of 7.7 tests per problem. 对于这些任务来说，手写是很重要的，因为Codex模型是通过GitHub上的代码训练的，而如果测试的问题是网上公开的，那很可能从GitHub上获取的训练数据集可能已经包含了对应的测试问题及其答案(毕竟本来是要评估模型的回答能力，结果模型直接看到答案了，就没法准确评估了)
It is important for these tasks to be hand-written, since our models are trained on a large fraction of GitHub, which already contains solutions to problems from a variety of sources.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ca750e415bb1b4389c75778d609aabd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b17cce8bd4f5527ba9a2cc977d280eb/" rel="bookmark">
			React 中 5 个好用的 Hook
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. useTimeout 使用这个hooks，我们可以使用声明式方法来实现setTimeout。首先，我们创建一个自定义hooks子，其中包含回调函数和延迟参数。然后，我们使用useRef hooks为回调函数创建一个引用。最后，我们两次使用useEffect，一次用于记住上次的回调函数，一次用于设置超时并清理。
以下是一个计时器的实现示例：
import {useEffect} from 'react' const useTimeout = (callback,delay)=&gt;{ const savedCallback=React.useRef(); useEffect(()=&gt;{ savedCallback.current=callback },[callback]); useEffect(()=&gt;{ const tick=()=&gt;{ savedCallback.current(); } if(delay!==null){ let id=setTimeout(tick,delay); return ()=&gt;clearTimeout(id); } },[delay]) } 2. useInterval 如果你想以声明性的方式实现setInterval，你可以使用名为useInterval的hooks。
首先，我们需要创建一个自定义hooks，接受一个回调函数和一个延迟时间作为参数。然后，我们使用useRef为回调函数创建一个ref。最后，我们使用useEffect来记住最新的回调函数，并设置和清除间隔。
该示例展示了自定义ResourceCounter的实现。
import {useRef,useEffect} from 'react'; const useInterval = (callback,delay)=&gt;{ const savedCallback=React.useRef(); useEffect(()=&gt;{ savedCallback.current=callback },[callback]); useEffect(()=&gt;{ const tick=()=&gt;{ savedCallback.current(); } if(delay!==null){ let id=setInterval(tick,delay); return ()=&gt;clearInterval(id); } },[delay]) } 3. usePrevious 这是另一个可以在我们的应用程序中使用的很棒的自定义钩子。通过它，我们可以存储props或先前的状态。首先，我们创建一个接受值的自定义钩子。然后，我们使用useRef钩子为该值创建一个ref。最后，我们使用useEffect来记住最新的值。这个示例展示了一个计数器的实现。
import {useRef,useEffect} from 'react'; const usePrevious=value=&gt;{ const ref=useRef(); useEffect(()=&gt;{ ref.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b17cce8bd4f5527ba9a2cc977d280eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98227bab0bf7a62bb624f60dcbcb0a41/" rel="bookmark">
			Oracle 11g&#43;PLSQL Developer安装及环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 安装包 数据库服务管理平台：OracleXE112_Win64.zip 第三方客户端：plsql 11.0.4 安装包+语言包+注册机.rar 链接: https://pan.baidu.com/s/1AKTrd6Qu9-qk59N_G6AVWg 提取码: dich
2. Oracle安装 ❑ 安装前注意事项：
以管理员身份登录（即管理员身份运行）关闭杀毒软件检查计算机名称以及当前操作系统管理员名称是否包含中文字符以及特殊符号如果服务器上有运行其他Oracle服务，必须全部停止（之前没安装过oracle这个可忽略） ❑ 步骤：
setup.exe 右键以管理员身份运行按照提示点击next安装即可，只需要输入口令，随便都行但要记住口令（我写的是 xe） ❑ 验证是否安装成功：
在开始菜单那可以看到 运行SQL命令行 ，点击运行
连接：connect sys/xe as sysdba 或者更简单点 conn / as sysdba （xe即口令，根据自己之前填的口令做更改）断开连接：disconnect 或 disc 出现以下界面即说明安装成功
3. PLSQL安装 文件夹中第1个是汉化包，第2个是注册机，第3个是安装包
❑ 步骤：
plsqldev1104x64b1.exe 右键以管理员身份运行同样按提示点击next安装，可不用做其他修改，其中路径可按自己的需求更改，也可直接按默认接着直接点击运行chinese.exe，按确定即可汉化 然后点击桌面的PLSQL Developer，出现登录界面，点取消 找到帮助→注册... ；运行上面文件夹中的keygen.exe；再对应填入就可以了，如图所示 注册成功后出现以下界面： 关闭程序 4. 环境配置 ❑ Step1. 打开 系统→环境变量→高级系统设置→环境变量（win10打开路径） 在 系统变量 新建
第一：
&gt;&gt;变量名 ORACLE_HOME
&gt;&gt;变量值 C:\oraclexe\app\oracle\product\11.2.0\server
第二：
&gt;&gt;变量名 TNS_ADMIN
&gt;&gt;变量值 C:\oraclexe\app\oracle\product\11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98227bab0bf7a62bb624f60dcbcb0a41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2f4238020c67e4174ddce9fafbb94b8/" rel="bookmark">
			Sourcepawn脚本入门(二)命令与事件监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍎Sourcepawn脚本入门(二)命令与事件监听 （控制台）命令是常用的插件形式，eg. noclip …等都是常用的命令，在游戏中使用也很容易,souremod可以注册自己的命令。
事件的监听则需要考虑到不同的起源游戏支持的事件不同，具体可以参考如下：Game Events (Source) - AlliedModders Wiki (alliedmods.net)
1.注册控制台命令 使用RegConsoleCmd注册控制台命令
#include &lt;sdkhooks&gt; #include &lt;sdktools&gt; #include &lt;sourcemod&gt; #pragma newdecls required #pragma semicolon 1 public Plugin myinfo = { name = "pluginOne", author = "", description = "", version = "1.0.0", url = "https://github.com//pluginOne" }; public void OnPluginStart() { PrintToChatAll("这是第一个测试"); //注册控制台命令 RegConsoleCmd("sm_sayhellow",SayHellowToAll,"这是一个测试测试的控制台命令"); } //命令第二个参数为CallBack函数，参数固定为两个int变量（名字随便起） //但分别代表客服端id和该命令参数的个数 public Action SayHellowToAll(int client,int args) { //向所有人发送信息 PrintToChatAll("WDNMD"); //Plugin_Handled是Action的返回值，代表执行的结果 //如果执行成功则为Plugin_Handled,失败则可以为Plugin_Error等 //当然也可以不返回，但不利于调试 return Plugin_Handled; } 编译部署到服务器的执行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2f4238020c67e4174ddce9fafbb94b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c980c0d5e1f11a69432adf574238bedc/" rel="bookmark">
			解决npm install时报：gyp ERR! configure error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错内容：
npm ERR! gyp ERR! cwd C:\Users\zccbbg\code\my\examvue\node_modules\node-sass
npm ERR! gyp ERR! node -v v16.13.1
npm ERR! gyp ERR! node-gyp -v v3.8.0
npm ERR! gyp ERR! not ok
npm ERR! Build failed with error code: 1
解决办法：
降npm版本，之前用的是：16.13.1，现在改成：12.14.0。就好了
ps：
建议装个nvm，相当好用
nvm list nvm use 12.14.0 再跑npm install 就不报错了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29c09046cea59b9cc30d490250e39105/" rel="bookmark">
			Linux基础命令5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		独立Web主机，Web通信基于B/S（Browser/Server）架构的网页服务，服务端提供网页，浏览器下载并迅速网页。 HTML：超文本标记语言，HTTP：超文本传输协议 装httpd包，网页根目录/var/www/html 创建网页，并重新启动服务 在pc2主机查看网页（需要先卸载防火墙firewalld） httpd主配置文件/etc/httpd/conf/httpd.conf 默认配置： Listen：监听地址，端口（80） ServerName：本站点注册的DNS名称（空缺） DocumentRoot：网站根目录（/var/www/html），指定存放网页文件的路径 DirectoryIndex：起始页、首页文件名（index.html） 更改网页文件根目录（如果有两个DocumentRoot下面的会覆盖上面的文件） 重启服务 创建页面 pc2主机查看网页 修改目录访问控制规则，默认不放行/根目录，放行/var/www/目录 创建网页文件目录 添加放行目录，让修改的网页文件目录被允许放行 创建网页文件，重启服务 pc2主机查看网页 访问出现测试页面的原因：1、没有网页文件。2、网页文件名称不是index.html。3、httpd的访问控制规则拒绝了。 当curl 192.168.88.240是就直接访问到网页文件根目录（/var/www/）里面，如果在创建一个目录需要在该主机IP地址后面加上该目录（/var/www/abc/） 例如使用/webroot做网页文件根目录，在创建一个新目录 pc2主机查看创建的新目录的网页 调用配置文件/etc/httpd/conf.d/以.conf为结尾，在读取完主配置文件后，就会读取调用配置文件中以.conf为结尾的文件（最后操作，会覆盖前面的操作），方便操作，只需要在调用配置文件写，不需要编辑主配置文件 创建网页文件根目录，创建网页，重启服务 pc2主机查看网页 可以修改首页文件的名称 Listen：检讨IP地址：监听端口号（80） 端口：数字编号起到标识作用， 标识协议或进程，http协议默认端口：80。自定义端口要大于1024，小于65535. pc2查看网页 虚拟Web主机：由统一台服务器，提供多个不同的web站点 基于域名的虚拟主机 基于端口的虚拟主机 基于IP地址的只能主机（需要添加网卡，配置IP地址，太繁琐） 为每个虚拟站点添加配置 &lt;VirtualHost IP地址：端口&gt; ServerName 此站点的DNS名称 DocumentRoot 此站点的网页根目录 &lt;/VirtualHost&gt; 1、创建基于域名的虚拟主机，在所有IP地址上监听80端口 创建网页文件根目录和首页，重启服务 2、/etc/hosts：只为本机提供解析域名文件 此时只能在本机上访问网页 3、如果使用pc2主机访问需要把pc2主机上的/etc/hosts文件添加web服务器的域名 此时就能访问服务器的web 当访问IP地址的时候会显示第一个虚拟主机的网页 一旦使用虚拟Web主机功能，所有的网站都必须使用虚拟Web方式进行呈现。 1、创建基于端口的虚拟主机 重启服务 2、pc2主机访问端口 NFS服务：Network File System网络文件系统 为客户机提供共享使用的文件夹（让其他主机上的共享目录挂载到本主机上） 安装软件包nfs-utils（默认安装） 创建共享目录并创建几个文件 /etc/exports：共享文件的配置文件 重启服务 在pc2主机上查看服务器NFS共享资源 showmount - e命令：查看该服务器有哪些NFS共享资源 手动挂载NFS共享目录：mount 服务器地址：文件夹路径 挂载点 此时服务器添加文件，其余主机挂载点也会出现该文件（数据同步） 因为服务器共享目录设置了ro只读模式，所以该挂载点是不能创建、修改和删除文件的 设置开机自动挂载，服务端要保持正常允许（开机），否则开机的时候找不到该文件 触发挂载：由autofs服务提供“按需访问”机制，只要访问挂载点，就会触发响应，自动挂载指定设备，闲置超过时限后（默认5分钟），会自动卸载 装包autofs 重启服务 /misc：监控目录 查看触发挂载的初始化挂载的光盘设备目录 /etc/auto.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29c09046cea59b9cc30d490250e39105/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7181bdc364b329dc302b4fda0e3287a/" rel="bookmark">
			微软 Copilot 重磅更新，免费进入GPT-4 Turbo 与 DALL-E 3 时刻！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Microsoft Copilot 正在加速创新。
原文链接：https://blogs.bing.com/search-quality-insights/december-2023/Continued-AI-Innovation-in-Copilot
编译 | 梦依丹 出品 | AI科技大本营（rgznai100）
微软在庆祝 Microsoft Copilot 发布一周年的文中称，今年是人工智能走进人们日常生活中的一年。以必应聊天（Bing Chat）为例，它改变了人们在互联网上搜索、购物、编码、准备求职面试、提高游戏技能、创建漂亮的文档和图像的方式。
庆祝之余，微软还官宣了 Copilot 一些重磅功能，其中包括：
GPT-4 Turbo：不久后，Copilot 将能够使用 OpenAI 最新的模型 GPT-4 Turbo 生成回复，这意味着用户可以处理更复杂、更长的任务，例如编写代码等。目前，该模型正在与一些用户进行测试，并将在未来几周内广泛应用到 Copilot 中。
全新的 DALL-E 3 模型：大家现在可以通过 Copilot 创建更高质量、更符合提示的图像，使用的是更新后的 DALL-E 3 模型。大家可以访问 bing.com/create 或命令 Copilot 创建图像来体验这些新功能。
微软还在贴出了新模型生成效果对比图：一个逼真的剑龙在美甲沙龙接受护理其骨质板块。
多模态与 Bing 深度搜索： 微软正在将 GPT-4 的强大能力与 Bing 图像搜索和网页搜索数据相结合，以更好地理解您的查询并提供更准确的图像结果。这项新功能即将上线。
通过这项功能，您可以更轻松地找到您想要的图像，并且对于您的查询，系统能够提供更全面、更准确的理解和回答。我们对这一功能的升级改进感到非常兴奋。
结果非常令人惊叹，就像大家在下面的示例中所看到的那样。传统的多模态系统只能以一种笼统的方式描述图像内容，但是通过搜索关联，结果能够准确辨别出照片中的航天飞机以及它的发射日期。这意味着可以给大家提供更具体、更精准的信息。
代码解释器：正在开发一个新功能，让大家能够执行更复杂的任务，比如更精确的计算、编程、数据分析、可视化、数学等等。目前微软团队正在从一些用户那里收集对这些功能的反馈，并计划快速推出。
Copilot 将根据复杂的自然语言请求编写代码，并在受限的环境中运行该代码，然后利用结果给你提供更高质量的回答。大家还可以与 Copilot 上传和下载文件，这样就可以使用自己的数据和代码，还可以利用 Bing 搜索结果进行工作。
Copilot 强大的 Python 环境在安全隔离的环境中运行，基于 Azure Container Apps 构建。它提供了快速且用户独立的环境，预装了许多广受欢迎的数据科学工具和库，如 pandas、numpy、matplotlib、sklearn、flask 等，用于解决复杂问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7181bdc364b329dc302b4fda0e3287a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ef810e204ec43f42b9d4b1976124613/" rel="bookmark">
			nuScenes的使用（一）——简介和下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、简介一个小提醒 二、数据集下载及排布方式1.数据集下载（1）NuScenesFull dataset (v1.0)A. 下载B. 排布 Map expansionCAN bus expansionnuScenes-lidarsegnuScenes-panoptic （2）nuImages（3）数据集完整性检查 三、各个挑战赛道和SOTA查看 一、简介 我第一个接触的数据集，不用挂梯子也可以直接上，国内用亚洲线下载数据集也非常快（科学上网下kitti真的是一种折磨）。nuscenes里面包含了RGB图片、激光雷达点云和毫米波雷达的数据，具体介绍的话可以看官网：nuScenes官网。
一个小提醒 特别注意：使用想要读取数据请一定按照官网对应的Tutorials里给的方式操作，即用token访问对应的传感器数据，不要直接读json里的，否则无法读到你想要的！！
tutorial有两种获取方式：
第一种是来自官网对应界面：
另一种是见nuscenes-devkit/python-sdk/tutorials/下的.ipynb文件。开发者工具包的Github有，可直接找。 二、数据集下载及排布方式 1.数据集下载 先放一个下载链接：nuscenes下载。要先登录才能下载，没有账号直接注册。
nuscenes官网一共放出了很多数据集，有：
（1）NuScenes 组合拳，传感器含6 个摄像头、1 个激光雷达、5 个雷达、GPS、IMU，里面有RGB图，radar/LiDAR点云图，标注（3D），map等等。数据集用数据库的方式管理，靠token查询对应数据，具体依赖关系看官网给的图：
想要得到对应数据最快的办法就是用nuscenes-devkit，在调用API的时候对应这张图用有奇效。
Full dataset (v1.0) 完整的数据集，看命名似乎以后还会继续更新的样子。
A. 下载 该数据集包含：
Mini：缩减过的数据集，里面只有10个scenes，不可分传感器下载。Trainval：完整的数据集，被分成了10份，一共有850个scenes（700个训练的，100个检验的）。总共差不多有300多GB的样子，可分传感器下载 Test：150个scene的无标注样本，可分传感器下载
注意：Trainval 和 Test 要单独下载metadata，Mini 不用（已经包含在压缩包内） 具体每一个里包含哪几个scenes，参见nuscenes-devkit/python-sdk/nuscenes/utils/splits.py或根据tutorial调用工具包输出查看
B. 排布 解压到/data/sets/nuscenes，对于多个part的注意不要将原本的覆盖。解压后的文件结构（来自nuscenes-devkit）：
/data/sets/nuscenes samples	-	Sensor data for keyframes. sweeps	-	Sensor data for intermediate frames. maps	-	Folder for all map files: rasterized .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ef810e204ec43f42b9d4b1976124613/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beccf4240efb58182eb51bf271177d4a/" rel="bookmark">
			Android studio 工程的 module 依赖关系图绘制 、 Android Module 依赖关系的可视化实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整体步骤：
1、利用gradle脚本生成dot；
2、利用graphviz将dot可视化转为图片
利用gradle脚本生成dot 下载projectDependencyGraph.gradle脚本 下载 projectDependencyGraph.gradle ，放在项目根目录，
源码如下：
task projectDependencyGraph { doLast { def dot = new File(rootProject.buildDir, 'reports/dependency-graph/project.dot') dot.parentFile.mkdirs() dot.delete() dot &lt;&lt; 'digraph {\n' dot &lt;&lt; " graph [label=\"${rootProject.name}\\n \",labelloc=t,fontsize=30,ranksep=1.4];\n" dot &lt;&lt; ' node [style=filled, fillcolor="#bbbbbb"];\n' dot &lt;&lt; ' rankdir=TB;\n' def rootProjects = [] def queue = [rootProject] while (!queue.isEmpty()) { def project = queue.remove(0) rootProjects.add(project) queue.addAll(project.childProjects.values()) } def projects = new LinkedHashSet&lt;Project&gt;() def dependencies = new LinkedHashMap&lt;Tuple2&lt;Project, Project&gt;, List&lt;String&gt;&gt;() def multiplatformProjects = [] def jsProjects = [] def androidProjects = [] def javaProjects = [] queue = [rootProject] while (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/beccf4240efb58182eb51bf271177d4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4920c738dd64f0177976b0b99ec060b6/" rel="bookmark">
			CSS总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS 什么是CSS 中文名字：层叠样式表
CSS格式 选择器
{
属性：属性值；
}
选择器 基础选择器 标签选择器 标签名 { 属性：属性值; } 类名选择器 .类名（class的属性值） { 属性：属性值; } id选择器 #id名(id的属性值) { 属性:属性值; } 通用选择器–&gt;一般用于清除浏览器默认样式 *{ 属性:属性值; } 组合 div,p{}后代 ul li{}
*交叉 div .one{} 伪类选择器 :hover:focus， 伪元素选择器 ::before::after::first-letter::first-line 属性选择器 [attrname]—拥有属性 例：[data-name]{}[attrname=value]—属性等于值 例：[data-name=uek]{ color: red;}[attrname^=value]—开始等于值 例：[data-name^=uek]{color: blue;}–开头为uek字符的都变成蓝色[attrname = v a l u e ] − − − 结束等于值例： [ d a t a − n a m e =value]---结束等于值 例：[data-name =value]−−−结束等于值例：[data−name=uek]{color: green;}–结尾为uek字符的都变成绿色[attrname*=value]—包含值 例：[data-name*=uek]{ color:purple}–所有包含uek字符的都变成紫色[attr1][attr2][attr3]… —交叉 例： p[data-name]{ color:pink;} &lt;p data-name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4920c738dd64f0177976b0b99ec060b6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/47/">«</a>
	<span class="pagination__item pagination__item--current">48/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/49/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>