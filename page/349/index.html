<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec4eee807c80470b50f2b7c92780c835/" rel="bookmark">
			山石岩读丨前沿领域探析——汽车CAN总线协议详解及攻击面分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 、CAN总线的基本概念以及由来 CAN（Controller Area Network）总线协议是由 BOSCH 发明的一种基于消息广播模式的串行通信总线，它起初用于实现汽车内ECU之间可靠的通信，后因其简单实用可靠等特点，而广泛应用于工业自动化、船舶、医疗等其它领域。
要了解CAN总线协议，我们首先知道的一个概念是汽车ECU是指的什么？ECU（Electronic Control Unit）电子控制器单元，又称为汽车的“行车电脑”，它们的用途就是控制汽车的行驶状态以及实现其各种功能。主要是利用各种传感器、总线的数据采集与交换，来判断车辆状态以及司机的意图并通过执行器来操控汽车。
简而言之CAN总线是用于各个ECU之间互相通信的网络以及协议。
发展历史
1983年，BOSCH开始着手开发CAN总线；
1986年，在SAE会议上，CAN总线正式发布；
1987年，Intel和Philips推出第一款CAN控制器芯片；
1991年，奔驰 500E 是世界上第一款基于CAN总线系统的量产车型；
1991年，Bosch发布CAN 2.0标准，分 CAN 2.0A （11位标识符）和 CAN 2.0B （29位标识符）；
1993年，ISO发布CAN总线标准（ISO 11898），随后该标准主要有三部分：
ISO 11898-1：数据链路层协议
ISO 11898-2：高速CAN总线物理层协议
ISO 11898-3：低速CAN总线物理层协议
2、 CAN总线协议详解 2.1 CAN协议标准 CAN总线协议大的分类包含底层的标准协议和上层协议两种；其中以ISO 11898-1；ISO 11898-2和ISO11898-3这三种协议为主，下面介绍这三种协议的主要作用和应用方向。
ISO 11898-1: 2015 定义CAN总线的数据链路层（DLL）和电气信号标准，描述CAN总线的基本架构，定义不同CAN总线设备在数据链路层通信方式，详细说明逻辑链接控制（LLC）和介质访问控制（MAC）子层部分；
ISO 11898-2: 2003 定义高速CAN总线（HS-CAN）物理层标准，最高数据传输速率 1Mbps ，应用为两线平衡式信号（CAN_H, CAN_L），HS CAN是汽车动力和工业控制网络中应用最为广泛的物理层协议；
ISO 11898-3: 2006 定义低速CAN总线（LS-CAN, Fault-Tolerant CAN）物理层标准，数据传输速率在 40Kbps ~ 125Kbps 。Fault-Tolerant是指总线上一根传输信号失效时，依靠另外的单根信号也可以通信，LS CAN主要应用于汽车车身电控单元之间通信；
然而上层协议就更加丰富了，几乎每个厂商都有自己的can总线协议。下图就列举了一些CAN总线的常用上层协议类型：
2.2 CAN总线特性 CAN总线具有多种特点其中包括：多主的工作方式；每条协议具有不同的优先级；采用非破坏性总线仲裁技术；CAN可以通过报文实现点对点、一点对多点以及全局广播方式传送数据；节点数取决于总线驱动电路；采用短帧结构（8/16字节），传输时间短，鲁棒性强，抗干扰；CRC帧校验，数据出错率低。
这其中最重要的特点是多主的工作方式，一般操作系统都有一个大脑，对整个操作系统的环境进行管理，但是CAN总线的是多主的工作方式，各个ECU只负责往总线上收发它们的协议帧即可，所以当多个ECU同时收发消息时，就会导致冲突，这就又和它第二三个特点相关了。仲裁的特点是基于协议的优先级进行仲裁的，主要是为了给CAN总线上的协议进行优先级排序，决定发生冲突的时候哪个协议先占用CAN总线进行通讯。同时CAN协议的一些特点比如短帧结构，鲁棒性强，抗干扰等等能力也让CAN总线具有了在汽车上适用的条件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec4eee807c80470b50f2b7c92780c835/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85bd28e355e5b5628956350570f5e1ec/" rel="bookmark">
			Spring面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐博客：https://blog.csdn.net/a745233700/article/details/80959716
1. Spring是什么 Spring是一个轻量级的IoC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。主要包括以下七个模块：
Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；Spring Core：核心类库，所有功能都依赖于该类库，提供IOC和DI服务；Spring AOP：AOP服务；Spring Web：提供了基本的面向Web的综合特性，提供对常见框架如Struts2的支持，Spring能够管理这些框架，将Spring的资源注入给框架，也能在这些框架的前后插入拦截器；Spring MVC：提供面向Web应用的Model-View-Controller，即MVC实现。Spring DAO：对JDBC的抽象封装，简化了数据访问异常的处理，并能统一管理JDBC事务；Spring ORM：对现有的ORM框架的支持； 2. Spring 的优点 （1）spring属于低侵入式设计，代码的污染极低；
（2）spring的DI机制将对象之间的依赖关系交由框架处理，减低组件的耦合性；
（3）Spring提供了AOP技术，支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用。
（4）spring对于主流的应用框架提供了集成支持。
3. Spring的IoC理解（重点） （1）IOC就是控制反转，指创建对象的控制权转移给Spring框架进行管理，并由Spring根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。DI依赖注入，和控制反转是同一个概念的不同角度的描述，即 应用程序在运行时依赖IoC容器来动态注入对象需要的外部依赖。
（2）最直观的表达就是，以前创建对象的主动权和时机都是由自己把控的，IOC让对象的创建不用去new了，可以由spring自动生产，使用java的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。
（3）Spring的IOC有三种注入方式 ：构造器注入、setter方法注入、根据注解注入。
4. Spring的AOP理解（重点） OOP面向对象，允许开发者定义纵向的关系，但并不适用于定义横向的关系，会导致大量代码的重复，而不利于各个模块的重用。
AOP，一般称为面向切面，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，提高系统的可维护性。可用于权限认证、日志、事务处理。
AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。
（1）AspectJ是静态代理，也称为编译时增强，AOP框架会在编译阶段生成AOP代理类，并将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。
（2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。
Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：
​ ① JDK动态代理只提供接口的代理，不支持类的代理，要求被代理类实现接口。JDK动态代理的核心是InvocationHandler接口和Proxy类，在获取代理对象时，使用Proxy类来动态创建目标类的代理类（即最终真正的代理类，这个类继承自Proxy并实现了我们定义的接口），当代理对象调用真实对象的方法时， InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；
InvocationHandler 的 invoke(Object proxy,Method method,Object[] args)：proxy是最终生成的代理对象; method 是被代理目标实例的某个具体方法; args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。 ​ ② 如果被代理类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。
（3）静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。
IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。 5. Spring AOP里面的几个名词的概念 （1）连接点（Join point）：指程序运行过程中所执行的方法。在Spring AOP中，一个连接点总代表一个方法的执行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85bd28e355e5b5628956350570f5e1ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ae792d4f744788871ab9f25fa052a4c/" rel="bookmark">
			Linux系统通过apt安装新内核-come from 麒麟V10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先使用下面的命令更新源：
sudo apt updaete 然后使用下面的命令搜索内核版本:
sudo apt search image | grep ^linux-image | awk '{print $1}' | awk -F '/' '{print $1}' | grep -Po "^linux-image-\d+\.*\d+.*" 结果如下：
l@l:~/桌面$ sudo apt search image | grep ^linux-image | awk '{print $1}' | awk -F '/' '{print $1}' | grep -Po "^linux-image-\d+\.*\d+.*" WARNING: apt does not have a stable CLI interface. Use with caution in scripts. linux-image-4.15.0-10-generic linux-image-4.15.0-10-lowlatency linux-image-4.15.0-1001-aws linux-image-4.15.0-1001-gcp linux-image-4.15.0-1003-azure linux-image-4.15.0-1003-kvm linux-image-4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ae792d4f744788871ab9f25fa052a4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7558ee8662d0e946f8cf279371bd017c/" rel="bookmark">
			智能硬件产品的软件测试,智能硬件测试三大关键点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2015 年可谓智能硬件产业在我国的孕育突破时期，智能硬件产品在大众市场、公共服务领域以及国名经济各行业的应用不断拓展。到了 2016 年，更多的智能硬件新品袭入市场，越来越多的企业也开始加入到智能硬件大军中——传统制造企业望通过这样的新技术新产品来刺激新的业务增长点，互联网企业也期望通过实现传统行业的互联网化在市场中分一杯羹，而对于创新型企业来说，智能硬件行业属于新兴领域，发展机会多，进入壁垒少，能快速实现增长。
面对这样如火如荼的智能硬件开发大潮，投身于其中的企业们也明白智能硬件的测试是不可忽视的环节，但是对于这个新兴领域，很多企业在对进行智能硬件测试的时候找不到测试关键点，很多时候都是按着感觉来进行测试，那么往往当产品上市的时候，可能就会因为测试时遗漏了一些重要的环节而造成大小不一的问题，大大削弱了其在市场中的竞争力。
而针对这样的问题，总结出了目前智能硬件测试的三大关键点：
一、功能问题
●智能硬件及其配套软件的功能是否能够正常运行？
智能硬件做得再好，但配套的软件功能不能够正常运行，那智能硬件便不能完全发挥其相应的功能，仅仅只是一个普通的产品而已那，有怎么能称“智能”呢？
●数据交互的准确性问题： 智能硬件是否能够正确的执行配套软件下发的指令，软件能否准确收集硬件采集的数据？
配套软件能够正常运行了，但和智能硬件之间的数据交互不够准确，不能执行你需要的指令，就算执行了你所提出的指令，最终却没有能够完成数据采集，那不是白忙活？这“智能”二字恐怕也落不上去。
二、兼容性问题
●智能硬件能否与手机顺利连接适配，是否能兼容主流热门的手机？
高高兴兴地戴上了刚买的智能手环，准备去外面溜达一天，打开你的手机却发现它并不能和智能手环连接适配，这手环瞬间变成了装饰品，何其无奈，估计这时你出门的好心情也顿时烟消云散。
●智能硬件配套的 APP 能否正常运行，是否会出现连接不稳定、崩溃、卡死、 UI 异常等问题？
为了身体健康，你下定决心买了一个价格不菲的智能水杯，但配套的 APP 出现了各种问题，那么它最终并不会按时告诉你该喝水了，你现在该吃药了等等一系列你当初需要它提供的功能，那这还是智能水杯吗？
三、稳定性问题
●智能硬件能否长时间或者在复杂的网络环境中还能保持持续稳定连接？
智能硬件时连时断，最终记录的数据断断续续不完整，功能使用体验时好时坏，这貌似任谁也不愿意继续用下去，只得“差评”！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2dcc136f7ed8767c1befe597f59963d/" rel="bookmark">
			java设计模式-单例模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、单例模式的定义 单例模式顾名思义就是一个类只能拥有一个实例，这样保证对象的一致性。
2、单例模式的特点 1、单例类只能有一个实例
2、单例类必须自己创建自己的唯一实例
3、单例类必须给其他的对象提供这个实例
3、线程安全问题 1、首先不管是饱汉式还是饿汉式的单例模式，都必须将对象的构造方法进行私有化，避免外部调用时能实例化对象（这里不考虑反射的情况，对于反射可以直接暴力访问）
2、饿汉式单例模式，由于在类加载时就已经初始化对象，所以只会有一个实例。
3、饱汉式单例模式，在使用时才去实例化对象，这样就需要使用锁的机制来避免多线程造成的多个实例。
4、实现单例模式的方式 1、饿汉式单例（立即加载方式）
public class Singleton{ //私有化构造方法，避免外部访问 private Singleton(){} //初始化静态对象 private static Singleton singleton = new Singleton(); //静态工厂方法，供外部进行调用 public static Singleton getInstance(){ return singleton; } } 2、饱汉式单例（使用synchronized同步锁）
public class Singleton{ //构造方法私有化 private Singleton(){} //声明静态对象 private static Singleton singleton = null; //静态工厂方法，供外部调用 public static Singleton getInstance(){ //校验,如果没有创建实例，则需要创建 if(singleton == null){ //进行悲观锁的控制，避免多线程的情况 synchronized(Singleton.class){ //校验 if(singleton == null){ singleton = new Singleton(); } } } return singleton; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95167e4db093d56af5b7318546094579/" rel="bookmark">
			C&#43;&#43; Socket 服务端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面代码已在VS2017上验证，运行代码时需要将项目属性-&gt;C/C++-&gt;常规-&gt;SDL检查设置成否，否则运行报错。
#include &lt;iostream&gt; #include &lt;WinSock2.h&gt; /* * 表示链接ws2_32.lib这个库。和在工程设置里写上链入ws2_32.lib的效果一样（两种方式等价，或说一个隐式一个显式调用）， */ #pragma comment(lib,"ws2_32.lib") #define _WINSOCK_DEPRECATED_NO_WARNINGS /* 不加这个宏的话会有这个错误 * inet_addr': Use inet_pton() or InetPton() instead or define _WINSOCK_DEPRECATED_NO_WARNINGS * to disable deprecated API warnings */ int main() { int result = 0; SOCKET server_ = INVALID_SOCKET; //socket 对象 WSADATA data_; result = WSAStartup(MAKEWORD(2, 2), &amp;data_);//inital if (result != 0) { std::cout &lt;&lt; "WSAStartup() init error " &lt;&lt; GetLastError() &lt;&lt; std::endl; system("pause"); return 1; } server_ = socket(AF_INET, SOCK_STREAM, 0); SOCKADDR_IN addrSrv; addrSrv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95167e4db093d56af5b7318546094579/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a21dbc15f3079df8b441056cfe723978/" rel="bookmark">
			迭代器源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迭代器的常用操作 对于我这种编程新人来说，知道怎么用比知道底层的源码要更加重要一些，在绝大多数情况下当成指针用都没有太大问题。
下面以vector为例
vector&lt;int&gt; iter; //声明（有时候传参的时候我习惯用auto） *iter //解引用，返回指向元素的引用 iter-&gt;val //解引用，获取成员 iter++ //指向下一个元素 ++iter iter+n //指向前面 iter1==iter2 //比较是否指向同一个元素 iter1-iter2 //计算两个迭代器的距离也就是difference_type iter.begin()	//头迭代器 iter.end() //尾迭代器 结合源码新的理解 之前理解的迭代器就是算法操控容器的工具，也可以理解成指针。侯捷老师给了一个新的解释，算法向迭代器提五个关于容器的问题，迭代器进行回答，这就是迭代器的作用。下面通过源码再来看看。
//提问 template&lt;typename I&gt; inline void algorithm(I first,I last) { I::iterator_category I::pointer I::reference I::value_type I::difference_type }; //回答 template&lt;class T,class Ref,class Ptr&gt; struct __list_iterator { typedef bidirectional_iterator_tag iterator_category typedef T value_type; typedef Ptr pointer; typedef Ref reference; typedef ptrdiff_t difference_type } Traits 这样的设计方式有一个小问题，如果iterator并不是一个class呢，也就是说是一个普通的指针，编译器又如何识别之间的区别呢？Iterator Traits完成了这项工作。所以算法不能直接问，而是间接问，先问traits，让后者先去识别是class iterator还是non-class iterator。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a21dbc15f3079df8b441056cfe723978/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d25e3673b2d15c9aca7d0f229268ca84/" rel="bookmark">
			常量对象、常量成员函数和常引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常量对象、常量成员函数和常引用 常量对象 如果不希望某个对象的值被改变，则定义该对象的时候可以在前面加const关键字。
class CEngine //引擎类 { }; const CEngine obj; //常量对象 常量成员函数 1、在类成员函数说明后面可以加上const关键字，则该成员函数成为常量成员函数。
2、常量成员函数执行期间不应该修改其所作用的对象。因此，在常量成员函数中不能修改成员函数的值（静态成员变量除外），也不能调用同类的非常量成员函数（静态成员函数除外）。
class Sample { public: int value; void GetValue() const; void func() {} Sample() {} }; void Sample::GetValue() const { value = 0; //错误：修改了其所作用的对象 func(); //错误：调用了同类的非常量成员函数 } int main() { const Sample o; o.value = 100; //错误：常量对象不可以被修改 o.func(); //错误：常量对象上面不能执行非常量成员函数 o.GetValue(); //正确：常量对象可以执行常量成员函数 return 0; } 常量成员函数的重载 两个成员函数，名字和参数表都一样，但是一个是const，一个不是，算重载。
class CTest { private: int n; public: CTest() { n = 1; } int GetValue() const { return n; } int GetValue() { return 2 * n; } }; int main() { const CTest objTest1; CTest objTest2; cout &lt;&lt; objTest1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d25e3673b2d15c9aca7d0f229268ca84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b602abd743fc817dde1a7e6e0994033/" rel="bookmark">
			什么软件可以测试音乐速度,测算歌曲速度有什么好用的编曲软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无论是制作DJ歌曲，还是喊麦，作者都要了解歌曲的节拍。而节拍的快慢在编曲软件中的体现是BPM(Beats per minute的缩写)参数，熟悉了BPM参数才方便合曲。
乐感强的创作人稍微听几遍曲子，跟着打几下节拍便能测算出大概数值，可以直接创作了。但是，对于乐感不强的创作人，则需要借助节拍器来测算歌曲速度。
小编将分别演示如何使用Studio one和Cubase来测算歌曲速度，看看哪个软件更好用。
图1：Studio one工作台界面
首先，在Studio One新建工程，导入需要测算速度的歌曲。单击工作台底部走带按钮，找到歌曲副歌位置，将播放线定位于副歌开始处。
图2：测速界面
鼠标置于走带面板“速度”位置，单击鼠标左键四下，同时默念4拍，4拍后“速度”上方的数值发生改变，此时显示的便是BMP参数。
超级简单吧。
Studio one除了测速，还可以在该界面直接调整BPM参数，也就是改变歌曲的速度。
图3：调整重音位置界面
仔细听歌曲重音是否在节拍器的上，如果感觉慢于节拍器，点击“声音”上方数值，输入大于当前数值的参数即可，如有细微差别再按照上面方法调试。
是不是也非常简单。
下面我们再来看看如何使用Cubase测算歌曲速度
二、Cubase测算歌曲速度
图4：Cubase节拍器界面
首先，打开节拍器，播放歌曲，点击计算“敲击”的选项，同时用鼠标根据节奏点击，直到数字稳定。然后，关闭节拍器，把工程速度修改为测试速度，再找到歌曲第一拍位置。关闭对齐按钮，剪掉空白内容。再次打开对齐，将音频与小节线对齐，再打开节拍器测算，如果中间出现节奏不稳，再关闭对齐，剪开，一点点的调试。
相较于Studio one，Cubase测算歌曲速度的方法真的很繁琐。
所以测算歌曲速度有什么好用的编曲软件呢？综上，小编更推荐新手在编曲测算速度时使用Studio one，更多编曲实操技巧，请持续关注Studio one5中文网站。不仅测试时操作简便，测速后如果要对歌曲速度进行修改也非常方便，你值得拥有！
作者：李大山
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1de3e942434ca23452a477fa5d9460a8/" rel="bookmark">
			Embedding-based Retrieval in Facebook Search向量化召回
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Embedding-based Retrieval in Facebook Search 2020.7 Facebook
Brief summary:
Text的boolean match不能解决语义匹配问题，引入embedding。（EBR）双塔模型：query embedding；document embedding; hinge_loss 三元组作为训练样本&lt;q,d+,d_&gt;，q与d+的相似性得分大于q与d-的相似性得分。困难样本挖掘： 困难正样本：实际上是正样本但在判断中被判为负的。困难负样本：分在线，离线方式；本质上是选与正样本相似的负样本。简单样本能一般性的代表检索的数据空间（提升召回），困难样本能提升精确率。文章探讨了集成的方法（weight_concat，cascade model），利用这两种方式训练的embedding。在线时，用Fasis相似性搜索工具，NN的方式，最近邻的方式，用ANN搜索算法（Approximate Nearest Neighbor）节省时间。结合了term(Boolean match)和embedding（radius控制相似性得分范围，判断是否match。）做query和document 的match。 一篇关于向量化召回很好的分享：https://mp.weixin.qq.com/s/E5a4TF9P2aMrF6gVatAF8A
Abstract 除了用户搜索的query text,用户的上下文信息也很重要。
之前FB搜索基于Boolean matching model。
引入网页搜索引擎中常用的EBR（基于embedding的召回）
我们介绍了为个性化搜索建模语义嵌入而开发的统一嵌入框架，以及在基于倒排索引的典型搜索系统中为基于嵌入的检索提供服务的系统。
1.INTRODUCTION 搜索技术大多主要基于各种各样的term matching methods。对于关键字匹配可以解决的情况，它表现得很好，但是它很难计算出搜索意图，或者语义上的匹配，不能满足用户的搜索意图。
一种搜索引擎包括一个召回层（recall layer），其目标是以低延迟和计算成本检索一组相关文档，通常称为检索(retrieval)，精确层(precision layer)的目标是用更复杂的算法或模型将最需要的文档排在最上面，通常称为排名(rank)。
The application of embeddings in retrieval is called embedding-based retrieval or EBR for short.
简短的来说，embedding-based retrieval 是一种用embedding表示query和文档，并把retrieval问题转换为在embedding空间的最近邻问题的技术。
由于需要考虑海量数据，搜索引擎中的EBR是一个极具挑战性的问题：
process billions or trillions of documents in the index of a search engine；巨大的规模给嵌入训练和嵌入服务带来了挑战。
其次，与计算机视觉任务中的基于嵌入的检索不同，搜索引擎通常需要将基于嵌入的检索和基于词匹配的检索结合起来，在检索层对文档进行评分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1de3e942434ca23452a477fa5d9460a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bfa6a6437b06bc43ddcc5339aaee24e/" rel="bookmark">
			压力测试软件怎么用,鲁大师温度压力测试如何使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多朋友都在网上问鲁大师的温度压力测试怎么看结果，结果到底在哪里，其实小编也想知道。下面就是小编收集来的各路大神的说法，大家可以看看对比一下。
说法一：鲁大师的温度压力测试不需要你开任何应用程序的。你只需要点击鲁大师“温度检测”里的“进行温度压力测试”，然后它会弹出两个动态的窗口，你只需要看温度曲线的走向，如果有上70度的，那就高了，测个5分钟，都在70度下就正常！
说法二：温度压力测试是不会自动结束，他会让你的机子一直满载然后你可以观察温度，关闭那两个窗口就能停止，通常满载10分钟或者以上就能反映问题了，你一分钟不到就能上90度，散热系统已经出了问题，建议先清理灰尘，再不行就换散热吧。
说法三：Y480M，用鲁大师进行温度压力测试CPU从50度一下子就到90多度，室内有空调，其他配件都正常45度左右，电脑中有自我保护的系统，如果温度过高会出现死机、蓝屏、自动断电等情况，以保证电脑硬件不会由于温度过高而造成损坏，如果您使用过程中都正常，建议放心使用即可。
说法四：温度压力：主要是把cpu利用提升到100% 然后监测个硬件温度。进行压力测试的时候，你可以直接电脑监测里看各硬件的温度信息 ,你主要就是注意温度的变化。这个测试是不会自动结束，会让你的机子一直满载然后你可以观察温度，关闭那两个窗口就能停止，通常满载10分钟或者以上就能反映问题了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/961363fde1f276161f09a2e34face240/" rel="bookmark">
			ios多个framework相互调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aed684b8e9366256ce5e73f48b591d91/" rel="bookmark">
			JanusGraph概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要从以下几个方面来概述JanusGraph： 什么是图计算？
什么是TinkerPop？
什么是JanusGraph？
TinkerPop和JanusGraph的关系
1、什么是图计算 就如程序=数据结构+算法一样，图计算=Structure+Process
Structure，即图形结构，图数据库或图计算框架常用的图形结构通常是基于属性图模型：
一个图由Vertex(顶点、节点、实体)和Edge(边，线，关系)组成。顶点通过边连接，边有方向，也就是说一条边有一个起始节点和一个结束节点。
其中顶点和边上都可以包含属性（键值对形式，键一般是字符串，值可以是任意类型的数据）
顶点和边都有标签label进行标记，用于分类，顶点可以有多个label，边通常只有一个label。
Process，即处理过程，图处理过程是分析图结构的手段，图过程的典型形式称为遍历(Traversal)
2、什么是TinkerPop Apache TinkerPop™ is a graph computing framework for both graph databases (OLTP) and graph analytic systems (OLAP).
TinkerPop的核心Gremlin是什么？- Gremlin is Gremlin is Gremlin
理解Gremlin以及这句话的含义，可以将Gremlin大致类比为JDK，通过下面类比应该很容易理解Gremlin is Gremlin is Gremlin这句话，用户不管是通过哪种程序语言编写的Gremlin程序，不管是编写的OLTP程序还是OLAP程序，都是没有分别的，都可以通过编译为Gremlin字节码，在GTM(Gremlin Traversal Machine, Gremlin遍历机）上执行：
JDK = Java语言 + JVM + Java API类库
Gremlin = Gremlin语言 + GTM + TinkerPop结构API/过程API
TinkerPop不是一个完整的图数据系统，其提供了操作图数据的图形结构接口，图操作过程接口，以及编写图形操作程序的Gremlin语言，和执行图形遍历过程的GTM，但是其并不提供图数据持久化存储功能
3、什么是JanusGraph JanusGraph是一个开源的分布式图形数据库，注意JanusGraph并不是一个真正意义上的分布式并行图计算数据库。这里的分布式主要是指JanusGraph可以使用HBase, Cassandra等分布式数据库作为后端数据存储，同时还可使用ElasticSearch或Solr等分布式全文检索系统作为索引后端，以及可以结合spark作为olap图分析处理。但是JanusGraph的oltp操作仍然是单机的，因为gremlin server虽然可以部署多台，但每个服务都是独立的，相关oltp操作只能在一台服务器上单机执行。
4、TinkerPop与JanusGraph的关系 JanusGraph是基于TinkerPop技术栈实现的，用TinkerPop的官方术语描述，JanusGraph属于TinkerPop-Enabled Data System Provider，即JanusGraph是启用TinkerPop功能的图数据系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aed684b8e9366256ce5e73f48b591d91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb6016a84377cc6943b460b2ddd88a7e/" rel="bookmark">
			使用vue-cli创建new project报错： Failed to download repo vuejs-templates/webpack: read ECONNRESET
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 今天学习vue-cli，使用命令vue init webpack projectname常见新的项目时，出现下面的报错信息：
通过google找到github上相同错误提交信息，Failed to download repo vuejs-templates/webpack: read ECONNRESET。
解决办法： 报错原因： 通过查看相关资料，发现报错原因在vue官网中有提过：
使用命令vue --version查看我的vue-cli版本，信息如下：
果然我的vue-cli版本超过3,按照官网提示，使用命令npm install -g @vue/cli-init全局安装一个桥接工具，如下：
安装完后，重新创建项目，新的报错：
这个报错是因为网络原因，重新执行命令即可。
成功创建：
希望对你有用。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2317644452b51c270132c8f0e0015d01/" rel="bookmark">
			无序数组的中位数(三种方法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.利用排序进行查找中位数 基本思路:对数组进行排序,直接访问数组中位数
double MIDnum(vector&lt;int&gt;&amp; array) { if(array.empty()) return -1; int midIndex = (array.size() - 1) / 2; sort(array.begin(), array.end()); if (array.size() % 2 == 1) { return (double)array[midIndex]; } return ((double)array[midIndex] + (double)array[midIndex + 1]) / 2; } 二.类似于快速排序,采用的是分而治之的思想. 基本思路:任意挑选一个元素,以该元素为基准点,将数组分为两部分.左部分都是小于基准点的,右部分都是大于基准点的.如果运气好的话,基准值正好就是中位数.
int partion(vector&lt;int&gt;&amp; array, int begin, int end) { int start = begin; int key = array[begin]; while (begin &lt; end) { while (begin &lt; end &amp;&amp; array[end] &gt;= key) { end--; } while (begin &lt; end &amp;&amp; array[begin] &lt;= key) { begin++; } swap(array[begin], array[end]); } swap(array[start], array[begin]); return begin; }	double getNum(vector&lt;int&gt;&amp; array, int midIndex) { int left = 0; int right = array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2317644452b51c270132c8f0e0015d01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71b222ee541c7ae6b213ebbf4f3bbd3e/" rel="bookmark">
			Window.devicePixelRatio(设备像素比)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Window 接口的devicePixelRatio返回当前显示设备的物理像素分辨率与CSS像素分辨率之比。 此值也可以解释为像素大小的比率：一个CSS像素的大小与一个物理像素的大小。 简单来说，它告诉浏览器应使用多少屏幕实际像素来绘制单个CSS像素。
当处理标准显示器与HiDPI或Retina显示器之间的差异时，这很有用，后者使用更多的屏幕像素绘制相同的对象，从而获得更清晰的图像。
您可以使用window.matchMedia() 检查devicePixelRatio的值是否发生更改（例如，如果用户将窗口拖动到带有 不同的像素密度）。 请参阅下面的例子.。
语法 value = window.devicePixelRatio; 值Value 一个双精度浮点值，指示显示器的物理像素分辨率与CSS像素分辨率之比。 值1表示经典96 DPI（在某些平台上为76 DPI）显示，而对于HiDPI / Retina显示屏则期望值为2。 在异常低分辨率的显示器中，或更常见的是，当屏幕的像素深度比简单地将96或76 DPI的标准分辨率提高一倍时，可能还会返回其他值。
例子 在 &lt;canvas&gt; 中更正分辨率 &lt;canvas&gt;可能在视网膜屏幕上显得太模糊。 使用window.devicePixelRatio确定应添加多少额外的像素密度以使图像更清晰。
HTML
&lt;canvas id="canvas"&gt;&lt;/canvas&gt; JavaScript
var canvas = document.getElementById('canvas'); var ctx = canvas.getContext('2d'); // Set display size (css pixels). var size = 200; canvas.style.width = size + "px"; canvas.style.height = size + "px"; // Set actual size in memory (scaled to account for extra pixel density).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71b222ee541c7ae6b213ebbf4f3bbd3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b728b11a7a4784da4b3b1868b8f171a5/" rel="bookmark">
			计算机关机键 自动重启,电脑关机后自动重启怎么办？原因及解决方详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：电脑关机后自动重启怎么办？原因及解决方详解
电脑关机后自动重启的原因是什么？相信有不少的用户在使用电脑的时候，都有遇到过电脑关机后自动重启的情况，导致电脑关机后自动重启的原因有很多，硬件、软件等这些都有可能导致出现这个问题。那么该如何解决呢？下面小编就给大家介绍下电脑关机后自动重启的原因及解决方法。
一、系统设置问题
系统错误造成自动重启。关机过程中系统出现错误，从而导致重启电脑。解决的方法如下：
1、右击桌面上的计算机图标，选择属性，点击左侧的“高级系统设置”。
2、在打开的系统属性窗口中，点击启动和故障恢复下面的“设置”按钮；
3、取消勾选系统失败栏下面的“自动重启启动”，点击确定即可。
二、高级电源管理
关机是与电源管理密切相关的，造成关机后自动重启的原因，也有可能是因为电源管理对系统支持不好造成的。若方法一无法解决，可以尝试下此方法：
1、打开控制面板，点击电源选项；
2、在弹出的窗口中，根据需要启用或取消“高级电源支持”，如果你在故障发生时启用了“高级电源支持”则取消它，反之启用它。
三、USB设备
一般情况下，USB设备包括U盘、鼠标、键盘等，都是造成关机后自动重启的原因。如果电脑上接有USB设备，建议先将其拔掉再关机。或进入BIOS设置，将Power Management Setup的Restore AC Power Loss设置为Disabled，将Power Management Setup的PM Control by APM设置为Yes。
除了上述原因外，电脑电压不稳、内存接触不良等都有可能导致电脑关机后自动重启。有遇到同样问题的用户可以参考上述的方法进行解决，希望可以帮助到大家。返回搜狐，查看更多
责任编辑：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f7c96137f3810f53a30cb2fe7b2dcb6/" rel="bookmark">
			Kafka整合WebFlux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.projectreactor.kafka&lt;/groupId&gt; &lt;artifactId&gt;reactor-kafka&lt;/artifactId&gt; &lt;version&gt;1.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; 2、代码示例 @Component public class KafkaService { private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(); private KafkaSender&lt;String, String&gt; kafkaSender; private KafkaReceiver&lt;String, String&gt; kafkaReceiver; @PostConstruct public void init() { final Map&lt;String, Object&gt; producerProps = new HashMap&lt;&gt;(); producerProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, IntegerSerializer.class); producerProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class); producerProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092"); final SenderOptions&lt;String, String&gt; producerOptions = SenderOptions.create(producerProps); this.kafkaSender = KafkaSender.create(producerOptions); final Map&lt;String, Object&gt; consumerProps = new HashMap&lt;&gt;(); consumerProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, IntegerDeserializer.class); consumerProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f7c96137f3810f53a30cb2fe7b2dcb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0e64252e9cdc0fca98b31990d6ba03a/" rel="bookmark">
			三大框架-- SpringMVC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.概念 Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的SpringMVC框架或集成其他MVC开发框架
二.MVC模型 M代表: Model模型
V代表: View视图
C代表: Control控制层
用来进行分层的结构，这样代码分离结构清晰，各层代码，各司其职，易于开发大型项目。
MVC(Model模型、View视图、Control控制层)，将软件进行分层达到松耦合的效果。
通用的软件编程思想, 在MVC设计模式中认为, 任何软件都可以分三层：控制层（Controller）、数据处理模型（Model）、负责展示数据的视图（View）。
在MVC设计思想中要求一个符合MVC设计思想的软件应该保证上面这三部分相互独立，互不干扰，每一个部分只负责自己擅长的部分。如果某一个模块发生变化，应该尽量做到不影响其他两个模块。提高代码的可读性，实现程序间的松耦合、提高代码复用性。
三.SpringMVC的工作原理 1、用户发送请求至前端控制器DispatcherServlet。
2、DispatcherServlet收到请求调用HandlerMapping处理器映射器。
3、处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。
4、DispatcherServlet调用HandlerAdapter处理器适配器。
5、HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。
6、Controller执行完成返回ModelAndView。
7、andlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。
8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器。
9、ViewReslover解析后返回具体View。
10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。
11、DispatcherServlet响应用户。
四.处理请求的方式 1.概述
当客户端打开浏览器要访问服务器时,可能会带着一些http请求参数过来.
这时,服务器需要获取http参数进行业务处理,如何处理http请求并获取参数呢?
总共有8种,重点时两种方式:GET方式和POST方式.
2.GET方式
向特定的资源发出请求,并返回实体.有固定的写法.而且数据有最大长度,超出就不行
例如:
http://localhost:8080/car/insert?id=1&amp;name=张三&amp;age=18
3.POST方式
向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
4.RESTFul方式（推荐）
为了简化GET请求的写法,可以使用RESTFul方式,用法:
1&gt;、需要使用注解@PathVariable来获取请求路径中的参数值,@PathVariable用来绑定值
2&gt;、通过{???}获取路径中传递来的值
3&gt;、以前GET的访问方式即将被简化成:
5.总结
get：把请求参数 在地址栏拼接http://localhost:8080/car/insert?id=1&amp;name=张三&amp;age=18
post：安全，数据不在地址栏展示
package cn.tedu.controller; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import cn.tedu.pojo.Car; @RestController//接受请求,返回json数据 @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0e64252e9cdc0fca98b31990d6ba03a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd8d7051db2fb9dd10681b822030945d/" rel="bookmark">
			QT QTableWidget中添加控件并居中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 QTableWidget中添加控件并居中 1.效果2.核心代码3.参考链接 1.效果 2.核心代码 // item文字居中 //item = new QTableWidgetItem(um-&gt;it.value().name); //item-&gt;setTextAlignment(Qt::AlignHCenter|Qt::AlignVCenter); //ui-&gt;tableWidget-&gt;setItem(0, 0, item); //添加到界面 // 创建相应的控件 布局 窗体 QSpinBox *bt; QWidget *widget; QHBoxLayout *hLayout; bt = new QSpinBox(); widget = new QWidget; hLayout = new QHBoxLayout();// 水平布局 hLayout-&gt;setMargin(0); // 与窗体边无距离 尽量占满 hLayout-&gt;addWidget(bt); // 加入控件 hLayout-&gt;setAlignment(bt, Qt::AlignCenter); // 控件居中 widget-&gt;setLayout(hLayout); ui-&gt;tableWidget-&gt;setCellWidget(0, 0, widget); //添加到界面 bt = new QSpinBox(); ui-&gt;tableWidget-&gt;setCellWidget(0, 1, bt); //添加到界面 3.参考链接 https://zhidao.baidu.com/question/1887492447205900948.html --QtableWidget表格中添加控件怎么居中 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed1b447abef2a66cf0ac38bc017bcacb/" rel="bookmark">
			小白都会的一键软件搬家？你还不会吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说到软件搬家，就想起当年刚上大学那会儿，就一个纯小白，对电脑最多也就了解下打字什么的。
我买的第一台电脑还是在大一下学期买的，拿到电脑的那一刻非常激动，毕竟是属于自己的第一台电脑
由于刚开始对电脑装软件啥也不懂，就一股脑的百度搜索下载安装包，然后疯狂下一步，看都不看。到最后没想到 C 盘的存储空间却是“伤痕累累”。
在这里奉劝小白，安装软件一定要看清楚软件安装的位置和大小，否则就是你 C 盘占满了，后果就是“重装系统”，当然补救的机会就是使用 软件搬家
软件搬家，说到底就是把原来初始软件安装的位置搬到另外一个盘符下，减少对C盘空间的依赖
下面就介绍下我怎么使用软件搬家的功能，市面上也有好多类型的，但感觉都不太靠谱，这里我介绍的是 腾讯电脑管家 自带的 软件搬家，亲测有效，我已经试过好多软件的搬移了
我电脑上用的是腾讯电脑管家，用的还行，当然也熟知其他好用的杀毒软件：火绒。电脑管家我从大学一直用到现在，不愿意换了，感觉功能都相差不大。打开电脑管家，点击 工具箱，搜索 软件搬家，下载安装
安装打开后就可以看到哪些软件是可以搬移的，哪些是不可以选择好搬家的软件，再选择搬移的路径，等待搬家完成就行了
其他盘符也可以搬家到另外的盘符中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a54bc117e2c40c35dc07b033268354b1/" rel="bookmark">
			简单梳理软件维护相关知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 概念 软件维护是指由于软件产品出现问题或需要改进而对代码及相关文档的修改，其目的是对现有软件产品进行修改的同时保持其完整性。 分类 软件维护技术 程序的理解软件再工程软件逆向工程 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c7eea124495d86e4f27f1acc7d357d5/" rel="bookmark">
			北京大学计算机学院复试名单2021,北京大学2021拟录取推免研究生毕业院校统计，多位来自非211高校...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，北京大学是我国综合实力最强的两所高校之一，考上这所大学是很多学生的梦想。由于录取人数有限，很多学生没能通过高考进入北京大学。其实，除了高考外，还有一种考上北大的方式，那就是考研。而考研又分为两种方式，第一种是参加研究生统一招生考试，第二种就是推荐免试，也就是保研。
一般来说，只有学校内综合成绩排名靠前的学霸才有资格保研，而保研到北大的学生更是学霸中的学霸。最近，北京大学正式公示了2021拟录取推荐免试研究生名单，笔者对这些拟录取研究生的毕业院校进行了统计，并根据毕业人数对院校进行了排名，那么，来自哪些大学的推免生比较多呢？这些大学实力如何呢？下面我们来看一下。
一、1-31名分析
北京大学2021拟录取推免研究生当中，来自上面31所高校的毕业生最多，其中北京大学毕业生人数高达1087名，这其实也是理所当然的事，首先北京大学的毕业生本来就很优秀，再者学生保研本校也很有优势。第2名到第11名在学科设置上与北京大学是非常相似的，这些高校其实都是以人文社科类学科、理学类学科为主的高校，当然，中国人民大学的理学类学科并不强。
其余985高校当中，电子科技大学、兰州大学的表现都是非常出色的，这两所高校虽然是985高校，但综合实力排名都不是很高。具体来看，电子科技大学主要是信息科技类专业比较出名，这所大学的高考录取分数线很高，生源质量相对较好。兰州大学也是一所以理学类学科、人文社科类学科为主的高校，学科设置和北大也非常相似。
前31名当中，有三所大学是非985高校，这三所高校是对外经济贸易大学、中央财经大学、西南财经大学，它们都是我国一流的财经高校，并入选“211工程”。从第四轮学科评估结果来看，中央财经大学的应用经济学排名最高。
二、32名-89名分析
这一区间的高校基本上都是211高校，其中一小部分是985高校。具体来看，中央民族大学的表现是非常惊艳的，这所高校虽然是985高校，但综合实力并不强，排名也不高。在高考录取中，中央民族大学的投档分数线也相对较低。但是，我们可以看到，这所弱985大学有多位学生成功保研北大。
211高校当中，中国政法大学、西安电子科技大学、北京邮电大学的表现都是非常不错的，这三所大学名气都非常大，优势专业都是全国顶尖水平，同时高考录取分数线也经常超过部分985高校。另外，郑州大学的表现也非常抢眼，这所高校虽然是省属211高校，但也有多位学生成功保研北大。
南方科技大学、西南政法大学、北京语言大学、上海科技大学、华东政法大学、广东外语外贸大学都是非211高校，但这些高校也至少有3名学生保研北大。南方科技大学、上海科技大学都是刚成立不久的理工科强校，这两所高校的办学水平可比肩985高校。其余四所高校都是特色强校，它们的优势学科都非常厉害。
三、90名-150名分析
这一区间非211高校比较多，其中保送北大人数在1人以上的高校名气基本上都很大。燕山大学是河北省综合实力最强的高校，工科实力尤其突出，这所高校的机械工程、材料科学与工程都非常厉害。四川外国语大学、天津外国语大学都是我国重点组建的八大外语高校之一。
首都师范大学、宁波大学、深圳大学凭借地理位置优势，近些年发展很快，其中前两所顺利入选了“一流学科建设高校”。南方医科大学、华南农业大学都是特色强校，它们分别在医学、农学领域实力强劲。更值得注意的是，辽宁工程技术大学、河南理工大学、桂林理工大学这些地理位置不占优势的非211高校，也同样有学生逆袭北大。
欢迎大家在下面评论，分享观点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adcc6fb6fdf5492a333978e063265900/" rel="bookmark">
			实时数仓入门训练营：实时数仓助力互联网实时决策和精准营销
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：《实时数仓入门训练营》由阿里云研究员王峰、阿里云高级产品专家刘一鸣等实时计算 Flink 版和 Hologres 的多名技术/产品一线专家齐上阵，合力搭建此次训练营的课程体系，精心打磨课程内容，直击当下同学们所遇到的痛点问题。由浅入深全方位解析实时数仓的架构、场景、以及实操应用，7 门精品课程帮助你 5 天时间从小白成长为大牛！ 本文整理自直播《实时数仓助力互联网实时决策和精准营销-合一》
视频链接:https://developer.aliyun.com/learning/course/807/detail/13886
近年来，实时数仓是互联网的热门话题，主要应用场景主要是在实时决策和营销等领域，这些领域对数据分析的精细度、实时性都有很高的要求，是走在技术前沿的领域。
业务在线化、运营精细化推动数仓实时化、交互化 我们先看一下过去几年数据分析发展的一些趋势，如上图所示。
可以看到，数据分析基本的趋势是从批处理向交互式分析、流计算的方向演进。在10年前，大数据更多的是处理规模的问题，通过并行计算的技术处理海量的数据，那个时候我们更多的是在做数据的清洗，数据模型的设计，对分析的需求并不太多。
如今，我们的大数据团队基本上都变成了数据分析的团队，对数据模型的沉淀，对交互式分析的支持能力，对查询响应延迟的支持效率，对QPS的要求都会越来越多。数据分析也并不只是数据存下来再分析，也有很多计算前置，先有逻辑后有计算的场景。比如在双11的时候，在多少秒有多少成交量，这样一个典型的场景就不是先有交易数据后有计算量的问题，一定是随着交易而发生实时计算结果的过程。
因此，交互式分析和流计算几乎是一个并行前进的过程，这两种新的场景对背后技术有很多不一样的要求。批处理更多的是讲究并行度，在交互式分析领域里边，我们开始有很多的预计算、内存计算、索引等技术，所以这个也是推动了整个大数据技术的演进。
总结来看，数据分析支撑着越来越多的在线业务，在线业务包括我们任何时候打开手机，手机屏幕里边推荐的产品、展示的广告，这些都是需要在几毫秒之内返回结果，靠数据智能推荐出来，如果不推荐的话点击率、转化率一定非常低。
因此，我们的数据业务在支撑越来越多的在线业务，在线业务对查询延迟、QPS、精细度都有非常高的要求，这也推动着数仓向实时化、交互化方向演进。
阿里巴巴典型实时数仓场景 在阿里巴巴有很多数仓的使用场景，例如双11的实时GMV大屏。GMV只是一个结论性的数字，实际上对数据分析师而言，这个工作只是刚刚开始。我们要向下分析，是什么产品，在什么渠道，针对什么样的人群，以什么样的促销手段，达成这样的转化效果，有哪些转化效果没有达成，等等一系列分析。这些分析其实非常的细粒度，是精细化分析的效果。
分析之后，就会对所有的商品、人群做一些标签化，通过标签化我们下一步可以去指导在线的应用去做推荐、分析、圈选等等，所以有很多数据中台的业务也会产生。
还有一类业务是偏监控类业务，订单突然抖动、增长，网络质量的抖动，视频直播的一些监控等，这些也是实时数仓典型的应用场景。
大数据实时数仓体系的“纷繁芜杂” 过去我们建设实时数仓的时候参考过很多公司，阿里巴巴也是走过很复杂的一条路线。
上方是我画的架构图，第一次看的时候挺兴奋的，那个时候自己是个大数据架构师，能够画出这么多个箭头是很体现功力的一件事情。但当真正去做这样一个系统的时候，发现这个系统的开发效率、运维效率非常令人抓狂。
这套系统从左上角演化开始，消息从消息中间件收集，之后是一个离线加工的过程，那个时候我们还没有很多实时的技术，首先要先解决规模的问题。通过离线的加工，我们会把加工的结果集变成小的结果集，存到MySQL和Redis，这是一个典型的加工服务二元化的体系。
通过把数据变成小数据之后，才能对外提供上层的应用，包括报表应用、推荐应用等。之后数据分析需要实时化，光靠这种“T+1”的离线加工不能够满足需求，数据越实时越有上下文，价值越大。这个时候就有很多计算前置的技术被采用，例如Flink。通过Flink直接消费Kafka里的事件，通过事件驱动的方式做计算，由于Flink是分布式的，因此可扩展性非常好，它可以通过计算前置，通过事件驱动的方式，可以把端到端的延迟做到极致。
然后我们会把结果集也存到一个介质里面，通过Flink加工的结果集是一个非常精简的结构，一般是以kv6结构为主，放在HBase、Cassandra这样的系统，这样的系统对上提供的大屏报表是最快的。比如说双11的大屏，绝对不能等成交几千万、几亿条记录之后再去做统计，否则查询性能一定无法满足。因此，我们一开始都会加工成如以每秒每个渠道为粒度的原始数据集，原始数据集在做大屏分析的时候，就可以从一个很大的数据集变成一个很小的数据集，性能达到极致。
现在我们看到有处理规模，有处理速度，这两者看起来表面上都满足一定需求，但其实成本也是不小的。如果想要计算足够地快，需要把计算前置，这样的话数据模型的灵活度就会减少，因为我们已经通过Flink把所有的数据汇聚成一个结果集了。
例如，如果有些业务逻辑一开始没有定义好，比如刚开始分析的是某三个维度的聚合，如果后续想分析第四个维度的聚合，由于提前没有计算好，因此无法进行分析，所以这里牺牲了灵活性。
此时就有一些相比HBase更灵活，又比Hive实时性更好的技术会被采用，例如ClickHouse、Druid。数据可以实时写入，写入之后也提供一定的交互式分析、自助式分析的能力。
我们会发现，数据处理将同一份数据分散在三个不同的介质，包括离线处理的介质，近实时处理的介质和全实时处理介质。三个介质往往需要三个团队来维护，三个团队随着时间发生人员的变动，数据加工逻辑一定会有多多少少的调整，造成的结果就是，我们会发现同一个指标通过三个不同渠道产生的计算结果不一致，这个事情几乎每个公司都会发生。
这还只是表面的问题，对于分析师来说更痛苦，他需要使用不同的数据，访问不同的系统，学习不同的接口，甚至是有不同的访问控制机制，这对分析师来说就非常不方便。因此，很多公司都要搭一套所谓的数据中台，通过中台来屏蔽底下物理引擎上的不同，这种情况下Presto、Drill这种联邦计算技术就会被采用。
联邦计算技术有着二十多年的发展历史，从最早期的数据信息系统集成到数据虚拟化，技术一直在发展。这个技术是一套数据不移动、计算移动的技术，听起来很美好，但是当真正在生产上使用的时候会发现，这套系统的查询体验是不可预期的，我们不知道通过系统查询下去数据是快还是慢，因为它把查询下压到不同的引擎，如果下压到Hive，就没那么快，要是下压到ClickHouse可能就比较快。所以这对一个分析师来说，他不知道这个系统的预期是什么，叫不可预期性。例如，以前打开报表可能用了5秒钟，另外一次可能用了5分钟，这种情况会让分析师不知道到5分钟的时候是正常还是不正常。如果跑在Hive上，就叫正常，如果跑在Drill上，就叫不正常。不可预期性也让这个系统很难进入生产的领域，所以这个时候我们不得以，还要是通过数据做一次汇聚，变成小的结果集去分析。
我们看到，整个链路实际上是由多个组件层层嵌套、层层依赖组成的，除了刚才提到的不同团队维护会造成数据口径不一致的情况，对数据维护的成本也会变得非常高。
经常遇到的情况有，我们看到报表上某个数字可能是不正确的，比如某天这个指标突然增长或下滑很多，这时没人能确认中间是数据质量出问题，还是加工逻辑出问题，或者是数据同步链路出错了，因为中间链路太长了。数据源头如果修改一个字段，重新补一个数据，那么每一个环节都要重跑，所以说这套架构如果是运行正常就没有问题，但是一旦数据质量有问题或者数据调度上出问题，环环依赖，这让整个运维成本变得非常高。
同时，懂这么多技术的人才难找且贵，经常发生的情况是一个公司辛苦培养出这样的人才，之后就被其他大厂挖走了，这样的人才从招聘到培养都非常困难。
以上是这套架构的现状。
今天大数据的复杂，让人想起60年代 上面这套架构让我想起60年代，那个时候数据库基本还没有诞生，70年代末期才诞生了关系型数据库。
60年代我们是怎么管理数据的状态？
在60年代，每个程序员要自己写状态维护。有的人用文件系统，但是光用文件系统会非常离散，维护起来也非常难，因为数据之间是有关系的。这个时候还有一些网状结构的系统出现，通过一个文件可以跳到另外一个文件去，但是网络结构管理起来也相对比较复杂，因为循环、嵌套等等。除此之外还有层级结构，也是一种数据类型的描述方式。
所以可以看到，60年代的程序员自己管理数据状态，其实成本很高。
到了80年代，我们基本上不会再这么干了，因为我们知道所有的状态尽量都存在数据库里，也是因为关系型数据库让这件事情变得简单了很多。尽管我们有很多种关系型数据库，但基本都是以SQL接口为主，这让我们整个数据的存储、查询、管理等成本急剧下降。
这件事情在过去20年又发生了一些不少变化，从大数据的时代到NoSQL到NewSQL，诞生了各种各样的技术，如Hadoop、Spark、Redis等，这让数据领域蓬勃发展。
但是我总觉得这个地方隐含了一些问题，可能未来不一定是这样。目前大数据发展蓬勃但不统一，所以我在想未来是不是可以把大数据技术相对收拢一些，用一种更有描述性的方式来解决问题，而不是让每个程序员都去学习不同的组件，学习几十种不同的接口，配置上千个参数。为了提高开发效率，或许在未来我们有必要将这些技术进一步收拢简化。
实时数仓核心需求：时效性 我们回过头看一看，脱离这些技术组件，实时数仓到底有什么业务上的需求，针对这些业务需求可以要求什么样的数据架构。
什么是实时？很多人认为实时分析就是从数据产生到能够被分析的时间足够短，其实这并不完全准确。我认为实时数仓分为两种实时，一种叫端到端的延迟短，另外一种实时也可以称为准时，就是当我们真正分析数据的时候，能够拿到有效的数据，并且能够得出结论，这就可以叫准时。
第一种实时是偏技术的概念，然而我们的业务一定需要这么低的延迟吗？
通常情况下，业务并不是每秒钟都在做决策，业务当我们打开报表，我们看数那一刻，这一刻我们关心的数据可能是过去的一天，上一个小时，5分钟之前，或者是一秒钟之前的。但经验告诉我们，99%的数据分析如果能做到5分钟的延迟，基本能满足业务上的数据分析需求。在分析场景是这样的，如果是在线服务的场景，这肯定是不够的。
所以大多数公司里也许并不要求那么实时，因为这背后的成本是不一样的。
因为一旦要的是端到端的延迟，就一定需要很多计算前置的业务逻辑，不能等数据都存下来之后再去查询，因为要求延迟非常地短，我们必须要把很多数据提前汇聚、加工、拉宽，才能让数据分析的时候计算量足够小，才可以做到延迟足够地短。
所以如果追求的是端到端的延迟，要做很多计算前置的工作。刚才我们提到，如果计算全部前置，灵活性会有损失，所以这件事是有成本的。相对来说，如果追求的是一个准时的系统，那可以把一部分的计算逻辑后置，换取的是一个灵活分析的场景。
例如双11的时候只是为了追求延时，那我们只会把最后一个GMV存下来，这是一种场景，这事就结束了。但这件事不符合公司要求，公司一定要出详细的报告，需要知道什么时候卖的好，什么时候卖的不好。所以这种情况下，全部提前预计算的方式肯定是不适合的，需要有更多的明细数据能够存下来，我们可以做更多的交互式分析、关联分析、探索式分析，所以说这两套系统背后的需求是不一样的。
相对来说，我觉得绝大部分公司要的其实是个准时的系统，它需要具备计算后置的能力，具备实时写入、写入即可分析的能力，哪怕分析的效率不是那么高，还要具备灵活分析的能力。
实时数仓核心需求：数据质量 数据质量是实时数仓建设里很重要的一环，刚才提到如果不追求数据质量，只追求时效性的话，一开始通过计算前置加工成一个结果集，这个结果集告诉我们GMV达到了100亿，绝大部分老板是不敢相信的，因为这100亿背后可能是数据质量出问题，也可能是计算逻辑写错了，所以说系统要能够保证数据质量。
数据质量分两个方面，一个是多久发现质量问题，另一个是多久修正质量问题，这两个解决思路是不太一样的。
如果想发现数据质量问题，就需要让计算过程的状态能够被持久化，就希望数据仓库引擎里边能够有明细，以及汇总数据能够落盘，这些数据可以被检查。这样的话，当老板问指标为什么增长这么多，到底是哪个客户带来的增长，你就可以通过这些明细的数据去检查原因，分析数据时如果发现错了能否修正，这也是很关键的问题。
有些系统只能看不能改，这是很多大数据系统的通病。大数据系统在处理规模性问题非常好，但是处理小的问题，如更正数据就特别地难。因为它每次更正都是需要很大的数据块为单位，或者是没有主键，将整个文件替换，所以更新起来确实比较难。
发现问题和修正问题相比，我更希望一个系统能够具备修正数据问题的能力。
修正问题就是在发现数据质量的时候，可以简单地更新数据的状态，比如说单行数据的更新，单列数据的更新，批量的更新等，有很简单的方式做数据的刷新。数据刷新的状态这个事情经常会发生，例如上游数据质量有问题，加工逻辑写错了等，都需要做数据刷新的工作。
其次，我也希望数据修正的时候尽量能够只修正一个系统就好。
刚才我们看到，一份数据的数据源出错了之后，它要在后端4~5个环节反复流转，这意味着一旦数据出错了之后，在4~5个环节里面都要做数据修正的工作，这里面的数据存在大量的冗余和不一致，要修正的话每个环节都要修正，这也是特别复杂的一件事情。所以我们希望数仓的状态尽量只存一个地方，这样话我只修正一处就可以了。
实时数仓核心需求：成本优化 成本分为三部分，分别是开发成本、运维成本和人力成本。
开发成本表示我们想要业务需求多久能上线。做同样一件事，是需要一个团队还是一个人，是需要一周还是一天，所以开发成本是很多公司很关心的一件事情，如果开发不出来，就意味着很多业务的需求是被压制或者是抑制的。
我们希望IT同学不需要再很疲惫地响应业务团队取数的要求。经常发生的情况是，等数据真正加工完之后，业务团队反馈说数据加工得不对，等IT同学好不容易修正对了之后，业务团队表示活动结束了，想看的数据已经没有意义了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adcc6fb6fdf5492a333978e063265900/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b077b65f6646333e461fd0ba106f7ff4/" rel="bookmark">
			【mathtype】将公式左对齐（右对齐）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将这样的一个公式右对齐
step1 在mathtype中打开
step2 点击-格式-矩阵-更改矩阵-对齐方式改为左侧
成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85fb92503b5a2cb1efe81aab49e2594b/" rel="bookmark">
			win8删除计算机管理员权限,win8.1系统如何删除administrator账户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，win8.1系统管理员帐户是Windows默认的最高权限用户，修改或删除重要文件都需要管理员Administrator账户。有时候创建本地账户之后就不用administrator账户了。想要删除administrator账户但不知道怎么设置，网上介绍关于win8.1如何删除administrator账户的内容比较少，小编整理出一些删除administrator账户的方法，想进一步了解的用户一起往下学习吧。
1、wind+R(运行)，compmgmt.msc(计算机管理)——本地用户和组——用户——右键新用户(N)—新用户；
2、选择
Administrator右键删除(D)，删除前要建一个账户不删除属性里钩选禁止。以前在没有得到同样的权限和关闭UAC下删除后，安装新系统时安装程序需要管理员权限我没有所以没法再运行系统的时候安装。最高的管理权限并不是Administrator，TrustedInstaller比
Administrator高了不知多少。
3、TrustedInstaller是在安装系统的时候用的，有了它的权限管理员的文件属性中即使当前用户没有权限访问和修改也是可以删除的。
方法二：
1、默认administrator是禁用的。可以禁用/开启administrator帐户。
2、在管理工作，点击“本地安全策略”；
上述小编介绍就是win8.1系统删除administrator账户的方法，一般win8.1系统默认禁用administrator账户的，有需要的用户可以参考教程设置。
相关推荐：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4380a6e6bfc73977224d834b84a1ccfe/" rel="bookmark">
			测试管理及项目测试流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 基于需求测试管理文件压缩项目1.项目启动，介入了解需求2.需求分析3.制定测试方案（计划+策略）4.测试执行流程5.编写测试用例6.测试执行7.输出测试报告8.版本发布9.项目总结 练习：百度云盘测试用例 基于需求测试管理 测试目标：量化指标；性能测试；需求分析
测试范围：
测试工具：兼容性测试：app，主流机型；性能测试-jmeter，loadrunner；接口测试：postman soupUI 写脚本
测试资源：人力资源；物力资源
测试计划：时间
测试策略：有限的时间，有限的资源要达到一个平衡，最终软件质量和测试所产生的风险之间的平衡。
需求分析：
功能性需求：登录、注册、查询。。。
非功能性需求：在功能性需求上增加一些限制，易用性，兼容性，可靠性，可移植性，安全性，性能
例如：登录：在高峰期，用户平均成功登录的时间不超过3s钟。
安全性限制：上传的时候上传任何病毒，报警。
不同的产品，不同的用户群体，测试的需求也不同
例如：手机：老年机 / 智能机
测试案例：
一个全新上线的app需要做哪些测试？
兼容性，安全性，功能性，接口，可靠性，可移植性，性能
一个增加了新功能的app需要做哪些测试？
对增加的功能进行测试，如果有其他非功能性的测试需求，也要进行相应的测试，并进行回归测试（可能会影响历史功能）
一个只修改了页面广告的aoo需要做哪些测试？
界面测试，兼容性测试
文件压缩项目 1.项目启动，介入了解需求 项目背景：磁盘空间不够，需要一个压缩、解压缩文件 目标：完成所有文件类型的压缩、解压缩。 时间：2018-6-
1到2018-6-7 项目成员：
项目经理：唐僧
产品经理：孙悟空
开发：猪八戒
测试：沙和尚
2.需求分析 功能需求：
文件类型:支持所有的文件
压缩文件个数:最多压缩100个文件 —— 等价类；边界值
压缩大小:不超过5G —— 等价类；边界值
界面需求:布局、排版美观
非功能需求：
性能需求:压缩、解压缩文件不超过30分钟
安全需求:带有病毒感染的文件不能压缩
易用性需求:操作简单、方便
兼容性需求:windows7，windows8，windows10都可以使用。
3.制定测试方案（计划+策略） 测试的范围及测试点： 压缩、解压缩文件，单文件，多文件
测试方法： 手工
测试所涉及的类型：
功能：依照功能测试用例全部执行
性能：依照性能测试用例全部执行
安全：依照安全测试用例全部执行
兼容：依照兼容测试用例全部执行
界面：依照界面测试用例全部执行
易用性：依照易用性测试用例全部执行
测试管理工具：禅道
测试资源：
风险:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4380a6e6bfc73977224d834b84a1ccfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7cb6b3ae3b1d02470dca3574259fc23/" rel="bookmark">
			二进制计算机基础,计算机基础_03 二进制是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		朋友们是否还记得2008年电视上播出的42集电视连续剧《魔幻手机》，在片头部分，有一个画面是这样的：
大家从图中可以看到里面有很多的数字从0-9都有，可能当时朋友们觉得这个好酷炫，并没有更多的思考。但是看了这篇文章之后，就需要知道计算机里面全是这些数字了。那下面就来具体说说吧。
首先需要纠正上面图中的一个问题：目前所有的计算机采用的全都是二进制，即只有0和1。而图中是0-9，就称为十进制(但是也有一个问题我们谁都不知道会怎么样：那就是真正到了2060年(说2060年是因为《魔幻手机》这部电视剧中的傻妞来自于2060年)，计算机是否会变为十进制)。
其次说为什么计算机要采用二进制而不是图中的十进制。其实在计算机诞生之初(1946年诞生的ENIAC，目前略微有争议，本文以ENIAC为准)(第一代计算机 电子计算机 1946-1958)，冯·诺依曼这位数学家就考虑过采用几进制的问题(有二进制(只有0、1)、八进制(0-7)、十进制(0-9)、十六进制(0-9 A-F))。后来采用了二进制的原因有很多：比如早期的计算机是需要人工操作，通过在纸带上打孔来确定0或1(比如有孔代表0，没有孔代表1)，从而进行计算机的一系列操作(算数加法、算数减法、算数乘法、算数除法以及逻辑与、逻辑或、逻辑非、逻辑异或)。可能有的朋友们不能理解：如果计算机里面全都是0和1的话，它怎么可以区分这些数字是参与运算的数字还是代表的各种操作或者是内存的各种地址什么的。所以说早期的计算机真的是有操作员在那里坐着进行记录等操作。
后来因为科技的进步，计算机进入到了第二(晶体管计算机1959-1964)、第三(中小规模集成电路计算机 1965-1970)、第四阶段(大规模集成电路计算机 1971-1990)、第五阶段(大规模和超大规模集成电路计算机 1991至今)时，计算机当时的运算也经过了很多的更新：比如像之前在纸带上打孔来确定0或者1，更新为以电压的高电平或低电平来确定0或者1，或者是以电流稳定或电流跳动表示0或者1等等。
另外使用二进制的一个优点就是方便运算。假定给你0和1让你进行加减乘除等运算和给你从0-9让你进行加减乘除的运算，你使用哪种会算的更快。很明显就是只有0和1这样运算更快。一方面是因为只有两个数字，另一方面如果出错，很容易就可以查出错误。
最后使用二进制的优点是进行各种转换更加简单方便(二进制的运算我们之后会详细进行运算解答)。
好啦，通过这些文字，希望大家都可以了解计算机为什么采用二进制。计算机采用二进制的优点都有什么。
如果有疑问欢迎在评论区留言，我们下期再见。
编辑：今天是小米粥
觉得不错就点赞关注加收藏吧！
举报/反馈
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94b6a35986e6c07230b1635ae44391e4/" rel="bookmark">
			第27节 实例-相机显示的内容抓取保存成图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本节需求 经常的，我们需要将相机渲染的内容传给其它的机器或者保存成图片。甚至需要将相机显示的内容进行录制，制作成mp4。其实制作成mp4也是用的图片，将每一帧的图片存下来，使用相关库制作成mp4就可以。
具体实现 其实将相机的内容抓取到图片只需要一句话：其中_t2d是一个osg::Image
camera-&gt;attach(osg::Camera::COLOR_BUFFER, _t2d);
此时，相机在渲染时，就可以实时的将渲染内容rtt到image当中。
本节还写了个事件处理，当点击p键的时候，保存图片到a.png：
virtual bool handle(const osgGA::GUIEventAdapter&amp; ea, osgGA::GUIActionAdapter&amp; aa) { //点击p键 if ((ea.getEventType() == ea.KEYDOWN)&amp;&amp;((ea.getKey() == 'P')|| (ea.getKey() == 'p'))) { osgDB::writeImageFile(*_t2d, "a.png"); } return false; } 主要的代码就上面这些了。
本节资源 本文集包括本节所有资源包括模型代码都在此下载，按节的序号有文件或文件夹，具体到本节是27.cpp：
注意： 务必使用浏览器打开：
【击此打开网盘资源链接】
所有代码 #include &lt;osgViewer/Viewer&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgGA/GUIEventHandler&gt; #include &lt;osg/Texture2D&gt; #include &lt;osgDB/WriteFile&gt; osg::ref_ptr&lt;osg::Image&gt; _t2d = new osg::Image; class MyEventHandler : public osgGA::GUIEventHandler { public: MyEventHandler() { } virtual bool handle(const osgGA::GUIEventAdapter&amp; ea, osgGA::GUIActionAdapter&amp; aa) { //点击p键 if ((ea.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94b6a35986e6c07230b1635ae44391e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7dc256c10313febb2944a15c7fe3b46/" rel="bookmark">
			单例模式（总）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		饿汉式 package com.kuang.singleton; //饿汉式单例 public class Hungry { // 饿汉式一上来就把这个类的所有东西和内存都加载了 相当于这个对象就已经存在了 //可能造成浪费空间 private byte[] date1 = new byte[1024*1024]; private byte[] date2 = new byte[1024*1024]; private byte[] date3 = new byte[1024*1024]; private byte[] date4 = new byte[1024*1024]; /*	public static void main(String[] args) { // TODO Auto-generated method stub }*/ //无参构造方法 private Hungry(){ } //new 出来一个对象 保证这个对象是唯一的了 private final static Hungry HUNGRY = new Hungry(); //给出一个对外的方法 用static 保证对外的可见性 public static Hungry getInstance(){ return HUNGRY;//饿汉式的意思就是一上来就把这个对象加载了 } } 懒汉式（完整） package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7dc256c10313febb2944a15c7fe3b46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23f386957a06ae9bee5b0c75cd35d8d0/" rel="bookmark">
			怎么查看计算机系统r2,Windows Server 2012 R2 如何找出域中的操作主机（FSMO）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		域级别主机有：RID主机，PDC主机，结构主机。
林级别主机有：域命名主机，架构主机。
下面我们通过图形界面来找出当前域中的操作主机。
首先是与级别的三个操作主机。
打开服务器管理器—工具—AD用户和计算机。
域名上右键选择操作主机。
接着我们就能看到与级别的三个操作主机了，第一个是RID主机。
第二个PDC主机。
第三个是结构主机。
接着我们查看林级别的两个主机，我们需要用到命令行，首先运行regsvr32 schmmgmt.dll(注册架构主机动态链接库文件)。
继续运行mmc(控制台)。
点击文件—添加/删除管理单元。
点击AD架构—添加—完成。
右键AD架构—操作主机。
架构主机。
域命名主机，右键—AD域和信任关系。
以上是通过图形界面来查看五种主机，下面我们通过命令行，来查看当前域中的操作主机。
运行neddom query fsmo。
查看操作主机的演示到这里就结束了，个人推荐用最后的命令行方法，比较简单，一目了然。
·
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6e4f781bc33c65e823fbf28bbb7f039/" rel="bookmark">
			Linux安装deb安装包命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		deb是Debian Linux的安装格式，跟Red Hat的rpm非常相似，最基本的安装命令是：
dpkg -i &lt;file.deb&gt; dpkg 是Debian Package的简写，是为Debian 专门开发的套件管理系统，方便软件的安装、更新及移除。所有源自Debian的Linux发行版都使用dpkg，例如Ubuntu、mint 等。
1、dpkg -i &lt;package.deb&gt; 安装一个 Debian 软件包，如你手动下载的文件。 2、dpkg -c &lt;package.deb&gt; 列出 《package.deb》 的内容。 3、dpkg -I &lt;package.deb&gt;从 《package.deb》 中提取包裹信息。 4、dpkg -r &lt;package&gt; 移除一个已安装的包裹。 5、dpkg -P &lt;package&gt;完全清除一个已安装的包裹。和 remove 不同的是，remove 只是删掉数据和可执行文件，purge 另外还删除所有的配制文件。 6、dpkg -L &lt;package&gt; 列出 《package》 安装的所有文件清单。同时请看 dpkg -c 来检查一个 .deb 文件的内容 7、dpkg -s &lt;package&gt; 显示已安装包裹的信息。同时请看 apt-cache 显示 Debian 存档中的包裹信息，以及 dpkg -I 来显示从一个 .deb 文件中提取的包裹信息。 8、dpkg-reconfigure &lt;package&gt;重新配制一个已经安装的包裹，如果它使用的是 debconf (debconf 为包裹安装提供了一个统一的配制界面) 上面就是dpkg 命令简介
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29d52fa05178049239a1e8bcf6d1097c/" rel="bookmark">
			CUDA 内存不足如何解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多小伙伴在跑pytorch的项目的时候可能会出现CUDA内存不足的情况，或者在使用GPU的时候明明显存充足却一直显示显存不足的情况，这个时候我们要怎么解决呢？接下来就来看看小编是怎么解决的吧。
小编复现大佬project发现GPU跑不动，出现如下报错：
RuntimeError: CUDA out of memory.
看下来最简单粗暴方法就是减少batch_size，慢是慢了不止一点点但至少跑得动了！
补充：Pytorch GPU显存充足却显示out of memory解决办法
今天在测试一个pytorch代码的时候显示显存不足，但是这个网络框架明明很简单，用CPU跑起来都没有问题，GPU却一直提示out of memory.
在网上找了很多方法都行不通，最后我想也许是pytorch版本的问题，原来我的pytorch版本是0.4.1，于是我就把这个版本卸载，然后安装了pytorch1.1.0，程序就可以神奇的运行了，不会再有OOM的提示了。虽然具体原因还不知道为何，这里还是先mark一下，
具体过程如下： 卸载旧版本pytorch：
conda uninstall pytorch 安装pytorch1.1.0，按照官网上的办法，我的CUDA版本是9.0：
conda install pytorch torchvision cudatoolkit=9.0 -c pytorch 大功告成！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9694966d7139e0042b50433a0ddaffd/" rel="bookmark">
			golang开发:Error的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Error是Go语言开发中最基础也是最重要的部分，跟其他语言的try catch的作用基本一致，想想在PHP JAVA开发中，try catch 不会使用，或者使用不灵活，就无法感知到程序运行中出现了什么错误，是特别可怕的一件事。
Error 基础 Golang中 error类型就是一个最基本interface，定义了一个Error()的方法
type error interface { Error() string } 平常使用最多的是这样的
errors.New("error") 在Golang中errors.New这样定义的
func New(text string) error { return &amp;errorString{text} } // errorString is a trivial implementation of error. type errorString struct { s string } func (e *errorString) Error() string { return e.s } 其实是返回了一个errorString的结构体，这个结构体实现了Error()方法，所以实现了error interface
看下Error在项目开发中是怎么使用的？
1.定义Error变量 在一段代码里面可能返回了很多个error，我怎么判断这个error是哪一种呢？
是这样的吧
var ERR_MSG = "error" if err.Error() == ERR_MSG 这样的话，多个第三方类库和自己项目的错误描述要是一致的话就无法比较出来了，其实不应该是这样的。
我们看下 beego里面orm是怎么定义的，从上面的基础我们知道errors.New返回的是errorString的指针
var ( ErrTxHasBegan = errors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9694966d7139e0042b50433a0ddaffd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50932e6b9de09a8b6c1268b9ca037f7c/" rel="bookmark">
			全国计算机互联网城市排名,中国互联网&#43;城市排名：杭州第一 北京仅排第八
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		即将结束，而互联网在今年对人们的生活更多方面又进行了更深层次的渗透，“互联网+”的概念被越来越多的应用。中国“互联网+”城市排名出炉，排名第一的是杭州，上海和南京分列二、三位，北京仅排第八。下面我们就来看看详细排名。
中国互联网+城市排名前十
排名 城市 互联网+指数
1、杭州 383.14
2、上海 237.23
3、南京 218.82
4、武汉 210.20
5、宁波 209.27
6、广州 202.26
7、深圳 193.65
8、北京 186.28
9、苏州 184.38
10、厦门 182.23
通过对全国335个城市的“互联网+”社会服务指数评测，杭州成为全国“互联网+”程度最高、生活最智慧的城市，而杭州也是阿里巴巴总部所在地，而深圳和北京仅排第七、八位，令人意外。
从全国范围看，除北上广深外，杭州、南京、宁波、苏州、武汉、长沙、郑州、成都、重庆、青岛、廊坊等区域龙头城市的电子政务和智慧城市服务覆盖率也处于较高水平。
不过在此前的腾讯的数据研究得出的结果是北京、深圳、广州、上海四个一线城市，“互联网+”指数之和占据整个中国的四分之一份额。
而最终得出的结果是北京、深圳、广州、上海、杭州、成都、重庆、武汉、长沙和福州10个城市获评中国“互联网+”十大城市。
不过有一点事实，不同城市间的差距正在拉大，甘、宁、蒙、新等地，以及东北地区的公共服务智能化水平及其增速都明显偏低。
中国“互联网+”指数覆盖移动互联发展基础、产业、创新创业、智慧城市四大板块，涵盖零售、金融、交通物流、医疗、教育、文化娱乐、餐饮住宿、旅游、商业服务、生活服务这十大行业，试图刻画中国数字经济地图，反映过去一年“互联网+”战略在全国351个城市的落地情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1ef78b2af610cecfea4b9e3ef06e3c3/" rel="bookmark">
			Pycharm 简单设置成官方中文版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用过很多的IDLE程序，（当然教学老师使用，来回切换真的头大）。这其中最大的问题就是英文版本，初次使用不习惯和英文基础不好，真的让人崩溃。
好了开始教程
1 打开pycharm 2点击file 找到setting点进去
3搜索plugins
4plugins 下搜索框里输入 chinese
安装自己需要的中文包
重启pycharm 就可以变成中文版本 再使用pycharm 就超级方便了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce03d26de4a2b8fa603efb044bac7221/" rel="bookmark">
			交换机生成树协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STP概念 STP是数据链路层协议。运行该协议的设备通过被此交互信息发现网络中的环路，井有选择的对某个端口进行阻塞，最终将环形网络结构修前成无环路的树形网络结构。从源防止报文在环形网络中不断增生和无限循环。避免设备由于重复接收相同的报文造成处理能力下降。
线路冗余——二层网络桥接环路 因为路由器的路由表是有相对完善的计算所得，且存在防环规则；故路由器物理链路上实施备份时，一般不会出现环路
但交换转发数据依赖MAC表（CAM表），该表的生成规则非常简单（记录产生），没有防环设计，故只要交换机使用链路备份，就将出现二层环路
CAM：将MAC地址+接口编号+VLAN ID进行哈希运算后，存储的哈希值
二层环路导致的问题： 广播风暴MAC地址表翻滚 --- MAC地址在交换机中的刷新时间为5min，一个接口可以对应多个MAC；但一台交换机上同一MAC地址只能对应一个接口同一数据帧的重复拷贝 生成树协议的作用： 在一个二层交换网络，逻辑的阻塞部分接口；当最佳路径故障时，自动疏通部分接口来实现链路备份
生成树：在一个二层交换网络中，生成一棵树型结构，逻辑的阻塞部分接口，使得从根到所有的节点仅存在唯一的路径；当最佳路径故障时，自动打开部分阻塞端口，来实现线路备份的作用；
生成树在生成过程中，应该尽量的生成一棵星型结构，且最短路径树
版本： 802.1D PVST/PVST+(CISCO) RSTP(CISCO) /802.1W(公有) MST=802.1S 802.1D 交换机间使用BPDU—桥协议数据单元 – 交换机间沟通互动收发的数据：
配置BPDU：
只有根网桥可以发送bpdu在交换网络初始状态时，所有交换机默认自己是根网桥，发送BPDU，所有交换机均收到其他设备的BPDU，根据参数选出根网桥，之后其他非根网桥不再发送BPDU 周期2s发送，hold time 20sTCN—拓扑变更消息（也是BPDU）本地交换机链路故障后，STP重新收敛，为了快速刷新全网所有交换机的MAC表，将向本地所有STP接口发送TCN（标记位中的TCN位置1），邻居交换机收到TCN后，先标记为ACK位为回复，用于可靠传输消息；之后将TCN逐级转发到根网桥处，由根网桥回复TC消息来逐级回复到所有交换机；使所有交换机临时将MAC表的老换时间修改为15s（默认的，转发延时） 选举 根网桥： 在每一棵生成树实例中，有且仅有一台交换机作为根桥；负责发送BPDU，计算和指 挥整个树的收敛；作为树形结构的根部，交换网络部分的中心节点 先比较网桥优先级（0-65535，默认32768），小优；若优先级一致，比较MAC地址，数值小优根端口： 在每一台非根网桥上有且仅有一个接口；本地离根网桥最近的接口，用于接收来自根网桥的BPDU，同时转发终端的数据帧；
1）比较从根网桥发出，之后通过该接口进入时最小的cost值；
2）若入向的cost相同，比较接口对端的设备的BID，小优
3）若对端设备的BID相同，那么比较对端接口的PID；小优
4）若对端设备的PID相同，那么比较本地的PID，小优
PID=端口ID = 接口优先级（0-240，默认128 小优）+ 接口编号 先比较优先级，小优；若优先级相同比较接口编号，数值小优
指定端口： 在每一段运行了STP的物理链路上有且仅有一个接口；转发来自根网桥的BPDU，同时转发终端的数据帧；根网桥上所有接口均为指定端口；根端口的对端一定为指定端口
比较转发来自根网桥的BPDU是，出项的最小cost值若出向cost值相同，比较本地的BID，小优若本地的BID相同，比较本地的PID，小优若本地PID相同，将直接阻塞该端口 非指定端口： 以上所有角色选举完成后，剩余各个接口的角色；该接口处于阻塞状态；接口阻塞是逻辑上的，并不是接口被关闭；该接口处于可以接收到数据，但不进行转发的状态 接口状态 Down ：所有接口通电后进入下一状态
侦听：交换机收发BPDU，选出所有角色；根端口、指定端口15s后进入学习状态；非指定端口进入阻塞
学习：学习终端设备发出数据帧中的源mac地址，生成交换机的MAC表（CAM表）；15s后进入转发状态
转发：根端口、指定端口可以开始转发终端的数据帧
阻塞：逻辑阻塞
802.1D的收敛时间 1、初次收敛 30s 15s侦听+15s学习
2、结构变化
1）存在直连检测 –本地仅存在一个阻塞端口可以接收到来自根网桥的BPDU；需要30s收敛
2）无直连检测 --- 20s hold time等待+30s收敛=50s
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce03d26de4a2b8fa603efb044bac7221/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4af71c06eba3dbcd6a41d2c61e28d9da/" rel="bookmark">
			全国大学生数学建模竞赛2018A题高温作业专用服装设计MATLAB程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、第1问
1.1 第一问追赶法求解差分方程与绘图MATLAB程序
二、第2问 2.1 第二问枚举法求解最优解与绘图MATLAB程序
三、第3问 3.1 第三问枚举法求解最优解与绘图MATLAB程序
一、第1问 本问主要用到了：偏微分方程转差分方程，再通过矩阵转化利用追赶法求解偏微分方程。
1.1 第一问追赶法求解差分方程与绘图MATLAB程序 %第一问追赶法求解差分方程与绘图MATLAB程序 clear; close all; r=xlsread('2018A.xlsx','附件1','M3:M6'); k=xlsread('2018A.xlsx','附件1','D3:D6'); m=xlsread('2018A.xlsx','附件1','K3:K6'); n=xlsread('2018A.xlsx','附件1','N3'); T0=xlsread('2018A.xlsx','附件2','B5403'); t0=xlsread('2018A.xlsx','附件2','A3:A5403'); a=zeros(sum(m),sum(m)); b=zeros(sum(m),1); u=zeros(sum(m)+1,n+1); he=linspace(8,9,100); for z=1:100 h=0.0001; u(:,1)=37; u(1,:)=75; %a矩阵 for i=1:(sum(m)) if i==1 a(i,i)=1+2*r(1); a(i,i+1)=-r(1); end if (1&lt;i)&amp;&amp;(i&lt;m(1)) a(i,i)=1+2*r(1); a(i,i-1)=-r(1); a(i,i+1)=-r(1); end if (i==m(1)) a(i,i)=(k(1)+k(2))/h; a(i,i-1)=-k(1)/h; a(i,i+1)=-k(2)/h; end if (m(1)&lt;i)&amp;&amp;(i&lt;(m(1)+m(2))) a(i,i)=1+2*r(2); a(i,i-1)=-r(2); a(i,i+1)=-r(2); end if i==(m(1)+m(2)) a(i,i)=(k(2)+k(3))/h; a(i,i-1)=-k(2)/h; a(i,i+1)=-k(3)/h; end if ((m(1)+m(2))&lt;i)&amp;&amp;(i&lt;(m(1)+m(2)+m(3))) a(i,i)=1+2*r(3); a(i,i-1)=-r(3); a(i,i+1)=-r(3); end if i==(m(1)+m(2)+m(3)) a(i,i)=(k(3)+k(4))/h; a(i,i-1)=-k(3)/h; a(i,i+1)=-k(4)/h; end if ((m(1)+m(2)+m(3))&lt;i)&amp;&amp;(i&lt;(m(1)+m(2)+m(3)+m(4))) a(i,i)=1+2*r(4); a(i,i-1)=-r(4); a(i,i+1)=-r(4); end if i==(m(1)+m(2)+m(3)+m(4)) a(i,i)=k(4)/h+he(z); a(i,i-1)=-k(4)/h; end end %b矩阵 for s=2:n+1 for t=1:(sum(m)) if t==1 b(t,1)=u(2,s-1)+r(1)*u(1,s); end if t&gt;1 b(t,1)=u(1+t,s-1); end b(m(1),1)=0; b((m(1)+m(2)),1)=0; b((m(1)+m(2)+m(3)),1)=0; b((m(1)+m(2)+m(3)+m(4)),1)=37*he(z); end %追赶法求解 bb=diag(a)'; aa=[0,diag(a,-1)']; c=diag(a,1)'; N=length(bb); L=zeros(N); uu0=0;y0=0;aa(1)=0; L(1)=bb(1)-aa(1)*uu0; y(1)=(b(1)-y0*aa(1))/L(1); uu(1)=c(1)/L(1); for i=2:(N-1) L(i)=bb(i)-aa(i)*uu(i-1); y(i)=(b(i)-y(i-1)*aa(i))/L(i); uu(i)=c(i)/L(i); end L(N)=bb(N)-aa(N)*uu(N-1); y(N)=(b(N)-y(N-1)*aa(N))/L(N); x(N)=y(N); for i=(N-1):-1:1 x(i)=y(i)-uu(i)*x(i+1); end u(2:sum(m)+1,s)=x'; end if u(153,5401)&lt;=T0 hee=he(z); break end end x=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4af71c06eba3dbcd6a41d2c61e28d9da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2665252702e3366468de01b3040e2455/" rel="bookmark">
			typeScript学习笔记-接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//参数接口 设定一个标准，这个参数以后只能传这两个参数 interface FnName{ name:string; age:number; } function getName(obj:FnName):void{ console.log(obj,'obj'); } getName({name:'张三',age:24}); //函数接口 interface Fun{ (name:string):string } let getName1:Fun=function(name:string):string{ return name; } console.log(getName1('小明')); //数组可索引接口 interface arrayFn{ [index:number]:string; } let arr:arrayFn=['1','2','3']; console.log(arr,'arr'); //对象可索引接口 interface objFn{ [index:string]:string } let obj:objFn = {name:'张三',age:'18'} console.log(obj,'obj'); //类接口 interface Animal{ name:string; eat(val:string):string; } class Dog implements Animal{ public name:string; constructor(name:string){ this.name=name; } eat(val:string):string{ return this.name+val; } } let dog = new Dog('小黑'); console.log(dog.eat('吃狗粮')); interface people extends Animal{ word(val:string):void; } class Programmer implements people{ name:string; constructor(name:string){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2665252702e3366468de01b3040e2455/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/863e28d6be4091e65195b772b8df39cf/" rel="bookmark">
			通过@Aspect切面自定义注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一种通过切面编程来自定义注解，以下代码demo是通过自定义注解对加密参数进行验证的过程，不用关心代码的业务过程，直接看通过@Aspect是如何自定义注解的，有了以下代码，springboot工程中的主类还需要加
@EnableAspectJAutoProxy 注解 直接看代码：
@Documented @Target({ElementType.PARAMETER, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) public @interface SignCheck { } @Slf4j @Aspect @Configuration public class SignCheckAspect { private String secret = "123123"; private Long expire = (1000 * 60) * 2L; // 定义切点方法 @Pointcut("@annotation(com.ecej.ecejcomponents.basic.anotation.SignCheck)") public void pointCut() { } @Around("pointCut()") public void around(ProceedingJoinPoint joinPoint) { String signStr = RequestUtils.getHeader("sign"); // 拦截的类名 Class clazz = joinPoint.getTarget().getClass(); // 拦截的方法 Method method = ((MethodSignature) joinPoint.getSignature()).getMethod(); SignCheck annotation = method.getAnnotation(SignCheck.class); if (annotation !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/863e28d6be4091e65195b772b8df39cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd8a0d72e80ff8efe7c89a59d9a9816f/" rel="bookmark">
			伺服驱动器--增益调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		增益调整 1.1 惯量辨识1.2 刚性等级1.2.1 刚性等级设定1.2.2微调参数 1.3 指令滤波1.4 机械特性曲线1.5 项目实战：3.1、刚性等级15 的情况下分析曲线3.2、刚性等级28 的情况下分析曲线3.3、刚性等级22 的情况下分析曲线**补充说明：**采样频率采样周期换算公式 增益调整分为快速调整和自整定。快速调整是通过修改刚性等级找到一个合适的增益参数，若刚性等级不满足使用需求，可以在所设刚性等级下修改响应性参数和刚性参数。自整定分为内部指令自整定和外部指令自整定。自整定（内部指令自整定）是指，不从上位装置发出指令，伺服单元进行自动运行（正转及反转的往复运动），在运行中根据机械特性进行调整的功能。自整定（外部指令自整定）是针对来自上位装置的运行指令自动进行最佳调整的功能。 1.1 惯量辨识 （转动惯量(Momentum of Inertia)，是刚体绕轴转动时惯性（回转物体保持其匀速圆周运动或静止的特性）的量度，用字母I或J表示。 [1] 在经典力学中，转动惯量（又称质量惯性矩，简称惯矩）通常以I 或J表示，SI 单位为 kg•m²。对于一个质点，I = mr²，其中 m 是其质量，r 是质点和转轴的垂直距离。转动惯量在旋转动力学中的角色相当于线性动力学中的质量，可形式地理解为一个物体对于旋转运动的惯性，用于建立角动量、角速度、力矩和角加速度等数个量之间的关系。)
1、点动配置
设置——限位运动速度，点击【伺服使能】。
设置——软件反向限位，点击【确认】。
设置——软件正向限位，点击【确认】，弹出提示框，点击确定。
2. 手动设定
设置行程圈数。
设置运动方向，点击确定，弹出提示对话框，点击确定。
1.2 刚性等级 (在伺服电机的应用中，用联轴器来连接电机和负载，就是典型的刚性连接。而用同步带或者皮带来连接电机和负载，就是典型的柔性连接。电机刚性就是电机轴抗外界力矩干扰的能力，而我们可以在伺服控制器调节电机的刚性。伺服电机的机械刚度跟它的响应速度有关。一般刚性越高其响应速度也越高，但是调太高的话，很容易让电机产生机械共振。所以，在一般的伺服放大器参数里面都有手动调整响应频率的选项，要根据机械的共振点来调整，需要时间和经验（其实就是调增益参数）。在伺服系统位置模式下，施加力让电机偏转，如果用力较大且偏转角度较小，那么就认为伺服系统刚性强，反之则认为伺服刚性弱。注意这里我说的刚性，其实更接近响应速度这个概念。从控制器角度看的话，刚性其实是速度环、位置环和时间积分常数组合成的一个参数，它的大小决定机械的一个响应速度。
像松下和三菱伺服都有自动增益功能，通常不需要特别去调整。国产的一些伺服，只能够手工调整。
其实如果你不要求定位快，只要准，在阻力不大的时候，刚性低，也可以做到定位准，只不过定位时间长。因为刚性低的话定位慢，在要求响应快，定位时间短的情况下，就会有定位不准的错觉。
1.2.1 刚性等级设定 若机器产生较大噪声，则不宜增加刚性等级。增加刚性等级过程中，若产生共振，需要先消除共振，再尝试增加。
1.2.2微调参数 若刚性等级不满足使用需求，可以在所设刚性等级下修改响应性参数和刚性参数。一般仅需要修改响应性参数P2-49。
1.3 指令滤波 1.4 机械特性曲线 陷波器通过降低特定频率处的增益，可达到抑制机械共振的目的。正确设置陷波器后，振动可以得到有效抑制，可尝试继续增大伺服增益。
电机发生共振后点击机械特性的测定，机械特性测定完成之后会生成机械特性曲线，点击指针中显示的复选框，找到共振频率点，在曲线图上点击鼠标左键，可以得到幅频和相频的数值，将频率的值输入到陷波器设置的频率中，点击写入即可。
1.5 项目实战： 调试要求：指令给定完成时间到伺服定位完成时间要小于10ms，且没有振动。
电机的额定电流：4A
电机峰值电流：12A。
步骤
1、伺服正确完成接线，电机代码设置正确，点动和试运行无误，安装负载。
2、打开【增益调整】中的【快速调整】界面，推定惯量。
3.1、刚性等级15 的情况下分析曲线 打开刚性等级界面，默认情况下刚性等级为15，（若使能后遇到机械振动请使用机械特性分析功能，消除共振。）
点击【波形曲线】中的【曲线采集】，打开【曲线采集】界面。
选择采样模式为手动触发，采样频率选择1000，采样周期选择1024，采样占比选择100，配置通道，若没有特殊要求，默认即可。伺服处于运行状态，点击【手动触发】，待读取数据由灰变亮后，点击【读取数据】，数据采集后绘制成曲线显示。刚性等级15（默认）情况下的位置指令和位置反馈曲线。在图形中按住鼠标左键拖拽，可以放大位置指令和位置反馈曲线。添加游标比较功能，分析位置曲线响应时间。在刚性等级15 的情况下可以看出，指令给定完成时间到伺服定位完成时间为15ms，不符合调试要求。
刚性等级15（默认）情况下的转矩电流指令和转矩电流反馈曲线。电机的额定电流为4A，峰值电流为12A。借助游标比较功能可以看出转矩电流反馈、转矩电流指令的最大值和最小值均未达到峰值电流，刚性等级可以继续增加。
3.2、刚性等级28 的情况下分析曲线 增大刚性等级，重新采集曲线。刚性等级28 的情况下，采集曲线。曲线采集分析，添加游标，指令给定完成时间到伺服定位完成时间为6ms，但是刚性等级略高，电机产生振动，不符合调试要求。刚性等级28 情况下的转矩电流指令和转矩电流反馈曲线。电机的额定电流为4A，峰值电流为12A。借助游标比较功能可以看出转矩电流反馈、转矩电流指令的最大值和最小值均未达到峰值电流，但是电机的电流声过大且有振动，不符合要求，需降低刚性等级。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd8a0d72e80ff8efe7c89a59d9a9816f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dfb1c38abc89dbaba914edb41ca5097/" rel="bookmark">
			初中信息技术计算机系统组成,初中信息技术计算机系统的组成(硬件)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初中信息技术计算机系统的组成(硬件) (22页)
本资源提供全文预览，点击全文预览即可全文预览,如果喜欢文档就下载吧，查找使用更方便哦！
19.90 积分
第 1 章 计 算 机 基 础 知 识上一页 下一页 返回本章首页 第 1 章 计 算 机 基 础 知 识二、计算机系统的组成 上一页 下一页 返回本章首页 第 1 章 计 算 机 基 础 知 识现今流行的计算机外观 上一页 下一页 返回本章首页 第 1 章 计 算 机 基 础 知 识上一页 下一页 返回本章首页 第 1 章 计 算 机 基 础 知 识 存取速度快， 主存 但容量较小 (内存)主机中内存条 RAM 容量大，成 本低，但存 辅存 取速度较慢 (外存) 上一页 下一页 返回本章首页 第 1 章 计 算 机 基 础 知 识 内存和外存的区别 内存和外存本质的区别是能否被中央处理器(CPU)直接访问。CPU不能直接执行外存中的程序，处理外存中的数据。两者的主要区别是： 从原理上讲位置不同，主机内还是主机外； 构 成 材 料 不 同 ， 半 导 体 还 是 磁 介 质 ( 光 介 质 ) ； 存储容量不同，内存小，外存大； 价格不同：价格/每存储单元内存高，外存低； 存取速度不同：内存高，外存低。 上一页 下一页 返回本章首页 第 1 章 计 算 机 基 础 知 识 RAMROM 是一种读写存储器，存放最基本的输入输出控制程序； 其内容可以随时根据其中的信息只能读出不能写入； 需要读出或写入；断电后信息不会丢失。 断电后信息丢失。 上一页 下一页 返回本章首页 第 1 章 计 算 机 基 础 知 识上一页 下一页 返回本章首页 第 1 章 计 算 机 基 础 知 识上一页 下一页 返回本章首页 第 1 章 计 算 机 基 础 知 识存储容量练习 上一页 下一页 返回本章首页 第 1 章 计 算 机 基 础 知 识上一页 下一页 返回本章首页 第 1 章 计 算 机 基 础 知 识上一页 下一页 返回本章首页 第 1 章 计 算 机 基 础 知 识上一页 下一页 返回本章首页 第 1 章 计 算 机 基 础 知 识上一页 下一页 返回本章首页 第 1 章 计 算 机 基 础 知 识 微机常用的输入输出设备 键盘 输入设备 鼠标器 扫描仪 CRT和LCD显示器。 显示器 SVGA、TVGA。 常用 隔行扫描和逐行扫描。外部设备 分辩率：1024?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dfb1c38abc89dbaba914edb41ca5097/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c4af47c8d4eae7e0a4e1189330b1cb6/" rel="bookmark">
			JS运动总结封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS运动总结封装 1.匀速运动,往返运动 //第一个参数为需要移动的元素，第二个为速度， //第三个为目标，第四个前进按钮，第五个后退按钮 function constantBack(node, speed, target, node1, node2) { let time = null; let time1 = null node1.addEventListener("click", function() { clearInterval(time) clearInterval(time1) time = setInterval(() =&gt; { node.style.left = node.offsetLeft + speed + "px" if (node.offsetLeft &gt; target) { node.style.left = target + "px" clearInterval(time) } }, 50); }) node2.addEventListener("click", function() { clearInterval(time) clearInterval(time1) time1 = setInterval(() =&gt; { node.style.left = node.offsetLeft - speed + "px" if (node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c4af47c8d4eae7e0a4e1189330b1cb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d325bfab84b95d1621c779490a4b6ac8/" rel="bookmark">
			npm使用的常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
npm使用的常见问题 **
npm全局环境下的下载包的路径 可以在C/用户/USER里的npmrc里设置；
如果在使用的途中发现，无法加载文件，因为在此系统上禁止运行脚本
1.管理员身份打开powerShell
2.输入set-ExecutionPolicy RemoteSigned
.3 选择Y 或者A ，就好了
npm尾缀 -g是全局安装
-S
即–save（保存）
包名会被注册在package.json的dependencies里面，在生产环境下这个包的依赖依然存在
-D
即–dev（生产）
包名会被注册在package.json的devDependencies里面，仅在开发环境下存在的包用-D，如babel，sass-loader这些解析器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dd62f9dae9df295220f9d8ca477b9c7/" rel="bookmark">
			eeglab教程系列(4)-绘制通道光谱图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行通道光谱图绘制前，需要先按照eeglab教程系列(3)-绘制脑电头皮图进行先操作(只需操作完第二步后点击OK即可)。
绘制通道光谱图
在eeglab界面进行如下操作：Plot &gt; Channel spectra and maps，会打开pop_spectopo.m界面。
根据需求设置参数，这里采用默认设置，点击OK,会跳转到spectopo.m界面：
这幅图是在采样15%的数据得到的结果，[15%是在第一幅图中红框中设置]。也可以设置为100%，设置100%的效果图为:
上面图中，每个彩色记录道表示一个数据通道活动的频谱。最左边的头皮图显示了6赫兹时头皮的能量分布，这些数据集中在额叶中线。其他的头皮图显示了10赫兹和22赫兹的能量分布。
想要看详细的信息，可以单击每个小图，比如单击6赫兹的脑图，会得到如下结果：
可以操作：Plot &gt; Channel properties 来绘制所选通道的头皮位置，其活动范围以及其活动在单个时期内的ERP图像。
可以在红框处编辑通道数，这里填写通道1.点击OK出现如下界面：
上图红色处为所选通道的头皮位置，上图还包括活动范围以及其活动在单个时期内的ERP图像。
不用于商业行为，转载请联系后台
若有侵权，请后台留言，管理员即时删侵！
更多阅读
EEG伪影类型详解和过滤工具的汇总(一)
Nature子刊：基于水凝胶的灵活脑机接口
重磅！用脑机接口首次让患者输出完整句子
EEG伪影详解和过滤工具的汇总(二)
P300脑机接口及数据集处理
Neuralink的脑机接口：目标是破世界纪录！
脑机产业“新标准”，CESI发布《脑机接口标准化白皮书》
脑电分析系列[MNE-Python-13]| "bad"通道介绍
投稿通道
如何让你的工作让更多人知晓和受益？
脑机接口社区就是这样一个连接学界、
企业界和爱好者的平台渠道。
社区鼓励高校实验室、企业或个人在我们平台上分享优质内容。
稿件要求
稿件系个人原创作品，若已在其他平台发表，请明确标注。
稿件一经录取，便提供稿费！
投稿通道
微信扫码，备注：投稿+姓名+单位
微信交流群，请扫码上方微信
(备注：姓名+单位+专业/领域/行业)
QQ交流群：913607986
你的每一次在看，我都很在意！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76a50e57c9e56e1100313e1640713474/" rel="bookmark">
			mvn基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mvn dependency:get -Dartifact=GROUPID:ARTIFACTID:VERSION:PACKAGING:CLASSIFIER -DrepoUrl=repo1.maven.org #单个包下载
https://mvnrepository.com/ #可以查看对应版本和依赖配置
http://maven.apache.org/download.cgi # mvn工具下载
https://www.oracle.com/technetwork/java/javase/downloads/index.html # jdk下载
集成工具：IntelliJ IDEA
在线帮助文档(插件)： http://maven.apache.org/plugins/index.html 命令帮助：
mvn help:describe -Dplugin=dependency
mvn help:effective-pom
mvn help:active-profiles
mvn help:effective-settings
初始化：
mvn archetype:generate
jar文件：
只包含class文件和清单文件，不包含资源文件，比如图片等所有的 res下的资源文件；
aar文件：
class以及res下的所有的资源文件全部包含；
war：
是一个web模块,其中需要包括WEB-INF,是可以直接运行的WEB模块
zip：
mvn compile # 编译
mvn package # mvn 打包命令
mvn install #下载依赖，打包本地
mvn deploy #上传
mvn antrun:run：打印属性
配置文件：${user.home}/.m2/settings.xml 全局配置路径为： maven安装路径/conf/settings.xml
本地仓库：默认是~/.m2/repository，可在配置文件中设置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92f6a908ebf36ebfcc2405fad9f4baee/" rel="bookmark">
			TDengine安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快捷安装 TDengine软件分为服务器、客户端和报警模块三部分，目前2.0版服务器仅能在Linux系统上安装和运行，后续会支持Windows、Mac OS等系统。客户端可以在Windows或Linux上安装和运行。任何OS的应用也可以选择RESTful接口连接服务器taosd。CPU支持X64/ARM64/MIPS64/Alpha64，后续会支持ARM32、RISC-V等CPU架构。 您可根据需求选择通过源码或者安装包来安装。
查看完整的Release notes，请点击这里。下载其他组件、最新beta版及之前版本的安装包，请点击这里。 具体的安装过程，请参见TDengine多种安装包的安装和卸载 以及视频教程。
通过源码安装 请参考我们的TDengine github主页下载源码并安装.
通过Docker容器运行 暂时不推荐生产环境在 Docker 内部署 TDengine 的客户端或服务端，但在开发环境下或初次尝试时，使用 Docker 方式部署是十分方便的。特别是，利用 Docker，可以方便地在 Mac OSX 和 Windows 环境下尝试 TDengine。
直接运行：docker run tdengine/tdengine 即可
更详细的步骤说明，请参考通过Docker快速体验TDengine
通过安装包安装 TDengine 的安装非常简单，从下载到安装成功仅仅只要几秒钟。为方便使用，标准的服务端安装包包含了客户端程序、各种编程语言的连接器和示例代码；如果您只需要用到服务端程序和客户端连接的 C/C++ 语言支持，那么也可以仅下载 lite 版本的安装包。在安装包格式上，我们提供 rpm、deb、tar.gz 三种，以方便在特定操作系统上使用，您可以根据需要选择下载：
TDengine-server-2.1.4.1-beta-Linux-x64-Lite.tar.gz (2.7M)TDengine-server-2.1.4.1-beta-Linux-x64.rpm (8.9M)TDengine-server-2.1.4.1-beta-Linux-x64.deb (7.2M)TDengine-server-2.1.4.1-beta-Linux-x64.tar.gz (9.3M)TDengine-server-2.0.20.9-Linux-x64.rpm (4.5M)TDengine-server-2.0.20.9-Linux-x64.deb (2.8M)TDengine-server-2.0.20.9-Linux-x64.tar.gz (4.9M) 客户端 如果客户端和服务端运行在不同的电脑上，可以单独安装客户端。Linux 和 Windows 安装包如下（其中 lite 版本的安装包仅带有 C/C++ 语言的连接支持，而标准版本的安装包还包含 Java、Python、Go、Node.js 等编程语言的连接器支持和示例代码）：
TDengine-client-2.1.4.1-beta-Linux-x64-Lite.tar.gz(2.4M)TDengine-client-2.1.4.1-beta-Linux-x64.tar.gz(8.0M)TDengine-client-2.1.4.1-beta-Windows-x64.exe(3.4M)TDengine-client-2.1.4.1-beta-Windows-x86.exe(3.4M)TDengine-client-2.0.20.9-Linux-x64.tar.gz(3.6M)TDengine-client-2.0.20.9-Windows-x64.exe(3.7M)TDengine-client-2.0.20.9-Windows-x86.exe(3.4M) 轻松启动 安装成功后，用户可使用systemctl命令来启动TDengine的服务进程。
systemctl start taosd 检查服务是否正常工作。
systemctl status taosd 如果TDengine服务正常工作，那么您可以通过TDengine的命令行程序taos来访问并体验TDengine。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92f6a908ebf36ebfcc2405fad9f4baee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8348622d1581c68d9aaeb73667b77d7d/" rel="bookmark">
			HTTP(REST)和RPC的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是RPC和REST 在 OpenStack 里的进程间通信方式主要有两种，一种是基于HTTP协议的RESTFul API方式，另一种则是RPC调用。
RESTful主要用于各组件之间的通信（如nova与glance的通信），或者说用于组件对外提供调用接口。
RPC 则用于同一组件中各个不同模块之间的通信（如nova组件中nova-compute与nova-scheduler的通信）
1、所属类别不同 REST指的是某个瞬间状态的资源数据的快照，包括资源数据的内容、表述格式（XML、JSON）等信息。REST是一种软件架构风格（HTTP是最典型：简单、扩展性强）
RPC可以实现客户端像调用本地服务一样屌用服务器的方法，RPC 可以基于 TCP/UDP，也可以基于 HTTP 协议进行传输，与HTTP（REST）不是一个层面意义上的东西。
2、使用方式不同 HTTP接口只需关注服务提供方，对于客户端并不关心。客户端在调用对应接口的时候只要保证数据返回就可以了。
RPC是服务端提供好方法给客户端调用，客户端需要知道服务端的具体类，具体方法，然后像调用本地方法一样直接调用它。
3、面向对象不同 HTTP是面向资源的，而RPC是面向方法的。
4、序列化协议不同 通信协议：REST 是 基于 HTTP 协议，而 RPC 可以基于 TCP/UDP，也可以基于 HTTP 协议进行传输的。
序列化协议：json、xml、hession、protobuf、thrift、text、bytes等
HTTP 通常使用的是 JSON或者XML
RPC 使用的是 JSON-RPC，或者 XML-RPC
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4addc7f05658923b19723d7edfda68d/" rel="bookmark">
			一文搞懂考研数列极限问题(概念/计算/证明)史上最强/最全总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不管本科高数还是考研数学，数列极限问题，看这一篇文章管够，看完还不会做你来找我！ 数列极限，是数列和极限两个充满不确定性的概念相混合，容易让人产生摸不着头脑，看到题目就害怕的感觉，本篇文章就按以下目录对这块儿重难点拨云见日，内容循序渐进，越往后越精彩，大家可以自行感受一下！
01 什么是数列
02 数列的极限
03 数列极限的计算(三种类型)
04数列相关证明题(两种类型)
01 什么是数列？(掌握难度：★) 从字面意思就可以看出来：数列数列，就是将数排成队列。详细点来说，就是将一堆数按照某种规律排成一排，p.s.类似军训，教官让我们按照从矮到高(某种规律)排成一排。
这时，有个数在开小差，教官就开始点名了。还记得我们当时军训时教官是怎么点名的么?
“第m排第n列,请出列”——这耳熟能详的语句。
由于我们的数只有一列，所以我们就变成了，“第n个数请出列”。为了描述方便我们用符号 x n x_{n} xn​ 表示，含义为第n个数，于是就有 x 1 = 1 2 ， x 4 = 1 16 ， x 5 = 1 32 x_{1}=\frac{1}{2} ， x_{4}=\frac{1}{16} ， x_{5}=\frac{1}{32} x1​=21​，x4​=161​，x5​=321​。如果可以用某个含n的式子来表示 x n x_{n} xn​ ，那么这个式子就叫做这个数列的通项公式，例如本文举例的数列，它的通项公式就是： x n = 1 2 n x_{n}=\frac{1}{2^{n}} xn​=2n1​ 。有了它，我们就可以快速get这一列数中的每一个数，是不是很方便。
但是，人总是贪心的。所以一定会有人问：“你不是说每一项你都知道么？那么第无穷项是多少呢？”这个时候就涉及到了数列的极限。
02 数列的极限(掌握难度：★★) 针对刚刚的问题——数列{ x n x_{n} xn​ }的“无穷项”是多少？即当 n → ∞ n\rightarrow\infty n→∞ 时， x n x_{n} xn​ 趋近于多少。可见这是一个极限问题，用数学式来表示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4addc7f05658923b19723d7edfda68d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/380ccfd46fef9386cfb642a0730b95cf/" rel="bookmark">
			Qt5.5.0交叉编译及openssl支持
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		X86平台交叉编译aarch64平台
操作系统：CentOS7.9.2009
交叉编译器的配置，网上有很多，我使用的是：
gcc-linaro-5.5.0-2017.10-x86_64_aarch64-linux-gnu.tar.xz
默认源代码交叉编译，不带openssl很简单，直接编译就可以。
这里只描述openssl支持。
1、首先交叉编译openssl库
下载openssl源代码，下载版本我是这样决定的，运行openssl version查看当前平台的openssl版本，然后下载对应版本的openssl源代码
解压后，交叉编译命令：
源代码加压在：/opt/openssl-1.0.2k
cd /opt/openssl-1.0.2k/
./config no-asm shared no-async --prefix=$(pwd)/install --cross-compile-prefix=aarch64-linux-gnu-
注意这里，最后面就是gnu- 没有gcc或g++
可能会提示m64错误
cc1: error: unrecognized command line option "-m64" vi 打开Makefile 将编译选项中的 -m64 删掉,还有一个是m64的配置，直接注释即可
保存后，重新执行config，成功后，执行make &amp;&amp; make install
make install完成后，会在安装在当前目录的install目录
好了，到这里openssl交叉编译完成了
现在来看Qt交叉编译。
下载Qt对应版本的源代码，我用的是Qt5.5.0
放在/opt目录下
cd /opt/qt-everywhere-opensource-src-5.5.0/ ./configure -v -release -extprefix /opt/aarch64-qt -xplatform linux-aarch64-gnu-g++ -no-opengl -nomake tests -no-compile-examples -nomake examples -qt-libpng -qt-libjpeg -qt-sql-sqlite -openssl -I/opt/openssl-1.0.2k/install/include -L/opt/openssl-1.0.2k/install/lib -lssl -lcrypto 重要的是openssl选项
-openssl -I/opt/openssl-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/380ccfd46fef9386cfb642a0730b95cf/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/348/">«</a>
	<span class="pagination__item pagination__item--current">349/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/350/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>