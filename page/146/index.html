<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c50b8535e33a1e8ef7c6e2f91cd21d33/" rel="bookmark">
			一分钟内用9条命令查看服务器性能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、uptime 命令
uptime 这条命令用来查看机器的负载情况，命令的输出分别表示1分钟、5分钟、15分钟的平均负载情况
2、dmesg命令
dmesg | tail 这条命令则是输出系统日志的后10行，这些日志信息能帮助排查性能问题，所以这个命令千万不要漏掉了哟
3、vmstat命令
vmstat 1 这条命令可以输出系统核心指标，后面的参数1表示每秒输出一次统计信息。这些指标可以让我们更详细地了解系统的状态
4、mpstat命令
这条命令是需要下载后才能使用的，下载如下
yum -y install sysstat 使用
mpstat -P ALL 1 这条命令可以显示每个CPU的占用情况，如果有一个CPU占用率特别高，那么就很有可能是运行了一个单线程应用引起的
5、pidstat命令
pidstat 1 这条命令可以输出进程的CPU利用率，而且会持续输出还不会覆盖之前输出的数据。可以更加方便观察系统的动态。
6、iostat命令
iostat -xz 1 这条命令则是用来查看机器磁盘的I/O情况，值得注意的是，读写量过大可能会引起性能问题。当然，即使I/O性能不理想就代表这这个应用程序性能也不怎么样，咱们可以利用一些如读、写缓存的策略来提高应用的性能
7、free命令
free -m 这条命令可以查看系统内存的使用情况，而 -m 表示按照兆字节来展示。值得注意的是如果可用内存非常少，如果你配置了交换分区，系统就有可能会使用这个交换分区，这样的话就会增加I/O的开销，导致系统性能降低。
8、sar命令
sar -n DEV 1 这条命令用于查看网络设备的吞吐率
sar -n TCP,ETCP 1 而这条命令则可以查看TCP的连接状态
9、top命令
top 这条命令可以相对全面的查看系统负载的来源，同时top命令支持排序，方便找出一些比如内存占用最多的进程、CPU占用率最高的进程等的信息。值得注意的是 top 命令输出的是瞬间值，需要一直盯着，不然会错过一些重要的信息，这时我们就有可能需要暂停top刷新来对比数据了。
好啦，整理出来的命令希望对各位有所帮助
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/306dba4f16d623fd3b795700c3032300/" rel="bookmark">
			Ubuntu18.04安装opencv和opencv_contrib
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu18.04安装opencv和opencv_contrib 目录
Ubuntu18.04安装opencv和opencv_contrib
1. 版本
2.源码编译和安装opencv和opencv_contrib
(1) 下载opencv和opencv_contrib源码
(2) 安装 OpenCV相关依赖库
(3) 源码编译
(4) android studio中使用opencv_contrib
3.一些异常处理
1.undefined reference to `TIFFReadDirectory@LIBTIFF_4.0'
2.usr/lib/x86_64-linux-gnu/libvtkIOImage-6.3.so.6.3：对‘TIFFReadDirectory@LIBTIFF_4.0’未定义的引用
4.Windows安装opencv和opencv_contrib
【尊重原创，转载请注明出处】https://blog.csdn.net/guyuealian/article/details/127400841
1. 版本 以安装opencv-4.3.0和opencv_contrib-4.3.0为例子，其他版本编译原则上步骤一样，但需确保opencv和opencv_contrib的版本号一致，避免版本差异导致编译错误。
库本地使用版本下载地址说明UbuntuUbuntu18.04-本机系统 opencv
opencv-4.3.04.3.0opencv-3.2.0以上亦可opencv_contribopencv_contrib-4.3.04.3.0 opencv_contrib-3.2.0以上亦可 2.源码编译和安装opencv和opencv_contrib (1) 下载opencv和opencv_contrib源码 opencv-4.3.0：Release OpenCV 4.3.0 · opencv/opencv · GitHubopencv_contrib-4.3.0：Release 4.3.0 · opencv/opencv_contrib · GitHub (2) 安装 OpenCV相关依赖库 首先安装 OpenCV 所需要的依赖库，在终端依次执行以下命令：
sudo apt-get update sudo apt-get install build-essential sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev (3) 源码编译 解压 opencv-4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/306dba4f16d623fd3b795700c3032300/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6659f063087cfedf5fbb93dcbcb7ae44/" rel="bookmark">
			Https证书/SSL证书异常导致访问失败该如何解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在使用SSL证书时，经常会碰到一些常见的SSL证书错误，例如浏览器提示证书无效，证书在地址栏中被红色警告等等。下面是关于SSL证书错误的几种原因及解决方法。
1.报错：NET::ERR_CERT_DATE_INVALID
原因：SSL证书已过期
解决方案：证书已过期并删除，重新申请新证书并正确安装可以解决错误。
2.报错：NET::ERR_CERT_COMMON_NAME_INVALID
原因：网站使用的证书与域名不匹配
解决方案：证书支持的域名与网站域名不一致。换句话说，网站使用了错误的证书。解决方案是重新安装网站SSL证书[1]。
3.报错：NET::ERR_CERT_AUTHORITY_INVALID
原因：网站使用无效证书颁发机构颁发的证书
解决方案：该错误表明网站使用的证书的根证书不受浏览器的信任，可能是用户使用自签名证书，也可能是该证书的根证书被吊销。解决方案是重新申请浏览器信任的证书颁发机构颁发的证书。
4.报错：NET::ERR_CERT_REVOKED
原因：网站使用的证书已被吊销
解决方案：证书颁发机构因企业信息变更或网站内容违规等原因吊销证书，证书进入证书吊销清单CRL。我们需要重新申请证书并正确部署。
5.报错：NET::ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN
原因：网站使用证书和网站内置证书HTTP公钥固定不匹配
解决方案：网站可能被劫持，我们需要检查网站DNS分析恢复正常HTTPS访问；也有可能HPKP谷歌浏览器报错是因为没有正确的设置。
6.报错：NET::ERR_CERT_WEAK_SIGNATURE_ALGORITHM
原因：网站使用不安全的签名算法
解决方案：数字签名算法用于通信双方的身份验证，如果使用不安全SHA-1签名算法浏览器会报错。我们应该使用SHA-256签名算法。
7.报错：ERR_SSL_VERSION_OR_CIPHER_MISMATCH
原因：网站使用浏览器不支持的加密协议版本或加密套件
解决方案：错误报告在低版本的操作系统或浏览器中更为常见。
SSL证书错误有很多潜在的原因，排除问题往往很麻烦。然而，迅速处理这个问题是至关重要的。如果我们自己在自己的站点上看到这个错误，那么其他人可能也会遇到这个错误。由于这个错误有很多原因，你可以先尝试下刷新站点、校正本地时间。然后再尝试其他更多的方法，比如清除 SSL 缓存或者测试浏览器插件等。
JoySSL官网
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e498a408859411fe2d9645f77aefb476/" rel="bookmark">
			SpleeterGUI 歌曲人声伴奏分离软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpleeterGUI: https://makenweb.com/SpleeterGUI
Spleeter: https://github.com/deezer/spleeter
SpleeterGUI最新版本为v2.9.4.0，已停止更新
运行时可能会遇到报错
ValueError: Can’t load save_path when it is None
需要下载https://github.com/deezer/spleeter/releases/download/v1.4.0/2stems.tar.gz(需要梯子)，
并解压到/pretrained_models/2stems
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5bfd9be0ebc053d120ed0c78bac5af6/" rel="bookmark">
			Android：LeakCanary原理的简单理解和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LeakCanary原理的简单理解和使用 1、背景2、LeakCanary2.1、LeakCanary 工作原理2.1.1、检测未被 GC 回收的对象2.1.2、转储堆2.1.3、分析堆2.1.4、对泄漏进行分类 2.2、LeakCanary 使用2.2.1、引入依赖2.2.1.1、原理 2.2.2、配置 LeakCanary2.2.3、检测内存泄漏 3、Fragment 和 Activity 的监听4、源码分析4.1、ReferenceQueue说明4.2、注册监听入口（第三节）4.3、Watcher和Activity的监测时机4.4、Fragment的监测时机4.5、ViewModel的检测时机4.6、总结 5、优缺陷6、简单实现leakcanary，简化版，没有dump参考 1、背景 LeakCanary，由Square开源的一款轻量第三方内存泄露检测工具。能够在不影响程序正常运行的情况下，动态收集程序存在的内存泄露问题。小的内存泄露可能不会直接导致程序崩溃，但随着数量增多，量变引起质变，造成内存溢出，程序崩溃。
2、LeakCanary 2.1、LeakCanary 工作原理 安装 LeakCanary 后，它会自动检测并报告内存泄漏，分为以下 4 个步骤：
1、检测未被 GC 回收的对象2、转储堆3、分析堆4、对泄漏进行分类 2.1.1、检测未被 GC 回收的对象 LeakCanary Hook 到 Android lifecycle 以自动检测 Activitis 和 Fragments 何时被 Destroy 并且被 GC 回收。这些被 Destroy 的对象被传递给一个 ObjectWatcher，它持有对它们的弱引用。LeakCanary 能够自动检测以下对象的泄漏：
1、被销毁的 Activity实例2、被销毁的 Fragment实例3、被销毁的 fragmentView实例4、被清除ViewModel实例 可以查看任意一个不再使用的对象，例如 detached view 或 destroyed presenter：
AppWatcher.objectWatcher.watch(myDetachedView, "View was detached") 如果在等待 5 秒并运行 GC 回收后，ObjectWatcher持有的弱引用没有被清除，则该对象被认为是未被回收的，并且可能会产生泄漏。LeakCanary 就会将这些对象记录到 Logcat：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5bfd9be0ebc053d120ed0c78bac5af6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a19a0b37f25b23bfc5eeef5ecc07908f/" rel="bookmark">
			Python-OpenCV实现简单的颜色识别（对红色和蓝色识别并输出）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摄像头识别红色和蓝色并框选，当该颜色为摄像头屏幕上大多数颜色时打印出该颜色的名称
新手学习笔记，第一次写博客，若有错误还请指出（ ~`_` ）~
1.调包 import cv2 import numpy as np from matplotlib import pyplot as plt 2.初始设置 lower_red = np.array([0, 50, 100]) #为红色和蓝色设置阈值用来为之后处理图像准备 upper_red = np.array([10, 255, 255]) #该阈值是在HSV颜色空间下 lower_blue = np.array([100,50,100]) upper_blue = np.array([124, 255, 255]) red = (0,0,225) #设置红色和蓝色在BGR颜色空间下的数值元组 blue = (225,0,0) cv2.namedWindow('video', cv2.WINDOW_AUTOSIZE)#设置窗口'video'，大小为自适应模式 cv2.resizeWindow('video',640,480) #为窗口设置宽度（640）和高度（480） 3.图像处理，提取颜色 def img_process(img,lower,upper): """根据阈值处理图像，提取阈值内的颜色。返回处理后只留下指定颜色的图像（其余为黑色） img：原图像；lower：最低阈值；upper：最高阈值""" kernel = np.ones((35, 35), np.uint8) #创建一个35x35卷积核，卷积核内元素全为1 hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV) #将BGR图像转化为HSV图像，方便颜色提取 Open = cv2.morphologyEx(hsv,cv2.MORPH_OPEN,kernel) #用卷积核对图像进行形态学开运算操作，去除噪声 mask = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a19a0b37f25b23bfc5eeef5ecc07908f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14343e15b887d8151e14a4785e89a38e/" rel="bookmark">
			黑猫带你学UFS协议第1篇：全网最全UFS协议中文详讲，这份学习框架图，你值得拥有！！！（持续更新中...）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文/黑猫学长
1 作者想说 笔者本人从事于存储芯片行业多年，对eMMC/UFS/SD等芯片有深入研究，协议尤甚。而今看来，UFS协议在整个存储产品中（包括U盘、SPI、SD卡，NM卡、emmc、SSD、flash颗粒等），属于最难梯队。
对于嵌入式存储芯片来说，从最初大家熟悉的SD/TF卡，发展到emmc，再到如今的UFS，速率越来越快，性能越来越稳定。即使是最新的UFS产品，从问世到笔者写这篇文章（2022.07），都已经发展10余年了。奈何国内芯片产业起步比较晚，对于UFS，国内各大相关厂商大部分都是近两年才逐渐投入人力、财力研发。但UFS已经大规模应用到高端旗舰智能手机、平板电脑、AR/VR等智能终端领域。
尽管目前嵌入式产品中eMMC依旧是主流，但随着5G、人工智能、大数据的发展，对性能、数据量要求越来越高，
UFS的使用率和市场占有率一定会越来越大。因此，对于嵌入式设备相关技术人员，将难免会越来越多的与UFS打交道。无论对于是否为存储芯片行业的人员，想要在有限的时间内搞通UFS相关知识，还是非常困难的。
中文互联网上对于UFS相关的资料也相对来说比较少也不够详细。因此，笔者会根据UFS spec、学习/工作经验、网络资料等，对UFS协议进行详细讲解。希望能够帮助到需要研究UFS芯片的朋友们，让你不再繁琐地查阅各种资料，不再头大地翻译英文spec，物有所值，欢迎订阅…
本专栏适合人群：
1、存储芯片行业相关人员，包括但不限于：IC\FW\验证开发\TE\FAE\AE\销售等
2、嵌入式开发人员
3、对eMMC、UFS等存储芯片感兴趣人员
注意：
《黑猫带你学：UFS协议详解》系列文章预估15万+字，撰写不易，为付费内容，禁止私自转载。
本专栏文章主要针对UFS jedec 3.1协议相关内容，关于Unipro、M-PHY等内容不会过多涉及。
内容如若有误，欢迎评论留言。
2 专栏内容 黑猫带你学UFS协议第1篇：全网最全UFS协议中文详讲
黑猫带你学UFS协议第2篇：UFS相关名词释义
黑猫带你学UFS协议第3篇：UFS简介
黑猫带你学UFS协议第4篇：UFS协议栈详解
黑猫带你学UFS协议第5篇：UFS物理层简介（MIPI M-PHY）
黑猫带你学UFS协议第6篇：UFS链路层简介（MIPI UNIPRO）
黑猫带你学UFS协议第7篇：UFS传输层（UTP）简介
黑猫带你学UFS协议第9篇：UFS电气特性详解（Power、CLK、Reset等）
黑猫带你学UFS协议第10篇：两万字详解UFS SCSI命令
黑猫带你学UFS协议第11篇：UFS协议信息单元详解（UPIU）
黑猫带你学UFS协议第12篇：UFS描述符详解（descriptor）
黑猫带你学UFS协议第13篇：UFS标志（Flags）和属性（Atrributes）详解
黑猫带你学UFS协议第14篇：UFS初始化详解（Boot Operation）
黑猫带你学UFS协议第15篇：什么是逻辑单元（LU）与逻辑块（Sector）
黑猫带你学UFS协议第16篇：UFS如何配置逻辑单元（LU Management）
黑猫带你学UFS协议第19篇：UFS模式页是什么（Mode Page）
黑猫带你学UFS协议第20篇：UFS安全模式详解（Secure Mode）
黑猫带你学UFS协议第21篇：UFS数据保护机制（Device Data Protection）
黑猫带你学UFS协议第22篇：UFS语境管理详解（context management）
黑猫带你学UFS协议第23篇：UFS cache详解
黑猫带你学UFS协议第24篇：UFS命令队列详解（CMDQ）
黑猫带你学UFS协议第25篇：全网最全UFS RPMB LU详解（重放保护逻辑单元）
3 如何学好UFS协议 关于UFS协议学习框架，本人已整理如下框架，供大家学习使用。
第一部分为协议栈，类似于网络协议栈，要了解UFS的应用层、传输层、链路层、物理层之间的关系及作用，了解UPIU\SCSI命令帧格式。该部分主要掌握其大体框架，不建议过分过分深究。经过此部分，对UFS层级就有一个相对清晰的认识。
第二部分为UFS寄存器。通过控制这些寄存器，来控制UFS部分功能和属性。学习过程中要注意这些寄存器的属性（即是否可读可写等），大概了解每个寄存器的功能即可。
第三部分为UFS电气特性。比较UFS是颗芯片，是存在现实中的一个硬件设备。那么就应该要了解UFS样片供电应该是多少伏？CLK是多少？几路信道进行数据传输？等各种物理特性。
第四部分为UFS的一些重要功能/机制，大部分知识点之间没有太大联系，不用按顺序学习研究。当掌握基础内容后，该部分内容只需要用到哪一块就对哪一块进行深入研究即可。
本人所列出的UFS学习框架图，为本人工作多年所研究整理，基本涵盖了UFS的常用及主要内容。当然，对于一些细枝末节，基本上不会用到知识点，学习框架图中并未列出，但这无伤大雅，不需要过分纠结。笔者坚信，对于框图中的内容都学习研究后，就已经掌握了UFS3.1协议中至少90%以上的内容，基本就算“吃透”UFS协议了。
《黑猫带你学：UFS协议详解》专栏中文章顺序，基本也就是按照学习框架图顺序所撰写，逐一进行研究即可。
4 更好的阅读体验 为了让读者有更好的阅读体验，读者朋友们应该知道如下信息，不至于看文章时候产生迷惑。
1、文章中设备、device、UFS、Target Port均指UFS；host、主机、initiator port均指使用UFS的具体产品，包括但不限于手机、平板、嵌入式开发板等设备。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14343e15b887d8151e14a4785e89a38e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab105464cc66677be796a78970aaf615/" rel="bookmark">
			idea中class文件中文乱码解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开idea安装地址\bin中idea.exe.vmoptions 和idea64.exe.vmoptions 打开文件在最后加上
-Dfile.encoding=UTF-8
然后就好了 此方法只能解决idea文件里面的乱码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0178a2ce8a75c67df0be8d9b9964844/" rel="bookmark">
			安装Anaconda,新建Anaconda虚拟环境，用pycharm配置新建的Anaconda虚拟环境。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装Anaconda 本人由于某种原因，重装了不下十遍Anaconda。试过多种版本，最终收获了一些经验，在这里分享。
本人刚开始安装的是Anaconda3-2022.10-Windows-x86_64.exe Anaconda版本为22.9.0
安装好之后又使用命令更新到23.3.1的版本，截至2023年5月1日，Anaconda最新版本为23.3.1
随着人工智能的发展，Python成为了最受欢迎的编程语言之一。Anaconda是一个Python环境管理器，它提供了一个易于使用的界面来安装、配置和管理Python环境，包括安装Python解释器、第三方库和工具。
本文将向您介绍如何安装Anaconda、新建Anaconda虚拟环境并使用PyCharm配置新建的Anaconda虚拟环境。
我的是：Windows系统 安装Anaconda
前往Anaconda官网（https://www.anaconda.com/products/individual），下载适合您操作系统的Anaconda版本，建议下载最新的稳定版。
这里可以直接进入这个：https://repo.anaconda.com/archive/
可以看到
例如64位的windows操作可以选择
Anaconda3-2023.03-1-Windows-x86_64.exe
双击即可，等待下载完成后。
【在Windows上，您可以选择64位或32位版本。在MacOS上，您只能下载64位版本。】
还是分享一下教程吧： 开始 ！！！！重要：--------------------------------------------------------------------------------------------- ！！！！重要：下载完成后，运行安装程序。建议双击就行，不建议以管理员身份运行 ---------------------------------------------------------------------------------------------------------------------------------
&amp;&amp;这里以2021.11的4.10.0版本为例，此教程 适用于所有版本的安装 &amp;&amp;
第一步：点击 Next
第二步：点击 I Agree
第三步：不管电脑有几个用户，建议选择Just Me 。然后点击Next
【一般来说，电脑上只有一个用户，选择Just Me, 多个用户的话选择All Users 】。
第四步： 选择安装路径，可以修改，也可以默认路径安装。这里建议自己修改路径安装，避免后期不容易找到。
第五步： 这里极为重要，Install时建议将两个选项进行勾选，一个是添加环境变量的，一个安装python的，这能够避免后期不必要的麻烦。
***【如果你在安装过程中没有看到下图中添加path的选项，建议你按照上面的第三步来安装。 这个是2023.03发布的，安装时出现的是这样的选项（官方更新了），可以看到类似的，第二个Add Anaconda3 to my PATH environment variable ,将四个选项勾选，第二个必选！
最后：根据安装程序的提示，完成安装。最后弹出的窗口点击Finish，选项选不选都无所谓。
验证Anaconda是否安装成功！
安装完成后，您可以打开：命令提示符-----Windows+R，输入cmd，打开命令终端，或者打开Anaconda Prompt(Anaconda)
输入下面的命令
conda --version *************************如果安装成功，将会显示您安装的Anaconda版本。显示有类似版本信息，恭喜你，已经成功安装好Anaconda。【但是能不能被Pycharm配置使用，还有待验证 】
********如果出现错误信息，可能是环境变量为未被正确配置
在桌面，搜索栏搜索，编辑系统环境变量，选择环境变量，找到系统变量，里面点击Path，
添加四个路径。
【找不到编辑系统环境变量的话，这些步骤我之前的文章里有----配有图片，可以看看】
如果还是不行的话，或是出现其他问题，呢就不得而知了，建议卸载重装。
二、新建Anaconda虚拟环境 1、安装完成后，我们将创建一个新的Anaconda虚拟环境，在打开Anaconda Prompt终端中输入以下命令来创建一个名为myenv的新环境：(名字可以自己任意命名）
命令：
conda create --name myenv 还可以创建一个3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0178a2ce8a75c67df0be8d9b9964844/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d091296a32228ab1174fa2877e820933/" rel="bookmark">
			【C&#43;&#43;】实现两个线程交替打印1-100
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 实现两个线程交替打印1-100 实现两个线程交替打印1-100 尝试用两个线程交替打印1-100的数字,要求一个线程打印奇数,另一个线程打印偶数
该题目主要考察的就是线程的同步和互斥:
互斥：两个线程都在向控制台打印数据,为了保证两个线程的打印数据不会相互影响,因此需要对线程的打印过程进行加锁保护,同步：两个线程必须交替进行打印,因此需要用到条件变量让两个线程进行同步,当一个线程打印完再唤醒另一个线程进行打印, 但如果只有同步和互斥是无法满足题目要求的**,因为我们无法保证哪一个线程会先进行打印**,不能说先创建的线程就一定先打印,后创建的线程先打印也是有可能的, 因为题目没有要求的是先打印的是奇数还是偶数
此外,有可能会出现某个线程连续多次打印的情况,比如线程1先创建并打印了一个数字,当线程1准备打印第二个数字的时候线程2可能还没有创建出来,或是线程2还没有在互斥锁上进行等待,而t1时间片很充足,t1打印完后,这时线程1就会再次获取到锁进行打印,那么t1就可能连续打印了2次或者更多次, 此时就不能满足交替打印了！
鉴于此,这里还需要定义一个flag变量,该变量的初始值设置为true. 步骤:
1)假设让线程1打印奇数,线程2打印偶数,那么就让线程1调用wait函数阻塞等待时,传入的可调用对象返回flag的值,而让线程2调用wait函数阻塞等待时,传入的可调用对象返回!flag的值,
2)由于flag的初始值是true.就算线程2先获取到互斥锁也不能进行打印,因为最开始线程2调用wait函数时,会因为可调用对象的返回值为false而被阻塞,这就保证了线程1一定先进行打印,
3)为了让两个线程交替进行打印,因此两个线程每次打印后都需要更改flag的值,线程1打印完后将flag的值改为false并唤醒线程2.这时线程2被唤醒时其可调用对象的返回值就变成了true.这时线程2就可以进行打印了,
4)当线程2打印完后再将flag的值改为true并唤醒线程1.这时线程1就又可以打印了,就算线程2想要连续打印也不行,因为如果线程1不打印,那么线程2的可调用对象的返回值就一直为false.对于线程1也是一样的道理,
int main() { int n = 100;//打印1-100 mutex mtx;//互斥锁 condition_variable cv;//条件变量 bool flag = true; //线程1打印奇数 thread t1([&amp;]{ //以引用方式捕获上述变量 int i = 1;//从1开始打印 while (i &lt;= 100) { unique_lock&lt;mutex&gt; ul(mtx);//调用构造函数加锁 cv.wait(ul, [&amp;flag]()-&gt;bool{ return flag;}); //等待条件变量满足 cout &lt;&lt; this_thread::get_id() &lt;&lt; ":" &lt;&lt; i &lt;&lt; endl; i += 2;//下一个奇数 flag = false;//让线程2满足条件 cv.notify_one(); //唤醒条件变量下等待的一个线程 } }); //线程2打印偶数 thread t2([&amp;]{ //以引用方式捕获上述变量 int j = 2;//从2开始打印 while (j &lt;= 100) { unique_lock&lt;mutex&gt; ul(mtx); cv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d091296a32228ab1174fa2877e820933/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dd6b50224c39698d9cece11f25e7340/" rel="bookmark">
			ios中的锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码测试可参考，只有实际写过才能更好的理解：
在平时开发中我们经常会使用多线程，多线程为我们带来了很大便利，也提高了程序的执行效率，但同时也带来数据风险：当至少有两个线程同时访问同一个变量，而且至少其中有一个是写操作时，就发生了Data race。所以这是就要利用一些同步机制来确保数据的准确性，锁就是同步机制中的一种。
什么是锁？锁 – 是保证线程安全常见的同步工具。锁是一种非强制的机制，每一个线程在访问数据或者资源前，要先获取(Acquire) 锁，并在访问结束之后释放(Release)锁。如果锁已经被占用，其它试图获取锁的线程会等待，直到锁重新可用。
怎么检测项目中的Data race？ 只需要在设置中勾选Thread Sanitizer 即可，顺便可以勾选Pause on issues 就可以断点到相应的代码。
简单的性能测试 下图是针对iOS中的锁测试得出的，图中数字代表每次加解锁需要消耗的时间，单位为ns。
值得注意的是：1.这个数字仅仅代表每次加解锁的耗时，并不能全方面的代表性能。2.不同的机型和系统，不同的循环次数可能结果会略微有些差异。
但是还是可以看出@synchronized:是表现最差的。
在具体说这些锁之前，先来说几个概念定义：
临界区：指的是一块对公共资源进行访问的代码，并非一种机制或是算法。 通俗点理解, 就是一段代码.
自旋锁：是用于多线程同步的一种锁，线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。自旋锁是比较耗费 cpu 的，然而在互斥临界区计算量较小的场景下，它的效率远高于其它的锁。因为它是一直处于 running 状态，减少了线程切换上下文的消耗。
OSSpinLock（已废弃，不推荐，虽然效率最高，使用os_unfair_lock替代）
互斥锁（Mutex）：在编程中，来保证共享数据操作的完整性。每个对象都对应于一个可称为 互斥锁 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。通过将代码切片成一个一个的临界区而达成.NSLock, NSConditionLock, NSRecursiveLock, NSCondition，pthread_mutex，@synchronized，os_unfair_lock
读写锁：是计算机程序的并发控制的一种同步机制，也称“共享-互斥锁”、多读者-单写者锁) 用于解决多线程对公共资源读写问题。读操作可并发重入，写操作是互斥的。比如pthread_rwlock，读写锁通常用dispatch_barrier_async 实现
信号量（semaphore）：是一种更高级的同步机制，互斥锁可以说是semaphore在仅取值0/1时的特例。信号量可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。
条件锁：就是条件变量，可以自己设置一个条件来定义加锁 与 释放锁的时机. NSCondition ， NSConditionLock中注意条件并不是bool类型的，而是一个固定的数字，加锁或者解锁，都会把condition修改为参数 。
递归锁 ：递归锁允许同一个线程多次请求锁，而不会出现死锁的情况。 属于对互斥锁的一种。@synchronized NSRecursiveLock ， pthread_mutex
互斥锁 1.NSLock：是Foundation框架中以对象形式暴露给开发者的一种锁，（Foundation框架同时提供了NSConditionLock，NSRecursiveLock，NSCondition）NSLock定义如下：
@protocol NSLocking - (void)lock; - (void)unlock; @end @interface NSLock : NSObject &lt;NSLocking&gt; { @private void *_priv; } - (BOOL)tryLock; - (BOOL)lockBeforeDate:(NSDate *)limit; @property (nullable, copy) NSString *name API_AVAILABLE(macos(10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dd6b50224c39698d9cece11f25e7340/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71a4a79e0961173e272586ca51f26ef4/" rel="bookmark">
			按钮循环波动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		:after{ content: ""; animation: pulse-border-2 2s ease-out infinite; top: 36px; left: 50%; background: #fff; width: 100%; border-radius: 36px; } @keyframes pulse-border-2{ 0%{transform:translate(-50%,-50%) translateZ(0) scale(1);opacity:.7} 100%{transform:translate(-50%,-50%) translateZ(0) scale(1.35);opacity:.1} } 下面提供全部代码（上面是转载，下面是我自己的代码）
.btn-play { display: flex; justify-content: center; align-items: center; border-radius: 100%; border: none; outline: none !important; padding: 18px 20px 20px 28px; background: #FFFFFF; } .btn-play:before { content: ""; position: absolute; z-index: 0; left: 50%; top: 50%; transform: translateX(-50%) translateY(-50%); display: block; width: 60px; height: 60px; background: #FFFFFF; border-radius: 100%; animation: pulse-border 1500ms ease-out infinite; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71a4a79e0961173e272586ca51f26ef4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce478ae017f8f743a6cb36db8a36a767/" rel="bookmark">
			关于P2P资料整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 环境搭建相关：
使用Flash在电脑与Android间开发局域网P2P项目-flash在电脑中的作用 openrtmfp+action script +flash builder搭建P2p视频服务器_weixin_33840661的博客-CSDN博客
基于FlashP2P技术的视频服务器架构的搭建 - 豆丁网 FlashPP协议及应用技术方案.doc FlashP2P协议分析及应用
如何使用P2PS进行flash+p2p的点播网站开发 - 百度文库 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e74264a2a7d7902ef7493015b02e3c9/" rel="bookmark">
			Python学习：Anaconda23.3.1&#43;spyder5.4.3&#43;Python3.10.11环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题1：Anaconda安装配置教程（真的非常详细的安装过程，还带环境配置）
【参考文献】本文链接：Windows安装Anaconda使用教程_在奋斗的大道的博客-CSDN博客
问题2：Anaconda半天打不开，就在这转啊转。
【原因】anaconda有个广告载入功能，这个功能需要联网，但国内网络环境有时候连不上目标网络，所以打开anaconda navigator的时候会因为网络问题一直卡在Initializing。
【解决】
在anaconda安装路径里找到存放该功能的脚本，限制广告载入功能访问时长。
（参考一下路径 D:\anaconda3\Lib\site-packages\anaconda_navigator\utils\attribution ）
在attribution文件夹里找到resources并打开，直接双击打不开的话，右键选择打开方式为记事本，然后参考图片逐行找到图中红框位置进行修改。
我的打开后那个位置的原内容是requests.get(url)，改成requests.get(url,timeout(0.01,0.1)）后，顺利打开了anaconda navigator。
【参考文献】本文链接：anaconda navigator打开时卡在Initializing_anaconda一直在initializing_菜鸟好吃不贵的博客-CSDN博客​​​​​​
问题3：anaconda常见命令。安装完就搞个环境。
1、查看版本
conda --version 2、工具包全部升级
conda upgrade --all 3、进入虚拟环境
Activate 4、python版本情况查看
python 5、创建虚拟环境
conda create -n 虚拟环境名称 python=指定python 运行版本 例如：conda create -n python310 python=3.10 6、查看虚拟环境和切换虚拟环境
查看虚拟环境：conda env list 切换虚拟环境：activate 虚拟环境名称 7、卸载虚拟环境
conda remove --name 虚拟环境名称 --all 问题4：安装Spyder，有博主说最好安装在新的虚拟环境里，错误少点，而且版本不能太高。
1、查找spyder版本
conda search spyder 会出现：
2、安装spyder，后面接的是版本号，自己选跟python对应的版本（我的python3.10，spyder5.4.3），脾气大得很，一言不发就闪退。
conda install spyder=5.4.3 3、查看spyder安装情况
喜抱错误一个：
fromIccProfile: failed minimal tag size sanity
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e74264a2a7d7902ef7493015b02e3c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/489d3f2fadd5acdc6555554ba5ad8513/" rel="bookmark">
			python:缩进与注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、Python语法元素分析
（一）程序的格式框架
1、缩进
缩进：指每一行代码开始前的空白区域，用来表示代码之间的层次关系。
1缩进=4个空格
不输出
输出：没有缩进。
2、注释
注释：程序员在代码中加入的说明信息，不被计算机执行。
注释快捷键Ctrl+1
注释的两种方法：
单行注释以#开头 多行注释以'''开头和结尾 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/330c1dd512edab521a3fed312a2e1d1d/" rel="bookmark">
			linux向windows传文件自动化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux脚本使用scp命令可以直接传文件到windows下的指定目录，这需要linux和windows都开启ssh服务。当有大量分散的文件需要从linux服务器下载到windows本地时，使用脚本可以高效完成任务。然而windows默认是没有ssh服务的，因此需要安装OpenSSH软件。本文linux系统为CentOS7.9，windows系统为win10。windows端可以直接从设置-应用-可选功能里添加OpenSSH服务器，由于实在太慢，这里采用手动安装的方法。
一、windows安装OpenSSH 1、从https://github.com/PowerShell/Win32-OpenSSH/releases下载OpenSSH的安装包OpenSSH-Win64.zip
2、将压缩包解压到C:\Program Files，解压的文件夹为OpenSSH-Win64，将其重命名为OpenSSH
3、以管理员身份运行PowerShell依次执行以下指令
进入解压目录
cd "C:\Program Files\OpenSSH" 安装OpenSSH
powershell.exe -ExecutionPolicy Bypass -File install-sshd.ps1 设置防火墙
New-NetFirewallRule -Name sshd -DisplayName 'OpenSSH Server (sshd)' -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22 启动 OpenSSH
net start sshd 设置开机自动启动
Set-Service sshd -StartupType Automatic 4、修改OpenSSH 的核心配置文件C:\ProgramData\ssh\sshd_config，将最后两行进行注释，并保存，如下图所示。这一步关系到能否免密连接
如果C盘里找不到ProgramData这个文件夹，在查看选项卡下勾选隐藏的项目即可显示这个文件夹，如下图
5、修改配置文件后在PowerShell中使用以下命令重启 OpenSSH 服务使其生效
net stop sshd net start sshd 6、在系统变量path里添加Openssh的环境变量C:\Program Files\OpenSSH
7、在PowerShell中输入ssh得到如下输出证明安装成功
二、linux使用ssh免密连接windows 1、完成上面的操作后在linux命令行和windows PowerShell中输入如下命令一直回车，生成公钥id_rsa.pub和私钥id_rsa，生成的文件分别在~/.ssh目录和%homepath%\.ssh目录中
ssh-keygen 2、将linux端的公钥id_rsa.pub复制到windows端的桌面下，重名为authorized_keys，再剪切到windows端的用户目录中的.ssh文件夹下，如下图所示。从持有私钥的linux端连接windows端时，会用它来解锁。两者匹配时，系统无需密码就能解除锁定
3、查找windows端的ip地址，在linux中输入以下命令，第一次连接需要输入yes，第二次不需要任何输入直接出现如下结果则连接成功，可以输入exit来退出连接
4、然后就可以在命令行和脚本中使用scp命令传输文件到windows端了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d309e99614c448ec9241c9c44582e192/" rel="bookmark">
			Java Stream API 操作完全攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自:
Java Stream API 操作完全攻略：让你的代码更加出色 (一)
Java Stream API 操作完全攻略：让你的代码更加出色 (二)
Java Stream API 操作完全攻略：让你的代码更加出色 (三)
Java Stream API 操作完全攻略：让你的代码更加出色 (四)
filter()：根据指定的 Predicate 保留符合条件的元素。
map()：根据指定的 Function 映射每个元素，生成一个新的 Stream。
flatMap()：将每个元素映射为一个 Stream，然后将这些 Stream 连接成一个 Stream。
distinct()：返回一个去重后的 Stream。
sorted()：对 Stream 进行排序。
peek()：对每个元素执行指定的操作，但并不消费元素。
limit()：返回一个截断后的 Stream。
skip()：返回一个跳过指定元素后的 Stream。
forEach()：对每个元素执行指定的操作。
toArray()：将 Stream 转换为数组。
reduce()：将 Stream 中的所有元素合并为一个，可以传入一个初始值。
collect()：将 Stream 中的元素收集到一个集合中。
count()：返回 Stream 中元素的数量。
anyMatch()：判断是否存在至少一个元素满足指定的条件。
allMatch()：判断是否所有元素都满足指定的条件。
noneMatch()：判断是否不存在任何一个元素满足指定的条件。
findFirst()：返回 Stream 中的第一个元素。
findAny()：返回 Stream 中的任意一个元素。
min()：返回 Stream 中的最小元素。
max()：返回 Stream 中的最大元素。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d309e99614c448ec9241c9c44582e192/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f03639e29beb7d61cd6882aa038c371/" rel="bookmark">
			HTML界面利用 http-vue-loader.js以组件方式引入vue文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网
Vue Loader 是一个 webpack 的 loader，它允许你以一种名为单文件组件 (SFCs)的格式撰写 Vue 组件：
http-vue-loader 这套工具可提供开发者直接在网页环境中载入 .Vue File，无需透过 nodeJS 环境编译，也不需要 Build 的步骤。
用法很简单，首先在网页上载入 Vue 与 http-vue-loader，如下
&lt;script src="../js/vue.min.js"&gt;&lt;/script&gt; &lt;script src="../js/http-vue-loader.js"&gt;&lt;/script&gt; 独立的Vue文件
&lt;template&gt; &lt;div class="head"&gt;{{msg}}&lt;/div&gt; &lt;/template&gt; &lt;script&gt; // http-vue-loader的示例中，单文件子组件中写的是module.exports = {}，而不是export default {} module.exports = { // 一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝 data: function() { return { msg: '头部导航栏' } }, } &lt;/script&gt; &lt;style&gt; .head{ height: 60px; line-height: 60px; text-align: center; background-color: pink; } &lt;/style&gt; 主界面引入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f03639e29beb7d61cd6882aa038c371/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40788156743c2d68eb17a96dd88da512/" rel="bookmark">
			git的忽略规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.gitignore文件 在仓库的目录如果有一个.gitignore文件，则提交的文件会按照.gitignore文件的配置对提交的文件进行过滤，这样可以有效防止像node_modules这种不需要提交的文件被提交。
.gitconfig 和 .git 在同一层。
忽略规则 在 .gitignore 文件中，每一行的忽略规则的语法如下：
空格不匹配任意文件，可作为分隔符，可用反斜杠转义以“＃”开头的行都会被 Git 忽略。即#开头的文件标识注释，可以使用反斜杠进行转义。以斜杠"/"开头表示目录；"/"结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；"/"开始的模式匹配项目跟目录；如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录。以星号"*"通配多个字符，即匹配多个任意字符；使用两个星号"**" 表示匹配任意中间目录，比如a/**/z可以匹配 a/z, a/b/z 或 a/b/c/z等。以问号"?"通配单个字符，即匹配一个任意字符；以方括号"[]"包含单个字符的匹配列表，即匹配任何一个列在方括号中的字符。比如[abc]表示要么匹配一个a，要么匹配一个b，要么匹配一个c；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配。比如[0-9]表示匹配所有0到9的数字，[a-z]表示匹配任意的小写字母）。以叹号"!"表示不忽略(跟踪)匹配到的文件或目录，即要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。需要特别注意的是：如果文件的父目录已经被前面的规则排除掉了，那么对这个文件用"!"规则是不起作用的。也就是说"!"开头的模式表示否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用"!"也不会再次被包含。可以使用反斜杠进行转义。 需要谨记：git对于.ignore配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；
忽略规则简单说明 复制# 表示此为注释,将被Git忽略 *.a 表示忽略所有 .a 结尾的文件 !lib.a 表示但lib.a除外 /TODO 表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO build/ 表示忽略 build/目录下的所有文件，过滤整个build文件夹； doc/*.txt 表示会忽略doc/notes.txt但不包括 doc/server/arch.txt bin/: 表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件 /bin: 表示忽略根目录下的bin文件 /*.c: 表示忽略cat.c，不忽略 build/cat.c debug/*.obj: 表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj **/foo: 表示忽略/foo,a/foo,a/b/foo等 a/**/b: 表示忽略a/b, a/x/b,a/x/y/b等 !/bin/run.sh 表示不忽略bin目录下的run.sh文件 *.log: 表示忽略所有 .log 文件 config.php: 表示忽略当前路径的 config.php 文件 /mtk/ 表示过滤整个文件夹 *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40788156743c2d68eb17a96dd88da512/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65106bdf8a4bc144b42b09c1c031f40e/" rel="bookmark">
			结构体字节对齐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
结构体字节对齐意义
1、平台原因（移植原因）
2、性能原因
结构体字节对齐方法
1、对齐值概念
1.1 自身对齐值
1.2 指定对齐值 1.3 有效对齐值
1.4 结构体有效对齐值
2、对齐规则
2.1 规则一
2.2 规则二
3、对齐步骤（实操）
3、结构体嵌套
编程应用
1、节省空间
2、节省时间
3、隐患
结构体字节对齐意义 1、平台原因（移植原因） 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。（例如无法使用0x00000000地址处的空间）
2、性能原因 数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。
结构体字节对齐方法 1、对齐值概念 自身对齐值：数据类型本身的对齐值，例如char类型的自身对齐值是1，short类型是2；指定对齐值：编译器或程序员指定的对齐值；有效对齐值：自身对齐值和指定对齐值中较小的那个。结构体有效对齐值：其最大数据成员的自身对齐值。 1.1 自身对齐值 1.2 指定对齐值 指定对齐值：无预编译指令#pragma pack(n)就看默认CPU周期。
(1) CPU周期
WIN vs qt 默认8字节对齐
Linux 32位 默认4字节对齐，64位默认8字节对齐
(2) 预编译指令：
使用伪指令#pragma pack (n)，C编译器将按照n个字节对齐。n = 1 2 4 8 16
使用伪指令#pragma pack ()，取消自定义字节对齐方式。
1.3 有效对齐值 自身对齐值和指定对齐值中取最小值。
1.4 结构体有效对齐值 结构体最大数据成员的自身对齐值。（包括嵌套中的结构体的最大成员）。
2、对齐规则 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65106bdf8a4bc144b42b09c1c031f40e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84705045426d805e2e2339a293122d07/" rel="bookmark">
			Ubuntu系统界面卡死解决方案记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Ubuntu20.04版本，因为Ubuntu系统内有很多内容，系统界面卡死时，若强制关机，损伤太大，还有可能进不了系统，直接坏掉。所以搜集了网上大佬们解决方案，现把解决我问题的两种方法放在这里。
说明：我使用第一种重新进入系统界面了，但是还是卡，于是采用了第二种方法，成功解决方法
解决方案一：不需要重启
1.按Ctrl+Alt+F1可以进入tty终端
2.会出现login和password界面。输入系统的账号和密码进行登录，
注：切记，这里不要使用小键盘
3.使用命令
sudo pkill Xorg 或者
sudo restart lightdm 注销桌面，重新登录
4.重新输入系统密码即可正常使用系统
解决方案二：安全重启 真的救我系统一命！！！！！
1. 同时按住 Ctrl 和 Alt 键，执行2、3步骤都一直按住不要放 2. 按顺序按一下键盘的PrtSc键（或者SysRq 键）、 R 键、E 键 3. 再依次按下 I , S , U , B 键 感谢感谢大佬们救我一命，在此记录，以防以后再次使用！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8b606d5557a76e8fdf3702b09c30d63/" rel="bookmark">
			springboot 整合 log4j2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot 整合 log4j2 日志服务 log4j
jul
jcl
logback 同样也是log4j的作者设计完成
log4j2
commons-logging
slf4j
log4j2.xml 配置详解 ```xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt; &lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt; &lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，可设置一个非零的间隔秒数来检测配置变更 --&gt; &lt;Configuration status="WARN" monitorInterval="60"&gt; &lt;!-- 自定义一些变量 --&gt; &lt;Properties&gt; &lt;!-- 变量定义 --&gt; &lt;Property name="log_base_dir"&gt;/app_data/logs/my_app&lt;/Property&gt; &lt;!-- Appender在将日志数据写入目标位置之前，一般会将日志数据通过Layout进行格式化。PatternLayout可以使用与C语言printf函数类似 的转换模式来指定输出格式。常见的配置如下： - %d{yyyy-MM-dd HH:mm:ss.SSS} : 日志生成时间，输出格式为“年-月-日 时:分:秒.毫秒” - %p : 日志输出格式 - %c : logger的名称 - %m : 日志内容，即 logger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8b606d5557a76e8fdf3702b09c30d63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9bf411eb25eeff26ab58bd6da9a3bf2/" rel="bookmark">
			Oracle中的单列函数-聚合函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、distinct -去重
二、group by-分组
三、having -分组之后的筛选
四、order by --排序
五、listagg(列,'分隔符')within group(order by 列)
Oracle中的聚合函数是用于对一组数据进行聚合计算的函数，包括SUM、AVG、MAX、MIN、COUNT等。它们的作用是对数据进行统计分析和汇总，用于得出数据的总体情况和特征，例如计算平均值、总和、最大值、最小值、数量等，以便进行决策和分析。聚合函数可以用于SELECT语句中，对查询结果进行聚合计算，返回一个聚合结果。
聚合函数又称为分组函数，有以下几种常用的聚合函数：
①max(列) 最大值
②min(列) 最小值
③avg(列) 平均值 ，只能是数值型
④sum(列) 求和 ，只能是数值型
⑤count(列)计数 ，不分组计算全表，count（）函数的用法可查看http://t.csdn.cn/bkstx
比如： select min(sal),max(sal),avg(sal),sum(sal),count(sal) from emp; 聚合函数适用于需要对数据进行统计和计算的场景，如：
统计某个表中某列的行数；计算某个表中某列的总和、平均值、最小值、最大值等；对查询结果进行分组并计算每个分组的数据的聚合值。 下面结合聚合函数描述下分组-排序-去重-。
一、distinct -去重 DISTINCT用于查询不同的值。它可以用于SELECT语句中指定要查询的列，以返回不同的值。例如，以下查询将返回不同的城市名称：
SELECT DISTINCT city FROM customers; 如果要查询多列并返回不同的值，可以在DISTINCT关键字后面指定多个列名，例如：
SELECT DISTINCT city, country FROM customers; 注意：
使用DISTINCT会增加查询的开销，因为Oracle需要对结果集进行去重操作。在查询大量数据时，使用DISTINCT可能会导致性能问题。
二、group by-分组 GROUP BY用于将查询结果按照一个或多个列进行分组。它可以用于SELECT语句中指定要分组的列，以便对每个分组计算聚合函数。例如，以下查询将返回每个城市的顾客数量：
SELECT city, COUNT(*) as customer_count FROM customers GROUP BY city; 在上面的查询中，我们使用了COUNT函数来计算每个城市中的顾客数量，并使用GROUP BY语句将结果按城市进行分组。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9bf411eb25eeff26ab58bd6da9a3bf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1725f303fb37ce7057a50aeb4b3811fb/" rel="bookmark">
			MAC移动硬盘无法正常推出：“磁盘无法推出，因为一个或多个程序正在使用它”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MAC移动硬盘在使用中，经常会碰到无法正常退出的情况，提示：“磁盘无法推出，因为一个或多个程序正在使用它”，如果你“直接拔掉”或“强行推出”的话，可能导致你下次重新连接移动硬盘无法识别。（参考：MAC移动硬盘无法识别解决方案）
步骤一：
如果无法正常退出，你通常首先会遇到的情形是：磁盘未能正常推出，因为Finder正在使用它。
看到这个提示，可以点击左上角苹果图标，选择“强制退出...”，进入“强制退出应用程序”窗口，然后选中 Finder，点击按钮“重新开启”。执行这样的操作后，如果还是不能正常推出移动硬盘，可以参考步骤2。
步骤二：
如果步骤1不起作用，通常会提示：“磁盘无法推出，因为一个或多个程序正在使用它”。
碰到这样情况，最直接有效的方法就是找出这个占用移动磁盘的后台程序，并且终止他。
步骤三：
3.1 在“终端”显示移动硬盘
打开MAC电脑的终端(Teminal)，执行命令: diskutil list， 找到我们目前正在运行的移动硬盘：
可以看到外接的移动硬盘(external, physical)是：/dev/desk2，它下面包括两个盘符标记：disk2s1 和 disk2s2, 多个盘符表示硬盘包括多个分区，可以看到disk2s1的 TYPE NAME 是 EFI：
EFI系统分区中存放了可供引导启动的文件，作用是引导操作系统正常启动。EFI系统分区是一个使用FAT32格式化的小分区，该分区在Windows操作系统下一般是不可见的，其中存储已安装系统的EFI引导加载程序以及启动时固件使用的应用程序。
因为 EFI 分区在这里对我们没有什么意义，我们实际存储数据的的硬盘分区是 disk2s2，后面命令的操作对象也是针对的硬盘分区 disk2s2 来说的。
如果你觉着上面的方式不太好理解，也可以在终端执行命令：df -lh
这里直接就显示当前移动硬盘的数据存储分区：dev/disk2s2
3.2 执行推出移动硬盘命令：umount /dev/disk2s2
通过命令执行推出硬盘，由于后台程序占有，会提示具体的错误信息，上图显示，后台占用进程的 PID = 232， 程序名称是：mds_stores。
3.3 强制终止 mds_stores
打开“活动监视器”，在右上角搜索框输入：mds_stores，点击搜索。
选择上图的 mds_stores 程序，点击终止，就可以正常推出移动硬盘了。mds_stores 是 spotlight的后台进程，spotlight 为了用户在查询数据的时候能够快速显示查找结果，所以需要对这些文件建立索引等信息。mds_stores 就是后台在建立索引等信息的进程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c50908a93f3c3880f21c93839f259bb/" rel="bookmark">
			【学习日记2023.5.3】之 MyBatis快速入门_JDBC介绍(了解)_数据库连接池_lombok类库_MyBatis基础操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. MyBatis入门1.1 快速入门1.1.1 入门程序分析1.1.2 入门程序实现1.1.2.1 准备工作1.1.2.1.1 创建springboot工程1.1.2.1.2 数据准备 1.1.2.2 配置Mybatis连接数据库的四大参数： 1.1.2.3 编写SQL语句1.1.2.4 单元测试 1.1.3 解决SQL警告与提示 2. JDBC介绍(了解)2.1 介绍2.2 代码2.3 问题分析2.4 技术对比 3. 数据库连接池3.1 介绍3.2 产品 4. lombok4.1 介绍4.2 使用 5. MyBatis基础操作5.1 需求5.2 准备5.3 删除5.3.1 功能实现5.3.2 日志输入5.3.3 预编译SQL5.3.3.1 介绍5.3.3.2 SQL注入5.3.3.3 参数占位符 5.4 新增5.4.1 基本新增5.4.2 主键返回 5.5 更新5.6 查询5.6.1 根据ID查询5.6.2 数据封装解决方案： 5.6.3 条件查询5.6.4 参数名说明 6. 总结 1. MyBatis入门 在前面我们学习MySQL数据库时，都是利用图形化客户端工具(如：idea、datagrip)，来操作数据库的。
在客户端工具中，编写增删改查的SQL语句，发给MySQL数据库管理系统，由数据库管理系统执行SQL语句并返回执行结果。 增删改操作：返回受影响行数 查询操作：返回结果集(查询的结果) MyBatis是一款优秀的 持久层 框架，用于简化JDBC的开发。
MyBatis本是 Apache的一个开源项目iBatis，2010年这个项目由apache迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。
官网：https://mybatis.org/mybatis-3/zh/index.html
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c50908a93f3c3880f21c93839f259bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/712ca901a3130c262021fb633df85859/" rel="bookmark">
			TypeError: Cannot read properties of null (reading ‘parentNode‘) vue3踩坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法一：如果声明的常量用ref，则检查赋值与被赋值是否都是对应的。
如上图，我赋值的为一个对象，直接这样写就会报上面第一张图的错误。
改正：将ref()改成ref({})
解决方法二：如果用的是reactive
则用Object.assign(a, b)，第一个a是被赋值的，第二个是有数据的
有关Object.assign()的知识可点击Object.assign() - JavaScript | MDN (mozilla.org)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0777e9d0c8346a040a152f7de84660db/" rel="bookmark">
			内网渗透信息收集总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内网信息收集 信息收集 一、内网信息收集概述 1.1、我是谁？
——对当前机器角色的判断
WEB服务器？开发测试服务器？公共服务器？文件服务器？代理服务器？DNS服务器？等等？？
根据 主机名、文件、网络连接情况综合判断。
1.2、这是哪？
—— 对当前机器所处网络环境的拓扑结构进行分析与判断。
绘制大致内网拓扑图
1.3、我在哪
——- 对当前机器所处区域的判断。
DMZ区、办公区、核心区
二、收集本机信息 2.1手动信息收集
2.1.1查询网络配置信息 ipconfig/all 2.1.2查询操作系统及软件信息 systeminfo 可查询出补丁，可利用系统自身存在的漏洞进行后续的提权。 systeminfo | findstr /B /C:“OS 名称” /C:“OS 版本” 查看系统体系结构
echo %PROCESSOR_ARCHITECTURE% 查看安装的软件版本及路径等
wmic product get name,version 利用powershell收集软件版本信息
powershell “GET-WmiObject -class Win32_Product | Select-Object -Property name,version” 2.1.3查询本机服务信息 wmic service list brief 2.1.4查询进程列表 tasklist 查看当前进程和进程用户
wmic process list brief 2.1.5查看启动程序（启动项）信息 wmic startup get command,caption 2.1.6查看计划任务 schtasks /query /fo LIST /v 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0777e9d0c8346a040a152f7de84660db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b239afca4e61a146537ccd53cba767d4/" rel="bookmark">
			Python保留指定位数的小数【5种方法】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 %.2f’ %[变量] 【四舍五入】 可以在print()打印处使用，也可以赋值给新的变量进行输出
# 四舍五入方法 a = 2.345566 print('%.4f'% a) # 2.3456 print('%.3f'% a) # 2.346 print('%.2f'% a) # 2.35 # 赋值给新的变量 c = '%.2f'% a print(c) # 2.35 2 format函数【四舍五入】 可以在print()打印处使用，也可以赋值给新的变量进行输出
# 四舍五入方法 a = 2.345566 print(format(a, '.4f')) # 2.3456 print(format(a, '.3f')) # 2.346 # 赋值给新的变量 c = format(a, '.4f') print(c) # 2.3456 3 直接截断【不进行四舍五入】 3.1 先放大指定倍数，后取整，后再除以指定倍数 1 保留三位小数：先×100，后int，后÷100
a = 2.345566 c = int(a * 100) / 100 print(c) # 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b239afca4e61a146537ccd53cba767d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/745129e7e5f84c8e687a8c30c3dc2394/" rel="bookmark">
			idea修改 项目代码，浏览器页面不生效 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用快捷键ctrl + shift + delete，清理浏览器缓存 1、问题描述
idea修改前端项目代码，运行谷歌浏览器不起作用。
我也试过 rebuild project, 重启idea，等方法都不管用。
再次运行谷歌浏览器，还是没有变化。
2、尝试了以下方法，还是不管用
2.1、rebuild project
2.2、设置idea自动编译
File-&gt;Settings-&gt;Build,Execution,Deployment-&gt;Compiler-&gt;勾选Build project automatically
2.3、ideal清理缓存并重启，
File -&gt; Invalidate caches-&gt;Invalidate and Restart
3、迎来了转机，就在我一筹莫展的时候，我用edge浏览器打开，惊奇的发现可以了
经常运行的谷歌浏览器，不起作用，但是在新浏览器edge上起作用，这可能与谷歌浏览器缓存有关，所以尝试清理谷歌浏览器缓存
4.最终解决方案，清理谷歌浏览器缓存
使用快捷键清理缓存
ctrl + shift + delete选择时间范围，建议设置 大于等于24小时
再次启动项目，运行正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/197140267009e42579ae178d1795065b/" rel="bookmark">
			写给初学者的YOLO目标检测 概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是目标检测What is YOLO?为什么YOLO在目标检测领域如此流行？1. 速度快2. 高检测精度3. 更好的泛化性4. 开源 YOLO架构YOLO目标检测是如何工作的？残差块(Residual blocks)边界框回归（Bounding box regression）交并比 IoU (Intersection over Union)非极大值抑制（Non-Maximum Suppression） YOLO的应用场景1- 应用于工业领域医疗农业 安全监控 YOLO, YOLOv2, YOLO9000, YOLOv3, YOLOv4, YOLOR, YOLOX, YOLOv5, YOLOv6, YOLOv7比较YOLO/YOLOv1，起点YOLOv2或YOLO90001- 批量归一化(批标准化)2- 更高的输入分辨率3- 使用锚框的卷积层4- 维度聚类5- 细粒度特征 YOLOv3 - 渐进式改进1- 更好的边界框预测2- 更准确的类别预测3- 在不同尺度上更准确的预测 YOLOv4 - 目标检测的最佳速度和准确性YOLOR — You Only Look One Representation1- 预测对齐2- 目标检测的预测细化3- 多任务学习的规范表示 YOLOX - 2021年超越YOLO系列1- 高效分离的头部2- 强大的数据增强3- 无锚点系统4- SimOTA标签分配 YOLOv5YOLOv6 - 一种面向工业应用的单阶段物体检测框架YOLOv7 - 可训练的免费工具包为实时目标检测器设定了新的技术水平1- 架构层面2- 可训练的免费工具包 YOLOv8结果： 结论 本文主要介绍; YOLO（You Only Look Once） 目标检测的 优势、它在过去几年中的发展情况以及一些现实生活中的应用。 什么是目标检测 目标检测（Object detection）是计算机视觉中使用的一种技术，用于识别和定位图像或视频中的对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/197140267009e42579ae178d1795065b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cd2f8ecd792fb439f599fb63a3afe5a/" rel="bookmark">
			ARM处理器的指令集（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ARM处理器的指令集 一、数据处理类指令 数据处理指令只能对寄存器的内容进行操作，而不能对内存中的数据进行操作，所以ARM数据处理指令均可以选择使用S后缀，以影响状态标志位。
影响状态标志位的命令：
MOVS–&gt;数据传送指令（只能用在寄存器和寄存器之间）
MVNS–&gt;数据传送指令（和mov区别是，不仅进行数据传输，还进行数据取反）
ADDS–&gt;加法指令
SUBS–&gt;减法指令
MULS–&gt;乘法指令
ANDS–&gt;逻辑与指令（相同是1，不同是0，区别“按位与TST"指令）
ORRS–&gt;逻辑或指令（不同是0，相同是1，区别“按位与TST"指令）
BICS–&gt;设置某一位为1
CMP–&gt;比较指令
TST–&gt;安位与指令
1.数据传送指令 用于操作数传送到目的寄存器中。
MOV R1,R0 ;将寄存器R0的值传送到寄存器R1中。
MVN R0,#0 ;将立即数0按位取反传送到寄存器R0中。
可以在MOV和MVN后面加S，S会改变CPSR的值，不加就不会改变。
2.比较指令 用于对2个操作数进行比较，同时更新CPSR中的条件标志位的值。该指令进行一次减法运算，但不存储结果，只更改条件标志位。
CMP R1,R0 ；将R1的值与R0的值相减，并更新结果CPSR的标志位，不用加S
CMN R1,#100 ;取反后相减进行比较，即将R1的值与立即数100相加，并设置标志位
3.测试指令 用于对2个操作数进行按位的与运算，并根据运算结果更新CPSR中的标志位。
TST R1,#%1 ;将R1的值与二进制1按位与运算，并改变标志位。
TEQ R1,R2 ;将R1的值与R2的值按位异或，并设置标志位，通常用来比较两个操作数的是否相等。可以看Z位，如果为Z位是1，那就相等，不是1，就不相等。
4.加法指令 用于将2个操作相加，并将结果存放到目的寄存器中,需要三个参数。
ADD R0,R1,R2 ;R1+R2=R0,操作数1+操作数2
ADC R0,R1,R2 ;R1+R2+进位数=R0
例：
MOV R0,#0Xffffffff ;0xffffffff→R0 R0=0xffffffff ADDS R0,R0,#0xffffffff ;R0=R0+0xffffffff R0=0xfffffffe,不考虑进位 ADCS R0,R0,#0xffffffff ;R0=R0+0xffffffff+进位数 R0=0xfffffff,进位标识符位C=1,R0最后还要加1 5.减法指令 用于操作数1减操作数2，并将结果存放到目的寄存器中。注意在访问CPSR时设置后缀S。
SUB R0,R1,R2 ；R0=R1-R2
SBC R0,R1,R2 ;R0=R1-R2-!C 操作数1减操作数2,再减去标志位C位的反码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cd2f8ecd792fb439f599fb63a3afe5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/470548bc01215c58acf5144b09362a2b/" rel="bookmark">
			Git（六）：基本命令（3）：储藏、标签、拉取、子模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
17、stash 储藏
17.2 描述
17.3 基本用法
18、tag 标签
18.1 描述
18.2 基本用法
19、fetch 获取
19.1 描述
19.2 基本用法
20、pull 整合
20.1 描述
20.2 基本用法
20.3 pull 与 fetch 的区别
21、push 更新推送
21.1 描述
21.2 基本用法
22、remote 管理
22.1 基本用法
23、submodule 管理子模块
23.1 使用场景
23.2 描述
23.3 基本用法
24、show 显示
24.1 描述
24.2 基本用法
25、shortlog 汇总
25.1 基本用法
26、describe 显示最近标签
26.1 描述
26.2 基本用法
27、rebase 合并修改
27.1 示例
17、stash 储藏 用于将更改储藏在脏工作目录中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/470548bc01215c58acf5144b09362a2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34483d7f7ae73f2469964e7dadc528db/" rel="bookmark">
			c&#43;&#43;中public、private和protected
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类的三个特性：封装、继承、多态
封装，public和private作用就是实现这一目的，类外可以访问public成员而不能访问private成员。
private成员只能由类内成员和友元成员访问。
继承，protected作用就是实现这一目的，protected成员可以被派生类对象访问，不能被类外成员访问。
public继承，基类public成员，protected成员，private成员的访问属性在派生类中分别变成：public、protected、private。
protected继承，基类public成员，protected成员，private成员的访问属性在派生类中分别变成：protected，protected、private。
private继承，基类public成员，protected成员，private成员的访问属性在派生类中分别变成：private、private、private。
https://zhuanlan.zhihu.com/p/70758317
public：类内类外都可以访问。
protected：类内可以访问，类外不可以访问。
private：类内可以访问，友元可以访问，类外不可以访问。
继承时：
class A ：public B：public、protected、private还是public、protected、private，保持原有特性，其中private不能被派生类访问。
class A ：protected B ：public、protected、private变成了protected、protected、private，保持原有特性，其中private不能被派生类访问。
class A ：private B ：public、protected、private变成了private、private、private，其中private不能被派生类访问。
基类是private，派生类不能访问基类private成员！
基类是private，派生类不能访问基类private成员！
基类是private，派生类不能访问基类private成员！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a15e28ae0eac0d763b441422a3826c2a/" rel="bookmark">
			mysql如何正确的删除数据(drop,delete,truncate)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们需要删除 MySQL 数据库中的数据时，通常有三种可供选择的命令，即 DROP、DELETE 和 TRUNCATE。虽然这三个命令都可以用来删除数据，但它们之间有一些不同点。在本篇博客中，我们将会详细介绍这三个命令的用法和区别。
mysql如何正确的删除数据drop,delete,truncate 1、DROP2、DELETE3、TRUNCATE4、总结 1、DROP DROP 命令用于删除整个数据库或表。如果你想要删除整个数据库，可以使用如下命令：
DROP DATABASE database_name; 如果你只想删除表格，可以使用如下命令：
DROP TABLE table_name; ⚠️DROP 命令会彻底删除整个数据库或表格及其所有数据和结构。这意味着删除后无法恢复，因此在使用该命令时应该非常小心。
2、DELETE DELETE 命令用于删除表格中的行。它允许你根据特定的条件删除表格中的一部分数据。例如，如果你想删除名字为 “John” 的行，可以使用如下命令：
DELETE FROM table_name WHERE name = 'John'; ⚠️DELETE 命令可以根据条件删除表格中的任何行。但是，删除操作会留下一些空间，因为数据只是被标记为“已删除”，并未被实际删除。这意味着，虽然数据在逻辑上已被删除，但在物理上仍然存在于数据库中。
3、TRUNCATE TRUNCATE 命令与 DELETE 命令非常相似，都是用于删除表格中的行。但是，TRUNCATE 命令会删除表格中的所有行，并释放所有占用的空间。如果你想删除一个表格的所有数据并释放空间，可以使用如下命令：
TRUNCATE TABLE table_name; ⚠️TRUNCATE 命令会删除表格中的所有行，并将表格重置为其初始状态。它比 DELETE 命令更快，并且会释放所有占用的空间。但是，与 DELETE 命令不同，TRUNCATE 命令无法根据条件删除表格中的部分数据。
4、总结 DROP、DELETE 和 TRUNCATE 命令都可以用于删除 MySQL 数据库中的数据。DROP 命令可以用于删除整个数据库或表格，DELETE 命令可以用于根据条件删除表格中的部分数据，而 TRUNCATE 命令可以删除整个表格并释放所有占用的空间。当使用这些命令时，应该非常小心，以免意外删除了重要的数据。在使用 TRUNCATE 和 DELETE 命令时，应该特别注意删除操作是否能够被撤销，以免造成无法挽回的损失。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1af703f733d05da1e7b67bd2b905ae0a/" rel="bookmark">
			yolov5导出onnx模型报错：Unsupported ONNX opset version: 17
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win10系统下使用pytorch1.11.0、onnx1.12.0转换yolov5cls转换onnx报错如下。
查找了相关资料后是由于pytorch对onnx算子的不支持
参考资料：
1、模型部署，https://zhuanlan.zhihu.com/p/498425043
2、onnx算子文档，https://github.com/onnx/onnx/blob/main/docs/Operators.md
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a49d4f486697acce4e01a23e6a63598f/" rel="bookmark">
			使用Rider断点调试lua代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下：
新建调试配置
在 Rider 工具栏的 Debug Config 中点击 Editor Configigurations ，然后点击+号，新建一个 Emmy Debugger（NEW），输入调试器名字为 Tcp（Debugger connect IDE），选择 Connection 类型。
Rider 充当服务器
1、将“新建调试配置”的调试代码复制到 HotUpdate.lua 中（添加 socket 调试入口代码）
package.cpath = package.cpath … ‘自己的emmy_core路径’
local dbg = require(‘emmy_core’)
dbg.tcpConnect(‘localhost’, 9966)
2、在 LuaLoader.cs 中绕过 emmy_core 脚本的加载路径指定。
if (fileName == “emmy_core”)
{
return base.ReadFile(fileName);
}
3、回到 Rider 的主界面，选择 EmmyLua 做为调试器，启动 EmmyLuaDebugger，此时控制台应该会输出：
调试代码
启动 Unity，就可以愉快地调试代码。
出现该错误是因为手动在 Rider 中关闭 Debugger。
如果是 Lua 代码调试，那么可以在不关闭 Debugger 的情况下修改代码，因此只需要每次启动 Unity 即可，不需要每次关闭 Debugger。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a49d4f486697acce4e01a23e6a63598f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b891b07aec4da6f99fb616aef3acafd/" rel="bookmark">
			CityGML标准文档（14）（第七章——7.2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7.2 CityGML 配置文件 CityGML配置文件是主题扩展模块与CityGML核心模块的结合。每个CityGML实例文档都将应采用与所提供数据相匹配的CityGML 配置文件。通常，有两种方式来区分一个实例文档是否使用CityGML配置文件 ：
1.CityGML配置文件的定义嵌入在CityGML实例文档中 CityGML配置文件可以使用在XMLSchema实例名称空间中定义的schemaLocation属性绑定到实例文档中，http://www.w3.org/2001/XMLSchema-instance（通常与前缀xsi关联）。在一个XML 实例文档中，xsi:schemaLocation属性提供了一种能定位已定义了命名空间的XML模式定义的方法。它的值是一个以空格分隔的统一资源标识符（URI）对列表，其中每对都由一个命名空间组成，后面跟着该命名空间的XML Schema定义的位置，该定义通常是.xsd文件。
通过这种方式，各个CityGML模块的名称空间在CityGML实例文档中进行定义。然后，xsi:schemaLocation属性用来为每个模块的XML Schema定义提供位置。附件G中给出的所有实例文件都遵循第一种方法。
2.CityGML配置文件定义由单独的XML schema文件提供 CityGML配置文件也可以由其自己的XML Schema文件指定。该模式文件通过导入相应的XML Schema定义来组合适当的CityGML模块。这种情况下，应使用XML Schema命名空间中定义的 import元素，http://www.w3.org/2001/XMLSchema （通常与前缀xs关联）。对于xs:import元素，必须声明导入的CityGML模块的命名空间以及命名空间的XMLSchema定义的位置。为了将CityGML配置文件应用于实例文档，必须使用xsi:schemaLocation属性将配置文件的schema绑定到实例文档。CityGML配置文件的XML Schema文件不得包含任何更进一步的内容。
配置文件格式中的targetNamespace应与导入的CityGML模块的命名空间不同。与配置文件关联的命名空间应该由实例文档的发起者控制，并且必须作为以前未使用的全局唯一URI进行提供。分析相关CityGML实例文档的每个人都必须可以使用（或可以在互联网上访问）配置文件的XML Schema文件。
第二种方法通过以下CityGML基本配置文件的XMLSchema定义示例进行了说明。由于基本概要文件是所有CityGML模块的并集，因此相应的XMLSchema定义会导入每个CityGML模块。通过这种方式，CityGML数据模型的所有组件都可以进行使用，并且可以通过引用此示例基本配置文件的实例文档进行交换。基本配置文件的模式定义文件随CityGML模式包一起提供，可访问http://schemas.opengis.net/citygml/profiles/base/2.0/City
&gt; &lt;xs:schema xmlns="http://www.opengis.net/citygml/profiles/base/2.0" &gt; xmlns:xs="http://www.w3.org/2001/XMLSchema" &gt; targetNamespace="http://www.opengis.net/citygml/profiles/base/2.0" &gt; elementFormDefault="qualified" attributeFormDefault="unqualified" &gt; version="2.0.0"&gt; &lt;xs:import &gt; namespace="http://www.opengis.net/citygml/appearance/2.0" &gt; schemaLocation="http://schemas.opengis.net/citygml/appearance/2.0/appearance.xsd"/&gt; &gt; &lt;xs:import namespace="http://www.opengis.net/citygml/bridge/2.0" &gt; schemaLocation="http://schemas.opengis.net/citygml/bridge/2.0/bridge.xsd"/&gt; &gt; &lt;xs:import namespace="http://www.opengis.net/citygml/building/2.0" &gt; schemaLocation="http://schemas.opengis.net/citygml/building/2.0/building.xsd"/&gt; &gt; &lt;xs:import &gt; namespace="http://www.opengis.net/citygml/cityfurniture/2.0" &gt; schemaLocation="http://schemas.opengis.net/citygml/cityfurniture/2.0/cityFurniture.xsd"/&gt; &gt; &lt;xs:import &gt; namespace="http://www.opengis.net/citygml/cityobjectgroup/2.0" &gt; schemaLocation="http://schemas.opengis.net/citygml/cityobjectgroup/2.0/cityObjectGroup.xsd"/&gt; &gt; &lt;xs:import namespace="http://www.opengis.net/citygml/generics/2.0" &gt; schemaLocation="http://schemas.opengis.net/citygml/generics/2.0/generics.xsd"/&gt; &gt; &lt;xs:import namespace="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b891b07aec4da6f99fb616aef3acafd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e70149dc193c8ccbc7727a7ef6daf91c/" rel="bookmark">
			Java线程协作的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 Java中线程协作的最常见的两种方式：利用Object.wait()、Object.notify()和使用Condition方法一 Object中的wait、notify、notifyAll方法定义如下public final native void notify(); public final native void notifyAll(); public final native void wait(long timeout) throws InterruptedException;wait()、notify()和notifyAll()方法是本地方法，并且为final方法，无法被重写调用某个对象的wait()方法能让当前线程阻塞，并且当前线程必须拥有此对象的monitor（即锁）调用某个对象的notify()方法能够唤醒一个正在等待这个对象的monitor的线程，如果有多个线程都在等待这个对象的monitor，则只能唤醒其中一个线程调用notifyAll()方法能够唤醒所有正在等待这个对象的monitor的线程之所以这三个方法声明在Object类中是因为每个对象都拥有monitor（即锁）调用某个对象的wait()方法，当前线程必须拥有这个对象的monitor（即锁），因此调用wait()方法必须在同步块或者同步方法中进行示例 public class Test { public static Object object = new Object(); public static void main(String[] args) { Thread1 thread1 = new Thread1(); Thread2 thread2 = new Thread2(); thread1.start(); try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } thread2.start(); } static class Thread1 extends Thread{ @Override public void run() { synchronized (object) { try { object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e70149dc193c8ccbc7727a7ef6daf91c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49ae668f3c27f68f7962aa97c023422f/" rel="bookmark">
			No module named ‘quaternion‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		### 解决办法
首先卸载原本的quaternion（有的文件要手动删，不删应该也没事）
python -m pip uninstall quaternion 然后
python -m pip install --upgrade --no-deps --force-reinstall numpy-quaternion 成功！
### 问题原因
直接安装的quaternion是假的
pip install quaternion 这是错误做法，安装的是Quaternion
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79c4f203a289c6cb80e132eb69f795f1/" rel="bookmark">
			C语言中的if语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言中的if语句：
if语句是一种判断语句，当条件满足（表达式为真）时执行其内部语句，否则不执行。
if语句的三种形式：
第一种：if语句
if （表达式）{语句；}
如果表达式成立，则执行语句
如果表达式不成立，则不执行语句
例如：
if(6&gt;5){ printf("真好吃！");} //6&gt;5为真，则执行语句printf("真好吃！") if(2&gt;3){ printf("真倒霉！");} //2&gt;3为假，则不执行语句printf("真倒霉！") 第二种：if-else语句
if（表达式）{语句1；}else {语句2；}
如果表达式成立，则执行语句1,不执行语句2
如果表达式不成立，则不执行语句1，执行语句2
例如：
if(8&gt;5){ printf("真漂亮！");}else { printf("西瓜！"); } //8&gt;5为真，则执行语句 printf("真漂亮！")不执行语句printf("西瓜！") if(6&gt;9){ printf("真漂亮！");}else { printf("西瓜！"); } //6&gt;9为假，则不执行语句 printf("真漂亮！")执行语句printf("西瓜！") 第三种：if-else-if语句
if (表达式1){
语句1;
}else if(表达式2){
语句2;
}else if(表达式3){
语句3;
}....else if(表达式n){
语句n;
}else{
语句W;
}
程序自上而下执行，当某一表达式为真时，执行其内部的语句，执行完后跳出if-else-if语句
例如：
if (3&gt;5) { printf("西瓜"); } else if (7&gt;4) { printf("橘子"); } else if (9&gt;8) { printf("桃子"); }else{ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79c4f203a289c6cb80e132eb69f795f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a59b14a4daa9bb41b0e978e37977c79b/" rel="bookmark">
			unity如何锁定鼠标光标位置并且隐藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 介绍 unity如何锁定鼠标光标位置并且隐藏？常见fps游戏需要这样的设定
方法 Unity中隐藏鼠标光标的方法是使用 Cursor.visible 属性和 Cursor.lockState 属性。
要隐藏鼠标光标，可以将 Cursor.visible 属性设置为 false，同时将 Cursor.lockState 设置为 CursorLockMode.Locked，这将锁定鼠标在屏幕中央并隐藏光标。
以下是一个简单的示例代码，演示如何在Unity中隐藏鼠标光标：
void Start() { Cursor.visible = false; Cursor.lockState = CursorLockMode.Locked; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d58d7986855b0477686c9578cff1a41/" rel="bookmark">
			java 倒计时实现的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		倒计时的实现方法有很多种，本文给大家介绍其中一种，最简单的一种实现方式，也是最方便的一种方式，希望能帮到大家。 1、 java中倒计时是利用循环来实现的，我们可以使用循环语句来实现。 2、 java中使用 bool类的 setTimeout方法也是可以实现倒计时的。 3、 java中还有一种方式是利用列表实现的，但是这种方式比较麻烦，要给每个元素都加上task_value属性，代码如下： 4、 java中还有一种使用了 myTaskManager类来实现倒计时，这是一种用到了时间类的task_value属性来实现的。 5、 java中还有一种使用列表来实现倒计时的方式，我们可以使用 left （）方法来获取当前元素在列表中的位置，然后使用 found （）方法获取列表中的下一个元素。 6、 java中还有一种方式是使用 setTimeout方法来实现倒计时，这种方式比上面两种要简单一些。 7、 java中还有一种是用到了 for循环和 while循环来实现倒计时。
1.使用 for循环
在 Java中， for循环语句是一个非常常用的语句，也是一个非常有用的语句，在 Java中用到 for循环语句的地方非常多，下面举两个例子来说明一下。 示例1: 示例2: 上面两个示例都是利用 for循环来实现倒计时的。上面这两个示例中使用的循环语句都是 for循环语句，下面我们来看看用 for循环实现倒计时的代码： 上面两个代码都是先初始化一个变量，然后使用 found （）方法获取当前元素在列表中的位置，然后使用 for循环来实现倒计时。上面这两个代码都是使用 for循环语句来实现倒计时的，下面我们再来看看 myTaskManager类中使用 setTimeout方法实现倒计时的代码：
2.使用 myTaskManager类的task_value属性
在上面的代码中，我们先给 myTaskManager类添加一个task_value属性，然后再用 setTimeout （）方法来获取当前元素的位置，然后再用 for循环和 while循环来获取列表中的下一个元素。 上面这段代码其实也很简单，只不过它没有添加任何的条件语句，也没有循环语句，而且在执行的过程中也没有判断下一个元素是不是需要添加条件。所以我们只要把上面这段代码改一下就可以了。 上面的代码也是利用task_value属性来实现倒计时的，只不过它没有添加任何的条件语句，也没有循环语句，只是在执行的过程中，给每一个元素都加上了task_value属性而已。
3.使用 myTaskManager实现倒计时，需要给每个元素都加上task_value属性
java中实现倒计时还有很多种方式，因为使用的语言不同，所以实现的方法也是不同的。在这里给大家介绍一种最简单，最方便的一种方式。 1、首先定义一个倒计时类，然后在这个类中定义一个倒计时变量，使用 for循环来实现倒计时。 2、在这个类中定义一个 myTaskManager类，然后使用 myTaskManager对象来实现倒计时。 3、在 myTaskManager对象中，在左边属性栏中定义了一个task_value属性，然后在右边属性栏中定义了一个 timestamp值。
4.使用列表实现倒计时
在 Java中使用列表实现倒计时的方法和上面提到的三种方式都不一样，下面我们就来看一下 java中用列表实现倒计时的方法： 2)、在循环语句中使用列表实现倒计时的方法和上面介绍的三种方式都是一样的，只是要给每个元素都加上task_value属性。 3)、在循环语句中使用列表实现倒计时的方式只适合于元素比较少或者是在循环语句中使用，如果想要实现较多元素的倒计时方式就不太适合了。 4)、使用列表实现倒计时最简单，但是也是最麻烦的一种方式，因为它需要给每个元素都加上task_value属性，因此我们在使用这种方式时，要给每个元素都加上task_value属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d58d7986855b0477686c9578cff1a41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1c1cf70332233e625fee7764eff20f1/" rel="bookmark">
			使用C语言创建登录系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人大一作品，适合初学者使用，利用优化登陆系统的构建来巩固C语言基础。具体为三个从简单到稍微复杂的登录系统： 第一版本
①第一个版本的登录系统十分简陋，只能在当次运行时进行登录和注册，再次运行时需要重新注册才可以登录，并不能实现隐藏密码的功能。
#define _CRT_SECURE_NO_WARNINGS 1 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; struct zhanghu//用户信息储存 { char name[20]; char zhanghao[20]; char mima[20]; }; int zhuce(struct zhanghu zh[],int m);//注册模块 void denglu(struct zhanghu zh[],int m);//登录模块 void menu(void);//菜单 void again(struct zhanghu zh[], char l[]);//检测模块 int main(void)//主程序 { int m=0; int k; struct zhanghu zh[100]; while (1) { menu(); printf("请选择服务："); scanf("%d",&amp;k); switch (k) { case 1: zhuce(zh, m); m++; printf("%d\n\n",m); break; case 2: denglu(zh, m); break; case 3: printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1c1cf70332233e625fee7764eff20f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/118b82c0e3aa2f35497408f07a3ea8f6/" rel="bookmark">
			PySpark基础入门（1）：基础概念＋环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Spark基础入门
spark基础概念
spark架构
Spark环境搭建
local模式
Standalone 模式
Spark On YARN 模式
PySpark开发环境搭建
Python On Spark 执行原理 更好的阅读体验：PySpark基础入门（1）：基础概念＋环境搭建 - 掘金 (juejin.cn)
Spark基础入门 版本：Spark3.2.0
特性：完善了对Pandas API的支持
spark基础概念 Apache Spark是用于大规模数据处理的统一分析引擎 Spark 的核心数据结构：弹性分布式数据集（RDD），支持在大规模集群中的内存计算Spark 借鉴了 MapReduce 思想发展而来，保留了其分布式并行计算的优点并改进了其明显的缺陷。让中间数据存储在内存中提高了运行速度、并提供丰富的操作数据的API提高了开发速度 如何理解“统一分析引擎”？ spark可以对任意类型的数据进行自定义计算，比如说结构化、半结构化、非结构化等各种类型的数据结构；spark支持使用多种语言，如Python、Java、Scala、R以及SQL语言去开发应用程序计算数据 spark和hadoop的对比
在计算层面，Spark相比较MR（MapReduce）有巨大的性能优势Spark仅做计算，而Hadoop生态圈不仅有计算（MR）也有存储（HDFS）和资源管理调度（YARN），HDFS和YARN仍是许多大数据体系的核心架构Spark处理数据与MapReduce处理数据的不同点： Spark处理数据时，可以将中间处理结果数据存储到内存中Spark 提供了非常丰富的算子(API), 可以做到复杂任务在一个Spark 程序中完成 *Hadoop的基于进程的计算和Spark基于线程方式优缺点
Hadoop中的MR中每个map/reduce task都是一个java进程方式运行，好处在于进程之间是互相独立的，每个task独享进程资源，没有互相干扰，监控方便，但是问题在于task之间不方便共享数据，执行效率比较低。比如多个map task读取不同数据源文件需要将数据源加载到每个map task中，造成重复加载和浪费内存。而基于线程的方式计算是为了数据共享和提高执行效率，Spark采用了线程的最小的执行单位，但缺点是线程之间会有资源竞争
spark的特点
速度快：Spark支持内存计算，并且通过DAG（有向无环图）执行引擎支持无环数据流通用性强： 在 Spark 的基础上，Spark 还提供了包括Spark SQL、Spark Streaming、MLib 及GraphX在内的多个工具库，我们可以在一个应用中无缝地使用这些工具库Spark 支持多种运行方式，包括在 Hadoop 和 Mesos 上，也支持 Standalone的独立运行模式，同时也可以运行在云Kubernetes上（2.3之后）Spark 支持从HDFS、HBase、Cassandra 及 Kafka 等多种途径获取数据 spark框架模块
Spark Core：Spark的核心，Spark核心功能均由Spark Core模块提供，是Spark运行的基础。Spark Core以RDD为数据抽象，提供Python、Java、Scala、R语言的API，可以编程进行海量离线数据批处理计算。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/118b82c0e3aa2f35497408f07a3ea8f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/568f25c27b86634f5882931c3dddeddb/" rel="bookmark">
			更改docker数据目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、背景
二、挂载数据库盘
1、 查看在云上挂载好的100G数据盘
2、 数据盘sdb分区，使用到的分区命令为fdisk
3、 将已做好分区的数据盘格式化为ext4格式
4、挂载数据盘
5、写入开机自动挂载
三、更新docker数据目录
四、删除docker旧存储数据
提示： 更深入的docker优化技巧，镜像加速等内容见：https://blog.csdn.net/weixin_44770684/article/details/130018908https://blog.csdn.net/weixin_44770684/article/details/130018908
一、背景 在生产环境有一个于构建镜像发布的docker服务器，该docker服务器是云主机，系统盘为40G，而docker默认的数据库目录为 /var/lib/docker ,使用的是系统盘做存储，随着时间的推移，该docker服务器存在的已构建的镜像越来越多，需要使用的存储空间也越来越多，导致该docker服务器系统盘没有足够的存储空间。
为了保证docker服务器有更多的存储空间，需要额外挂载一块数据盘到该docker服务器，并且更改该docker数据库目录到数据盘。
二、挂载数据库盘 1、 查看在云上挂载好的100G数据盘 fdisk -l 2、 数据盘vdb分区，使用到的分区命令为fdisk fdisk /dev/vdb [root@erp02 ~]# fdisk /dev/vdb Welcome to fdisk (util-linux 2.23.2). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. Device does not contain a recognized partition table Building a new DOS disklabel with disk identifier 0xc227e904.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/568f25c27b86634f5882931c3dddeddb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf9eb73d7cc5843a281be2cd23716a03/" rel="bookmark">
			ARM汇编语言（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ARM汇编语言 一、引言 ARM汇编语言是一种低级别的计算机指令集架构（ISA）语言，它是ARM处理器上的一种指令集架构，用于编写底层的系统软件，例如操作系统、驱动程序和嵌入式系统应用程序。
ARM汇编语言使用基于寄存器的指令集，其中指令操作的数据通常存储在处理器的寄存器中，而不是内存中。ARM汇编语言使用汇编指令来控制计算机的操作，例如数据传输、算术和逻辑操作、分支和跳转指令等等。
ARM汇编语言的语法通常是简单直观的，并且与其他汇编语言相似，但是具体的语法规则会因不同的ARM处理器型号而有所不同。编写ARM汇编语言代码需要对底层计算机硬件和指令集架构的工作原理有深入的理解。
二、ARM处理器的寻址方式 1.寄存器寻址 将一个寄存器的值传送到另一个寄存器的操作。
MOV R1,R2 ；R2→R1，将寄存器R2的值传送到寄存器R1 指令执行时对寄存器中的值直接取出进行操作。
2.立即寻址 立即寻址方式的目的就是将操作数紧跟在操作码后面，与操作码一起放在指令代码段中，在程序运行时，程序直接调用该操作数，而不需要到其他地址单元中去取相应的操作数，上述的写在指令中的操作数也称作立即数。
MOV R0,#0x1234
MOV为操作码，R0为第一操作数，0x1234为立即数
立即数（immediate）是指在指令中直接指定的数据值，必须对应8位常数通过循环右移偶数位的得到，立即数通常被用于指令中的常量、地址、偏移量。
如何判断快速判断这个立即数合法：
（1）首先把这个数用二进制表示出来，顺着看和循环看数中“1”的最大间隔是否都大于8（包含首尾的两个1），如果大于8，那这个数肯定是非法的。如果有一次小于等于8则有可能是合法的。
例如:
0x1101的二进制为：0000 0000 0000 0000 0001 0001 0000 0001，无论顺着看和循环看，两个1的最大间隔都大于8，所以不是立即数。
（2）方法1：
如果两个1的最大间隔都大于8，一定不是立即数。
如果顺序看时1的最大间隔等于8，此时可以看看，这个数最高位1的前面或者最低位1的后面是否有偶数个0，只要一种情况下有，这个数就是合法的。
如果循环看时1的最大间隔小于等于8，此时可以看看，循环看时，两端得到的间隔个数是否有一个为偶数，如果有一个是偶数，这个数就是合法的。
（3）方法2：
1.把数据转换成二进制形式，从低位到高位写成4位1组的形 式，高位一组不够四位的，在高位前面补0。
2.数1的个数，如果大于8个肯定不是立即数，如果小于等于8进行下面步骤。
3.如果数据中间有连续的大于等于24个0,循环左移4的倍数，使高位全为0。
4.找到高位的1，去掉前面大偶数个0。
5.找到低位的1，去掉后面大偶数个0。
6.数剩下的位数，如果小于等于8位，那么这个数就是立即数，反之就不是立即数。
总结：判断立即数时，先把它化成二进制，然后取八位数，看左右移动偶数位是否能还原。
例如：
1、判断 0X20000018 是不是立即数：
把数据转换成二进制 0010 0000 0000 0000 0000 0000 0001 1000 循环右移32-3=29次得到原来的数，所以不是立即数。
2、判断0x104是不是立即数：
把数据转化为二进制0000 0000 0000 0000 0000 0001 0000 0100如果取01000001循环32-2=30次得到原数，如果取10000010，循环32-1=31次得到原数。
在ARM汇编语言中，立即数可以使用前缀“#”来表示，表示16进制数值时用“0x”表示，注意“#”后面一定是一个合法的立即数。例如，下面的指令中：
ADD R0, R0, #10 ;R0+10→R0 ,将立即数10加到寄存器R0中 MOV R0,#0x1234 ;0x1234→R0 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf9eb73d7cc5843a281be2cd23716a03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47f06f5f1bbb08179955325d6f21e7a9/" rel="bookmark">
			docker-harbor私有仓库的部署与管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Harbor
Harbor介绍
Harbor的特性
Harbor的构成
部署Harbor
搭建本地私有仓库
Docker容器的重启策略
部署Docker-compose服务
部署Harbor服务
关于Harbor.cfg配置文件中两类参数
启动Harbor
查看 Harbor 启动镜像
创建一个新项目
在其他客户端上传镜像
维护管理Harbor
通过 Harbor Web 创建项目
创建 Harbor 用户
添加项目成员
在客户端上使用普通账户操作镜像
查看日志
修改 Harbor.cfg 配置文件
移除 Harbor 服务容器同时保留镜像数据/数据库，并进行迁移
Harbor Harbor介绍 Harbor 是 VMware 公司开源的企业级 Docker Registry 项目，其目标是帮助用户迅速搭建一个企业级的 Docker Registry 服务。
Harbor以 Docker 公司开源的 Registry 为基础，提供了图形管理 UI 、基于角色的访问控制(Role Based AccessControl) 、AD/LDAP 集成、以及审计日志(Auditlogging) 等企业用户需求的功能，同时还原生支持中文。
Harbor 的每个组件都是以 Docker 容器的形式构建的，使用 docker-compose 来对它进行部署。用于部署 Harbor 的 docker-compose 模板位于 harbor/docker-compose.yml。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47f06f5f1bbb08179955325d6f21e7a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaaa12a595e519e33987222b5de9ae97/" rel="bookmark">
			react配置代理代码记录（基础）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 俩种方法，别问为啥是图片，因为是万能的群友分享出来的 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3a70eea5d599950986b12cc981bc82c/" rel="bookmark">
			Android的RecyclerView实现列表拖动（移动顺序）交换数据位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.先看效果图
这是拖动前的图片
这是拖动列表改变位置后的图片
这里放上视频演示
RecyclerView实现列表拖动交换数据位置
2.主活动MainActivity2类代码如下
import androidx.appcompat.app.AppCompatActivity; import androidx.recyclerview.widget.ItemTouchHelper; import androidx.recyclerview.widget.LinearLayoutManager; import androidx.recyclerview.widget.RecyclerView; import android.annotation.SuppressLint; import android.os.Bundle; import com.example.myapplication001.R; import java.util.ArrayList; import java.util.Collections; import java.util.List; public class MainActivity2 extends AppCompatActivity { private HomeAdapter rv_1_homeAdapter; RecyclerView rv_1; LinearLayoutManager rv_1_Manager; ItemTouchHelper mItemTouchHelper; List&lt;String&gt; titles; @SuppressLint({"MissingInflatedId", "WrongViewCast"}) @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); rv_1=findViewById(R.id.rv_1); titles = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 50; i++) { titles.add("中文"+i); } rv_1_homeAdapter = new HomeAdapter(getApplicationContext(),titles); rv_1_Manager=new LinearLayoutManager(getApplicationContext()); //这里使用垂直滑动 rv_1_Manager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3a70eea5d599950986b12cc981bc82c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbaa375c496c6572741b80624125aeb7/" rel="bookmark">
			Vue 图片、视频文件的直接下载和在线查看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、直接下载 // 仅支持视频下载和图片下载 /** * * @param {文件路径} url * @param {文件名称} name */ downLoad(url, name) { var xhr = new XMLHttpRequest(); xhr.open('GET', url, true); xhr.responseType = 'arraybuffer'; // 返回类型blob xhr.onload = function() { if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) { let blob = this.response; console.log(blob); // 转换一个blob链接 // 注: URL.createObjectURL() 静态方法会创建一个 DOMString(DOMString 是一个UTF-16字符串)， // 其中包含一个表示参数中给出的对象的URL。这个URL的生命周期和创建它的窗口中的document绑定 let downLoadUrl = window.URL.createObjectURL(new Blob([blob], { type: 'video/mp4' })); // 视频的type是video/mp4，图片是image/jpeg // 01.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbaa375c496c6572741b80624125aeb7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/145/">«</a>
	<span class="pagination__item pagination__item--current">146/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/147/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>