<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cec34ddb27a2fd4b3b6b5bd61417e13/" rel="bookmark">
			吴恩达深度学习学习笔记——C5W1——循环序列模型（RNN）——练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C5W1 Quiz - Recurrent Neural Networks 20230626 updated:
Ans: A
Ans: A
Ans: B、D
4.
Ans: C
Ans: D
Ans: B
Ans: D
Ans: C
Ans: A
Ans: C
1. Suppose your training examples are sentences (sequences of words). Which of the following refers to the j^{th}jth word in the i^{th}ith training example?
Ans: x(i)&lt;j&gt;
2. Consider this RNN: This specific type of architecture is appropriate when:
Ans: T_x = T_y
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cec34ddb27a2fd4b3b6b5bd61417e13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb877514efa10f9616ebfcde93a25994/" rel="bookmark">
			elasticsearch7.17开发笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目中如何引入elasticsearch是一个值得研究的问题，本系列文章不谈论相关概念，主要对笔者在java开发过程中的流程及相关问题进行记录，也可以供大家作为学习笔记使用
java版本：11 后台框架：SpringCloudAlibaba 2021.0.3 es版本：7.17 es服务器系统：linux 流程记录 一、Linux安装Elasticsearch、ik、kibana
由于关于es安装的现有相关文章非常完善，则直接贴上文章地址
二、es-head安装
es-head主要对es数据进行管理，可以直观看到索引列表和数据列表
三、java调用es - 生成连接、查询系统参数、索引相关操作
四、java调用es - 新增数据，基本数据查询，条件筛选查询，追加条件查询
五、elasticsearch7.17.3 实现按中文分词
六、elasticsearch7.17.3实现类似mysql的like查询
七、elasticsearch7.17.3实现以图搜图
八、elasticsearch7.17.3实现按terms传入顺序排序，类似mysql中order by filed()的排序方式
错误记录 一、canal的sql中含有group by语句时增量同步报空指针异常
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8278337432ee6926d1f3b798405a5478/" rel="bookmark">
			Jenkins 相关命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 重启 Jenkins service jenkins restart 启动 Jenkins service jenkins start 停止 Jenkins service jenkins stop 查看 Jenkins 进程 ps -ef | grep jenkins 查看 Jenkins 状态 service jenkins status 修改端口（Jenkins默认端口是 8080） vi /etc/sysconfig/jenkins # 修改下面内容 JENKINS_PORT="8080" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/885657612d1d2cf4416fe16cc479f290/" rel="bookmark">
			idea快捷键总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 查看类中的方法 1.1 Alt+7 按快捷键 Alt+7就能显示当前类中的所有方法、全局常量，方法还包括形参和返回值
1.2 Ctrl + F12
当前类中查找一个方法快捷键：第一步：Ctrl + F12 第二步：直接输入要查找的方法名
1.3 Alt+F7 查看一个方法被其它那些方法对象调用
1.4 Ctrl+Alt+H 查看一个方法被其它那些方法对象调用或者点击菜单栏的Navigate --&gt; Call Hierarchy
2 代码自动补全 2.1 Alt+/ 修改方法如下：
点击 文件菜单(File) –&gt; 点击 设置(Settings… Ctrl+Alt+S), –&gt; 打开设置对话框。
在左侧的导航框中点击 KeyMap。 接着在右边的树型框中选择 Main menu –&gt; Code –&gt; Completion. 接着需要做两件事： 1. 移除原来的Cycle Expand Word 的 Alt+/ 快捷键绑定。 2. 在 Basic 上点击右键,去除原来的 Ctrl+空格 绑定,然后添加 Alt+/ 快捷键。
然后应用(Apply), OK.
2.2 Alt+Insert 生成代码(如get,set方法,构造函数等) 2.3 Ctrl+Alt+T 生成try catch（这个被qq热键占用，需要修改成ctrl+alt+R）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/885657612d1d2cf4416fe16cc479f290/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bee981a7aa4ab9f5a762c9fbfd917415/" rel="bookmark">
			Ansible简介及安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、基本概念 Ansible是近年来越来越火的一款轻量级运维自动化工具，主要功能为帮助运维实现运维工作的自动化、降低手动操作的失误、提升运维工作效率。常用于自动化部署软件、自动化配置、自动化管理，支持playbook编排。配置简单，无需安装客户端，被管理端主机通过ssh协议通信。Ansible本身不具有自动化部署功能，全交由其丰富的模块实现。
2、核心组件 连接插件：负责与被管理端通信主机清单：配置被管理的主机模块：进行各种自动化部署playbook(剧本)：实现对自动化部署进行流程控制 3、架构 以上即为Ansible的基本架构图，控制端于客户端基于ssh进行通信，涉及的部署任务也是基于ssh（密码认证或者密钥认证）。
Ansible：核心Host Inventoy：定义被管理的主机群组Playbook：定义要执行的具体的任务Plugins：集成的各类插件实现更多的功能Modules：包含Ansible的核心模块及自定义的扩展模块 3、安装 由于ansible如那件包由epel源提供，所以需要先安装epel源。
# 安装epel源 yum install -y epel-release # 安装 yum install ansible -y # 查看版本 ansible --version ansible [core 2.14.2] config file = /etc/ansible/ansible.cfg configured module search path = ['/root/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules'] ansible python module location = /usr/lib/python3.11/site-packages/ansible ansible collection location = /root/.ansible/collections:/usr/share/ansible/collections executable location = /usr/bin/ansible python version = 3.11.2 (main, Jun 22 2023, 04:35:24) [GCC 8.5.0 20210514 (Red Hat 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bee981a7aa4ab9f5a762c9fbfd917415/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8321402a1a9afaa36fb7f008fee9bc2a/" rel="bookmark">
			chatgpt赋能python：Python解析宏定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python解析宏定义 在Python编程中，宏定义是一种强大的工具，允许程序员为代码中的变量或函数定义常量值或缩写。这些宏定义可以在整个代码中使用，从而减少代码的重复性，提高代码的可读性和可维护性。
什么是宏定义？ 宏定义是一种预处理器指令，用于在编译代码之前替换代码中的文本。在Python中，我们可以使用#define指令来创建宏定义。一个宏定义包括宏名称和宏值，以及可选的参数列表。
下面是一个示例：
#define PI 3.14159 radius = 10 circumference = 2 * PI * radius 在这个例子中，我们使用#define指令定义了一个名为PI的宏，它的值是3.14159。我们可以在代码的其他部分中使用PI来代替这个值，从而使代码更易读和易于维护。
除了简单的文本替换，宏定义还可以接受参数，这使得宏定义更加灵活和强大。
Python如何解析宏定义？ 在Python中，我们可以使用m4工具来解析宏定义。m4是一个独立的宏处理器，可以处理各种类型的宏定义，包括简单的文本替换和具有参数的复杂宏定义。
下面是一个使用m4解析宏定义的例子：
首先，我们创建一个名为example.m4的文件，并定义我们的宏：
define(`PI', 3.14159) 然后，我们使用m4命令行工具来解析这个文件：
$ m4 example.m4 &gt; example.py 这将生成一个名为example.py的Python文件，其中包含了我们的宏定义。
最后，我们可以在Python中导入生成的example.py文件，使用我们的宏：
from example import PI radius = 10 circumference = 2 * PI * radius 在这个例子中，我们使用m4工具解析了我们的宏定义，并将结果保存在一个Python文件中。然后，我们可以在Python中导入这个文件，并使用我们的宏定义。
结论 在Python编程中，宏定义是一个非常有用的工具，可以帮助我们减少代码的重复性，提高代码的可读性和可维护性。通过使用m4工具，我们可以轻松地解析宏定义，并将结果保存为Python文件，从而使我们的代码更加灵活和强大。
最后的最后 本文由chatgpt生成，文章没有在chatgpt生成的基础上进行任何的修改。以上只是chatgpt能力的冰山一角。作为通用的Aigc大模型，只是展现它原本的实力。
对于颠覆工作方式的ChatGPT，应该选择拥抱而不是抗拒，未来属于“会用”AI的人。
🧡AI职场汇报智能办公文案写作效率提升教程 🧡 专注于AI+职场+办公方向。
下图是课程的整体大纲
下图是AI职场汇报智能办公文案写作效率提升教程中用到的ai工具
🚀 优质教程分享 🚀 🎄可以学习更多的关于人工只能/Python的相关内容哦！直接点击下面颜色字体就可以跳转啦！ 学习路线指引（点击解锁）知识定位人群定位🧡 AI职场汇报智能办公文案写作效率提升教程 🧡进阶级本课程是AI+职场+办公的完美结合，通过ChatGPT文本创作，一键生成办公文案，结合AI智能写作，轻松搞定多场景文案写作。智能美化PPT,用AI为职场汇报加速。AI神器联动，十倍提升视频创作效率💛Python量化交易实战 💛入门级手把手带你打造一个易扩展、更安全、效率更高的量化交易系统🧡 Python实战微信订餐小程序 🧡进阶级本课程是python flask+微信小程序的完美结合，从项目搭建到腾讯云部署上线，打造一个全栈订餐系统。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a1ac711c613d2b35d7052c5e294a9bc/" rel="bookmark">
			NVMe入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前情 存储的概念 尺寸外形：设备的形状和大小。
- 2.5寸或者3.5寸驱动器（在SFF标准中定义）
- M.2 和 PCI Express（PCIe）（在PCI-SIG标准中定义）
接口：设备如何和计算机通信。常见的存储设备接口包括：
- SATA接口，通常用于2.5寸和3.5寸硬盘，有时候一些M.2设备也会使用
- PCI Express(PCIe)接口， 用于M.2和PCIe设备
- SAS（串行SCSI）和FC（Fibre Channel）接口，仅用于服务器领域和数据中心 PCIe接口要比SATA接口快的多，SATA3最大带宽是6Gb/s，而基于4X PCIe的M.2接口最大可以达到32Gb/s。
协议：定义了如何在计算机与设备之间传输数据。
- 用于SATA接口的AHCI或者ATA协议
- 用于PCIe接口的NVMe协议
所以，NVMe是运行在某种接口上的通信协议，用于规范计算机与存储设备的数据传输！
Non-Volatile Memory Express (NVMe)-非易失性内存主机控制器接口规范
作用：提升硬盘读写带宽
存储设备的接口规范 为什么NVMe快？
由于SSD本身的物理特性，其数据的访问已经非常快了，性能的瓶颈就是出在计算机与设备连接的接口和协议上面。我们举一个简单的例子。比如我们有一个仓库会不断的生产出产品来，我们可以机械手将产品从仓库拿到其它地方（如图5所示）。对于SATA的SSD，类似于一个单臂的机器人，仓库生产的很快，但机器人每次只能拿一个，搬移的速度就比较慢。
对于NVMe的SSD，相当于机器人有数百只手
NVMe协议原理：本质上建立了多个计算机与存储设备的通路（队列）
SATA只有一个队列，而NVMe协议最多有64K个队列，每个CPU可以有一个队列，提高了并发程度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69388a52d907b5b5252c0fa67c71ed29/" rel="bookmark">
			QMainWindow添加状态栏提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QMainWindow添加状态栏提示 直接上代码：
//其中ui.statusBar是MainWindow状态栏指针 QLabel* m_pMousePoint = nullptr;//屏幕坐标 QLabel* m_pMapPoint = nullptr;	//地理坐标 QLabel* m_pMapScale = nullptr;	//当前比例尺 m_pMousePoint = new QLabel(QString::fromLocal8Bit("屏幕坐标:(0,0)"),ui.statusBar); m_pMousePoint-&gt;setGeometry(1,ui.statusBar-&gt;y()-2,200,ui.statusBar-&gt;height()); m_pMapPoint = new QLabel(QString::fromLocal8Bit("地理:(0,0)"),ui.statusBar); m_pMapPoint-&gt;setGeometry(200,ui.statusBar-&gt;y()-2,200,ui.statusBar-&gt;height()); m_pMapScale = new QLabel(QString::fromLocal8Bit("比例尺:(0,0)"),ui.statusBar); m_pMapScale-&gt;setGeometry(400,ui.statusBar-&gt;y()-2,200,ui.statusBar-&gt;height()); 使用的是绝对坐标，通过stausBar自身的坐标来获取位置，并同时获取宽高
推测 在QMainWindow的类中ui.statusBar是类QStatusBar，继承于QWidget,如此一来便可使用布局，使得状态栏中所有的内容都挤在右侧或者左侧，类似于以下代码：
QVBoxLayout* pLayout = new QVBoxLayout(ui.statusBar); ui.statusBar-&gt;setLayout(pLayout); //添加第一个label { QLabel* pLabel = new QLabel(QString::fromLocal8Bit("屏幕坐标:(0,0)"),ui.statusBar); pLayout-&gt;addWidget(pLabel); } //添加第二个label { QLabel* pLabel = new QLabel(QString::fromLocal8Bit("屏幕坐标:(0,0)"),ui.statusBar); pLayout-&gt;addWidget(pLabel); } //添加第三个label { QLabel* pLabel = new QLabel(QString::fromLocal8Bit("屏幕坐标:(0,0)"),ui.statusBar); pLayout-&gt;addWidget(pLabel); } //添加拉伸 { auto pSpacer = new QSpacerItem(40, 20, QSizePolicy::Expanding, QSizePolicy::Minimum); pLayout-&gt;addItem(pSpacer); } 注：上面的这一段代码是直接手写的，没有经过验证，应该没有问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69388a52d907b5b5252c0fa67c71ed29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7de35c59587146bec064a3f909333146/" rel="bookmark">
			重定向子进程的输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重定向子进程的输出 直接上代码
QProcess* pProcess = new QProcess(m_pGLobby); pProcess-&gt;setReadChannel(QProcess::ProcessChannel::StandardOutput); pProcess-&gt;setWorkingDirectory(QCoreApplication::applicationDirPath()); QString _gid = gid; QObject::connect(pProcess, &amp;QProcess::readyReadStandardOutput, [=]() { L_Printf("[C Process] %s output: %s" , _gid.toLocal8Bit().data() , pProcess-&gt;readAllStandardOutput().constData()); }); //pProcess-&gt;setStandardOutputFile("out.txt");//输出到文件 pProcess-&gt;start(appFile); 备注：需要等待子进程的缓冲区满了之后才会进入槽函数，如果想要立即看到输出结果，可以在子进程的main函数中把缓冲区设置的小一点。
//设置缓冲区 setvbuf(stdout, NULL, _IOLBF, 3); 但是，上述方法输出的内容并不完整，对局监听子进程这种的需求，并不能很好的进行输出，期望能够单独打开一个黑窗口，将输出内容定位到黑窗口中去。或者是提供协助输出的模块进行内容输出。
后期项目中实践，最终没有使用多进程的方式，而是一个多线程，并且将日志输出抽象成为了接口，并支持通过该接口进行控制台、UI窗口、日志文件、服务日志等方式进行输出，多进程的开发方式在后期似乎并没有用到。
Setvbuf.c Line64 Expression: (2&lt;=size)&amp;&amp;(size&lt;=INT_MAX)
For information on how your program can cause an assertion failure, see the visual C++ documentation on asserts.
*setvbuf*(*stdout*, *NULL*, *_IOLBF*, 0); *setvbuf*(*stdout*, *NULL*, *_IOLBF*, 3); 备注：Debug模式下，不能把缓冲区设置的太小。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41f1b69d08db9be2faf915c2cff63df7/" rel="bookmark">
			图像色彩增强论文调研
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读论文 Deep Symmetric Network for Underexposed Image Enhancement with Recurrent Attentional Learning(ICCV2021)
使用对称编码器和解码器学习图像从低曝光转化到正常图片的映射方式，通过IFT（Invertible Feature Transformer）网络和提出模块RRAM学习到低曝光转化到正常图片映射关系； 单图-GAN DPE-Deep Photo Enhancer Unpaired Learning for Image Enhancement from Photographs with GANs
本文提出了一种无配对学习方法图像增强。 给他一组照片所提出的方法学习照片的期望特征增强器，它将输入图像转换成具有这些特征的en增强图像。 该方法基于双向生成对手网络(GANs)框架，进行了若干改进。 首先,我们用全局特征增强U-Net，并展示它是更有效的。 全局U-Net在我们的GAN模型中作为生成器。 第二，我们改进了具有自适应加权方案的GAN (WGAN)。 与 该方案训练收敛速度快，收敛效果好，且训练量少 比WGAN-GP对参数敏感。 最后，我们支持提出在双向GANs中为generer ators使用单独的批处理规范化层。 它帮助生成器更好地适应 它们自己的输入分布。 把它们放在一起，意义重大 为我们的应用提高GAN训练的稳定性。 定量和可视化结果都表明了该方法的可行性 该方法是一种有效的图像增强方法。
MIEGAN Mobile Image Enhancement via A Multi-Module Cascade Neural Network
移动设备捕获图像的视觉质量 通常不如数码单反相机捕捉的图像。 本文提出了一种基于生成对抗网络的移动图像增强方法，称为MIEGAN。 它由一种新型的多模块级联生成网络和一种新型的自适应多尺度判别网络组成。 该多模块级联类网络建立在双流编码器、特征变换器和译码器的基础上。 在双流编码器中，提出了一种亮度正则化流来帮助网络聚焦在弱光区域。 在特征转换模块中，两个网络可以有效地获取图像的全局和局部信息。 为了进一步帮助生成网络生成高视觉质量的图像，使用多尺度鉴别器代替常规的单一鉴别器，在全局和局部区分图像的真伪。 为了平衡全局和局部鉴别器，提出了一种自适应权值分配方法。 此外，提出了一种对比度损失，并开发了一种新的混合损失函数来提高增强图像的视觉质量。 在流行的DSLR照片增强数据集和MIT-FiveK数据集上的大量实验验证了所提出的MIEGAN算法的有效性。
Unpaired Image Enhancement with Quality-Attention Generative Adversarial Network
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41f1b69d08db9be2faf915c2cff63df7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64cdceeab9ba0b5b2a1eea96b8f09e65/" rel="bookmark">
			【全网最全】图像色彩增强开源代码数据集汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
代码-调色
代码-低光照
数据集
代码-调色 (CVPR2022) AdaInt: Learning Adaptive Intervals for 3D Lookup Tables on Real-time Image Enhancement-code 在3D LUT基础上，考虑自适应采样间隔，根据颜色分布密集程度来采样；
具体地：使用低分辨率输入和网络，预测LUT参数和采样坐标（分别预测三个颜色采样坐标并笛卡尔积得到三维坐标）；
增加少量参数，训练得到结果提升；25.29--25.49
(ECCV2022) Neural Color Operators for Sequential Image Retouching code (ICCV2021) Deep Symmetric Network for Underexposed Image Enhancement with Recurrent Attentional Learning- code (ICCV2021) Seeing Dynamic Scene in the Dark: A High-Quality Video Dataset with Mechatronic Alignment- code (CVPR 2021) Learning Multi-Scale Photo Exposure Correction" code (TPAMI2020) *Learning Image-adaptive 3D Lookup Tables for High Performance Photo Enhancement in Real-time code 3个3D LUT basic block；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64cdceeab9ba0b5b2a1eea96b8f09e65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71265d1c34d8da1b0a5757d54b8bf168/" rel="bookmark">
			图像色彩增强相关论文阅读-Representative Color Transform for Image Enhancement(ICCV2021)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Representative Color Transform for Image EnhancementAbstractIntroductionRelated workMethod实验Conclusion Representative Color Transform for Image Enhancement 作者：Hanul Kim1, Su-Min Choi2, Chang-Su Kim3, Yeong Jun Koh
单位：Seoul National University of Science and Technology 2Chungnam National University 3Korea University
Abstract 前人方法都是encode-decode方式，丢失细节；密集转化也限制颜色空间的迁移效果；
本文使用颜色迁移表征（RCT）表征颜色变化，根据输入和表征颜色相似性增强颜色，得到更好效果；
RCT determines different representative colors specialized in in- put images and estimates transformed colors for the repre- sentative colors. It then determines enhanced colors us- ing these transformed colors based on the similarity be- tween input and representative colors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71265d1c34d8da1b0a5757d54b8bf168/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2bfd572151c15e562a7c4157f69c858/" rel="bookmark">
			全网独家--【图像色彩增强】方法梳理和问题分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 图像增强图像色彩增强问题可视化比较 难点色彩空间大，难以准确表征？不同场景差异大，难以自适应？计算量大，但应用场景往往实时性要求高？ 方法传统方法深度学习逐像素预测3D LUT模仿ISP 个人思考批判性看待论文工作速度快效果好大模型 图像增强 图像增强是一个非常大的领域，包含去噪，去雾，超分辨率，去模糊，低光照增强，重建等都属于
图像增强！
但我要讨论的方向更具体是：图像色彩增强，区别于低光照增强和水下图像增强!
图像色彩增强 图像色彩增强针对图像色彩进行调整优化，有的文章叫做——图像润色（image retouching），无法去噪，无法在极低光照情况恢复（这种低光照恢复往往伴随着大量噪声，因为颜色已经完全丢失，或大部分丢失，难度更大）。
图像色彩增强的主要评价数据集是：MIT5K，HDR++和PPR10K，有的论文中说是image retouching，也有论文说image enhancement，本质都是对颜色空间的调整优化，使其更符合人类视觉感知！
其中MIT5K数据集是包含低光照处理的，训练和测试图光照降低，有A/B/C/D/E五个专家调色，一般方法都使用C标签进行训练和比较；HDR也是训练图片亮度和色彩都降低；
PPR10K主要是针对人像精修图片，进行精细化的色彩、亮度和曝光的调整，同时数据集中加入了人像的mask用于指导优化训练。
问题 本质上：模型优化调整图片的颜色，亮度和曝光，能让图片和专家的调色结果更加一致！
图像色彩增强还有一个额外的任务，图像色调调整image tone，色调的调整一般使用16bit图片进行训练和XYZ空间评价；
所以训练图片的格式也有区别：润色任务使用sRGB图像格式训练，主要专注色彩和亮度调整，使用C专家标记和PSNR，SSIM，Eab进行评价；色调调色任务使用16bitS的图片进行训练；
可视化比较 上图分别是sRGB, XYZ空间和gt图片。
原始图像的色彩和亮度都很低，人们的视觉主观感受很差；
中间这张的色调也不好，整体呈现灰蒙蒙和青色，影响对图像中物体的观感！
最右边这张专家标记图片的亮度、色彩和色调都很棒，能清楚看到山丘、草堆，沙石和天空，主观感受也更舒适，用PSNR和SSIM评价结果，前两者的结果很差！
难点 色彩空间大，难以准确表征？ 色彩空间是一个庞大的空间数量，不同颜色组合成255x255x255的颜色空间，如果进行逐一统计和建立映射关系，复杂度非常高。
本质上，图像色彩映射是一个复杂度高、非线性和结果多样性的过程！需要模型能够准确映射颜色空间高维度和大数量的颜色关系，构建出高效表征的映射关系。
不同场景差异大，难以自适应？ 对于不同场景图片中，同一个颜色会有多种映射结果，这也给色彩映射带来极大的难度和挑战！
不仅要求模型能够适应不同场景的差异映射关系，还要适应同一色彩的不同场景自适应映射；
色彩映射的结果需要自然、符合人类视觉机制，这其实是难度非常大的。
计算量大，但应用场景往往实时性要求高？ 图像增强根据其方法不同，计算方式也不同，计算量差距较大。
传统的方法直接计算色彩映射矩阵，使用较少的参数实现色彩映射，计算量小；
但深度模型后的GAN生成网络和FCN逐像素预测的网络模型，计算量大，训练复杂，限制了实用性；
基于颜色迁移函数拟合的深度学习，通过预测少量的映射函数，能达到计算量小、效果好！
方法 传统方法 使用线性或者非线性方程拟合颜色映射关系。
最典型的是：曲线色彩映射图，2D lut；
Color Transfer Using Probabilistic Moving Least SquaresExample-Based Image Color and Tone Style EnhancementLearning Photographic Global Tonal Adjustment with a Database of Input / Output Image Pairs 深度学习 色彩映射方程拟合
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2bfd572151c15e562a7c4157f69c858/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6550da51215c870f940ad0bb3d3c1c76/" rel="bookmark">
			Redis的3大特殊数据类型(1)-BitMap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BitMap(位图/位数组)是Redis2.2.0版本中引入的一种新数据类型，该数据类型本质是一个仅含0和1的二进制字符串。因此可以把 Bitmap 想象成一个以位为单位的数组，数组的每个单元只能存储 0 和 1，数组的下标在 Bitmap 中叫做偏移量 offset，bitmap默认值都为0.
BitMap底层实际上使用字符串来存储,由于 Redis 中字符串的最大长度是 512 MB字节，所以 BitMap 的偏移量 offset 值也是有上限的，其最大值是：8 * 1024 * 1024 * 512 = 2^32(4G)。
由于 Redis中字符串的末尾都要存储一位分隔符，所以实际上 BitMap 的偏移量 offset 值上限是：2^32-1。
1.SETBIT key offset value SETBIT 用来设置 key 对应第 offset 位的值（offset 从 0 开始算），可以设置为 0 或者 1。当指定的 KEY 不存在时，会自动生成一个新的字符串值。
127.0.0.1:6379&gt; setbit isSign 0 0 (integer) 0 127.0.0.1:6379&gt; setbit isSign 1 0 (integer) 0 127.0.0.1:6379&gt; setbit isSign 2 1 (integer) 0 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6550da51215c870f940ad0bb3d3c1c76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eff9a40b3fc2f0d7e09b17989e606bbf/" rel="bookmark">
			二叉树遍历方法——前、中、后序遍历（java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树结构： static class TreeNode{ public char val; public TreeNode left; public TreeNode right; public TreeNode(char val) { this.val = val; } @Override public String toString() { return this.val+""; } } 一、前序遍历 前序遍历是一种访问二叉树的每一个结点的方法，它的遍历顺序是根节点，左子树，右子树。
1）递归版本 public void preOrder1(TreeNode root){ if(root==null){ return ; } System.out.println(root.val); preOrder1(root.left); preOrder1(root.right); } 递归版本其实很简单，就是按照它的遍历方式来写一下就可以，我们主要来介绍一下非递归的方法。
2）非递归版本 前序遍历的非递归方式就是将递归的版本的每一个过程都存储下来，而我们就需要一个辅助栈来帮助我们实现。
算法思想：
1.节点不为空，打印，入栈，遍历左子树
2.节点为空但是栈不为空，出栈顶元素，遍历栈顶元素右子树
3.节点为空栈也为空，结束程序
4.二叉树为空结束程序
按照上述的代码思路，我们可以实现代码如下：
public void preOrder2(TreeNode root){ Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while(!stack.empty()||cur!=null){ if(cur!=null){ //打印根节点 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eff9a40b3fc2f0d7e09b17989e606bbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2afa09f31a69d9db92826232c907db0f/" rel="bookmark">
			python迭代器(Iterator)与生成器(Generator)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在阅读技术文档时遇到迭代器和生成器相关的概念，这篇文章总结一下学到的东西。
感谢：
1. Python进阶——什么是迭代器？
2. Python __iter__()迭代器 （十三）_鼻涕虫de皮皮的博客-CSDN博客
3. python 类的__iter__、__next__方法与yield_JpyJpy321的博客-CSDN博客
主要结合实例，以个人理解总结"容器"，"迭代器"，"可迭代对象"，"生成器"这四个概念及其用法。
1. 容器，在Python中主要指用类实现的一种数据结构，这个类的定义一定是包含了__contain__()方法，以支持Python的in关键字能够和这个类兼容，确定某个元素是否在容器里，如：
class CustomContainer: def __init__(self) -&gt; None: self.data = [1,2,3,4,5] def __contains__(self, element): if element in self.data: return True else: return False if __name__ == "__main__": # test container: container = CustomContainer() print("1 in container: ") print(1 in container) print("10 in container: ") print(10 in container) 2. 迭代器，在Python指用类实现的服从迭代器协议的数据结构，即迭代器类定义了__iter__()方法和__next__()方法，使得该迭代器能够被for关键字迭代等等，其中：
__iter__()方法返回一个迭代器对象，一般是self，这个返回的对象必须实现了__next__()方法，因为for循环使用这个迭代器时，会首先调用一次__iter__()，然后每次循环时调用这个__iter__()返回的对象的__next__()方法，将__next__()返回值赋给循环变量。当数据结构中的数据被遍历过一遍时，要__next__()负责抛出StopIteration异常，告诉for语句停止迭代。
另外，关于一个迭代器对象可以迭代几次的问题。这个取决于抛出StopIteration异常前，是否有将这个迭代器对象的状态重置。如果没有重置，第一次for循环不会出现问题，第二次不会报错，但是for语句块没有循环。下面将通过实际例子说明
循环后无重置的Iterator:
class CustomIterator: def __init__(self) -&gt; None: self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2afa09f31a69d9db92826232c907db0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0a56784c64e603f4f225b6700c1284c/" rel="bookmark">
			Centos配置postfixadmin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装配置 postfixadmin；创建虚拟域 chinaskills.cn 以及 99 个邮件用户 mailuser1～mailuser99.虚拟用户映射至本地用户 vmail 和用户组 vmail，UID 和GID 均为 2000；链接：https://pan.baidu.com/s/1ymz6qz8i6w5wqhw1kONwvw?pwd=1111 提取码：1111 1、安装lamp环境
2、初始化数据库
3、上传postfixadmin服务文件到网页根目录并编辑config.inc.php文件
nano /webdata/postfixadmin/config.inc.php
类型选择mysql 其他根据题目修改数据库用户名和密码
4、创建数据库
mysql -uroot -p #这里填写初始化的root密码 create database postfix character set utf8 collate utf8_bin; 创建邮件数据表 grant all privileges on postfix.* to postfix@localhost identifited by 'postfix'; #添加postfix用 5、浏览器访问mail文件
根据报错信息来进行配置添加问你拿 在/webdata/postfixadmin/目录下创建 temlates_c 目录并设置755权限
再给php设置vmail拥有者权限 chown vmail.vmail /var/lib/php
setup password修改密码需要修改config.inc.php文件替换
修改完成之后重启一遍网页就可以创建mail管理员登录到postfixadmin
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e63e192c0cbb0a3f571a494d3b4ebd8/" rel="bookmark">
			php常用函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是一些常见的 PHP 函数：
strlen()：获取字符串的长度。
strtolower()：将字符串转换为小写。
strtoupper()：将字符串转换为大写。
trim()：删除字符串开头和结尾的空格。
rtrim()：删除字符串结尾的空格。
ltrim()：删除字符串开头的空格。
md5()：计算字符串的 MD5 哈希值。
sha1()：计算字符串的 SHA-1 哈希值。
current()：获取数组中当前元素的值。
each()：获取数组中下一个元素的值和键。
reset()：将数组的内部指针指向第一个元素。
end()：获取数组中最后一个元素的值。
prev()：获取数组中前一个元素的值。
next()：获取数组中下一个元素的值。
以上是一些常见的 PHP 函数，但并不是全部。PHP 拥有大量的内置函数，你可以通过查看 PHP 官方文档来获取更多的信息。
本文转载 http://www.yinmeihua.xyz/index.php?m=home&amp;c=View&amp;a=index&amp;aid=93&amp;admin_id=1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/054428f44f0d76234d9792ce04838221/" rel="bookmark">
			生成六位随机数密码的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一，Vue项目中生成随机六位数密码功能1，知识储备（1）js中+号的隐式类型转换（2）Math.random()方法（3）Math.floor()方法 2，实现思路3，核心代码 一，Vue项目中生成随机六位数密码功能 1，知识储备 （1）js中+号的隐式类型转换 在使用+号的时候，如果其中一个是字符串，另一个会被转换成字符串类型，最后输出的结果也是字符串。
例：1 + ‘1’ = ‘11’
（2）Math.random()方法 Math.random()函数返回一个浮点数，伪随机数范围从0到小于1(不包括1)，可以根据自己的需求来选择缩放范围，实现随机数生成算法。
（3）Math.floor()方法 Math.floor(x)函数总是返回小于等于一个给定数字的最大整数，通俗点来说就是向下取整。
2，实现思路 首先定义一个code空字符和codeLength来设置密码长度，再定义一个数组来存放生成的内容(比如密码只能包含数字)，接着for循环六次，生成随机0~9的索引，利用索引拿到数组中的元素，依次赋值给code。
3，核心代码 let code = '';//声明一个空的字符串值用于后面赋值 const codeLength = 6; //随机密码的长度 const random = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; //随机数的取值范围 for (let i = 0; i &lt; codeLength; i++) { //循环遍历codeLength，值是几，就循环几次 let index = Math.floor(Math.random() * 10); code += random[index]; //根据索引取得随机数加到code上 } this.param.password = code; //把code值赋给data中定义好的password 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/432bccb7a54bc03f347d4b07ba1f6a82/" rel="bookmark">
			文件后缀名和MimeType的映射关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tomcat 的源码里边有。
打开 Tomcat官网
在 Download 菜单下找一个版本，比如 Tomcat 9，点进去，下载源码
找到 conf 目录下的 web.xml 文件
打开，里边有很多 &lt;mime-mapping&gt; 节点就是，总共一千多个吧
粘出来，自己处理一下
123,application/vnd.lotus-1-2-3 3dml,text/vnd.in3d.3dml 3ds,image/x-3ds 3g2,video/3gpp2 3gp,video/3gpp 7z,application/x-7z-compressed aab,application/x-authorware-bin aac,audio/x-aac aam,application/x-authorware-map aas,application/x-authorware-seg abs,audio/x-mpeg abw,application/x-abiword ac,application/pkix-attr-cert acc,application/vnd.americandynamics.acc ace,application/x-ace-compressed acu,application/vnd.acucobol acutc,application/vnd.acucorp adp,audio/adpcm aep,application/vnd.audiograph afm,application/x-font-type1 afp,application/vnd.ibm.modcap ahead,application/vnd.ahead.space ai,application/postscript aif,audio/x-aiff aifc,audio/x-aiff aiff,audio/x-aiff aim,application/x-aim air,application/vnd.adobe.air-application-installer-package+zip ait,application/vnd.dvb.ait ami,application/vnd.amiga.ami anx,application/annodex apk,application/vnd.android.package-archive appcache,text/cache-manifest application,application/x-ms-application apr,application/vnd.lotus-approach arc,application/x-freearc art,image/x-jg asc,application/pgp-signature asf,video/x-ms-asf asm,text/x-asm aso,application/vnd.accpac.simply.aso asx,video/x-ms-asf atc,application/vnd.acucorp atom,application/atom+xml atomcat,application/atomcat+xml atomsvc,application/atomsvc+xml atx,application/vnd.antix.game-component au,audio/basic avi,video/x-msvideo avx,video/x-rad-screenplay aw,application/applixware axa,audio/annodex axv,video/annodex azf,application/vnd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/432bccb7a54bc03f347d4b07ba1f6a82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d8f5582ff719d19eec9733a1af610c8/" rel="bookmark">
			交叉熵、Focal Loss以及其Pytorch实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		交叉熵、Focal Loss以及其Pytorch实现 本文参考链接：https://towardsdatascience.com/focal-loss-a-better-alternative-for-cross-entropy-1d073d92d075
文章目录 交叉熵、Focal Loss以及其Pytorch实现一、交叉熵二、Focal loss三、Pytorch1.[交叉熵](https://pytorch.org/docs/master/generated/torch.nn.CrossEntropyLoss.html?highlight=nn+crossentropyloss#torch.nn.CrossEntropyLoss)2.[Focal loss](https://github.com/clcarwin/focal_loss_pytorch/blob/master/focalloss.py) 一、交叉熵 损失是通过梯度回传用来更新网络参数是之产生的预测结果和真实值之间相似。不同损失函数有着不同的约束作用，不同的数据对损失函数有着不同的影响。
交叉熵是常见的损失函数，常见于语义分割、对比学习等。其函数表达式如下，其中 Y i 和 p i Y_i和p_i Yi​和pi​分别表示真实值和预测结果：
C r o s s E n t r o p y = − ∑ i = 1 i = n Y i l o g ( p i ) CrossEntropy=-\sum_{i=1}^{i=n}Y_ilog(p_i) CrossEntropy=−i=1∑i=n​Yi​log(pi​)
因为 p i p_i pi​值在0~1之间，故交叉熵大于等于0。这个函数什么时候最小呢？数学证明结果表明当 Y i = p i Y_i=p_i Yi​=pi​时交叉熵最小。下面，我们取二分类情况来进行简单证明：
B C E L o s s = − y l o g x − ( 1 − y ) l o g ( 1 − x ) BCELoss=-ylogx-(1-y)log(1-x) BCELoss=−ylogx−(1−y)log(1−x)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d8f5582ff719d19eec9733a1af610c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eff9c65e7fa74542afc32c5d6a4da600/" rel="bookmark">
			docker学习笔记(七) ——dockers部署nacos并挂载文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、nacos是什么？二、nacos部署步骤1. 下载nacos镜像2.搭建临时nacos容器3.从容器中复制nacos配置文件4.创建nacos数据库和用户5.删除nacostest容器6.修改nacos的配置文件application.properties7.执行挂载命令8.常见错误 提示：以下是本篇文章正文内容，下面案例可供参考
一、nacos是什么？ 服务（Service）是 Nacos 世界的一等公民。Nacos 支持几乎所有主流类型的“服务”的发现、配置和管理
二、nacos部署步骤 1. 下载nacos镜像 docker pull nacos/nacos-server:latest 2.搭建临时nacos容器 这一步主要是为了将初始的配置文件，从临时容器中复制到主机中
docker run -p 8848:8848 --name nacostest -d nacos/nacos-server:latest 3.从容器中复制nacos配置文件 ## 创建conf和logs文件夹 mkdir -p /dockerImageFile/nacos/conf mkdir -p /dockerImageFile/nacos/logs ## 复制conf和logs文件夹 docker cp nacostest:/home/nacos/logs/ /dockerImageFile/nacos/ docker cp nacostest:/home/nacos/conf/ /dockerImageFile/nacos/ 4.创建nacos数据库和用户 创建nacos用户名
进入github复制nacos-db.sql文件并执行SQL文件
5.删除nacostest容器 docker stop nacostest docker rm nacostest 6.修改nacos的配置文件application.properties vim /dockerImageFile/nacos/conf/application.properties ## 修改数据库类型为mysql spring.datasource.platform=mysql ## 修改mysql地质问本地 db.url.0=jdbc:mysql://192.168.87.128:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=30000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC ## mysql用户名密码为步骤四创建的 db.user=nacos db.password=nacos 7.执行挂载命令 docker run -d -e MODE=standalone -v /dockerImageFile/nacos/logs:/home/nacos/logs -v /dockerImageFile/nacos/conf:/home/nacos/conf -p 8848:8848 --name nacos --restart=always nacos/nacos-server:lates i
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eff9c65e7fa74542afc32c5d6a4da600/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afa08df7a9f82b2f72b2fe0f0fd2e207/" rel="bookmark">
			关于linux系统的衍生系统Centos7共享服务samba设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、关于samba的介绍
二、samba的优势
三、samba的服务场景
四、Centos7共享服务samba设置的实验
实验目的：
实验内容：
1.安装共享服务
2.修改smb.conf配置文件，设置共享
3.以账号（用户）访问共享：
一、关于samba的介绍 Samba是一种开源软件，可以在Linux和其他操作系统之间实现文件和打印共享。Samba可以让不同的操作系统的计算机在同一网络中共享资源并相互通信。
在CentOS 7中，要安装Samba服务器，首先需要使用下面的命令安装Samba软件包： sudo yum install samba 安装后，您需要编辑Samba配置文件（/etc/samba/smb.conf）以配置Samba共享。您可以使用文本编辑器，如vim或nano，打开并编辑此文件。
在Smb.conf文件中，您需要指定共享名称、共享的路径、可访问共享的用户等详细信息。例如，以下是一个示例共享配置。
[share_folder] comment = Shared Folder path = /home/username/share_folder/ browseable = yes writable = yes guest ok = no valid users = your_username 在这个示例中，share_folder 是共享的名称，/home/username/share_folder 是共享的路径，your_username 指定了可以访问共享的用户。
编辑完共享配置文件后，记得重启Samba服务：
sudo systemctl restart smb.service 现在，在Windows或其他计算机上，您可以使用文件管理器浏览到CentOS服务器的共享位置，并访问其中的文件。
二、samba的优势 Samba是一款非常强大的软件，以下是它的一些优点：
1. 跨平台：Samba可以在不同的操作系统上实现文件和打印机的共享，它支持Windows、Linux、Unix等平台，可以实现不同平台之间的通信。
2. 易于配置：Samba的配置简单，可以通过编辑文本配置文件实现，对于熟悉Linux的用户而言非常容易使用和维护。
3. 安全：Samba提供了许多安全的功能，如身份验证和加密传输，以更好地保护共享的数据。
4. 可扩展性：Samba可以扩展到大型网络环境中，可以支持数百个并发用户访问共享资源。
5. 开源和免费：Samba是一款开源软件，任何人都可以免费使用、修改和分发。
总的来说，Samba为用户提供了一种简便有效的方式来实现在不同平台之间的文件和打印机资源的共享，确保不同操作系统之间能够顺畅地进行通信。
三、samba的服务场景 Samba的服务场景非常广泛，以下是其中一些典型应用场景：
1. 共享文件和数据：Samba可以让不同操作系统的计算机之间共享文件和数据，使得团队协作更加轻松便捷，有助于提高工作效率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afa08df7a9f82b2f72b2fe0f0fd2e207/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8aff0da3189b437ac83773759850147/" rel="bookmark">
			Redis 全面入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、安装和启动 Redis二、Redis 基本操作1. 连接 Redis2. 设置和获取键值对3. 删除键值对4. 判断键是否存在：5. 设置键的过期时间：6. 查询键的剩余生存时间7. 查看所有键 三、数据结构和高级功能1. 字符串（String）2. 列表（List）3. 集合（Set）4. 哈希（Hash）5. 有序集合（Sorted Set） 四、持久化和高可用性1. 快照（Snapshot）持久化2. 日志（Log）持久化3. 主从复制（Replication）4. 集群（Cluster） Redis（Remote Dictionary Server）是一个开源的高性能键值存储数据库，常用于缓存、消息队列和数据持久化等场景。
一、安装和启动 Redis 安装和启动 Redis：https://blog.csdn.net/weixin_43749805/article/details/131398922
二、Redis 基本操作 1. 连接 Redis 使用 Redis 客户端连接到 Redis 服务器，默认端口为 6379
2. 设置和获取键值对 SET key value GET key SET 命令设置键值对， GET 命令获取键对应的值
3. 删除键值对 DEL key DEL 命令删除指定的键值对
4. 判断键是否存在： EXISTS key EXISTS 命令判断指定的键是否存在
5. 设置键的过期时间： EXPIRE key seconds EXPIRE 命令设置键的过期时间，单位为秒
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8aff0da3189b437ac83773759850147/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7095047e5cc8411330bd5c2aa1c02004/" rel="bookmark">
			Linux 环境下 Redis 安装和启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、安装 Redis1. 更新包管理器2. 安装 Redis 二、配置 Redis1. 打开 Redis 配置文件2. 配置绑定 IP 和端口3. 保存并关闭文件 三、启动 Redis1. 启动 Redis 服务2. 验证 Redis 是否已成功启动 四、测试 Redis1. 连接到 Redis 服务器2. 执行 Redis 命令 五、开机自启动 Redis1. 启用 Redis 服务的开机自启动2. 验证 Redis 服务是否已设置为开机自启动 简介
Redis 是一个快速、开源的键值存储数据库，常用于缓存、消息队列和数据持久化等场景。
一、安装 Redis 1. 更新包管理器 sudo apt update 2. 安装 Redis sudo apt install redis-server 二、配置 Redis 1. 打开 Redis 配置文件 vi /etc/redis/redis.conf 2. 配置绑定 IP 和端口 默认情况下，Redis 绑定在本地回环地址 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7095047e5cc8411330bd5c2aa1c02004/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/271f020f729c0dc52db7fd9091cefd5c/" rel="bookmark">
			git撤回某次commit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设我们已经将本地代码提交到远程分分支上，但是我们想撤回某一个commit或者是对某一个文件的修改进行撤回等操作，我们可以使用以下这几种方式
一、git reset git reset ：回滚到某次提交。
git reset --mixed：此次提交之后的修改会被退回到工作区。不删除工作区改动的代码，撤销commit，撤销git add .【暂存区】
git reset --soft：此次提交之后的修改会被退回到暂存区。不删除工作空间的改动代码 ，撤销commit，不撤销git add . 【用于只想删除该提交本身而不影响其他更改】
git reset --hard：此次提交之后的更改都会被删除，git status 查看工作区是没有记录的(删除工作空间的改动代码，撤销commit且撤销add)
reset命令会更改 Git 存储库的历史记录，这意味着您的提交历史记录将会被修改
reset 命令只能回滚某次的提交，无法满足保留最后一次提交只回滚之前的某次提交。
回滚代码 git log // 查看所有commit的信息 git reset --hard commit_id // 回滚到指定提交 git push origin HEAD --force // 将本地分支代码强制推送到远处分支 或者
git reset --soft HEAD^ 命令解释：
HEAD^ 表示上一个版本，即上一次的commit，几个^ 代表几次提交，如果回滚两次就是HEAD^^。
也可以写成HEAD~ 1，如果进行两次的commit，想要都撤回，可以使用HEAD~2。
tips:
假设我们有些时候commit的备注写错了，我们可以运行
git commit --amend 进入vim编辑模式，修改完保存即可
撤回回滚
假设我们整错了commit_id或者误删了某次commit git reflog //显示可引用的历史版本记录. 找到要撤回的commit的前面的 git reset --hard commit_id // 恢复到这次修改 git push origin HEAD --force // 将本地分支代码强制推送到远处分支 补充：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/271f020f729c0dc52db7fd9091cefd5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a20989ae14096acc9af00e724c08462/" rel="bookmark">
			基于Arduino单片机超声波测距仪设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
摘 要
1.课程设计任务
1.1课程设计题目
1.2设计的要求
2.设计总体方案
2.1初步设计方案
2.2各个单元电路的设计要求
2.3主要性能指标
2.4总体方案
3.单元模块设计
3.1显示模块
3.2超声波测距模块
3.3蜂鸣器模块
3.4电机模块
3.5 LED二极管模块
4.软件流程图
5.设计代码
5.1核心控制代码
5.2超声波测距代码
5.3代码设计总结
6.系统电路设计
6.1整体电路
6.2测试结果
7.系统调试
7.1系统整体测试方法
7.2出现的问题
7.3修改调整的方法
8.总结
8.1心得体会
8.2系统的优缺点
8.3设计的改进思路
参考文献
摘 要 Arduino单片机在自动控制领域里享有很高的价值，以其易用性和多功能性受到了广大电子设计爱好者的好评。本次设计主要是利用Arduino单片机、显示模块、超声波测距模块、蜂鸣器模块、电机模块、LED二极管模块完成测距报警系统的制作，以Arduino为主控芯片，利用超声波对距离的检测，将前方物体的距离探测出来，同时通过LCD显示出距离，然后单片机处理运算，与设定的报警距离值进行比较判断，当测得距离小于设定值时，Arduino发出指令控制蜂鸣器报警、LED闪烁报警同时控制电机转速降低；当测得距离大于设定值时，Arduino发出指令控制蜂鸣器报警停止、LED闪烁报警停止同时控制电机转速升高。
关键词 Arduino； 超声波测距仪； 单片机。
1.课程设计任务 1.1课程设计题目 基于Arduino单片机超声波测距仪设计
1.2设计的要求 用控制器实现一个超声波测距仪，具体要求如下。
设计要求：
1、能在数码管上实时显示障碍物的实际距离；
2、所测距离大于5cm小于300cm，精度1mm；
3、距离过近时产生声光报警；
4、根据距离变化，控制电机以不同转速转动。
2.设计总体方案 2.1初步设计方案 按照系统总体要求，用功能模块框图表达整体功能，如图1所示。
图1 功能模块框图
该系统由Arduino单片机、超声波测距仪、LCD液晶显示屏、电机、蜂鸣器、LED二极管等组成。其中，Arduino单片机：作为整个系统的核心控制器，接收来自超声波测距仪传感器的距离信号，并根据不同的距离变化，控制LCD显示屏、电机、蜂鸣器和LED二极管的状态；超声波测距仪传感器：通过发射超声波并检测其回波的时间来测量目标物体与传感器之间的距离；LCD液晶显示屏：用于实时显示测量到的距离值。它的作用类似于计算器的显示屏，可以显示数字和文字等信息；电机：可以根据距离变化以不同的转速旋转。在超声波测距仪中，电机主要用于产生震动或驱动其他机械设备；蜂鸣器：用于产生声音警报，当距离过近时，超声波测距仪可以发出警报以提醒用户注意安全；LED二极管：用于指示系统状态或警报状态等。在超声波测距仪中，LED可以用来指示系统是否正常工作或是否出现警报状态等。
在该系统中，通过上述各个模块的协作，超声波测距仪可以实现实时测量距离、显示距离、控制电机转速、发出声光报警等功能。
2.2各个单元电路的设计要求 （1）超声波测距仪传感器电路：需要设计一个可以触发超声波信号的电路，并接收回波信号以计算距离。需要考虑电路稳定性和抗干扰性能，以确保测量精度和可靠性。
（2）Arduino单片机电路：需要提供足够的输入输出口以连接其他电路，并能够控制电机、蜂鸣器和LED等外围设备。需要考虑电路的可编程性、稳定性和实时性等因素。
（3）LCD液晶显示屏电路：需要提供足够的接口以与Arduino单片机进行通信，并可以显示数字和文字等信息。需要考虑电路的显示分辨率、显示速度和亮度等因素。
（4）电机驱动电路：需要提供足够的电流和电压以驱动电机，并可以根据距离变化以不同的转速旋转。需要考虑电路的效率、稳定性和精度等因素。
（5）蜂鸣器电路：需要提供足够的电流和电压以驱动蜂鸣器，并可以产生不同频率的声音。需要考虑电路的音质、音量和稳定性等因素。
（6）LED二极管电路：需要提供足够的电流和电压以驱动LED，并可以产生不同颜色的光。需要考虑电路的亮度、稳定性和色彩饱和度等因素。
2.3主要性能指标 在确定各单元电路的设计要求后，我们可以拟定以下主要性能指标：
（1）测量距离范围：大于5cm小于300cm。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a20989ae14096acc9af00e724c08462/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c56f0b2a4f34c835aa7445ee239ca31/" rel="bookmark">
			详解ThreadLocal和其中的应用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了提升程序运行的效率，多线程的使用是必不可少的。 那么提到多线程的使用，有一个知识点是我们必然无法绕过的，那便是线程之间的通信方式。
线程之间的通信方式主要有以下这些：
那么在本文中我们来重点讲解一下ThreadLocal的原理和使用场景。
1、ThreadLocal是什么？ 顾名思义,Thread-&gt;线程，Local-&gt;本地变量。所以ThreadLocal是线程本地变量的意思，当我们创建了一个ThreadLocal变量的时候，访问这个变量的每个线程都会有这个变量的一个本地拷贝，当多个线程来操作这个变量的时候，实际操作的是本地内存里面的变量，通过这种方式实现线程隔离，避免多线程导致的数据安全问题。
我们可以用一张图来看一下TheadLocal的位置：
通过以下语句就可以创建一个ThreadLocal变量，在线程对共享变量进行修改时，实际上修改的就是这个变量副本，通过这种空间换时间的方式，来保证线程的安全。
arduino复制代码public static ThreadLocal&lt;String&gt; localVar = new ThreadLocal&lt;&gt;(); 2、ThreadLocal用那些典型的使用场景？ 我在工作中的以下场景中用到了ThreadLocal
场景一：用户登录态上下文 当用户登录后访问接口，会从前端携带必要的登录信息，存放在Cookie中，请求经过统一的网关后，我们会解析出用户的ID。当请求走入业务代码时，用户可能会执行一些操作。而在这些操作中会包含一些公用的信息。例如，如果是B端的用户，我们需要获取到用户的公司，用户的身份，角色，权限等等。而如果是C端用户，则需要解析出用户是否VIP，是否用某些内容的查看权限等等。
这些公用的信息如果我们放在具体的服务层中去做则会产生大量的冗余代码，降低代码的可读性，而且如果后续如果一些公用的规则有所更改，例如权限校验的规则有所改变，那么我们需要大范围的更改代码，这个过程也十分容易产生遗漏。
因此通过TheadLocal封装用户公共的上下文信息就是一个非常好的办法，这样我们可以将身份鉴定、权限等一系列公用内容统一处理，服务层直接应用即可。
场景二：参数校验上下文 第二个业务场景是这样子，我们用一个实体A，要经过一系列校验规则后确定是否能够转换为实体B。这是一个典型的参数校验的场景，在这个业务场景中我们使用了责任链的设计模式。
在初期使用责任链时，我们的整个请求是串行的。这种设计模式的应用让我们对于校验规则的拆分十分细致，但是在不断的迭代中也出现了一些问题。其中最为显著的问题便是在维护责任链的过程中，每次的改动可能都存在于一个类里面(一个类既是一个单独的校验规则)，但是当规则越来越多的时候，不可避免的会出现业务重叠，即某个第三方服务可能会在不同校验规则里面多次调用。这样子导致了第三方服务的压力，同时也使得我们的请求时间变长。
我们的解决方案即是在参数校验的责任链中增加一个统一上下文信息。
假设在链式场景中有三个校验规则，而这三个校验规则的实体类中又有这一些公共信息，我们使用ThreadLocal来存放这些公共信息的值。
因为这个参数校验流程是非常底层的服务，QPS很高，在保障服务的高可用性的同时也需要尽量的降低请求时间。所以使用多线程便是一个非常必要的途径。通过ThreadLocal存放一些公用信息作为上下文，首先可以保证多线程请求下的数据安全，并且我们可以有效降低对其他服务的请求次数，同时也缩短了响应的时长。
3、ThreadLocal核心源码分析 那么讲了这么多，我们一起来看一下ThreadLocal在Java中是如何实现的。
我们首先来看源码中ThreadLocal最重要的两个方法：get 和 set方法
ini复制代码 public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings("unchecked") T result = (T)e.value; return result; } } return setInitialValue(); } scss复制代码 public void set(T value) { Thread t = Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c56f0b2a4f34c835aa7445ee239ca31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a0d8bfa40534663f24dedfb4ac3cc1d/" rel="bookmark">
			python 视频转字符视频 bate
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只需要在最后一行括号填入视频路径即可
import os from PIL import Image, ImageDraw, ImageFont import cv2 import time from tqdm import tqdm import threading if __name__ == '__main__': # path = r'img\sportball\0.jpg' def cv2_pit_imgchar(path,save_path=''): def create_img(text,show='no',save_path=save_path):#创建图片,将文本写入到图片 s = time.time() img = Image.new('RGB', (1260, 915), color = (255, 255, 255))#创建一张图片 draw = ImageDraw.Draw(img) font = ImageFont.truetype('SIMLI.TTF', 10)#字体,文字大小 draw.text((1,0),text, font=font, fill=(0, 0, 0))#起始坐标,字符串,字体,字体颜色 e = time.time() # print(f'创建图片写入字符耗时{round(e-s,2)}s') if show=='yes':#如果show为yes, img.show() if not save_path=='':#如果路径不为空,保存图片 img.save(save_path) return img ASCII_CHARS = ['.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a0d8bfa40534663f24dedfb4ac3cc1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b377dbd33f637caa1ab8eef2875bd46/" rel="bookmark">
			解决执行shell命令时出现argument list too long错误的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果执行shell命令时出现argument list too long的错误，其原因是需要操作的目标文件过多，比如超过2万个文件。
解决方式就是分批甚至逐个处理目标文件。
1. grep命令
命令行执行：
grep "Java" * -l 如果返回：
zsh: argument list too long: grep 命令改为：
ls | xargs -n 100 grep "Java" -l 说明：-n参数表示每批执行多少条数据。
2. cp命令
命令行执行：
cp -r *.zip ../result/ 如果返回：
zsh: argument list too long: cp 命令改为：
find . -name "*.zip" -exec cp {} ../result/ \; 3. rm命令
命令行执行：
rm -f *.zip 如果返回：
zsh: argument list too long: rm 命令改为如下任意一种：
ls *.zip | xargs rm -f find .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b377dbd33f637caa1ab8eef2875bd46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7825a307ff334c033174c70f405c743/" rel="bookmark">
			c#---汉字转拼音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/// &lt;summary&gt; /// 汉字转化为拼音 /// &lt;/summary&gt; /// &lt;param name="str"&gt;汉字&lt;/param&gt; /// &lt;returns&gt;全拼&lt;/returns&gt; public static string GetPinyin(string str) { string r = string.Empty; foreach (char obj in str) { try { ChineseChar chineseChar = new ChineseChar(obj); string t = chineseChar.Pinyins[0].ToString(); r += t.Substring(0, t.Length - 1); } catch { r += obj.ToString(); } } return r; } /// &lt;summary&gt; /// 汉字转化为拼音首字母 /// &lt;/summary&gt; /// &lt;param name="str"&gt;汉字&lt;/param&gt; /// &lt;returns&gt;首字母&lt;/returns&gt; public static string GetFirstPinyin(string str) { string r = string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7825a307ff334c033174c70f405c743/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc1a2b3d8e019ae1bf7cdaf2c9585558/" rel="bookmark">
			HTML 全面入门教程：从基础到高级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、基本结构和标签1. HTML 文档结构2. 常用标签 二、表单和输入元素1. 表单标签（`&lt;form&gt;`）2. 输入元素3.实例 三、样式和布局1. 内联样式2. 内部样式表3. 外部样式表 四、多媒体和嵌入内容1. 图像2. 音频和视频3. 嵌入内容 五、语义化标签语义化标签 HTML（Hypertext Markup Language）是用于创建网页的标记语言。它定义了网页的结构和内容，是前端开发的基础。 一、基本结构和标签 1. HTML 文档结构 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;HTML 全面入门教程：从基础到高级&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 代码中，展示了一个简单的 HTML 文档结构，其中包含 &lt;!DOCTYPE&gt; 声明、html 元素、head 元素、 body 元素和 h1 元素。
2. 常用标签 标题标签（&lt;h1&gt; - &lt;h6&gt;）：用于定义标题级别：&lt;h1&gt;标题一&lt;/h1&gt;段落标签（&lt;p&gt;）：用于定义段落文本：&lt;p&gt;这是一个段落。&lt;/p&gt;链接标签（&lt;a&gt;）：用于创建链接：&lt;a href="https://www.example.com"&gt;点击这里&lt;/a&gt;图像标签（&lt;img&gt;）：用于插入图片：&lt;img src="image.jpg" alt="图片"&gt;列表标签（&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;）：用于创建无序列表和有序列表： &lt;ul&gt; &lt;li&gt;列表项一&lt;/li&gt; &lt;li&gt;列表项二&lt;/li&gt; &lt;/ul&gt; 表格标签（&lt;table&gt;、&lt;tr&gt;、&lt;td&gt;）：用于创建表格： &lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格一&lt;/td&gt; &lt;td&gt;单元格二&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 二、表单和输入元素 1. 表单标签（&lt;form&gt;） &lt;form&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc1a2b3d8e019ae1bf7cdaf2c9585558/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/449ce504d3620bd42aa34d59ea21c32b/" rel="bookmark">
			Web教程（2） JSP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 JSPjsp内置对象内置对象详解转发和重定向的区别 JSP代码的几种写法代码 JSP 全名: Java Server Pages，中文名: java服务器页面
其根本是一个简化的Servlet设计。JSP技术有点类似ASP技术，它是在传统的网页HTML（标准通用标记语言的子集）文件(*.htm, *.html)中插入Java程序段(Scriptlet)和JSP标记(tag)，从而形成JSP文件，后缀名为(*.jsp)。
它实现了HTML语法中的java扩展（以 &lt;%, %&gt;形式）。JSP与Servlet一样，是在服务器端执行的。通常返回给客户端的就是一个HTML文本，因此客户端只要有浏览器就能浏览。
JSP技术使用Java编程语言编写类XML的tags和scriptlets，来封装产生动态网页的处理逻辑。网页还能通过tags和scriptlets访问存在于服务端的资源的应用逻辑。JSP将网页逻辑与网页设计的显示分离，支持可重用的基于组件的设计，使基于Web的应用程序的开发变得迅速和容易。
JSP(JavaServer Pages)是一种动态页面技术，它的主要目的是将表示逻辑从Servlet中分离出来。
Java Servlet是JSP的技术基础，而且大型的Web应用程序的开发需要Java Servlet和JSP配合才能完成。JSP具备了Java技术的简单易用，完全的面向对象，具有平台无关性且安全可靠，主要面向因特网的所有特点。
jsp内置对象 就是jsp中已经存在的，可以直接使用的内置对象
内置对象详解 jsp中有9大内置对象，本文介绍两种。
详解见 https://blog.csdn.net/niceliusir/article/details/78468661
1.request（请求）对象，表示请求。该对象中有请求中的所有参数，有以下常用方法：
根据name属性，获取表单提交的数据 request.getParameter("username") 表示把请求转发到sueccess.jsp request.getRequestDispatcher("success.jsp").forward(request, response); 网址仍为 check.jsp，网页内容却为 success.jsp
2.response（响应）对象，用于动态响应客户端请示，控制发送给用户的信息，并将动态生成响应。
从check.jsp 重定向至 login.jsp response.sendRedirect("login.jsp"); 网页跳转至check.jsp后立刻重定向至login.jsp
转发和重定向的区别 转发后地址栏不发生变化；重定向发生变化。转发能够带上参数，传到其他页面；重定向不行。转发是一次请求，一次响应；重定向是两次请求两次响应。需要参数的时候用转发，不需要参数的时候用重定向。 JSP代码的几种写法 1.JSP脚本(&lt;% %&gt;,里面都是java代码)
request.setAttribute("name", name); //为了将check.jsp内的name，传至seccess.jsp String name=(String)request.getAttribute("name"); //接收check.jsp传来的name 2.JSP表达式(&lt;%= %&gt;)，效果相当于获取到name的值
欢迎您&lt;%=name %&gt;，登录成功! 代码 login.jsp
&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/449ce504d3620bd42aa34d59ea21c32b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74ba184237fc2766c3b0a746cf44defa/" rel="bookmark">
			如何在 Spring Boot 中使用 OAuth2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Spring Boot 中使用 OAuth2 OAuth2 是一种授权协议，用于授权第三方应用程序访问受保护的资源。Spring Security 是一个强大的安全框架，支持 OAuth2 协议。在本文中，我们将介绍如何在 Spring Boot 中使用 Spring Security 实现 OAuth2 认证和授权。
什么是 OAuth2 OAuth2 是一种流行的授权协议，用于授权第三方应用程序访问受保护的资源。OAuth2 协议定义了四种角色：资源所有者、客户端、授权服务器和资源服务器。资源所有者是资源的拥有者，客户端是请求访问资源的应用程序，授权服务器是授权客户端访问资源的服务器，资源服务器是托管受保护资源的服务器。
OAuth2 协议涉及以下几个步骤：
客户端向授权服务器发送请求，请求授权访问某个资源。授权服务器向资源所有者询问是否授权客户端访问该资源。如果资源所有者授权客户端访问该资源，则授权服务器向客户端颁发访问令牌。客户端使用访问令牌向资源服务器请求访问受保护的资源。 OAuth2 协议定义了多种授权方式，包括授权码模式、隐式授权模式、密码模式和客户端凭证模式。每种授权方式都适用于不同的场景。
Spring Security OAuth2 Spring Security 是一个强大的安全框架，支持 OAuth2 协议。Spring Security OAuth2 提供了一组类和接口，用于实现 OAuth2 认证和授权。Spring Security OAuth2 支持多种授权方式，包括授权码模式、隐式授权模式、密码模式和客户端凭证模式。
Spring Boot 中使用 OAuth2 在 Spring Boot 中使用 OAuth2，我们需要添加以下依赖：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-autoconfigure&lt;/artifactId&gt; &lt;/dependency&gt; Spring Boot 会自动配置 Spring Security 和 Spring Security OAuth2。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74ba184237fc2766c3b0a746cf44defa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e8d16514660fe9913e6aa377a86eb10/" rel="bookmark">
			Web 开发的一些常用基础——HTTP请求与响应、Cookies与Session
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP 请求 进入浏览器的开发者模式下的 Network 监听组件，访问百度 https://www.baidu.com/，输入该 URL 后回车，观察这个过程中发生了怎样的网络请求：
请求，由客户端向服务端发出，可以分为 4 部分内容：请求方法（Request Method）、请求的网址（Request URL）、请求头（Request Headers）、请求体（Request Body）。
请求方法 常见的请求方法有两种：GET 和 POST。
在浏览器中直接输入 URL 并回车，这便发起了一个 GET 请求，请求的参数会直接包含到 URL 里。例如，在百度中搜索 Python，这就是一个 GET 请求，链接为 https://www.baidu.com/s?wd=Python，其中 URL 中包含了请求的参数信息，这里参数 wd 表示要搜寻的关键字。POST 请求大多在表单提交时发起。比如，对于一个登录表单，输入用户名和密码后，点击 “登录” 按钮，这通常会发起一个 POST 请求，其数据通常以表单的形式传输，而不会体现在 URL 中。
GET 和 POST 请求方法有如下区别：
GET 请求中的参数包含在 URL 里面，数据可以在 URL 中看到，而 POST 请求的 URL 不会包含这些数据，数据都是通过表单形式传输的，会包含在请求体中。GET 请求提交的数据最多只有 1024 字节，而 POST 请求没有限制。 常见的 HTTP 请求方法如下：
请求头 请求头，用来说明服务器要使用的附加信息，比较重要的信息有 Cookie、Referer、User-Agent 等。下面简要说明一些常用的头信息。
Accept：请求报头域，用于指定客户端可接受哪些类型的信息。Accept-Language：指定客户端可接受的语言类型。Accept-Encoding：指定客户端可接受的内容编码。Host：用于指定请求资源的主机 IP 和端口号，其内容为请求 URL 的原始服务器或网关的位置。从 HTTP 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e8d16514660fe9913e6aa377a86eb10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e2837de1a86c95ac8c733c128303d27/" rel="bookmark">
			点云配准综述一篇综述《A comprehensive survey on point cloud registration》（翻译）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参照了 2021最新关于点云配准的全面综述 - 知乎，并且加了些自己翻译，全篇的内容可能稍有删减。主要作为个人笔记，阅读了几篇综述，发现这篇是质量较好的，值得花时间细读。
文章分类
文章将配准方法分为了同源配准和不同源（跨源）数据配准，同源配准分为了基于优化的方法，基于特征的方法，基于端到端的配准算法
目录
III. 挑战（CHALLENGES）
A. Same-source challenges
B.跨源点云配准
IV. 分类（CATEGORIES）
A基于优化的方法（Optimisation-based registration methods）
B特征学习的配准方法
C基于端到端学习的方法
D跨源点云配准方法
V. 基于优化的配准方法（OPTIMISATION-BASED REGISTRATION METHODS）
A. ICP-based registration
B. Graph-based registration
C. GMM-based registration
D. Semi-definite registration
VI. 基于学习的配准方法（FEATURE-LEARNING METHODS FOR REGISTRATION）
A Learning on volumetric data
B Learning on point cloud
VII.基于端到端的深度学习方法 (END-TO-END LEARNING-BASED REGISTRATION)
A. Registration by regression
B. Registration by optimization and neural network
VIII. 跨源点云配准（CROSS-SOURCE POINT CLOUD REGISTRATION）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e2837de1a86c95ac8c733c128303d27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f30bd84f429ae91ac9ef8ac9e060830/" rel="bookmark">
			AntV G6新版源码浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 AntV是蚂蚁金服全新一代数据可视化解决方案，其中G6主要用于解决图可视领域相关的前端可视化问题，其是一个简单、易用、完备的图可视化引擎。本文旨在通过简要分析G6 5.x版本源码来对图可视领域的一些底层引擎进行一个大致了解，同时也为G6引擎的社区共建共享提供一些力量，可以更好的提供插件化功能的编写。
架构 新版G6整体是基于“插件化”的架构进行设计的，对外整体暴露Graph类及StdLib标准库，将主题、数据处理、布局、视图、类型、交互等均作为插件来进行处理，提供更高层次的定制化需求，提升更好的开源能力。
目录 整体采用monorepo进行源码的仓库管理
packages g6docssrc constant index.tsshape.ts item combo.tsedge.tsitem.tsnode.ts runtime controller data.tsextensions.tsindex.tsinteraction.tsitem.tslayout.tsplugin.tstheme.tsviewport.ts graph.tshooks.ts stdlib behavior activate-relations.tsbrush-select.tsclick-select.tsdrag-canvas.tsdrag-node.tshover-activate.tslasso-select.tsorbit-canvas-3d.tsrotate-canvas-3d.tstrack-canvas-3d.tszoom-canvas-3d.tszoom-canvas.ts data comboFromNode.ts item edge base.tsindex.tsline.ts node base.tsbase3d.tscircle.tsindex.tssphere.ts plugin grid index.ts legend index.ts minimap index.ts selector lasso.tsrect.ts theme dark.tslight.ts themeSolver base.tsspec.tssubject.ts index.ts types animate.tsbehavior.tscombo.tscommon.tsdata.tsedge.tsevent.tsgraph.tshook.tsindex.tsitem.tslayout.tsnode.tsplugin.tsrender.tsspec.tsstdlib.tstheme.tsview.ts util animate.tsarray.tscanvas.tsevent.tsextend.tsextension.tsindex.tsitem.tsmapper.tsmath.tspoint.tsshape.tsshape3d.tstext.tstype.tszoom.ts index.ts tests 源码 从架构层次可以看出，整体对外暴露的就是Graph的类以及stdLib的标准库，因而在分析源码调用过程中，我们抓住Graph进行逐步的往外拓展，从而把握整体的一个设计链路，避免陷入局部无法抽离。
Graph 对外暴露的Graph类是整个G6图的核心类
// https://github.com/antvis/G6/blob/v5/packages/g6/src/runtime/graph.ts export default class Graph&lt;B extends BehaviorRegistry, T extends ThemeRegistry&gt; extends EventEmitter implements IGraph&lt;B, T&gt; { public hooks: Hooks; // for nodes and edges, which will be separate into groups public canvas: Canvas; // the container dom for the graph canvas public container: HTMLElement; // the tag to indicate whether the graph instance is destroyed public destroyed: boolean; // the renderer type of current graph public rendererType: RendererName; // for transient shapes for interactions, e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f30bd84f429ae91ac9ef8ac9e060830/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13273cebe1f184728ed3deca67577730/" rel="bookmark">
			Go语言函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Go语言函数 函数是基本的代码块，用于执行一个任务。
Go 语言最少有个 main() 函数。
你可以通过函数来划分不同功能，逻辑上每个函数执行的是指定的任务。
函数声明告诉了编译器函数的名称，返回类型，和参数。
Go 语言标准库提供了多种可动用的内置的函数。例如，len() 函数可以接受不同类型参数并返回该类型的长度。如
果我们传入的是字符串则返回字符串的长度，如果传入的是数组，则返回数组中包含的元素个数。
1.1 函数定义 Go 语言函数定义格式如下：
func function_name( [parameter list] ) [return_types] { 函数体 } 函数定义解析：
func：函数由 func 开始声明
function_name：函数名称，参数列表和返回值类型构成了函数签名。
parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为
实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参
数。
return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这
种情况下 return_types 不是必须的。
函数体：函数定义的代码集合。
// 函数传入两个整型参数num1和num2,并返回这两个参数的最大值 // 函数返回两个数的最大值 func max(num1, num2 int) int { /* 声明局部变量 */ var result int if num1 &gt; num2 { result = num1 } else { result = num2 } return result } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13273cebe1f184728ed3deca67577730/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54cde976c48ebd3a426a4f0387bf5bf5/" rel="bookmark">
			Android系统安全 — 6.3 TLS双向认证原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考资料：
HTTPS协议详解(一)：HTTPS基础知识
HTTPS协议详解(二)：TLS/SSL工作原理
HTTPS协议详解(三)：PKI 体系
HTTPS协议详解(四)：TLS/SSL握手过程
HTTPS协议详解(五)：HTTPS性能与优化
SSL/TLS工作原理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ce890b715b25b7c3d2a0d372a832178/" rel="bookmark">
			Go学习圣经：Go语言实现高并发CRUD业务开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说在前面： 现在拿到offer超级难，甚至连面试电话，一个都搞不到。
尼恩的技术社群中（50+），很多小伙伴凭借 “左手云原生+右手大数据”的绝活，拿到了offer，并且是非常优质的offer，据说年终奖都足足18个月。
第二个案例就是：前段时间，一个2年小伙伴希望涨薪到18K， 尼恩把GO 语言的项目架构，给他写入了简历，导致他的简历金光闪闪，脱胎换骨，完全可以去拿头条、腾讯等30K的offer， 年薪可以直接多 20W。
第二个案例就是：一个6年小伙伴凭借Java+go双语言云原生架构，年薪60W。
从Java高薪岗位和就业岗位来看，云原生、K8S、GO 现在对于 高级工程师/架构师 来说，越来越重要。
所以，尼恩从架构师视角出发，基于尼恩 3高架构知识宇宙，写一本《GO学习圣经》，请到文末【技术自由圈】取。
《GO学习圣经》已经完成的内容有：
Go学习圣经：0基础精通GO开发与高并发架构 Go学习圣经：队列削峰+批量写入 超高并发原理和实操 Go学习圣经：从0开始，精通Go语言Rest微服务架构和开发
《GO学习圣经》PDF的最终目标
咱们的目标，不仅仅在于 GO 应用编程自由，更在于 GO 架构自由。
另外，前面尼恩的云原生是没有涉及GO的，但是，没有GO的云原生是不完整的。
所以， GO语言、GO架构学习完了之后，咱们再去打个回马枪，完成云原生的第二部分: 《Istio + K8S CRD的架构与开发实操》 , 帮助大家彻底穿透云原生。
文章目录 说在前面：业务CRUD的Restful API接口层的设计与开发业务CRUD的Restful API接口的设计Restful API路由管理，类似于SpringMVC 控制器Handler 处理器的设计和实现启动Gin WEB服务器 业务CRUD的Restful API服务层的设计与开发服务层的基础类context.Context 类型的上下文对象Context的原理Context接口内置函数Background()和TODO() Context的With系列函数WithCancelWithDeadlineWithTimeoutWithValue 使用Context的注意事项 业务CRUD的Dao层设计与开发Dao层的基础类global.DBEngine 对象的初始化model领域对象层使用GORM 链式操作，完成orm持久层的访问链式方法终结方法（Finisher ）新建会话方法 编写公共组件错误处理组件定义公共错误码定义处理公共方法 公共日志组件logrus 日志组件的使用日志组件初始化包全局变量 分页响应处理响应处理分页返回的使用 Swagger接口文档OpenAPI &amp; Swagger安装 Swagger写入注解swagger注解的编写swagger 配置文件的生成swagger中间件的注册通过swagger查看接口文档Swagger 背后发生了什么初始化 docsswagger注册路由 为接口做参数校验validator 介绍业务接口校验文章接口校验 模块开发：商品管理商品model 领域层开发商品 dao 层开发商品 service 层开发新增业务错误码新增商品的handler方法新增商品的api路由验证商品接口 《Golang 圣经》还有 5W字待发布参考资料技术自由的实现路径 PDF：实现你的 架构自由：实现你的 响应式 自由：实现你的 spring cloud 自由：实现你的 linux 自由：实现你的 网络 自由：实现你的 分布式锁 自由：实现你的 王者组件 自由：实现你的 面试题 自由： 业务CRUD的Restful API接口层的设计与开发 本文，围绕一个简单的商品微服务CRUD案例进行介绍。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ce890b715b25b7c3d2a0d372a832178/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3cf9bd9360b95a2de3b88ab4d750bd8/" rel="bookmark">
			【Java|多线程与高并发】定时器(Timer)详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 前言2. 定时器的基本使用3. 实现定时器4. 优化上述的定时器代码5. 总结 1. 前言 在Java中，定时器Timer类是用于执行定时任务的工具类。它允许你安排一个任务在未来的某个时间点执行，或者以固定的时间间隔重复执行。
在服务器开发中,客户端向服务器发送请求,然后等待服务器响应. 但服务器什么时候返回响应,并不确定. 但也不能让客户端一直等下去, 如果一直死等,就没有意义了. 因此通常客户端会通过定时器设置一个"等待的最长时间".
2. 定时器的基本使用 Java的标准库库中就给我们提供了一个定时器Timer类
可以看到Timer这个类在很多包里面都有,注意要选择java.util里的
其中在Timer类中有一个十分重要的方法- schedule()方法
形参：
task：要执行的任务，必须是TimerTask的子类，可以通过继承TimerTask类并重写run()方法来定义具体的任务逻辑。time：指定任务执行的时间，类型为java.util.Date。 当然一个Timer类中也可以执行设置多个任务.
示例:
public class Demo17 { public static void main(String[] args) { Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { System.out.println("1s!"); } },1000); timer.schedule(new TimerTask() { @Override public void run() { System.out.println("2s!"); } },2000); timer.schedule(new TimerTask() { @Override public void run() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3cf9bd9360b95a2de3b88ab4d750bd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e90c7975ec10d8920895aa395b95f0fe/" rel="bookmark">
			秒懂数据降维——主成分分析PCA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是主成分分析(PCA) 主成分分析（Principal Component Analysis，简称 PCA）是一种常用的数据降维方法，旨在通过将高维数据投影到低维空间中的主要方向来捕获数据的本质结构。主成分分析可用于降低数据的维度，压缩图像、音频和视频数据，去除冗余信息等。
为什么用主成分分析 数据压缩：PCA可以将高维数据投影到低维空间中，用较少的维度来表示数据，将数据的维度降低到原来的一部分，以达到数据压缩的目的。这不仅有助于减少计算开销和存储空间，还可以延长算法的生命周期，因为降维后的数据有更简单的结构，更容易使用和分析。去除冗余信息：PCA可以去除数据中的冗余信息，使数据更加紧凑。这有助于提高数据分析和挖掘的效率，因为我们只需要更少的数据来达到相同的分析目标。数据可视化：PCA可以将高维数据投影到低维平面上，帮助人们更好地可视化数据，揭示它们之间的关系和分布。例如，在图像识别和人脸识别中，可以用PCA来降低维度并展示人脸的主要特征，以更好地识别和分类。数据预处理：在某些分析方法中，高维数据可能会导致过拟合或其他问题，这时可以使用PCA来降低维度以避免这些问题。特征提取：PCA可以发现数据的主要特征，这对于特征提取很有用。例如，在机器学习中，可以使用PCA来选择最有代表性的特征，然后使用这些特征来训练机器学习模型。 主成分分析的数学原理 主成分分析（PCA）是一种线性变换技术，用于减少高维数据的复杂性并保留大部分变化的信息。其基本数学原理是通过对数据进行正交变换，使得每个新的主成分（也称为“特征向量”）都是原始数据的线性组合。原始数据如下图。
换句话说，PCA通过找到数据中的主要方向并将其重构为新的坐标轴，从而使我们能够更好地理解数据的结构。它的目的是将数据投影到一个低维空间上，使得每个主成分都包含了尽可能多的“信息”。
主成分分析后的数据如下图：
在数学上，PCA的探索目标是找到一个新的投影空间，使得在此空间中数据的方差最大。因此，在得出每个主成分（特征向量）后，它们按照其方差的降序排列。因此，在进行主成分分析时，我们需要考虑以下两个步骤：
计算协方差矩阵（covariance matrix）。找到协方差矩阵的特征值和特征向量，以便确定新的坐标轴。 通过以上两个步骤，我们可以确定每个主成分的方向和它们在数据集中的重要性（即方差）。通常，我们只使用前N个重要的主成分，这取决于数据本身的复杂性和需要保留多少信息来满足分析目的。
怎么使用主成分分析 以下是使用主成分分析的数学计算过程：
数据预处理：如果需要，将数据标准化，使每个变量具有相同的尺度。计算协方差矩阵：计算数据中各变量之间的协方差矩阵（或相关系数矩阵）。计算特征值和特征向量：对协方差矩阵进行特征值分解，得到其特征值和特征向量。选择主成分：根据特征值的大小，选择最高的几个特征向量作为主成分。计算得分：将选定的主成分作为新的变量，用数据集中的每个观测值投影到这些主成分上，得到得分，即降维后的新数据点。可视化结果：可视化降维后的数据点，以及主成分的贡献和方差解释程度等。 以下数据为例：
因素1因素2a5.44.4b-2.6-1.6c-3.6-2.6d2.41.9e-1.6-2.1 则以上数据用矩阵表示如下
因素1为x = ( 5.4 − 2.6 − 3.6 2.4 − 1.6 ) \begin{pmatrix}5.4 \\-2.6 \\-3.6 \\2.4 \\-1.6\end{pmatrix} ​5.4−2.6−3.62.4−1.6​ ​ ，因素2为y= ( 4.4 − 1.6 − 2.6 1.9 − 2.1 ) \begin{pmatrix}4.4 \\-1.6 \\-2.6 \\1.9 \\-2.1\end{pmatrix} ​4.4−1.6−2.61.9−2.1​ ​
那么组成的协方差矩阵为：
Q = ( V a r ( X ) C o v ( X , Y ) C o v ( X , Y ) V a r ( Y ) ) \begin{pmatrix} Var(X) &amp; Cov(X,Y) \\ Cov(X,Y) &amp; Var(Y) \end{pmatrix} (Var(X)Cov(X,Y)​Cov(X,Y)Var(Y)​) = 1 5 ( X ⋅ X X ⋅ Y X ⋅ Y Y ⋅ Y ) \frac{1}{5}\begin{pmatrix} X·X &amp; X·Y \\ X·Y &amp; Y·Y \end{pmatrix} 51​(X⋅XX⋅Y​X⋅YY⋅Y​) = 1 5 ( 57.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e90c7975ec10d8920895aa395b95f0fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4449d7c03c0d478be7733638ca67080/" rel="bookmark">
			什么是监督学习和无监督学习？它们有什么区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 监督学习（Supervised Learning）和无监督学习（Unsupervised Learning）是机器学习中两种基本的学习范式，它们有以下区别：
监督学习：
监督学习是基于有标签的训练数据进行学习的。在监督学习中，训练数据集包含输入样本和对应的标签或输出值。算法通过学习输入和对应的标签之间的关系，构建一个预测模型，用于预测未标记数据的输出值。监督学习的目标是通过已知的输入和输出之间的关系来进行预测和分类。 无监督学习：
无监督学习是基于无标签的训练数据进行学习的。在无监督学习中，训练数据集只包含输入样本，没有对应的标签或输出值。算法通过学习输入数据中的模式、结构或特征之间的关系，对数据进行聚类、降维或异常检测等操作。无监督学习的目标是发现数据中的隐藏结构或模式，对数据进行无监督的分析和理解。 总结：
监督学习需要有标签的训练数据，学习的目标是预测或分类。无监督学习使用无标签的训练数据，学习的目标是发现数据中的结构或模式。监督学习和无监督学习都是机器学习的重要领域，根据问题的性质和数据的特点选择适当的学习范式。 更多深度学习书籍+CV计算机视觉学习资料、AI论文、行业报告、思维导图等资料 +威❤公众H：AI技术星球 回复暗号 123 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3981297cf74f25bfaceea431d888bda2/" rel="bookmark">
			HCIP-7.3QinQ技术原理、配置&amp;链路聚合Eth-Trunk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HCIP-7.3QinQ技术原理、配置&amp;链路聚合Eth-Trunk 1、QinQ概述1.1、QinQ实现方式：1.2、QinQ封装结构：1.3、QinQ的分类：1.3.1、基于端口的QinQ1.3.2、灵活QinQ 2、链路聚合Eth-Trunk2.1、Eth-Trunk基本原理2.2、手工聚合模式2.2.1、配置接口的注意事项： 2.3、LACP模式2.3.1、LACP模式的抢占机制2.3.2、Eth-Trunk接口负载分担2.3.3、Eth-Trunk接口配置流程2.3.4、LACP模式Eth-Trunk配置 2.4、华为Eth-trunk和E-trunk区别 QinQ（ dot1Q in dot1Q）协议在用户私网（VPN）VLAN tag之外封装公网VLAN tag，在公网中报文只根据公网VLAN Tag传播。QinQ为用户提供一种较为简单的二层VPN隧道。 VLAN ID只有4096个，这对于小型网络当然是够用，但是遇上大中型网络4096个VLAN ID是远远不够的。
QinQ（802.1Q in 802.1Q）就是一项扩展vlan空间扩展技术，通过在内网Tag外面在添加一层公网Tag，这样数据就有了4096 * 4096个VLAN ID。
在运营商的边界使用，也称为终节，简单的二层VPN。与VPN不一样的是由路由器换成交换机。
1、QinQ概述 什么是QinQ？
基于802.1 Q封装的隧道协议核心思想是在用户私网VLAN tag之外封装公网VLAN tag, QinQ优点,报文封装双层VLAN Tag解决日益紧缺的公网VLAN ID资源问题 4096 * 4096用户可以规划自己的私网VLAN ID提供一种较为简单的二层VPN解决方案使用户网络具有较高的独立性 基于传统的802.1Q协议的实现方式:
1.1、QinQ实现方式： VLAN200-300–&gt;用VLAN3 tag包裹私网的200-300。
在公网进行传输时，设备只对外层VLAN Tag进行识别并学习，之前内网的Tag也会变为公网运输数据的一部分，到达目的私网后公网Tag就会被剥去，只留下一个私网Tag在私网内传输，所以即使私网VLAN Tag相同也不影响在公网上的传输。
1.2、QinQ封装结构： 8100是802.Q类型。
1.3、QinQ的分类： 根据QinQ的具体实现方式，通常分为如下几类：
基于端口的QinQ 基于端口的基本QinQ 灵活QinQ VLAN Stacking 基于流的灵活QinQ 基于ACL的灵活QinQ 1.3.1、基于端口的QinQ 配置了此功能的端口，设备会为从此端口进入的报文打上一层VLAN ID为端口PVID的外层VLAN tag。
基于端口的QinQ通过配置端口类型为dot1q-tunnel实现。
当端口类型为dot1q-tunnel时，该端口加入的VLAN不支持二层组播功能。
配置案例：
先配置二层
SW3
undo info-center enable //关闭系统信息 language-mode Chinese //中文信息，只能在交换机上使用。 clear configuration int g0/0/1 un shutdown sysn sw3 vlan b 10 20 int g 0/0/2 p l a p d v 10 int g 0/0/3 p l a p d v 20 int g 0/0/1 p l t p t a v 10 20 SW5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3981297cf74f25bfaceea431d888bda2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ece85f03b405520d0939519ed060d6d/" rel="bookmark">
			Unity 实现简单的发射子弹功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：对于射击类游戏，相信大家并不陌生。那么想要实现这一功能，我们通常会使用两种方法：
1.射线追踪。 2.子弹实例化。
今天，我们就通过第二种方式去实现发射的功能。
一、首先，我们准备好一把枪的模型，将其放到场景中，调整好位置。
二、 我们在枪口前面一点的位置创建一个空物体，作为发射口，调整好位置（注意：发射器位置不要和枪身太近）
三、制作简易子弹，这里我们使用胶囊体，改变一下大小和旋转调度就可以了。（注：这里的参数仅供参考，另外可以加材质球使其变个色）
四、实例化生成子弹。现在，我们将制作好的子弹做成预制体，并在枪发射器上新建一个脚本。（注意：发射器的Rotation要和子弹的保持一致）
using System.Collections; using System.Collections.Generic; using UnityEngine; public class GunShoot : MonoBehaviour { public GameObject bulletPrefab; //子弹预制体 void Update () { Shoot(); } void Shoot() { if (Input.GetMouseButtonDown(0)) //如果按下鼠标左键，生成预制体 { Instantiate(bulletPrefab, transform.position, transform.rotation); //生成预制体 } } } 写好后不要忘记将子弹的预制体拖到脚本里。现在，我们已经可以通过按下鼠标左键，来生成一枚子弹啦，只是还不能将其发射出去。
五、我们给子弹再新建一个脚本，让其具有移动功能。
using System.Collections; using System.Collections.Generic; using UnityEngine; public class Bullet : MonoBehaviour { public float speed = 8f; //子弹速度 void Start () { Destroy(gameObject, 7f); //7s后销毁自身 } void Update () { transform.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ece85f03b405520d0939519ed060d6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/054e06707ac189c50bae96709eabe188/" rel="bookmark">
			2023年，web前端工程师20道Vue面试题及解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 什么是Vue.js？它有哪些特点？2. Vue.js中的指令有哪些？如何使用？3. Vue.js中的生命周期函数有哪些？分别在什么时候被调用？4. Vue.js中的computed和watch有何不同？在什么情况下应该使用哪一个？5. 什么是Vue.js的单文件组件？如何使用？6. 如何实现Vue.js中的父子组件通信？7. Vue.js中的mixins有何作用？如何使用？8. Vue.js中的路由是什么？如何使用？9. Vue.js中的v-for指令有哪些用法？如何使用？10. Vue.js中的v-bind指令有何作用？如何使用？11. Vue.js中的事件修饰符有哪些？如何使用？12. Vue.js中的组件间通信有哪些方法？13. Vue.js中的路由导航钩子有哪些？如何使用？14. Vue.js中的lazy-loading有何作用？如何实现？15. 什么是Vue.js的异步更新队列？它有什么作用？16. Vue.js中的动态组件是什么？如何使用？17. Vue.js中的插槽是什么？如何使用？18. Vue.js中的内置指令有哪些？如何使用？19. Vue.js中的transition动画有哪些作用？如何使用？20. Vue.js中的key属性有什么作用？ 本文章列出了20道关于Vue.js的面试题，包括基础和进阶问题，并提供了问题的答案及解析，以帮助读者更好地准备面试。从指令、生命周期函数到组件间通信和路由等各方面都作了涉及。 1. 什么是Vue.js？它有哪些特点？ 答案：Vue.js是一款用于构建用户界面的渐进式框架。它的特点包括：
轻量级，文件体积小双向数据绑定组件化开发易于上手，学习曲线低
解析：这是一个基础问题，用于检验面试者是否了解Vue.js的基本特点，以及是否能够简单、清晰地用语言表述出来。 2. Vue.js中的指令有哪些？如何使用？ 答案：Vue.js中的指令包括v-if、v-for、v-bind、v-model、v-on等。使用方式是在HTML元素中添加以“v-”开头的属性。
解析：这是一个基础问题，主要考察面试者是否熟悉Vue.js中的常用指令，以及是否能够简单、清晰地用语言描述出来。
3. Vue.js中的生命周期函数有哪些？分别在什么时候被调用？ 答案：Vue.js中的生命周期函数有：beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed。它们分别在组件实例化、挂载、更新、销毁等不同的阶段被调用。
解析：这是一个基础问题，主要考察面试者Vue.js的生命周期函数是否熟悉，并且能够清晰地描述每个函数在何时被调用。
4. Vue.js中的computed和watch有何不同？在什么情况下应该使用哪一个？ 答案：computed和watch都是Vue.js中用于监听数据变化的方法。computed是计算属性，它会根据相关的数据自动计算出一个新的值；watch是监听器，它会在需要监听的数据发生变化时执行相应的操作。应该根据具体的需求选择合适的方法。
解析：这是一个进阶问题，主要考察面试者是否能够对Vue.js中的计算属性和监听器进行较为深入的理解，并能够根据实际场景进行选择。
5. 什么是Vue.js的单文件组件？如何使用？ 答案：Vue.js的单文件组件是将一个组件的HTML模板、JavaScript代码和CSS样式集中到一个文件中，以.vue作为后缀名保存。使用方式是使用import语句导入单文件组件，然后在组件中使用。
解析：这是一个基础问题，主要考察面试者是否了解Vue.js的单文件组件的基本概念，以及是否能够简单、清晰地用语言描述出来。
6. 如何实现Vue.js中的父子组件通信？ 答案：Vue.js中的父子组件通信有两种方式：props和$emit。
props是父组件向子组件传递数据的方式，子组件通过props来接收父组件传递的数据。$emit是子组件向父组件发送事件的方式，父组件通过v-on来监听子组件的事件并处理相应的逻辑。
解析：这是一个进阶问题，主要考察面试者对Vue.js组件通信的掌握程度，以及是否能够清晰地描述出来。 7. Vue.js中的mixins有何作用？如何使用？ 答案：Vue.js中的mixins是一种代码复用的方式，它允许开发者在多个组件中共享一些相同的代码。使用方式是在组件中使用mixins属性声明一个包含相应代码的对象，然后在组件中进行引用。
解析：这是一个进阶问题，主要考察面试者对Vue.js中mixins的理解，以及是否能够清晰地描述出来。
8. Vue.js中的路由是什么？如何使用？ 答案：Vue.js中的路由是一种管理前端路由的方式，可以在浏览器中实现页面之间的无缝跳转。Vue.js的路由功能通过vue-router库来实现。使用方式是在main.js中导入vue-router库，并在router实例中定义路由规则。
解析：这是一个进阶问题，主要考察面试者对Vue.js中路由的掌握程度，以及是否能够简单、清晰地描述出来。
9. Vue.js中的v-for指令有哪些用法？如何使用？ 答案：Vue.js中的v-for指令有两种用法：遍历数组和遍历对象。使用方式是在HTML元素上添加v-for属性，并指定相应的遍历对象。
解析：这是一个基础问题，主要考察面试者Vue.js中v-for指令的熟悉程度，并且是否能够简单、清晰地描述出来。
10. Vue.js中的v-bind指令有何作用？如何使用？ 答案：Vue.js中的v-bind指令用于绑定HTML元素的属性或特性。使用方式是在HTML元素上添加v-bind属性，并指定需要绑定的属性或特性。
解析：这是一个基础问题，主要考察面试者Vue.js中v-bind指令的熟悉程度，并且是否能够简单、清晰地描述出来。
11. Vue.js中的事件修饰符有哪些？如何使用？ 答案：Vue.js中的事件修饰符包括stop、prevent、capture、self、once、passive等。使用方式是在v-on指令后添加相应的修饰符。
解析：这是一个基础问题，主要考察面试者Vue.js中事件修饰符的熟悉程度，并且是否能够简单、清晰地描述出来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/054e06707ac189c50bae96709eabe188/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17a00e60dcaebacd1adc3149aa5c9feb/" rel="bookmark">
			SpringMVC全套详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、SpringMVC是什么1.1、MVC定义1.2、MVC和 SpringMVC的关系2.创建SpringMVC项目 2.1、SpringMVC 链接2.2、@RequestMapping 注解说明2.3 、 @GetMapping 和 @PostMapping 3、获取参数3.1、传递单个参数3.2、传递多个参数/表单参数传递3.3、传递对象3.4、后端参数重命名(后端参数映射)3.4.1、非必传参数设置 3.5、接收JSON对象3.6、获取URL中参数 @PathVariable3.7、上传文件@RequestPart 4、获取Cookie/Session/Header4.1、@CookieValue4.2、@RequestHeader4.3、@SessionAttribute 5、返回数据5.1、返回静态页面5.2、返回text/html5.3、返回JSON对象 6、请求转发 / 请求重定向7、@ResponseBody / @RestController 1、SpringMVC是什么 Spring MVC（Model-View-Controller）是Spring框架的一部分，是基于Servlet API构建的Web原始框架。用于开发基于Java的Web应用程序。它采用MVC设计模式，将应用程序分为三个核心组件：模型（Model）、视图（View）和控制器（Controller）。
SpringMVC 是一个Web框架。SpringMVC是基于Servlet API构建的。 1.1、MVC定义 模型（Model）： 表示应用程序中的数据和业务逻辑。在Spring MVC中，通常使用POJO（Plain Old Java Object）作为模型对象。通常模型对象负责在数据库中存取数据。视图（View）： 负责展示用户界面，通常是HTML页面、JSON响应或其他类型的视觉呈现。视图负责将模型数据渲染，并向用户呈现。控制器（Controller）： 接收并处理HTTP请求，并根据请求的内容选择相应的处理方法。控制器负责调度适当的业务逻辑，操作模型数据，并通过相应的视图返回响应结果。 MVC模式遵循单一职责原则，将应用程序的不同方面分离开来，使得每个部分都可以独立进行修改和扩展，提高了代码的可维护性和可测试性。同时，它也带来了更好的代码组织和清晰的逻辑层次。
在MVC模式中，用户与视图进行交互，视图将用户的请求发送给控制器，控制器根据请求调用相应的模型进行数据处理和更新，并选择合适的视图进行展示。这种分离使得每个部分可以独立开发、测试和维护，同时也支持更好的可重用性和可扩展性。
总而言之，MVC模式通过将应用程序划分为模型、视图和控制器三个组件，实现了数据、展示和交互的分离，以提供灵活、可维护和可扩展的软件设计方案。
1.2、MVC和 SpringMVC的关系 Spring MVC是在MVC模式的基础上实现的一种Web框架，或者说是MVC是一种思想，而SpringMVC是一种具体实现。它利用了MVC的优势并添加了更多的功能和便利性，使得开发者可以更轻松地构建和维护现代化的Web应用程序。
2.创建SpringMVC项目 在创建SpringBoot项目时，我们勾选的SpringWeb框架就是SpringMVC框架，因此照着SpringBoot创建流程就可以，只需添加SpringWeb依赖。【SpringBoot创建 链接】
2.1、SpringMVC 链接 在SpringMVC项目中使用@RequestMapping注解来实现URL路由映射。也就是在浏览器上连接程序的作用。接下来实现的访问地址localhost:8080/hi打印“hello SpringMVC”信息。
创建UserController类，实现用户到Spring 程序的连接。 import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; @Controller @ResponseBody //返回非页面数据 （默认是返回静态页面的） public class UserController { @RequestMapping("/hi") //注册路由 public String sayHi(){ return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17a00e60dcaebacd1adc3149aa5c9feb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/440f79f5f521bcee326806c0950525c6/" rel="bookmark">
			计算机内部总线详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 总线概述地址总线位宽 数据总线位宽CPU性能指标 例题 总线概述 众所周知，总线就是用来帮助连接两个或多个计算机组件，用于数据传输，计算机内部存在三种类型的总线：
地址总线：用于传输指示计算机中的内存或外设的物理地址数据总线： 是CPU与内存或其他器件之间的数据传送的通道。控制总线：管理组件之间的信息流，指示操作是读取还是写入，并确保操作在正确的时间发生。 CPU通过地址总线寻址，然后通过数据总线与外部设备互换信息。
地址总线 地址总线是一种微处理器用于传输内存物理地址的计算机总线。
CPU是通过地址总线来指定存储单元的。
它是单向的，只能在一个方向传输数据的 I/O 和数据的内存地址。
CPU 和 DMA（直接内存访问）使用地址总线来定位物理地址，计算机处理器使用地址总线从内存中定位数据的位置，在需要访问时指定物理地址的单个内存块，然后可以进行后续的读取/写入数据。
CPU 和 DMA 以二进制位的形式读/写所有的地址总线。
当系统要在内存中写入数据时，它会发送写入信号并将写入地址放在地址总线上，通过地址总线定位内存中的某个位置，然后将特定数据放在数据总线上，将数据传输到该位置。
位宽 地址总线位宽决定了CPU所能访问的最大内存空间的大小。地址总线是地址线数量之和。一根线只能传输地址的一个bit。
比如说：32根地址线就能传输32bit也就是32位宽，那么他可以传输的地址范围就是2的32次方=4G。也就是CPU的寻址范围是4G，所以最多支持4G内存。
如果电脑的地址总线宽度为 32，那么即使有 8G 内存，其中的 4G的内存也是用不了的（想使用 8G 内存，至少需要总线宽度为 33）。现在，新的计算机都在使用 64 位地址总线，寻址范围是非常大的。
数据总线 是CPU与内存或其他器件之间的数据传送的通道。
数据总线仅用于传输数据信号，分为内部和外部数据总线。
内部总线在处理器内部传输或传输信息或数据。
而外部总线在处理器和内存之间传输数据。
位宽 数据总线是数据线数量之和。
每条传输线一次只能传输1位二进制数据。eg: 8根数据线一次可传送一个8位二进制数据(即一个字节)。32跟数据线就可以传输一个32位的二进制数据，一次就可以传送一个32位的数据。
数据的每一位都必须在数据总线的不同线上传输，假如数据总线宽度为8，则数据 7 表示为 0000 0111，这些 0 和 1 比如分别放在 8 条数据总线上。
所以数据总线的宽度决定了CPU和外界的数据传送速度。数据总线的位数决定CPU单次通信能交换的信息数量。
比如：64位数据总线的CPU一次就能取出64bit的数据，8位数据总线的CPU一次只能取出8bit的数据，在相同频率的情况下，8位数据总线的CPU就得连续取8次数据，数据量才能和64位数据总线一次取出的数据量相同，单就比较取数据的性能就相差8倍。况且，通常CPU中的寄存器的位数与数据总线的宽度一样，所以在数据处理方面，64位的CPU又比8位的CPU快很多。
CPU的地址总线位数和数据总线可以不同（典型代表就是51单片机），但是一般都相同。
CPU性能指标 首先，总线的速度，即：CPU的主频，CPU的性能指标之一决定CPU和外设互换信息的速度。
其次，数据总线的宽度也是表示CPU性能的参数之一（通常，我们说“64位的CPU”是指CPU的数据总线的宽度是64位）。
例题 若内存容量为4GB，字长为32，则______。
A．地址总线和数据总线的宽度都为32
B．地址总线的宽度为30，数据总线的宽度为32
C．地址总线的宽度为30，数据总线的宽度为8
D．地址总线的宽度为32，数据总线的宽度为8
答案:A
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/440f79f5f521bcee326806c0950525c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2225046c9df47719e59086e7d7c548f/" rel="bookmark">
			Ubuntu 18.04分区方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu分区方案 先分逻辑分区后面在分主分区
【不需要全部设为主分区，只需要第一个设为主分区；各个分区大小根据情况自己定义】
目录分区建议大小格式描述是否可选/主分区100Gext4根目录，用于存放系统，相当于c 盘 安装系统和软件必选/home逻辑分区尽量大ext4相当于我的文档 存放一些个人数据必选swap（相当于电脑内存）逻辑分区物理内存 *（1~2）swap交换空间，类似Windows下的虚拟内存。空间大小，一般是等于电脑内存；如果容量足够，可以等于物理内存的2倍。必选/boot（引导分区）逻辑分区4096MBext4主分区,Linux的内核及引导系统程序所需要的文件，比如 vmlinuz initrd.img文件都位于这个目录中。在一般情况下，GRUB或LILO系统引导管理器也位于这个目录；启动撞在文件存放位置，如kernels，initrd，grub。建议选/usr逻辑分区ext4软件更新和安装（相当于软件盘）可单独分区也可不分区，如果不分区则应把容量加给 / 根目录可选efi系统分区逻辑分区4096MB它的作用和boot引导分区一样，但是boot引导默认grub引导，而efi是UEFI引导。不要按照那些老教程去选boot引导分区，否则就无法使用UEFI启动系统。容量大小给4096MB。可选 安装启动器设备 boot引导
我选的是/dev/sda 就是整块硬盘的那一个 让ubuntu引导windows
有些人选择的是/boot 对应的分区 但是安装完毕后得进入windows使用EasyBCD来维护引导而且感觉windows不太友善我是有丢失ubuntu的引导选项,又得用EasyBCD 重新设置一些
UEFI引导
启动器安装到efi系统分区下，切记。要不然会出现GRUB错误，而不能进入系统。
如果重做系统要找回/home数据 /home还是选择原来的对应的那个/home但是不要格式化就能恢复home的数据了
安装完成后的优化工作 完成上面的步骤后，Ubuntu18.04 就可以正常使用了。但是为了更加方便快捷的使用，建议再对装好的 Ubuntu 系统做以下的更改。
1.更换软件源 这里只给出步骤，详细的讲解请点我访问
Ubuntu 官方源服务器在欧洲，国内访问很慢。所以这里有必要将软件源更换为国内的源,
国内源很多，在这里我们选择阿里云与清华大学的 Ubuntu 源
# 阿里云源 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse ##測試版源 deb http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2225046c9df47719e59086e7d7c548f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdfdf5d91034394f76e4025b0744a58e/" rel="bookmark">
			【嵌入式烧录/刷写文件】-S１９文件解析（首行数据解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、概述二、S19文件解析三、举例 一、概述 １.概述：
Motorola S-record是一种文件格式，由摩托罗拉在20世纪70年代中期为Motorola 6800处理器创建，以ASCII文本形式传达二进制信息的十六进制值，其文件格式也可能为SRECORD，SREC，S19，mot，.S28，S37，SX，.s，.s1，.s2，.s3，. exo，.mxt。
S-record格式文件是Freescale CodeWarrior编译器生成的后缀名为.S19的程序文件，是一段直接烧写进MCU的ASCII码，英文全称问Motorola format for EEPROM programming。
注意：
上面“是一段直接烧写进MCU的ASCII码”，这样说可能会误导初学者，因为并不是直接将ASCII码写进MCU，写进MCU前还要对S19文件进行一个解析，把有用的机器代码分解出来，然后再进行写入，写入的也不是ASCII而是二进制码。
二、S19文件解析 S19文件格式与mot、SREC文件只是命名方式不同，看数据格式的话，其实是同一种文件，这里以S19文件为例。
S19文件每一行数据全部由记录类型和十六进制数字组成，包含类型、长度、地址、数据和校验和五个部分。
以下举例详细介绍每个组成部分
S19中记录类型包括S0、S1、S2、S3、S5、S7、S8、S9，S4是保留的，目前没有定义。
S0：位于文件的第一行，和其他行不同，地址部分没有使用，用“0000”置位，整行表示记录的开始；
数据场中的信息被划分为以下四个子域（此行表示程序的开始，不需烧入memory）：
name(名称)：20个字符，用来编码单元名称 ver(版本)：2个字符，用来编码版本号 rev(修订版本)：2个字符，用来编码修订版本号 description(描述)：0-36个字符，用来编码文本注释。 S1：表示地址长度为两字节（4字符）的记录，包含类型、长度、地址、数据和校验和五个部分；
S2：表示地址长度为三字节（6字符）的记录，包含类型、长度、地址、数据和校验和五个部分；
S3：表示地址长度为四字节（8字符）的记录，包含类型、长度、地址、数据和校验和五个部分；
S5：表示文件中含有S1、S2、S3记录的个数，其后不接数据，包含S5的记录并不是每个文件必须的；
S7：表示地址长度为四字节（8字符）的记录，包含类型、长度、地址和校验和四个部分，此行表示程序的结束；
S8：表示地址长度为三字节（6字符）的记录，包含类型、长度、地址和校验和四个部分，此行表示程序的结束；
S9：表示地址长度为两字节（4字符）的记录，包含类型、长度、地址和校验和四个部分，此行表示程序的结束；
只有S1、S2、S3、S5需要写入Flash中。
三、举例 S0 11 0000 0000486578766965772056312E31 08 ：
长度：长度包含一个字节，长度 = 地址字节数 + 数据字节数 + 校验和字节数；
0x11转换成十进制为17，即地址2+数据14+校验1 三部分长度为17；
地址：表示该行的起始地址，字节数由类型决定，S1位两个字节，S2为三个字节，S3位四个字节；
0000.由于是S0类型，所以地址位不用，使用0000置位，表示记录的开始；
数据：0000486578766965772056312E31，解析为HexviewV1.1（版本生成工具信息）
校验和：08， 校验和=0xff – (记录长度 + 存储地址 + 数据)——&gt;0xff-(0x11+0x00+0x00 +0x00+0x00+0x48+0x65+0x78+0x76+0x69+0x65+0x77+0x20+0x56+0x31+0x2E+0x31)=0xff-(0x3F7)——&gt;0x3F7取0xF7——&gt;0xff-0xf7=0x08
S3 0D 00F98000 015A000000FA0400 20:
类型：S3，地址长度为4个字节
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdfdf5d91034394f76e4025b0744a58e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/122/">«</a>
	<span class="pagination__item pagination__item--current">123/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/124/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>