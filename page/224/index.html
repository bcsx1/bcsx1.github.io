<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fd1ae277fb91a6295c77aec8c9b65e6/" rel="bookmark">
			Unity Text换行问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用Unity中UGUI的人都会有一个问题，在Text中显示中文文字是Text文本会莫名其妙的出现换行的问题
Text 在unity中的一段文字
不做处理是以下的显示效果
当对文字进行处理之后显示就不会出现换行的问题了。
Text只会对英文空格进行自动换行，当将英文空格换成中文空格(\u3000)时文本就不会被换行，而且也能实现一些文本设置如：首行缩进等.
private void settext() { //获取Text的文本内容 string temp_content = mText.text; string temp_indent = ""; //首行缩进的字符数 int m_Text_indent =2; for	(int i = 0; i &lt; m_Text_indent; i++) {	temp_indent = string.Format("{0}{1}", temp_indent, "\u3000"); } temp_content = string.Format("{0}{1}", temp_indent, text); //处理空格 if (m_IsSpace) { temp_content = temp_content.Replace(" ", "\u3000"); } //首行缩进替换 temp_content = temp_content.Replace("\n", "\n" + temp_indent); //重新设置Text文字 mText.text = temp_content; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c34960f70264e0dccdba0c779939692/" rel="bookmark">
			.NET/C# --- 读取单个或多个Json文件内的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、本篇文章主要讲述从json内获取数据通过后台代码
2、可以获取本地任何文件夹内的所有Json文件
3、本篇还是只提供方法，可变化性，升级性强，可以改成活得路径也非常简单大家可以自行操作
4、这里我还是用控制器给大家做演示
一、首先我得有json文件，我这里是存到了一个文件夹里 大家可以看我这个文件夹里面有好几个Json文件和别的格式的文件，接下来我们就要获取这个文件夹然后进行过滤，然后获取内容；
二、其次我们要有项目来写这个方法 我用的是控制器项目来进行演示，大家可以用Api、MVC、等多种方法进行编写。
//获取你想要获取的文件夹路径，也可以变成上传文件然后获取路径 DirectoryInfo directoryInfo = new DirectoryInfo(@"D:\lei.zhang\Desktop\json"); //获取文件夹下的所有子集文件 var fileInfos = directoryInfo.GetFiles(); //创建一个FileInfo类型的list集合用来存储我们找到的这些文件 List&lt;FileInfo&gt; list = new List&lt;FileInfo&gt;(); //然后我们通过for循环来循环我们的这些文件 for (int i = 0; i &lt; fileInfos.Count(); i++) { //这里我想要获取的是该文件夹下所有的json文件 所以我给加了个条件，后缀名为.json；大家如果要读取别的文件可以修改 if (directoryInfo.GetFiles()[int.Parse(i.ToString())].Extension == ".json") { //判断结束后；如果第i个文件是我们想要的格式，那么我们就把他存到我们的list集合中去方便我们接下来使用 list.Add(directoryInfo.GetFiles()[int.Parse(i.ToString())]); } else { //如果不是我们想要的文件我们就跳出本次循环进行下次循环 continue; } } //声明一个变量来存储接下来的循环次数 int count = 0; //我们接下来循环便利我们list集合中的我们想要的文件 （list里面存的是已经筛选好的文件） foreach (var fileInfo in list) { //循环次数加一 count++; //var str = File.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c34960f70264e0dccdba0c779939692/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5962b108463e68fef185d2505e5b0260/" rel="bookmark">
			VxLAN概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 什么是VxLAN？
VxLAN 全称是 Visual eXtensible Local Area Network（虚拟扩展本地局域网），从名字上就知道，这是一个VLAN的扩展协议。
VxLAN本质上是一种隧道封装技术。它使用TCP/IP协议栈的惯用手法——封装/解封装技术，将L2的以太网帧（Ethernet frames）封装成L4的UDP数据报（datagrams），然后在L3的网络中传输，效果就像L2的以太网帧在一个广播域中传输一样，实际上是跨越了L3网络，但却感知不到L3网络的存在。
2 为什么需要VxLAN？
一台服务器可虚拟多台虚拟机，而一台虚拟机相当于一台主机。主机的数量发生了数量级的变化，这也为虚拟网络带来了如下问题：
1. 虚拟机规模受网络规格限制
在传统二层网络环境下，数据报文是通过查询MAC地址表进行二层转发，而MAC地址表的容量限制了虚拟机的数量。
2. 网络隔离能力限制
当前主流的网络隔离技术是VLAN，在大规模的虚拟化网络中部署存在如下限制：
① 由于IEEE 802.1Q中定义的VLAN Tag域只有12比特，仅能表示4096个VLAN，无法满足大二层网络中标识大量租户或租户群的需求。
② 传统二层网络中的VLAN无法满足网络动态调整的需求。
3. 虚拟机迁移范围受网络架构限制
虚拟机启动后，可能由于服务器资源等问题（如CPU过高，内存不够等），需要将虚拟机迁移到新的服务器上。为了保证虚拟机迁移过程中业务不中断，则需要保证虚拟机的IP地址保持不变，这就要求业务网络是一个二层网络，且要求网络本身具备多路径的冗余备份和可靠性。
针对大二层网络，VXLAN的提出很好地解决了上述问题：
1. 针对虚拟机规模受网络规格限制
VXLAN将虚拟机发出的数据包封装在UDP中，并使用物理网络的IP、MAC地址作为外层头进行封装，对网络只表现为封装后的参数。因此，极大降低了大二层网络对MAC地址规格的需求。
2. 针对网络隔离能力限制
VXLAN引入了类似VLAN ID的用户标识，称为VXLAN网络标识VNI（VXLAN Network Identifier），由24比特组成，支持多达16M的VXLAN段，从而满足了大量的用户标识。
3. 针对虚拟机迁移范围受网络架构限制
VXLAN通过采用MAC in UDP封装来延伸二层网络，将以太报文封装在IP报文之上，通过路由在网络中传输，无需关注虚拟机的MAC地址。且路由网络无网络结构限制，具备大规模扩展能力、故障自愈能力、负载均衡能力。通过路由网络，虚拟机迁移不受网络架构限制。
3 VxLAN隧道是如何建立的？
VXLAN在两台TOR交换机之间建立了一条隧道，将服务器发出的原始数据帧加以“包装”，好让原始报文可以在承载网络（比如IP网络）上传输。当到达目的服务器所连接的TOR交换机后，离开VXLAN隧道，并将原始数据帧恢复出来，继续转发给目的服务器。
另外，VxLAN网络中出现了一些传统数据中心网络中没有的新元素，如VTEP、VNI等。
VxLAN VTEP
VTEP（VXLAN Tunnel Endpoints，VXLAN隧道端点）是VXLAN网络的边缘设备，是VXLAN隧道的起点和终点，VXLAN对用户原始数据帧的封装和解封装均在VTEP上进行。
VTEP是VXLAN网络中绝对的主角，VTEP既可以是一台独立的网络设备，也可以是在服务器中的虚拟交换机。源服务器发出的原始数据帧，在VTEP上被封装成VXLAN格式的报文，并在IP网络中传递到另外一个VTEP上，并经过解封转还原出原始的数据帧，最后转发给目的服务器。
VxLAN VNI
以太网数据帧中VLAN只占了12比特的空间，这使得VLAN的隔离能力在数据中心网络中力不从心。而VNI的出现，就是专门解决这个问题的。
VNI（VXLAN Network Identifier，VXLAN 网络标识符），VNI是一种类似于VLAN ID的用户标识，一个VNI代表了一个租户，属于不同VNI的虚拟机之间不能直接进行二层通信。VXLAN报文封装时，给VNI分配了24比特的长度空间，使其可以支持海量租户的隔离。
另外，在分布式网关部署场景下，VNI还可分为二层VNI和三层VNI，它们的作用不同：
① 二层VNI是普通的VNI，以1：1方式映射到广播域BD，实现VXLAN报文同子网的转发。
② 三层VNI和VPN实例进行关联，用于VXLAN报文跨子网的转发。
4 VxLAN网关
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5962b108463e68fef185d2505e5b0260/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0cf007bc5cf16165370fca9bffce4fa/" rel="bookmark">
			MySQL 虚拟列和虚拟索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 虚拟列和虚拟索引 是什么
Mysql 5.7 中推出了一个非常实用的功能 虚拟列 Generated (Virtual) Columns
在MySQL 5.7中，支持两种Generated Column，即Virtual Generated Column和Stored Generated Column，前者只将Generated Column保存在数据字典中（表的元数据），并不会将这一列数据持久化到磁盘上；后者会将Generated Column持久化到磁盘上，而不是每次读取的时候计算所得。很明显，后者存放了可以通过已有数据计算而得的数据，需要更多的磁盘空间，与Virtual Column相比并没有优势，因此，MySQL 5.7中，不指定Generated Column的类型，默认是Virtual Column。
如果需要Stored Generated Golumn的话，可能在Virtual Generated Column上建立索引更加合适
综上，一般情况下，都使用Virtual Generated Column，这也是MySQL默认的方式
能干嘛
能对 where 条件 上使用函数等原因使索引失效 如使用函数 就可以对这个 字段和函数建立一个虚拟类和虚拟索引提高效率
怎么用
比如是 sys_user 表中 create_time
他是一个datetime 类型的
假设我们有一个查询
SELECT dayofweek(create_time) from sys_user WHERE dayofweek(create_time) = 1 结果
执行计划
如果我们为create_time 字段 建立索引 这个查询语句 仍然无法使用索引 因为 函数 阻止了索引 (这里就不实验了啊 有兴趣可以自己试试 肯定没用)
建立一个虚拟列
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0cf007bc5cf16165370fca9bffce4fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43d3066ca8ab7dac60fcba311d8ce020/" rel="bookmark">
			【Css】移动端用flex实现DIV高度自适应屏幕和带滚动条效果（代码示例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、自适应高度 vh: 相对于视窗的高度, 视窗被均分为100单位的vh; vw: 相对于视窗的宽度, 视窗被均分为100单位的vw;
vmax: 相对于视窗的宽度或高度中较大的那个。其中最大的那个被均分为100单位的vmax; vmin: 相对于视窗的宽度或高度中较小的那个。其中最小的那个被均分为100单位的vmin; calc(100vh - 10px) 表示整个浏览器窗口高度减去10px的大小
calc(100vw - 10px) 表示整个浏览器窗口宽度减去10px的大小
.card_1 { width: 100%; height: calc(100vh - 320px); } 二、滚动条设置 .big_div { width: 100%; overflow-x: hidden; /*x轴禁止滚动*/ overflow-y: scroll; /*y轴滚动*/ height:height: calc(100vh - 320px); } .big_div::-webkit-scrollbar { display: none;/*隐藏滚动条*/ } 三、div自适应，还能实现滚动条实例（垂直） &lt;html&gt; &lt;head&gt; &lt;title&gt;div自适应，还能实现滚动条实例&lt;/title&gt; &lt;meta http-equiv="content-type" content="text/html;charset=gb2312"&gt; &lt;/head&gt; &lt;style&gt; .box { height: 500px; width: 350px; background-color: rgb(253, 242, 242); display: flex; flex-direction: column; border-bottom: 3px rgb(206, 11, 190) solid; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43d3066ca8ab7dac60fcba311d8ce020/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a082c6bb9d2e455f27eb4461def7aa71/" rel="bookmark">
			华为交换机配置SNMP精讲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、SNMP原理
SNMP是广泛应用于TCP/IP网络的网络管理标准协议。网管系统可以通过SNMP协议对网络设备（包括交换机、路由器、防火墙等）进行监测和管理。
SNMP是被广泛接受并投入使用的工业标准，用于保证管理信息在任意两点间传送，便于网络管理员在网络上的任何节点检索信息、修改信息、寻找故障、完成故障诊断、进行容量规划和生成报告。SNMP采用轮询机制，只提供最基本的功能集，特别适合在小型、快速和低价格的环境中使用。SNMP的实现基于连接的传输层协议UDP，得到众多产品的支持。
SNMP分为NMS和Agent两部分，NMS（Network Management Station），是运行客户端程序的工作站，目前常用的网管平台有Sun NetManager和IBM NetView；Agent是运行在网络设备上的服务器端软件。
NMS可以向Agent发出GetRequest、GetNextRequest和SetRequest报文，Agent接收到NMS的请求报文后，根据报文类型进行Read或 Write操作，生成Response报文，并将报文返回给NMS。Agent在设备发现重新启动等异常情况时，也会主动向NMS发送Trap报文，向NMS汇报所发生的事件。
SNMP网络架构：
如上图所示，SNMP网络的组成包括网管、被纳管设备、中间网络，这几部分都有可能导致网管与被纳管设备之间的SNMP交互异常。
SNMP版本及支持的MIB：
为了在SNMP报文中唯一标识设备中的管理变量，SNMP用层次结构命名方案来识别管理对象。用层次结构命名的管理对象的集合就象一棵树，树的节点表示管理对象，如下图所示。管理对象可以用从根开始的一条路径别无二义地识别。
MIB（Management Information Base）的作用就是用来描述树的层次结构，它是所监控网络设备的标准变量定义的集合。在上图中，管理对象B可以用一串数字{1.2.1.1}唯一确定，这串数字是管理对象的Object Identifier（客体标识符）。
以太网交换机中的SNMP Agent支持SNMP V1、V2C和V3，支持的常见MIB如下表所示。
以太网交换机支持的常见MIB：
二、配置SNMP流程
SNMP的主要配置包括：
1. 设置团体名；
2. 设置sysContact；
3. 允许或禁止发送Trap；
4. 设置Trap目标主机的地址；
5. 设置sysLocation；
6. 配置本地或远端设备的名字；
7. 配置一个SNMP的组；
8. 指定发送Trap的源地址；
9. 为一个SNMP的组添加一个新用户；
10. 创建或者更新视图的信息；
11. 设置Agent能接收/发送的SNMP消息包的大小。
开启SNMP：
1.通过telnet登录交换机或者去机房插console线。
配置交换机的读团体名和写团体名为"public"。
snmp-agent/设置读团体名∶public/snmp-agent community read public/设置写团体名∶private/snmp-agent community write private 2.配置SNMP版本（all是所有版本）。
snmp-agent sys-info version all/设置联系方式/snmp-agent sys-info contact MR.LI-tel:8002/设置设备位置/snmp-agent sys-info location 3rd-flood 3.允许向网管工作站（NMS）192.168.1.1发送Trap报文，使用的团体名为public。
snmp-agent target-host trap address udp-domain 172.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a082c6bb9d2e455f27eb4461def7aa71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ff5946aad1a040c838f436a1ffa4876/" rel="bookmark">
			C&#43;&#43;设计模式——观察者模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、观察者模式二、代码实现总结 前言 设计模式分为三大类： 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
一、观察者模式 观察者模式（有时又被称为模型（Model）-视图（View）模式、源-收听者(Listener)模式或从属者模式）是软件设计模式的一种。在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。
二、代码实现 代码如下（示例）：
//观察者抽象类 class Observer	{ public: //处理消息的接口 virtual void handle(int msgid) = 0; }; //第一个观察者实例 class Observer1 : public Observer { public: void handle(int msgid) { switch (msgid) { case 1: cout &lt;&lt; "Observer1 recv 1 msg" &lt;&lt; endl; break; case 2: cout &lt;&lt; "Observer1 recv 2 msg" &lt;&lt; endl; break; default: cout &lt;&lt; "Observer1 recv unknow msg!" &lt;&lt; endl; break; } } }; //第二个观察者实例 class Observer2 : public Observer { public: void handle(int msgid) { switch (msgid) { case 2: cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ff5946aad1a040c838f436a1ffa4876/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac80e56bc93920caf5c96d6fd5b859bb/" rel="bookmark">
			C&#43;&#43;设计模式——适配器模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、适配器模式二、使用步骤1.引入库 总结 前言 设计模式分为三大类： 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
一、适配器模式 在计算机编程中，适配器模式（有时候也称包装样式或者包装）将一个类的接口适配成用户所期待的。一个适配允许通常因为接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。
二、使用步骤 1.引入库 代码如下（示例）：
class VGA	//VGA接口类 { public: virtual void play() = 0; string getType()const { return "VGA"; } }; //TV01表示支持VGA接口的投影仪 class TV01 : public VGA { public: void play() { cout &lt;&lt; "通过VGA接口连接投影仪，进行视频播放" &lt;&lt; endl; } }; //实现一个电脑类	只支持VGA接口 class Computer { public: //由于电脑只支持VGA接口，所有该方法的参数也只能支持VGA接口的指针/引用 void playVideo(VGA* pvga) { pvga-&gt;play(); } }; //进了一批新的投影仪，但是新的投影仪都只支持HDMI接口 class HDMI { public: virtual void play() = 0; }; class TV02 :public HDMI { public: void play() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac80e56bc93920caf5c96d6fd5b859bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfb7d9afe7597dbc433cf80adeee20ea/" rel="bookmark">
			vscode快捷键整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 注释
（1）// 方式
注释/取消注释：Ctrl + /
（2）/* */ 方式
注释：Ctrl + Shift + /
取消注释：Ctrl + Shift + \
2. 代码排版
整体右移 - 选中代码段： Tab
整体左移 - 选中代码段： Shift + Tab
Ctrl+Shift+P，F1：显示命令面板
Ctrl+P：快速打开
Ctrl+Shift+N：新窗口/实例
Ctrl+Shift+W：关闭窗口/实例
Ctrl+X：剪切行
Ctrl+C：复制行
ALT+↑/↓：上下移动
Shift+Alt+↓/↑：向上/向下复制行
Ctrl+Shift+K：删除行
Ctrl+Enter：在下面插入行
Ctrl+Shift+Enter：在上面插入行
Ctrl+Shift+\：跳到匹配的括号
Ctrl+]/[：缩进
Home/End：转到文件的开头/转到文件的末尾
Ctrl+↑/↓：上下滚动
ALT+PgUp/PgDown：上下滚动页面
Ctrl+Shift+[：折叠(折叠)区域
Ctrl+Shift+]：展开(未折叠)区域
Ctrl+K Ctrl+C：添加行注释
Ctrl+K Ctrl+U：删除行注释
Ctrl+/：切换行注释
shift+Alt+A：切换块注释
ALT+Z：切换换行
Ctrl+Tab：显示所有符号
Ctrl + G：转到行
Ctrl + P：转到文件
Ctrl + Shift + O：转到符号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfb7d9afe7597dbc433cf80adeee20ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c901189af08a48c6f176df450392f95/" rel="bookmark">
			[linux][报错]多个硬盘状态foreign解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有台linux服务器一直无法正常启动。
机房查看raid（ctrl+g）
查看一块磁盘failed，两块磁盘foreign
忘记拍照了。反正就是状态不是online。
1.首先尝试将failed修复为是online
pd mgmt界面。选中 failed的磁盘，按 F2。
选择 place drive online.
2.修复提示foreign的两块
进入VD Mgmt中选择contrllor 0,按F2，选择foreign，选择clear
此动作有丢失数据的风险，其实如果不是坏得很严重，一般不会。因为我搞过很多次。
经过以上操作我现在的状态如下，进行重启可以进入系统
但是服务器闪灯还是异常，因为还在修复
发现有一块盘为ug状态，清除已存在的RAID信息，此时硬盘变为UG(UnconfigGood)状态，重新拔插该硬盘，保存退出RAID卡管理界面。（这步建议rebuild完成后操作）
重启可以进入界面了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e650a20bdb33360efe63b1e7a47cfed/" rel="bookmark">
			Springboot&#43;Zookeeper&#43;Seata
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		maven依赖
&lt;dependency&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.esotericsoftware.kryo&lt;/groupId&gt; &lt;artifactId&gt;kryo&lt;/artifactId&gt; &lt;version&gt;2.24.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.esotericsoftware&lt;/groupId&gt; &lt;artifactId&gt;kryo&lt;/artifactId&gt; &lt;version&gt;4.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.javakaffee&lt;/groupId&gt; &lt;artifactId&gt;kryo-serializers&lt;/artifactId&gt; &lt;version&gt;0.44&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;!--排除这个slf4j-log4j12--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.13.0&lt;/version&gt; &lt;/dependency&gt; yml配置
seata: enabled: true application-id: system-user tx-service-group: my_test_tx_group data-source-proxy-mode: AT client: undo: # undo序列化方式 这个值需要在 seata server 的配置中心中修改，否则不生效 logSerialization: jackson # 自定义undo表名 logTable: undo_log rm: lock: retryInterval: 10 retryTimes: 30 # 分支事务与其它全局回滚事务冲突时锁策略 默认true，优先释放本地锁让回滚成功 retryPolicyBranchRollbackOnConflict: false tm: # 一阶段全局提交结果上报TC重试次数 commit-retry-count: 5 # 一阶段全局回滚结果上报TC重试次数 rollback-retry-count: 5 # 分布式事物超时时间 default-global-transaction-timeout: 600000 # 降级开关,false 不打开 degrade-check: false degrade-check-period: 2000 degrade-check-allow-times: 10 service: # 全局事务开关 disableGlobalTransaction: false vgroupMapping: # my_test_tx_group: default system-user-fescar-service-group: default default: grouplist: 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e650a20bdb33360efe63b1e7a47cfed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2df6a46a7516ea86abad3284a431d789/" rel="bookmark">
			nginx 反向代理minio错误排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误1 在使用预签名时出现以下错误：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Error&gt; &lt;Code&gt;SignatureDoesNotMatch&lt;/Code&gt; &lt;Message&gt;The request signature we calculated does not match the signature you provided. Check your key and signing method.&lt;/Message&gt; &lt;Key&gt;25ddd455-0f47-414c-8f32-40a4f9dab2ad.jpg&lt;/Key&gt; &lt;BucketName&gt;object-images&lt;/BucketName&gt; &lt;Resource&gt;/object-images/25ddd455-0f47-414c-8f32-40a4f9dab2ad.jpg&lt;/Resource&gt; &lt;RequestId&gt;171DC9F70242E7B9&lt;/RequestId&gt; &lt;HostId&gt;e018e642-71a1-41f3-bd47-e20d6c2ad4f1&lt;/HostId&gt; &lt;/Error&gt; 错误原因：
错误的将MINIO_HOST指定成ip:port，前端上传时使用域名上传就会出现以上错误
正确的方法是签名和上传时应该统一，使用ip:port或域名，不能混用
minio_client = Minio( MINIO_HOST, access_key=MINIO_ACCESS_KEY, secret_key=MINIO_SECRET_KEY, secure=MINIO_SECURE ) 错误2 urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='xxx.com', port=443): Max retries exceeded with url: /object-images?location= (Caused by SSLError(SSLCertVerificationError(1, '[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1129)'))) 指定http_client即可
http_client = urllib3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2df6a46a7516ea86abad3284a431d789/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6b43c4d0f745b653b5ac0d6d558adb0/" rel="bookmark">
			AT32F403A, XMC, SPIM, LVGL, 图片, SPIM存储意外擦除的BUG原因与解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面： XMC初始化时添加：
gpio_pin_remap_config(XMC_NADV_MUX, TRUE);
1、环境： IAR， LVGLv8， ILI9488, W25Q32, XMC, AT32F403A-LQFP100
2、现像描述： 1)关键代码如下： system_clock_config();
nvic_priority_group_config(NVIC_PRIORITY_GROUP_4);
delay_init();
dG_Flash0.pf_Config();
spim_init();
lv_obj_t* img1 = lv_img_create(lv_scr_act());
lv_img_set_src(img1, &amp;_book_alpha_50x50);
lv_obj_set_style_bg_color(img1, lv_color_make(0, 0xff, 0), 0);
lv_obj_set_size(img1, 50, 50);
lv_obj_set_pos(img1, 0, 0);
while(1){
lv_task_handler();
}
图片是存储在W25Q32里的位置0x08400000，通过QSPI访问。
2)现像如下： 当运行到spim_init(); 后，可以通过IAR的调试得到数据如下
初始化前
初始化后
当运行到lv_task_handler();也就是，运行完后，数据如下：
使用w25q64为ff,使用w25q32为乱码
3)、问题查找 已经能够确定不是显示驱动，因为能正常画按键。
程序最开始是调试的SPIM，能够正常运行。后来使用XMC与SPIM就出现问题。
单步调试时，只出现过一次正常显示图片的上边一点点，猜测为硬件问题。
查找硬件原理图如下：
官方推荐硬件图如下AN0042_AT32_SPIM_Application_Note_ZH_V2.0.0.pdf (arterytek.com)：
修改电路后如下：
测试后，问题依然存在。
此时继续各种调试，没有发现有用的现像。问题到此卡住。不过依然怀疑与XMC有关。
通过网络搜索得到 AN0024， PB7做为XMC的NADV共用（都为PB7），存在数据冲突。
使用gpio_pin_remap_config(XMC_NADV_MUX, TRUE);将XMC_NADV转为复用功能后恢复正常。
到此问题解决。
3、值得注意的是，外部SPIM还会影响单片机的时钟频率： 查询DS得到如下：
4、总结 AT32F403A的XMC与SPIM共用时存在引脚冲突(PB7),在初始化XMC时加上此句gpio_pin_remap_config(XMC_NADV_MUX, TRUE);
以解决利用问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7f315ed5b9d1e9d408e48a178662a0f/" rel="bookmark">
			C/C&#43;&#43; static
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		static 是什么？ static 是C++中的一个修饰符，它用来控制变量的存储方式和可见性。
为什么要用static 因为函数内部定义的变量，当程序执行到它的定义处时，编译器为它在栈上分配空间，函数在栈上分配的空间在此函数执行结束时会释放掉。如果想将函数中此变量的值保存至下一次调用时，如何实现？使用全局的变量（使得在此函数中定义的变量，不仅仅只受此函数控制）。static 关键字则可以很好的解决这个问题。
什么时候用 当需要一个数据对象为整个类而非某个对象服务，同时又力求不破坏类的封装性，即要求此成员隐藏在类的内部，对外不可见时，可将其定义为静态数据。
静态数据的存储 全局（静态）存储区 全局（静态）存储区：分为 DATA 段和 BSS 段。DATA 段（全局初始化区）存放初始化的全局变量和静态变量；BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。
在 C++ 中 static 的内部实现机制： 静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。
这样，它的空间分配有三个可能的地方，一是作为类的外部接口的头文件，那里有类声明；二是类定义的内部实现，那里有类的成员函数定义；三是应用程序的 main() 函数前的全局数据声明和定义处。
静态数据成员要实际地分配空间，故不能在类的声明中定义（只能声明数据成员）。类声明只声明一个类的"尺寸和规格"，并不进行实际的内存分配，所以在类声明中写成定义是错误的。它也不能在头文件中类声明的外部定义，因为那会造成在多个使用该类的源文件中，对其重复定义。
static 被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。
优势 可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。
C/C++ 中static的作用 在修饰变量的时候，static 修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）。 面向过程中的static 静态全局变量 静态全局变量在全局数据区分配内存，未经初始化的会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化），在声明它的整个文件都是可见的，而在文件之外是不可见的；
优点：静态全局变量不能被其它文件所用；其它文件中可以定义相同名字的变量，不会发生冲突。
全局变量和全局静态变量的区别 全局变量是不显式用 static 修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量。全局静态变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用。 静态局部变量 静态局部变量在全局数据区分配内存，在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化，一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0，它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。
面向对象中的static 静态数据成员 对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。也就是说，静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；
在类内数据成员前加上 static 关键字，即为静态数据成员对于类静态数据成员，无论有多少个该类的对象，该静态数据成员在内存中只有一份拷贝(其他普通数据成员，每个类对象都有自己的内存拷贝)，该静态数据成员由所有该类对象共享静态数据成员存储在全局数据区，在定义时分配存储空间，程序运行结束时销毁静态数据成员不能再类中定义和初始化，只能在类中声明，在类外进行定义和初始化，默认初始化为0静态数据成员的初始化为 &lt;类型名&gt; &lt;类名&gt;::&lt;变量名&gt; = &lt;值&gt;静态数据成员遵从 public private protected 访问规则静态数据成员可以直接使用类名加作用域运算符(::)直接访问 &lt;类名&gt;::&lt;变量名&gt;(访问规则允许的情况下) 静态成员函数 与静态数据成员一样，我们也可以创建一个静态成员函数，它为类的全部服务而不是为某一个类的具体对象服务。静态成员函数与静态数据成员一样，都是类的内部实现，属于类定义的一部分。普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this是缺省的。如函数fn()实际上是this-&gt;fn()。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7f315ed5b9d1e9d408e48a178662a0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8de1a0d6cb0747a478db2ba4ea5f511/" rel="bookmark">
			C&#43;&#43; const
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class A { private: const int a; // 常对象成员，可以使用初始化列表或者类内初始化 public: // 构造函数 A() : a(0) { }; A(int x) : a(x) { }; // 初始化列表 // const可用于对重载函数的区分 int getValue(); // 普通成员函数 int getValue() const; // 常成员函数，不得修改类中的任何数据成员的值 }; void function() { // 对象 A b; // 普通对象，可以调用全部成员函数 const A a; // 常对象，只能调用常成员函数 const A *p = &amp;a; // 指针变量，指向常对象 const A &amp;q = a; // 指向常对象的引用 // 指针 char greeting[] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8de1a0d6cb0747a478db2ba4ea5f511/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2ba00e86c0312b9be35232b067e5ef6/" rel="bookmark">
			学习solid works第四课------草图镜像、阵列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、镜像 先草图绘制一个圆，跟在圆的一侧画一条垂直线。点击镜像实体-然后选择需要镜像的实体和镜像轴，完成后确定。
二、阵列 1、线性阵列 点击草图中的线性草图阵列，弹出设计树。在设计树中选择需要阵列的草图，数量以及方向等。预览无误后点击确定。
2、圆周 点击草图阵列中的圆周草图阵列在弹出的设计树中设置参数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32ccae7de964b9634ff5227a4096cdff/" rel="bookmark">
			ECharts tooltip 位置设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Echarts如果data较多tooltip默认显示会遗漏一些数据，导致无法展示
解决方法：
给tooltip增加position函数，自动更新位置
tooltip: { trigger: 'axis', position( point: number[], _params: unknown, _dom: unknown, _rect: unknown, size: { contentSize: number[] } ) { const [pointX, pointY] = point; const [boxWidth, boxHeight] = size.contentSize; const x = boxWidth &gt; pointX ? pointX + 10 : pointX - boxWidth - 10; const y = boxHeight &gt; pointY ? 5 : pointY - boxHeight; return [x, y]; }, }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27e86e1aa51d960b4843171e541bb2ff/" rel="bookmark">
			图解 CSS Grid 布局详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图解 CSS Grid 布局 Grid（网格）布局是最强大的 CSS 布局方案，用于构建二维布局。Grid 布局将页面划分成一个个网格，可以任意组合不同的网格，实现各种各样的布局。下面就来看看 CSS Grid 布局是如何使用的！
1. Grid 布局概述 在解释 CSS Grid 布局之前，我们先来看看 Grid 布局中一些重要概念。
（1）网格容器 网格容器是所有网格项的父元素，网格容器会定义display:grid。下面例子中，类名为 container 的 div 元素就是网格容器：
.container { display: grid; } &lt;div class="container"&gt; &lt;div class="item"&gt;1&lt;/div&gt; &lt;div class="item"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt; &lt;div class="item"&gt;4&lt;/div&gt; &lt;/div&gt; （2）网格项 网格项是网格容器的子元素，上面例子中类名为item的div元素就是网格项。
（3）网格线 构成网格结构的水平和垂直分隔线就是网格线，这些线位于列（列网格线）或行（行网格线）的任一侧。
下图中的网格有 9 个网格项，有 4 条行网格线和 4 条列网格线：
（4）网格轨道 两条相邻网格线之间的区域就是网格轨道。下图紫色区域就是网格轨道（红线圈起来的位置）：
（5）网格单元 两条相邻的列网格线和两条相邻的行网格线组成是的网格单元。它是网格的单个单元，也是最小单元。下图紫色区域就是一个单元网格：
（6）网格区域 网格区域就是网格上的一个矩形区域，由一个或多个网格单元组成。下图中紫色的区域就是网格区域：
2. 设置基本网格 要想创建 CSS 网格布局，首先需要定义网格容器。可以使用display: grid或者display: inline-grid指定一个容器为网格布局。这样网格容器的所有直接子元素都会隐式转换为网格项。
.container { display: grid; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27e86e1aa51d960b4843171e541bb2ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d51c406b014671f28f616a3eb8b06fdf/" rel="bookmark">
			vue用锚点跳转到当前页面的指定位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 结构区：
行为区：
methods: { goToAnchor(selector) { this.$el.querySelector(selector).scrollIntoView({ behavior: "smooth", // 平滑过渡 block: "center" //[可选] "start"，"center"，"end"或"nearest"。默认为"center"。 }) }, } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56c6d76d9e2189486a77da033a1e1d47/" rel="bookmark">
			vue中使用element-ui ，设置级联选择器高度问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、前言 我本来以为设置elemnt-ui组件样式需要用到深度选择器，然后找了好多关于深度选择器的，比如&gt;&gt;&gt; /deep/ ::v-deep
后来才明白是权重不够，解决方法如下
二、设置高度方法 1、在全局css中设置 .el-cascader-menu{ height: 400px; } 缺点：所有级联选择器的高度都是固定的
结论：只有在所有页面级联选择器都一致的情况下或者只有一个级联选择器情况下使用这种方法
2、在使用级联选择器的页面单独设置 &lt;style&gt; /* .el-cascader-menu__wrap { height: 400px!important; } */ /* .el-cascader-menu{ height: 400px!important; } */ .el-cascader-panel{ height: 400px!important; } &lt;/style&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39ebddb14304b3403fe5e44f6a6c34b3/" rel="bookmark">
			postgresql设置自动更新时间方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们日常开发中，在设计数据库字段的时候不可避免的都要created_time（创建时间）以及updated_time（修改时间）两个时间戳字段，作用大家也都一目了然。下面将为大家详细介绍两个字段的如何去设置来达到你想要的那个样子.我将用Navicat以及sql语句来大家详细介绍 一、created_time 首先是created_time，我们可以通过Navicat在添加字段时候将字段设置为timestamp类型，生成时间戳方式为CURRENT_TIMESTAMP或者设置为now()
至于SQL语句只需在建表过程default 一下就行这里不做赘述。
二、updated_time 接下来是updated_time，也就是我们本篇文章的重点，相信你已经找遍了度娘还没解决吧，没关系，我来帮你解决。
postgresql更新时间戳需要通过触发器来实现，至于有没有其他方式，我暂时还没找到。
1、首先需要通过代码创建函数，也就是定义触发器。
CREATE OR REPLACE FUNCTION "public"."cs_timestamp"() RETURNS "pg_catalog"."trigger" AS $BODY$ begin new.updated_time= current_timestamp; return new; end $BODY$ LANGUAGE plpgsql VOLATILE COST 100 cs_timestamp():为你定义函数的名称。
updated_time:为你表中更新时间戳字段名称（pgsql不可以大写的）。
其他的不用管执行就可以了。此过程只能通过sql实现.
2、接下来就是创建触发器了
create trigger cs_name before update on student for each row execute procedure cs_timestamp(); cs_name:触发器名称，可以随意设置，但是不要设置成中文的。
student:表名
cs_timestamp()：触发器所要用的函数名称，与第一步函数名称保持一致。
django开发我给它写到了迁移文件里面了：
此过程可以通过Navicat设置，我用的是Navicat15，大家仅供参考
结尾：当然函数可以在建好表后定义，也可以在建表前定义，这里无伤大雅。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/221ba7ec4a760cc0e3ea06858dab445d/" rel="bookmark">
			数组与数组对象对比id，生成新数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		let list = [{
id: 1,
name: 张三,
},
{
id: 2,
name: 李四,
},
{
id: 3,
name: 王五,
}]
let all = [1,2] let list = list.filter((item) =&gt;all.includes(item.id));
console.log(list)
//输出
[{id: 1,name: 张三,},{id: 2,name: 李四,}]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8199eb249c059dfa72d7c13e0726d692/" rel="bookmark">
			为什么要配置JDK的环境变量？和配置JDK环境变量的步骤个人总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1问： 为什么要配置JDK的环境变量？ 1. 编写好Java程序代码； 2. 使用Win+R键使用cmd命令进入DOS控制台； 3. 当使用javac编译工具时，并不能使用； 原因： 因为JDK中的javac.exe程序不在当前Java程序文件目录下，所以不能执行Hello.java。 但windows有一种运行机制：当前执行的程序在当前目录中如果不存在时，就会在系统中一个名为path的环境变量指定的目录中寻找，如果还没有，就会报以上图片中的错误。所以我们需要配置JDK的环境变量！ 放在path目的：将工具放在统一的路径下，在当前电脑的任何位置都可以直接使用工具！ 第2问： 配置JDK环境变量的步骤： 1. 右击桌面上的我的电脑点击属性； 2. 再点击高级系统设置； 3. 再点击环境变量； 4.此时环境变量页面 第一种：用户变量path设置 1. 在上方的用户变量界面中点击新建； 2. 在变量名输入JAVA_HOME ； 创建JAVA_HOME变量的目的：1.这是一种相对路径的写法，方便统一修改变量值，
2.引用方便
3.其它编辑器或其它环境也可以这样指定
在变量值中填入JDK的绝对路径； 3. 点path，然后点编辑； 4. 先点新建，输入%JAVA_HOME%\bin，并确定； （相当于进入JDK中的bin目录中，bin目录中的程序为JDK的开发工具） 5. 验证JDK环境变量是否配置成功。 在DOS控制台分别输入java -version，javac -version 查看JDK的版本，如图所示，配置成功！ 第二种：系统变量path设置 1. 先点击Path，再点击编辑； 2. 点击新建； 3.出现此界面； 4. 复制JDK中的bin目录的绝对路径； 5.输入JDK中的bin目录的绝对路径并点击确定； 6. 验证JDK环境变量是否配置成功。 在DOS控制台分别输入java -version，javac -version 查看JDK的版本，如图所示，配置成功！ 如有错误或侵权，望您联系我进行修改，谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdb70b33302a0eb6097a1ef199eb8a95/" rel="bookmark">
			python之numpy库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
numpy是什么？
ndarray对象
使用array创建数组
array参数
array与asarray的区别
ndarray数组的属性
ndarray.shape
ndarray.ndim
ndarray.size
ndarray.itemsize
ndarray.dtype
ndarray中使用便捷函数创建数组
使用arange创建等差数组(指定步长)
使用linspace创建等差数列（指定数量）
使用logspace创建等比数列
使用ones创建全是1的数组
使用ones_like创建形状相同的全是1的数组
使用zeros创建全是0的数组
使用zeros_like创建形状形同的全是0的数组
使用empty创建未初始化的数组
使用empty_like创建形状相同的未初始化的数组 使用full创建指定值的数组
使用full_like创建形状相同的指定值的数组
ndarray数组本身支持的大量操作和函数
reshape()方法
resize()方法
ndarray.T
flatten()方法
ravel()方法
flatten()与ravel()的区别
astype()方法
tobytes() 或 tostring()
np.unique(ar,return_index=False,return_inverse=False,return_counts=False)
数组中元素间的算术运算
数组间的算术运算
对数组按索引查询
基础索引
神奇索引
布尔索引
条件的组合索引
常用的random随机函数
seed(seed=None)
rand(d0, d1, ..., dn)
numpy是什么？ --- 一个开源的python科学计算库。
--- 使用numpy可以方便的使用数组、矩阵进行计算。
--- 包含线性代数、傅里叶变换、随机数生成等大量函数。
ndarray对象 --- ndarray（全称The N-dimensional array）是存储着相同类型和大小的元素的一维数组或多维数组对象，是numpy的核心数据结构。
--- 与Python的List的区别是，它元素必须是同一种数据类型，这也是Numpy高性能的一个原因。
使用array创建数组 array参数 名称描述object数组或嵌套的数列dtype数组元素的数据类型，可选copy对象是否需要复制，可选order创建数组的样式，C为行方向，F为列方向，A为任意方向subok默认返回一个与基类类型一致的数组ndmin指定生成数组的最小维度 --- 创建一维数组：
import numpy as np a = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdb70b33302a0eb6097a1ef199eb8a95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/057644d7400c3c863c139deb26e3547f/" rel="bookmark">
			如何在Ubuntu系统中使用Traefik为容器设置反向代理?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Traefik 是一种为 docker 容器建立反向代理的现代方法。当您希望在 docker 容器中运行多个应用程序，并公开端口 80 和 443 时，traefik 可能是反向代理的最佳选择。Traefik 提供了自己的监控仪表板。您还可以将 Traefik 用于 HTTP 负载均衡器。在本文中，我们将通过一个简单的示例在 Ubuntu 20.04 上安装 Traefik v2.4。
先决条件 Ubuntu 20.04 LTSDocker CE (Community Edition)Internet connection to download packagesSudo Privileged user accountA domain for traefik dashboard [Should be maintained A record]A domain for wordpress site [Should be maintained A record] 在本文中，我们使用的是 linuxtechi.local 作为域名，traefik.linuxtech .local 作为 Traefik dashboard 的 FQDN。
Ubuntu 20.04 上设置 Traefik 的步骤 在本文中，首先我们将设置 Traefik，然后将 Wodresspress 容器注册到 Traefik，以进行反向代理和负载平衡。我们将使用 Let’s Encrypt SSL 证书配置 Traefik，以通过 HTTPS 提供所有内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/057644d7400c3c863c139deb26e3547f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa736869f72db948fac3c6e78499fd4d/" rel="bookmark">
			【uni-app】创建底部或者顶部导航栏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、创建底部导航栏
2、自定义顶部导航栏组件
第一个图的代码 第二个图的代码
1、创建底部导航栏 （1）新建导航页面
在 pages 中新建tabBar目录，在目录下创建choose和me目录。然后在pages.json的pages中，生成新页面的默认配置代码。（不一定非要创建在一个目录下，可以独立成一个文件）
（2）配置底部导航栏结构
在 pages.json 中，配置 tabBar 注意：pages 的第一个 path 必须与 tabBar 的第一个 pagePath 相同否则不显示底部导航
"pages": [{ "path": "pages/tabBar/choose/index", "style": { "navigationBarTitleText": "行情", "navigationStyle": "custom", "navigationBarTextStyle": "white" } }, { "path": "pages/tabBar/me/index", "style": { "navigationBarTitleText": "量化平台", "navigationStyle": "custom", "navigationBarTextStyle": "white" } } ], "tabBar": { "color": "#d4dbe3", "selectedColor": "#000000", "borderStyle": "black", "backgroundColor": "#ffffff", "list": [{ "pagePath": "pages/tabBar/choose/index", "iconPath": "static/hqicon2.png", "selectedIconPath": "static/hqicon1.png", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa736869f72db948fac3c6e78499fd4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd21e135b1517611ba77329603059df8/" rel="bookmark">
			在JasperReport报表中支持中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用JasperReport默认不支持中文
如果需要支持中文，需要：
在项目文件中添加中文字体文件，并进行适当配置在报表模板中指定中文字体名称 以下分别说明。假设已经有一个能够正常显示英文报表的SpringBoot maven项目
在SpringBoot项目中添加字体文件和相关设置信息 jasperreports_extension.properties文件用于指定我们的字体信息文件在哪里。比如我这里是：
net.sf.jasperreports.extension.registry.factory.simple.font.families=net.sf.jasperreports.engine.fonts.SimpleFontExtensionsRegistryFactory net.sf.jasperreports.extension.simple.font.families.lobstertwo=fonts/fonts.xml 说明字体信息文件在 fonts/fonts.xml文件中
在 fonts/fonts.xml文件中指定有哪些字体文件，以及字体的名称。例如，我的项目中用到了“华文宋体”和“黑体”两种。
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;fontFamilies&gt; &lt;fontFamily name="华文宋体"&gt; &lt;normal&gt;fonts/STSONG.TTF&lt;/normal&gt; &lt;bold&gt;fonts/STSONG.TTF&lt;/bold&gt; &lt;italic&gt;fonts/STSONG.TTF&lt;/italic&gt; &lt;boldItalic&gt;fonts/STSONG.TTF&lt;/boldItalic&gt; &lt;pdfEncoding&gt;Identity-H&lt;/pdfEncoding&gt; &lt;pdfEmbedded&gt;true&lt;/pdfEmbedded&gt; &lt;exportFonts&gt; &lt;export key="net.sf.jasperreports.html"&gt;'华文宋体', Arial, Helvetica, sans-serif&lt;/export&gt; &lt;export key="net.sf.jasperreports.xhtml"&gt;'华文宋体', Arial, Helvetica, sans-serif&lt;/export&gt; &lt;/exportFonts&gt; &lt;/fontFamily&gt; &lt;fontFamily name="黑体"&gt; &lt;normal&gt;fonts/simhei.ttf&lt;/normal&gt; &lt;bold&gt;fonts/simhei.ttf&lt;/bold&gt; &lt;italic&gt;fonts/simhei.ttf&lt;/italic&gt; &lt;boldItalic&gt;fonts/simhei.ttf&lt;/boldItalic&gt; &lt;pdfEncoding&gt;Identity-H&lt;/pdfEncoding&gt; &lt;pdfEmbedded&gt;true&lt;/pdfEmbedded&gt; &lt;exportFonts&gt; &lt;export key="net.sf.jasperreports.html"&gt;'黑体', Arial, Helvetica, sans-serif&lt;/export&gt; &lt;export key="net.sf.jasperreports.xhtml"&gt;'黑体', Arial, Helvetica, sans-serif&lt;/export&gt; &lt;/exportFonts&gt; &lt;/fontFamily&gt; &lt;/fontFamilies&gt; 上述字体文件可以从Windows/Fonts文件夹复制而来
经过这样设置，我的项目就正常显示上述中文字体了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0d90732fdec35bb181a79df12729818/" rel="bookmark">
			PTA - 数据库合集41
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
10-208 在员工表中查询全体员工编号，姓名和年龄
10-209 在订单表中查询运费的最大值和最小值
10-210 在顾客表中查询公司城市在“济南”的顾客数目
10-211 在员工表中查询男女职工的平均年龄
10-208 在员工表中查询全体员工编号，姓名和年龄 分数 3
全屏浏览题目
切换布局
作者 刘冬霞
单位 山东理工大学
在员工表中查询全体员工的编号，姓名和年龄。
提示：年龄需要计算得到，假定当前系统年份是2021年，不要用计算年份的函数。
表结构: 员工（员工编号 文本型，姓名 文本型，性别 文本型，出生日期 日期型，入职日期 日期型，住址 文本型，电话 文本型）
表样例 员工表：
员工编号姓名性别出生日期入职日期电话011陈诚瑞男1988-7-112011-7-1415762338155023郭彩霞女1987-1-42010-7-1015762348111099王新英女1978-9-212000-7-3013864352920121范鼎毅男1995-4-12019-7-517864354679133钟鸣女1990-4-212016-7-618553346120 输出样例: 员工编号姓名年龄011陈诚瑞32023郭彩霞33099王新英42121范鼎毅25133钟鸣30 SELECT 员工编号,姓名,2021 - YEAR(出生日期) AS 年龄 FROM 员工 10-209 在订单表中查询运费的最大值和最小值 分数 3
全屏浏览题目
切换布局
作者 刘冬霞
单位 山东理工大学
在订单表中查询运费的最大值和最小值。
表结构: 订单（订单编号 文本型，顾客编号 文本型，员工编号 文本型,订单日期 日期型,运费 数字型）
表样例 订单表：
订单编号顾客编号员工编号订单日期运费10325J1010232018-10-75010326J1020112017-6-164210327Q1131212019-11-83110328Q1140992015-9-185610329B0101332014-1-124810330B0110232014-7-1164 输出样例: 最高运费最低运费6431 select max(运费) as 最高运费,min(运费) as 最低运费 from 订单; 10-210 在顾客表中查询公司城市在“济南”的顾客数目 分数 3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0d90732fdec35bb181a79df12729818/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f827d65f31233791d439e11ba67cb0d9/" rel="bookmark">
			@ConditionalOnProperty 和@Conditional注解作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring boot中的注解@ConditionalOnProperty Spring boot中的注解@ConditionalOnProperty，可以通过配置文件中的属性值来判定configuration是否被注入.
配置类:
@Configuration
@ConditionalOnProperty(prefix = “x.y”, name = “test”, havingValue = “1”, matchIfMissing = true)
public class XConfiguration {…}
配置文件：
x.y.test=1
解释：
prefix为配置文件中的前缀.
name为配置的名字.
havingValue是与配置的值对比值,当两个值相同返回true,配置类生效.
matchIfMissing属性为true时，配置文件中缺少对应的value或name的对应的属性值，也会注入成功.
使用场景：
1、在日常使用中，定义一个mq的消费，在本地测试环境、预发环境、线上环境均对此定义，满足不同阶段的开发、测试、上线需要。通常接入一个新的mq消费，三个环境使用同一套mq配置，可以保障开发联调效率和上线后保证和预发环境一致。但在一个mq主题中，一个应用只能消费一次，就意味着三个环境同时运行，只能有一个环境生效，则可以使用 @ConditionalOnProperty 注解，通过配置控制。
2、过滤器等随部署环境变动的类，使用该注解方便调试。
@ConditionalOnProperty( prefix = "zn.com.interceptor", name = "enable", havingValue = "true" ) 还可以用在链式配置中，比如Spring MVC的过滤器和拦截器。
3、通过@ConditionalOnProperty来控制Configuration是否生效
@Configuration //在application.properties配置"mf.assert"，对应的值为true @ConditionalOnProperty(prefix="mf",name = "assert", havingValue = "true") public class AssertConfig { @Autowired private HelloServiceProperties helloServiceProperties; @Bean public HelloService helloService(){ HelloService helloService = new HelloService(); helloService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f827d65f31233791d439e11ba67cb0d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afc78130920e24d5daf1dda420306cd2/" rel="bookmark">
			遗传算法（Genetic Algorithm，GA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一篇关于遗传算法的总结博客，包括算法思想，算法步骤，python实现的两个简单例子，算法进阶（持续更新ing）。
目录 1 算法思想2 算法步骤3 第一个简单的例子（python实现）4 二元函数例子（python实现）5 算法进阶 1 算法思想 遗传算法的应用很多，诸如寻路问题，8数码问题，囚犯困境，动作控制，找圆心问题（在一个不规则的多边形中，寻找一个包含在该多边形内的最大圆圈的圆心），TSP问题，生产调度问题，人工生命模拟等。
遗传算法起源于对生物系统所进行的计算机模拟研究，是一种随机全局搜索优化方法，它模拟了自然选择和遗传中发生的复制、交叉(crossover)和变异(mutation)等现象，从任一初始种群（Population）出发，通过随机选择、交叉和变异操作，产生一群更适合环境的个体，使群体进化到搜索空间中越来越好的区域，这样一代一代不断繁衍进化，最后收敛到一群最适应环境的个体（Individual），从而求得问题的优质解。
举个已经举烂的例子：
我们把要求的函数曲线想象成一个一个山峰和山谷组成的山脉。那么我们可以设想每一个可能解都是一只袋鼠，我们希望它们不断的向更高处跳去，直到跳到最高的山峰（尽管袋鼠本身不见得愿意那么做）。
遗传算法是这样做的：有一大群袋鼠，有的跳跃能力强，喜欢往高处，有的跳跃能力弱，喜欢在低处。有一天它们被莫名其妙的零散地扔到喜马拉雅山脉，在那里艰苦的生活繁衍下去。海拔低的地方弥漫着一种无色无味的毒气，海拔越高毒气越稀薄。可怜的袋鼠们并不知道毒气的存在，还是活蹦乱跳。于是，不断有不善跳跃的袋鼠死于海拔较低的地方，而在海拔越高的善于跳跃的袋鼠活得越久，也越有机会生儿育女，把善于跳跃的基因传给后代。就这样经过许多年繁衍生息，这些袋鼠们渐渐聚拢到了一个个的山峰上。最终，只有最高的珠穆朗玛峰上的袋鼠被带回了美丽的澳洲。
术语介绍：
染色体(Chromosome)：染色体又可称为基因型个体(individuals)，一定数量的个体组成了群体(population)，群体中个体的数量叫做群体大小（population size）。位串(Bit String)：其实就是遗传学中的染色体在计算机中的表示。基因(Gene)：基因是染色体中的元素，用于表示个体的特征。例如有一个二进制串（即染色体）S=1011，则其中的1，0，1，1这4个元素分别称为基因。特征值( Feature)：在用串表示整数时，基因的特征值与二进制数的权一致；例如在串 S=1011 中，基因位置3中的1，它的基因特征值为2；基因位置1中的1，它的基因特征值为8。适应度(Fitness)：各个个体对环境的适应程度叫做适应度(fitness)。为了体现染色体的适应能力，引入了对问题中的每一个染色体都能进行度量的函数，叫适应度函数。这个函数通常会被用来计算个体在群体中的优良等级。基因型(Genotype)：或称遗传型，是指基因组定义遗传特征和表现。对应于位串。表现型(Phenotype)：生物体的基因型在特定环境下的表现特征。对应于位串解码后的参数。 2 算法步骤 染色体编码，寻找一种对问题潜在解进行“数字化”编码的方案，建立表现型和基因型的映射关系。（建立袋鼠跳跃能力与基因的映射关系）初始化种群（刚开始袋鼠们被零散地扔到喜马拉雅山脉）用适应度函数对每一个个体进行适应度评估（袋鼠跳得越高毒气越稀薄，相当于适应度越大）用选择算子按照某种规定择优选择（低处的袋鼠很快被毒死，也就是被淘汰掉，以保证袋鼠总体数目持平）让个体基因变异，保持种群多样性。（让袋鼠随机地跳一跳，说不定就刚好跳到了珠穆朗玛峰附近呢）然后产生子代（希望存活下来的袋鼠是善于跳向高处的，并生儿育女，把善于跳跃的基因传给后代）达到迭代次数或最小误差，算法终止，否则转向步骤3. 3 第一个简单的例子（python实现） 跟着B站一位博主的学习视频敲下了我的第一个遗传算法
视频链接
题目：在一个长度为n的数组nums中选择10个元素，使得10个元素的和与原数组的所有元素之和的1/10无限接近。
比如n=50，sum（nums）=1000，选择的元素列表answer要满足sum（answer）-100的绝对值小于e，e要尽可能的小。
思路：
创建包含100个解的随机初始解集（用random.sample(list,number)从list中随机抽取number个元素）对解集中每两个解（父体与母体）进行选择交换，问题：如何选择这两个解？那就是选择优秀的交换，用轮盘赌选择法。
每个解都对应有一个误差和一个适应度，误差越小的解适应度越大（反比例函数）。
这里的适应度=1/误差。
归一化，将每个解的适应度除以所有解的适应度之和，归一化后得到选择概率。
叠加化 a1=a1,a2=a1+a2,a3=a1+a2+a3…,叠加之后每个解的选择概率从0-1依次增长，得到累积概率。
在0-1中随机选取一个浮点数（如0.4），从选择概率中挑出一个最接近的。选择一部分进行交叉重组。随机变异，保持种群多样性。 import random #1.创建初始解集 def create_answer(numbers_set,n): result=[]#存放解集的列表 for i in range(n):#循环n次，每次创建一个解集（包含10个元素） result.append(random.sample(numbers_set,10))#从初始数组中随机抽取10个元素 return result #2.选择两个解 #计算误差 def error_level(new_answer,numbers_set): error = []#存放适应度的列表 right_answer = sum(numbers_set)/10#正确答案，也就是原数组所有元素之和的1/10 for item in new_answer: value = abs(right_answer-sum(item))#误差等于每个解与正确答案之差的绝对值 if value==0:#误差最小是0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afc78130920e24d5daf1dda420306cd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3dde84d68d964324d34eeb86d861203/" rel="bookmark">
			模拟退火算法（Simulated Annealing，SA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一篇关于模拟退火算法的总结博客，包括算法思想，算法步骤，Python实现，MATLAB实现，算法进阶等。
目录 1 算法思想2 算法步骤3 SA解函数最小值（python实现）4 SA解旅行商问题（MATLAB实现）5 算法进阶 1 算法思想 SA是基于Monte-Carlo 迭代求解策略的一种随机寻优算法；出发点是基于物理中固体物质的退火过程与组合最优化问题（NP完全问题）之间的相似性。GA其实也是一种Greedy算法，但它比Greedy改进的地方就在于，它的搜索过程用到了Metropolis准则，也就是以一定的概率来接受一个比当前解要差的解，因此有可能会跳出局部最优解，找到全局最优解。Monte-Carlo 基本思想：利用大量采样的方法来求解一些难以直接计算得到的积分。例如，假想你有一袋豆子，把豆子均匀地朝一个形状超级不规则的图形上撒，然后数这个图形之中有多少颗豆子，这个豆子的数目就是图形的面积。当你的豆子越小，撒的越多的时候，结果就越精确。借助计算机程序可以生成大量均匀分布坐标点，然后统计出图形内的点数，通过它们占总点数的比例和坐标点生成范围的面积就可以求出图形面积。（这里我没有明白SA中具体哪里用到了Monte-Carlo思想）物理中固体物质的退火过程：
首先物体刚开始处于非晶体状态（左图）。我们将固体加温至充分高，固体内部粒子随温升变为无序状，能量增大，可以自由运动和重新排列（中图）。再让其缓慢冷却，粒子渐趋有序，在每个温度都达到平衡态，最后完全冷却时能量减为最小，物体形成晶体形态，这就是退火（右图）。 2 算法步骤 look这个函数，我们要求它的最小值。
模拟退火算法是这么做的：
设定初始温度 T 0 T_0 T0​，终止温度 T f T_f Tf​，降温速度 0 &lt; r a t e &lt; 1 0&lt;rate&lt;1 0&lt;rate&lt;1， T 0 T_0 T0​要取的很高，相当于加温到很高的温度。 T f T_f Tf​要取的很小，相当于基态， r a t e rate rate越大，降温越慢。取一个起始点x，算出函数值 f(x)。当 T 0 &gt; T f T_0&gt;T_f T0​&gt;Tf​时，随机让 x 移动，计算新的函数值 f(x+1)；根据Metropolis准则进行判断：
（1）如果新值 f(x + 1) &lt; 当前值f(x) ，以概率1把当前值更新为新值；这很好理解，如果你发现移动到的新点求出来的值更小，肯定要更新当前值；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3dde84d68d964324d34eeb86d861203/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02e9538b235fca3dcda90c1f6bef7903/" rel="bookmark">
			从零构建libbpf&#43;ebpf CO-RE程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 背景一、libbpf和BPF CO-RE二、确认配置依赖1.开启BTF特性2.依赖包 三、构建过程1.生成vmlinux2.编写minimal.bpf.c，代码如下3. 将minimal.bpf.c编译成minimal.bpf.o4. 将minimal.bpf.o转换为minimal.skel.h5. 编写用户程序minimal.c6.编译用户态程序minimal.o7.链接成为可执行程序minimal 背景 今年来bpf在内核发展迅速，从一开始的网络包过滤，发展到现在可用于trace，TC，权限控制等等，现在Facebook的工程师也将其引入到调度子系统，可见bpf发展迅速。通常我们可以使用BCC (BPF Compiler Collection)来快速的开发原型或者实验工具，通过BCC提供的一套框架，将程序部署之后，BCC首先会唤醒其嵌入的Clang/LLVM编译器提取本地内核头文件(必须确保已从正确的kernel-devel软件包中将其安装在系统上)，并即时进行编译。这种方式存在以下问题：
Clang/LLVM组合是一个很大的库，导致发布的应用的库会比较大；Clang/LLVM组合使用的资源比较多，因此当编译的BPF代码启动时会消耗大量资源，可能会推翻已均衡的生产负载；BPF程序的测试和开发迭代也相当痛苦，因为一旦重新编译并重启用户空间控制应用程序，甚至会在运行时遇到各种琐碎的编译错误。这无疑会增加难度，且无益于快速迭代。 一、libbpf和BPF CO-RE 为了解决以上提到的资源占用、兼容性等问题，社区提出了BPF CO-RE（Compile Once, Run Everywhere），通过用户空间的BPF加载器库(libbpf)，和编译器(Clang)。通过这些组件来支持编写可移植的BPF程序，使用相同的预编译的BPF程序来处理不同内核之间的差异。更加详细的信息可参考：https://facebookmicrosites.github.io/bpf/blog/2020/02/19/bpf-portability-and-co-re.html。
网上也有大量介绍该特性的文档，本文将会使用一个简单的示例，以命令行的方式构建使用libbpf的应用程序，方便理解相关工程的Makefile或者自己搭建环境。
二、确认配置依赖 本次实验使用内核版本为5.10版本：
[root@localhost ~]# uname -r 5.10.0+ 1.开启BTF特性 确认内核开启BTF特性，以下两个方式均可，如果没有打开，需要开启该选项并重新编译内核（如果编译过程中出现BTF的一个报错，尝试安装dwraves、libdwarves-devel包解决）。
# zcat /proc/config.gz | grep BTF CONFIG_DEBUG_INFO_BTF=y # file /sys/kernel/btf/vmlinux /sys/kernel/btf/vmlinux: data 2.依赖包 CO-RE构建方式需要安装bpftool、libbpf、libbpf-devel、elf-utils、kernel-source。
三、构建过程 1.生成vmlinux # bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h 2.编写minimal.bpf.c，代码如下 #include &lt;linux/bpf.h&gt; #include &lt;bpf/bpf_helpers.h&gt; // 需要包含的头文件 char LICENSE[] SEC("license") = "Dual BSD/GPL"; // SEC宏会将此字符串放到一个elf文件中的独立段里面供加载器检查 SEC("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02e9538b235fca3dcda90c1f6bef7903/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fde636c490b7450cc00b52394315a38/" rel="bookmark">
			FPGA学习笔记（二）——Modelsim仿真、testbench编写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的Modelsim-Altera是在安装Quartus13.0时下载的，里面会有选项，安装初学者版本就可以，在Quartus18.0里也可以使用。
一、设置Quartus和Modelsim的关联路径 这样就完成了关联设置，再次进行仿真就不会出现上篇文章出现的报错了。
sel为1的时候，out与a一致；sel为0的时候，out与b一致。 这只是简单的波形仿真，下面来学习更加强大的Modelsim仿真。 二、用Verilog编写测试脚本testbench 1.File——New
2.保存在testbench文件夹，命名时在被测模块名后面加tb
3.编写代码
4.编译通过
三、调用testbench、RTL功能仿真 1.打开设置
2.设置仿真脚本
3.点击New，调用testbench文件
名称保持一致
4.开始仿真
RTL是理想化功能仿真（不考虑逻辑延迟），GateLevel是门级仿真，可以仿真布局布线和延迟
先进行RTL功能仿真
Modelsim窗口 点击这里，使波形窗口独立出来，便于分析
想要放大或者缩小波形的话，点击这里
可见，s3=0时，Light1波形与s2一致； s3=1时，Light1波形与s1一致。
s1——a；s2——b；s3——sel；Light1——out。
这与本文第一章的波形仿真结果相同。实现了二选一多路选择器的功能。
四、Modelsim常用操作 1.添加模块内部信号
选择 Add Wave ，然后回到Modelsim
由于之前仿真时没有加载这部分波形，所以只能重新运行仿真
点击Restart——OK，再点击RUN-All
可以看到两组波形是完全相同的。
2.关闭路径
3.波形分组
Ctrl+鼠标左键 选中要分组的端口，右键，选择Group
结语 门级仿真部分在下一篇文章介绍，欢迎大家和我一起学习~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/980f02cd91a6ce042f7e5c2bcd3b6714/" rel="bookmark">
			LaTeX调整enumerate的间距
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 若需要调整enumitem的内容，首先需要引入enumitem宏包！！！ \usepackage{enumitem}
注：该宏包的文档：https://mirrors.concertpass.com/tex-archive/macros/latex/contrib/enumitem/enumitem.pdf
2. 根据自己的需求设置参数 不同间距的含义：
垂直间距
topsep 列表环境与上文之间的距离
parsep 条目里面段落之间的距离
itemsep 条目之间的距离
partopsep 条目与下面段落的距离水平间距
leftmargin 列表环境左边的空白长度
rightmargin 列表环境右边的空白长度
labelsep 标号与列表环境左侧的距离
itemindent 条目的缩进距离
labelwidth 标号的宽度
listparindent 条目下面段落的缩进距离 举例：
\begin{enumitem}[itemsep=2pt,topsep=0pt,parsep=0pt] \item item1 \item item2 \item item3 \end{enumitem} Reference [1] https://mirrors.concertpass.com/tex-archive/macros/latex/contrib/enumitem/enumitem.pdf[2] https://blog.csdn.net/robert_chen1988/article/details/83179571[3] https://cloud.tencent.com/developer/article/1827319 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f3958c3ff54ae3bda9e4e33ff4bac32/" rel="bookmark">
			按ctrl&#43;z把文件弄丢了怎么办？ctrl加z文件消失怎么恢复！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用电脑过程中，电脑快捷键给用户提供了很多便捷渠道，而善于应用电脑快捷键的用户，能够节省不少时间，从而达到更高的工作效率。但是凡事都可能存在利弊，享受好处的同时，相应也会带来一些隐患，比如最近有位用户因为按ctrl+z把文件弄丢了，回收站也找不回的那种！而对于有备份习惯的用户来说，可能并不担心文件丢失问题，但是如果在未备份的情况下丢失重要文件如何恢复呢？别着急，继续阅读下面的内容，或许有您想要的答案！
为什么按ctrl+z消失的文件不经过回收站
ctrl+z属于撤销快捷键，具体用途是撤销上一步的操作。比如您在电脑上新建了文件后无任何操作，直接按键盘上的ctrl+z，即撤销了刚刚新建文件的操作；同理可得，假如您进行了文件复制/剪切/移动的操作，然后按了Ctrl+z，相当于撤销了刚刚的复制/剪切/移动操作，所以按了ctrl+z快捷键消失的文件是不会经过回收站的，因为并没有执行任何删除操作，那么电脑按ctrl加z文件消失怎么恢复呢？下面一起来具体了解一下吧！
电脑按ctrl加z文件消失怎么恢复
▷方法一：使用ctrl+z相反快捷键恢复
ctrl+z相反快捷键是ctrl+y，ctrl+y的功能是恢复上一步操作和ctrl+z的功能刚好相反。想要恢复因按ctrl加z文件而消失的文件，在未进行任何操作的情况下，马上敲击键盘上的ctrl+y，即可恢复因撤销而丢失的文件。
▷方法二：借助专业数据恢复软件恢复
如果按ctrl+y都恢复不了那么可以尝试借助专业的数据恢复软件进行恢复。下面以云骑士数据恢复软件为例，它针对数据丢失的场景全，支持在XP/Win7/Win8/Win10/win11系统上恢复丢失的文件，没有花里胡哨的软件界面，一看就懂！
具体操作方法如下：
进入官网并下载最新版的云骑士数据恢复软件，安装好软件后在打开界面中点击相应的恢复模式，这里以场景模式中的“误删除文件”为例。
选择文件消失所在磁盘位置，可以是C盘、D盘、F盘等，如果不知道文件原来存储在哪个磁盘，可以逐一选择磁盘进行扫描，选择好以后点击“开始扫描”。
等待文件扫描完成以后，通过文件类型/大小或者直接在搜索框内输入文件名/扩展名寻找，当扫描结果不全面时，可以点击“深度扫描”（已找到所需文件可以忽略）。
找到所需文件后，在文件名左侧方框中打上“√”，执行右下角的“立即恢复”操作，将文件保存到其他安全的位置，切记不可将数据保存回源盘中，最后等待文件导出完成即可。
总结
通过上面的方法，电脑按ctrl加z消失的文件是否成功恢复了呢？如果在使用软件过程中有任何疑问、建议或是需要帮助，请随时联系在线客服。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1717fece79ac451cb124859e8444668b/" rel="bookmark">
			编译原理 --- 语法分析概念，自上而下分析面临的问题以及如何消除左递归问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一部分 --- 语法分析基本概念 1.上面这个箭头 --&gt; 符号表示的意思是P被 α 定义
A是一个非终止符，γ是一个和α，β属于同一个集合的元素
1.一个双箭头符号表示的是直接推出，而一个双箭头符号加上* 表示的是推导
1.合式的意思是形式上合法 2.语法分析器的任务就是根据语言的语法规则分析从词法分析器中得来的字符串是否是一个符合这个语法规则的句子（或者说是否是一个合式的程序）
1.在编译的前半阶段，语法分析器起着驱动的作用：
语法分析器调用词法分析器分析源程序获取一个单词，获取后进行语法分析，分析不下去时继续调用词法分析器分析源程序获取单词
1.所谓的归约其实就是推导的逆过程，假定有产生式 L--&gt;β，采用自下而上法时我们在字符串中识别到了β的化就将它规约为在产生式中被它定义的L
第二部分 --- 自上而下分析面临的问题 1.自上而下分析的匹配示例：给定一个字x * y，这个字中有三个字符
首先语法分析器调用词法分析器识别一个字符x（从左往右识别句子中的单词），然后我们从开始符号开始对这个词进行语法匹配
2.首先x与开始符号（非终结符）S不匹配，此时看非终结符S有没有产生式，有的话将产生式左边用来定义S的xAy中的每一个符号作为S的一个子结点并且按照从左往右的顺序生成树，没有的话就匹配失败
3.继续将识别到的x按照从左往右的顺序与子结点进行匹配判断，如果匹配的上的话调用词法分析器获取下一个字符继续进行匹配，匹配不上的话就继续重复第2步
4.有时候一个非终结符的产生式的右边可能具有多个候选式，此时如果我们的识别到的字符与这个非终结符某一个候选式展开后的子结点都不匹配的话，我们并不能直接结束判断，我们需要回溯到判断选取那一个候选式进行展开的时候，并在这个时候选取另一个候选式，然后继续展开和判断。就这样不停的判断回溯，直到所有的候选式都展开并判断过一次或者判断成功为止。
1.这种回溯问题会导致编译器在进行语法分析时不得不执行很多额外的步骤
1.左递归：一个非终结符P能够推出包含自己的句型，且自己在句型的最左边的话，我们就称这个非终结符P是左递归的
1.如果出现了左递归的情况的话，根据我们上面的分析不难得到当字符与P不匹配时，语法树会无限生长，而字符不会更新的死循环情况
第三部分 --- 消除左递归问题的方法 接下来我们将学习如何构造不带回溯的，也不会陷入死循环的自上而下分析算法
1.如果是左递归的话，不管我们获取到的是不是符合语法的字符，都会先和非终极符P进行判断，然后不相等，然后展开并不断重复，这就会陷入死循环
2.但是如果是右递归的话，我们执行的顺序是先判断字符是否匹配，如果匹配则获取新字符并继续往后判断进入递归重复第2步，如果不匹配的话直接匹配失败出现回溯 --- 这样即避免了左递归死循环问题的出现，也完成了字符的语法识别。
（注意在匹配的过程中如果匹配不成功且进行匹配的是终结符话就会直接导致当前匹配失败并出现回溯问题）
1.我们前面消除的都是直接左递归，即在可以直接从非终结式的产生式的右边看到非终结式本身在候选式的最左边，但是有时候还存在间接左递归的情况，比如下面这个：
在经过一系列产生式转换后我们可以发现S具有左递归性质
相比于直接从候选式的最左边看到自己，这个需要我们在经过一系列产生式转换之后才能够看到
接下来介绍一个既能够消除直接左递归也能够消除间接左递归的算法：
1.使用这个算法前需要满足上面这两个条件
2.所谓的形成回路其实就是指从一个非终结符开始经过一系列推导后又推回了这个非终结符自身，这种就是回路情况
第二个蓝框是将R的产生式中的候选式直接代入到Q中得到的，第三个则是将第二个蓝框中的Q的产生式代入到S中得到的
做完这两步处理之后我们就将产生式中的间接左递归情况转换为了直接左递归情况，此时我们只需要用我们前面处理直接左递归的方法进一步转换为直接右递归就能够解决问题了
1.通过 i 循环选择一个非终结符Pi
2.通过 j 循环将Pi的产生式右边的候选式中下标小于 i 的非终结符P处理掉，处理完之后Pi的产生式就被改造为了红框中那种形式，此时结束 j 循环
3.结束 j 循环来到 i 循环之后我们在对Pi改造后的候选式进行左递归消除
1.将所有的非终结符进行排序 --- 上面选择的序列是R，Q，S
2.从第一个终结符A开始检视其产生式的候选式中有没有在它前面的非终结符（根据第一步排的序来判断非终结符之间的前后关系） --- 只看非终结符，对于终结符不进行处理
3.如果没有则这个非终结符A处理完毕，接着判断这个非终结符的产生式中是否出现左递归情况，如果出现的话消除左递归，消除左递归之后视这个非终结符A为开始符号，将从这个开始符号出发，将不会使用到的产生式都删除掉，结束之后开始处理所排的序中的下一个非终结符
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1717fece79ac451cb124859e8444668b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b7db88c110b596aecc10a88e912f02b/" rel="bookmark">
			js执行机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js的线程问题 首先需要明确 JS 是单线程的，这是 Javascript 语言的一大特点。单线程即同一时间程序只能处理一件事。这是因为 javascript 这门脚本语言诞生的使命所致——javascript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对某个 DOM 元素进行添加和删除的操作不能同时进行。单线程就意味着所有的任务需要排队，前一个任务结束后才能执行下一个任务。这样出现的问题是：如果 JS 执行时间过长会导致页面渲染不连贯，导致页面加载阻塞的感觉。
抛出问题 以下三个案例的结果是什么？
function test() { console.log(3); } // 第一段代码 // console.log(1); // setTimeout(test, 1000); // console.log(2); // 第二段代码 // console.log(1); // setTimeout(test, 0); // console.log(2); // 第三段代码 console.log(1); document.onclick = function() { console.log('click'); } console.log(2); setTimeout(test, 3000) 同步和异步 为解决上述线程问题，利用多核 CPU 的计算能力，H5 提出了 Web Worker 标准，允许 javascript 脚本创建多个线程。于是，JS 中出现了同步和异步。
同步：前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。
异步：你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。
js中的同步任务和异步任务 同步任务 JS 中的同步任务是指在主线程上排队执行的任务，只有上一个任务执行完毕才能继续执行下一个任务。这些在主线程上执行的任务形成一个执行栈。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b7db88c110b596aecc10a88e912f02b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dda60d6b385a56659a7b95d61e43a6bd/" rel="bookmark">
			VSCode配置Lua环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇是用于学习热更Lua语言的环境配置参考文章
1. Lua下载
首先进入Lua下载页面，页面链接：Lua官方下载链接，如图所示
​
根据对应的操作系统选择点击即可下载，本人下载的是lua-5.4.2_Win64_bin.zip版本
下载完成后，创建一个文件夹命名为Lua，把下载的包拖进Lua文件夹进行解压，如图：
​
这里会解压出来lua54.exe，而不是lua.exe，要注意一下
2. Lua添加环境变量
对环境变量的理解可以移步：什么是环境变量
按Win键搜索环境变量，如图
​
打开环境变量
​
双击系统变量中的Path
新建添加路径，把我们刚才创建的Lua文件的路径填写上去，如图
此时环境变量就已经添加好了，狂点确定就行了
3. Vscode下载和基本配置
进入VSCode下载页面：VSCode官方下载链接
根据不同的操作系统选择不同下载
基本配置和插件下载：分别为简体中文，CodeRunner，LuaDebug三个即可
在齿轮里边打开设置并在搜索栏搜索executorMap
点击在settings.json中编辑，会跳转到页面
将lua后边的路径更改为刚刚解压过的lua54.exe路径，路径查找方式为：右键-&gt;属性
并在D:\DevTools\Lua后添加lua54.exe文件名，由于VSCode中会有转义字符，需要把D:\DevTools\Lua\lua54.exe变为双斜杠D:\\DevTools\\Lua\\lua54.exe
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a807210c6cfe569d08b085525cf154d1/" rel="bookmark">
			IDEA中打jar包和war包以及jar包和war包的区别及理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先我们先理解一下什么是jar包和war包！
jar包：jar是类的归档文件！ JAR（Java Archive，Java 归档文件）是与平台无关的文件格式，它允许将许多文件组合成一个压缩文件，为 J2EE 应用程序创建的jar文件是 EAR 文件（企业 jar文件），jar文件格式以流行的 ZIP 文件格式为基础。与 ZIP 文件不同的是，jar文件不仅用于压缩和发布，而且还用于部署和封装库、组件和插件程序，并可被像编译器和 JVM 这样的工具直接使用。在 jar中包含特殊的文件，如 manifests 和部署描述符，用来指示工具如何处理特定的 jar。
通常是开发时要引用通用类，打成jar包便于存放管理，当你使用某些功能时就需要这些jar包的支持，需要导入jar包。
jar包就是java的类进行编译生成的class文件打包的压缩包，包里面就是一些class文件。当我们自己使用Maven写一些java程序，进行打包生成jar包。同时在可以在其他的工程下使用，但是我们在这个工程依赖的jar包，在其他工程使用该JAR包也要导入。最常接触的就是你Maven引入的东西！
war包：war包是一个Web应用程序！ 一个web程序进行打包便于部署的压缩包，里面包含我们web程序需要的一些东西，其中包括web.xml的配置文件，前端的页面文件，以及依赖的jar。便于我们部署工程，直接放到tomcat的webapps目录下，直接启动tomcat即可。同时，可以使用WinRAR查看war包，直接将后缀.war改成.rar。
jar包和war包区别 jar是java普通项目打包，通常是开发时要引用通用类，打成jar包便于存放管理。当你使用某些功能时就需要这些jar包的支持，需要导入jar包。
war是java web项目打包，web网站完成后，打成war包部署到服务器，目的是为了节省资源，提供效率。
jar文件（扩展名为. Jar，Java Application Archive）包含Java类的普通库、资源（resources）、辅助文件（auxiliary files）等。通常是开发时要引用的通用类，打成包便于存放管理。简单来说，jar包就是别人已经写好的一些类，然后对这些类进行打包。可以将这些jar包引入到你的项目中，可以直接使用这些jar包中的类和属性，这些jar包一般放在lib目录下。
war文件（扩展名为.War,Web Application Archive）包含全部Web应用程序。在这种情形下，一个Web应用程序被定义为单独的一组文件、类和资源，用户可以对jar文件进行封装，并把它作为小型服务程序（servlet）来访问。 war包是一个可以直接运行的web模块，通常用于网站，打成包部署到容器中。以Tomcat来说，将war包放置在其\webapps\目录下,然后启动Tomcat，这个包就会自动解压，就相当于发布了。war包是Sun提出的一种web应用程序格式，与jar类似，是很多文件的压缩包。war包中的文件按照一定目录结构来组织。根据其根目录下包含有html和jsp文件，或者包含有这两种文件的目录，另外还有WEB-INF目录。通常在WEB-INF目录下含有一个web.xml文件和一个classes目录，web.xml是这个应用的配置文件，而classes目录下则包含编译好的servlet类和jsp，或者servlet所依赖的其他类（如JavaBean）。通常这些所依赖的类也可以打包成jar包放在WEB-INF下的lib目录下。
SpringBoot项目既可以打成war包发布，也可以找成jar包发布。 jar包：直接通过内置Tomcat运行，不需要额外安装Tomcat。如需修改内置Tomcat的配置，只需要在SpringBoot的配置文件中配置。内置Tomcat没有自己的日志输出，全靠jar包应用输出日志。但是比较方便，快速，比较简单。
war包：传统的应用交付方式，需要安装Tomcat，然后放到wabapps目录下运行war包，可以灵活选择Tomcat版本，可以直接修改Tomcat的配置，有自己的Tomcat日志输出，可以灵活配置安全策略,相对打成jar包来说没那么快速方便。
=========================================================================
OK，到这里我们就大致了解了什么是Jar包什么是War包了，下面我们就看看IDEA中的打包步骤！
=========================================================================
1：IDEA打Jar包的步骤 方法一：不使用Maven直接打Jar包。 1.File --&gt;Project Structure --&gt;Artifacts --&gt; Jar --&gt; From module with dependencies.
点击ok以后我们在返回上一步Project Structuer中发现IDEA中默认已经将我们的jar包输出目录填上了，这时我们可以更改一下上述的jar包输出目录，这样也更加方便的管理，此时我们更改号路径以后在点下右下角的Apply就可以了。
2.Build --&gt; Build Artifacts
选择上述的Build Artifacts后会自动弹出来下面的Build
3.这时我们去刚才相应的jar包输出目录发现已经有了对应的包
4.运行：可以使用如下两种方法来运行jar包
java -classpath xxx.jar xxx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a807210c6cfe569d08b085525cf154d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1de378b7e0134a401e12f46c0c8d8c80/" rel="bookmark">
			centos7下安装arcgis server10.4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、linux环境与安装包准备。 linux ： centos7
arcgis server 10.4 安装包与破解文件下载：
安装包地址：链接：https://pan.baidu.com/s/1USZCxcUelhLjZ1J_y5PZXA
提取码：hg2r
之前使用centos8与arcgis server 10.3 安装失败，操作系统与安装包版本之间应该有对应版本关系。
二、linux安装所需的依赖包 yum -y install fontconfig mesa-libGL mesa-libGLU libXtst libXext \ libX11 libXi libXdmcp libXrender libXau xorg-x11-server-Xvfb \ libXfont vim 三、修改hosts文件 这里hosts文件需要一定的格式，不然创建站点可能会报错。
vim /etc/hosts 进入文件后，输入“i” 进入编辑模式，然后再最后一行添加本机IP和机器名+域名 机器名。然后按下Esc，输入“wq”保存并退出。(如图所示)
四、修改防火墙设置 开放相应的端口，不然的话，安装完之后，不能访问。
firewall-cmd --zone=public --add-port=6080/tcp --permanent firewall-cmd --zone=public --add-port=6443/tcp --permanent firewall-cmd --zone=public --add-port=4000/tcp --permanent firewall-cmd --zone=public --add-port=4001/tcp --permanent firewall-cmd --zone=public --add-port=4002/tcp --permanent firewall-cmd --zone=public --add-port=4003/tcp --permanent systemctl restart firewalld //重启防火墙 6080与6443端口是必须的，其他的4000~4003为备用端口，这个备用端口有啥用，目前还没搞清楚。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1de378b7e0134a401e12f46c0c8d8c80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb62580eb3fd243999b537149f5c35ca/" rel="bookmark">
			PIC仿真器接口定义及连接注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口定义 PickIt3使用手册：https://ww1.microchip.com/downloads/en/DeviceDoc/PICkit_3_User_Guide_51795A.pdf
问题一、能读到ID，但是不能下载。
原因：电脑的USB口有大电流设备，造成下载器电压不稳定。如接了副屏显示器、360WiFi、手机充电等。先拔除USB口的其他设备。
1、成功读取到ID，提示 PK3Err0037: Timed out waiting for response from PICkit 3 Programming failed
2、成功读取到ID，提示 Programming... Programming failed
问题二 Debug模式下可以Program成功，却不能仿真
PK3Err0040: The target device is not ready for debugging. Please check your configuration bit settings and program the device before proceeding.
原因：调式一些20引脚以下的单片机，需要加调试头，不然只能烧写而不能仿真。调试头是一个专门用来进行仿真的特殊的单片机。解决方法：需要购买对应的仿真头，或者将代码改一下，下载到20PIN以上的IC进行仿真。
其他常见小问题及解决方法
提示找不到目标IC： 检查烧录线是否正确；检查IC的供电电源是否正常，可选择外部或内部供电。提示ID错误：检查芯片的config配置位是否正确，按正确的配置先烧录程序，再连仿真器调试： 复位脚要设置成复位口，不能是普通IO口；调试标志位须打开。连接成功，但是不能烧录(或者提示：Failed to get Device Id)： 检查电脑USB口连接的设备，串口模块（PL2303）连接时，烧录时会失败。仿真单步执行时，PC指针乱跳： 重新Program程序，再仿真。 5、路径不能有中文。
正确的Debug步骤：
1、连接好ICE后，点击“Debugger-Program”，下载程序。如果弹出警告，须按警告提示处理相应的标志位。
2、MCLR 引脚设置为复位功能；
3、在线调试器模式位打开；
4、闪存程序存储器自写使能位关闭，不然不能进入Debug。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32c90fb6164a43a5384732a677357694/" rel="bookmark">
			Linux上配iptables开放指定端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 编辑配置文件
通过vi或vim命令进行编辑iptables
vi /etc/sysconfig/iptables 如果要开放80端口则添加如下一行配置：
-I INPUT -p tcp --dport 80 -j ACCEPT 重启 iptables 使配置生效
service iptables restart 查看开放端口
/sbin/iptables -L -n 如果没有iptables文件就需要安装一下
yum install -y iptables yum install iptables-services 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5d3a0d1834c934eb9e860177d9a5c35/" rel="bookmark">
			通俗易懂的搞明白什么是IP地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看本机IP：
通过百度查看IP：
但我们能够发现一个问题，为啥百度出来的IP地址和我们自己本机查看的不一样呢？
本机为：
172.20.10.4
百度的结果为
112.97.61.59
这就要说一下公有IP地址和私有IP地址了
1、公有IP地址与私有IP地址 首先我们前面知道，IP地址是由32位二进制组成，那么就会有2的32次方的地址总数可使用，也就是4 294 967 296个。但是有一部分的地址是有其他用途的（以后会讲到），所以能用的打了折。
我们可以简单想下假设全球76亿人口，每个人都有一部手机上网连接，前面我们提到，设备要联网必须遵循IP协议规则，就需要有IP地址，那么每部手机都会有一个独一无二的IP地址，你会发现IP地址的数量根本不够用啊，更别说还有电脑等终端设备没算进去。所以要想想办法怎么才能保证地球上的每一台终端设备连入互联网。
如果一层楼，或者一栋楼，一个区域共享一个IP地址，这样是不是就能大大的缓解数量上的问题。但如果一个区域的人都使用同一个IP地址，那么怎么知道具体是谁向互联网发出信息，互联网怎么知道要把信息发送给这个区域里具体的哪个人。比如你的快递收货地址只填写广东省深圳市福田区，快递小哥怎么给你送，快递都给你扬咯。
所以，拥有这个IP地址的区域可以私自搞个内部管理，比如深圳市光明小区拥有一个IP，然后可以给小区内的每户人家分配一个私有的IP，这个IP就像每户人家的具体地址一样，比如“A幢7楼701房”。然后隔壁一个拥有IP地址的黑暗小区也给每户人家分配一个私有IP，也会有“A幢7楼701房”的地址。
小区的人快递收货地址就可以写上
“广东省深圳市福田区XX街道光明小区 A幢7楼701房”
快递小哥就会把快递送往光明小区，小区的快递站有贴心服务根据“A幢7楼701房”把快递送到你手上。小区的地址就相当于公有的IP，具有发送和接收快递具体地址的标识，而“A幢7楼701房”就相当于私有的IP，小区对你负责，你的快递发送和接收都要靠小区的地址。
所以，百度上搜到的IP地址是你的公有IP，而你在设备上查到的就是私有IP。那么一个收发地址大概就可以意会成
广东省深圳市福田区XX街道光明小区 A幢7楼701房
112.97.61.59 172.20.10.4
是不是就一下子明白了哈，公有IP是唯一的，但私有IP就可以不唯一，比如你也许和隔壁小区的朋友拥有一个一样的私有IP，例如“192.168.1.4”。
懂了什么是公有IP和私有IP，可以知道能连上网的只有公有IP，私有是不行的，必须借助上面的公有IP。
2、IP地址的分类 在了解IP地址的分类之前，我们需要先知道一个网络请求是怎么传达到目的地的，方便我们对IP地址的分类有更好的理解。
网络路由传输流程简化版
还是寄收快递的例子，这次，我们寄出的收货地址是同城不同区的。
寄：“广东省深圳市福田区XX街道光明小区 A幢7楼701房”
收：“广东省深圳市南山区XX街道奥特曼小区 A幢2楼201房”
当我们从光明小区快递站寄出快递后，一路先到达福田区的快递分站，快递分站查了查福田区的可送达地址列表，发现没有对应的地址，然后再向上面的深圳市快递总站发送快递。深圳市总站收到快递后也查了查深圳市可送达的地址列表，芜湖，发现居然就在下面的南山区，往下面的南山区快递分站发送快递，分站收到后再根据可送达地址列表以此类推的往下发送快递，最终送到收货人的手上。
在这个快递发送和接收的过程，就是一个非常简化的网络信息传输流程。其中快递分站和总站就代表着有层级关系的路由器，而每个站对应的“可送达地址列表”就是路由表。也就是说一个路由器中的路由表会存放下面路由器的公有IP地址，信息的传输过程就是向上层路由发送，上层路由通过找表的形式来看看目标IP地址是否在自己的下层，不在的话再向上层路由发送，每个路由器都有一个公有IP地址。
IP地址过去的分类
在很久之前，人们想到，如果路由器中的路由表存放的是全球所有IP的地址，那每次信息经过路由器的时候有多难找表啊，效率太低下，搭建互联网的成本也增高。不如把所有的IP地址做分类，就像把一个国家分成很多个省市区一样，每个快递站对应管理它下面的可送达地址即可。于是，IP地址的分类就出来了。
我们可以看到一个IP地址被分为网络号和主机号，然后又根据网络号的占位数来区分A-C类，为啥要这样分？拿A类地址举例。
一个A类地址，前8位是网络号，后26位为主机号。网络号还规定第一位必定是0，也就是网络号的范围为：
0000 0000-0111 1111 转成十进制为 0-127
但因为00000000和后面的主机号组成的是网络地址，01111111和后面的主机号组成的是广播地址，所以除去这两个一头一尾，网络号的范围就为 1-126 。（ps：1是给网关的比如路由器）
也就是A类的IP会长这样：1-126.xxx.xxx.xxx，然后每个网络号下的主机号有16,000,000个组合。例如126.12.3.1这个地址，被分类成了全球IP地址下的A类下的126网络号下的主机号为12.3.1的IP地址。B，C类同理。
在图表中我们可以看到，A类第一位被强制为0，B类前两位被强制为10，C类被强制为110，博主个人认为这样的强制是能让人快速的知道一个IP地址属于哪类。你看，由于被强制，所以每一类的地址前八位被划分了范围：
A类：1-126
B类：128-191
C类：192-233
…
所以，我们只需要通过IP地址的第一组数值就能快速的判断是属于哪一类，然后就可以知道前多少位是网络号，后多少位是主机号。
IP地址有了分类以后，路由器的路由表就可以做的很小了。
过去分类带来的问题
通过A-C类分的网络号和主机号的占比我们可以知道，A类的网络号很少，但主机号巨多，适合给超级大型公司或者超大政府等机构，因为数量少，但是内部设备很多。给一个完整的A类IP地址，一个机构就能有16,000,000个IP地址，其实很浪费，因为用不完。
B类就给一些较大公司政府之类的，自然数量会比需要A类的机构多，网络号能提供16,384个，每个网络号下的主机号也有65,534多个，也挺浪费的。
C类就是给数量最多的小体量组织或机构等使用啦。
这个把IP地址分成A-E类划分网络号和主机号的规则是在过去的时候，人们认为未来的终端设备不会超过IP总数量的背景下诞生的，如今我们也马后炮的知道这样的想法too young, sometimes naive! 本身分为A-E类没什么问题，但网络号和主机号的划分显然不符合当代的需求。
既然原来的划分方式既浪费又不够用，那就采用新的划分方式吧，于是后来就有了子网掩码这个东西。
下期讲解子网掩码~
————————————————
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5d3a0d1834c934eb9e860177d9a5c35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b0449ad9a70b56e360441545a8b9ec8/" rel="bookmark">
			一些tcl的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.变量的头部定义​
set CLK 4​​
set clk_H [expr 0.5*$CLK]​
2.设断点停下来做事情​
stop -create -condition {#%x TB.cpm.fsm == 'h2 &amp;&amp; #%xTB.reset ==1}​
run​
stop -delete *​
run $clk_H​
3.force语句格式​
force TB.a.b..c.status 1​
4.task调用（verilog写）。调用后的run时间是系统去做事情去了。必须要留一部分时间去供系统调度使用。​
task -schedule TASK​
deposit TASK.a 4'b0001​
deposit TASK.b 18​
run 5000ns​
5.循环的写法​,最后得到的是16位的DATA。
set DATA [value %x TB.OUT_H]​
for{set i 0}{$i &lt; 15}{incr i}{​
run 100ns​
set DATA2 [value %x TB.OUT_H]​
set DATA [expr($DATA&lt;&lt;1)+$DATA2]
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99edefd8aa073b55efe22b2027db4485/" rel="bookmark">
			SpringBoot统一返回处理遇到cannot be cast to java.lang.String问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后端接口返回个前端的格式为：{"result":null,"status":1010}
以前接口有一个return ner ResultBody.success()的操作，后期利用@RestControllerAdvice统一处理后，就不用每一个方法都要写一个返回ResultBody.success()了
但是当返回值是一个String时，会报错ResultBody cannot be cast to java.lang.String
原因是返回值是String，Spring会使用StringHttpMessageConverter来处理返回体，但是我们定义的统一返回处理类将返回值String，变成了Result.success(（String）)，是一个对象。导致类型转换失败了。具体的代码是：
父类AbstractHttpMessageConverter write时，会调子类StringHttpMessageConverter的addDefaultHeaders方法，注意父类处理的是一个泛型
而子类StringHttpMessageConverter接收的是String。就会报错了（此时，接收的是Result，是一个对象）。
原因就是原来返回值是一个String，统一处理后变为了一个对象Result。导致类型转换失败了。
解决方案有多种，这里使用fastjson序列化来处理
/** * 项目中的一些bean配置 */ @Component public class ProjectConfig { @Bean public HttpMessageConverters cusHttpMessageConverter(){ return new HttpMessageConverters(new FastJsonHttpMessageConverter()); } } 注意要引入fastjson的依赖
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4e228025f752429bc56960d5d51c8e6/" rel="bookmark">
			fiddler抓pycharm请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、fiddler抓包pycharm失败
原来的代码：
r = requests.post(url, data)
此时发送的请求fiddler抓取不了数据
修改为：
fiddler_proxies = {'http': 'http://127.0.0.1:8080', 'https': 'http://127.0.0.1:8080'} # 避免fiddler抓不到请求数据而设置的 或者fiddler_proxies = {'http': 'http://127.0.0.1:8888', 'https': 'http://127.0.0.1:8888'}
r = requests.post(url, data, proxies=fiddler_proxies, verify=False) # verify和proxies均是为了可以正常使用fiddler抓而设
再次尝试，可以正常抓包，但是有警告：InsecureRequestWarning: Unverified HTTPS request is being made to host '127.0.0.1'. Adding certificate verification is strongly advised. See
2、解决警告：InsecureRequestWarning: Unverified HTTPS request is being made to host '127.0.0.1'. Adding certificate verification is strongly advised. See
在发送请求前，添加代码，如下：
fiddler_proxies = {'http': 'http://127.0.0.1:8080', 'https': 'http://127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4e228025f752429bc56960d5d51c8e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0dc1ba0c0d1f2e4adef6952226c4362/" rel="bookmark">
			学习solid works第三课------转换实体引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 注：使用版本为2022版
转换实体引用-举例说明 一、普通方法拉伸 1、如下图画一个缺了一个角的正方形。 2、点击特征，拉伸凸台/基体，深度选择50。 3、点击其中一个面-草图-绘制草图-画一个矩形跟这个面重合-拉伸凸台50，即得到下面的立体图。 二、转换实体引用 1、跟之前步骤一样，点击其中一个面-绘制草图-转换实体引用（会自动生成一个所选面的轮廓线）-拉伸凸台50，这样同样可以得到一个跟上面一样的立体图。 三、转换实体引用例2 1、选择另外一个长的面-草图-绘制草图，如下图 2、按住鼠标中键选择视角，选择这个面对面的一个面-转换实体引用，就会在绘制草图的面上得到一个转换过来的面，如下图3中就是生成的框。 3、拉伸凸台，得到下面的立体图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4453408d0e3b1d193eda36d758f5a279/" rel="bookmark">
			oracle报错:SQL命令行未正确结束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.常见的错误就是说，标点符号忘记拼接导致出错
2.大致可以检查SQL是否有语法错误，基本就这几点
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb3cb0999a710e0f9b2eb41d6d21618b/" rel="bookmark">
			GO语言中三种方式创建切片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 GO中三种方式创建切片 第一种方式：var 切片名 []数据类型
var s1[]string fmt.Println(s1) fmt.Println(len(s1)) 第二种方式：切片名 := []类型{}
s2 := []int{} fmt.Println(s2) fmt.Println(len(s2)) 第三种方式：使用make()函数创建:make(切片类型，长度，容量)
s3 := make([]int, 3, 5) fmt.Println(s3) fmt.Println(len(s3)) fmt.Println(cap(s3)) 使用make()函数创建注意事项：
1.make(切片类型，长度，容量)
2.长度是已经初始化的空间。容量是已经开辟的空间，包括已经初始化的空间和空闲的空间
3.切片长度要小于容量
4.len()返回长度，cap()返回容量
5.函数中的容量参数是可以省略的，这是容量与长度相等
s4 := make([]int, 6) fmt.Println(s4) fmt.Println(len(s4)) fmt.Println(cap(s4)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14d2f9d079f58d8a8786a2d459194c30/" rel="bookmark">
			Unity 关卡跳转——开始界面切换到游戏场景的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在已有关卡的基础上，另外新建一个关卡，将其命名为start并进行保存。
2.在新建立的start关卡中创建TitleScreen.cs脚本，代码如下。
using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.SceneManagement; public class TitleScreen : MonoBehaviour { //响应游戏开始事按钮件 public void OnButtonGameStart() { SceneManager.LoadScene("level1"); //读取关卡level1 } } （值得注意的是，这里不要忘记使用unity引擎提供的SceneManagement类，即在脚本顶部添加 using UnityEngine.SceneManagement;）
3.将TitleScreen.cs脚本挂载到相机上面。
4.创建UI Canvas，然后选择[UI]-&gt;[Image]创建图像UI，这里命名为Image_background。在Source Image中指定一张贴图作为背景（默认的.png格式是Texture类型，不能直接使用到UI上），我们这里先将示例图片转为sprite类型。
5.添加标题文字，最后创建一个按钮[UI]-&gt;[Button]，并修改文本内容为“游戏开始”。
6.选择Button_gamestart,然后单击On Click（）下面的“+”按钮，指定摄像机为消息接收对象，选择TitileScreen的OnButtonGameStart函数作为响应按钮单击事件的回调函数。 7.在编辑器菜单栏中选择[File]-&gt;[Build Settings],添加关卡。
运行游戏，现在可以通过单击“开始游戏”按钮跳转到“level1”关卡。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/223/">«</a>
	<span class="pagination__item pagination__item--current">224/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/225/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>