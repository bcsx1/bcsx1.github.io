<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81d6ddaeece4c64661ec48946bb80c57/" rel="bookmark">
			数据结构—单链表的基本操作(源代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef int Elemtype; typedef struct Node{ Elemtype data; struct Node *next; }Node,*LinkList; /*初始化链表需要修改头指针，修改头指针则必须用二级指针或一级指针的引用做参数，这里用二级指针*/ /*原因：初始化链表用到malloc函数，函数返回某个内存块的首地址。一级指针是指向内存块的， 如果用一级指针作参数，则只能通过指针修改指针所指内容，却无法修改指针的值，也就是指针所指的地址。而二级指针指向一级指针，所以可以用二级指针作参数，修改一级指针的值，使一级指针指向其他内存块，即指向malloc所申请的内存空间。*/ //创建头结点 void create_ListHead(LinkList *pHead)	//初始化链表必须用二级指针	方便起见没有对参数进行检查 { *pHead=(LinkList)malloc(sizeof(Node)); if(NULL!=pHead) (*pHead)-&gt;next=NULL; else printf("开辟内存失败\n"); } //创建新结点 LinkList get_newNode(Elemtype e) { LinkList newNode=(LinkList)malloc(sizeof(Node)); if(NULL!=newNode) { newNode-&gt;data=e; newNode-&gt;next=NULL; return newNode; } else { printf("开辟内存失败\n"); return 0; } } //头插 void push_Front(LinkList *L,Elemtype e) { LinkList p; p=get_newNode(e); p-&gt;next=(*L)-&gt;next; (*L)-&gt;next=p; } //尾插 void push_Back(LinkList *L,Elemtype e) { LinkList tail; tail=*L; while(NULL!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81d6ddaeece4c64661ec48946bb80c57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/150af4757c58bf35cac5d4a5fbf7de6b/" rel="bookmark">
			Log4j2指定配置文件路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一文中，我们学习了如何利用Log4j2来帮助我们更加优雅的打日志。在项目编译成jar包正式上线的时候，作者遇到了一个问题，就是log4j2.xml将会被打包到jar中，不能再上线后随时更改。
为了能让项目上线后，根据不同的需要改变一些日志的配置信息，如：日志输出路径，日志输出级别等，我们需要对log4j配置文件的加载进行一些变化。对此，可以通过log4j的ConfigurationSouce来指定配置文件位置，并加载。
ConfigurationSource source; String relativePath = "log4j2.xml"; String filePath = CONFIG_PATH + System.getProperty("file.separator") + relativePath; File log4jFile = new File(filePath); try { if (log4jFile.exists()) { source = new ConfigurationSource(new FileInputStream(log4jFile), log4jFile); Configurator.initialize(null, source); log = (Logger) LogManager.getLogger("LOGGER_NAME"); log.debug("this is a debug"); log.info("this is a info"); //..... } else { logInited = false; System.out.println("loginit failed"); System.exit(1); } } catch (Exception e) { e.printStackTrace(); System.exit(0); } 这样，我们只需要将配置文件放置到CONFIG_PATH路径下，命名为log4j2.xml即可成功加载，如果项目有需要，可以随时更改。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71294270d904ae9ae48f77f9c87b1136/" rel="bookmark">
			mysql创建远程用户、mysql用户授权、mysql编码、mysql备份和mysql快捷登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql和ubuntu版本Server version: 5.7.21-0ubuntu0.16.04.1 (Ubuntu) #mysql用户创建和授权 ## 1.使用root用户登录，查看数据库： mysql&gt; select Host,User from mysql.user; +-----------+------------------+ | Host | User | +-----------+------------------+ | localhost | debian-sys-maint | | localhost | mysql.session | | localhost | mysql.sys | | localhost | root | +-----------+------------------+ 4 rows in set (0.00 sec) ## 2.使用指定编码创建远程数据库 CREATE DATABASE testdb DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; 更改远程数据库指定编码 ALTER DATABASE testdb DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; ## 3.创建远程数据库用户 CREATE user test IDENTIFIED BY 'lenovo111!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71294270d904ae9ae48f77f9c87b1136/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f47854401f759b65918a4568fb445229/" rel="bookmark">
			【c语言】数据结构—动态储存顺序表的扩容、合并（源代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;assert.h&gt; #define MAXSIZE 3 //结构体定义 typedef int elemtype; typedef struct sqList{ elemtype *data; int size;	//当前长度 int capacity; //当前容量 }sqList; //初始化 void init_sqList(sqList *Psql) { assert(Psql);	//当参数为0时报错并终止程序 Psql-&gt;data=(elemtype *)malloc(MAXSIZE*sizeof(elemtype)); Psql-&gt;capacity=MAXSIZE; Psql-&gt;size=0; } //扩容 void expland_sqList(sqList *Psql,int n) { assert(Psql); if(Psql-&gt;size=Psql-&gt;capacity)	//表满 { Psql-&gt;capacity*=n;	//扩容成n倍 elemtype *new_data=(elemtype*)malloc(Psql-&gt;capacity*sizeof(elemtype));	//不建议用realloc函数 memcpy(new_data,Psql-&gt;data,Psql-&gt;size*sizeof(elemtype));	//从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所指的内存地址的起始位置中 free(Psql-&gt;data); Psql-&gt;data=new_data; printf("扩容成功\n"); } } //合并顺序表 sqList union_sqList(sqList *La,sqList *Lb)	//结构体变量作函数返回值 { assert(La); assert(Lb); sqList Lc; Lc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f47854401f759b65918a4568fb445229/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d675ffad8a0f99c2f82be72348270d8/" rel="bookmark">
			数据结构与算法 - 时间复杂度详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间复杂度详解 我们可以使用著名的高斯定理来解释什么是时间复杂度，时间复杂度的重要性
也就是从小到大我们所熟悉的一个定理 1+2+3+4+5+6+….+100的结果
使用高斯定理我们可以很轻松的算出答案
sum = 1 + 2+ 3 + 4 + 5+….+99 + 100
sum = 100 + 99+ 98 +97 +96+….+2 + 1
sum + sum = 101 +101 +101 + 101 + 101 +…… (共100个)
sum = 10100 / 2 = 5050
大家可以看出高斯定理是可以非常迅速的算出答案，我们可以使用程序来计算
我们先用最基础的for循环来计算答案
int sum = 0; for (int i = 1; i &lt;= 100; i++){ sum = sum + i; } System.out.println(sum); } 由程序可知for循环 循环了 100次才算出答案 当我们使用等差数列中的高斯定理来运算时
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d675ffad8a0f99c2f82be72348270d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d47c4a01598466f71e6adeaeafa8925/" rel="bookmark">
			详解协方差与协方差矩阵计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		协方差的定义
对于一般的分布，直接代入E(X)之类的就可以计算出来了，但真给你一个具体数值的分布，要计算协方差矩阵，根据这个公式来计算，还真不容易反应过来。网上值得参考的资料也不多，这里用一个例子说明协方差矩阵是怎么计算出来的吧。
记住，X、Y是一个列向量，它表示了每种情况下每个样本可能出现的数。比如给定
则X表示x轴可能出现的数，Y表示y轴可能出现的。注意这里是关键，给定了4个样本，每个样本都是二维的，所以只可能有X和Y两种维度。所以
用中文来描述，就是：
协方差(i,j)=（第i列的所有元素-第i列的均值）·（第j列的所有元素-第j列的均值）
注：这里（第i列的所有元素-第i列的均值）形成的行向量·（第j列的所有元素-第j列的均值）形成的行向量的转置，再将该点乘结果做平均（在这里，就是除以4）才得到协方差(i,j)，但是，由于下面的例子中要求的协方差阵中各个协方差均需要取相同的平均4，因此该协方差求解中省去了求平均的过程，最后求的协方差阵与未求平均的协方差阵拥有相同的特征向量（特征根变为原来的1/4）,所以不做平均也可以
这里只有X,Y两列，所以得到的协方差矩阵是2x2的矩阵，下面分别求出每一个元素：
所以，按照定义，给定的4个二维样本的协方差矩阵为：
(注：实际python求解该X,Y的协方差阵也是得到其各个元素的1/4)，如下图所示
）
用matlab计算这个例子
z=[1,2;3,6;4,2;5,2]
cov(z)
ans =
2.9167 -0.3333
-0.3333 4.0000
可以看出，matlab计算协方差过程中还将元素统一缩小了3倍。所以，协方差的matlab计算公式为：
协方差(i,j)=（第i列所有元素-第i列均值）*（第j列所有元素-第j列均值）/（样本数-1）
下面在给出一个4维3样本的实例，注意4维样本与符号X,Y就没有关系了，X,Y表示两维的，4维就直接套用计算公式，不用X,Y那么具有迷惑性的表达了。
常见的4维样本的计算如下:
（3）与matlab计算验证
Z=[1 2 3 4;3 4 1 2;2 3 1 4]
cov(Z)
ans =
1.0000 1.0000 -1.0000 -1.0000
1.0000 1.0000 -1.0000 -1.0000
-1.0000 -1.0000 1.3333 0.6667
-1.0000 -1.0000 0.6667 1.3333
可知该计算方法是正确的。我们还可以看出，协方差矩阵都是方阵，它的维度与样本维度有关（相等）。参考2中还给出了计算协方差矩阵的源代码，非常简洁易懂，在此感谢一下!
参考：
[1] http://en.wikipedia.org/wiki/Covariance_matrix
[2] http://www.cnblogs.com/cvlabs/archive/2010/05/08/1730319.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/018a636e2d86c4d952d0ce693b76bd4f/" rel="bookmark">
			查看jdk版本号和安装目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看安装的jdk 版本号
java -version 查看安装的jdk 安装目录 输入java -verbose，查看最后一行显示路径
java -verbose 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/243ce6207eb064685b8b7b13594ee9b8/" rel="bookmark">
			原码、补码以及四则运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原码：以n位为例，最高位表示真值的符号位，0表示正号，1表示负号，剩下的n-1位对数字部分进行编码。如果数字部分不足n-1位，则在高位补零，补足n-1位。
注意，按照以上表示方法，0的表示方法有两种：+0=0000 0000；-0=1000 0000。
原码是对数值的直接表示，所以其简单直观，但是在进行加减法运算时，需要对符号位和数值等等绝对值大小进行判断，使得运算十分复杂。
补码：符号位与原码相同，0表示正数，1表示负数。数字部分与符号位相关，正数的数字部分与原码相同，负数的数字部分需要将原码的数字部分按位取反再加1。以补码转换原码时，也是按位取反再加1。
原码与补码的转换：x=+1101，y=-1110
原码：0000 1101，1000 1110
补码：0000 1101，1111 0010
以补码求原码：0000 1101，1000 1110
补码的表示范围：
在8位的位模式下，正数部分为0000 0000到0111 1111，即+0到+127，负数部分1000 0000到1111 1111。
我们需要对负数部分的补码进行转换，得到原码才能知道表示范围。
1000 0000的原码为1 1000 0000，即-128，1111 1111的原码为1000 0001，即-1。注意这里1000 0000的原码实际上是溢出了的。
所以8位的位模式下，补码的表示范围是[-128,127]，或者[-128,128)。
对于n位的位模式，补码的表示范围是-2^(n-1)到2^(n-1)-1，一共2^n个数。
之所以要使用补码，因为补码可以简化运算，补码运算有下面两个公式：
(x+y)补=x补+y补(x-y)补=x补+(-y)补
这里只对第二个公式进行推导。
(x-y)补=(2^n+(x-y)) mod 2^n
=((2^n+x)+(2^n-y)) mod 2^n
=x补+(-y)补
例：A=+1011=11，B=+1110=14，求A-B
A补=0 1011，B补=0 1110，A补+(-B)补=0 1011+1 0010=1 1101=(A-B)补，则A-B=1 0011=-3
在进行补码运算时，符号位也参与运算，且不考虑符号位的进位问题，直接忽略掉进位。
例：A=+1111=15，B=-1101=-13，求A+B
0 1111+1 0011=10 0010，这里我们直接忽略最高位的1，结果变为0 0010=2
二进制的乘法运算与人们通常使用的十进制乘法运算有相似之处，分别使用乘数的各个数与被乘数相乘，最后结果相加，于是有：
例：1101*1011即13*11
1101+1101 0+0000 00+1101 000=1000 1111
所以二进制的乘法运算其实就是被乘数的移位与相加，这两个动作都可以使用加法器完成。
二进制的除法运算实际是除数的移位与相减，显然加法器是可以完成这两个动作的，这里不做解释。
至此，二进制的四则运算都已完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0b6520c9b450431db60db12da4f3671/" rel="bookmark">
			GFM 是 Github 拓展的基于 Markdown 的一种纯文本的书写格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [url=https://www.zybuluo.com/techird/note/46064]https://www.zybuluo.com/techird/note/46064[/url] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ff68c5244fcb0b1690d14e1acbb6b5a/" rel="bookmark">
			如何爬取天猫评论数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、原理 首先在浏览器地址栏中输入https://www.tmall.com/打开天猫商城，任意检索某一商品，以奶粉为例，搜索结果如下图所示：
任意点开其中的某个商品：
这是我们常见的网页，由文字、图片和排版组成。现在将屏幕向下翻，直到看到“累计评价”，即下图中红色矩形圈起来的东西：
到目前为止这个页面没有任何评价信息，当用鼠标点击“累计评价”后，评价信息才会显示出来。信息并不会凭空产生，那么，这些信息是从哪里来的？显然是从服务器而来。具体的讲便是：
浏览器发送请求到服务器，告诉服务器自己需要显示某某商品的评论信息；服务器接到请求，查询某某商品的评论信息；服务器将查询到的评论信息发送给浏览器；浏览器接收到评论信息，将其解析为符合人类阅读习惯的格式，显示在网页上。 现在来看看这一过程具体是如何实现的。需要用到流量监控工具，火狐浏览器按Ctrl+Q或F12可调出此工具。在火狐浏览器中，其界面如下：
页面下方的部分便是流量监控工具，它可以实时的显示该网页与外界通讯的情况，即流量。当然只会监控打开它之后的流量。主流浏览器都内置了此工具，可能会有不同的名称，但功能都大同小异，调出它的快捷键可能不同，但大都为F12。当然也有独立的功能更强大的专业流量监控工具，如WireShark等，不过这次使用浏览器内置的工具足矣。
以下部分强烈建议读者实际操作。网页结构经常会发生巨大改变，若在实践中发现有与下述不符的部分，实属正常。网页在变，但其原理不变。
我们利用流量监控工具来查看浏览器和服务器之间的通讯是如何完成的。在打开流量监控工具的情况下，点击“累计评价”，点击完成后可以看到流量监控工具捕捉到了许多数据包，即下图中红框框起来的部分：
其中每一行都是一个完整的通讯过程，包括了浏览器向服务器发出的请求和服务器返回的数据。可以看到，点击“累计评价”后，浏览器总共发出了9个数据包，请求不同的信息，也接收到了9个数据包，获得了不同的信息。用鼠标选中某一数据包，右键单击，再在弹出菜单中点击”Open in new tab”，就可以看到该数据包返回的文件的具体内容了。
但逐个查看，会发现评论信息并不存在于任何一个数据包中。这是因为流量监控工具只会监控打开它之后的流量，而第一页的评论在我们打开流量监控工具之前就已经加载了。现在我们先点流量监控工具右下角的“Clear”（这样做是为了减少无用的数据包，便于以后分析，不点也可以），然后将屏幕向下翻，点击“下一页”，再次捕捉流量，观察浏览器与服务器之间的通讯：
这次只有两个数据包，而且其中一个是图片，对另一个”Open in new tab”，可以看到如下页图中所示的内容，确实是评论信息。这个文件的后缀虽然是.html，但实际上是一个不规范的Json文件（JavaScript Object Notation，一种轻量级的数据交换格式）。有许多现成的库可以解析该格式的数据。
对比网页中的评论：
可以看到两者是相符的。
分析第一个数据包，Method为GET，也就是说，它仅仅通过URL来告诉服务器自己需要什么商品的评论信息。来分析下它的URL，是下面长长的一串：
https://rate.tmall.com/list_detail_rate.htm?itemId=44090725053&amp;spuId=324363453&amp;sellerId=725677994&amp;order=3&amp;currentPage=2&amp;append=0&amp;content=1&amp;tagId=&amp;posi=&amp;picture=&amp;ua=251UW5TcyMNYQwiAiwTR3tCf0J%2FQnhEcUpkMmQ%3D|Um5OcktzSXdDdkhxSnVMeS8%3D|U2xMHDJ%2BH2QJZwBxX39RaFF%2FX3E3VjBMPRNFEw%3D%3D|VGhXd1llXGReYFRhX2ZdYltuWWRGeEN5Q31EcEV7QnlMc01xSnNdCw%3D%3D|VWldfS0SMg41ASEbOxU5WDYSfg98UgRS|VmhIGCMaOAM4AzgDOgY5Bz8BOQU%2BHiMDPwA6BiYaJx8hGzsHOA0wECoVKAg0Cz4DIxkkHUsd|V2xMHDIcPAA6GicHPAI4bjg%3D|WGNDEz0TMw80FCgIMwk1YzU%3D|WWJCEjwSMgkzEysLMQsyZDI%3D|WmNDEz0TMws1Dy8bIRU1DDAMMGYw|W2JCEjwSMgs3Dy8bJhk5DDQONmA2|XGVFFTsVNQ8xCCgUKRAtDTkGOAxaDA%3D%3D|XWREFDoUNAg1DzQUKBUtEzMPMgY%2FBlAG|XmVFFTsVNQkzEy4OMg46DzpsOg%3D%3D|X2REFDoUNAgzEy8PMw87DzttOw%3D%3D|QHtbCyULKxAqCjISLhEtEil%2FKQ%3D%3D|QXhYCCYIKBArFzcDOgAgHCMYLBdBFw%3D%3D|QntbCyULKxIpETEEPAEhHSUcIBhOGA%3D%3D|Q3paCiRPKE4zXjhFa0t2VmlWaEh0T3VKfyl%2F|RH1dDSMNLRUuGjoGOwQ4GCYeJBsncSc%3D|RXxcDCIMLBUuEzMGPwcnGSIdIB1LHQ%3D%3D|Rn5eDiAOLn5HekBgVWtSBCQZORc5GSccJh0pfyk%3D|R35eDiAOLhcrFzcCPAgoFiwXKBZAFg%3D%3D|SHBQAC4AIHBEfUdnWGNcZ0dzT3ZWalJpS3BLcEtxTXdPcER7T3VVYFp6RHEnBzoaNBo6DjIKMQU7bTs%3D|SXBNcFBtTXJSbldrS3VNd1duTnBNbVJmRnlMbFZ2TW1VdUxsU21Nck1tUm5Oc1NyTm5PcFBxT29Od1duTm9UdEsd&amp;_ksTS=1457399262078_1440&amp;callback=jsonp1441 看上去很复杂，包含了很多参数。整理一下，按所含参数换行：
https://rate.tmall.com/list_detail_rate.htm ?itemId=44090725053 &amp;spuId=324363453 &amp;sellerId=725677994 &amp;order=3 &amp;currentPage=2 &amp;append=0 &amp;content=1 &amp;tagId= &amp;posi= &amp;picture= &amp;ua=251UW5TcyMNYQwiAiwTR3tCf0J/QnhEcUpkMmQ=|Um5OcktzSXdDdkhxSnVMeS8=|U2xMHDJ+H2QJZwBxX39RaFF/X3E3VjBMPRNFEw==|VGhXd1llXGReYFRhX2ZdYltuWWRGeEN5Q31EcEV7QnlMc01xSnNdCw==|VWldfS0SMg41ASEbOxU5WDYSfg98UgRS|VmhIGCMaOAM4AzgDOgY5Bz8BOQU+HiMDPwA6BiYaJx8hGzsHOA0wECoVKAg0Cz4DIxkkHUsd|V2xMHDIcPAA6GicHPAI4bjg=|WGNDEz0TMw80FCgIMwk1YzU=|WWJCEjwSMgkzEysLMQsyZDI=|WmNDEz0TMws1Dy8bIRU1DDAMMGYw|W2JCEjwSMgs3Dy8bJhk5DDQONmA2|XGVFFTsVNQ8xCCgUKRAtDTkGOAxaDA==|XWREFDoUNAg1DzQUKBUtEzMPMgY/BlAG|XmVFFTsVNQkzEy4OMg46DzpsOg==|X2REFDoUNAgzEy8PMw87DzttOw==|QHtbCyULKxAqCjISLhEtEil/KQ==|QXhYCCYIKBArFzcDOgAgHCMYLBdBFw==|QntbCyULKxIpETEEPAEhHSUcIBhOGA==|Q3paCiRPKE4zXjhFa0t2VmlWaEh0T3VKfyl/|RH1dDSMNLRUuGjoGOwQ4GCYeJBsncSc=|RXxcDCIMLBUuEzMGPwcnGSIdIB1LHQ==|Rn5eDiAOLn5HekBgVWtSBCQZORc5GSccJh0pfyk=|R35eDiAOLhcrFzcCPAgoFiwXKBZAFg==|SHBQAC4AIHBEfUdnWGNcZ0dzT3ZWalJpS3BLcEtxTXdPcER7T3VVYFp6RHEnBzoaNBo6DjIKMQU7bTs=|SXBNcFBtTXJSbldrS3VNd1duTnBNbVJmRnlMbFZ2TW1VdUxsU21Nck1tUm5Oc1NyTm5PcFBxT29Od1duTm9UdEsd &amp;_ksTS=1457399262078_1440 &amp;callback=jsonp1441 现在很清楚了，以下参数无疑是很关键的：
?itemId=44090725053 &amp;sellerId=725677994 &amp;currentPage=2 itemId是商品ID， sellerId 是卖家ID， currentPage是当前页码。基于此构造如下URL：
https://rate.tmall.com/list_detail_rate.htm? ItemId=44090725053 &amp;sellerId=725677994 &amp;currentPage=2 将其复制粘贴到浏览器地址栏后打开（当然先要去掉换行），可以看到同样的评论信息。把currentPage的值修改为1，便可以看到第1页的评论，修改为3，便可以看到第3页的评论。简单实验可知，可以看到前99页的评论（当然该商品得有这么多的评论），currentPage=100及以上时的内容与currentPage=99时相同。而若某商品评论较少，不足99页，例如只有45页，那么，currentPage=46及以上时的内容与currentPage=45时相同。
这样，只要知道某商品的itemId和sellerId就可以通过遍历currentPage获取该商品的所有的评论（前99页，人工不停地点“下一页”也最多只能翻到第99页）。 如何得知商品的itemId和sellerId呢？回到搜索“奶粉”后的界面（即第一张插图），把鼠标放在任意商品上，可以在浏览器左下角看到如下的URL：
查看网页源码：
放大后：
这个URL指向了商品详情页面，其中的id就是我们需要的itemId，user_id就是sellerId（可能对于天猫来说，卖家就是用户，所以叫user_id）。基于此，只要获取搜索结果页的各商品的URL就可以获得itemId和sellerId了。这件简单的事情用八爪鱼之类的数据采集器可以迅速完成。当然也可以自己写爬虫获取。
小结： 当我们在天猫商品详情页点“累计评价”时及查看评论翻页时，浏览器用如下的URL：
https://rate.tmall.com/list_detail_rate.htm? itemId=itemID&amp;sellerId=sellerID&amp;currentPage=N （省略了其他参数）来告诉服务器自己需要的是那个商品的第几页评论。服务器接到请求，查询该商品的特定评论并将查询结果返回给浏览器，浏览器解析并显示接收到评论信息。 经上面的试验已经知道，不打开天猫纷繁庞杂的电商网页，只发送申请评论信息的URL，产生很少的网络流量，也可以获得评论信息，这对爬取者和被爬取者来说都是一件好事。 以上便是爬取天猫评论信息的原理。总结一下：
打开https://www.tmall.com/；搜索某一商品名称；将搜索结果中的所有商品的url爬下来；从url中提取出itemId（id）和sellerId（user_id）；利用https://rate.tmall.com/list_detail_rate.htm?itemId=itemID&amp;sellerId=sellerID&amp;currentPage=N 遍历N（0 二、用Python实现的爬虫 基于以上原理用Python2.7写了一个以爬取千万级天猫评论数据为目标的爬虫，为避免文章过长，就不贴在这了，点 https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ff68c5244fcb0b1690d14e1acbb6b5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc9733ea4a688790d51e14aca55140cf/" rel="bookmark">
			Android Activity和Fragment之间的常规通信方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Activity和Fragment之间是可以相互传递数据的，这是无需置疑，而且还可以使用其他 特别的方式达到通信效果，如：广播、EventBus ,但这无疑增加了代码的阅读难度。
Activity和Fragment原本就有提供相互通信的方法，如下： 1、Activity 直接通过FragmentManager加载Framgment。
//Activity里添加Fragment getSupportFragmentManager().beginTransaction().add(R.id.frameLayout,new BlankFragment(),"blankFragment").commitNowAllowingStateLoss(); //Activity调用Fragment,可以通过getSupportFragmentManager().findFragmentByTag得到Fragment的对象 BlankFragment fragment= (BlankFragment) getSupportFragmentManager().findFragmentByTag("blankFragment"); fragment.sendFragmentToast(); //Fragment调用Activity ((Main2Activity)getActivity()).sendActiviyToast(); 2、Activity通过ViewPager加载Fragment
//Activity调用Fragment, adapter为ViewPager的Adapter(FragmentPagerAdapter/FragmentStatePagerAdapter) BlankFragment fragment = (BlankFragment)adapter.instantiateItem(ViewPager对象，Fragment索引位置); fragment.sendFragmentToast(); //Activity获取当前ViewPager显示的Fragment //在Adapter里面重写该方法 Fragment mCurrentFragment; @Override public void setPrimaryItem(ViewGroup container, int position, Object object) { mCurrentFragment=(BlankFragment)object super.setPrimaryItem(container, position, object); } //Fragment调用Activity ((Main2Activity)getActivity()).sendActiviyToast(); 以上为实现思路，如有错误，欢迎指正
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15cbfa102cc676f93cceae8ea2bf0ca8/" rel="bookmark">
			Java 设计模式之命令模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、了解命令模式 1.1 什么是命令模式 命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。这种说法比较难以理解，换种说法就是指：
在软件系统中，“行为请求者”与“行为实现者”通常呈现一种“紧耦合”。但在某些场合，比如要对行为进行“记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。
在这种情况下，如何将“行为请求者”与“行为实现者”解耦？将一组行为抽象为对象，实现二者之间的松耦合。这就是命令模式（Command Pattern）。
1.2 命令模式组成结构
命令接口 (Command)：定义命令的接口，声明执行的方法。 具体命令 (ConcreteCommand)：命令接口实现对象，是“虚”的实现；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。 接受者 (Receiver)：接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。 调用者 (Invoker)：要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。 客户 (Client)：创建具体的命令对象，并且设置命令对象的接收者。注意这个不是我们常规意义上的客户端，而是在组装命令对象和接收者，或许，把这个 Client 称为装配者会更好理解，因为真正使用命令的客户端是从 Invoker 来触发执行。 1.3 命令模式 UML 图解 1.4 命令模式适用场景
系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。 系统需要在不同的时间指定请求、将请求排队和执行请求。 系统需要支持命令的撤销 (Undo) 操作和恢复 (Redo) 操作。 系统需要将一组操作组合在一起，即支持宏命令。 二、命令模式具体应用 2.1 问题描述
电灯遥控器：现在让你为一种新型电灯设计一种手持的远程遥控器，这个遥控器可以打开和关闭电灯。
2.2 问题分析设计设计图 2.3 代码实现
接收者 Light 类
package com.jas.command; /** * 电灯提供打开和关闭的功能 */ public class Light { void on(){ System.out.println("Light is on!"); } void off(){ System.out.println("Light is off!"); } } 命令接口 Command
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15cbfa102cc676f93cceae8ea2bf0ca8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c826eff8a1c9375a23e489b3e8b7d13/" rel="bookmark">
			解决安卓微信浏览器中location.reload 或者 location.href失效的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在移动wap中，经常会使用window.location.href去跳转页面，这个方法在绝大多数浏览器中都不会 存在问题，但早上测试的同学会提出了一个bug：在安卓手机的微信自带浏览器中，这个是失效的，并没有跳转；
原来的代码：
window.location.reload(location.href); 初步判断可能是缓存的问题，首先想到的解决办法就是在要跳转的url后面加个时间戳，告知浏览器这是一个新的请求；
window.location.reload(location.href+'?time='+((new Date()).getTime())); 然而并没有什么卵用，看了下js文档：
href是location对象的一个属性，reload()则是location对象的方法 所以对于href，可以为该属性设置新的 URL，使浏览器读取并显示新的 URL 的内容。 对于reload()则是重新加载当前文档，如果该方法没有规定参数，或者参数是 false，它就会用 HTTP 头 If-Modified-Since 来检测服务器上的文档是否已改变。如果文档已改变，reload() 会再次下载该文档。如果文档未改变，则该方法将从缓存中装载文档。这与用户单击浏览器的刷新按钮的效果是完全一样的。如果把该方法的参数设置为 true，那么无论文档的最后修改日期是什么，它都会绕过缓存，从服务器上重新下载该文档。这与用户在单击浏览器的刷新按钮时按住 Shift 健的效果是完全一样。
但对于安卓手机微信中的浏览器，reload只是从缓存中装载文档，所以当你使用该方法，是失效的；
解决办法就是，使用location.href代替reload(),而且在以后的使用中也强烈建议大家使用location.href来进行刷新或者跳转
window.location.href = location.href+'?time='+((new Date()).getTime()); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f29bdb261cb7e946616b2c8469292a3a/" rel="bookmark">
			ARM &#34;重定位&#34; 与 &#34;分散加载&#34; 之间的联系与区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前刚刚学完了ARM的裸机部分，有一个问题一直比较困惑：就是 “重定位” 和 “分散加载” 到底是什么关系？
首先结合S5PV210的启动方式，iROM(BL0)中的程序执行完之后，将BL1（16K）从SD卡中复制到SRAM中执行，然后把BL2(剩余的程序)复制到DDR中去执行。把BL2(剩余的程序)复制到DDR中去执行：这个过程其实就是重定位。为什么需要这一步重定位呢？因为程序(uboot)的大小不止16K，所以就一定要把一个程序分成两部分，BL1和BL2，即用分散加载的方式实现重定位。S5PV210_SD卡启动
在做裸机实验重定位这一部分时，做过一个实验，将SRAM中的程序重定位到DDR中。具体就是用汇编把SRAM中的程序段复制到DDR中，复制结束之后清.bss段。
// r0是程序运行地址；r1是链接地址；r2是.bss段的起始地址 copy_loop: ldr r3, [r0], #4 // 源 str r3, [r1], #4 // 目的 这两句代码就完成了4个字节内容的拷贝 cmp r1, r2 // r1和r2都是用ldr加载的，都是链接地址，所以r1不断+4总能等于r2 bne copy_loop // 清bss段，其实就是在链接地址处把bss段全部清零 clean_bss: ldr r0, =bss_start ldr r1, =bss_end cmp r0, r1// 如果r0等于r1，说明bss段为空，直接下去 beq run_on_dram// 清除bss完之后的地址 mov r2, #0 clear_loop: str r2, [r0], #4// 先将r2中的值放入r0所指向的内存地址（r0中的值作为内存地址）， cmp r0, r1// 然后r0 = r0 + 4 bne clear_loop 上面这段程序是很直观的重定位过程，但是其实并没有什么作用，因为这个只是把SRAM 中自己的程序挪了个地方去执行而已。与uboot的分散加载不同的就是，这里的重定位过程是自己写的，而uboot的重定位是用设备复制函数直接复制完成的。当然，uboot重定位也要自己写清.bss段，应该是在BL2的start.S中写。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bb553c0de4ce7956c04026d81366e29/" rel="bookmark">
			jQuery_轮播图_淡入淡出效果（如何用jQuery实现一个淡入淡出轮播图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解释： jQuery做的轮播图，淡入淡出效果，没有使用面向对象
效果图： 思路图： 代码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; *{ margin:0; padding:0; list-style: none; } #box{ position:relative; width:400px; height:300px; } img{ position:absolute; width:400px; height:300px; } #imgId1{ opacity:1; } #imgId2{ opacity:0; } #imgId3{ opacity:0; } #imgId4{ opacity:0; } #imgId5{ opacity:0; } ul{ position:absolute; right:20px; bottom:10px; height:40px; } li{ float:left; margin-left:10px; width:20px; height:20px; border-radius:50%; background-color:orange; } #leftArrow{ position: absolute; left:0px; top:50%; } #rightArrow{ position: absolute; right:0px; top:50%; } &lt;/style&gt; &lt;/head&gt; &lt;body style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bb553c0de4ce7956c04026d81366e29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68543f8c47de5d6d8e839836ff248a20/" rel="bookmark">
			GSM sim900a mini模块用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
使用要点：
现有如下资料例程
模块图片
USB转串口连接900a
与串口连接
1 AT 指令简介
常用AT指令
读取短信：
发送短信
常用AT指令
2 拨打/接听电话
短信的读取与发送
英文短信的发送
GPRS 通信
使用要点： 通信协议是什么？UART串口传输、标准的 AT 命令对模块进行控制、波特率选择默认的 115200
难点是首先要实现串口助手与模块之间的通信，接好线发送AT命令。这一步之后接上单片机与单片机之间通信。
焊接一个转接板。不然觉得接线不方便。
1、stm32写一个关于gsm模块通信的库，
读取内容、写内容
别的接口在此两个接口基础上，做到更加具体的功能，如：拨打&lt;号码&gt;电话，发送&lt;号码&gt;短信，读取短信内容
读到短信内容后，解析内容（自己定义通信协议）
不知为何自己用别的USB转串口不起作用，只有ft232bl可以使用 串口调试。
5V 供电，电脑调试初期电脑USB供电可以满足要求。模块有1000UF的大电容。长时间传输数据用电量大1A以上的直流，TTL电平串口自适应兼容3.3V和5V单片机。
现有如下资料例程 1 发送一条中文短信
2 发送一条英文短信
3 拨打指定电话，1分钟后自动挂断
4 接到指定短信内容，控制LED开断
5 检测模块是否注册到网络，是否读到SIM卡，并发送提示信息
6 通过GPRS，连接指定的服务器并发送指定数据
说明：
可以直接连接单片机。待机在80MA左右，可以设置休眠状态在10MA左右低功耗。电脑调试USB--232和USB--TTL均可，根据各人配件而定。支持短信，数据，彩信，上网等。复位排针引出，可实现现场无人值守远程复位,带DTMF功能实现远程遥控功能。模块最大的优点是保留232口，在学习或者开发时可以监听51低端单片机和模块指令执行情况，能更快的找出原因，节省开发和学习的时间.[支持2,3,4G手机卡】。
模块的优点：
串口电路：采用TVS和磁珠保护器件来保护板子，使板子不会受到浪涌、高电压的伤害。
SIM卡电路：增加SMF05C静电释放芯片。
天线电路：保证的短且直，这样才能保证信号强度。
PCB展示：各个接口丝印标出，方便二次开发，设计时完全遵循SIM900A硬件设计手册。
一路5V 供电电源接口：做了保护，即使接反了也不会烧板子。电脑初期调试电脑USB供电即可；长时间传输数据用电量较大我们推荐1A以上的直流。
一路TTL接口：支持3.3V单片机和5V单片机。也就是说支持51类的5V单片机和STM32单片机。
两路天线接口：SMA天线接口，IPX MINI天线接口（默认不焊接）。
一路232 电平接口：也就是说您可以通过一根232---USB串口线直接将模块连接到电脑上调。也可以USB--TTL连接电脑，根据个人的配件情况而定。
模块图片 USB转串口连接900a 与串口连接 此外还需要给SIM900A模块供电。
USB--TTL需要接模块TTL串口中间俩个针一个是5VTXD和RXD,然后共GND. 板子上有标注 ，千万别接错线。
第二种：通过USB--232串口线将模块与电脑连接起来，再接入5V电源，之所以我们的SIM900A模块在设计时保留了232接口，原因为：51等低端单片机无法实现仿真，所以你不能知道单片机发给SIM900A 模块的每条指令执行的情况。但是这个问题在我们这里就得到了很好的解决，通过将SIM900A模块232接口将模块连接到电脑上，就可以轻松监测到每条指令执行的情况，在实际开发时特别特别的有用，很多问题就是通过这个232找到的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68543f8c47de5d6d8e839836ff248a20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34716327058cd355cb9d1ceded930b47/" rel="bookmark">
			Bitset模板 Bitset题型大荟萃
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以codeforces上的ASC28J为例，讲了一些我遇到的Bitset的题目及做法
#include&lt;stdio.h&gt; #include&lt;iostream&gt; #include&lt;string.h&gt; #include&lt;ctype.h&gt; #include&lt;math.h&gt; #include&lt;map&gt; #include&lt;set&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;functional&gt; #include&lt;string&gt; #include&lt;algorithm&gt; #include&lt;time.h&gt; #include&lt;bitset&gt; void fre(){freopen("triatrip.in","r",stdin);freopen("triatrip.out","w",stdout);} template &lt;class T&gt; inline void scand(T &amp;x){char c;x=0;while((c=getchar())&lt;'0');while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+(c-48),c=getchar();} #define MS(x,y) memset(x,y,sizeof(x)) #define MC(x,y) memcpy(x,y,sizeof(x)) #define ls o&lt;&lt;1 #define rs o&lt;&lt;1|1 typedef long long LL; typedef unsigned int UI; template &lt;class T&gt; inline void gmax(T &amp;a,T b){if(b&gt;a)a=b;} template &lt;class T&gt; inline void gmin(T &amp;a,T b){if(b&lt;a)a=b;} using namespace std; const int N=1515,M=0,Z=1e9+7,maxint=2147483647,ms31=522133279,ms63=1061109567,ms127=2139062143; int n,i,j; char s[N]; /* 【算法介绍】 bitset是可以类似于状压DP，可以对01状态进行压缩和表示。 &lt;1&gt;bitset不仅限于32bits or 64bits，而是可以达到甚至是1e8 bits &lt;2&gt;bitset支持or and xor &lt;&lt; &gt;&gt; 等位运算，效率很高 其常用函数如下： b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34716327058cd355cb9d1ceded930b47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1c7dac2a537f8a28203ff11dd3cc1b6/" rel="bookmark">
			adb命令大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
基本用法
命令语法
为命令指定目标设备
启动/停止
查看 adb 版本
以 root 权限运行 adbd
指定 adb server 的网络端口
设备连接管理
查询已连接设备/模拟器
USB 连接
无线连接（需要借助 USB 线）
无线连接（无需借助 USB 线）
应用管理
查看应用列表
安装 APK
卸载应用
清除应用数据与缓存
查看前台 Activity
查看正在运行的 Services
查看应用详细信息
与应用交互
调起 Activity
调起 Service
发送广播
强制停止应用
文件管理
复制设备里的文件到电脑
复制电脑里的文件到设备
模拟按键/输入
电源键
菜单键
HOME 键
返回键
音量控制
媒体控制
点亮/熄灭屏幕
滑动解锁
输入文本
查看日志
Android 日志
内核日志
查看设备信息
型号
电池状况
屏幕分辨率
屏幕密度
显示屏参数
android_id
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1c7dac2a537f8a28203ff11dd3cc1b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45ba1844502a974e08473bfb81775d9a/" rel="bookmark">
			js的必包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 js的必包， 他是js的难点 ，也是js的特色。 很多高级的应用都依赖于必包的实现。
要理解必包， 前提要理解js的变量作用域 。
js分为全局变量 和局部变量；这点不同于java ，java中不存在全局变量。
全局变量：在函数体外window下声明的变量 被称为全局变量。 任意一个函数都可以访问这个变量。但在实际开发中， 并不推荐定义全局变量。 会造成变量的污染。
局部变量： 在函数体内 且用var声明的变量 称之为局部变量。（注：在函数体内并没有用var声明的变量 也叫全局变量。so 在函数体内声明变量一定要用var声明。）； 局部变量只能在函数体内被使用。 换句说 ：局部变量的作用域是定义他的函数体本身。
以上我们了解js的变量作用域范围，那么定义过多的全局变量会造成变量的全局污染， 但有时我们还必须要使用到函数体外的变量怎么办？
============================================================================
此时我们的js必包就可以闪亮登场了。
var f1 = function(){ n = 99; function f2(){ n = n+1; } return f2(); } //调用函数 f1();以上的函数就是一个必包， 满足了即没有声明全局的变量但又保证了任意函数都可以访问n这个局部变量。 原理：
js在调用变量时 假如这个变量不是这个函数体本身的 他会一级一级的向父元素查找 直到父元素也没有定义这个变量，这时js会抱一个错给我们。
所以以上代码在f1函数内定义了一个局部变量n，n这个变量对于f1 和其子元素都是可见的 可以被访问的。 f1只是定义了n这个变量并为其赋值为99. f2函数所执行的操作是对n做加一的操作 ，所以此时n等于100，f1返回了f2函数，所以f1最终的结果返回的时n=100；
这样就实现了函数的内部和外部可以使用n这个变量。
以上就是我对js必包的理解 。
必包虽好，并不代表可以随意使用必包，由于必包的所有变量都会保存在内存中，内存的消耗会比较大。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d917d2fcd8d0adceed9617b4901a5275/" rel="bookmark">
			java实现发送短信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java实现发送短信(本章调用阿里云API) 地址如下 https://market.aliyun.com/products/56928004/cmapi022659.html?spm=5176.2020520132.101.5.TsClbR#sku=yuncode16659000011 进入控制台得到AppCode 告诉商家你的短息模板,动态内容是自定义参数的 和卖家商议 maven工程所需的依赖
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.aliyun.api.gateway&lt;/groupId&gt; &lt;artifactId&gt;java.demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.15&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpcore&lt;/artifactId&gt; &lt;version&gt;4.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-util&lt;/artifactId&gt; &lt;version&gt;9.3.7.v20160115&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.5&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 将测试代码写在TestController.java
import java.util.HashMap; import java.util.Map; import org.apache.http.HttpResponse; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d917d2fcd8d0adceed9617b4901a5275/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0158ab82609ac092fce2913bf432a317/" rel="bookmark">
			ServletException ClassNotFoundException 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		javax.servlet.ServletException: Error instantiating servlet class java.lang.ClassNotFoundException: com.zx.demo.GetUserServlet
突然想学习下servlet，不幸的也遇到了这个问题，因此记录一下解决方案，百度了一堆也没解决我的问题。
开发工具：InteliJ IDEA 出现这个问题，如果你确定你的代码没问题（web.xml），那么继续往下看
第一步：检查File –&gt; Project Structure - Artifacts 点击+号，直接选择FromModules，会自动拉取你的WEB-INF，即可
第二步：检查Tomcat的配置
Server 里面的8099/an 要和Deployment里面的/an对应
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5d7a101f567c64d381d5f6f865a9775/" rel="bookmark">
			java实现身份证实名认证(阿里云api)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java实现身份证实名认证(调用阿里云api) !!这个接口调用了公安接口 进行验证 不是普通的身份证号码验证.可以识别身份证号码生成器 阿里api市场链接: https://market.aliyun.com/products/56928004/cmapi016424.html?spm=5176.2020520132.101.9.VRsLss#sku=yuncode10424000011 复制Appcode package ali; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.HttpURLConnection; import java.net.URL; public class aliyun { /** * requestGet * @param strUrl * @param param * @param appcode * @return */ public static String requestGet(String strUrl, String param, String appcode) { String returnStr = null; // 返回结果定义 URL url = null; HttpURLConnection httpURLConnection = null; try { url = new URL(strUrl + "?" + param); httpURLConnection = (HttpURLConnection) url.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5d7a101f567c64d381d5f6f865a9775/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5a343e81306923d64860ea4b60d2db4/" rel="bookmark">
			在docker中使用tensorboard以及docker的可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在docker中使用tensorboard docker无法打开两个窗口同时做不同的事，而启用tensorboard时，需要打开一个窗口启动tensorboard，然后打开另外一个窗口启动浏览器。因此一般不能在docker环境下使用tensorboard，因为docker使用tensorboard时启动的端口6006是属于这个docker容器的，因此在Linux系统上无法直接用浏览器打开这个端口。 解决方法： 在创建docker容器时，开放6006这个端口。比如创建一个叫lhh的容器： nvidia -docker run -p 0.0.0.0:6006:6006 -it -v /home/lhh:/home/lhh –name lhh tensorflow/tensorflow bash docker的可视化 如果需要在docker里面进行看图像等可视化操作，需要在创建docker容器时指定，比如 nvidia -docker run -it lhh –net=”DISPLAY” -v /home/lhh:/home/lhh –volume=”$HOME/.Xauthority:/root/.Xauthority:rw” tensorflow/tensorflow bash
其中的–net=”DISPLAY” 和–volume=”$HOME/.Xauthority:/root/.Xauthority:rw”配合使用就是开放可视化的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d67674912050474b87a231ae37836fdd/" rel="bookmark">
			【opencv】最小包围矩形minAreaRect与最小包围圆minEnclosingCircl详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、RotatedRect类 RotatedRect该类表示平面上的旋转矩形，该类对象有三个重要属性：矩形中心点(质心)，边长(长和宽)，旋转角度。三种构造函数和三种成员操作函数，RotatedRect类定义如下：
class CV_EXPORTS RotatedRect { public: //构造函数 RotatedRect(); RotatedRect(const Point2f&amp; center, const Size2f&amp; size, float angle); RotatedRect(const CvBox2D&amp; box); //!返回矩形的4个顶点 void points(Point2f pts[]) const; //返回包含旋转矩形的最小矩形 Rect boundingRect() const; //!转换到旧式的cvbox2d结构 operator CvBox2D() const; Point2f center; //矩形的质心 Size2f size; //矩形的边长 float angle; //旋转角度，当角度为0、90、180、270等时，矩形就成了一个直立的矩形 }; 二、minAreaRect(最小包围矩形）
minAreaRect( InputArray points );//返回类型为RotatedRect对象，参数为vector&lt;vector&lt;Point&gt;&gt;点集，作用为计算包围点集的最小旋转矩阵 三、minEnclosingCircle(最小包围圆）
minEnclosingCircle函数功能是利用一种迭代的算法，对给定的2D点集，去寻找面积最小的可包围的她们的面积
void minEnclosingCircle(InputArray point, Point2f¢er, float&amp;radius); 第一个参数：输入的二维点集，可以是vector&lt;&gt; 第二个参数：圆的输出圆心 第三个参数：圆的输出半径 四、程序演示
求随机点的最小包围圆和最小包围矩形
#include&lt;opencv2\opencv.hpp&gt; #include&lt;opencv2\imgproc\imgproc.hpp&gt; #include&lt;iostream&gt; using namespace cv; using namespace std; void on_ThreshChange(int, void*); int ThreshValve = 100; Mat srcImage, srcImage_gray, srcImage_blur, srcImage_thresh; int main() { Mat image(600, 600, CV_8UC3, Scalar::all(255)); //imshow("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d67674912050474b87a231ae37836fdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e3126856a0529145c517456a505dcc7/" rel="bookmark">
			联想 win10 无法进入BIOS的处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象：Win10系统默认打开了【快速启动】，会导致笔记本开机过快，无法进入BIOS开启intel vt-x。
原因：【快速启动】原理：关机时 Windows 10 会将当前所有系统状态写入到休眠文件中，然后再关机，当再次启动计算机时，Windwos 就不用再重新加载系统内核、驱动程序和系统状态，而是直接从休眠文件进行加载并刷入内存，完成之后直接向用户推送 Windwos 登录界面。
四种解决方法：
一、重启电脑，黑屏时，按进入BIOS按键； 二、关机，拔掉电源线，约等10秒后，再插回电源线开机，按进入BIOS按键；
三、 关闭【快速启动】
四、windows恢复功能
1、设置win键 - 设置 - 更新和安全 - 高级启动（立即重启）
2、疑难解答 - 高级选项 - UEFI固件设置 - 重启。重启后，系统会自动进入BIOS。
注：第四种方法本人电脑无该选项，仅供参考。
进入BIOS后，设置启用intel vt-x。我的电脑是联想G470，仅供参考。
BIOS按键
组装机主板品牌笔记本品牌台式机主板品牌启动按键笔记本品牌启动按键台式机品牌启动按键华硕主板F8联想笔记本F12联想台式机F12技嘉主板F12宏基笔记本F12惠普台式机F12微星主板F11华硕笔记本ESC宏基台式机F12映泰主板F9惠普笔记本F9戴尔台式机ESC梅捷主板ESC或F12联想ThinkpadF12神舟台式机F12七彩虹主板ESC或F11戴尔笔记本F12华硕台式机F8华擎主板F11神舟笔记本F12方正台式机F12斯巴达卡主板ESC东芝笔记本F12清华同方台式机F12昂达主板F11三星笔记本F12海尔台式机F12双敏主板ESCIBM笔记本F12明基台式机F8翔升主板F10富士通笔记本F12 精英主板ESC或F11海尔笔记本F12 冠盟主板F11或F12方正笔记本F12 富士康主板ESC或F12清华同方笔记本F12 顶星主板F11或F12微星笔记本F11 铭瑄主板ESC明基笔记本F9 盈通主板F8技嘉笔记本F12 捷波主板ESCGateway笔记本F12 Intel主板F12eMachines笔记本F12 杰微主板ESC或F8索尼笔记本ESC 致铭主板F12 磐英主板ESC 磐正主板ESC 冠铭主板F9 注意：其它机型请尝试或参考以上品牌常用启动热键 参考链接：
1、https://zhidao.baidu.com/question/1707453252554106500.html
2、http://blog.csdn.net/dreamtheworld1/article/details/51413829
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/250dd2e3d1e8fa1cc7f009c48f6ec8e9/" rel="bookmark">
			ES6 学习（二）[多行字符串``，重复字符串repeat,原始字符串raw]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1\ 我们平时定义字符串一般用引号(单引号，双引号)，这些定义的单行字符串内部不能出现特殊字符（换行符等等），我们可以通过转义符号代表这些特殊字符。
引号嵌套：单引号与双引号可以相互嵌套，单引号与单引号，双引号与双引号不能直接嵌套，字符串内部不能使用变量。。。。
为了解决上述问题，ES6提出来多行字符串概念，将字符串写在``内，就是一个多行字符串。
在多行字符串中，可以使用任何字符（除了`）,想在多行字符串中使用变量要使用插值语法${变量}。该变量要在当前作用域下访问到。
插值语法提供了一个js环境，因此可以使用表达式。
插值语法如下： ejs: &lt;%=key%&gt; MVC: &lt;%key%&gt; Backbone|underscore:&lt;%=key%&gt;
vue: {{key}} angular:{{key}} less:@{key} sass:#{$key}
stylus:{key} react:{key} ES6:${key}
let html = '';
for (let i = 0; i &lt; data.length; i++) {
// data[i] 表示每一个成员
html += `&lt;li&gt;
&lt;a href="#/detail/${data[i].id}"&gt;
&lt;h3 class="${'color' + i}"&gt;${data[i].title}&lt;/h3&gt;
&lt;p&gt;${data[i].description}&lt;/p&gt;
&lt;img src="${'img/ad/' + data[i].url}" alt=""&gt;
&lt;/a&gt;
&lt;/li&gt;` }
html = `&lt;ul&gt;${html}&lt;/ul&gt;`;
2\重复字符串
repeat: 重复参数次字符串
参数表示重复的次数
repeat 方法返回一个新字符串，表示将原字符串重复n次。
3\原始字符串
字符串扩展了一个静态方法 raw,用来获取原始字符串，内部的转义字符不会转义（怎么写，怎么输出）
方法的特殊之处是参数用``定义（不需要用参数集合()）
console.log(String.raw`这是一个神奇的\n网站\n爱创课堂`)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4eb55966e265f97569fc566cfd56c8b/" rel="bookmark">
			Vue组件data必须是函数的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们先来看data的几种写法：
1、
&lt;script type="text/javascript"&gt; var app=new Vue({ el:'#app', data:{ isLogin: false } }) &lt;/script&gt;2、 &lt;script type="text/javascript"&gt; var app=new Vue({ el:'#app', data: function(){ return { isLogin: false } } }) &lt;/script&gt;3、 &lt;script type="text/javascript"&gt; var app=new Vue({ el:'#app', data() { return { isLogin: false } } }) &lt;/script&gt; 第三种是第二种的ES6写法。 一、在简单的Vue实例中，1、2写法没有什么区别，因为你的app对象不会被复用
var app = new Vue({...})二、但是在组件中，因为可能在多处调用同一组件，为了不让多处的组件共享同一data对象，只能返回函数。 data为对象的话会报错，为了理解这种机制，我们假设data为一个对象，那么这同一个对象有可能被很多实例共享，一个实例改变其它也会跟着变，这明显是不对的。而通过data函数，每新建一个实例，都会调用data来return一组新的原始数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9c82b3a33d3c6275a9038d3efa6ca58/" rel="bookmark">
			【cocos2d-x 源码解析】事件系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事件系统 事件 Event事件监听器 EventListener事件分发器 EventDispatcher 监听器管理注册监听器移除监听器暂停和恢复监听器派发事件 使用方法总结 实现自己的事件系统 事件系统 cocos2d-x 3.x 的事件比 2.x 要好用很多，也比较简单，主要由三部分组成：事件分发器 EventDispatcher、事件监听器 EventListener 和事件 Event。
cocos2d-x 3.x 所有与事件相关的文件都在 cocos/base 模块下。
事件 Event 事件在现实中的意思是发生了一件事，当事情发生之后会有人去做一些处理；在应用程序中事件可以看作是一个带有数据的实体，而事件监听器就是事情发生之后做一些处理工作的人；派发事件就是将事件这个实体派发出去，告诉大家发生了这个事情，然后事件监听器会监听到事件触发，接收事件这个实体，取到事件中的数据，做相应的处理。
在这里事件可以简单地看成一个数据体，它在整个事件系统中的作用是传送数据，事件派发器将事件派发出去，事件监听器接收到这个数据，然后把事件中的数据取出来，进行下一步操作。事件的基类是 Event，它的定义很简单，只定义了几个属性
class CC_DLL Event : public Ref { public: /** Type Event type.*/ enum class Type { TOUCH, KEYBOARD, ACCELERATION, MOUSE, FOCUS, GAME_CONTROLLER, CUSTOM }; public: //function protected: Type _type; ///&lt; Event type bool _isStopped; ///&lt; whether the event has been stopped. Node* _currentTarget; ///&lt; Current target friend class EventDispatcher; }; Event 类只声明了事件类型 _type，事件是否停止 _isStopped，事件附加的目标结点 _currentTarget 这三个属性。其中，事件类型共有七种，分别是 触摸事件、键盘事件、加速计事件、鼠标事件、焦点事件、手柄事件和自定义事件。具体事件类在 Event 的基础上多定义了几个属性而已，比如键盘事件 EventKeyboard 就多定义了两个属性，_keyCode 表示按下的键值，_isPressed 表示是按下还是松开
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9c82b3a33d3c6275a9038d3efa6ca58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/120aa4871db183a31379eec942e63c41/" rel="bookmark">
			VMware安装一台虚拟主机的过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.准备工具 2.安装过程 这里稍后安装,如果vmware安装会安装非常庞大 这里我安装的Linux 虚拟机的名字 和 路径(路径建议别选不是C盘,选择容量大的盘) 建议默认配置 内存建议选择1G 太小跑不起来,因为Linux也是需要吃内存的 推荐默认的网络类型 默认磁盘类型 创建虚拟磁盘 指定磁盘大小 这个默认就可以 创建虚拟机成功 3.安装Linux系统 下面截图是问用不用检测安装媒介,例如硬盘 这里就选择不用检测了 系统语言就选择英文吧 键盘也是美式键盘吧 它问的是电脑磁盘是哪一种 选择基础的磁盘就行 这里问 磁盘要不要被格式化, 这里选择格式化(都是虚拟的没关系) 主机的名字 时区选择上海 为超级用户root 设置密码 输入2遍 如果弹出这个窗口,提示这是一个弱密码,是否要采用选择 use anyway可以了 下一步询问磁盘是不是要分区的,不要选择自定义分区了,让它自己分好了 这一步就是要写磁盘了,准备分区了 选择版本(桌面版本,最小桌面,最精简我桌面软件工具都没有) 完成分别输入 ll 和pwd命令测试了一下 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f06d693fdbcda73afa35f431db1cdee5/" rel="bookmark">
			Editing Drive Letter Assignments
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Editing Drive Letter Assignments The code example in this topic shows you how to add or remove persistent drive letter assignments. These drive letter assignments persist through system shutdown. For more information, see Assigning a Drive Letter to a Volume.
The code example uses the following functions: DefineDosDevice, DeleteVolumeMountPoint, GetVolumeNameForVolumeMountPoint, andSetVolumeMountPoint.
C++ /* DLEDIT -- Drive Letter Assignment Editor Command-line syntax: DLEDIT &lt;drive letter&gt; &lt;device name&gt; -- Adds a drive letter DLEDIT -r &lt;drive letter&gt; -- Removes a drive letter Command-line examples: If E: refers to the CD-ROM drive, use the following commands to make F: point to the CD-ROM drive instead.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f06d693fdbcda73afa35f431db1cdee5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9e64adab9d49d3797ae97cde1e35b6c/" rel="bookmark">
			Spring中Bean的作用域与StepScope关系、疑问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring中Bean的作用域与StepScope关系、疑问 Spring Bean有5个作用域，但是最近有需求在多个地方获取同一个Bean，只修改其中一个参数。那么Bean只在一个地方注入，修改属性就好，名字能一样吗？一系列问题 这个StepScope是什么鬼，5个默认的Scope能满足需求吗？ Bean scopes ScopeDescriptionsingletonScopes a single bean definition to a single object instance per Spring IoC container.prototypeScopes a single bean definition to any number of object instances.requestScopes a single bean definition to the lifecycle of a single HTTP request; that is each and every HTTP request will have its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9e64adab9d49d3797ae97cde1e35b6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54e1c08b512c384756badbefd370d755/" rel="bookmark">
			nodejs的应用范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只想单纯的小总结一下nodejs的应用范围： 主要应用领域： 1.RESTful API 2.实时消息：如消息推送 3.该并发：单进程便可承载 4.io阻塞：网络文件和数据库就有这个问题，那么js的异步加载可以解决这个问题 nodejs的生态圈主要是以npm为中心 从开发、测试、部署 从单元测试到功能测试都有对应工具。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0960a6480d9455607855edf99e638e73/" rel="bookmark">
			Android ijkDemo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 引入VideoView2 初始化Settings4 视频路径6 设置VideoView播放路径7 openVideo7.1 判断是否已经准备好播放7.2 释放播放器7.3 中心取得音频焦点7.4 创建播放器 8 createPlayer1 安卓原生播放器2 google的exo播放器3 默认的是ijk的播放器4 首先看是否使用硬解码5 是否开启opensl-es6 设置准备监听1 首先设置准备监听接口，2 当mMediaConfroller不为空时，设置按钮可以接收监听3 接收MediaPlayer的宽高，赋值给全局的VideoView的宽高4 记录并滑动到指定位置5 当宽高都不为0时6 当无法获取当前宽高值时 7 设置屏幕尺寸改变监听8 错误监听9 信息回调10 设置数据更新回调接口11 设置播放地址12 将MediaPlayer和IRenderView绑定13 设置音频类型 7 播放 1 引入VideoView &lt;tv.danmaku.ijk.media.example.widget.media.IjkVideoView android:id="@+id/video_view" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_gravity="center"&gt;&lt;/tv.danmaku.ijk.media.example.widget.media.IjkVideoView&gt; 2 初始化Settings mSettings = new Settings(this); Settings存储了关于播放器的设置，比如后台播放，使用SurfaceView还是TextureView渲染等。
部分示例：
public boolean getEnableBackgroundPlay() { String key = mAppContext.getString(R.string.pref_key_enable_background_play); return mSharedPreferences.getBoolean(key, false); } public int getPlayer() { String key = mAppContext.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0960a6480d9455607855edf99e638e73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a447c69b2a7fbea78774c8b4b0e41ff/" rel="bookmark">
			论文写作: 一点心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 以下记录的是这两天和导师、师兄讨论小论文写作所总结的一点心得体会。
题目 要 基于问题 出发，而不是基于方法出发。
比如你的工作是用深度学习解决了某个复杂场景下的问题，就要在题目上体现出这是一个多么多么 难的挑战，让人一看就觉得，哎这个问题一看就很难，就会很 有兴趣去了解你是如何解决的 。比如《基于XX复杂场景下的XXXX》，这样的题目就不错。
如果题目定为《基于深度学习的XXXX》，就变成了基于方法出发，会让人觉得你纯粹就是 为赋新词强说愁 ，这样就似乎本末倒置了。
摘要 摘要极其重要，一定要字斟句酌。
大部分审稿人会把主要时间花在你的摘要上。
在摘要里面，一定要讲清楚以下三点：面临什么挑战，做出什么贡献，实验效果如何 。
Introduction 也是要点之一。
Relation Work 不重要，大部分时候会被审稿人跳过。
图表 图表一定要多，要专业。
高大上且丰富的图表展示，能让一篇文章的档次上几个台阶。
尽量把图表下的解释文字体现在图表中，免得审稿人还要一边看图表下面的注释，一边回过头去你图表里找。
推荐几个 在线 绘制图表的网站：
流程图：ProcessOn 折线图：图表秀 修图：美图秀秀 其他 写论文要写得 傻瓜式，要假设你的读者是什么专业知识的都没有的人，而你的叙述能做到让外行人也觉得：嗯，你的这个东西是真的好～
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05b95ab47f3679c99912bfb108ed8021/" rel="bookmark">
			[已解决]Argument list too long如何处理？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Argument list too long 本质是需要处理的长度超过系统的长度，因此无法执行相关命令。
经过搜索发现了两种方法，思想都是将参数切分成小的段落进行执行。
法一：通过xargs传递参数 (数据量大了还是不太奏效)
find . -name "*.log" | xargs -0 rm ls | xargs -t -I {} mv {} ../matchres/ 可以把当前目录下的所有文件移到 "../matchres"下 ls | head -n 50 |xargs -t -I {} mv {} ../ 可以把当前目录中的前50个移动到上级目录 合并201301目录文件到 hbtmp/bill201301.txt cd 201301/ ls | xargs -t -I {} cat {} &gt;&gt; ../hbtmp/bill201301.txt xargs使用的命令一次会被调用2000〜4000次左右，因此，如果列出的日志有一万笔的话，可能就会被分成3到5次左右来执行，因而避开了。
find -maxdepth 1 -type f \( -exec grep -q '^- ' {} \; -o -print \) maxdepth 深度type 文件类型 法二：shell脚本循环执行rm命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05b95ab47f3679c99912bfb108ed8021/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/731b64f1523d6d071b7656550d2c919c/" rel="bookmark">
			C语言实现——————“学生成绩管理系统”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		话不多说，代码附上：
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; struct Student { char num[20]; //学号 char name[20]; //姓名 char sex[5]; //性别 char address[80]; //家庭住址 struct Student *next; //动态链表连接下一个 int *p 与上面对比 方便思考 }; struct Student *creat(struct Student *head0) //定义了一个返回值为结构体类型的指针变量 { struct Student *head1, *p1, *p2, *t0, *t1; int m, n = 1, h; FILE *fp; printf("请选择："); printf("1.继续上次输入: 2.重新输入:"); scanf("%d",&amp;h); if (h==1) { if(head0 == NULL) { printf("\n\n上次无学生输入！！！\n"); return NULL; } t0 = head0; while (t0 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/731b64f1523d6d071b7656550d2c919c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/025144714ca3e38cb158721160294875/" rel="bookmark">
			Internet流量监管机制之漏桶算法和令牌桶算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		漏桶算法和令牌桶算法都是为了限制应用无限制的向网络注入流量而设定的算法。两者看似区别不大，但是如果仔细来看，是有区别的：漏桶算法只能把应用的输出速率限定在一个固定的速度，但是令牌桶除了在把总的输出速率限制在一定范围内，还能容忍一定时间的高速率突发流量。
上图为漏桶算法的示意图。漏桶算法的原理是：将主机用户进程输出的不规则包流转换为输入网络的均速包流，主机和网络的接口就是一个漏桶，漏桶就是一个有限的内部队列。
从桶底小孔向外漏的速率恒定，一旦桶空外漏速率为0，一旦满水就从上面溢出。也就是说，漏桶的上方的应用注入到漏桶里面的速率是随意的，只不过经过流量整形，输出到网络中的速率永远是一定的，和漏桶的底部大小有关。并且，当输入速率大于输出速率的时候，桶里面会堆积，堆积的过多，当大于桶的容量之后，就会出现溢出的现象，也就是数据丢包。这也是漏桶算法的一个缺点。它的最重要特征是输出速率是恒定的，这也是区别于令牌桶的根本。
令牌桶算法：
令牌桶示意图如上所示：它的思想是，令牌桶以一定速率生成令牌，只有在令牌桶里面有令牌时才能发送包，每发送一个包漏桶内的令牌数减1，令牌桶满时新产生的令牌将被丢弃。所以当突发大量流量的时候，因为令牌桶里面之前存有一定数量的令牌，那么可以首先以很高的速率发送数据包。当令牌桶里面的令牌消耗完毕之后，它只能按照令牌生成的速率来发送剩余的数据包了。
比如令牌桶容量b=250KB，令牌到达速率r=2MBps，网络最大传输率M=25MBps。假设突发数据长为1MB，到达时令牌桶已满，那么令牌桶流量整形情况是怎么样的呢？
首先肯定的一点是，令牌桶整形的速率首先是25MBps,之后一段时间后变成2MBps. 那么各自花了多长时间呢？ 设突发时间为s；则突发数据最大输出为b＋r · s。 可得b＋r · s= M · s。 所以解得s=10.8ms。 在s秒内以25MBps的速率突发一部分，其余的数据只能以2MBps的速率发送，这种速率持续了T s,直到发送结束。 那么 T= （1-25MBps * s）/2MBps = 364ms。输出流量示意图如下：
令牌桶和漏桶算法的区别是：令牌桶算法可积累发送数；桶满时会丢失令牌而不会丢失包。但是他们都可以进行基本的流量整形，使得网络应用不至于一下子把自己的流量全都注入网络造成的严重的拥塞和丢包事件。
延伸阅读
TCP协议的流量控制 数据链路层的流量控制
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08f8abaa484c99d17bf23cc1a0d8337b/" rel="bookmark">
			MFC：获取和设置控件文本（GetDlgItemText和SetDlgItemText）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 GetDlgItemText：获取给定控件的文本。
语法
virtual int GetDlgItemText( int nID, LPTSTR lpStr, int nMaxCount ) const; 参数
nID：控件的标识符，也就是控件的ID。
lpStr：与控件文本的指针，也就是控件文本中的内容，你需要获取的东西。
nMaxCount：在字符指定最大长度，要复制的，该字符串就缓冲区指向由 lpStr。如果该字符串的长度超过限制，字符串被截断。
返回值
如果函数成功，则返回值指定字符数复制到缓冲区，不包括终止null字符）。
如果函数失败，则返回值为零。若要扩展的错误信息，调用 GetLastError。
示例
CString str_id(_T("")); GetDlgItemText(IDC_EDIT_ID, str_id);//获取帐号 CString str_password(_T("")); GetDlgItemText(IDC_EDIT_PASSWORD, str_password);//获取密码 SetDlgItemText：将指定控件的文本，使用在 lpszString包含的文本。
语法
virtual void SetDlgItemText( int nID, LPCTSTR lpszString ); 参数
nID：控件的标识符。
lpszString：与控件文本的指针。
示例
SetDlgItemText(IDC_EDIT_ID,_T("请输入帐号")); SetDlgItemText(IDC_EDIT_PASSWORD, _T("请输入密码")); 或者也可以另外一种方式获取和设置控件文本
((CEdit*)GetDlgItem(IDC_EDIT_ID))-&gt;GetWindowText(str_id); ((CEdit*)GetDlgItem(IDC_EDIT_PASSWORD))-&gt;GetWindowText(str_password); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d92cd5e10033e421023be0db56750d80/" rel="bookmark">
			Vue不能检测数组或对象变动问题的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来看一个实例：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue&lt;/title&gt; &lt;script src="https://unpkg.com/vue@2.3.3/dist/vue.js"&gt;&lt;/script&gt; &lt;style&gt; li:hover { cursor: pointer; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="wrap"&gt; &lt;ul&gt; &lt;li v-for="item,index in items" v-on:click="handle(index)"&gt; &lt;span&gt;{{item.name}}&lt;/span&gt; &lt;span&gt;{{numbers[index]}}&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: ".wrap", data: { numbers: [], items: [ {name: 'jjj'}, {name: 'kkk'}, {name: 'lll'}, ] }, methods: { handle: function (index) { // WHY: 更新数据，view层未渲染，但通过console这个数组可以发现数据确实更新了 if (typeof(this.numbers[index]) === "undefined" ) { // 注：下面这么设置是可以的。例如 // var arr = []; // arr[3]=3; // console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d92cd5e10033e421023be0db56750d80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bec0b34972c4a3b183bcb582efea4de/" rel="bookmark">
			【深度相机系列八】深度相机：想说爱你不容易
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过前面一系列的文章，我们已经了解了深度相机的原理及其广泛的应用。看起来深度相机貌似是一种完美产物。可是稍微有点哲学思维的读者都知道，世界上不存在绝对完美的物体，万物都有两面性，而这两个方面是既对立又统一的。
那么深度相机光辉的一面背后，是否也隐藏有一些不为人知的坑？
答案是肯定有，而且挺深。
下面我们来探讨一下：深度相机在应用开发上有哪些需要特别注意的坑。
从《深度相机哪家强？附详细参数对比清单》里最后的参数对比清单中，我们发现在消费级深度相机产品中，结构光原理的深度相机具有绝对的数量优势，加上iPhone X的前置深度相机也采用了结构光，这无疑给移动端厂商释放了信号，预计2018年出货的带深度相机的手机也会大概率沿用结构光原理的深度相机解决方案。
因此，我们抓主要矛盾，主要探讨结构光深度相机到底埋了哪些坑。
黑色物体的影响 先给出结论：
基于红外的结构光深度相机对深色（尤其是黑色）物体的测量一般不准确，甚至测量失败（没有深度值）。
如果不关心原因，可以跳过这一节后续内容，直接进入下一节。
下面是具体解释：
我们首先从物体的颜色说起。我们看到的物体的颜色是由于物体对不同波长的光具有选择性吸收而产生的。这个原理可以通过化学实验直观的观察到：当一束白光照射某溶液时，若溶液不吸收可见光，则白光全部通过，溶液呈现无色透明；若溶液吸收了某种颜色的单色光，那它就呈现出被吸收光的互补光。而溶液颜色的深浅，取决于浅溶液中吸光物质的浓度。
那么什么是互补光呢？
可以简单理解如下：如果两种不同颜色的单色光按一定的强度比例混合可以得到白光，那么就称这两种单色光为互补色光，这种现象称为光的互补。下图右中连线的两端构成互补光。
举个例子吧，更容易理解：
根据上图，我们知道黄光（波长580-610nm）的互补光是蓝光。因此，一束白光入射到某溶液，如果该溶液吸收了白光中的黄光，那么该溶液的表观颜色就是被吸收的黄光的互补光，也就是蓝色。如下图所示：
物体对光的选择性吸收决定了物体本身的颜色
因此，不难推断，如果溶液对可见光全部吸收，溶液就会呈现黑色。
而结构光一般采用的是人眼不可见的近红外光，它也是可以被物体吸收的。只不过因为其本身是不可见光，人眼无法直接观察到红外光被吸收的现象。
但是通过红外成像传感器我们很容易观察到红外光被吸收的现象。
如下图所示，被测物体表面不同颜色（现在我们知道是不同物质对不同光的吸收不同）对结构光深度相机成像的影响。从图中可以明显看出深色物体（尤其是黑色物体）对红外光的吸收能力非常强，这导致投射在黑色物体上的红外光无法返回，红外成像传感器因为无法接收到返回的红外光，因此也就无法测量物体的深度。
红外散斑图（左）及其彩色图（右）
但是，这里要补充一点，虽然黑色物体都能够吸收可见光，但并不是所有的黑色物体都能够吸收红外光（虽然接近可见光波长）。不过从概率上讲，黑色物体既然能够吸收大量的可见光，那它能够吸收红外光的概率还是很高的。
好吧，绕了这么大一圈。我们终于明白了为什么红外结构光对黑色物体的测量很多时候是无能为力的。下面给出一个实例，直观感受一下。下图右红框内黑色表示无深度值，可以看到黑色的椅子背靠和支撑腿都没有深度值。
彩色图（左）及对应深度图（右）：黑色物体的影响
光滑物体表面反射的影响 老规矩，先给结论：
当物体表面超过一定的光滑程度时，深度相机测量精度会急剧下降，甚至测量失败（没有深度值）。
赶时间的可以跳过该小节后续内容，对原因感兴趣的可以继续往下看。
让我们的思绪飞回到初中物理课题上，物理老师正在讲解光线的镜面反射和漫反射原理。他在黑板上画出了如下两张图。
漫反射和镜面反射示意图
上图左是漫反射示意图，指的是投射在粗糙表面上的光向各个方向反射的现象。当一束平行的入射光线射到粗糙的表面时，表面会把光线向着四面八方反射，所以入射线虽然互相平行，但由于各点的法线方向不一致，造成反射光线向不同的方向无规则地反射。
自然界几乎所有的物体表面都符合漫反射条件，比如大气层、动植物、地面、墙壁、衣服等，有些物体表面粗看起来似乎很平滑，但用放大镜仔细观察，就会看到其表面其实是凹凸不平的。因此本来是平行的太阳光被这些表面反射后，弥漫且随机的地射向不同方向。
漫反射是物体可以清晰成像的基础，因此我们从不同角度看同一物体，都能看的比较清楚。因此，深度相机中的成像端能够接收到足够的光线，从而清晰的成像。
而相比之下，镜面反射发生在物体表面（接近）绝对光滑的情况下，比如水面、镜子、抛过光的金属表面等。当物体表面发生镜面反射时，只有当被测物体位于深度相机的发射端和接收端（成像端）的中垂线时，才能接收到反射光线，并且强度很集中，容易发生过度曝光；而其他情况下能够接收到的反射光线非常少，无法成像。
下面给出一个实例，直观感受一下。下图左中光滑的桌面在下图右红框中对应的深度值是无效的（右图中黑色表示没有深度值）。
彩色图（左）及对应深度图（右）：光滑表面反射的影响
透明物体透射的影响 我们知道红外光是可以轻松穿透普通透明玻璃的。所以除了前面提到的反射的影响，红外光在一定条件下还可能产生透射现象，这会给红外结构光深度相机带来新的问题：我称之为深度值的歧义性。
我们想象深度相机投射出一束红外光到一块普通的玻璃上，这束红外光不会发生镜面反射，它会穿透玻璃继续前行，如果透过玻璃后能够在有效测量范围内遇到其他物体并反射回红外光，那么此时深度相机测量的深度值其实是玻璃后面物体距离相机的距离，并不是玻璃表面距离相机的距离。更悲剧的是，很多时候光线透过玻璃后是一个开阔空间，透射过玻璃的红外光线就变成了“肉包子打狗，有去无回”，因此没有对应的深度值。如下图所示。
彩色图（左）及对应深度图（右）：玻璃透射的影响
视差的影响 结构光深度相机的发射端和接收端通常有一定的间距，因此在物体的边缘会存在一定的视觉盲区。这对于较远的物体边缘影响不大，但是对于近距离的物体边缘影响较大，会产生无效深度值的类似阴影的区域（如下图红框内所示）。
彩色图（左）及对应深度图（右）：视差的影响
以上是几种比较常见的坑，此外还有很多小坑，比如红外光点恰好打在物体边缘造成的边缘深度不准确等。
好吧，关于深度相机的坑就说到这儿吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed0574f8ea3f2110937cf46e856ff4fb/" rel="bookmark">
			redis 查看所有键值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		zb@zb-computer:/home/wwwroot/default/lion/Admin$ /usr/local/redis/bin/redis-cli 127.0.0.1:6379&gt; keys * 1) "CAOMALL_doctor::13391840644" keys * 转载于:https://www.cnblogs.com/pansidong/p/8296812.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9508248951329c6ba878af1756fde2d1/" rel="bookmark">
			Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX AVX2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tensorflow学习过程中，很多同学会遇到如下问题，是当前tensorflow版本兼容问题，如下继续进行，需要执行，如下命令：
import os
os.environ[‘TF_CPP_MIN_LOG_LEVEL’] = ‘2’
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7429d969f47105dbeef28284a1f29fa7/" rel="bookmark">
			React-router在混合应用开发中的注意事项。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近有一些朋友，使用react+cordova进行打包，但是使用过程中遇到很多问题，比如初始页面无法加载的问题，这里写个博客分享一个：
路由 react项目中，我们最经常使用的路由控制时react-router（3.x）,当然现在有最新版本我们不做讨论。
传统的使用如下：
import { Router, browserHistory } from 'react-router'; const bootstrap = () =&gt; { const store = configureStore(); render( &lt;Provider store={store}&gt; &lt;Router history={browserHistory} routes={getRoutes(store)} /&gt; &lt;/Provider&gt;, document.getElementById('root') ); }; bootstrap(); 上面我们看到我们使用browserHistory初始化路由，开发测试过程中，浏览器端（运行在server上）正常运行，没有任何问题，可以抛开服务，在client端运行，比如cordova打包，就是无法显示初始页面，也没有任何错误。
对此我们需要替换 browserHistory 为hashHistory.
代码如下：
import { browserHistory, hashHistory } from 'react-router'; export default function getHistoryRouter() { if (window.cordova) { return hashHistory; } return browserHistory; } 以上代码我们区分了在服务端与客户端使用不同的history, 到此问题解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e89607bb9b3b23c255f0f410776a3a0/" rel="bookmark">
			常见的MIME类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的MIME类型 超文本标记语言文本 .html,.html text/html 普通文本 .txt text/plain RTF文本 .rtf application/rtf GIF图形 .gif image/gif JPEG图形 .jpeg,.jpg image/jpeg au声音文件 .au audio/basic MIDI音乐文件 mid,.midi audio/midi,audio/x-midi RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio MPEG文件 .mpg,.mpeg video/mpeg AVI文件 .avi video/x-msvideo GZIP文件 .gz application/x-gzip TAR文件 .tar application/x-tar
参考：http://baike.baidu.com/view/160611.htm
格式前面为后辍名，后面为对应的MIME型（例如：rar application/x-rar-compressed 表示.RAR对应的是application/x-rar-compressed ） application/vnd.lotus-1-2-3 3gp video/3gpp aab application/x-authoware-bin aam application/x-authoware-map aas application/x-authoware-seg ai application/postscript aif audio/x-aiff aifc audio/x-aiff aiff audio/x-aiff als audio/X-Alpha5 amc application/x-mpeg ani application/octet-stream asc text/plain asd application/astound asf video/x-ms-asf asn application/astound asp application/x-asap asx video/x-ms-asf au audio/basic avb application/octet-stream avi video/x-msvideo awb audio/amr-wb bcpio application/x-bcpio bin application/octet-stream bld application/bld bld2 application/bld2 bmp application/x-MS-bmp bpk application/octet-stream bz2 application/x-bzip2 cal image/x-cals ccn application/x-cnc cco application/x-cocoa cdf application/x-netcdf cgi magnus-internal/cgi chat application/x-chat class application/octet-stream clp application/x-msclip cmx application/x-cmx co application/x-cult3d-object cod image/cis-cod cpio application/x-cpio cpt application/mac-compactpro crd application/x-mscardfile csh application/x-csh csm chemical/x-csml csml chemical/x-csml css text/css cur application/octet-stream dcm x-lml/x-evm dcr application/x-director dcx image/x-dcx dhtml text/html dir application/x-director dll application/octet-stream dmg application/octet-stream dms application/octet-stream doc application/msword dot application/x-dot dvi application/x-dvi dwf drawing/x-dwf dwg application/x-autocad dxf application/x-autocad dxr application/x-director ebk application/x-expandedbook emb chemical/x-embl-dl-nucleotide embl chemical/x-embl-dl-nucleotide eps application/postscript eri image/x-eri es audio/echospeech esl audio/echospeech etc application/x-earthtime etx text/x-setext evm x-lml/x-evm evy application/x-envoy exe application/octet-stream fh4 image/x-freehand fh5 image/x-freehand fhc image/x-freehand fif image/fif fm application/x-maker fpx image/x-fpx fvi video/isivideo gau chemical/x-gaussian-input gca application/x-gca-compressed gdb x-lml/x-gdb gif image/gif gps application/x-gps gtar application/x-gtar gz application/x-gzip hdf application/x-hdf hdm text/x-hdml hdml text/x-hdml hlp application/winhlp hqx application/mac-binhex40 htm text/html html text/html hts text/html ice x-conference/x-cooltalk ico application/octet-stream ief image/ief ifm image/gif ifs image/ifs imy audio/melody ins application/x-NET-Install ips application/x-ipscript ipx application/x-ipix it audio/x-mod itz audio/x-mod ivr i-world/i-vrml j2k image/j2k jad text/vnd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e89607bb9b3b23c255f0f410776a3a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8b7980f513b2147a91b44f4ff346f98/" rel="bookmark">
			winForm如何调用WebApi接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为本人接触的项目属于C/S结构的偏多，一直没有机会接触webApi,所以一直觉得webApi很神秘。刚好最近有时间，所以我就在网上搜了一些webApi的资料，然后结合winform写了一个Dome:
WebApi
winform
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39d861c90bcc3017adab3c342da293ed/" rel="bookmark">
			在Caffe中使用Python Layer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://blog.csdn.net/liuheng0111/article/details/53090473
http://blog.csdn.net/thesby/article/details/51264439
Caffe通过Boost中的Boost.Python模块来支持使用Python定义Layer： 使用C++增加新的Layer繁琐、耗时而且很容易出错 开发速度与执行速度之间的trade-off 编译支持Python Layer的Caffe 如果是首次编译，修改Caffe根目录下的Makefile.cinfig，uncomment
1 WITH_PYTHON_LAYER:=1 如果已经编译过
1 2 make clean WITH_PYTHON_LAYER=1 make&amp;&amp; make pycaffe 使用Python Layer 在网络的prototxt文件中添加一个Python定义的loss层如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 layer{ type: ’Python' name: 'loss' top: 'loss' bottom： ‘ipx’ bottom: 'ipy' python_param{ #module的名字，通常是定义Layer的.py文件的文件名，需要在$PYTHONPATH下 module: 'pyloss' #layer的名字---module中的类名 layer: 'EuclideanLossLayer' } loss_weight: 1 } 定义Python Layer 根据上面的要求，我们在$PYTHONPAT在创建pyloss.py，并在其中定义EuclideanLossLayer。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import caffe import numpy as np class EuclideadLossLayer(caffe.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39d861c90bcc3017adab3c342da293ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20adf35b706f9fe099a52bb867567992/" rel="bookmark">
			mui html 手机物理返回键的监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //首页返回键处理 //处理逻辑：1秒内，连续两次按返回键，则退出应用； var first = null; mui.back = function() { //首次按键，提示‘再按一次退出应用’ if (!first) { first = new Date().getTime(); mui.toast('再按一次退出应用'); setTimeout(function() { first = null; }, 1000); } else { if (new Date().getTime() - first &lt; 1000) { plus.runtime.quit(); } } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6beb97ee418085a15d7335507a58c6f/" rel="bookmark">
			jQuery  on()方法实现原理（事件委托）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery on()方法实现原理（事件委托）&lt;/title&gt; &lt;style&gt; #list li{ margin: 20px; width: 200px; height: 50px; background: yellowgreen; font-size: 30px; line-height: 50px; text-align: center; color: #fff; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id="list"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; &lt;!-- 1.data 是一个对象,给e增加一个属性data存储这个值 2.str 处理预留事件,事件委托,str要作为事件源 3.str只要是传了,此时事件源必须是str才可以执行绑定的函数,并且要把函数中的this变当前事件源 4.str没传,直接执行绑定的函数,函数中的this就给on方法中的this --&gt; &lt;script type="text/javascript"&gt; EventTarget.prototype.on=function (type,...arg) { let str,data,callback; arg.forEach((item)=&gt;{ //str要么是一个false要么是一个字符串 typeof item=="string"?str=item:item.toString()=="[object Object]"?data=item: typeof item=="function"?callback=item:null; }); function run(e) { if(data)e.data=data; if(str){ if(e.target.tagName==str.toUpperCase()){ callback&amp;&amp;callback.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6beb97ee418085a15d7335507a58c6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aca8b0b922d1a9c633cc3ecb3b737d0b/" rel="bookmark">
			在SVN服务器上某个目录下删除了一个项目，该目录下的其他项目也消失了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SVN的错误，跪求高手帮忙！！！！
操作过程：
1.在SVN服务器上的目录develop下有a、b、c 三个项目，我删除了a项目（右键delete）
2.在 开发工具myeclipse上同步了一下a项目，发现报错。
3.在SVN服务器上develop目录变成了一个空目录，即该目录下原有的项目a、b、c全都没有了。
4.点击develop,出现错误，failed to load module for FS type 'bdb' 。如下图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/434b4f5d77f72b5912cadffc9862a25a/" rel="bookmark">
			MMO网游系统划分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.UI系统 2.邮件系统 3.任务系统 4.战斗系统 5.网络通讯系统 6.结算系统 7.热更新系统 8.商店系统 9.角色系统 10.换装系统 11.地形系统 12.背包系统 13.聊天系统 14.登录系统 15.技能系统 16.PK系统 17.副本系统 18.画质系统 19.收集系统 20.结婚系统 21.宠物系统 22.寻路系统 23.地图系统 24.多语言系统
25.对话系统
26.变强系统
27.后宫系统
28.。。。（欢迎留言补充QAQ）
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/519/">«</a>
	<span class="pagination__item pagination__item--current">520/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/521/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>