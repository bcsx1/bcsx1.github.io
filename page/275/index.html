<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05f27ea068c0bfeb225eee9f7534f1fc/" rel="bookmark">
			js 赋值 react input的输入框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 js 赋值 react input的输入框
javascript:(function () { setNativeValue = function (qs, value) { const element = document.querySelector(qs); const valueSetter = Object.getOwnPropertyDescriptor(element, 'value').set; const prototype = Object.getPrototypeOf(element); const prototypeValueSetter = Object.getOwnPropertyDescriptor(prototype, 'value').set; if (valueSetter &amp;&amp; valueSetter !== prototypeValueSetter) { prototypeValueSetter.call(element, value) } else { valueSetter.call(element, value) } element.dispatchEvent(new Event('input', {bubbles: true})) }; setNativeValue('#basic_username', 'Hello World'); })(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3beef37ca6e171b00cbc5e6b1cae4022/" rel="bookmark">
			查看mysql数据库的各种编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SHOW VARIABLES LIKE 'character_set_%'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08548fbdaf1994f3a536f51a3db2916a/" rel="bookmark">
			ubuntu下最好用的截图工具flameshot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、下载安装flameshot二、设置快捷键三、高级选项：flameshot 命令行选项 一、下载安装flameshot sudo apt install flameshot 二、设置快捷键 打开 系统设置-&gt; 设备 -&gt; 键盘 拉到最下方，点击加号（红框中就是我所设置自定义的flameshot快捷键了）
名称可以随便起，命令是：flameshot gui,再按照自己喜欢设置快捷键。
三、高级选项：flameshot 命令行选项 Flameshot 支持一系列的命令行选项来延时截图和保存图片到自定义的路径。
要使用 Flameshot GUI 模式，运行：
flameshot gui 要使用 GUI 模式截屏并将你选取的区域保存到一个自定义的路径，运行：
flameshot gui -p ~/myStuff/captures 要延时 2 秒后打开 GUI 模式可以使用：
flameshot gui -d 2000 要延时 2 秒并将截图保存到一个自定义的路径（无 GUI）可以使用：
flameshot full -p ~/myStuff/captures -d 2000 要截图全屏并保存到自定义的路径和粘贴板中使用：
flameshot full -c -p ~/myStuff/captures 要在截屏中包含鼠标并将图片保存为 PNG 格式可以使用：
flameshot screen -r 要对屏幕 1 进行截屏并将截屏复制到粘贴板中可以运行：
flameshot screen -n 1 -c 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a338fdea1a82bf60401bc0b9b3c932b9/" rel="bookmark">
			51单片机 智能婴儿监护系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		成果展示 1、整体设计框架 2、电路设计 3、程序流程设计 主程序： void main() { uint sy_count1 = 0; uint sy_count2 = 0; uint yuyin = 0; bit flag = 0; char xdata SEND_BUF[]="心率:000,温度:00.0C\r\n"; time_init();//定时器初始化 lcd_init();//1602初始化 lcd_write_str(0, 0, " CLOSE 00.0C"); lcd_write_str(0, 1, "MS: ZIDONG 000"); uart_init(9600); while(1) { keyscan(); if(setn == 0) { if(Mode == 0)//在自动模式下 { if(Voice == 0)//检测到有声音 { if(sy_count1++ &gt; 10)//检测哭声是否延续 { DJ_TIME = 60;//电机开启时间1分钟 openFlag = 1;//电机开启 sy_count1 = 0; if(ShiDu==0)Line_1A(1);//播放歌曲 } } else { if(sy_count2++ &gt; 200) { sy_count2 = 0; sy_count1 = 0; } } } if(ShiDu==1)//检测到尿不湿湿了 { LED = 0; if(flag == 0)//只播放一次 { flag = 1; Line_1A(0);//播报 yuyin = 0; } if(flag==1) { if(yuyin++ &gt; 400) { yuyin = 0; Line_1A(0);//播报 } } } else { LED = 1;flag = 0; } if(openFlag==1)//电机开启 { lcd_write_str(0, 0, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a338fdea1a82bf60401bc0b9b3c932b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2293c56b38a9785fbb05d3bbc262b042/" rel="bookmark">
			DFX网上文章综合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 DFx简介
DFX是Design for X(面向产品生命周期各环节的设计)的缩写，其中X代表产品生命周期的某一环节或特性，如可制造性（Ｍ－Manufacturability）、可装配性(A-Assembly)、可靠性(R- Reliability)等。 DFX主要包括：可制造性设计DFM: Design forManufacturability，可装配性设计DFA: Design forAssembly，可靠性设计DFR: Design forReliability，可服务性设计DFS: DesignforServiceability，可测试性设计DFT: Design for Test，面向环保的设计DFE: Design for Environment等。
DFX设计方法是世界上先进的新产品开发技术, 这项技术在欧美大型企业中应用非常广泛, 指在产品开发过程和系统设计时不但要考虑产品的功能和性能要求, 而且要同时考虑产品整个生命周期相关的工程因素，只有具备良好工程特性的产品才是既满足客户需求，又具备良好的质量、可靠性与性价比产品，这样的产品才能在市场得到认可。DFM是DFX中最重要的部分，DFM就是要考虑制造的可能性、高效性和经济性，DFM的目标是在保证产品质量与可靠性的前提下缩短产品开发周期、降低产品成本、提高加工效率。DFX在电子产品设计中的出现有其深刻的历史背景，这是由于电子产品竞争越来越激烈，公司必须保证产品能够快速、高质量的进入市场，适应电子产品短生命周期的要求。
2、电子产品设计中采用DFX的意义
DFX的目的是提倡在产品的前期设计中考虑包括可制造性、可装配性等相关问题。传统的电子产品开发方法通常是设计---生产制造---销售各个阶段串行完成。由于设计阶段没有全面考虑制造要求，加之设计人员对工艺知识的欠缺，总会造成在产品生产时出现这样那样的问题，如元器件选择不当、PCB设计缺陷等，导致设计方案多次修改、PCB不断改板、生产多次验证等，使得产品开发周期延长、成本增加、质量和可靠性得不到有效保证。
DFX基于并行设计的思想，在产品的概念设计和详细设计阶段就综合考虑到制造过程中的工艺要求、测试要求、组装的合理性，同时还考虑到维修要求、售后服务要求、可靠性要求等，通过设计手段保证产品满足成本、性能和质量的要求。DFX不再把设计看成为一个孤立的任务，利用现代化设计工具和DFX分析工具设计具有良好工程特性的产品。图1所示为电子产品传统设计流程与DFX设计流程的对比，通过DFX设计可以减少产品的更改次数、缩短产品上市周期、降低产品成本、提高产品质量与可靠性，将问题解决在设计阶段，而不是让问题产品进入市场后才发现，造成巨大的浪费和损失！
根据相关统计，电子产品成本的70%是在设计阶段就决定了，设计缺陷流到后端，其解决费用会成百倍的增加，因此越来越多的公司开始关注DFX。
图1 电子产品传统设计流程与DFx设计流程的对比
3、业界领先公司的DFX设计
成功实施DFX的一个关键因素就是要尽早与DFX设计团队进行沟通。在项目正式启动前就要经常进行工程讨论。在该阶段，就基本确定了产品特性和元器件。通过真正将DFX活动集成到公司文化和每个产品的开发活动中，就能将效益最大化，保证最终产品具备量产和盈利能力。当DFX集成到产品开发流程中时，其执行力度会得到大大地加强，这一工作的基础就是要公司上层管理者的支持，当管理层确认DFX是产品设计中非常必要的工作时，执行推动起来就很容易了。
在思科，成立了一个团队开发“大工程方法论”（简称GEM，Great EngineeringMethodology）流程。该流程定义了思科开发产品所必须的各个步骤，所有的产品开发项目都必须利用该流程模板，它包括必须达成的关键里程碑、团队功能和文档，图2所示为思科公司基于DFX设计的产品开发流程，它描述了产品从概念阶段一直到生命周期终结的整个开发周期。漏斗型代表需求的收集，中间部分代表产品的开发，右侧部分代表产品的应用周期。
图2 思科公司基于DFX设计的产品开发流程
流程中关键里程碑包括：产品需求文档（PRD），它定义了产品的设计需求；概念交付会议（CC）；设计实施交付会议（EC）；制造和测试计划定义（制造计划）；工程设计验证测试（DVT）；技术就绪评审（TRR）；订单就绪评审（ORR）；原型机生产；DFX评审；产品发布生产；试制；可靠性验证测试（RDT）；常规可靠性测试（ORT）；产品首次发货（FCS）；达到质量和生产量要求的时间（TTQV）和产品开发后评估（PPA）。思科公司基于DFX设计的产品开发流程是并行的开发流程。在流程中，DFX的评审意见反馈贯穿在整个开发活动中，它们需要尽早地得到更改实施，而不是等到相应活动结束后再反馈或更改。
华为技术有限公司在产品开发中采用集成产品开发IPD（Integrated Product Development）方法, 最先将IPD付诸实践的是IBM公司，1992年IBM在激烈的市场竞争下，遭遇到了严重的财政困难，公司销售收入停止增长，利润急剧下降。经过分析，IBM发现他们在研发费用、研发损失费用和产品上市时间等几个方面远远落后于业界最佳。为了重新获得市场竞争优势，IBM提出了将产品上市时间压缩一半，在不影响产品开发结果的情况下，将研发费用减少一半的目标。为了达到这个目标，IBM公司率先应用了集成产品开发（IPD）的方法，在综合了许多业界最佳实践要素的框架指导下，从流程重整和产品重整两个方面来达到缩短产品上市时间、提高产品利润、有效地进行产品开发、为顾客和股东提供更大价值的目标。
IBM公司实施IPD的效果不管在财务指标还是质量指标上得到验证，最显著的改进在于：（1）产品研发周期显著缩短；（2）产品成本降低；（3）研发费用占总收入的比率降低，人均产出率大幅提高；（4）产品质量普遍提高；（5）花费在中途废止项目上的费用明显减少。
在IBM成功经验的影响下，国内外许多高科技公司采用了集成产品开发（IPD）模式，如美国波音公司和深圳华为技术公司等，华为公司从1998年开始请IBM的咨询团队帮助建立IPD体系，经过10多年的引进、改进、提高，IPD在华为取得了巨大的成功，为华为成为通讯行业巨擎奠定基础。
不管是思科的GEM还是IBM、华为的IPD，其核心思想都是基于并行设计的研发流程，而DFx是其重要的核心内容和使能技术，国内一些企业实施IPD之后感觉效果不够明显，一个很重要的原因就是DFx技术方面的欠缺，由于没有DFx平台、规范、流程、方法的支持，公司又缺乏DFx方面的人才和技术积累，导致研发流程中的DFx设计与评审无法有效实施，这就是为什么IBM、华为、波音实施IPD取得了巨大成功，而有些中小型公司实施IPD之后没有达到期望的效果的主要原因。
4、结束语
DFX设计不仅是一个技术工作，还是一个管理工作，因为DFx的实施必须有流程的保证和平台的支撑，只有流程建立了，节点定义了，人员责任明确了、技术积累达到了，DFx的工作才能落实。当我们在产品研发中贯彻了DFx的思想与方法，我们会看到以下的改进：产品研发周期显著缩短、产品成本降低、花费在中途废止项目上的费用明显减少、产品质量与可靠性普遍提高、客户满意度不断提升。要达到这样的效果就需要真正将DFX方法集成到公司文化和产品开发活动中，这一工作的基础就是DFx工作要得到公司上层领导者的支持，中层管理者的组织，基层技术人员的实施。
当然在公司DFx技术积累不够、DFx人才缺乏的情况下，通过业内外部专家的咨询与协助来建立DFx体系也是快速有效的方法，华为公司的IPD流程和DFx建立就是在IBM顾问和业内各行业专家的帮助下迅速建立的。从1998年到2008年经过近10年时间华为在IBM顾问的帮助下实现了IPD在公司的落地，并使之融入到华为的文化之中，使公司在产品开发周期、产品质量、成本、响应客户需求、产品综合竞争力上都取得了根本性的改善，有力地支撑了华为快速和规模的国际化扩张。
--------------------
lDFX工作目标是提升产品综合竞争力。 功能容易复制，但产品竞争力的关键往往是DFX。 l以大家都熟知的手机为例：我们每个人都用过不止一款手机，普通品牌与国际顶级品牌相比，功能基本上差不多，但使用中总是感觉有些差距，其中关键的因素就是DFX：可靠性、性能、易用性、客户体验等，这些因素往往决定了产品的竞争力。
DFX＝“Design for X” ，表示面向产品非功能性属性的设计。其中“X”代表产品生命周期或其中某一环节，如供应、安装、维护等，也可以代表产品竞争力或决定产品竞争力的因素，如可靠性、节能减排、网络安全性等。
业界情况：
lA公司：DFX业务有很长的历史，比如可靠性，其硬件可靠性能力经过了长期的积累。主要关注的DFX是可靠性、可供应性、可制造性、节能、环境、易用性、可服务性、可重用性、可装配性、可折卸性、可测试性、可诊断性等。 lE公司：主要关注的DFX是可靠性、可测试性、可服务性、节能、环境、可供应性、可制造性等。 lC公司：生产大部分都是外包，所以其对可供应性/可制造性非常重视，同时C公司将软件可靠 性和面向网络级的HA设计看作是公司的战略方向，因此对可靠性设计非常重视。同时，C公司也重视如下DFX：安全性、互操作性、节能、可迁移性。
一级DFX包括如下10个，还有隶属于这些一级DFX的二级DFX，具体参见下页的《DFX架构培训教材》
序号
缩写
英文全称
中文名称
说明
1
DFR
Design for Reliability
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2293c56b38a9785fbb05d3bbc262b042/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e96c2bddb2115652b7616e8855243dac/" rel="bookmark">
			解决 jvm 1 Error occurred during initialization of VM Could not reserve enough space for object heap问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双击activemq.bat启动mq报以下错误时，
原因是 内存不够使用 引起的，可以通过Ctrl+Alt+Del --&gt; 任务管理器，把一些进程任务关闭以腾出空间，之后就再启动就可以了
可能还有一些其他类似的情况也可能是这种内存不租所引起的 ，比如下图的启动kafka时包的错：Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000c0000000, 1073741824, 0) failed; error='页面文件太小，无法完成操作。' (DOS error/errno=1455)
通过上面同意的方法，之后就可以启动成功了
（如果还是不可以，可以尝试另外一位博主的解决方法(47条消息) (已解决)Error occurred during initialization of VM Could not reserve enough space for object heap_Aloneii的博客-CSDN博客）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fe97183daafac40e0faff5ed4444e36/" rel="bookmark">
			【多图警告】彻底搞懂浮点数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 float类型，在很多地方没有看明白，多文字也看得人心烦。
最近不是很愿意看多文字的博客和技术文章了，但确实不是什么好事。
要改。
本文用大量图片讲解了浮点数在计算机中的存储方式以及浮点数的最值、精度等问题，文末有测试用的C++程序。
从二进制表示小数说起 我们先不让小数点“浮动”，表示12.625这个数字。
小数点左边好说，直接十进制转二进制就好了：
12-&gt;1100
小数点右边呢？
其实和十进制一样，二进制的小数点左边从左到右分别表示的是23、22、21、20，现在跳到小数点右边，自然也就有了2-1、2-2、2-3……这和我们早就熟悉了的十进制小数也是一样的思想，只不过二进制只有0、1两种数字。
再到科学计数法 十进制的科学计数法是人人都会了：
12.625 ( 常 规 表 示 ) = 1.2625 × 1 0 1 ( 常 规 科 学 计 数 法 ) = 1.2625 E 1 ( 源 码 中 的 表 示 法 ) 12.625(常规表示)=1.2625\times10^{1}(常规科学计数法)=1.2625E1(源码中的表示法) 12.625(常规表示)=1.2625×101(常规科学计数法)=1.2625E1(源码中的表示法)
然而计算机很憨，不认识十进制，只能存储二进制，二进制1100.101的科学计数法如何表示呢？
把十进制的思想直接用上就好，只不过底数要从10改成2：
浮点数在计算机中的存储方式 顺着讲下来，想必也能看出来浮点数在二进制中是通过二进制的科学计数法存储的了，我们需要的有这么三部分：
符号。表示浮点数的正负号，1bit足够；数字部分（尾数部分）。即上图中蓝色的部分，因为除了0以外，蓝色数字部分小数点左边的首位都是1，所以我们直接存储小数点后面的部分，即尾数部分（本例为100101）。指数部分。即上图中红色的部分，是一个有符号整数（本例为3）。 我们以4字节的float为例：
符号位。占1bit，0表示正数，1表示负数；
指数部分。占后续的8bit，以+127偏移的方式存储，比如指数部分若为-3，则存储为130（10进制），即二进制的1000 0010；
为什么指数部分以偏移的方式存储而非以二进制补码方式存储？
尾数部分。占后续的23bit，本例中为100101；
总结：记符号位为Sign，指数部分为Exponent，尾数部分为Fraction，则浮点数为：
注：指数部分的0x00、0xff特殊值在下一节讲。
8字节的double双精度浮点数，符号位不变，指数部分变为11bit，尾数部分变为52bit，其他同理。
浮点数的特殊值和最值 本节回答这么几个问题：
浮点数最大（绝对值最大）可以表示到什么值？浮点数如何处理越界的值？浮点数如何表示0？ 指数部分的特殊值： 0xff 和 0x00 浮点数标准规定1111 1111(0xff)被留作特殊值用，对于越界的无法处理的值，也就是inf或-inf（infinity），尾数部分均为0。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fe97183daafac40e0faff5ed4444e36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4ad5a6f9d4f72b1ed663f77614c64a6/" rel="bookmark">
			JavaWeb学习：session
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于Session： 图1
session的话，是将数据保存在服务端的，是服务端的会话跟踪技术。关于session的原理，其实session是基于cookies实现的。
假设服务端写了两个servlet，一个是servlet_a，一个是servlet_b。
此时在servlet_a中创建一个session对象，并对session对象赋值；然后在servlet_b中可以通过getAttribute的方法获取到servlet_a中的数据。
这就是session传输数据的基本过程，但是怎么保证servlet_a与servlet_b调用的是同一个session呢？
此处就用到了cookies，当servlet_a创建完session之后，会在给客户端响应的时候返回一个set-cookie的值，当下一次客户端发送请求到servlet_b的时候，会同时发生这个session的cookie值。从而保证servlet_a与servlet_b访问的是同一个session。这也是为什么说session是基于cookie的。
图2
session主要工作流程前面已经简单叙述过了，现在让我们来看一看具体的代码实现。主要用的方法如图2所示，具体代码如下图。
图3
这是创建的servlet demo1，具体在demo1中实现session的获取与数据的储存，其中需要注意的是，在给session里面储存数据时，使用的是键值对的数据类型，但value部分的数据类型不止是字符串类型，可以是任何类型，当我们查看此方法的源代码时（如图4）可以看到，value部分的数据类型是object。
图4
图5
在图3中我们创建好了session对象，这时我们在servlet-demo2中访问该数据，从而达到两个servlet之间数据的交流。可以将数据打印出来查看是否是同一个seesion的值。
图6
session的使用细节 session钝化与活化： 正常关闭重启：（下述内容为正常实验观察钝化与活化的过程）
首先重启tomcat： 在tomcat中用ctrl_c停止,依此输入(windows下）
cd ..
cd cookie-demo
mvn tomcat7:run(注意这里是用的你自己配置的tomcat的版本）
再访问用来创建session对象的servlet
再结束tomcat服务 ctrl c（等待一会儿）
出现提示，选择“Y”，终止操作。
再次启动服务器 tomcat命令行输入“mvn tomcat7:run(注意这里是用的你自己配置的tomcat的版本）”
然后直接访问使用demo1中session的demo2，并输出session值来观察session是否变化。 注意：不用再次访问demo1.
结果可以看见session值还在。
————————————————————————————
这是因为在正常关闭之下，tomcat会执行tomcat的钝化与活化（如图6）并且再次活化时，存入文件的session值会在加载之后自动删除。
即！正常重启，session是不会丢失的（但还是有时间限制）
—————————————————————————————
还有一种情况：
demo1创建session1，然后关闭浏览器，再打开浏览器，demo2获取session2，此时的sessio1与session2就不是一样的了。因为关闭浏览器后，再次产生的会话就不是同一个会话了，因此cookie值代表的ID也就不一样了。
因此，若是需要共享session，通过session传递数据，那在需要的期间，浏览器都不能关闭。
即session是不能长期地储存数据的。
question：那直接关闭浏览器就不算是正常关闭了吗？
session的销毁： 两种销毁方式，如图6所示。
默认的自动销毁时间是30分钟，可以到web.xml文件中自行定义从而改变默认值。session自己调用invalidate（）方法就自己把自己销毁了，里面的数据就没有了。 图7
关于session与cookie的区别 ： 有如图7所示的5点。
关于安全性：因为cookie是将数据存储在客户端的，在发请求的时候会多次在客户端与服务端之间进行传递，然而传递就会容易被半路截住，而session就一直呆在服务端里，在家里总是比出门要安全的多的。
所以，根据他俩的区别，一般我们在运用的时候
购物车数据：C
账户信息：S
登录账号密码输入：C（确实需要安全性，但是session不能长时间记住嘛，那就给cooki里的数据加密吧）
验证码：S
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54f5b721d34900745885cdf6f600c30c/" rel="bookmark">
			ACL理论及简单配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用意义 ACL可以通过定义规则来允许或者拒绝流量的通过。
如图所示，192.168.1.0网段的社交场所为只能够进入公网，而不能够进入服务器，这个时候我们在路由器或者是三层交换机上（带路由功能的交换设备）上配置ACL策略，在192.168.1.0网段的数据包发送到RTA的时候会在入网口进行检测，从而判断能否让该（IP/MAC/端口）通过。
1.ACL是由一系列规则组成的集合。设备可以通过这些规则对数据包进行分类，并对不同类型的报文进行不同的处理。
2.本示例中，网关RTA允许192.168.1.0/24中的主机可以访问外网，也就是Internet;而192.168.2.0/24中的主机则被禁止访问Internet。对于服务器A而言，情况则相反。网关允许192.168.2.0/24中的主机访问服务器A但却禁止192.168.1.0/24中的主机访问服务器A。
ACL运用的位置： 路由器上、防火墙、三层交换机上
路由器上就叫ACL !
防火墙上一般称为策略! 策略就是升级版的ACL，策略可以基于IP、端口、协议、应用层数据进行各种过滤
其实也是一种过滤技术，基于数据包中的IP地址、端口号来对数据包进行过滤！
ACL分类 华为 思科 编号越小优先级越靠前
ACL的规则 华为 每个ACL可以包含多个规则，RTA根据规则来对数据流量进行过滤。
1.一个ACL可以由多条“deny | permit”语句组成，每一条语句描述了一条规则。设备收到数据流量后，会逐条匹配ACL规则，看其是否匹配。如果不匹配，则匹配下一条。一旦找到一条匹配的规则，则执行规则中定义的动作，并不再继续与后续规则进行匹配。如果找不到匹配的规则，则设备不对报文进行任何处理。需要注意的是，ACL中定义的这些规则可能存在重复或矛盾的地方。规则的匹配顺序决定了规则的优先级，ACL通过设置规则的优先级来处理规则之间重复或矛盾的情形。
⒉.配置顺序按ACL规则编号（rule-id)从小到大的顺序进行匹配。设备会在创建ACL的过程中自动为每一条规则分配一个编号，规则编号决定了规则被匹配的顺序。例如，如果将步长设定为5，则规则编号将按照5、10、15...这样的规律自动分配。如果步长设定为2，则规则编号将按照2、4、6...这样的规律自动分配。通过设置步长，使规则之间留有一定的空间，用户可以在已存在的两个规则之间插入新的规则。路由器匹配规则时默认采用配置顺序。另外，ARG3系列路由器默认规则编号的步长是5。
3.自动排序使用“深度优先”的原则进行匹配，即根据规则的精确度排序。
4.本示例中，RTA收到了来自两个网络的报文。默认情况下，RTA会依据ACL的配置顺序来匹配这些报文。网络172.16.0.0/24发送的数据流量将被RTA上配置的ACL2000的规则15匹配，因此会被拒绝。而来自网络172.17.0.0/24的报文不能匹配访问控制列表中的任何规则，因此RTA对报文不做任何处理，而是正常转发。
5.华为ACL最后的默认的隐含的一条，不是拒绝所有，而是允许所有
ACL配置技巧 1）先判断要控制的数据流源和目标，并画出控制数据流的方向!进而判断ACL可以写在哪些路由器上!
2）打开那台路由器，开始编写ACL过滤规则!
3）最后将ACL表应用到某个接口的某个方向才能生效!
基本ACL的配置 华为 以上为模拟实验环境。
正常ping没问题
下面来配置ACL策略（在AR1上面配置）
acl 2000 创建一个ACL 并进入
rule deny source (IP/掩码) 在ACL2000中配置一条禁止某某IP通过的策略
interface gigabit Ethernet 0/0/0 进入接口
traffic-filter outbound acl 2000 将ACL2000写入0/0/0接口
试一试192到10.1.1.2能否通过
还能够ping通，这里是因为他不是对网关进行过滤，而是对单独IP进行过滤，所以我们需要在增加对192.168.1.1 和192.168.1.2IP的过滤
上面是PC1的
上面是PC2的。拿捏了。
再看看下面172的
OK
1.acl [ number ]命令用来创建一个ACL，并进入ACL视图。
2.rule [ rule-id ] { deny / permit } source f source-address source-wildcard | any }命令用来增加或修改ACL的规则。deny用来指定拒绝符合条件的数据包,permit用来指定允许符合条件的数据包,source用来指定ACL规则匹配报文的源地址信息，any表示任意源地址。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54f5b721d34900745885cdf6f600c30c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/590859cf36e0d3d6dfcd5c1eaf42e9aa/" rel="bookmark">
			Android Studio 之 TextView 内容变超链接的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在xml文件中，给TextView控件，添加 autoLink属性： android:autoLink="web" 或者在源码中添加如下代码： tv_text.setAutoLinkMask(Linkify.WEB_URLS); 例如：
效果图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45e683309e857ecbbf211dd4c2042279/" rel="bookmark">
			【GAMES101】作业8 库安装问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境配置 直接使用assignment中给出的库安装命令容易出现Unable to locate package的提示，这里给出自测有效的配置流程：
首先不可或缺的就是编译器与基本的函式库，如果系统没有安装的话，依照下面的方式安装：
$ sudo apt-get install build-essential 安装OpenGL Library
$ sudo apt-get install libgl1-mesa-dev 安装OpenGL Utilities
$ sudo apt-get install libglu1-mesa-dev OpenGL Utilities 是一组建构于 OpenGL Library 之上的工具组，提供许多很方便的函式，使 OpenGL 更强大且更容易使用。 安装OpenGL Utility Toolkit
$ sudo apt-get install freeglut3-dev OpenGL Utility Toolkit 是建立在 OpenGL Utilities 上面的工具箱，除了强化了 OpenGL Utilities 的不足之外，也增加了 OpenGL 对于视窗介面支援。 出现Failed to fetch的提示?
使用
$ sudo apt-get update
完成之后再执行报错的命令，若 sudo apt-get update 也出现Failed to fetch错误
执行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45e683309e857ecbbf211dd4c2042279/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cf582bda68f78a8095cda2c82ce6195/" rel="bookmark">
			【学习笔记】基于flask的web项目开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
正文
初始Flask
拓展一
Flask与HTTP
Flask模板
基本用法
辅助工具之上下文
辅助工具之全局对象
写在最后
参考资料
前言 21年9月，因为项目需求方催付上线，需要会python的人，所以我又临时顶上了。
其实项目本身更多的还是需求逻辑和算法逻辑，只是flask框架于我是个全新的知识，所以趁机就全面学习一下！
可能会因为个人理解和编写有所错误，欢迎各位勘正！
老规矩：在此做一些学习和错误记录，仅作个人小结用（不涉及任何项目细节，应该也涉及不到）
正文 初始Flask 使用pycharm(相关安装配置可查看以前的博文)新建flask项目
直接跑一下示例
前台页面显示
解释一下项目的整体结构，从上图可以看到，新建的最基本的项目会包含static和tamplate两个文件夹和一个与包同名的py文件
static通常存储静态文件，css\js等template默认存放模板，什么是模板？这部分详见Flask模板部分 我们知道在MVC框架中包含三个部分：Model、View、Controller
严格地说，Flask不是MVC架构的框架，因为他没有内置数据模型的支持。
from flask import Flask app = Flask(__name__) @app.route('/') def hello_world(): return 'Hello World!' if __name__ == '__main__': app.run() 简单解释一下这个示例代码：
传入Flask类构造方法的第一个参数是模块或者包的名称，此处用了当前模块__name__为函数附加app.route()装饰器，并传入URL规则作为参数，必须以‘/‘开始，可以绑定多个URL也可以是动态&lt;&gt;的，这样URL就和函数建立了关联，这个过程就是注册路由，这个函数被称为视图函数通过run()方法启动Flask程序，这里有一个调试模式，就是服务器会在代码修改以后自动重新载入，这样就不需要每次修改程序以后手动地去重启它。主要有如下两种方式(绝对不可以用于生产环境) 方式一：直接在应用对象上设置 app.debug = True app.run() 方式二：作为run方法的一个参数传入 app.run(debug=True) 这里我想顺带提一下python里面__(双下划线)和_(单下划线)的区别。
拓展一 _单下划线本身可以用作临时变量，比如：for _ in rang(n)；
_xx(变量前的单下划线)，用于声明私有化属性和方法，但实际上python本身没有真正的私有方法，所以这只是一个申明。form 包名 import * 禁止导入，类对象和子类可以访问，使用对象._变量名调用；
__xx(变量前的双下划线)，避免与子类中的属性命名冲突，同时双下划线开头的方法不能被重写，只允许类内部使用，无法在外部直接访问，应使用对象._类名__变量名调用；
__xx__(变量前后的双下划线)，用于定义类的魔法属性/方法，例如：__init__()当变量被创建初始化调用,__new__()用来创建实例、__str__等，无法直接调用；
Flask与HTTP 本部分根据书中的讲解，先行跳过，等完成所有Flask的基础学习以后再回过头补充。
Flask模板 基本用法 模板：包含固定内容和动态部分的可重用文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cf582bda68f78a8095cda2c82ce6195/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9277f9e4d8da4d6895a6ed6d32639f8f/" rel="bookmark">
			oracle中将字段内容拆分为多行显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查询sql:
select * from AS_SMS_REMIND_ITEM where ID =478 查询结果:
将表中RANGE字段按照逗号拆分并转成列显示
实现sql:
SELECT T1.*, T2.COLUMN_VALUE AS DS_ID FROM AS_SMS_REMIND_ITEM T1, table(split(T1.range, ',')) T2 where ID=478 实现效果:
DS_ID字段是由RANGE字段的值拆分并行转列后的结果。
split是自定义的一个function，内容如下：
create or replace function split (p_list clob, p_sep varchar2 := ',') return tabletype pipelined is l_idx pls_integer; v_list varchar2 (32676) := to_char(p_list); begin loop l_idx := instr (v_list, p_sep); if l_idx &gt; 0 then pipe row (substr (v_list, 1, l_idx - 1)); v_list := substr (v_list, l_idx + length (p_sep)); else pipe row (v_list); exit; end if; end loop; end; 函数split中return的返回值类型为tabletype，tabletype是一个自定义的类型。创建的脚本如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9277f9e4d8da4d6895a6ed6d32639f8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79fc4ab83426bae8be59dbd21df0dfa1/" rel="bookmark">
			No.1 雉兔各几何？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今有雉兔同笼，上有三十五头，下有九十四足，问雉兔各几何？
输出示例：
雉兔同笼，兔有12只，雉有23只 for x in range(1,36):
y=35-x
if x+y==35 and 4*x+2*y==94:
print(f'雉兔同笼，兔有{x}只，雉有{y}只')
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d28660d833cb8e2d5a3c2c819ccf6c18/" rel="bookmark">
			Spring 基础--第一个spring项目及IOC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、第一个spring项目 1、导入Jar包
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、创建实体类
package com.lisi.pojo; public class Hello { private String str; public String getStr() { return str; } public void setStr(String str) { this.str = str; } @Override public String toString() { return "Hello{" + "str='" + str + '\'' + '}'; } } 3、编写spring文件
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--bean就是java对象 , 由Spring创建和管理--&gt; &lt;bean id="hello" class="com.lisi.pojo.Hello"&gt; &lt;property name="name" value="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d28660d833cb8e2d5a3c2c819ccf6c18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/107f288de37bcbc7f0d13c615f027aae/" rel="bookmark">
			N: 无法安全地用该源进行更新，所以默认禁用该源。【树莓派 ubuntu 软件源问题】E: 无法下载 http://mirrors.tuna.tsinghua.edu.cn/ubuntu/dists/
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		N: 无法安全地用该源进行更新，所以默认禁用该源。【树莓派 ubuntu 软件源问题】 问题解决方法清华软件源E: 无法下载 http://mirrors.tuna.tsinghua.edu.cn/ubuntu/dists/bionic/main/binary-arm64/Packages 404 Not Found [IP: 101.6.15.130 80] 问题 当使用树莓派4b时遇到使用命令
sudo apt-get update 会报以下错误时
那就说明软件园那里有问题，不能够更新软件列表
解决方法 Ubuntu 的软件源配置文件是 /etc/apt/sources.list
打开这个文件夹，如果没有权限更改，那就使用下面这条命令进行提升权限
sudo chmod 777 /etc/apt/sources.list 权限提升后即可修改里面的内容
你的里面内容可能时这样的，看起来很复杂 ，其实起作用的没几行，大部分都是注释。
把没注释的那几行的内容，后边的https://改为http://
全部更改，然后保存退出，此时再进行更新软件列表就应该没有错误了。
清华软件源 如果你把上边的那个文件里面的内容已经改的面目全非了，但还是不对，不要怕。我们去找清华镜像那里提供的软件园，你的ubuntu是x86架构就进这个 如果你是ARM架构就进这个 进去之后选择合适的ubuntu版本，然后把网站下面这个东西复制一下
这里的下边已经提醒你该镜像适合什么架构了，自己注意一下就好了
把这个东西复制到你的那个/etc/apt/sources.list里面，把之前的全删除掉。
然后更新一下软件列表试试 即 在终端运行 sudo apt-get update
同样，它会报这个错，然后安装上面的方式把https://这里的s去掉变成http:// 这样应该就不报错。如果不报错，那就正常用把。
E: 无法下载 http://mirrors.tuna.tsinghua.edu.cn/ubuntu/dists/bionic/main/binary-arm64/Packages 404 Not Found [IP: 101.6.15.130 80] 如果你报的是这个错那就说明你的镜像源使用错了跟你的架构不对应，即你是arm架构而你这里填写的是x86架构的镜像源，所以不对。上边那两个清华的镜像源会提醒你适合哪些架构不适合哪些架构。
arm架构的软件源好像比x86架构的软件源里面少了好多软件安装不了 比如 luvcview 如果有人能在arm上装请告我一下 感谢鸥
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/235e82f3648f95f8e69130241a471a05/" rel="bookmark">
			ByteTrack翻译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ByteTrack：通过关联每个检测框进行多目标跟踪 摘要 多目标跟踪（MOT）旨在估计视频中物体的边界框和身份。大多数方法通过关联分数高于阈值的检测框来获得身份。检测分数低的物体，例如被遮挡的物体，被简单地扔掉，这带来了不可忽视的真实物体丢失和碎片轨迹。为了解决这个问题，我们提出了一种简单、有效和通用的关联方法，通过关联几乎每个检测框而不是只关联高分的检测框来进行跟踪。对于低分检测框，我们利用它们与 tracklets 的相似性来恢复真实对象并过滤掉背景检测。当应用于 9 个不同的最先进的跟踪器时，我们的方法在 IDF1 分数上实现了从 1 到 10 分的持续改进。为了提出 MOT 的 state-of-theart 性能，我们设计了一个简单而强大的跟踪器，命名为 ByteTrack。我们首次在单 V100 GPU 上以 30 FPS 运行速度在 MOT17 的测试集上实现了 80.3 MOTA、77.3 IDF1 和 63.1 HOTA。ByteTrack 还在 MOT20、HiEve 和 BDD100K 跟踪基准上实现了最先进的性能。源代码、带有部署版本的预训练模型和应用于其他跟踪器的教程在 https://github.com/ifzhang/ByteTrack 发布。
图 1. MOT17 测试集上不同跟踪器的 MOTA-IDF1-FPS 比较。横轴为FPS（运行速度），纵轴为MOTA，圆的半径为IDF1。我们的 ByteTrack 在 MOT17 测试集上以 30 FPS 的运行速度达到 80.3 MOTA、77.3 IDF1，优于所有之前的跟踪器。详情见表 4。
1. 简介 合理的就是真实的；真实的就是合理的。 —— G.W.F. 黑格尔
基于检测的跟踪是当前最有效的多目标跟踪方法。由于视频中的复杂场景，检测器容易做出不完美的预测。最先进的 MOT 方法 [1-3, 6, 12, 18, 45, 59, 70, 72, 85] 需要处理检测框中的真阳性/假阳性权衡，以消除低置信度检测框 [4, 40]。但是，消除所有低置信度检测框是否正确？我们的回答是否定的：正如黑格尔所说：“合理的就是真实的；真实的才是合理的。”低置信度检测框有时指示对象的存在，例如被遮挡的物体。过滤掉这些对象会导致 MOT 出现不可逆转的错误，并带来不可忽略的缺失检测和碎片化轨迹。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/235e82f3648f95f8e69130241a471a05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cbf6779e0114c847ef8c91b2be1d24a/" rel="bookmark">
			漏洞发现“小迪安全课堂笔记”系统，web，app，服务探针利用修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		漏洞发现 思维导图(全)相关名词解释操作系统之漏洞探针类型利用修复思维导图漏洞探针(漏扫)GobyNmapNessus(推荐使用) 利用工具SearchsploitMetasploit企业内部工具 单点EXPcvnd 国家信息安全漏洞共享平台seebug 知道创宇漏洞平台exploit-dbGithub搜索漏洞编号 修复 WEB应用之漏洞探针类型利用修复已知CMS开发框架未知CMS APP漏洞之探针类型利用修复思路说明案例http协议burp抓包Charles非http——wireshark安卓逆向便捷 APK 一键提取 URL利用 Burp 筛选及联动xray功能 API接口服务漏洞之探针类型利用修复端口服务类安全测试API 接口-WebServiceRESTful API涉及基础知识 案例-tomcat默认配置页弱口令上传war包案例-口令安全脚本工具简要使用SnetcrackerAPI案例-awvs涉及资源 总结： 思维导图(全) 相关名词解释 cvss
cve
exp ：利用代码，利用工具
poc：验证
操作系统之漏洞探针类型利用修复 思维导图 角色扮演∶操作系统权限的获取会造成服务器上安全问题
漏扫工具∶Goby，Nmap，Nes3us，Openvas，Nexpose等
漏洞类型∶权限提升，缓冲器溢出，远程代码执行，未知Eug等漏洞利用∶工具框架集成类，漏洞公布平台库类，复现文章参考等
漏洞修复∶打上漏洞补丁，关闭对应入门点，加入防护软件硬件等
1.系统漏洞发现意义?
操作系统的漏洞将直接影响目标服务器的安全性。
2.漏洞类型危害情况?
漏洞类型多样，不同漏洞利用条件不同。例如：提权漏洞的前提条件是已经拿到低权限，而一些其他漏洞不需要前提条件直接获取信息。
3.如何做好未卜先知?
需要经验累积。
漏洞探针(漏扫) Goby 下载地址：https://gobies.org
优点：界面舒适，速度快。缺点：漏洞库不够强大。
Nmap Nmap --script=vuln 默认 nse 插件
默认nse目录路径
开始扫描
Nmap——vulscan库 vulners库 调用第三方库探针 说明文档：https://www.cnblogs.com/shwang/p/12623669.html
Nessus(推荐使用) nessus漏洞库比较强大，所以推荐使用。
安装 nessus 执行命令的时候一定要管理员运行执行
利用 工具 Searchsploit https://github.com/offensive-security/exploitdb GitHub漏洞集合
参数说明：
这里使用忍者安全测试系统运行
Metasploit kali Metasploit基本使用：https://blog.csdn.net/Captain_RB/article/details/103836565
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cbf6779e0114c847ef8c91b2be1d24a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7563e1a139926892ab9f8653e5f2784/" rel="bookmark">
			python——turtle的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据俺的无脑想法，一顿无脑操作。弄出来个啥东西！！！
给大家欣赏欣赏！！！
from turtle import * import time a = [-400,-280] b = [-368,-248] c = [60,120] setup(1000,800) screensize(1000,800,'pink') pencolor('black') pensize(3) speed(10) #乌龟向某坐标点无痕迹移动 def yudon(x,y): up() goto(x,y) pd() #小红花 def xiaohonhua(): speed(10) begin_fill() right(90) fillcolor('green') fd(10) circle(10,180) end_fill() begin_fill() fillcolor('green') for i in range(9): fd(10) right(140) fd(10) circle(10,180) fd(10) end_fill() begin_fill() fillcolor('red') left(290) circle(30,360) end_fill() right(70) begin_fill() for i in range(2): yudon(a[i],0) left(c[i]) fd(100) right(120) fd(100) yudon(b[i],0) begin_fill() fillcolor('red') circle(20,360) end_fill() yudon(-330,-40) right(30) circle(40,180) yudon(-420,0) left(180) circle(130,360) yudon(-50,100) #第一个小红花 xiaohonhua() yudon(80,100) #第二个小红花 xiaohonhua() yudon(220,110) #第三个小红花 xiaohonhua() yudon(-20,65) xx = '恭' write(xx, font=('Arial', 30, 'bold'), align="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7563e1a139926892ab9f8653e5f2784/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deb02a563861040ec9392d1c775a5406/" rel="bookmark">
			【RK3588-linux开发】1、刷机ubuntu20
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接按firefly的教程来！
1、刷机到内部存储
主机环境（windows10），typeC接口连接主机，按下recover键再上电，2s后松开
下载工具与镜像
驱动安装 (DriverInstall.exe)
刷固件 (RKDevTool.exe) 升级固件-&gt;擦除flash-&gt;固件 选择img-&gt;升级
2、RK3588上跑Ubuntu-Gnome系统,设置中文
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70681a28b06139353aad31b5c43dde88/" rel="bookmark">
			无法打开虚拟机 CentOS 64 位: 获取该虚拟机的所有权失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是由于虚拟磁盘(.vmdk)本身有一个磁盘保护机制，为了防止多台虚拟机同时访问同一个虚拟磁盘(.vmdk)带来的数据丢失和性能削减方面的隐患，每次启动虚拟机的时候虚拟机会使用扩展名为.lck（磁盘锁）文件对虚拟磁盘(.vmdk)进行锁定保护。
当虚拟机关闭时.lck（磁盘锁）文件自动删除。但是可能由于非正常关闭虚拟机，这时虚拟机还没来得及删除系统上的.lck（磁盘锁）文件，所以当下次您启动虚拟机的时候出现了上述错误。
解决：
方法一： 到虚拟机目录下删除后缀为lck的文件(lock)，即可！
方法二： 使用记事本打开*.VMX文件上加上一行代码disk.locking = "FALSE"，重新启动该虚拟机。
（忘记截图，网上选用别人的）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/571d223c7137bc66f97603f57c5a84b9/" rel="bookmark">
			idea中配置文件的操作步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5b4093cde3cf91beb1177e024ed8fa9/" rel="bookmark">
			ZGC学习笔记：ZGC简介和JDK17对ZGC的优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		00 前情提要 不行了，之前还没写几篇文章，本来想保持住那种非常认真非常严谨的风格，保持不住了~
反正工作时候还不是遇到问题，先google，google不到再百度一下。解决不了就向同事卖萌啦~
这图我实在找不到更高清的了，凑合看看吧（其实可以ps，但是我懒）
然后之前是因为有一些东西很好奇嘛，比如为什么K8s弃用docker？那是真滴好奇，好歹有一个写作目的嘛，“为什么K8S要弃用Docker”。
在想本周写啥的时候，那要不写写ZGC？
于是就开始搜索ZGC。
然后发现别人都已经写好了，那我写了干嘛……
算了随便写写吧，写到哪算哪。
有一些东东就直接翻译了啦，好烦诶。
01 ZGC简介 ZGC是一个可扩展的低延迟垃圾收集器，能够处理8MB到16TB大小的堆，最大暂停时间为亚毫秒。
OpenJDK的官网只写到这里，然后让我们自己去看Wiki（链接2）……好偷懒……
Wiki的介绍是更详细一些。
Z Garbage Collector，也称为 ZGC，是一种可扩展的低延迟垃圾收集器，旨在满足以下目标：
亚毫秒最大暂停时间
暂停时间不会随着堆、live-set 或 root-set 的大小而增加
处理大小从 8MB 到 16TB 的堆
ZGC 最初是作为 JDK 11 中的一项实验性功能引入的，并在 JDK 15 中被宣布为 Production Ready。
ZGC的几个特征：
并发
基于区域
基于压缩
NUMA 感知
使用染色指针
使用负载屏障（原文为load barriers）
ZGC 的核心是一个并发垃圾收集器，这意味着所有繁重的工作都在 Java 线程继续执行的同时完成。这极大地减少了垃圾收集对应用程序响应时间的影响。
ZGC 项目由 HotSpot Group 赞助。
下图是截止目前为止（2020-04-17）的ZGC的发布时间表，可以看出ZGC总JDK11开始实验性推出，JDK15开始正式发布。
ZGC的部分参数：
ZGC部分操作：
使用下述命令选项启用ZGC
-XX:+UseZGC 启用ZGC
设置堆大小
ZGC 最重要的调优选项是设置最大堆大小（-Xmx&lt;size&gt;）。由于 ZGC 是一个并发收集器，因此必须选择最大堆大小，以便 1) 堆可以容纳应用程序的实时集，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5b4093cde3cf91beb1177e024ed8fa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc0ff915aa599b501fed2b309fef1327/" rel="bookmark">
			【Java基础】注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.简介2.注解语法2.1 注解接口2.2 注解格式及快捷方式2.2.1 注解格式2.2.2 快捷方式1：标记注解2.2.3 快捷方式2：单值注解 2.3 注解的用法 3.标准注解3.1 用于编译的注解3.2 用于管理资源的注释3.3 元注解 1.简介 在Java中，注解被当作一个修饰符（public、static、protect…）来用的。它被置于被注解项之前，中间没有分号。注解可以注解类、方法、成员和局部变量，甚至是注解（后面会提到元注解，元注解可以用来注解注解）。每个注解都必须通过注解接口进行定义。注解本身不会做任何事情，它们只存在于源文件中，编译器将它们置于类文件中，并且虚拟机会将他们载入。所有的注解都隐式地扩展自java.lang.annotation.Annotation接口。一个项可以有多个注解。 2.注解语法 2.1 注解接口 首先我们知道注解是通过注解接口定义的，如下
public @interface Test{ //类型 元素名(); String elementName1(); int elementName2(); } 其中elementName1();是注解中元素的声明方式。
注解元素的类型为以下之一：
基本类型（int、short、long、byte、char、double、float或者boolean）StringClass（具有一个可选类型的参数，例如Class&lt;? extends MyClass）enum类型注解类型由上述类型元素组成的数组 2.2 注解格式及快捷方式 首先我们先来说一下default的用法：
public @interface Test{ String elementName1() default value1; int elementName2(); } 这里的的default表示了注解被使用时，如果某个元素没有指定某个值，就会默认使用default后面的value。
注意：一个注解元素永远不能设置为null，甚至是默认值也不可以设置为null，所以你必须使用其他的默认值，例如 “” 或者 Void.class
2.2.1 注解格式 @AnnonationName(elementName1=value1, elementName2=value2) 这里元素的顺序无关紧要，下面我们来讲一下关于注解的快捷方式
2.2.2 快捷方式1：标记注解 如果一个注解中的元素没有指定值（注解中没有任何元素或者所有元素都是用默认值），那么你就可以省略括号，如下，7、8两行代码的效果是一样的。
public @interface Test{ String elementName1() default "[none]"; int elementName2() default 0; } @Test(element1="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc0ff915aa599b501fed2b309fef1327/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11cf15280614a2b908e885d37dc2a4b3/" rel="bookmark">
			leetcode234题-简单方法判断回文链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
题目
分析
代码实现
题目 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。
提示:
链表中节点数目在范围 [1,105] 内，0&lt;= Node.val &lt;= 9
要求：
时间复杂度：O(n)
空间复杂度：O(1)
分析 要满足复杂度的要求，我们可以反转从中间节点开始的子链表，将子链表与原链表对比，判断是否为回文链表。（此时并没有开辟新的链表节点，都是在原链表基础上操作的）
第一步：找出链表的中间结点
//找出中间点 public ListNode middleNode(ListNode head) { ListNode f = head; ListNode l = head; while (f != null &amp;&amp; f.next != null) { f = f.next.next; l = l.next; } return l; } 第二步：反转从中间结点开始的子链表
//反转 public ListNode reverList(ListNode head) { if(head ==null||head.next ==null){ return head; } ListNode prev = null; ListNode cur = head; while(cur !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11cf15280614a2b908e885d37dc2a4b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99a619b10b523b8a969b82deff7a08cb/" rel="bookmark">
			C&#43;&#43;二级练习题-7 大小写转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述 把一个字符串中所有出现的大写字母都替换成小写字母，同时把小写字母替换成大写字母。
输入格式 输入一行：待互换的字符串。
输出格式 输出一行：完成互换的字符串（字符串长度小于80）。
输入数据 1 If so, you already have a GoogleAccount. You can sign in on the right. 输出数据 1 iF SO, YOU ALREADY HAVE A gOOGLEaCCOUNT. yOU CAN SIGN 思路 这题其实十分简单，用string字符加上ASCII码就可以了。
代码 #include&lt;stdio.h&gt; #include&lt;string.h&gt; int main() { char str[90]; while(gets(str)!=NULL) { int i; for(i=0;str[i]!='\0';i++) { if(str[i]&gt;='A'&amp;&amp;str[i]&lt;='Z') str[i]+=32; else if(str[i]&gt;='a'&amp;&amp;str[i]&lt;='z') str[i]-=32; } puts(str); printf("\n"); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef69cc8febfc8e646079d6e95c8f1990/" rel="bookmark">
			TypeError: can‘t convert cuda:0 device type tensor to numpy. Use Tensor.cpu()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤵 Author ：Horizon Max
✨ 编程技巧篇：各种操作小结
🎇 机器视觉篇：会变魔术 OpenCV
💥 深度学习篇：简单入门 PyTorch
🏆 神经网络篇：经典网络模型
💻 算法篇：再忙也别忘了 LeetCode
错误提示 在将 tensor 格式转换成 numpy 格式时出现报错：
TypeError: can't convert cuda:0 device type tensor to numpy. Use Tensor.cpu() to copy the tensor to host memory first.
错误原因 需要先将 tensor 转换到 CPU ，因为 Numpy 是 CPU-only
解决方案 使用 .cpu() 先进行转换
修改前：
predict.numpy() 修改后：
predict.cpu().numpy() 🈺 喜欢的 留个 关注 、 加 点赞 哦 ~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c4ba4b3580f097a36bb5f688ebf1907/" rel="bookmark">
			JS总结——IntersectionObserverAPI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是IntersectionObserver 文档中的描述为:​​​​​​​Intersection Observer API​的IntersectionObserver接口提供了一种异步观察目标元素与祖先元素或顶级文档视口的交集变化的方法。祖先元素或视口称为根。
ntersectionObserver能做什么 可以监视页面中的一个元素是否出现在视口中，以此可以衍生出许多功能，当这个元素出现在视口中时，可以处理发送请求，触发动画等等业务。
如何使用 我们来分析一下官方给的案例
在使用之前，我们需要对InterceptionObserver进行注册，并且指定回调，该回调函数即当监视的元素出现在视口中，离开视口时均会触发，当元素绑定上监视器的时候首先会触发一次
关键属性:intersectionRatio属性告诉您当前有多少目标元素在根的交叉比率内可见，值介于 0.0 和 1.0 之间。简单地说，就是元素在页面中的面积和整个元素面积的比值，触发函数的时候元素完全在页面中，则为1，一半面积在页面中则为0.5。
//由于InterceptionObserver是JS原生的API，因此可以直接new 来创建对象 const io = new IntersectionObserver(entries =&gt; {//entries是触发回调函数的元素数组 //由于我们可以监视多个元素，可能会出现多个元素同时进入视口触发回调的情况，因此是一个数组 entries.forEach(entry =&gt; { //由于元素进入视口和退出视口都会触发 //如何判断此时元素是进入视口还是退出视口呢? if (entry.intersectionRatio &gt; 0) {//通过entry.intersectionRatio属性 //元素在页面中的面积大于0，则元素出现在视口中，即元素进入视口 entry.target.classList.add('active');//entry.target即为触发函数的dom元素 } else { //元素在页面中的面积=0，则元素不在视口中，即元素离开了视口 entry.target.classList.remove('active'); } }) }) 指定了回调之后，我们还需要给元素绑定上监视器,通过io.observe(element)
可以给多个元素绑定，也可以给一个元素绑定
// Declares what to observe, and observes its properties. const boxElList = document.querySelectorAll('.box'); boxElList.forEach((el) =&gt; { io.observe(el); }) 其他重要函数
io.unobserve(element) 元素绑定了监视器之后，可以在任意时刻解绑，接触绑定之后，当元素进入视口或离开视口，回调函数均不会执行。io.disconnect()。 停止观察其所有目标元素的可见性变化 ​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c4ba4b3580f097a36bb5f688ebf1907/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/299f70b0e48b3b4088f0b4aa54c20a28/" rel="bookmark">
			Spring整合Spring Security OAuth2.0认证授权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本概念 1.1 什么是认证 比如：在初次使用微信前需要注册成为微信用户，然后输入账号和密码即可登录微信，输入账号和密码
登录微信的过程就是认证。
系统为什么要认证？
认证是为了保护系统的隐私数据与资源，用户的身份合法方可访问该系统的资源。
认证 ：用户认证就是判断一个用户的身份是否合法的过程，用户去访问系统资源时系统要求验证用户的身份信
息，身份合法方可继续访问，不合法则拒绝访问。常见的用户身份认证方式有：用户名密码登录，二维码登录，手
机短信登录，指纹认证等方式。
1.2 什么是会话 用户认证通过后，为了避免用户重复认证，可将用户的信息保证在会话中。会话就是系统为了保持当前
用户的登录状态所提供的机制，常见的有基于session方式、基于token方式等。
基于session的认证方式如下图：
它的交互流程是，用户认证成功后，在服务端生成用户相关的数据保存在session(当前会话)中，发给客户端的
sesssion_id 存放到 cookie 中，这样用户客户端请求时带上 session_id 就可以验证服务器端是否存在 session 数
据，以此完成用户的合法校验，当用户退出系统或session过期销毁时,客户端的session_id也就无效了。
基于token方式如下图：
它的交互流程是，用户认证成功后，服务端生成一个token发给客户端，客户端可以放到 cookie 或 localStorage
等存储中，每次请求时带上 token，服务端收到token通过验证后即可确认用户身份。
基于session的认证方式由Servlet规范定制，服务端要存储session信息需要占用内存资源，客户端需要支持
cookie；基于token的方式则一般不需要服务端存储token，并且不限制客户端的存储方式，所以基于token的方式更适合。
1.3 什么是授权 授权： 授权是用户认证通过根据用户的权限来控制用户访问资源的过程，拥有资源的访问权限则正常访问，没有
权限则拒绝访问。
1.4 授权的数据模型 授权可简单理解为Who对What(which)进行How操作
Who，即主体（Subject），主体一般是指用户，也可以是程序，需要访问系统中的资源。
What，即资源（Resource），如系统菜单、页面、按钮、代码方法、系统商品信息、系统订单信息等。系统菜单、页面、按钮、代码方法都属于系统功能资源，对于web系统每个功能资源通常对应一个URL；系统商品信息、系统订单信息都属于实体资源（数据资源），实体资源由资源类型和资源实例组成，比如商品信息为资源类型，商品编号 为001的商品为资源实例。
How，权限/许可（Permission），规定了用户对资源的操作许可，权限离开资源没有意义，如用户查询权限、用户添加权限、某个代码方法的调用权限、编号为001的用户的修改权限等，通过权限可知用户对哪些资源都有哪些操作许可。
主体、资源、权限关系如下图：
主体、资源、权限相关的数据模型如下：
主体（用户id、账号、密码、…）
资源（资源id、资源名称、访问地址、…）
权限（权限id、权限标识、权限名称、资源id、…）
角色（角色id、角色名称、…）
角色和权限关系（角色id、权限id、…）
主体（用户）和角色关系（用户id、角色id、…）
主体（用户）、资源、权限关系如下图：
通常企业开发中将资源和权限表合并为一张权限表，如下：
资源（资源id、资源名称、访问地址、…）
权限（权限id、权限标识、权限名称、资源id、…）
合并为：
权限（权限id、权限标识、权限名称、资源名称、资源访问地址、…）
修改后数据模型之间的关系如下图：
1.5 RBAC 如何实现授权？业界通常基于RBAC实现授权。
1.5.1 基于角色的访问控制 RBAC基于角色的访问控制（Role-Based Access Control）是按角色进行授权，比如：主体的角色为总经理可以查
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/299f70b0e48b3b4088f0b4aa54c20a28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8772e253c836dfd9c2882cba696cd012/" rel="bookmark">
			【初学Javascript并在画布上绘图】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初学js的有关知识 1.Javascript是一种什么语言？2. JavaScript由那几部分组成？(1)ECMAScript(2)DOM(3)BOM 3.页面中引入JavaScript的三种方式(1)行内式(2)页面嵌入式(3)外部链接式 4.document文档对象5.画布绘图有关知识(1)创建画布(2)获取画布(3)准备画笔(4)绘制图形 6.绘制线条(1)绘制线的方法(2)线的样式(3)线的路径 1.Javascript是一种什么语言？ JavaScript：是一个脚本语言(嵌入页面中,通过浏览器解析运行)
2. JavaScript由那几部分组成？ (1)ECMAScript ECMAScript：是Javascript的核心，主要规定JavaScript的基本语法。所有的浏览器厂商 都会遵循这个语法(标准)。
(2)DOM DOM：文档对象模型(Document Object Model)，是W3c组织提供的编程接口。用户可以通过 DOM的接口去操作页面中的元素。
(3)BOM BOM：浏览器对象模型(Browser Object Model),独立于内容,可以和浏览器进行交互的对象结构， 通过BOM可以直接对浏览器窗口进行操作。
3.页面中引入JavaScript的三种方式 (1)行内式 行内式：写在标签的属性中
①代码段展示：
&lt;body&gt; &lt;!-- 行内式 --&gt; &lt;a href="javascript:alert('网络信号差'）"&gt;百度&lt;/a&gt; &lt;/body&gt; ②页面展示：
(2)页面嵌入式 页面嵌入式：通过标签在页面中嵌入js代码
①代码段展示：
&lt;body&gt; &lt;button onclick="fun()"&gt;登录&lt;/button&gt; &lt;script type="text/javascript"&gt;/*由javascript构成的文本，此type属性一般加上，防止有些浏览器无法识别*/ function fun(){ alert('登录失败') } &lt;/script&gt; &lt;/body&gt; ②页面展示：
(3)外部链接式 a、创建独立js文件：.js
b、在页面中使用&lt;script src=“js文件名”&gt;&lt;/script&gt;标签将外部的.js文件链接进来
外链式的优势
1)利于后期修改和维护
2)减轻文件体积、加快页面加
载速度
①代码段展示：
html:
&lt;head&gt; &lt;script src="../js/003.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick="fun()"&gt;登录&lt;/button&gt; &lt;p id="pt" &gt;西安邮电大学&lt;/p&gt; &lt;/body&gt; js:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8772e253c836dfd9c2882cba696cd012/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abe2c650d57656c685372d0d93cdfabd/" rel="bookmark">
			安装dlib工具箱失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记一次简单的解决方法：
使用以下命令：
pip install dlib-bin 即：安装dlib-bin
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef10f4e626289a252b9aaaf358f92254/" rel="bookmark">
			Nginx配置-日志格式配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx配置-日志格式配置 一、默认的日志格式二、我使用的日志格式三、参数四、测试效果 五一上线了一个小的预约程序，配置通过Nginx进行访问入口，默认的日志是没有请求时间的，因此需要配置一下，将每一次的请求的访问响应时间记录出来，备查与优化使用.
一、默认的日志格式 默认的日志格式如下(默认是注解掉的，系统也自动会使用)：
#log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #access_log logs/access.log main; 二、我使用的日志格式 我仅仅在默认的基础上加上响应时间的两个我较关心的参数：request_time与upstream_response_time
将以下的配置开放并修改(我后面用了格式2，时间在前面，容易查看)：
带时间数据参数的日志格式1
log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for" "$request_time" "$upstream_response_time"'; access_log logs/access.log main; 调整了下时间参数的显示顺序的格式2:
log_format main '$remote_addr - $remote_user [$request_time $upstream_response_time] [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log logs/access.log main; 注意的是：log_format与access_log的注释都要放开，仅放开log_format也是不生效的.
#设置成格式2后，可以用相应的正则表达式，查看大于1秒的日志，分两步如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef10f4e626289a252b9aaaf358f92254/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a5b34988e2291f7a9efb095dd152a96/" rel="bookmark">
			CMake file文件操作命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用cmake 文件操作时不可避免需要操作相关文件，比如读取文件内容，创建新文件的等等操作，都需要通过file命令进行操作。 读文件操作 file READ命令 常用的从文件中读取操作为file(READ &lt;filename&gt; &lt;variable&gt;)，将filename文件中内容原封不动读取到variable变量中，命令行全部格式为：
file(read &lt;filename&gt; &lt;variable&gt; [OFFSET &lt;offset&gt;] [LIMIT &lt;max-in&gt;] [HEX])
filename: 必选项 为要读取的文件，可以带绝对路径variable: 必选项，将文件内容读取到varible变量中。OFFSET &lt;offset&gt;：可选项，从文件中偏移位置offset 开始读取文件内容HEX：可选项，可以将读取文件内容转换成十六进制。 用例 LIMIT &lt;max-in&gt;: 可选项 最多读取&lt;max-in&gt;长度的内容到变量中
以一个例子说明，实验目录下有两个文件,使用tree命令查看：
$ tree
.
├── CMakeLists.txt
└── test.cpp
0 directories, 2 files
$
test.cpp文件内容如下：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ printf("hello world!\n"); } CMakeList.txt文件内容如下：
cmake_minimum_required(VERSION 3.13.4) project(cmake_read) message("--------Proj Src Dir: " ${PROJECT_SOURCE_DIR}) file(READ ${PROJECT_SOURCE_DIR}/test.cpp TEST_RESULT) message("--------TEST RESULT: " ${TEST_RESULT}) 使用file(read)命令将文件test.cpp的内容读取到TEST_RESULT变量中，并打印出来，使用cmake运行：
$ /public/home/huozhikun/cmake/cmake-3.17.0/bin/cmake .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a5b34988e2291f7a9efb095dd152a96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a43327c20bf8c5640954fa1a17a5a69b/" rel="bookmark">
			mybatis-plus-核心配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mybatis-plus核心配置生成代码 application.yml spring: datasource: url: jdbc:mysql://localhost:3306/mybatis_plus?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC driver-class-name: com.mysql.cj.jdbc.Driver username: root password: root pom文件 &lt;!-- MyBatis相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis-plus-generator模版依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.28&lt;/version&gt; &lt;/dependency&gt; 生成器代码： package com.no.seckill.generator; import com.baomidou.mybatisplus.annotation.DbType; import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.core.toolkit.StringPool; import com.baomidou.mybatisplus.generator.AutoGenerator; import com.baomidou.mybatisplus.generator.InjectionConfig; import com.baomidou.mybatisplus.generator.config.*; import com.baomidou.mybatisplus.generator.config.po.TableInfo; import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy; import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine; import com.baomidou.mybatisplus.generator.engine.VelocityTemplateEngine; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public class MyBatisPlusGenerator { //作者名 private static final String AUTHOR = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a43327c20bf8c5640954fa1a17a5a69b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb2c5ddc5073803b57519a0551e0a4f8/" rel="bookmark">
			FPGA中BCD码-七段数码管译码器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 定义输入为indec；输出为decodeout；则代码为：
module decode4_7(decodeout,indec); input [3:0] indec; output [6:0] decodeout; reg [6:0] decodeout; always @(indec) begin case(indec) 4'd0: decodeout = 7'b1111110; 4'd1: decodeout = 7'b0110000; 4'd2: decodeout = 7'b1101101; 4'd3: decodeout = 7'b1111001; 4'd4: decodeout = 7'b0110011; 4'd5: decodeout = 7'b1011011; 4'd6: decodeout = 7'b1011111; 4'd7: decodeout = 7'b1110000; 4'd8: decodeout = 7'b1111111; 4'd9: decodeout = 7'b1111011; default: decodeout = 7'bx; endcase end endmodule 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b296918ff3a06e10f1aba7551d557b6a/" rel="bookmark">
			STL详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STL简介 编程的抽象发展：面向过程 → \to →基于对象 → \to →面向对象 → \to →泛型
STL(Standard Template Library)是C++标准库的一部分(80%),采用模板(Template)机制来表达泛型。
STL容器 bitset 位集(位运算) 位运算基础（&amp;、|、^、~、&gt;&gt;、&lt;&lt;） 位运算概述 从现代计算机中所有的数据二进制的形式存储在设备中。即 0、1 两种状态,计算机对二进制数据进行的运算(+、-、*、/)都是叫位运算,即将符号位共同参与运算的运算。
口说无凭,举一个简单的例子来看下 CPU 是如何进行计算的,比如这行代码：
int a = 35; int b = 47; int c = a + b; 计算两个数的和,因为在计算机中都是以二进制来进行运算,所以上面我们所给的 int 变量会在机器内部先转换为二进制在进行相加：
35: 0 0 1 0 0 0 1 1 47: 0 0 1 0 1 1 1 1 ———————————————————— 82: 0 1 0 1 0 0 1 0 所以,相比在代码中直接使用(+、-、*、/)运算符,合理的运用位运算更能显著提高代码在机器上的执行效率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b296918ff3a06e10f1aba7551d557b6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f89a83a8c93043a19c9fcdee88ee33d9/" rel="bookmark">
			机器学习——KNN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、具体含义二、特点三、基本思路四、具体步骤五、实现代码 学习来源： 日撸 Java 三百行（51-60天，kNN 与 NB） 一、具体含义 KNN是K-Nearest Neighbor的英文简写，中文直译就是K个最近邻，有人干脆称之为“最近邻算法”。字母“K”也许看着新鲜，不过作用其实早在中学就接触过。在学习排列组合时，教材都喜欢用字母“n”来指代多个，譬如“求n个数的和”，这里面也没有什么秘密，就是约定俗成的用法。而KNN算法的字母K扮演的就是与n同样的角色。K的值是多少，就代表使用了多少个最近邻。机器学习总要有自己的约定俗成，没来由地就是喜爱用“K”而不是“n”来指代多个，类似的命名方法还有后面将要提到的K-means算法。KNN的关键在于最近邻，光看名字似乎与分类没有什么关系，但前面我们介绍了， KNN的核心在于多数表决，而谁有投票表决权呢？就是这个“最近邻”，也就是以待分类样本点为中心，距离最近的K个点。这K个点中什么类别的占比最多，待分类样本点就属于什么类别。 二、特点 简单. 没有学习过程, 也被称为惰性学习 lazy learning. 类似于开卷考试, 在已有数据中去找答案.本源. 找相似, 正是人类认识事物的常用方法, 隐藏于人类或者其他动物的基因里面. 当然, 人类也会上当, 例如有人把邻居的滴水观音误认为是芋头, 偷食后中毒.效果好. 永远不要小视 kNN, 对于很多数据, 你很难设计算法超越它.适应性强. 可用于分类, 回归. 可用于各种数据.可扩展性强. 设计不同的度量, 可获得意想不到的效果.一般需要对数据归一化.复杂度高. 这也是 kNN 最重要的缺点. 对于每一个测试数据, 复杂度为 O ( ( m + k ) n ) O((m+k)n)O((m+k)n), 其中 n nn 为训练数据个数, m mm 为条件属性个数, k kk 为邻居个数. 代码见 computeNearests(). 三、基本思路 KNN最核心的功能“分类”是通过多数表决“投票”来完成的，具体方法是在待分类点的K个最近邻中查看哪个类别占比最多。哪个类别多，待分类点就属于哪个类别。怎样确定K——是一个需要根据实际情况调节以便取得更好拟合效果的参数，可以根据交叉验证等实验方法，结合工作经验进行设置。KNN中常用的度量方法——欧几里得距离和曼哈顿距离。 四、具体步骤 找K个最近邻。KNN分类算法的核心就是找最近的K个点，选定度量距离的方法之后，以待分类样本点为中心，分别测量它到其他点的距离，找出其中的距离最近的 K个，这就是K个最近邻。统计最近邻的类别占比。确定了最近邻之后，统计出每种类别在最近邻中的占比。选取占比最多的类别作为待分类样本的类别。 五、实现代码 package machinelearning.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f89a83a8c93043a19c9fcdee88ee33d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcfb35891c73dca08b87dcf4d3656d6a/" rel="bookmark">
			蓝桥杯——排它平方数（python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 注：如有侵权！告知，立改！！！ 题目描述 小明正看着 203879 这个数字发呆。 原来，203879 * 203879 = 41566646641 这有什么神奇呢？仔细观察，203879 是个6位数，并且它的每个数上的数字都是不同的，并且它平方后的所有数位上都不出现组成它自身的数字。 具有这样特点的6位数还有一个，请你找出它！ 再归纳一下筛选要求： 1. 6位正整数 2. 每个数位上的数字不同 3. 其平方数的每个数位不含原数字的任何组成数位 答案是一个6位的正整数。 i = 100000 while i &lt; 1000000: if len(set(str(i))) == 6 and i != 203879: #set是集合，集合可去除重复值致重复值为非重复值 if set(str(i)).isdisjoint(set(str(int(i) ** 2))): #isdisjoint只针对集合 print(i) i += 1 #判断两个集合是否包含相同的元素，如果没有返回True，否则返回False #set(str(i))会将i分解成单个元素并去除重复元素致重复元素为非重复元素 听秃头大佬说留下关注的大神都能好运连连哦！！！ 你确定不试试？ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13ecedd3cdf0f5bcfbd2a116e5ac9fc8/" rel="bookmark">
			织梦安装，访问http://域名/install/index.php 出现空白页或Not Found 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		织梦安装，访问http://域名/install/index.php 出现空白页或Not Found 问题 织梦DEDECMS原因解决方案联系 织梦DEDECMS 小编已经安装了织梦的模板了 但是还想在安装一个织梦的模板 当我安装第二个模板的时候 依旧访问http://域名/install/index.php的时候 居然出现了空白页有时候还会显示Not Found找不到URl的文件
原因 当你安装第一个cms的模板时系统会默认一个路径 ，将会带来全新的写作体验；当你安装第二个模板时系统还是默认第一个cms模板的路径，这样就会导致访问不到相关文件，会出现空白页和找不到文件的问题 解决方案 删除
然后把后缀有bak的文件 后缀的bak删除 （如：index.php.bak 删除后缀后：index.php）
这样就可以安装地二个模板啦
联系 Wechat:yuxi2101016370
有不同建议的可以私聊小编。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b315614b8f355a32c6a4ce5872b21532/" rel="bookmark">
			教你三分钟用docker compose搭建一个自己的个人博客网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hi，大家好，我是 jack xu，今天和大家聊一个轻松、好玩、易懂的话题，就是教大家搭建一个自己的个人博客网站，可以在同事朋友面前炫耀一把。事情的缘由是我们公司有个同事，有一天他给了我一个网站，我打开一看，上面是一个 jenkins 的页面，我问他这个你是怎么搞的，他说他有一块树莓派，然后在上面搞着玩，装了个 jenkins，我说你这样子搞就浪费了，装个 jenkins 也没什么用，不如装个个人博客网站，这样你的树莓派也不浪费，别人也能通过你的域名来访问，你也可以发一些文章上去，这样岂不是妙哉。
小伙伴听后觉得很有道理，可是他不会搭，于是乎我就决定写一篇教程来帮助他，同事也分享给大家看下，扩展扩展知识，开阔开阔眼界哈。
准备工作 开头的准备工作还是那么两样，安装docker和配置镜像加速器，如果还不会的同学可以看下我的《初识docker》，这是预备知识。然后今天我们是用 docker compose 来实现的，所以还需要安装下 docker compose，我们先打开官网看到上面有步骤。
我们按步骤操作下
sudo curl -L "https://github.com/docker/compose/releases/download/1.26.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose docker-compose --version 测试一下，安装成功了
拉取镜像 安装个人博客的核心是 wordpress 开源框架，源码界面全都帮我们集成好了，所以我们只需要拉取它的镜像，当然我们还需要一个数据库来存储数据，所以还得拉一个mysql。
docker pull wordpress docker pull mysql:5.6 创建yml文件 首先说下什么是 docker compose，前面我们使用 docker 的时候，定义 dockerfile 文件，然后使用 docker build、docker run 等命令操作容器。然而微服务架构的应用系统一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，那么效率之低，维护量之大可想而知。
而 docker compose 的作用就是可以让我们轻松、高效的管理容器，它是一个用于定义和运行多容器 docker 的应用程序工具。
1、先创建一个文件夹
mkdir -p /jackxu/wordpress 2、进入到目录，创建一个 yml 文件。(这里我指定了一个网络，如果不指定的话会默认帮我们创建一个bridge类型的网络。)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b315614b8f355a32c6a4ce5872b21532/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/902b2bad89ac7fc58d4ff2193d63c3a9/" rel="bookmark">
			SQL SERVER BACKUP 证书 【请确保您有写权限、文件路径有效以及该文件尚不存在。】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		备份证书到本地时，选择任意一个文件夹或者路径都会报错，当确定登录账户有权限且文件不存在时，尝试在C根目录下创建一个文件夹，接着直接选择该文件夹作为路径，成功保存。
原理：未知。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92a268598d53e9389e209c0842f8d6a5/" rel="bookmark">
			C/C&#43;&#43; 静态库(lib)的概念和使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、静态库的作用？二、lib的创建使用1.创建lib项目2.编写lib代码3.使用lib文件 总结: 前言 静态库的学习
本节为Visual Studio 2022的编译器
以下是本篇文章正文内容，下面案例可供参考
一、静态库的作用？ 静态库是指在我们的应用中，有一些公共代码是需要反复使用，就把这些代码编译为“库”文件；在链接步骤中， 连接器 将从库文件取得所需的 代码 ，复制到生成的 可执行文件 中的这种库。
在一个软件中可以有很多lib文件 如：
后缀为.lib的都是
二、lib的创建使用 1.创建lib项目 点击Windows桌面向导-&gt;应用程序类型-&gt;静态库-&gt;空项目
2.编写lib代码 创建源文件demo.cpp© 和 头文件demoh.h
在头文件中写：防止头文件重复包含:
#pragma once #ifndef demoh_H #define demoh_H #endif 在#ifndef demoh_H~#define demoh_H之间写函数和变量或对象
#pragma once #ifndef demoh_H void add(int a,int b);//函数 class student { public: static int stu; }; #define demoh_H #endif 打开源文件demo.cpp©中
包含头文件 demoh.h
在源文件中写函数主体
#include "demoh.h" int add(int a, int b) { return a + b; } int student::stu = 188; 点击重新生成项目 也可以点运行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92a268598d53e9389e209c0842f8d6a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/627d40476bc3de1a0bdd88dda12bc11a/" rel="bookmark">
			Ubuntu——配置设置有线网络和无线网络的连接优先级并增加内网网段访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看配置 ip route show 解（fan）释（yi）：
default: 代表默认网卡enp4s0的所在网段为192.168.10.1，跃点优先级为100(越低优先级越高)；
default: 代表默认网卡wlo1的所在网段为10.10.14.1，跃点优先级为100；
10.10.12.0/22网段的数据均从网卡wlo1进行收发，主机的IP为10.10.14.219，跃点优先级为600（低）；
忽略；
192.168.10.0/24网段的数据均从网卡enp4s0进行收发，主机的IP为192.168.10.7，跃点优先级为100（高）；
增加某一网卡对特殊网段的访问 例如：我需要访问一个内网IP10.10.230.12，他是和网卡wlo1所在的网段10.10.14.1是同一局域网中，但是默认情况下无法进行访问，因此只需要将IP所在网段加入网卡wlo1的收发中即可：
# 括号代表需要填写的地方 # sudo ip route add "your target IP" dev wlo1 proto kernel scope link src "your pc IP" metric 600 sudo ip route add 10.10.230.12 dev wlo1 proto kernel scope link src 10.10.14.219 metric 600 增加后：
加入开机自启动 参考文章中的方法三：
ubuntu18.04设置开机启动命令/脚本的三种方法（可sudo） 参考文章：
ubuntu 双网卡内外网优先级设置Ubuntu解决网络连接优先级win10同时使用有线和无线网络，手动设置网络优先级的方法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c47f030619dcee998e82499b2d06d1c9/" rel="bookmark">
			《孙子算经》——类题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		！！！初学c，练练手！！！
李老师买笔
难度等级：★★★☆☆
思维训练方向：假设思维
李老师到文具店买圆珠笔，红笔每支1.9元，蓝笔每支1.1元，两种圆珠笔共买了16支，花了28元。问红､蓝笔各买了几支？
c解
//c解 #include&lt;stdio.h&gt; int main() { int honbi,lanbi; for(honbi = 0;honbi &lt;17;honbi++) { lanbi = 16 - honbi; if (1.9 * honbi + 1.1 * lanbi == 28) { printf("红笔为：%d 只\n蓝笔为：%d 只",honbi,lanbi); }	} } 结果！
python解 #python解 for honbi in range(17): lanbi = 16 - honbi if honbi * 1.9 + lanbi * 1.1 == 28: print('红笔为：{} 只\n蓝笔为：{} 只'.format(honbi,lanbi)) 结果！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d02f1c38550cafcfc2b88a26b8800ac9/" rel="bookmark">
			zynq_linux安装交叉编译环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 注：本文参考了其他博主的文章，都在文中进行了引用
1、下载 xilinx-2011.09-50-arm-xilinx-linux-gnueabi.bin
来自 &lt;zynq交叉编译环境搭建_flyingforever_wl的博客-CSDN博客_zynq 交叉编译&gt;
使用命令
sudo dpkg-reconfigure dash
将dash改为bash
安装编译环境
sudo ./xilinx-2011.09-50-arm-xilinx-linux-gnueabi.bin
此时注意在文件所在的文件夹中启动安装
安装完成后使用命令：
arm-xilinx-linux-gnueabi-gcc -v
若显示版本号：
则表示安装成功。
2、修改环境变量 环境变量可以在终端中直接进入root用户当下修改，但是每次重启后都需要再次修改；
也可以在 .bashrc 文件中添加修改命令，这样以后每次启动终端这个命令就会自动生效，.bashrc 文件相当于一个启动文件，每次启动终端时就会自动运行一遍该文件中的命令。
修改方法为：
gedit ~/.bashrc
进入gedit编辑器，在最后添加：
export ARCH=arm
export CROSS_COMPILE=arm-xilinx-linux-gnueabi-
export PATH=/root/CodeSourcery/Sourcery_CodeBench_Lite_for_Xilinx_GNU_Linux/bin/:$PATH
注意此处第三个命令 = 后面的地址要跟第一步中安装的地址一致才行；
3、使用 交叉编译环境可以直接编译.c文件为无后缀的可执行文件，可以直接在zynq上运行，编译的方法是：
1）新建一个c文件，如hello.c，编写代码（注意此处如果代码有语法错误在编译的时候会报错）； 2）进入root用户，执行 arm-xilinx-linux-gnueabi-gcc ./hello.c -g -o hello 也有：
使用交叉编译链的时候只需输入arm-xilinx-linux-gnueabi-gcc a.c -o a(a.c为待编译文件，a为输出文件)
来自 &lt;一天一点Zynq（1）xilinx-arm-linux交叉编译链 安装总结以及资源更新 - ccTec - 博客园&gt;
即可将hello.c编译成hello了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/799a67ae5a187f9c540d4a48a7e24f3c/" rel="bookmark">
			开发问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.代码切换分支后无法启动？
代码切换分支后，无法正常启动，这是因为idea等编辑器依据在之前分支的环境下，你需要在maven中执行clean操作清理旧环境；
2.为什么jar包做了改动，但一直无法拉取到最新代码？
拉取不到最新jar包，可能是因为idea的maven中没有勾选自动获取最新jar
Settings-&gt;Maven-&gt;勾选Always update snapshots
3.页面上线后，有人看到的是旧版，有人看到的是新版？
可能是页面有缓存，操作人可以清理浏览器缓存或者无痕模式浏览；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01b62e2d2896b195d43a5a79c3dad375/" rel="bookmark">
			浅学一下SQL - select(查询)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提前 我喜欢用小写
并没有具体分类
我的笔记~所以并不适合学习,适合忘记后快速恢复记忆
边学边更新~
浅看就好
命名 table 代表 表
col 代表列名
col_name1col_name2我是数据我也是数据 data 代表数据,具体是啥数据并不重要
select select 语句, 通常又称为 查询, 可以通过语句描述我们要取哪些数据，在数据返回前对数据做一些操作等等
where 没错,是条件,不多bb废话
and和or用于连接条件
例: select col_name,... from table where 条件
条件 关键字说明例子=, !=, &lt; ,&lt;=, &gt;, &gt;=额…没啥好说的col_name = datais null是空col_name is null datais not null不是空col_name is not null databetween data1 and data2在data1和data2之间,区间是[data1,data2]col_name between data1 and data2not between data1 and data2不在data1和data2之间,区间同上取反col_name not between data1 and data2in (data...)(data...)中存在col_name in (data1, data2)not in (data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01b62e2d2896b195d43a5a79c3dad375/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5981e95c2b3a93e5f7573bba2dc563c/" rel="bookmark">
			router-view中可传参吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		答：可以的。
如下：
// 父组件中： &lt;router-view :info="info"&gt;&lt;/router-view&gt; info:"好好学习，天天向上", // 子组件中： {{info}} info:{ type:String, default:'', } 子组件中显示结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7007c3371b22bd045d7062abb0b7e32/" rel="bookmark">
			通过中序、后序（前序、中序）（前序、后序）遍历结果画出二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、知识点概述 前序遍历第一个结点是根结点后续遍历最后一个结点是根结点中序遍历中在根节点左边的是左子树右边的是右子树 二、通过中序、后序遍历结果画出二叉树 例题如下：
首先根据后序遍历结果得知根节点为C；
C
/ \
在中序结果中找到C，发现AB在C左边、EFGHD在C右边，故AB在C的左子树中，EFGHD在C的右子树中；
在后序结果中找到AB，B在最后，故B是当前根节点；
C
/ \
B
/
A
在后序结果中找到FHGED，故D是根结点
C
/ \
B D
/
A
在中序遍历中找打EFGHD，故EFGH都在D的左子树中；
在后序结果中找到FHGE，故E是当前根节点；
C
/ \
B D
/ /
A E
在中序中找到EFGH，故FGH都在E的右子树中；
在后序结果中找到FHG，故G是当前根节点；
C
/ \
B D
/ /
A E
\
G
在中序中找到FGH，故F是G的左子树，H是G的右子树；
C
/ \
B D
/ /
A E
\
G
/ \
F H
然后就大功告成啦！
二、通过前序、中序遍历结果画出二叉树 例题如下：
由前序遍历结果得知根节点为A；
A
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7007c3371b22bd045d7062abb0b7e32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1ec5cf8af4c4dafbeb31db5032525df/" rel="bookmark">
			SQL SERVER 18456 状态 11 用户＜域\计算机名＞登录失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以域管理员登陆域里的一个服务器后，以windows身份验证方式登录一直报错，在网上查到了不少关于此错误的一些方法，都不怎么实用，后来在官方页面看到了错误的具体解释，猜测也许是因为没有创建登录名。
登录之前创建的一个登录名test，test已经给了sysadmin的权限。
然后创建一个登录名就是域管理员。
创建成功后，就可以直接用Windows验证方式登录了，记得给权限哦。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/274/">«</a>
	<span class="pagination__item pagination__item--current">275/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/276/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>