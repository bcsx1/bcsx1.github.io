<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/439725e4a4fabd17847e91facb3cde1c/" rel="bookmark">
			04 递归问题【数据结构与算法学习笔记(Java)】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构与算法（Java实现） 我的学习资料：
视频：尚硅谷Java数据结构与java算法（Java数据结构与算法）
书籍：《大话数据结构》
笔记中包括学习的内容，代码，同时自己总结了知识点速记（部分会带页内跳转，可点击跳转）供快速回顾和记忆学到的知识点。
五、递归（Recursion） 5.1 递归的应用场景 迷宫问题（回溯），递归
在后台可以看到小球从起点找到去终点的路(1代表墙壁，2代表走过的路)
5.2 递归的概念 简单来说：递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时让代码变得简洁。
5.3 调用机制 以打印问题和阶乘问题为例
递归调用规则：
当程序执行一个方法时，就会开辟一个独立的空间每个空间的数据（局部变量）是独立的
代码演示 public class RecursionTest { public static void main(String[] args) { // TODOAuto-generated method stub //通过打印问题，回顾递归调用机制 //test(4); int res = factorial(3); System.out.println("res=" + res); } //打印问题. public static void test(int n) { if (n &gt; 2) { test(n - 1); } //else { System.out.println("n=" + n); // } } //阶乘问题 public static int factorial(int n) { if (n == 1) { return 1; } else { return factorial(n - 1) * n; // 1 * 2 * 3 } } } 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/439725e4a4fabd17847e91facb3cde1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/262c6646ea6645c958ec7392ce1ea4df/" rel="bookmark">
			解决spring-cloud 注册nacos caused: dom name can only have these characters: 0-9a-zA-Z-._:的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误信息：java.lang.IllegalStateException: failed to req API:/nacos/v1/ns/instance after all servers([47.110.190.248:8848]) tried: failed to req API:xx.xx.xx.xxx8848/nacos/v1/ns/instance. code:400 msg: caused: dom name can only have these characters: 0-9a-zA-Z-._:, current: DEFAULT_GROUP@@sino-com/sino/cloud/service/social;
Application.run() 里面出现了/号 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/548030087a14d4ab3c773a8978c4837a/" rel="bookmark">
			nginx泛域名配置-私有二级域名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 通过nginx配置实现个性化二级域
配置域名的泛域名解析，如 *.m.domain.com, *.domain.com等配置nginx，反向代理的话，需要加proxy_set_header Host $host， 否则server取不到正确的host server { listen 80; server_name ~^(?&lt;subdomain&gt;.+)\.m\.domain\.com$; location /{ proxy_pass http://xxx/; proxy_set_header Host $host; } } python接口取request.host得到subdomain 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9babd0ebe8b01d56d97804424fa97a7e/" rel="bookmark">
			opencv 中Mat的基础使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用一段程序来展示opencv中Mat的基础用法。这个程序将原图以灰度图的方式读入，进行直方图均衡化处理。
#include "opencv2/highgui/highgui.hpp" #include "opencv2/imgproc/imgproc.hpp" #include &lt;iostream&gt; #include &lt;stdio.h&gt; using namespace cv; using namespace std; int main(int argc, char** argv) { //声明原图和目标图以及窗体名称 Mat src, dst; string source_window = "Source image"; string equalized_window = "Equalized Image"; //以灰度图形式读入lena图像 src = imread(lena_path, IMREAD_GRAYSCALE); // Mat img = imread(filename, IMREAD_COLOR); //确认src不为空 if (!src.data) { cout &lt;&lt; "不能读取文件" &lt;&lt; endl; return -1; } //确认为灰度图 CV_Assert(src.channels() == 1); //显示输入图像 imshow("输入图像", src); waitKey(0); // 输出图片的高度与宽度 cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9babd0ebe8b01d56d97804424fa97a7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c7b1aae68e71307bfc42720394c0823/" rel="bookmark">
			java&#43;swing&#43;mysql学生成绩管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学生成绩管理系统 java+swing+mysqlwindowbuilder先上主界面图片代码最后使用该程序或者是想要学习更简单的课设 java+swing+mysql 这是大二的java课设，主要是用了 Eclipse，windowbuilder插件和mysql完成，介于csdn上大多数界面做的很复古，让人以为swing做的界面很丑，所以我发布这个博客反驳一下，swing照样可以做的很好看（可能我做的还不是很好看）。
windowbuilder windowbuider是个挺好的插件，但是有人说他并不好，其一 容易崩溃，其二 写的代码太乱。我通过摸索得到了更多的windowbuilder正确使用的方法，但是windowbuilder的使用教程并不在本博客内。
先上主界面图片 这是今年做的管理系统主界面qu图片: 插入和查询等功能都实现了 查询功能还实现了不同科目的排名
右边的滚动条还是有点丑，实在不会操作了，不过比原版的JTable好看多了
fng一下去年做的被老师吐槽的界面：
是不是差距瞬间就有了，看了今年的这个界面，去年的简直不忍直视
#层次结构
当然我现在其实还是初学者- -结构还是很乱的
代码 //student public class student { private String name; private double java; private double math; private double datastruct; private double english; private double total; private double Average; private int paiming; public int getPaiming() { return paiming; } public void setPaiming(int paiming) { this.paiming = paiming; } public student(String name, double java, double math, double datastruct, double english, double total, double average) { super(); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c7b1aae68e71307bfc42720394c0823/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55562812d927086cf8244dd5f0d687b6/" rel="bookmark">
			laya使用ide创建的页面，作为局部UI动态加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当你想创建局部UI动态加载使用时：
1、要注意画布大小要设置为设计分辨率，画布以外的空间不能触发点击事件
2、使用多个时，开启scene的mousethrough
可以考虑动态加载prefab，使用方式如下：
1、官方方式
https://ldc2.layabox.com/doc/?nav=zh-as-8-0-0
先声明一个预设变量 {Laya.loader.create("prefab/预设名字.json",Handler.create(this,onComplete)); } private function onComplete(obj:Object):Void{ 一个预设变量.json = ojb 一个sprite = Pool.getItemByCreateFun("自己起一个名字", this.一个预设变量.create, this.一个预设变量); } 2、其他方式
let resPath = "prefab/abc.json"; Laya.loader.create(resPath, Laya.Handler.create(this, ()=&gt;{ let prefab = Laya.loader.getRes(resPath); let sprObj = prefab.create() as Laya.Sprite; this.owner.addChild(sprObj); }), null, Laya.Loader.PREFAB); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cbce4792c9396cb7d18b49faa91184d/" rel="bookmark">
			String类型和8种基本类型及其包装类之间的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		String类型和8种基本类型及其包装类之间的转换 weiyastory 2016-04-11 19:44:52 1494 收藏
分类专栏： java基础
版权
第十五讲
1、先说其他类型转换为String类型：
一：采用Object.toString()
toString方法是java.lang.Object对象的一个public方法。在java中任何对象都会继承Object对象，所以一般来说任何对象都可以调用toString这个方法。这是采用该种方法时，常派生类会覆盖Object里的toString()方法。但是在使用该方法时要注意，必须保证Object不是null值，否则将抛出NullPointerException异常。
如果用toString（）分两种情况：
（1）如果是引用数据类型转换为String类型，则为： 引用数据类型.toSring( 需要转换的引用数据类型对象 );
（2）如果是基本数据类型转换为string 类型，则为： 基本数据类型对应的包装类. toString( 基本数据类型的变量 );
二、采用(String)Object
该方法是一个标准的类型转换的方法，可以将Object转换为String。但是在使用该方法是要注意的是需要转换的类型必须是能够转换为String的，否则会出现CalssCastException异常错误。
Object o = new Integer(100);
String s = (String)o;
这段程序代码会出现java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String。因为将Integer类型强制转换为String类型，无法通过。
三、String.valueOf(Object)
上面我们使用Object.toString()方法时需要担心null问题。但是使用该方法无需担心null值问题。因为在使用String.valueOf(Object)时，它会判断Object是否为空值，如果是，则返回null。下面为String.valueOf(Object)的源码：
public static String valueOf(Object obj)
{
return (obj == null) ? “null” : obj.toString();
}
从上面我们可以看出两点：一是不需要担心null问题。二是它是以toString()方法为基础的。
但是一定要注意：当object为null时，String.valueOf（object）的值是字符串对象：“null”，而不是null！！！
参考大神的：http://www.jb51.net/article/43515.htm
2、再说String类型转换为基本数据类型以及相应的包装类的方法：
一、如果将String类型转换为包装类所对应的基本数据类型，所用的方法如下
包装类 返回值（返回的是基本数据类型） 方法名
Integer int public static int Integer parseInt ( String s )
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cbce4792c9396cb7d18b49faa91184d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1331b884371400a20a5c1e35f4f29629/" rel="bookmark">
			HTTP协议介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http协议 HTTP协议称为超文本传输协议，是客户端与服务器通讯的一种标准，客户端和服务器都哦遵循HTTP协议，就能从彼此发送的信息中提取自己想要的数据 特点 http协议遵循请求/响应模型 http协议是一个无状态协议，由于每次响应请求后，服务器客户端的连接会断开，这样，服务器会认为每次请求的用户都是新用户，http协议是一种无状态协议 http协议占用的是80端口 http协议i工作流程 1：客户端和服务器建立连接 2：客户端像服务器发送http请求 3：服务器产生http响应，回发给客户端 4：关闭连接 http请求信息 组成： 请求行：描述请求方式，请求URL地址，http协议版本 请求头：以键值对方式，描述客户机相关的信息 空行：标识请求头的结束 消息体（POST）：描述客户端请求的表单数据 请求方式： GET,POST,HEAD,OPTIONS, PUT, DELETE, TRACE, CONNECT GET请求：什么是GET请求 用户再浏览器中输入地址 用户点击超链接 用户提交表单，表单的method属性为get,或默认 POST请求：什么是POST请求 用户提交表单，表单是method属性为POST, GET请求和POST请求的区别 1：流格式的区别 ，GET请求的表单是附件再URL后面的，所以，没有消息体，而POST请求有消息体，再消息体中描述表单数据
2:用途的区别： GET方式主要用于资源的查找，而POST主要用于数据的传输，也就是如何将本地客户端的数据提交给服务器
3：传输性能的区别， 1:GET方式只能传输小文本数据，而POST方式可以传输大文本数据，而且可以传输二进制数据 2： GET方式提交表单数据时，会在浏览器地址栏中显示表单数据，很不安全，而POST表单数据在消息体中，提交表单时，浏览器地址栏中不会显示表单数据，相对安全 3： GET方式在浏览器中可以缓存，可以通过后退键返回之前的网页，而POST方式不会缓存 http协议的响应信息 组成 1：响应行： 描述http版本，状态码，以及响应描述 2：响应头：以键值对的方式描述服务器的相关信息 3：标识响应头的结束 4：消息体：服务器发送非客户端的句体数据 状态码，响应码 100-199：表示信息性代码，标识客户端应该采用其他动作，请求正在进行 200-299：表示客户端请求成功 300-399：表示用于以及移走的资源文件，职时新的地址 400-499：表示由客户端引发的错误 500-599：由服务器引发的错误 MME类型 MME类型是设定某中扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定的应用程序来打开
常见的MME类型 text/html:html网页 image/jpeg:jpg图片数据 application/json:json数据 text/xml:xml数据 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f136310f545582f952a40f0722f60a4/" rel="bookmark">
			php 结束for循环_php for 循环语句使用方法详细说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		for 循环是 PHP 中最复杂的循环结构。它的行为和 C 语言的相似。在PHP中使用的是执行相同的代码集的次数
for循环只是一个多一点的代码，同时循环添加到它。而所涉及的一个循环的共同任务是：
设置一些计数器变量的初始值。
请检查条件语句是正确的。
执行中的代码循环。
增量在每个迭代结束通过循环计数器。
for循环允许你定义一个简单的代码行这些步骤。它似乎有一种奇怪的形式，所以一定要密切注意语法用！
for 循环的语法是：
for (expr1; expr2; expr3)
statement
第一个表达式(expr1)在循环开始前无条件求值一次。
expr2 在每次循环开始前求值。如果值为 TRUE，则继续循环，执行嵌套的循环语句。如果值为 FALSE，则终止循环。
expr3 在每次循环之后被求值(执行)。
每个表达式都可以为空或包括逗号分隔的多个表达式。表达式 expr2 中，所有用逗号分隔的表达式都会计算，但只取最后一个结果。expr2 为空意味着将无限循环下去(和 C 一样，PHP 认为其值为 TRUE)。这可能不像想象中那样没有用，因为经常会希望用 break 语句来结束循环而不是用 for 的表达式真值判断。
看简单实例一
FOR ($i = 0; $i &lt;= 2; $i++)
{
print "value is now " . $i . "
";
}
输出值
value is now 0
value is now 1
value is now 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f136310f545582f952a40f0722f60a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/087a66cae0b2d2b861692f58241ed5f6/" rel="bookmark">
			FairyGUI虚拟列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先上代码为敬：
hero_List.itemRenderer = RenderListItem; hero_List.defaultItem = "ui://o3ujglcdqacwi3t"; hero_List.SetVirtual(); hero_List.numItems = LocalConfigManager.Instance.GetDic_HeroPONum(); hero_List.SetVirtualAndLoop(); 虚拟列表开启的前提条件：
1、需要定义itemRenderer hero_List.itemRenderer = RenderListItem; 注：RenderListItem方法是固定的方法类型
2、需要开启滚动。溢出处理不是滚动的列表不能开启虚拟。
3、需要设置好列表的“项目资源”。可以在编辑器内设置，也可以调用GList.defaultItem设置。
hero_List.defaultItem = "ui://o3ujglcdqacwi3t"; 这里的资源项就是在FairyGUI中设置的Item
注：虚拟功能只能开启，不能关闭。
更多详细情况请查看官网：https://www.fairygui.com/docs/guide/editor/list.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b6985c3319f8c6537b47a05298b6409/" rel="bookmark">
			vm虚拟机安装VMware Tools弹出‘安装程序无法自动安装主机-客户机共享文件夹驱动程序’
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		** 本人是在用VM16安装win7系统时遇到的，百度了好多种方法都没有效果，最后找到一个可行的办法。
这个问题的解决方法亦可解决‘安装程序无法自动安装VMCI’的问题。
问题出现原因 这个问题是由于微软从2019年12月3日已将Windows驱动程序签名更改为使用SHA-2算法，不支持SHA-2代码签名的旧版Windows系统将无法通过驱动程序签名验证。也就是说你的win7或者Windows Server 2008 系统中缺少使用新算法的签名，原来的SHA-1算法过时了。
详情见https://support.microsoft.com/en-us/topic/sha-2-code-signing-support-update-for-windows-server-2008-r2-windows-7-and-windows-server-2008-september-23-2019-84a8aad5-d8d9-2d5c-6d78-34f9aa5f8339
解决办法 1.点击下列网址进入补丁下载界面
http://www.catalog.update.microsoft.com/search.aspx?q=kb4474419
2.选择相应的补丁进行安装
我的是win7 64位系统，所以选最后一个，点击右侧‘Download’进行下载。 如果是32位系统就选倒数第二个。
3.把下载好的文件拖到虚拟机中
由于已经安装过一遍VMware Tools了（只是没有自动安装VMCI），所以可以把电脑中的文件拖动复制到虚拟机中。
如果你无法把电脑中的文件复制到虚拟机中，请参照这篇文章https://www.cnblogs.com/chun-xiaolin001/p/10285377.html
还是不行就用百度网盘、腾讯网盘之类的或者使用QQ共享文件。
4.双击虚拟机中的文件进行安装
安装过程等一下就好了
5.重新安装VMware Tools
后面就不一一赘述了，重新安装就行了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e732318574eed172c078b3119347e345/" rel="bookmark">
			什么是rs232？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：https://www.usr.cn/News/1626.html
什么是RS232协议?
RS232协议是一种流行的串行接口，用于将计算机连接到诸如串口服务器之类的联网设备。我们将了解用于实现RS232的串口引脚以及有关该协议的一些其他参考信息。
RS232协议使用不同于标准5V的信号电平传输电线数据，以最大程度地减少信号干扰。它以恒定速率执行异步传输，该速率与起始脉冲信号的电平同步。最长20米的距离是使用RS232接口进行可靠数据传输的极限。
RS232代表什么?
数据传输标准是由电子工业协会(EIA)制定的。前缀RS表示推荐标准，所有EIA标准均以这些字符开头。RS232的正式规范是它是一个使用串行二进制数据交换在DTE和DCE设备之间进行通信的接口。DTE是数据终端设备的缩写，而DCE代表数据通信设备。这两种设备的基本示例将计算机定义为DTE设备，而串口服务器充当了DCE的角色。
串行通信通过在DTE和DCE之间传输串行数据来实现。例如，计算机(DTE)可能会将二进制数据“ 11011101”串行发送到串口服务器(DCE)，然后串口服务器通过将“ 11010101”发送回DTE设备进行答复。
RS232协议在指定的操作模式、电气标准、位的数量和电压电平传送DTE和DCE之间数据时被使用。
串口服务器–串口通信设备
串口通信设备使用9或25针D型连接器进行电缆连接。它们通常被指定为DB-9或DB-25，其编号用于区分引脚数。各种制造商的名称可能会替换规范中的DB。插头包含插座和插针，每个插针都有编号和标记。串行引脚分配图如下所示。
RS232协议使用9针串行端口，该端口可以具有公接头或母接头。该协议的最新版本称为RS232C。
RS232C保留了RS232的功能，但使用25针而不是9针的串行引脚。无论使用DB9串行引脚输出还是25引脚连接，仅需三个引脚即可连接终端设备。
COM端口引脚排列和配置
RS232使用DB9或DB25的串行引脚分配来管理DTE和DCE之间的通信流。这些D-sub连接器可以以RS232母头插针或DB25或DB9母头插针端接。9或25串行连接器引脚排列中的每个引脚都有其自己独特的功能。您还可以了解RS485引脚排列。
功能说明：
除了定义电气特性外，RS232还指定用于串行电缆引出线和串行端口的信号。这些规格中包括计时信号和接地等熟悉的项目。
以下是RS232 COM端口引脚分配中使用的信号列表：
保护性接地：此信号连接到金属连接器的机箱接地。
公共接地：所有控制信号的零参考电压电平。
TxD(传输引脚)：将数据从DTE传输到DCE。
RxD(接收引脚)：将数据从DCE发送到DTE。
DTR(数据终端就绪)：DTE准备接受请求。
DCD(数据载波检测)：DCE从位于远程位置的DTE接受载波。
DSR(数据集就绪)：DCE准备发送和接收信息。
RI(振铃指示器)：检测电话线上的来电铃声。
RTS(发送请求)：DCE的DTE调用以发送数据。
RTR(准备接收)：DTE已做好准备以接收来自DCE的数据。
CTS(清除发送)：DCE处于就绪状态，可以接受来自DTE的数据。
这些信号是主要的RS232信号，但是协议也允许次要信号。它们包括辅助DTE，RTS，DCD，TxD和RxD。辅助信号用于可选地连接DTE和DCE设备。
RS232空串口联网转换器连接
串口服务器使DTE和DCE设备之间可以进行串行通信。RS232空串口联网转换器引出线将公连接器的Tx引脚与RS232母头上的Rx引脚以及Rx公头的引脚连接到母头的Tx引脚。
使用RS232协议，您可以使用零串口连接线连接两台没有串口联网转换器的计算机。这突出了RS232协议的原始用途之一，该协议的开发目的是使电传打字机通过其串口服务器相互通信。
直通电缆
RS-232电缆的另一种类型是直通电缆。它是一对一的连接器，它传输一个设备的引脚，该引脚连接到另一设备的传输引脚，一个设备的接收器引脚连接到另一设备的接收器引脚。
原因是，RS232信号传播的距离更长。而且，它具有更好的抗噪性（与SPI、I2C相比）。事实证明，它在连接计算机和串口服务器的不同制造商之间兼容。
笔记：RS232,RS422为全双工通信。其中RS232有一条发送线、一条接收线及一条地线即可完成通信。而RS422则是因信号的输入和输出分开，所以需要两根双绞线来传送输入和输出信号，标为A、B、Y、Z(A为输入信号的正极，B为输入信 号的负极，Y为输出信号的正极，Z为输出信号的负极)。
RS485半双工通信，由A,B形成的双绞线来实现数据传输。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acd0259ec20dd2ecb9b343da4bc2c6a5/" rel="bookmark">
			js闭包的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么叫闭包 闭包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成 " 定义在一个函数内部的函数" 。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
2. 闭包的三大特性 内嵌函数：函数嵌套函数，内嵌函数对函数中的局部变量进行访问局部变量：在函数内定义有共享意义的局部变量外部使用：函数向外返回此内嵌函数，外部可通过此内嵌函数访问声明在函数中的局部变量，而此变量在外部是通过其他路径无法访问的参数和变量不会立即被垃圾回收机制回收 3. 闭包的优点 可读取函数内部的变量局部变量可以保存在内存中，实现数据共享执行过程中所有变量都匿名在函数内部 4. 闭包的缺点 使函数内部变量存在于内存中，内存消耗大滥用闭包可能导致内存泄露闭包可以在父函数外部改变父函数内部的值，慎操作 5. 闭包的产生条件 作用域嵌套
在父级作用域里生成了一个变量 var i=0 在子作用域里使用这个变量，这样声明的那个变量 i 就是 自由变量，这种作用域嵌套环境叫做 闭包环境。
在内存中存在和回收站相似的机制，叫做 垃圾回收机制。自由变量在函数关闭后被放在垃圾回收机制里，当下次调用时，再重新出来。
6. 闭包的使用场景 模拟私有方法setTimeout循环匿名自执行函数结果要缓存场景实现类和继承 7. 使用闭包的注意点 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 8. 为什么要使用闭包？ 使用闭包可以延长局部变量的生命周期，不让局部变量使用后立即释放，被删除。 // 当声明变量 i 在outFn 函数外面时，输出结果为：1,2,3,4 var i=0; function outerFn(){ return function innerFn(){ i++; console.log(i); } } var fn1 = outFn(); fn1(); fn1(); var fn2 = outFn(); fn2(); fn2(); // 当声明变量 i 在innerFn函数里面时，输出结果为：1,1,1,1 // (当函数重复调用的时候，其内部的局部变量会被重新声明) function outerFn(){ return function innerFn(){ var i=0; i++; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acd0259ec20dd2ecb9b343da4bc2c6a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42216daf9a8417a5948ddcb20ecc77a6/" rel="bookmark">
			js方式调用php_如何从HTML或Javascript调用PHP文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何打个按钮调用PHP？
I don’t care if the page reloads or displays the results immediately;
好！
注意：如果您不想刷新页面,请参阅“Ok …但是如何使用Ajax？”下面.
I just want to have a button on my website make a PHP file run.
这可以通过一个带有单个按钮的表单来完成：
That’s it.
差不多.另请注意,有些情况下ajax确实是要走的路.
这取决于你想要什么.一般而言,当您想要避免重写页面时,您只需要ajax.你还说你不关心那个.
为什么我不能直接从JavaScript调用PHP？
If I can write the code inside HTML just fine, why can’t I just reference the file for it in there or make a simple call for it in Javascript?
因为PHP代码不在HTML中就好了.这是大多数服务器端脚本语言工作方式(包括PHP,JSP和ASP)的错觉.该代码仅存在于服务器上,并且在没有某种远程调用的情况下,客户端(浏览器)无法访问该代码.
如果您要求浏览器显示页面的源代码,您可以看到此证据.那里你不会看到PHP代码,因为PHP代码没有发送到客户端,因此无法从客户端执行.这就是为什么你需要做一个远程调用才能让客户端触发PHP代码的执行.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42216daf9a8417a5948ddcb20ecc77a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fd7273eddc2fb2c6137a5980a6d26d0/" rel="bookmark">
			php 获取前5天的日期_php-如何找出5天前的日期？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		php-如何找出5天前的日期？
好吧，下面的内容返回5天前的日期：
$days_ago = date('Y-m-d', mktime(0, 0, 0, date("m") , date("d") - 5, date("Y")));
但是，我如何才能找到5天前的任何日期，而不仅仅是今天？
例如：2008-12-02之前5天是多少？
Yeti asked 2020-01-15T16:45:43Z
8个解决方案
107 votes
我认为这样做的可读方式是：
$days_ago = date('Y-m-d', strtotime('-5 days', strtotime('2008-12-02')));
Mike answered 2020-01-15T16:46:02Z
13 votes
找出日期是从今天开始5天前在php
$date = strtotime(date("Y-m-d", strtotime("-5 day")));
找出日期是从今天开始的N天前
$date = strtotime(date("Y-m-d", strtotime("-n day")));
manoj singh answered 2020-01-15T16:46:26Z
11 votes
define('SECONDS_PER_DAY', 86400);
$days_ago = date('Y-m-d', time() - 5 * SECONDS_PER_DAY);
除此之外，您可以在任何日期使用strtotime：
$days_ago = date('Y-m-d', strtotime('January 18, 2034') - 5 * SECONDS_PER_DAY);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fd7273eddc2fb2c6137a5980a6d26d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b77b2e02a7aea5f7e5581b8cfc2c7a4/" rel="bookmark">
			慕课Java第三季学习及笔记整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习网址及截图和部分图片来源：https://www.imooc.com/learn/110
慕课Java第三季学习及笔记整理 一、异常与异常处理1-1 java异常简介概念异常体系结构 1-2 java中使用try...catch...finally...处理异常try会抛出很多种类的异常？ 1-3 java通过案例学习小结 1-4 练习题1-5 Java 中的异常抛出以及自定义异常throw自定义异常 1-6 练习题1-7 Java 中的异常链1-8 练习题1-9 经验总结模拟借书系统代码 二、认识java中的字符串2-1 什么是 Java 中的字符串2-2 Java 中字符串的不变性2-3 Java 中 String 类的常用方法 ⅠString类常用方法提示 2-4 Java 中的 String 类常用方法 Ⅱ“==” 和 equals() 的区别 2-5 认识 Java 中的 StringBuilder 类2-6 Java 中的 StringBuilder 类的常用方法StringBuilder方法String与StringBuilder的区别 2-7 练习题 第3章 Java 中必须了解的常用类3-1 Java 中的包装类基本类型和包装类之间的对应关系imgInteger 包装类的构造方法 3-2 java中基本类型和包装类之间的转换3-3 练习题3-4 java中基本类型和字符串之间的转换基本类型转换为字符串的三种方法字符串转换成基本类型的两种方法 3-5 练习题3-6 使用Date和SimpleDateFormat类表示时间注意： 3-7 Calendar类的使用3-8 使用Math类操作常用方法 第4章 Java 中的集合框架（上）4-1 java中的集合框架概述集合概念 4-2 Collection 接口 &amp; List 接口简介Collection接口List接口及其实现类--ArrayList 4-3 学生选课--创建学生类和课程类4-4 学生选课---添加课程 Ⅰ add4-5 学生选课---添加课程 Ⅱ addAll4-6 学生选课—课程查询 迭代器&amp;foreach4-7 学生选课—课程修改 set4-8 学生选课—课程删除 remove&amp;removeAll4-9 学生选课---应用泛型管理课程 Ⅰ集合与泛型泛型&lt;&gt; 4-10 学生选课---应用泛型管理课程 Ⅱ4-11 学生选课---通过 Set 集合管理课程 第5章 Java 中的集合框架（中）5-1 Map &amp; HashMap 简介Map接口HashMap类 5-2 学生选课---使用 Map 添加学生5-3 学生选课---删除 Map 中的学生Map增删改查： 5-4 学生选课---修改 Map 中的学生 第6章 Java 中的集合框架（下）6-1 学生选课---判断 List 中课程是否存在"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b77b2e02a7aea5f7e5581b8cfc2c7a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b62be63b204b3db9d5ce9c08bf68306/" rel="bookmark">
			双目红外相机两图之间的仿射变换矩阵快速计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 需求是这样的，有一个双目红外相机，一个镜头是RGB摄像头，一个是红外摄像头。传统的双目摄像头都是用经典的棋盘格标定，这个老经典方法了，无论是Matlab还是其他语言。
但是传统的方法是针对两个完全相同参数的相机设计的，而我们的双目红外相机，一个镜头是普通的镜头，另一个是红外镜头，无法直接应用棋盘格方法。
那么我们如何将一张图上的点对应到另一张图上呢？
正文 关键问题 视差问题分辨率不同 RGB: 1440*1080红外: 640*480 针对这个问题，我们简化传统方法，忽略图像的畸变。因为双目相机物品相对的平行度不变，我们可以采用仿射变换进行操作，相关介绍看这里。
仿射变换 因为红外图像与RGB图像的分辨率并不统一，同时因为物理视角的问题，存在视差。因此，RGB图像需要进行一些变换来匹配红外图像，为了正确匹配图像，需要进行一些缩放、旋转和平移操作。
我们可以通过标定RGB图像和红外的特征点，换算出他们之间的转化关系矩阵。矩阵变换公式如下：
( x ′ , y ′ ) (x^\prime,y^\prime) (x′,y′)是红外图像的坐标， ( x , y ) (x,y) (x,y)是RGB图像的坐标。 a 1 − 4 a_{1-4} a1−4​获取了两个图像之间的转化因子， t x t_x tx​、 t y t_y ty​表示了两个图像之间平移变量。至少需要3对匹配点来计算6个变量，但是更多的匹配点能够减少手动打标签带来的误差。所以我们每对图片至少设置了10对匹配点。
因为两个相机之间的物理角度和距离是不会改变的，因此只需要一次执行就能完成设置。
Python代码 GitHub仓库。这个仓库是我写的一个小工具，能够支持用户手动标定特征点，然后根据特征点进行仿射变换矩阵计算。经过实际测试，1m的距离内，核心区域的误差率在百分之一以下。
思路设计 添加数据点: 用于手动标定图像对，标定少量图像即可仿射变换矩阵计算: 使用RANSAC方法计算矩阵A点映射正确率测算: 将矩阵A实际应用到测试集上，与手动标定的结果对比 关键方法是OpenCV的cv2.estimateAffine2D方法，确定了target和source数据集之后，就可以得到放射变换矩阵了，得到的矩阵是一个2*3的矩阵。
OpenCV的底层原理默认方法是RANSAC方法，这个原理可以查看这个PPT，我已分享到百度网盘：
链接: https://pan.baidu.com/s/18NI3NNRFpmJZxw9XohEfEQ 密码: 85ef
相比于最小二乘法，RANSAC有着更强的鲁棒性，他能够减少一些手工标记错误点的影响，因此使用默认的RANSAC方法。后面考虑再仔细研究一下RANSAC方法，讲解一番。
最终效果 def predict_msx_by_dc(coordinates_dc, matrix): coordinates_predict = {} trans_matrix = matrix.T # reshape to (3, 2) for tag, coordinate in coordinates_dc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b62be63b204b3db9d5ce9c08bf68306/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e4f6bcea832fc33ee3b597ba3b1aa2d/" rel="bookmark">
			rabbitmq beam.smp cpu利用率过高
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的，而集群和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库。
问题：
rabbitmq 的吞吐有多大？
目前开启了rabbitmq的持久化/Ack 机制/用的是direct路由器。
上次测试，4.5w/min 的时候，beam.smp cpu利用率过100%
下午做了个测试，不阻塞下游，只测试rabbitmq 的消费速度：
golang 实现如下：
package main import ( "fmt" "github.com/streadway/amqp" "sync" ) const ( queueName = "queue.newpushservice.deal.push" exchange = "exchange.newpushservice.deal.push" mqurl = "amqp://admin:admin@172.18.19.168:5672/" ReceiverNum int = 5 ChannelBufferLength = 1000 ) func main() { fmt.Println("start") forever := make(chan bool) go WorkMessage(ReceiveMessage()) &lt;-forever } func getChannel() (*amqp.Connection, *amqp.Channel, error) { conn, err := amqp.Dial(mqurl) if err != nil { return nil, nil, err } channel, err := conn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e4f6bcea832fc33ee3b597ba3b1aa2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d2e691687bd87c71422fcb67f6b8ee7/" rel="bookmark">
			idea导入maven工程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		idea导入maven工程 前言第一种导入项目的方法第二种导入项目的方法第三种导入项目的方法总结 前言 博主发现idea中有几种不同的导入项目的方法，特此记录一下，供大家参考
提示：以下是本篇文章正文内容，下面案例可供参考
第一种导入项目的方法 第二种导入项目的方法 第三种导入项目的方法 小栗子正在上传，审核过了，会贴上连接
点击下载
总结 博主建议使用第三种导入方式，导入maven项目，不会改变maven的项目结构，以上仅仅是博主的个人的一点小经验，如果有不对的地方，还请大家指出来哈，多多分享才能一起进步嘛，嘿哈！~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a3de21d88e98ff051b0d60e598d2b57/" rel="bookmark">
			IDEA创建Maven项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA创建Maven项目 前言先创建一个maven工程，流程如下：Maven使用入门，小案例 前言 一些小问题：
关于maven无法创建servlet可以点击查看：《idea 的maven无法创建servlet》
先创建一个maven工程，流程如下： 以上maven工程创建完成了。
Maven使用入门，小案例 按照以上步骤，创建的maven工程，结构如下：
maven目录结构里面缺少了Java源文件夹，需要我们手动添加上去，过程如下：
先新建目录
3. 再将新建的文件设置为源文件
4.在java新建包，再在包里新建一个servlet，关于maven无法创建servlet，可以参考前言里的解决办法进行相应设置，
项目的结构如图：
servlet代码如下：
package aa.bb; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet("/testServlet") public class TestServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.getRequestDispatcher("/test.jsp").forward(request, response); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { doPost(request, response); } } jsp代码如下：
&lt;%@ page contentType="text/html;charset=UTF-8" language="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a3de21d88e98ff051b0d60e598d2b57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/417b987d6fd6248ea95172c3113f91fe/" rel="bookmark">
			Oracle常见死锁发生的原因以及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.删除和更新之间引起的死锁 造成死锁的原因就是多个线程或进程对同一个资源的争抢或相互依赖。这里列举一个对同一个资源的争抢造成死锁的实例。
CREATE TABLE testLock( ID NUMBER, test VARCHAR(100) ) COMMIT INSERT INTO testLock VALUES(1,'test1'); INSERT INTO testLock VALUES(2,'test2'); COMMIT; SELECT * FROM testLock ID TEST ---------- ---------------------------------- 1 test1 2 test2 死锁现象的重现：
1.在sql 窗口 执行：SELECT * FROM testLock FOR UPDATE; -- 加行级锁 并对内容进行修改，不要提交
查询死锁：
select s.username,l.object_id, l.session_id,s.serial#, s.lockwait,s.status,s.machine,s.program from v$session s,v$locked_object l where s.sid = l.session_id;
字段说明：
Username：死锁语句所用的数据库用户；
SID: session identifier， session 标示符，session 是通信双方从开始通信到通信结束期间的一个上下文。
SERIAL#: sid 会重用，但是同一个sid被重用时，serial#会增加，不会重复。
Lockwait：可以通过这个字段查询出当前正在等待的锁的相关信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/417b987d6fd6248ea95172c3113f91fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b81fe201c929184b7929ec1dd1ba228/" rel="bookmark">
			【C#】.net 5 踩坑 记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前的项目都是 .net framework 的，未曾正式触碰到 .net core，但是 最近 项目 使用了 .net 5,踩了不少坑，所以再次做个记录（不一定是 .net core 的 坑）。
1. 关于 https 的。项目 运行的 时候 给默认 是 https的了，导致 http 的 图片 显示 失效 百度了之后，看到 这篇文章 ，里面写道 相关的 内容， 应该是创建 项目的时候给 选到 了 配置 https 或是 ssl ，
不过 按里面的 做法 还没有 解决 问题 ，后面 直接项目 右键 → 属性 → 调试 → 取消 勾选 启用ssl →保存重新运行 就好了 2. 用惯了 webApi 里的 ApiController 的 return Json(object) 目前 发现 可以 改用 return new JsonResult(object) 来代替，不过现在 直接 使用 返回 实体 类型 了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b81fe201c929184b7929ec1dd1ba228/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eafb946897b958d086a3fc5f9d627892/" rel="bookmark">
			异常的概念以及异常的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异常(重点) 异常概念
异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。
在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。
异常体系
异常机制其实是帮助我们找到程序中的问题，异常的根类是 java.lang.Throwable ，其下有两个子类： java.lang.Error 与 java.lang.Exception ，平常所说的异常指 java.lang.Exception 。
异常和错误的区别
异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行
/* java.lang.Throwable:类是 Java 语言中所有错误或异常的超类。 Exception:编译期异常,进行编译(写代码)java程序出现的问题 RuntimeException:运行期异常,java程序运行过程中出现的问题 异常就相当于程序得了一个小毛病(感冒,发烧),把异常处理掉,程序可以继续执行(吃点药,继续革命工作) Error:错误 错误就相当于程序得了一个无法治愈的毛病(非典,艾滋).必须修改源代码,程序才能继续执行 */ public class Demo01Exception { public static void main(String[] args) /*throws ParseException*/ { //Exception:编译期异常,进行编译(写代码)java程序出现的问题 /*SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");//用来格式化日期 Date date = null; try { date = sdf.parse("1999-0909");//把字符串格式的日期,解析为Date格式的日期 } catch (ParseException e) { e.printStackTrace(); } System.out.println(date);*/ //RuntimeException:运行期异常,java程序运行过程中出现的问题 /*int[] arr = {1,2,3}; //System.out.println(arr[0]); try { //可能会出现异常的代码 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eafb946897b958d086a3fc5f9d627892/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c6dd9649357f6ed6acdcdbd2da54eb9/" rel="bookmark">
			pandas.DataFrame中iterrows()方法 转载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载来源：dechuan Pandas的基础结构可以分为两种：数据框和序列。
数据框（DataFrame）是拥有轴标签的二维链表，换言之数据框是拥有标签的行和列组成的矩阵 - 列标签位列名，行标签为索引。Pandas中的行和列是Pandas序列 - 拥有轴标签的一维链表。
iterrows()是在数据框中的行进行迭代的一个生成器，它返回每行的索引及一个包含行本身的对象。
所以，当我们在需要遍历行数据的时候，就可以使用 iterrows()方法实现了。
示例代码
import pandas as pd import numpy as np df = pd.DataFrame(np.random.randn(10, 4), columns=list('ABCD')) df 输出结果：
遍历行：
In [7]: for index, row in df.iterrows(): ...: print(index) ...: print(row) ...: ...: 0 A 1.035275 B -0.934941 C 0.701911 D -0.209808 Name: 0, dtype: float64 1 A 1.074598 B 0.290134 C 0.467647 D 0.055755 Name: 1, dtype: float64 2 A 1.105065 B 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c6dd9649357f6ed6acdcdbd2da54eb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e01a5b0bc32753c984e294ff2ce6d08f/" rel="bookmark">
			【论文笔记】DSIFN：用于高分辨率双时相遥感图像变化检测的深度监督图像融合网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是论文《A deeply supervised image fusion network for change detection in high resolution bi-temporal remote sensing images》的阅读笔记。
文章提出了一个深度监督图像融合网络DSIFN，首先使用量分支的全卷积网络进行特征提取，然后再用深度监督的差异判别网络DNN进行变化检测。为了提升变化图边界的完整性和内部的致密性，使用多层次的深度特征与图像差图特征通过注意力机制进行融合。
一、方法和网络结构 现有的深度学习方法有以下限制：1. 变化图边界的完整性和内部的致密性不好；2. 在双分支网络结构中，容易出现梯度消失；3. 怎么样在不同域中进行有效的特征融合是个问题。
上图是IFN网络的结构示意图。
上图是DNN的示意图。
深度图像融合网络IFN包括深度特征提取网络DFEN，差异判别网络DDN。DFEN的backbone是VGG-16，文章第一次尝试使用预训练网络进行端到端的变化检测任务。使用的注意力机制包括空间注意力和通道注意力，和CBAM注意力机制类似，大家可以去我博客搜一下，这里不再赘述。数据增强包括：1.图像旋转、2. 图像翻转、3. 增加噪声、4. 图像模糊、5. 图像平滑。
二值交叉熵损失公式如下：
L b c e = − t i log ⁡ ( y i ) − ( 1 − t i ) log ⁡ ( 1 − y i ) L_{b c e}=-t_{i} \log \left(y_{i}\right)-\left(1-t_{i}\right) \log \left(1-y_{i}\right) Lbce​=−ti​log(yi​)−(1−ti​)log(1−yi​)
其中， t i t_i ti​表示在像素 i i i处的GT值， t i = 1 t_i=1 ti​=1表示发生了变化， t i = 0 t_i=0 ti​=0表示未发生变化； y i y_i yi​表示像素 i i i处变化的概率； 1 − y i 1-y_i 1−yi​表示未变化的概率。文章中使用的sigmoid二值交叉熵损失，其公式如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e01a5b0bc32753c984e294ff2ce6d08f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c527594e42da37266b828bb12e3382aa/" rel="bookmark">
			Spring Boot集成mysql与Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：Spring Boot集成mysql与Redis
在项目搭建初期，我们便集成了mysql数据库，但是在现代的分布式架构中，往往还需要一种更高访问性能的键值数据库Redis。mysql结合redis解决了大多数软件系统的痛点，当然还有一些特殊的系统，需要保存大量的归档资料而用到分布式文件系统（比如GFS），需要同时满足数据强一致与高性能而自研了分布式数据库（比如OceanBase）。
本篇文章介绍我自己在Spring boot项目中，集成mysql与redis的过程，一些有关连接池的概念，遇到的一些坑，以及自己的想法。
tomcat连接池 tomcat提供了HTTP协议的web服务，如果tomcat的请求响应出现延迟，则必然会造成接口阻塞。创建连接是很消耗资源的，连接池能够很好地解决创建连接的问题，当请求结束时，不是真的物理上的关闭连接，而是将连接缓存起来，等待新的请求从而复用旧的连接。连接池这样的方式是对资源的一种抽象，客户端只要关心如何使用一个连接，而非如何获取一个连接，连接池返回的连接究竟是单例还是原型，取决于具体的实现。
tomcat连接池可选择的配置如下，每个配置条目将会覆盖tomcat对应的默认配置项：
server.tomcat.max-threads=211 server.tomcat.max-connections=10000 server.tomcat.accept-count=1000 max-threads 最大线程数。每一次HTTP请求到达Web服务，tomcat都会指派一个线程来处理该请求。最大线程数决定了Web服务容器可以同时处理多少个请求。maxThreads默认200。最大支持线程数受限于操作系统/CPU，过多的线程会导致系统频繁的上下文切换，会带来过多的内存消耗（JVM中默认情况下在创建新线程时会分配大小为1M的线程栈）。
max-connections 最大连接数。这个参数是指在同一时间，tomcat能够接受的最大连接数。对于旧版本Java的阻塞式IO，默认值等于最大线程数。对于Java 新的NIO模式，max-connections默认值是10000。如果设置为-1，则禁用max-connections功能，表示不限制tomcat容器的连接数。
accept-count 最大等待数。当所有的请求处理线程都在使用时，新的请求进入等待队列，当队列超过最大等待数时，任何的连接请求都将被拒绝。accept-count的默认值为100。max-connections和accept-count的关系为：当连接数达到最大值后，tomcat会继续接收连接，但不会超过accept-count的值。
tomcat的NIO模式“读取socket并交给Worker中的线程”这个过程是非阻塞的，当socket在等待下一个请求或等待释放时，并不会占用工作线程，因此Tomcat可以同时处理的socket数目远大于最大线程数，并发性能大大提高。
注意，测试并发效果时，测试工具不要选择浏览器，因为浏览器可能会做一些多余的动作影响测试结果，比如谷歌浏览器会对相同的请求参数队列化。
mysql与连接池 pom.xml添加mysql依赖之后，并在application.properties中配置了数据库源，在代码中就可以如下方式连接db
@Autowired private JdbcTemplate db; /** * 插入讲话 * @param talkContent 讲话内容 */ public boolean insertTalk(TalkContent talkContent){ return db.update("insert into talk_content(user_id,user_name,talk_content,talk_time) " + "values(?, ?, ?, now())", talkContent.getUserid(), talkContent.getUsername(), talkContent.getContent() ) &gt; 0; } Spring boot2.x默认使用HikariCP作为数据库连接池，在未配置的情况下，连接池以无感知的方式使用缺省参数初始化，可以在application.properties中显式配置：
# hikari spring.datasource.type=com.zaxxer.hikari.HikariDataSource spring.datasource.hikari.minimum-idle=2 spring.datasource.hikari.maximum-pool-size=2 spring.datasource.hikari.auto-commit=true spring.datasource.hikari.idle-timeout=30000 spring.datasource.hikari.pool-name=DatebookHikariCP spring.datasource.hikari.max-lifetime=1800000 spring.datasource.hikari.connection-timeout=30000 spring.datasource.hikari.connection-test-query=SELECT 1 测试连接池效果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c527594e42da37266b828bb12e3382aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b683371c0a7d1b4c645559bc2b7e8dba/" rel="bookmark">
			RocketMQ在项目中的简单实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：RocketMQ在项目中的简单实践
本文由一个特定的问题展开，讲述在项目中引入消息队列中间件的起因、过程与思路总结。
待解决的问题 在mytalk项目中，需要设计一个添加议题接口（由标题和内容等信息组成，相当于发一个微博话题），议题创建除了需要在数据库中添加记录外，还需要执行以下步骤：
通知议题相关的小组成员通知搜索引擎该议题上线给议题提出者增加积分未来可能增加的新的需求 更具体一些，我们希望第1，2两点的执行结果不影响议题本身的创建结果，最好也不要拖累创建议题这个基本业务的执行。也就是说，无论是通知失败还是通知过程异常，都是通知模块的事情，与议题创建接口无关，接口在逻辑上异步调用通知服务，单向通信，不必接收回调。我们希望第3点“给议题提出者增加积分”的操作的执行结果与议题创建的结果绑定，要么同时失败，要么同时成功，整体看作一个事务，不可以出现添加议题成功但是积分没有增加的情况。接口在逻辑上同步或异步完成添加积分的业务，但是在处理响应时，需要检查是否达成一致的状态，如有必要，需进行事务回滚。我们还希望未来这个接口能支持更多的功能，可以在添加议题成功或者失败时处理一些自定义业务。
观察者模式 如果是解依赖，这让我联想到观察者模式。观察者模式的实现思路是，在发布者类中声明一个委托列表，委托是可回调的接口或方法对象，订阅者在初始化时向发布者申请注册一个回调事件，发布者将该订阅者注册到自己的委托列表中，在目标事件触发时，遍历委托列表，逐个调用委托方法，由此订阅者收到事件的回传通知，进入到自己的方法执行过程。这的确是实现了解依赖，而且订阅者在事件发生的第一时间就能做成反应，但问题是，这是基于单线程的设计模式，不适用多线程，更不用说是不同机器上的服务了。
如果利用RPC，可以访问远程服务，观察者模式还能不能应用于服务间的解耦呢？可以用，但不能解耦。因为线程内的方法调用远远比远程服务的方法调用更可靠，只要是访问远程服务，就不可避免的需要看每个服务的脸色行事，网络延迟、计算超时、服务宕机都可能影响到发布者，因为发布者直接调用了这些远程方法。线程中的方法调用，多是同一组程序员完成的，很容易约定事件接收者的执行时间、同步异步协作方式等，因此使用观察者这种低依赖的设计模式即可，但是不同的服务可能是不同的团队甚至是不同的公司完成，暴露出的接口风格各不相同，完全不能信赖。
这时候就需要一个中间人，接受发布者传递的消息，并推送给订阅者，不管发布者和订阅者如何实现，如何故障，只保证自己的高吞吐，高可用。这个中间人一定是值得信任的，否则就退回到观察者模式的问题中，更有甚者，可以直接认为当消息发送到了中间人手里，就代表已经完成任务了，这是“基于信任编程”，这种编程方式是零耦合的。
​
消息队列RocketMQ Apache RocketMQ是一种低延迟、高并发、高可用、高可靠的分布式消息中间件。消息队列RocketMQ既可为分布式应用系统提供异步解耦和削峰填谷的能力，同时也具备互联网应用所需的海量消息堆积、高吞吐、可靠重试等特性。
消息队列核心概念：
Topic：消息主题，一级消息类型，生产者向其发送消息。Broker：中间人/经纪人，消息队列集群的节点，负责保存和收发消息。生产者：也称为消息发布者，负责生产并发送消息至Topic。消费者：也称为消息订阅者，负责从Topic接收并消费消息。Tag：消息标签，二级消息类型，表示Topic主题下的具体消息分类。消息：生产者向Topic发送并最终传送给消费者的数据和（可选）属性的组合。消息属性：生产者可以为消息定义的属性，包含Message Key和Tag。Group：一类生产者或消费者，这类生产者或消费者通常生产或消费同一类消息，且消息发布或订阅的逻辑一致。 生产者发送消息到消息队列，最终发送到消费者的示意图如下：
消息类型可以划分为：
普通消息。也称并发消息，没有顺序，生产消费都是并行的，拥有极高的吞吐性能事务消息。提供了保证消息一定送达到broker的机制。分区顺序消息。Topic分为多个分区，在一个分区内遵循先入先出原则。全局顺序消息。把Topic分区数设置为1，所有消息都遵循先入先出原则。定时消息。将消息发送到MQ服务端，在消息发送时间（当前时间）之后的指定时间点进行投递延迟消息。将消息发送到MQ服务端，在消息发送时间（当前时间）之后的指定延迟时间点进行投递 消费方式可以划分为：
集群消费。任意一条消息只需要被集群内的任意一个消费者处理即可。广播消费。将每条消息推送给集群内所有注册过的消费者，保证消息至少被每个消费者消费一次。 消费者获取消息模式可以划分为：
Push。开启单独的线程轮询broker获取消息，回调消费者的接收方法，仿佛是broker在推消息给消费者。Pull。消费者主动从消息队列拉取消息。 为什么要分Topic，分区 topic是逻辑概念。topic表示消息的主题，是消息系统中的抽象概念，生产者可以发布多个topic。
topic可能被大量消费者订阅，为了充分利用集群特性，topic将消息划分为多个分区（从实现角度来说是队列），再分布到多个集群节点上（broker），提供系统吞吐量。在广播消费模式中，一个队列将被所有消费者消费；在集群消费模式中，一个队列只被一个消费者线程消费，这保证了消费不会被重复消费。对于消费者端来说，可以消费多个分区的消息。
分区更倾向于是实现层面的概念，生产者和消费者并不需要关心分区，只需要关心Topic。但也注意到，分区只能被一个消费者实例消费，如果分区的设置数量小于消费者实例数，可能造成部分消费者线程空闲。
消费者组 消费者组是特定业务的服务集群，可以订阅一个topic，也可以订阅多个topic。官方文档上说明：消息队列 RocketMQ 的订阅关系主要由 Topic + Tag 共同组成，同一个消费者 Group ID 下所有 Consumer 实例所订阅的 Topic、Tag 必须完全一致。一开始我也有些疑惑，但后来发现这与订阅多个topic并不矛盾，只是一个Consumer 实例订阅Topic_A和Topic_B，那么同一组的其他Consumer也必须订阅Topic_A和Topic_B。这个规则只要不刻意违反其实很容易遵守，因为集群的原理之一就是一份代码多处布置，代码相同自然订阅关系相同。
订阅多个Topic的代码演示：
@Configuration public class ConsumerClient { @Autowired private MqConfig mqConfig; @Autowired private IssueMessageListener messageListener; @Autowired private OtherMessageListener otherMessageListener; @Bean(initMethod = "start", destroyMethod = "shutdown") public ConsumerBean buildConsumer() { ConsumerBean consumerBean = new ConsumerBean(); Properties properties = mqConfig.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b683371c0a7d1b4c645559bc2b7e8dba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26c8301808053960f72dd987f283ca50/" rel="bookmark">
			垂直居中的几种方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在CSS中最常用的就是居中对齐的样式，flex布局方法使得垂直水平居中变得非常容易，但是flex具有浏览器兼容问题，掌握其他CSS居中对齐的方法也是重要的。
其中，水平居中较为简单，通过判断元素是行内元素还是块级元素就能轻松区分：
行内或类行内元素：text-align: center;
块级元素：margin: 0 auto;
而垂直居中具有一定的难度，也有很多种方法；只要学好了垂直居中的几种方法，与水平居中轻松组合就能得出垂直水平居中的方案。
line-height 行高 适用于单行文本，不能应用于多行文本
设置子元素的line-height，用子元素的line-height撑开父元素
&lt;div id="parent"&gt; &lt;div id="child"&gt;Text here&lt;/div&gt; &lt;/div&gt; #child { line-height: 200px; } 图片
父元素设置line-height ;子元素设置vertical-align:middle;
&lt;div id="parent"&gt; &lt;img src="image.png" alt="" /&gt; &lt;/div&gt; #parent { line-height: 200px; } #parent img { vertical-align: middle; } table 通用，父元素设置成table布局，子元素为table-cell
&lt;div id="parent"&gt; &lt;div id="child"&gt;Content here&lt;/div&gt; &lt;/div&gt; #parent { display: table; height:200px } #child { display: table-cell; vertical-align: middle; } 绝对定位和负margin(已知子元素高度) &lt;div id="parent"&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26c8301808053960f72dd987f283ca50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dbabe9b3aa15adb8ce7d338587898b5/" rel="bookmark">
			关于BFC的定义及应用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BFC的定义 BFC（Block formatting context）块级格式化上下文，BFC里面的元素与外面元素隔离，使得里外元素的定位不会相互影响。
不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），有Block formatting context（BFC）和Inline formatting context（IFC）等。
BFC内部布局规则 BFC作为一种 Formatting Context，是脱离文档流的，其内部具有特殊的布局规则，掌握其内部的布局规则，对于理解BFC所产生的效果及应用都是有帮助的。
内部的Box（行盒和块盒）会在垂直方向，一个接一个地放置；Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠；（应用：防止垂直方向margin重叠）每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。（应用：两栏自适应）BFC的区域不会与float box重叠；BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。计算BFC的高度时，浮动元素也参与计算。（应用：清除浮动） BFC触发条件 根元素overflow不为visible的块元素floatposition:absolute或fixeddisplay:inline-block或table-cell或table-caption或flex BFC的应用 防止垂直方向margin重叠 同一个 BFC 下垂直方向的margin会发生折叠，为避免外边缘的重叠，可以将两个容器放在不同的BFC中 清除浮动（BFC内部可以包含浮动元素） 父元素不设置高度，子元素设定浮动，则会脱离了文档流，发生高度坍塌，这时可以触发BFC，使得BFC内部包含浮动元素。 阻止元素被浮动元素覆盖，自适应布局 这个方法可以用来实现两列或三列自适应布局 二列布局
//左固定，右自适应 &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="content"&gt;&lt;/div&gt; .left{ height:100px; width:100px: float:left; background-color:#000000; } .content{ height:100px; width:100000px://足够大 display:table-cell; background-color:#000fff; } 三列布局
//左右固定，中间自适应 &lt;div class="left&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;div class="content"&gt;&lt;/div&gt; /*这里注意顺序*/ .left{ height:100px; width:100px: float:left; background-color:#fff000; } .right{ height:100px; width:100px: float:right; background-color:#000000; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dbabe9b3aa15adb8ce7d338587898b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02469133ac4f1c06c89dd126892f7411/" rel="bookmark">
			Educoder - Java入门 - 方法的使用各关卡题目总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关 如何定义方法 package step1; public class HelloWorld { /********** Begin **********/ //定义一个方法，用来和老师打招呼 /********** End **********/	public static void main(String[] args) { helloEducoder(); } public static void helloEducoder() { System.out.println("hello teacher!"); } /********** Begin **********/	//调用方法 /********** End **********/ } 第2关 掌握无参有返回值方法的调用 package setp7; public class HelloWorld { public static void main(String[] args) { /********** Begin **********/ // 调用calcAvg()方法，并将返回值保存在变量avg中 double avg =calcAvg(); /********** End **********/ System.out.println("平均成绩为：" + avg); } // 定义一个返回值为double类型的方法 /********** Begin **********/ public static double calcAvg() { double java = 92.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02469133ac4f1c06c89dd126892f7411/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b570b2dbf3fafd95d4bbfc850f945484/" rel="bookmark">
			Javascript系列(八)：关于let和const是否会变量提升？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上很多博客和资料都写let和const不存在变量提升，只有var会产生变量提升，之前我一直对此深信不疑，直到看到大佬的文章开始对此产生了一点怀疑。
在理解这个问题之前，首先看看var let const的定义和区别。
var 在ES5前声明变量只能用var，且只存在函数作用域:
var message = "hi"; message = 100; //可以改变变量类型，合法但不推荐 age = 18; //不用var声明，代表全局变量 var存在变量提升：
//变量age自动提升到函数作用域顶部 function foo(){ console.log(age); var age = 26; } foo(); //等同于如下的代码： function foo(){ var age; //先声明，并赋值成undefined console.log(age); age = 26; } foo(); //undefined let / const let使得javascript具有块级作用域，const与let的唯一区别就是它在声明变量时必须同时初始化变量，且不能修改const声明的变量的值。
红宝书中文第四版P26中提到let与var的一个重要区别就是let存在暂时性死区，且let声明的变量不会在作用域中被提升
暂时性死区：在let声明之前的执行瞬间都被称为暂时性死区TDZ，在此阶段引用的任何后面才声明的变量都会抛出ReferenceError没有定义的错误。
//暂时性死区 console.log(name); //ReferenceError:name没有定义 let name = 'Jack'; 但是仔细翻翻红宝书P92中提到：
let在JavaScript运行中实际上会被提升，但由于“暂时性死区”的存在，不能在声明中使用let变量
也就是说let / const 实际上是存在变量提升的，但是由于暂时性死区的存在使let / const不能在声明之前被使用，这与var的变量提升不太一样。
所以，说let / const 不存在变量提升是不完全正确的，只能说由于暂时性死区的存在使得我们无法直观感受到变量提升的效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb84f65738bc69791df3bf58fa04fa28/" rel="bookmark">
			no remote repository
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		idea maven工程 no remote repository 如下图，创建maven工程后，明明本地仓库的路径都配置好了，这个地方却没有工厂的索引，这就导致配置pom.xml文件时基本没有提示，或者特别慢，还不全
最开始的时候，我一直以为是我的IDEA 的问题，因为我的idea好久没用了，确实有很多小问题，后来博主还没来得及重装idea，电脑就先挂了，重装了系统，后来再装了2020版本的idea后，这个问题就解决了，
总结一下原因：
idea版本问题，博主之前用的是2019.2.3的版本，我特地去看了一个师兄的idea，他也装的是这个版本的idea，也没有索引（极有可能）电脑Windows的问题，博主的电脑上回被我把注册表玩坏了，Windows变成未激活的了（电脑会在右下角有一个Windows未激活的水印，影响到idea的索引） 在用2019.2.3的版本的，又遇到这个问题的童鞋，建议重装idea，最好换一个版本的，因为博主还遇到过别的更奇葩的问题，博主之前在网上找了好久，压根就没找到这个问题的答案，
重装好之后的：
创作不易，如果这篇文章能够帮助到你，希望能关注或收藏一下博主，如果文章内容有问题也可留言讨论，我们一起学习，一起进步！！如有不足，也还请指正啊，嘿嘿嘿~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b8f1d7526686aab8e1d1f4f6d9c3140/" rel="bookmark">
			Can‘t launch Jupyter Notebook ModuleNotFoundError: No module named ‘resource‘解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Open this file: D:\conda3\Lib\site-packages\IPython\utils\timing.py
change import time to import timeitchange time.clock to timeit.default_timer 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23207dd7c0637a70aa092aeb9ab86e08/" rel="bookmark">
			java 包android studio_java-包android.support.v4.app不存在; 在Android Studio 0.8中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java-包android.support.v4.app不存在; 在Android Studio 0.8中
我最近将android studio IDE更新为0.8，以与新的android L SDK一起使用。 首先，我导入了一个完成的android项目，该项目在较旧版本的android studio中没有收到任何错误。 在版本0.8中，i行例如
import android.support.v4.app.Fragment;
get：无法解决支持，导致其余代码出错。 logcat返回101个实例
Error:(8, 30) error: package android.support.v4.app does not exist
每次在import语句中调用支持库时都为1。
我试过了
重新安装IDE
删除想法文件夹的内容
重新安装所有SDK(包括支持库)
同步gradle
手动将支持库复制到libs文件夹中
重建项目
以及创建一个新项目来测试库
不确定要做什么。
9个解决方案
109 votes
好的，所以我遇到了同样的问题，并在udacity论坛中找到了解决方案：
在Android Studio中：
右键单击您的项目的“ app”文件夹，然后单击-&gt;模块设置
点击“依赖项”标签
单击+号以添加新的依赖关系，然后选择“库依赖关系”
查找所需的库并添加它
Bernhardt Scherer answered 2020-02-04T14:06:34Z
33 votes
@boernard的答案是通过Android Studio IDE解决的，但是如果您想了解幕后情况，那是一个简单的gradle构建文件更新：
您可以在IDE中编辑build.gradle文件(左窗格：Android Support Libraries v4)或使用原始路径(/app/build.gradle)并添加/更新以下依赖项部分：
dependencies {
//
// IDE setting pulls in the specific version of v4 support you have installed:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23207dd7c0637a70aa092aeb9ab86e08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01526705385c74d6574d3fe63f369700/" rel="bookmark">
			URL编码中关于空格转换%20还是&#43;的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		W3C标准规定，当Content-Type为application/x-www-form-urlencoded时，URL中查询参数名和参数值中空格要用加号+替代，所以几乎所有使用该规范的浏览器在表单提交后，URL查询参数中空格都会被编成加号+。而在另一份规范(RFC 2396，定义URI)里, URI里的保留字符都需转义成%HH格式(Section 3.4 Query Component)，因此空格会被编码成%20，加号+本身也作为保留字而被编成%2B，对于某些遵循RFC 2396标准的应用来说，它可能不接受查询字符串中出现加号+，认为它是非法字符。所以一个安全的举措是URL中统一使用%20来编码空格字符。
js中可以通过下面两个方法统一转换
encodeURI：对整个的url进行编码时使用。
encodeURIComponent：对某个url中的参数进行编码。
在crul中，应该用%20代替空格，否则，空格以后的数据将get不到。
php转换函数为：
urlencode() 和 rawurlencode()
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d675c5c13078a449d1b3019b1d7d501/" rel="bookmark">
			Android保存图片到手机相册（res下的图片，网络图片都可以）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天主要说的是把图片保存到本地相册，
一、主要思路：
将一张图片，无论是本地图片还是网络图片先转成Bitmap格式，再调用方法保存到相册中
二、开发过程中可能会遇到的问题：
1：保存成功了，但图库不显示
原因：没刷新图库
解决：写一个广播，通知刷新图库
2：保存失败或者抛异常
原因：可能要写入的文件夹不存在
解决：如果不存在，一定要先创建文件夹再写入
三、实现方案：
/** * 保存图片到本地 * * @param name 图片的名字，比如传入“123”，最终保存的图片为“123.jpg” * @param bitmap 本地图片或者网络图片转成的Bitmap格式的文件 * @return */ public void saveImage(String name, Bitmap bitmap) { File pathFile = new File(Environment.getExternalStorageDirectory() + File.separator + Environment.DIRECTORY_PICTURES + File.separator); if (!pathFile.exists()) { pathFile.mkdir(); } File file = new File(pathFile, name + ".jpg"); try { FileOutputStream fos = new FileOutputStream(file); bitmap.compress(Bitmap.CompressFormat.JPEG, 100, fos); fos.flush(); fos.close(); // 最后通知图库更新 ToastsUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d675c5c13078a449d1b3019b1d7d501/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/556a1477b98e3f056feb933a60f77725/" rel="bookmark">
			mybatis中使用foreach遍历集合参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、对于xml文件中使用foreach遍历集合的使用
参考博客：
mybatis之foreach用法 - Boblim - 博客园
foreach元素的属性主要有item，index，collection，open，separator，close。
item：集合中元素迭代时的别名，该参数为必选。index：在list和数组中,index是元素的序号，在map中，index是元素的key，该参数可选open：foreach代码的开始符号，一般是(和close=")"合用。常用在in(),values()时。该参数可选separator：元素之间的分隔符，例如在in()的时候，separator=","会自动在元素中间用“,“隔开，避免手动输入逗号导致sql错误，如in(1,2,)这样。该参数可选。close: foreach代码的关闭符号，一般是)和open="("合用。常用在in(),values()时。该参数可选。collection: 要做foreach的对象，作为入参时，List对象默认用"list"代替作为键，数组对象有"array"代替作为键，Map对象没有默认的键。当然在作为入参时可以使用@Param("keyName")来设置键，设置keyName后，list,array将会失效。 除了入参这种情况外，还有一种作为参数对象的某个字段的时候。举个例子：如果User有属性List ids。入参是User对象，那么这个collection = "ids".如果User有属性Ids ids;其中Ids是个对象，Ids有个属性List id;入参是User对象，那么collection = "ids.id" 在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况： 如果传入的是单参数且参数类型是一个List的时候，collection属性值为list .如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array .如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key. 总结：
1、如果传入的参数只有集合一个参数，那么在xml文件中，collection直接写list就可以获取到，写参数名是获取不到的，如果想自定义，可以使用@Param("")指定键的名字
2、如果传入的参数需要多个，那么，不可以指定多个参数，需要封装为map，在collection中，填写map中的键名即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2a77c9991dbcf0e120fb49de7ed1fe1/" rel="bookmark">
			docker镜像打包为.tar文件解压后提示“不可信的旧时间戳”解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景复现：
docker save -o xxxx.tar xxxx:tag
tar -xvf xxxx.tar 报错“不可信的旧时间戳”
解决方案：
错了，docker镜像tar包不是用tar解压，而应该用
docker load -i xxxx.tar来导入
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34b4652097b8d2bddd7298329a9bae50/" rel="bookmark">
			判断String是否为空的几种方法（isEmpty(),equals()的用法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		判断String是否为空的几种方法 判断某字符串是否为空，为空的标准是 str==null 或 str.length()==0
基本的知识
(1)String str1 = null; 表示str1的引用为空，他没有地址， 他是一个没有被实例化的对象
(2)String str2 = " ";表示str2引用为空字符串，他有地址， 他是被实例化的对象，仅仅值为空而已
如果是string对象是null 如果是string对象是null,用 == 来判断，否则会抛出异常 “==
”操作在对String这种引用数据类型来说，比较的是地址
如果是空字符串"" 如果是空字符串""，用来equals() 判断， str.equals("")
equals()"判断的是内容
判断是否为空
str1.equals(str2)
if(s == null || “”.equals(s));
isEmpty()的用法 第一种方法
IsEmpty()是Java中用于判断某种容器是否有元素的系统库函数。
如用来判断ArrayList，HashSet，HashMap是否有元素等。
在Java中，可以用isEmpty();判断一个顺序容器ArrayList里面是否有元素，如果有的话返回一个Boolean类型的值false，否则返回true。
import java.util.ArrayList;//在此引入ArrayList所在的库 ArrayList&lt;Integer&gt; a = new ArrayList&lt;Integer&gt;(); System.out.println(a.isEmpty());//打印出true a.add(5); System.out.println(a.isEmpty());//打印出false 类似的，可以用来判断HashSet或者HashMap等容器是否有元素。 第二种方法
使用 isEmpty() 函数获取字符串 strCom 的值，将返回值赋给 boolean 变量 str。
String strCom = "I like java！"; //定义一个字符串 boolean str = strCom.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34b4652097b8d2bddd7298329a9bae50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed29df3482520b0a7c9a05b21f3b78f5/" rel="bookmark">
			JAVA HD 101_HD101
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Model:HD101
HD101 is a masterbatch for use as a nucleating agent in gas-injection applications. It is specially designed for easy incorporation into insulation raw material compound for processing Physical Foaming Insulated RG series coaxial cables. The compound consists of base resin and more than 4 kinds of other supporting agents such as Stabilizer, Activator, foamable antioxidant and expander. When used correctly, it allows the formation of small, uniformly distributed cells.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed29df3482520b0a7c9a05b21f3b78f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/325649317febf6698cfa17efdf21b936/" rel="bookmark">
			Jprofile远程监控JVM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本次将分享如何在本地电脑使用JProfile来监控服务器上的Springboot项目的状况，本地电脑如何安装JProfile请自行搜索，这里主要介绍在服务器安装JProfile并监控，注意服务端的JProfile需要和客户端的版本保持一致！
1、服务器安装JProfile 我们直接进官网下载安装：点击进入官网 。我本地电脑上的JProfile版本号是11.1.4，所以需要下载11.1.4版本的Linux客户端
拿到下载地址，下载tar.gz的客户端包
在服务器下载JProfile：
wget https://download-gcdn.ej-technologies.com/jprofiler/jprofiler_linux_11_1_4.tar.gz 解压客户端包
tar -zxvf jprofiler_linux_11_1_4.tar.gz 运行JProfile，进入到刚刚解压的 jprofiler11.1.4/bin 目录，执行 ./jpenable命令，启动JProfile，这里它将自动的找到服务器上的Java程序
./jpenable 如果有多个Java程序，选择一个要监控的就行，我的服务器上只跑了一个Java程序
启动了服务器的JProfile 输入数字 1 选择远程监控模式，回车输入监控用的端口号，我用的默认端口8849，服务器设置完成（如何停止JProfile呢？关闭掉我们要监控的Java程序就停止了，我是这样做的😹）
2、本地JProfile连接服务器 打开本地的JProfile，点击创建一个新的连接
选择远程监控，输入ip地址和端口号，点击确认
进入监控页面，点击ok按钮
以上就可以使用JProfile快乐的分析JVM了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e42e5b20e222c64e57826973003bcefd/" rel="bookmark">
			classes是什么意思怎么读_class是什么意思_class怎么读_class翻译_用法_发音_词组_同反义词_班-新东方在线英语词典...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		词汇搭配
用作名词 (n.)动词+～attend a class上课,听课
call off a class取消课
conduct a class教一个班,指导一个班
dismiss a class取消课
form a class形成一个阶级
give one's class讲课
go to class去上课,去听课
meet one's class授课
miss a class缺课
open classs in shorthand开速记课
organize a class开课
sit in on a class〈美〉旁听课
start a class开设一个班
take classes上课
teach a class教一个班形容词+～advanced class高级班
educated class(es)知识阶级
governing class(es)统治阶级
labouring class(es)劳动阶级
middle class(es)中层社会,中产阶级
primary class初级班
rapid class高速发展的社会
rich class富有阶层
ruling class统治阶级
science class理科课
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e42e5b20e222c64e57826973003bcefd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbbf18ba4a6e0762ab059a878ee5b0b0/" rel="bookmark">
			Ajax速成笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ajax速成笔记 什么是Ajax？Ajax具体使用常用方法和属性1.方法open()方法send()方法setRequestHeader()方法其他属性 2.属性readystate属性responseText属性status属性 什么是Ajax？ Ajax即异步Javasc与XML技术，是由JavaScript、XML、DOM、CSS、XHTML等多种技术组合成的客户端技术，用来实现客户端与服务器的异步请求。
Ajax具体使用 Ajax的核心技术是XMLHttpRaquest，是1999年微软发布的IE5的内嵌技术。
var obj = new XMLHttpRequest(); &lt;html&gt; &lt;head&gt; &lt;title&gt;创建ajax对象&lt;/title&gt; &lt;/head&gt; &lt;script type="text/javascript"&gt; var obj=new XMLHttpRequest(); alert(obj); console.log(obj); &lt;/script&gt; &lt;body&gt; &lt;p&gt;niaho&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 通过new XMLHttpRequest的方式创建Ajax的操作对象，此刻需要注意的是对于浏览器的内核不同方式也有所不同对于IE浏览器中创建Ajax的方法如下：
var obj = new ActiveXObject("Mocrosoft.XMLHPPT");//此版本为IE 8的 其他版本也有所不同 常用方法和属性 1.方法 open()方法 open()方法用来创建新的http请求，并指定请求的类型（如GET、POST等）、URL以及验证信息。
open("method","URL"[,asyncFlag[,"username"[,"password"]]]) method:指定请求方式（GET、POST、PUT以及PROPFIND），此处大小写不敏感。
URL：请求地址，可以是相当于地址，也可以是绝对地址。
anyncFlag：请求方式同步请求false，异步请求true，默认是异步请求。
uesrname和password顾名思义就是指定用户名和密码。
send()方法 send()方法用于请求http服务器并接收回应。
send(content) content指定要发送的数据，其值可以是DOM对象、数据流、字符串等，如果是同步请求会等请求完成或者是请求超时然后返回，如果是异步请求则是立即返回。
setRequestHeader()方法 serRequestHeader用于单独指定HTTP的头
serRequestHeader(“header”,“value”);
header用于指定HTTP的头，value则是指定的header的值，一般和POST一块用，但是要先使用open()后使用setRequestHeader()方法。
例如：GET方式
Ajax.html &lt;html&gt; &lt;head&gt; &lt;title&gt;创建ajax对象&lt;/title&gt; &lt;script type="text/javascript"&gt; var obj=new XMLHttpRequest(); obj.onreadystatechange=function(){ if(obj.readyState==4){ alert(obj.responseText); } } //设置传递的值 var name='小明'; name=encodeURIComponent(name); obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbbf18ba4a6e0762ab059a878ee5b0b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/277cd33a9d62ae2c3ae101d2e84656a8/" rel="bookmark">
			LSTM算法详细解析（含案例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LSTM单元结构图。
前向传播：
在Understanding LSTM Networks博客中已经详细得不能再详细的介绍了LSTM网络的前向传播过程。如果英文能力不是很好，也可以参考如何从RNN起步，一步一步通俗理解LSTM_结构之法 算法之道-CSDN博客翻译过来的版本。也可以参考本文的简略解析。
LSTM 的核心概念在于细胞状态以及“门”结构。细胞状态相当于信息传输的路径，让信息能在序列连中传递下去。你可以将其看作网络的“记忆”，记忆门一个控制信号控制门是否应该保留该信息，在实现上通常是乘1或乘0来选择保留或忘记。理论上讲，细胞状态能够将序列处理过程中的相关信息一直传递下去。因此，即使是较早时间步长的信息也能携带到较后时间步长的细胞中来，这克服了短时记忆的影响。信息的添加和移除我们通过“门”结构来实现，“门”结构在训练过程中会去学习该保存或遗忘哪些信息。
激活函数：sigmod
门结构中包含着 sigmoid 激活函数。Sigmoid 激活函数与 tanh 函数类似，不同之处在于 sigmoid 是把值压缩到 0~1 之间而不是 -1~1 之间。这样的设置有助于更新或忘记信息，因为任何数乘以 0 都得 0，这部分信息就会剔除掉。同样的，任何数乘以 1 都得到它本身，这部分信息就会完美地保存下来。这样网络就能了解哪些数据是需要遗忘，哪些数据是需要保存。
遗忘门：Forget Gate
遗忘门的功能是决定应丢弃或保留哪些信息。来自前一个隐藏状态的信息和当前输入的信息同时传递到 sigmoid 函数中去，输出值介于 0 和 1 之间，越接近 0 意味着越应该丢弃，越接近 1 意味着越应该保留。
遗忘门的计算公式
输入门：Input Gate
输入门用于更新细胞状态。首先将前一层隐藏状态的信息和当前输入的信息传递到 sigmoid 函数中去。将值调整到 0~1 之间来决定要更新哪些信息。0 表示不重要，1 表示重要。其次还要将前一层隐藏状态的信息和当前输入的信息传递到 tanh 函数中去，创造一个新的侯选值向量。最后将 sigmoid 的输出值与 tanh 的输出值相乘，sigmoid 的输出值将决定 tanh 的输出值中哪些信息是重要且需要保留下来的
输入门的计算公式
Cell State
首先前一层的细胞状态与遗忘向量逐点相乘。如果它乘以接近 0 的值，意味着在新的细胞状态中，这些信息是需要丢弃掉的。然后再将该值与输入门的输出值逐点相加，将神经网络发现的新信息更新到细胞状态中去。至此，就得到了更新后的细胞状态。
Cell State的计算公式
输出门：Output Gate
输出门用来确定下一个隐藏状态的值，隐藏状态包含了先前输入的信息。首先，我们将前一个隐藏状态和当前输入传递到 sigmoid 函数中，然后将新得到的细胞状态传递给 tanh 函数。最后将 tanh 的输出与 sigmoid 的输出相乘，以确定隐藏状态应携带的信息。再将隐藏状态作为当前细胞的输出，把新的细胞状态和新的隐藏状态传递到下一个时间步长中去。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/277cd33a9d62ae2c3ae101d2e84656a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc861a206cbc03b3b036743c6fbacee1/" rel="bookmark">
			APScheduler管理及监控平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 APScheduler是一个非常好用的调度平台，不过目前所有Scheduler的JOB信息都无法通过可视化的方式展示，只能通过后台日志来查看调度信息，对于管理上非常不便。
但是APScheduler非常的强大，已经预留的event功能可以帮助来实现此功能，对于APScheduler原理还不太理解的话，可以参考之前的一篇文章Python定时库APScheduler原理及用法
在使用Flask进行管理后，通过Flask-APScheduler插件来实现对APScheduler的管理以及动态增删JOB的接口实现，以此完成对APScheduler的全方位管理。
目的 本文的目的主要有两部分功能块，第一部分是利用APScheduler的event机制来实现以下两个功能并进行可视化查看
将APScheduler中所有添加的JOB进行状态跟踪APScheduler中每个JOB的生命周期进行跟踪 第二部分是在Flask框架上构建的管理平台上集成Flask-APScheduler插件，完成对APScheduler的管理以及动态增删JOB的接口实现。
实现 集成Flask-APScheduler插件完成APScheduler的动态管理 将APScheduler集成到Flask中 config_name = os.getenv('FLASK_CONFIG') or 'default' app = Flask(__name__) app.config.from_object(config[config_name]) config[config_name].init_app(app) # 初始化Sqlarchemy db.app = app db.init_app(app) # 初始化 flask_apscheduler，将scheduler嵌入到flask管理，本地在flask_apscheduler插件中增加add_listener监听所有的job生命周期 flask_apscheduler = CustomAPScheduler(db.session, app=app) # 启动apscheduler flask_apscheduler.start() 配置Flask-APScheduler开启对外接口 class Config: # apscheduler默认的jobstore SCHEDULER_JOBSTORES = {} # flask_apscheduler是否对外提供接口 SCHEDULER_API_ENABLED = True Flask-APScheduler提供的api如下
def _load_api(self): """ Add the routes for the scheduler API. """ self._add_url_route('get_scheduler_info', '', api.get_scheduler_info, 'GET') self._add_url_route('add_job', '/jobs', api.add_job, 'POST') self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc861a206cbc03b3b036743c6fbacee1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2005ab3c178284f49911fcacf8bcc8a0/" rel="bookmark">
			Adobe Premiere Pro视频剪辑，居然还有这个？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#Adobe#Adobe Premiere Pro——始终更胜一筹的#视频剪辑#视频剪辑；了解 Adobe 工具中将帮助您进一步提升视频效果的新增内容。
Adobe Premiere Pro视频剪辑，居然还有这个？
Premiere Pro 适用于电影、电视和 Web 业界领先的视频编辑软件。多种创意工具、与其他 Adobe 应用程序和服务的紧密集成以及 Adobe Sensei 的强大功能可帮助您将素材打造成为精美的影片和视频。借助 Premiere Rush，您可以从任何设备创建和编辑新项目。
始终保持高效的创意流程
由 Adobe Sensei 提供支持的自动化工具可节省时间，让您专注于讲述故事，集成的工作流程让您无需离开时间轴即可润饰作品。
Adobe Premiere Pro视频剪辑，居然还有这个？
任何相机，任何格式，任何平台
利用 Premiere Pro 视频编辑软件，您可以编辑从 8K 到虚拟现实的任何格式的素材。原生文件支持、轻量代理工作流程和更快的 ProRes HDR 使您可以随心所欲地处理媒体，即使使用移动工作站也是如此。
Adobe Premiere Pro视频剪辑，居然还有这个？
优秀的协作性
Premiere Pro 可与其他应用程序和服务（包括 Adobe Photoshop、After Effects、Audition 和 Adobe Stock）无缝协作。从 After Effects 打开动态图形模板，从 Adobe Stock 自定义一个模板，或者与数百个第三方扩展集成。
Adobe Premiere Pro视频剪辑，居然还有这个？
随时随地扩展编辑平台
Premiere Pro 附带有 Premiere Rush，这是可在您的所有设备上使用的全新一体式应用程序。在您的手机上进行拍摄和编辑，然后从您的设备或桌面分享到社交网站。还可以在 Premiere Pro 中打开 Premiere Rush 文件，进行进一步加工。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2005ab3c178284f49911fcacf8bcc8a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/154362dc41be9e231e6994a4801956d3/" rel="bookmark">
			MobaXterm登录之后无法输入命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MobaXterm登录之后无法输入命令
昨天在使用MobaxXterm安装好环境之后都是正常使用，但是今天早上登陆时就出现了下面这个问题：最下面一直是白色方块，没有出现输入命令的地方。（有朋友知道怎么解决吗？
后续记录：等待了很久最后出现了，但是每一条命令都要相应很久。
求助！！有人知道怎么解决吗？
破案了，原来是程序太多，导致服务器变卡！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/578206dc0924d0ff93cb70b9d5e84bab/" rel="bookmark">
			抽象数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抽象数据类型，泛指除基本数据类型以外的数据类型。
基本数据类型被认做是最基本地，不可再划分的数据，一般就是整形、浮点型、以及字符型。抽象数据类型是由若干基本数据类型归并之后形成的一种新的数据类型，这种类型由用户定义，功能操作比基本数据类型更多，一般包括结构体和类。其实说白了，抽象数据类型就是把一些有一定关联的基本数据类型打包，然后当做新的数据类型使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adadf95a18e7366b84dc195370e88b2d/" rel="bookmark">
			spring batch job重复多次执行的配置--spring batch restart Step already complete or not restartable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、问题：spring batch程序运行执行完某个job的时候，job配置的参数不变，程序再次运行的时候，程序提示：spring batch restart Step already complete or not restartable, so no action to execute:
2、原因：Spring Batch需要每次唯一的作业参数来执行。
3、解决：但是在测试阶段，程序需要被一次又一次的执行，我们可以在创建job的时候新增参数来满足要求：
1）Job配置如下：
import org.springframework.batch.core.launch.support.RunIdIncrementer; @Bean public Job backUpJob(AccountsDailyListener listener) { return jobBuilderFactory.get("backUpJob") .incrementer(new RunIdIncrementer()) .listener(listener) .flow(step1()) .end() .build(); } 新增incrementer(new RunIdIncrementer())的配置使每个job的运行id都唯一；
2）Job的入参：
JobParameters jobParameters = new JobParametersBuilder() .addDate("date", new Date()) .toJobParameters(); jobLauncher.run(ctx.getBean("myJob", Job.class), jobParameters); 看到很多Spring batch的示例代码中，JobParameter都会设置date并且值为new Date()。开始不知道用途就去掉了，然后程序再次执行会有提示：Step already complete or not restartable，加上addDate那段代码后就运行正常了。应该是参数相同的job里面的step默认都只执行一次，加上这个配置是最简单的解决方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82e8daea86b2fab7beafb4a4e5bbab50/" rel="bookmark">
			time&amp;异常&amp;import
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、高阶函数 1.1 filter 过滤 函数: filter(function or None, iterable) --&gt; filter object
l = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15] # 判断一个元素是否为偶数 def is_odd(x): if x % 2 == 0: return True 第一种方式: f_l = filter(is_odd,l 第二种方式: f_l = filter(lambda x:x%2==1,l) 第二个例子,过滤出全是小写的字母: courses = ["java","Py","Groovy"] def low(x): return x.islower() c_l = filter(low,courses) print(list(c_l)) 1.2 reduce 聚合 函数： reduce(function, sequence[, initial])
from functools import reduce nums = [1,2,3,4,5,6,7,8] multi = 1 multiResult = reduce(lambda x,y:x*y,nums) print(multiResult) 二、时间相关模块 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82e8daea86b2fab7beafb4a4e5bbab50/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/378/">«</a>
	<span class="pagination__item pagination__item--current">379/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/380/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>