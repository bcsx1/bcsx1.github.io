<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f3cbe7b03374d6d1761e5907e3059da/" rel="bookmark">
			docker容器centos开启ssh登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 新建centos的docker 容器，docker命令如下：(注意 --privileged 和 /usr/sbin/init ,否则执行systemctl restart sshd命令时会报 Failed to get D-Bus connection: Operation not permitted)
1.创建容器 docker run --privileged -itd --name centos -p 80:80 -p 443:443 -p 8888:8888 -p 888:888 -p 20:20 -p 21:21 -p 222:22 -p 3306:3306 -v /mydata:/mydata centos /usr/sbin/init
2.修改容器密码 passwd root 3.安装openssh服务 yum -y install openssh* 4.重启sshd服务 systemctl restart sshd 5.生成密钥文件 ssh-keygen -t rsa 6.新建authorized_keys文件输入ssh公钥
7.修改sshd配置 vi/etc/ssh/sshd_config GSSAPIAuthentication yes
GSSAPICleanupCredentials no
PasswordAuthentication yes 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9e57b4747aa022a3586412ef309b8fe/" rel="bookmark">
			redis的持久化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RDB持久化 概念 RDB持久化是将redis在内存中的数据库状态保存到磁盘上，避免数据意外丢失。
RDB持久化既可以手动执行，也可以根据服务器配置项定期执行，该功能将某个时间点上的数据库状态保存到一个RDB文件中。RDB持久化生成的文件是一个压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态。
RDB文件的创建和载入 生成RDB文件的命令有两个一个是SAVE，另一个是BGSAVE。
save命令会阻塞Redis服务器进程，直到RDB文件创建完成为止，在服务器进程阻塞期间，服务器不能处理任何命令和save命令直接阻塞服务器进程的做法不同，bgsave命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务父进程继续处理命令请求。 RDB文件的载入没有相关的命令，在服务器时会自动检测到是否存在RDB文件的存在，如果存在他就会自动载入RDB文件。
AOF持久化 概念 AOF是通过保存Redis执行的写命令来记录数据库的状态。
AOF持久化的实现 AOF持久化功能的实现可以分为命令追加、文件写入、文件同步三个步骤。
命令追加 当AOF持久化功能处于打开状态时,服务器在执行完一个写命令之后,会以协议的格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾
AOF文件的写入与同步 Redis的服务器进程是一个事件循环,在这个循环中文件事件负责接收客户端的请求命令,以及向客户端发送命令回复,而时间事件则负责执行像serverCron函数这样需要定时运行的函数.
因为服务器在处理文件事件时可能会执行写命令,使得一些内容被追加到aof_buf缓冲区,所以在服务器每次结束一个事件循环之前,都会调用flushAppendOnlyFile函数,考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41d1ace2c976f5637017ad42fe6ea645/" rel="bookmark">
			避免跳出谷歌人机验证 reCAPTCHA界面的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次遇到跳出谷歌人机验证 reCAPTCHA界面只要点击窗口就没有问题了，心里还感叹了下谷歌能把人机验证这事做的这么好，不错。然而这个窗口还是会不断调出来扰人= =，导致使用Chrome浏览器搜索变得很慢，体验感极速下降，非常烦人。
首先声明这个不是破解谷歌 reCAPTCHA 的意思Orz
当前世界范围的IPv4地址紧张，运营商给自家用户常常分配同一个IP上网(这句可以无视666)。在这种情况下访问谷歌搜索，容易被谷歌 reCaptcha 误伤识别成疑似机器人。这篇文章讨论如何避免这种情况。
接下来是正文
以前进行谷歌搜索的时候，都是很正常的。最近服务器发生了一些变动，在地址栏直接输入关键字搜索，就跳出了人机验证的界面，如下图
次数多了之后 Google 还会弹出一个窗口，要求输入传统的验证码或者跳出阿猫阿狗汽车的图片让你选择。
关于谷歌人机验证的详细新闻，可以看雷锋网的这篇文章——《与恼人的验证码说拜拜，Google用一次点击区分人与机器》。我猜测这是多人公用同一个谷歌搜索的站点引起的问题。Google reCaptcha 功能会在收集大量信息，包括IP地址和cookies，然后通过收集这些数据对比用户是否和过去在互联网上的行为一致，来判定这个用户究竟是不是机器人。
在好基友的帮助下我找到了一个折中解决的办法。简单说来就是新建一个搜索引擎，指定想要的搜索地址就好(最好避开与你共用一条线路的用户访问的谷歌搜索的站点——主站.com，香港.hk和日本.co.jp这一类)。下面是具体的步骤：
1 访问 &lt;google.com/ncr&gt;，随便搜索一个关键字。（ncr=no country redirect不做国家跳转） 2 修改浏览器默认搜索引擎。下面以 Chrome 为例：
打开设置
管理搜索引擎
自定义搜索引擎，并且设为默认搜索引擎
将自定义搜索的地址改成各种天花乱坠的谷歌 + /search?q=%s ，比如
亚洲：
蒙古 google.mn蒙古语 韩国 google.co.kr 韩语 日本 google.co.jp 日语 越南 google.com.vn 越南语 老挝 google.la 老挝语 柬埔寨 google.com.kh 高棉语 泰国 google.co.th 泰语 马来西亚 google.com.my 马来语 新加坡 google.com.sg 马来语 文莱达鲁萨兰国 google.com.bn 马来语 菲律宾 google.com.ph 菲律宾语 印度尼西亚 google.co.id 印尼语 东帝汶 google.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41d1ace2c976f5637017ad42fe6ea645/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a10b475cc05da57ed70052592cb5752/" rel="bookmark">
			关于 maven-compiler-plugin 插件的使用心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两种方式 maven 项目是通过 maven-compiler-plugin 插件来对 Java 代码编译的，如果不指定 JDK 版本，maven-compiler-plugin 会自动使用一个默认的版本，该版本可能与你使用的 IDE 所使用的 JDK 版本不一致，这种情况可能会导致代码无法通过 maven 的编译，例如：在 IDE 指定 JDK 1.8 ，coding 的时候使用了JDK 1.8 的特性，而 maven-compiler-plugin 默认的 JDK 版本为 1.5，此时 JDK 1.5 是不可能将带有 JDK 1.8 特性的代码编译通过的。此类问题的出现可通过在 pom 文件中指定 JDK 版本来避免，有如下两种方式：
方式一 &lt;properties&gt; &lt;!-- maven-compiler-plugin 将会使用指定的 JDK 版本将 java 文件编译为 class 文件（针对编译运行环境） --&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;!-- maven-compiler-plugin 将会使用指定的 JDK 版本对源代码进行编译（针对编译运行环境） --&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;properties&gt; 方式二 &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;configuration&gt; &lt;!-- 同【方式一】的 maven.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a10b475cc05da57ed70052592cb5752/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd8e325ac687ea435515c3208dba5646/" rel="bookmark">
			VSCode 查看、还原本地代码历史版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目组这次刚开始写前端页面就出现了代码合并丢失的现象，虽然可以经过一份周折可以找到，但是作为一名程序员要深知有备无患这个道理，在本地备份一份我们的“心血”，就一个词：踏实啊！
1. 安装插件：Local History ，点击右下角 Install 就行了。
2. 重启 VisualCode，左下角（最下面）会有新的本地历史文件夹 LOCAL HISTORY 。
3. 修改文件后就会在这里生成新的记录。选择好要还原的版本再 Restore 就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18082deaee6fd69df9233f4453475645/" rel="bookmark">
			解决AndroidStudio编译时报错：org.gradle.api.ProjectConfigurationException；编译报错Read Time out
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题一： org.gradle.api.ProjectConfigurationException: A problem occurred configuring root project ‘app’.
错误：编译报错Read Time out ，
分析一： 1.看log是 下载jar包时候超时了，
org.gradle.api.ProjectConfigurationException: A problem occurred configuring root project 'app'.
at org.gradle.configuration.project.LifecycleProjectEvaluator.addConfigurationFailure(LifecycleProjectEvaluator.java:94)
...
...
Caused by: org.gradle.api.internal.artifacts.ivyservice.DefaultLenientConfiguration$ArtifactResolveException: Could not resolve all files for configuration ':classpath'.
at org.gradle.api.internal.artifacts.configurations.DefaultConfiguration.rethrowFailure(DefaultConfiguration.java:918)
... 83 more
Caused by: org.gradle.internal.resolve.ArtifactResolveException: Could not download guava.jar (com.google.guava:guava:22.0)
at org.gradle.api.internal.artifacts.repositories.resolver.ExternalResourceResolver$RemoteRepositoryAccess.resolveArtifact(ExternalResourceResolver.java:506)
... 138 more
Caused by: org.gradle.internal.resource.transport.http.HttpRequestException: Could not HEAD 'https://jcenter.bintray.com/com/google/guava/guava/22.0/guava-22.0.jar'.
at org.gradle.internal.resource.transport.http.HttpClientHelper.performRequest(HttpClientHelper.java:96)
at org.gradle.internal.resource.transport.http.HttpClientHelper.performRawHead(HttpClientHelper.java:72)
... 141 more
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18082deaee6fd69df9233f4453475645/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4139812107e5a44115abe0f473adcffb/" rel="bookmark">
			Zabbix监控之监控项到达阈值报警解决方案汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们的服务器在添加模板之后，会有很多的监控项。当监控项到达一定的阈值之后就会触发报警，这里我们来总结一下当服务器出现问题触发报警的解决方法。
CPU CPU的性能对于计算机整体的性能起着主导作用。对于早期对计算机甚至直呼其CPU的型号，如 386 、486、奔三，奔四。
那么我们CPU性能最直接的评估就是查看其CPU工作频率，就是CPU的时钟频率，单位为是Hz。随着CPU的发展，主频由MHz现在的GHz
（1GHz=1000MHz=1000000KHz=1000000000Hz）处理器除了主频指标外，还有另外两个密切相关的概念：倍频与外频。外频是cpu的基准频率，单位是MHz。外频是CPU与主板- 之间同步运行的速度，而且目前的绝大部分计算机系统中外频与是内存与主板之间的同步运行速度，在这种方式下，可以理解为CPU的外频直接与内存相连通。实现两都的同步运行状态；倍频即主频与外频之间的倍数。
主频 = 外频 * 倍数 一、Processor load is too high on 主机
触发器的表达式
{192.168.43.12:system.cpu.load[percpu,avg1].avg(5m)}&gt;1 描述：这个信息，是说服务器太忙。
解决方案
检查下是不是运行的东西太多停掉不用的服务扫下病毒，进行杀毒工作重启下服务器，重新恢复下工作(保存好当前工作状态)打下补丁,将服务器的更新安装删除不必要的启动项目定时启动的如备份的日程安装到晚上。 二、% Total Processor Time
触发器的表达式
{192.168.43.12:perf_counter["\Processor Information(_Total)\% Processor Time",300].avg(600,0)}&gt;80 描述：获得处理器整体使用情况，阀值：处理器的阀值一般设为85%。
含义：这个计数器是处理器活动的主要指标。高数值并不一定是坏事，但是如果其他处理器相关的计数器（比如% Privileged Time 或者Processor Queue Length）线性增加的话，高CPU使用率就值得调查了
该计数值用于体现服务器整体的处理器利用率，对多处理器的系统而言，该计数值体现的是所有CPU的平均利用率。如果该值的数值持续超过90%，则说明整个系统面临着处理器方面的瓶颈，需要通过增加处理器来提高性能。
要注意的是，由于操作系统本身的特性，在某些多CPU系统中，该数据本身并不大，但此时CPU之间的负载状况极不均衡，此时也应该视作系统产生了处理器方面的瓶颈。
三、Processor Queue Length
触发器的表达式
{192.168.43.12:perf_counter["\System\Processor Queue Length",300].avg(600,0)}&gt;20 描述:处理器队列的线程数量。此计数器只显示就绪线程，而不是正在运行的线程。
当该计数器的值大于CPU数量的总数加1时，说明CPU产生了赌塞。(阀值：平均值持续大于2那么表示CPU存在瓶颈),如果就绪的任务超过处理能力线程就会被放进队列。处理器队列是就绪但是未能被处理器执行的线程的集合，这是因为另外一个线程正在执行状态。持续或者反复发生2个以上的队列则明确的表示存在处理器瓶颈。你也能通过减少并发取得更大的吞吐量。
你可以结合Processor/% Processor Time来决定增加CPU的话你的程序是否能够受益。即使在多处理器的电脑上，对于CPU时间也是单队列。因此，在多处理器电脑上，Processor Queue Length (PQL)的值除以用来处理负载的CPU个数。
如果CPU非常忙（90%以上的使用率），PQL的平均值也持续大于2/CPU，这是应该存在CPU瓶颈而且能够从更多的CPU中受益。或者，你可以减少线程的数量以及增加应用程序层的队列。这会引起少量的Context Switching，但是少许的Context Switching对于减少CPU负载是有好处的。PQL大于2但是CPU使用率却不高的的常见原因是对CPU时间的请求随机到达而且线程却从处理器申请到不对称的CPU时间。这意味着处理器并不是瓶颈，而你的线程逻辑是需要改进的。
磁盘I/O 硬盘应该是计算机硬件中发展最慢的设备，很多常见瓶颈都是由于硬盘的读/写速度慢导致的。提高硬盘读/写性能无非是提高转速、提高单碟容量，增加缓存和更新接口，因为传统的硬盘是物理旋转读写数据，所以转速的提高相当困难；而提高单碟容量也存在一写的技术瓶颈，1TB的单碟的容量想要突破还也需要时间。对于传统的温氏硬盘到现在速度也只能达到120MB/s的读取速度，这个速度还真对大文件的读写，而对于服务器大量4KB的小文件读/写速度，会惊人的下跌至1MB不到，而对应的IOPS（每秒磁盘的读/写次数）会低得可怜，大量的数据都在排队从硬盘上读取到内存中，再利用内存的超大带宽完成操作。这也是为什么内存大的系统比较快的原因。但内存的速度虽然比硬盘快得多，也有其致命的缺点，一旦断电，内存中的数据将全部丢失。IOPS（Input/Output Per Second）每秒磁盘的输入/输出量（或读/写次数），是衡量磁盘性能的主要指标之一。IOPS是指单位时间内系统能处理的I/O请求数量，一般以每秒处理的I/O请求数量为单位。另一个重要指标是数据吞吐量（Throughput），指单位时间内可以成功传输的数据数量。对于大量顺序读/写应用，则更关注吞吐量指标。 传统的温氏硬盘完成一个I/O请求所花费的时间包括 寻道时间、旋转延迟和数据传输时间三部分。 寻道时间，是指将读写磁头移动至正确的磁道上所需要的时间。目前磁盘的平均寻道时间一般在3~15ms 旋转延迟，是指盘片旋转将请求数据所在扇区移至读/写磁头下方所需要的时间。7200转速的磁盘，平均旋转言辞大于为60 * 1000/7200/2=4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4139812107e5a44115abe0f473adcffb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36bb60bca2114641f9c0ccccdb3e6cb7/" rel="bookmark">
			Makefile文件详解一（怎么在Windows下使用Makefile文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：如果熟悉在Linux开发的话，肯定知道Makefile文件的用处，它给我们带来很多的便利。在Linux系统下并不会像Windows那么多开发工具，在Windows下，只要在开发工具上点击一个按钮，就能将工程的所有源码进行编译运行。而在Linux下，工程源文件的编写往往是使用一个简单的编辑器（VIM），然后通过Makefile文件进行自动化编译。而我接下来想说的是，如何在Windows上如同Linux般使用Makefile文件进行编译。可能有人觉得没那个必要，因为Windows的开发工具数不胜数，随便一个都非常好用，不可否认，懂得利用开发工具开发是可大大提高开发效率。当然，接下我是从基础的知识出发，不仅仅是对Makefile文件的学习，从中还可帮你解开以往的一些疑惑，或者让你学习到一些新的有趣的知识。
1.搭建环境 1.gcc编译器下载，TDM-GCC，打开根据自己电脑的类型选择合适的程序，我的是win7/32bit，所以选择下载第一个：
2.下载完成后，以管理员方式打开安装程序，点击Create后：
3.选择相应的版本，点击Next，接下来会选择安装路径，自己随便选择一个不带中文的路径就行。
4.最后点击Install进行安装，安装完成后，可以在自己设置的安装路径下有这么一个文件夹“TDM-GCC-32”，接下来配置环境变量。打开控制面板 &gt; 系统和安全 &gt; 系统 &gt;高级系统设置 &gt; 环境变量：
添加系统变量，变量值是自己刚刚选择的安装路径，我安装在C盘，如下图：
找到变量Path，在后面加入 “;%GCC_PATH%\bin”，如图：
点击确定保存设置。
5.点击电脑桌面左下角，搜索cmd，以管理员身份打开cmd.exe，输入“gcc -v”:
得到如上输出可确认gcc编译器已正确安装，版本是5.1.0。
6.继续输入“mingw32-make -v”：
相对于Linux的make不同，这里是mingw32-make，在cmd里用cd命令切换在Makeflie文件所在目录，命令行输入mingw32-make回车运行，就行执行Makefile文件，进行自动化编译。
2.执行一个简单的Makefile文件： 1.将下面各个文件保存在同一目录下：
"src_a.c" #include "stdio.h" void funca() { printf("funca runing!!!\r\n"); } "src_b.c" #include "stdio.h" void funcb() { printf("funcb runing!!!\r\n"); } "src_c.c" #include "stdio.h" void funcc() { printf("funcc runing!!!\r\n"); } "main.c" #include "stdio.h" extern void funca(); extern void funcb(); extern void funcc(); int main() { funca(); funcb(); funcc(); } "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36bb60bca2114641f9c0ccccdb3e6cb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99931368b05ef1776bc9cec57a8b379b/" rel="bookmark">
			java中重载与重写的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重载 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。
重载Overloading是一个类中多态性的一种表现。
Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。
调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。
重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。
父类方法被默认修饰时，只能在同一包中，被其子类被重写，如果不在同一包则不能重写。
父类的方法被protoeted时，不仅在同一包中，被其子类被重写，还可以不同包的子类重写。
重写方法的规则：
1）、参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。
2）、返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。
3）、访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）
4）、重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。
而重载的规则：
1）、必须具有不同的参数列表；
2）、可以有不同的返回类型，只要参数列表不同就可以了；
3）、可以有不同的访问修饰符；
4）、可以抛出不同的异常；
重载和重写（覆盖）的特点：
Override 特点 1、覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；
2、覆盖的方法的返回值必须和被覆盖的方法的返回一致；
3、覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；
4、被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。
2.Overload 特点
1、在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int, float)， 但是不能为fun(int, int)）；
2、不能通过访问权限、返回类型、抛出的异常进行重载；
3、方法的异常类型和数目不会对重载造成影响；
4、对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。
总结：
override（重写）
1、方法名、参数、返回值相同。
2、子类方法不能缩小父类方法的访问权限。
3、子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。
4、存在于父类和子类之间。
5、方法被定义为final不能被重写。
overload（重载）
1、参数类型、个数、顺序至少有一个不相同。
2、不能重载只有返回值不同的方法名。
3、存在于父类和子类、同类中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60bad3310ba2c6cc15e9d158ff9f9f3f/" rel="bookmark">
			Python蒙特卡洛算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是蒙特卡洛算法？ 蒙特卡洛（Monte Carlo）法是一类随机算法的统称。随着二十世纪电子计算机的出现，蒙特卡洛法已经在诸多领域展现出了超强的能力。在机器学习和自然语言处理技术中，常常被用到的MCMC也是由此发展而来。
二、应用 1、求圆周率 π 一个正方形内部相切一个圆，圆的面积是 C C C，正方形的面积 S S S，圆和正方形的面积之比是 π 4 \frac{\pi}{4} 4π​。
C S = π r 2 4 r 2 = π 4 \frac{C}{S}=\frac{\pi r^2}{4r^2}=\frac{\pi}{4} SC​=4r2πr2​=4π​
在这个正方形内部，随机产生n个点（这些点服从均匀分布），计算它们与中心点的距离是否大于圆的半径，以此判断是否落在圆的内部。落在圆内部的点数统计出来是m个点。那么m、n点数个数的比例也符合面积的比：
m n = π 4 \frac{m}{n}=\frac{\pi}{4} nm​=4π​
m与n的比值乘以4，就是π的值:
π = 4 m n \pi = \frac{4m}{n} π=n4m​
如果m、n足够大的话，那么就可以较为精确的求出π的值。
2、求定积分（投点法） 求解 π \pi π 的方法也可以用来求解定积分，通常被称为投点法。如下图所示，有一个函数 f ( x ) f(x) f(x)，若要求它从 a a a 到 b b b 的定积分，其实就是求曲线下方的面积。这时我们可以用一个比较容易算得面积的矩型罩在函数的积分区间上（假设其面积为 A r e a Area Area）。然后随机地向这个矩形框里面投点，其中落在函数 f ( x ) f(x) f(x) 下方的点为绿色，其它点为红色。然后统计绿色点的数量占所有点（红色+绿色）数量的比例为 r r r，那么就可以据此估算出函数 f ( x ) f(x) f(x) 从 a a a 到 b b b 的定积分为 A r e a × r Area×r Area×r 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60bad3310ba2c6cc15e9d158ff9f9f3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25d477907fdf0b136ce974f0997b7f36/" rel="bookmark">
			C# 设计模式-状态模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		状态模式-允许对象在内部状态改变时改变他的行为，对象看起来好像修改了他的类。
状态模式分为2个部分，一个部分是状态，一个部分是动作。
状态是唯一的，某一时刻只能处于一种状态。任何状态都可以执行相同的方法，当然处在不同的状态执行相同的动作结果可能一样也可能不一样。
先看一张图
状态：1,2,3,4
动作：上下左右
当处在状态1时，可以按上下左右4个键，但是只有右和下可以正确运行，并将状态转换成另外的状态。
下面用代码来表示：
先定义一个状态接口（这个接口表示的一种共有的约定，可以是Interface，也可以是基类），里面包含了上下左右四种行为。每一个状态都需要继承此接口
public abstract class State { public abstract void Up(); public abstract void Down(); public abstract void Left(); public abstract void Right(); } 先看其中一个状态 状态1
public class One:State { public override void Up() { Console.WriteLine("forbidden"); } public override void Down() { Console.WriteLine("Three"); } public override void Left() { Console.WriteLine("forbidden"); } public override void Right() { Console.WriteLine("Two"); } } 当处在状态1时，只能执行Down和Right，然后我们需要把状态改为另外的状态了，下面就需要实现此功能了。
先看一下调用类Game
public class Game { //当前状态 public State State {get; set; } //所有可能的状态 public State One { get; set; } public State Two { get; set; } public State Three { get; set; } public State Four { get; set; } public Game() { //状态初始化 One = new One(this); Two = new Two(this); Three = new Three(this); Four = new Four(this); //设定初始状态为One State = One; } //定义所有的方法 public void Up() { State.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25d477907fdf0b136ce974f0997b7f36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66f69e86acc36b9362489f3949775d13/" rel="bookmark">
			深度学习优化学习方法（一阶、二阶）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习优化学习方法总结 （一阶为主）https://blog.csdn.net/sunflower_sara/article/details/81321886
常用的优化算法：梯度下降法，牛顿法，拟牛顿法,共轭梯度法 （二阶为主） https://blog.csdn.net/sunflower_sara/article/details/81215135
一阶方法：
随机梯度下降（Stochastic Gradient Descent，SGD）
动量（SGD with Momentum，SGDM）
牛顿动量法（Nesterov Acceleration Gradient，NAG）
AdaGrad（自适应梯度）
RMSProp（均方差传播）
Adam
Nadam
二阶方法：
牛顿法
拟牛顿法
共轭梯度法 CG
BFGS
L-BFGS
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ea5862be588fe3fdedc50d9757c5baf/" rel="bookmark">
			Leetcode刷题记录 2、两数相加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
示例：
输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
输出：7 -&gt; 0 -&gt; 8
原因：342 + 465 = 807
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/add-two-numbers
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
以下为C++解法
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode head(0); ListNode*tail=&amp;head; int flag=0; while(l1||l2||flag) { int temp=0; if(l1)temp+=l1-&gt;val; if(l2)temp+=l2-&gt;val; temp+=flag; flag=temp/10; temp=temp%10; ListNode* next=l1?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ea5862be588fe3fdedc50d9757c5baf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/297aa28c73d28919e008468467942732/" rel="bookmark">
			LSTM的性能局限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		元学习论文总结||小样本学习论文总结
2017-2019年计算机视觉顶会文章收录 AAAI2017-2019 CVPR2017-2019 ECCV2018 ICCV2017-2019 ICLR2017-2019 NIPS2017-2019
一：LSTM的局限性
循环神经网络（RNN），长短期记忆（LSTM），在现在都得到了广泛的应用。LSTM和RNN被发明于上世纪80、90年代，于2014年死而复生。接下来的几年里，它们成为了解决序列学习、序列转换（seq2seq）的方式，这也使得语音到文本识别和Siri、Cortana、Google语音助理、Alexa的能力得到惊人的提升。另外，不要忘了机器翻译，包括将文档翻译成不同的语言，或者是神经网络机器翻译还可以将图像翻译为文本，文字到图像和字幕视频等等。
在接下来的几年里，ResNet出现了。ResNet是残差网络，意为训练更深的模型。2016年，微软亚洲研究院的一组研究员在ImageNet图像识别挑战赛中凭借惊人的152层深层残差网络（deep residual networks），以绝对优势获得图像分类、图像定位以及图像检测全部三个主要项目的冠军。之后，Attention（注意力）模型出现了。所有的大型科技企业企业已经将RNN及其变种替换为基于注意力的模型。因为比起基于注意力的模型，RNN需要更多的资源来训练和运行。
2.1 LSTM的缺点分析
记住：不管是RNN还是LSTM及其衍生主要是随着时间推移进行顺序处理。请参阅下图中的水平箭头：
水平箭头的意思是长期信息需在进入当前处理单元前顺序遍历所有单元。这意味着其能轻易被乘以很多次&lt;0的小数而损坏。这是导致vanishing gradients（梯度消失）问题的原因。
为此，今天被视为救星的LSTM模型出现了，有点像ResNet模型，可以绕过单元从而记住更长的时间步骤（LSTM之所可以解决梯度问题是因为它避免了无休止的连乘，而是边加边乘，这和resnet本身就是异曲同工的）。因此，LSTM可以消除一些梯度消失的问题。
从上图可以看出，这并没有解决全部问题。我们仍然有一条从过去单元到当前单元的顺序路径。事实上，这条路现在更复杂了，因为它有附加物，并且忽略了隶属于它上面的分支。毫无疑问LSTM和GRU（Gated Recurrent Uni，是LSTM的衍生）及其衍生能够记住大量更长期的信息！但是它们只能记住100个量级的序列，而不是1000个量级，或者更长的序列。
还有一个RNN的问题是，训练它们对硬件的要求非常高。另外，在我们不需要训练这些网络快速的情况下，它仍需要大量资源。同样在云中运行这些模型也需要很多资源。训练RNN和LSTM的噩梦，RNN和LSTM的训练是困难的，因为它们需要存储带宽绑定计算，这是硬件设计者最糟糕的噩梦，最终限制了神经网络解决方案的适用性。简而言之，LSTM需要每个单元4个线性层（MLP层）在每个序列时间步骤中运行。线性层需要大量的存储带宽来计算，事实上，它们不能使用许多计算单元，通常是因为系统没有足够的存储带宽来满足计算单元。而且很容易添加更多的计算单元，但是很难增加更多的存储带宽（注意芯片上有足够的线，从处理器到存储的长电线等）。因此，RNN/LSTM及其变种不是硬件加速的良好匹配，
2.2 缺点总结
（1）RNN的梯度问题在LSTM及其变种里面得到了一定程度的解决，但还是不够。它可以处理100个量级的序列，而对于1000个量级，或者更长的序列则依然会显得很棘手。
（2）计算费时。每一个LSTM的cell里面都意味着有4个全连接层(MLP),如果LSTM的时间跨度很大，并且网络又很深，这个计算量会很大，很耗时。
————————————————————————————————————————————————
二：放弃 RNN/LSTM 吧，因为真的不好用！望周知~ https://blog.csdn.net/heyc861221/article/details/80174475
2014 年 RNN/LSTM 起死回生。自此，RNN/LSTM 及其变种逐渐被广大用户接受和认可。起初，LSTM 和 RNN 只是一种解决序列学习和序列翻译问题的方法（seq2seq），随后被用于语音识别并有很好的效果，比如 Siri，Cortana，Alexa 等；此外，这种技术在机器翻译领域也有应用，比如 Google Translate。
2015-2016 年，新的 ResNet 和 Attention 技术出现。实际上，我们可以将 LSTM 理解为一种巧妙地 bypass technique，而 attention 的成功表明了 MLP（多层感知器）网络可以被上下文向量影响的平均网络（averaging network）所替代。
两年过去了，我们现在已经可以给出结论：
放弃 RNN 和 LSTM 吧，它们真的不好用
基于 attention 的网络逐渐被越来越多的企业采用，比如 Google，Facebook，Salesforce 等公司都已经开始用基于attention的模型来替换RNN和其变种。RNN 在各种应用场景下时日无多，因为相比基于 attention 的模型，RNN 需要更多的资源来训练和运行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/297aa28c73d28919e008468467942732/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f5292eb622278169c4931b2290d0626/" rel="bookmark">
			Search API 概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
URI Search
指定字段 vs 泛查询
TermQuery vs PhraseQuery
布尔操作
范围查询
通配符查询
Request Body Search
分页
排序
_source filtering
使用查询表达式match
短语搜索match phrase
Query String
Simple Query String
搜索Response
URI Search 使用http get的方式在url中使用查询参数（通过uri参数实现搜索）
q指定查询语句df默认字段，不指定时则为所有字段Sort 排序 from和size用于分页Profile可以看到查询是怎样被执行的 用q来表示查询内容，搜索叫Eddie的客户 curl -XGET "http://127.0.0.1:9200/kibana_sample_data_ecommerce/_search?q=customer_first_name:Eddie" 实例：
GET /movies/_search?q=2012&amp;df=title&amp;sort=year:desc&amp;from=0&amp;size=10 { "profile": "true" } 结果：(类型是TermQuery，且仅查询了title中包含2012的)
指定字段 vs 泛查询 指定字段搜索到了1个结果，查询类型是TermQuery，针对的是title字段泛查询搜索到了219个结果，查询类型为 DisjunctionMaxQuery，会对id，title，分类等全部字段做了一个查询，这样查询的性能结果并不是特别好的 TermQuery vs PhraseQuery Beautiful Mind 等效于 Beautiful Or Mind"Beautiful Mind"，等效于 Beautiful And Mind，Phrase查询，还要求前后顺序一致PhraseQuery需要把查询的句子用引号引起来(引号)TermQuery需要用括号括起来(分组) 布尔操作 AND / NOT /OR(默认)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f5292eb622278169c4931b2290d0626/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/783c393bddbb13018b87743abb2f8b95/" rel="bookmark">
			springboot项目启动报错的一种解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息如下：
2019-09-04 18:03:22.693 [restartedMain] ERROR o.s.boot.SpringApplication - Application run failed
java.lang.IllegalStateException: Error processing condition on org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration.hiddenHttpMethodFilter
at org.springframework.boot.autoconfigure.condition.SpringBootCondition.matches(SpringBootCondition.java:64)
at org.springframework.context.annotation.ConditionEvaluator.shouldSkip(ConditionEvaluator.java:108)
at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsForBeanMethod(ConfigurationClassBeanDefinitionReader.java:181)
at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsForConfigurationClass(ConfigurationClassBeanDefinitionReader.java:141)
at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitions(ConfigurationClassBeanDefinitionReader.java:117)
at org.springframework.context.annotation.ConfigurationClassPostProcessor.processConfigBeanDefinitions(ConfigurationClassPostProcessor.java:327)
at org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(ConfigurationClassPostProcessor.java:232)
at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(PostProcessorRegistrationDelegate.java:275)
at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:95)
at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:691)
at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:528)
at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:140)
at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:775)
at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397)
at org.springframework.boot.SpringApplication.run(SpringApplication.java:316)
at org.springframework.boot.SpringApplication.run(SpringApplication.java:1260)
at org.springframework.boot.SpringApplication.run(SpringApplication.java:1248)
at com.yooli.point.DemoApplication.main(DemoApplication.java:23)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:498)
at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:49)
Caused by: java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy
at sun.reflect.annotation.AnnotationParser.parseClassArray(AnnotationParser.java:724)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/783c393bddbb13018b87743abb2f8b95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8965743cde495bcda34cfa3d44b5658f/" rel="bookmark">
			【深度学习】Xception
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Xception 发展历程多尺寸卷积核Pointwise Conv卷积核替换BottleneckDepthwise Separable Conv 创新点网络结构总结论文地址参考博客 Xception是google继Inception后提出的对Inception v3的另一种改进，主要是采用depthwise separable convolution来替换原来Inception v3中的卷积操作。 发展历程 多尺寸卷积核 Inception 最初提出的版本，其核心思想就是使用多尺寸卷积核去观察输入数据。
举个例子，我们看某个景象由于远近不同，同一个物体的大小也会有所不同，那么不同尺度的卷积核观察的特征就会有这样的效果。于是就有了如下的网络结构图：
于是我们的网络就变胖了，增加了网络的宽度，同时也提高了对于不同尺度的适应程度。
Pointwise Conv 但是我们的网络变胖了的同时，计算量也变大了，所以我们就要想办法减少参数量来减少计算量，于是在 Inception v1 中的最终版本加上了 1x1 卷积核。
使用 1x1 卷积核对输入的特征图进行降维处理，这样就会极大地减少参数量，从而减少计算。
举个例子，输入数据的维度是 256 维，经过 1x1 卷积之后，我们输出的维度是 64 维，参数量是原来的 14 。
这就是 Pointwise Convolution，俗称叫做 1x1 卷积，简写为 PW，主要用于数据降维，减少参数量。
也有使用 PW 做升维的，在 MobileNet v2 中就使用 PW 将 3 个特征图变成 6 个特征图，丰富输入数据的特征。
卷积核替换 就算有了 PW ，由于 5x5 和 7x7 卷积核直接计算参数量还是非常大，训练时间还是比较长，我们还要再优化。
人类的智慧是无穷的，于是就想出了 使用多个小卷积核替代大卷积核的方法，这就是 Inception v3，如图所示：
使用两个 3x3 卷积核来代替 5x5 卷积，效果上差不多，但参数量减少很多，达到了优化的目的。不仅参数量少，层数也多了，深度也变深了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8965743cde495bcda34cfa3d44b5658f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd89cdfd2c883e04ba6846d885114574/" rel="bookmark">
			比例分成算法--java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于业绩分配，常常会出现几家公司或者几个人合作的情况，那么合作之后创造出来的业绩价值如何分配的呢？有可能是1:1或者3:7.或者是3:3:4等等。那么我们针对这种情况就设计出来了一套比例分成系统。
代码如下所示：
主代码：
package com.handler.mark.cardperformance; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.dataplatform.dto.base.IBaseOrgDTO; import com.dataplatform.enums.DimensionChannelGroupEnum; import com.dataplatform.model.ApplyDetailInfo; import com.dataplatform.util.MarkByProportionUtil; import org.apache.commons.lang3.StringUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import redis.clients.jedis.ShardedJedis; import redis.clients.jedis.ShardedJedisPool; import java.math.BigInteger; import java.util.ArrayList; import java.util.List; /** * Created by on 2018/7/20. */ /** * 比例分成算法 * @author * @date 2018-07-26 * @version 1.0 * */ public class WeightRoundRobinBo { private static final int DEF_CURRENT_INDEX = -1; private static final int DEF_CURRENT_WEIGHT = 0; private static final String KEY_CURRENT_INDEX = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd89cdfd2c883e04ba6846d885114574/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0166a87b663ca57459d6da89e939b6ff/" rel="bookmark">
			Shiro配置踩坑（序列化）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题一： 1、在securitymanager配置 缓存管理类 cacheManager，这个cacheManager必须要在前面执行，因为setRealm 和 setSessionManage
2、源于：
将对象存入缓存中，
皆要将对象序列化
问题二： 序列化问题：
1、盐序列化：
我们在实现的realm类中，重写dogetAutenticationinfo:
需要将盐转换为ByteSource字节码对象： 但是该对象即实现类SimpleByteSource,没有实现serializable，导致不能序列化。 解决方法:
步骤1、继承SimpleByteSource类，实现serializable
步骤2、自定义ByteSourceUtils，加入生成SimpleByteSource静态方法
public class SimpleByteSource extends org.apache.shiro.util.SimpleByteSource
implements Serializable {
private static final long serialVersionUID = 5528101080905698238L;
public SimpleByteSource(byte[] bytes) {
super(bytes);
}
}
public class ByteSourceUtils {
public static ByteSource bytes(byte[] bytes) {
return new SimpleByteSource(bytes);
}
public static ByteSource bytes(String arg0) {
return new SimpleByteSource(arg0.getBytes());
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ed73de08de621b1496d3482631030e4/" rel="bookmark">
			vue中使用web worker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，JavaScript是单线程的，一些复杂比较耗时的操作，会阻塞页面的渲染交互，引起页面卡顿，影响用户体验。web worker是html5的新特性之一，主要就是用来解决此类问题，为页面额外开启一个线程，用来处理一些比较耗时操作，不影响主线程的进行。
在实际vue项目的开发使用过程中，还是遇到不少坑，特别记录一下。
首先，基本的web worker使用直接调用Worker构造函数，如下：
// url: js文件路径 // options: 配置信息 const worker = new Worker(url, options) 其次，不同模块间的通信主要通过postMessage进行消息推送，通过onmessage进行消息接收，如下所示：
// a.js let worker = new Worker('a.js') worker.postMessage({ method: 'transferLang' }) worker.onmessage = function (e) { init(e.data.params) } // b.js self.onmessage = ev =&gt; { let funName = ev.data.method if (self[funName]) { self[funName](ev.data.params) } else { console.warn(`方法${funName}未定义`) } } self.transferLang = function () { let arr = [] self.postMessage({ params: arr }) } 在vue项目中，如果直接使用，首先遇到的问题是worker文件路径与打包解析问题，这种首先需要安装worker-loader,解析web worker，执行以下命令即可：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ed73de08de621b1496d3482631030e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33522cfb120d63a9dfd31046f2722966/" rel="bookmark">
			js 防抖与节流（setTimeout的应用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.防抖（debounce）
防抖的作用是：当用户多次触发回调函数时，只触发最后一次操作的，其余的全部忽略掉；
在第一次触发事件时，不立即执行函数，而是给出一个期限值比如200ms 如果在200ms内没有再次触发滚动事件，那么就执行函数如果在200ms内再次触发滚动事件，那么当前的计时取消，重新开始计时 效果：如果短时间内大量触发同一事件，只会执行一次函数。
function debounce(fn,delay){ let timer = null //借助闭包 return function() { if(timer){ clearTimeout(timer) } timer = setTimeOut(fn,delay) } } function showTop () { var scrollTop = document.body.scrollTop || document.documentElement.scrollTop; console.log('滚动条位置：' + scrollTop); } window.onscroll = debounce(showTop,1000) 上述代码，在页面一直滚动时，不会打印出位置，只有停止滚动后1s，才会出现log里的内容。
如果在限定时间段内，不断触发滚动事件（比如某个用户闲着无聊，按住滚动不断的拖来拖去），只要不停止触发，理论上就永远不会输出当前距离顶部的距离。
2.节流（throttle）
但是如果产品同学的期望处理方案是：即使用户不断拖动滚动条，也能在某个时间间隔之后给出反馈呢？
其实很简单：我们可以设计一种类似控制阀门一样定期开放的函数，也就是让函数执行一次后，在某个时间段内暂时失效，过了这段时间后再重新激活（类似于技能冷却时间）。
function throttle(fn,delay){ let valid = true return function() { if(!valid){ //休息时间 暂不接客 return; } // 工作时间，执行函数并且在间隔期内把状态位设为无效 valid = false setTimeout(() =&gt; { fn() valid = true; }, delay) } } /* 请注意，节流函数并不止上面这种实现方案, 例如可以完全不借助setTimeout，可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定。 也可以直接将setTimeout的返回的标记当做判断条件-判断当前定时器是否存在，如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活，原理都一样 */ // 以下照旧 function showTop () { var scrollTop = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33522cfb120d63a9dfd31046f2722966/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ae3569eaf903ba5b52a47a12aa14712/" rel="bookmark">
			红黑树(自平衡的二叉查找树)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		30张图带你彻底理解红黑树
红黑树怎么自平衡？什么时候需要左旋或右旋？插入和删除破坏了树的平衡后怎么处理？ 红黑树定义和性质 红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：
性质1：每个节点要么是黑色，要么是红色。性质2：根节点是黑色。性质3：每个叶子节点（NIL）是黑色。性质4：每个红色结点的两个子结点一定都是黑色。性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。 性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点(在Java中，叶子结点是为null的结点。) 图1就是一颗简单的红黑树。其中Nil为叶子结点，并且它是黑色的。(值得提醒注意的是，在Java中，叶子结点是为null的结点。)
红黑树并不是一个完美平衡(左右子树高度相差为0)二叉查找树，从图1可以看到，根结点P的左子树显然比右子树高，但左子树和右子树的黑结点的层数是相等的，也即任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点(性质5)。所以我们叫红黑树这种平衡为黑色完美平衡。
我们把正在处理(遍历)的结点叫做当前结点，如图2中的D，它的父亲叫做父结点，它的父亲的另外一个子结点叫做兄弟结点，父亲的父亲叫做祖父结点。
红黑树自平衡 红黑树能自平衡，它靠的是什么？三种操作：左旋、右旋和变色。
左旋：以某个结点作为支点(旋转结点：P)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点（P）的右子结点，左子结点保持不变。如图3。 右旋：以某个结点作为支点(旋转结点：P)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。如图4。 变色：结点的颜色由红变黑或由黑变红。 我们先忽略颜色，可以看到旋转操作不会影响旋转结点的父结点，父结点以上的结构还是保持不变的。
左旋只影响旋转结点和其右子树的结构，把右子树的结点往左子树挪了。
右旋只影响旋转结点和其左子树的结构，把左子树的结点往右子树挪了。
但要保持红黑树的性质，结点不能乱挪，还得靠变色了。怎么变？具体情景又不同变法，后面会具体讲到，现在只需要记住红黑树总是通过旋转和变色达到自平衡。
红黑树查找 因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：
从根结点开始查找，把根结点设置为当前结点；若当前结点为空，返回null；若当前结点不为空，用当前结点的key跟查找key作比较；若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2； 非常简单，但简单不代表它效率不好。正由于红黑树总保持黑色完美平衡，所以它的查找最坏时间复杂度为O(2lgN)，也即整颗树刚好红黑相隔的时候。能有这么好的查找效率得益于红黑树自平衡的特性，而这背后的付出，红黑树的插入操作功不可没～
红黑树插入 插入操作包括两部分工作：一查找插入的位置；二插入后自平衡。查找插入的父结点很简单，跟查找操作区别不大：
从根结点开始查找；若根结点为空，那么插入结点作为根结点，结束。若根结点不为空，那么把根结点作为当前结点；若当前结点为null，返回当前结点的父结点，结束。若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束。若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4；若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4； 插入位置已经找到，把插入结点放到正确的位置就可以啦，但插入结点是应该是什么颜色呢？答案是红色。理由很简单，红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡。
插入情景1：红黑树为空树 最简单的一种情景，直接把插入结点作为根结点就行，但注意，根据红黑树性质2：根节点是黑色。还需要把插入结点设为黑色。
处理：把插入结点作为根结点，并把结点设置为黑色。
插入情景2：插入结点的Key已存在 插入结点的Key已存在，既然红黑树总保持平衡，在插入前红黑树已经是平衡的，那么把插入结点设置为将要替代结点的颜色，再把结点的值更新就完成插入。
处理：
把I设为当前结点的颜色（更换颜色）
更新当前结点的值为插入结点的值（更新值）
插入情景3：插入结点的父结点为黑结点 由于插入的结点是红色的，当插入结点的黑色时，并不会影响红黑树的平衡，直接插入即可，无需做自平衡。
处理：直接插入。
插入情景4：插入结点的父结点为红结点 再次回想下红黑树的性质2：根结点是黑色。如果插入的父结点为红结点，那么该父结点不可能为根结点，所以插入结点总是存在祖父结点。这点很重要，因为后续的旋转操作肯定需要祖父结点的参与。
情景4又分为很多子情景，下面将进入重点部分，各位看官请留神了。
插入情景4.1：叔叔结点存在并且为红结点（只需改颜色，并改变插入结点） 从红黑树性质4（每个红色结点的两个子结点一定都是黑色），祖父结点肯定为黑结点，因为不可以同时存在两个相连的红结点。那么此时该插入子树的红黑层数的情况是：黑红红。显然最简单的处理方式是把其改为：红黑红。如图9和图10所示。
处理：
将P和S设置为黑色
将PP设置为红色
把PP设置为当前插入结点
可以看到，我们把PP结点设为红色了，如果PP的父结点是黑色，那么无需再做任何处理；但如果PP的父结点是红色，根据性质4，此时红黑树已不平衡了，所以还需要把PP当作新的插入结点，继续做插入操作自平衡处理，直到平衡为止。
试想下PP刚好为根结点时，那么根据性质2，我们必须把PP重新设为黑色，那么树的红黑结构变为：黑黑红。换句话说，从根结点到叶子结点的路径中，黑色结点增加了。这也是唯一一种会增加红黑树黑色结点层数的插入情景。
我们还可以总结出另外一个经验：红黑树的生长是自底向上的。这点不同于普通的二叉查找树，普通的二叉查找树的生长是自顶向下的。
插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点 单纯从插入前来看，也即不算情景4.1自底向上处理时的情况，叔叔结点非红即为叶子结点(Nil)。因为如果叔叔结点为黑结点，而父结点为红结点，那么叔叔结点所在的子树的黑色结点就比父结点所在子树的多了，这不满足红黑树的性质5。后续情景同样如此，不再多做说明了。
前文说了，需要旋转操作时，肯定一边子树的结点多了或少了，需要租或借给另一边。插入显然是多的情况，那么把多的结点租给另一边子树就可以了。
插入情景4.2.1：插入结点是其父结点的左子结点（改颜色，右旋） 处理：
将P设为黑色
将PP设为红色
对PP进行右旋
由图11可得，左边两个红结点，右边不存在，那么一边一个刚刚好，并且因为为红色，肯定不会破坏树的平衡。
可以把PP设为红色，I和P设为黑色吗？答案是**可以！**看过《算法：第4版》的同学可能知道，书中讲解的就是把PP设为红色，I和P设为黑色。但把PP设为红色，显然又会出现情景4.1的情况，需要自底向上处理，做多了无谓的操作，既然能自己消化就不要麻烦祖辈们啦～
插入情景4.2.2：插入结点是其父结点的右子结点（左旋，修改插入结点，改颜色，右旋） 这种情景显然可以转换为情景4.2.1，如图12所示，不做过多说明了。
处理：
对P进行左旋
把P设置为插入结点，得到情景4.2.1
进行情景4.2.1的处理
插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点 该情景对应情景4.2，只是方向反转，不做过多说明了，直接看图。
插入情景4.3.1：插入结点是其父结点的右子结点（改颜色，左旋） 处理：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ae3569eaf903ba5b52a47a12aa14712/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/691bf52664b0f793b4ec69841e75d083/" rel="bookmark">
			git commit之后，撤销commit提交，却保留代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题背景：解决方法：关于参数：顺便说一下，如果commit注释写错了，只是想改一下注释，只需要： 简介： 已经git commit一次提交，但是想撤销commit这次提交，且保留代码不变
问题背景： 写完代码后，我们一般这样 git add . //添加所有文件 git commit -m "本功能全部完成" 执行完commit后，想撤回commit，怎么办？
解决方法： git reset --soft HEAD^ 这样就成功的撤销了你的commit
注意，仅仅是撤回commit操作，您写的代码仍然保留。
说一下个人理解： HEAD^的意思是上一个版本，也可以写成HEAD~1
如果你进行了2次commit，想都撤回，可以使用HEAD~2
关于参数： –mixed
意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作
这个为默认参数,git reset --mixed HEAD^ 和 git reset HEAD^ 效果是一样的。
–soft
不删除工作空间改动代码，撤销commit，不撤销git add .
–hard
删除工作空间改动代码，撤销commit，撤销git add .
注意完成这个操作后，就恢复到了上一次的commit状态。
顺便说一下，如果commit注释写错了，只是想改一下注释，只需要： git commit --amend 此时会进入默认vim编辑器，修改注释完毕后保存就好了。
参考：
git使用情景2：commit之后，想撤销commit
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/903e77fed74a92677f52db6fae36808e/" rel="bookmark">
			Android studio 创建aidl文件无法生成Java文件或Java文件为空(没有内容)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		as创建aidl生成的Java文件为空 在这里mark一下我自己发现的解决方案: 起初,我也搜索了很多篇博客文章,他们的方法还是没有解决我的问题, 他们的解决方法是, build--&gt;rebuild project, 我告诉你他们的这个方法 是解决as根本没有生成aidl对应的Java文件.在我这里的问题有点不一 样,我生成了aidl对应得Java文件,但是这个Java文件是空得,没有代码得 Java文件,我反复尝试了将近两个小时,都没有解决............................... . .	. . . . . . 经过多次尝试之后,我然后在aidl文件里面写了这样一句代码,生成Java成功 package com.example.date01; // Declare any non-default types here with import statements interface IMediaService { void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString); void hello(); } 我之前一直报错得代码是这样子的 package com.example.date01; // Declare any non-default types here with import statements interface IMediaService { void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString); //开始音乐 void openAudio(int position); //开始播放 void start(); //暂停 void pause(); } 发现有什么区别了没(这是细节) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/903e77fed74a92677f52db6fae36808e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9f1082feeace03d8d0bd0ffe1f6171f/" rel="bookmark">
			java社招面试题库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、编程语言java
java版本，jdk8么？使用过哪些新特性？
Lamdba表达式、stream api
https://blog.csdn.net/javazyw/article/details/82733459
Java中的String，StringBuilder，StringBuffer三者的区别
https://www.cnblogs.com/su-feng/p/6659064.html
HashMap,HashTable,HashSet之间的区别：
https://blog.csdn.net/baidu_21578557/article/details/51182135
设计模式一般用到了哪几种？有什么好处？
https://www.cnblogs.com/pony1223/p/7608955.html
jvm：
jvm运行时内存结构？
https://blog.csdn.net/Soinice/article/details/98038991
如何排查fullGc问题 ？
多线程：
说一下对synchronized的理解？说说自己在项目中是怎么使用 synchronized 关键字的？ https://blog.csdn.net/qq_41701956/article/details/83744357
二、j2ee
如何理解ioc和di
https://www.cnblogs.com/zdf159/p/7252949.html
Spring常用的三种注入bean的方式？
https://blog.csdn.net/a909301740/article/details/78379720
springMVC的整个处理机制
https://blog.csdn.net/andy_ayu/article/details/79528208 mybatis可以防止sql注入么？如何做到的？＃和&amp;的区别？
https://blog.csdn.net/weixin_39986856/article/details/83651847
如何理解restful
https://blog.csdn.net/a78270528/article/details/78469758
什么是Spring Boot，什么是Spring Cloud，以及两者之间有什么关系
Spring Cloud vs Dubbo
https://blog.csdn.net/gaowenhui2008/article/details/78486449
Docker Swarm和Kubernetes的优缺点以及如何进行取舍？
https://blog.csdn.net/qq_36609501/article/details/93138036
三、db
数据库事务的4种隔离级别？mysql是哪一种？
https://blog.csdn.net/mrsyf/article/details/79774168
数据库的隔离级别？mysql默认是哪个级别
https://blog.csdn.net/mrsyf/article/details/79774168
如何理解分库分表？
https://blog.csdn.net/wzbwzh/article/details/85332685
什么是索引
https://blog.csdn.net/liutong123987/article/details/79384395
Mysql几种索引类型的区别及适用情况
https://blog.csdn.net/qq_43747015/article/details/86555942
索引的利弊、使用索引的注意事项？
https://blog.csdn.net/qq_40933487/article/details/85269341
怎么判断sql有没有走到索引？
explain 查看执行计划
https://blog.csdn.net/zhujuntiankong/article/details/88118037
索引啥时候失效？
https://blog.csdn.net/xiao__ge/article/details/82145710
四、中间件
分布式缓存
Redis 与 memcache的区别，如何选择？
https://blog.csdn.net/followMyInclinations/article/details/82020116
本地缓存
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9f1082feeace03d8d0bd0ffe1f6171f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1d1ed41ae7db554c9715bdb5ab4d633/" rel="bookmark">
			idea报错 &#34;cannot access xxx&#34;的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用IEDA在项目中，偶尔会出现报错"cannot access xxx"
此时，执行IDEA重启，就不报错了，应该是IDEA本身的问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fe174081053455a1db5692bcc5f72d6/" rel="bookmark">
			LORA无线模块使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
DTU线数传电台
典型接法
串口参数配置
目录
快速通信配置
DTU线数传电台
典型接法
串口参数配置说明
电台功能
透明广播
定点传输
定点传输下的监听
LORA扩频模块AS-T20
连接方式
引脚说明
三种传输模式
四种工作模式
透明广播
定点传输
定点传输下的监听
透明传输
定向传输测试
快速通信配置 AS62-T20:5v供电、MD1&amp;MD2接低电平，透明传输 设置如下图：（注意：设置参数的时候，MD1&amp;MD2悬空）
DTU配置，通道设置一致
模块使用前都要先进行设置，是要地址通道的
模块使用：尽量5v，3.3v会降低传输距离。MD1、MD2上拉，不能悬空，可以都接地。
DTU线数传电台 典型接法 数传电台的参数可配置，支持读写命令操作，但是不常使用，不再了解。
串口参数配置说明 模块地址模块的地址，只有相同地址的模块才能通信，如果设置65535（0xffff）则是播地址，模 块在播地址下发送的数据任意地址的模块都可以收到，同时它可以接收任意 地址模块发来的数据。 通信信道只有相同信道的模块才能通信，如果在通信过程中受到扰可以改换其它信道。 FEC开关FEC前向纠错编码，FEC打开，模块抗扰性增强，但是实际的数据传输率会减低， FEC关闭，数据实际传输速率提升，但是抗扰能减弱。 发送状态透明传输：数据以透明方式发送和接收，所发即所收。 定向传输：数据帧的前3个字节作为高、低地址、信道。发射时，模块改变地址 和信道，完毕后，恢复原有设置。 定向传输在需要组的应用中，其它应用推荐用透明传输。
电台功能 电台功能 透明广播用户数据用户数据 任意电台发送数据，具有相同地址和相同信道的电台均 可接收。发送数据透明，所发即所收。
定点传输 接收方地址+接收方信道+用户数据
用户数据 任意电台发送数据，可指定电台接收，多个接收电台地址 信道相同时，均可接收数据。数据可以实现跨信道点对点 传输。
广播与监听 0xFF+0xFF+接收方信道+用户数据
用户数据 广播：任意电台发送数据，处于同一信道下的电台均可同 时接收数据； 监听：具有 0xFFFF 地址的电台可以接收同一信道下任意 地址电台发送的数据。
空中唤醒 1、透明传输模式下： （自动添加唤醒码 010101010······）+ 用户数据 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fe174081053455a1db5692bcc5f72d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c22d5c57cd25185571723f22716d8c8c/" rel="bookmark">
			面试问题之C&#43;&#43;语言：面向对象的三大特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载于：https://www.cnblogs.com/BEN-LK/p/10720249.html
面向对象的三大特性：封装、继承、多态
封装：就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或对象操作，对不可信的进行信息隐藏。一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。
继承：指可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念，它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的实现过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”和“组合”来实现。集成概念的实现方式有二类：实现继承与接口继承。
实现继承：是指直接使用基类的属性和方法而无需额外编码的能力；
接口继承：是指仅使用属性和方法的名称、但是子类必须提供实现的能力。
多态：是指一个类实例的相同方法在不同情况下有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。
转载于:https://www.cnblogs.com/yichengming/p/11450883.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e46c58750a8b58a6a05c7460c7e46e8/" rel="bookmark">
			排序入门练习题3 谁考了第k名 题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目出处：《信息学奥赛一本通》第二章 上机练习1
题目描述 在一次考试中，每个学生的成绩都不相同，现知道了每个学生的学号和成绩，求考第k名的学生的学号和成绩。
输入格式 输入的第一行包含两个整数，分别是学生的人数 \(n(1 \le n \le 1000)\) ，和求第 \(k\) 名学生的 \(k(1 \le k \le n)\) 。
接下来 \(n\) 行，每行包含一个学号（整数）和一个成绩（浮点数），中间用一个空格分隔。
输出格式 输出第 \(k\) 名学生的学号和成绩，中间用空格分隔，成绩请保留 \(2\) 位小数。
样例输入 5 3 9525 90.5 9526 100 9527 55.2 9528 60.13 9529 70.23 样例输出 9529 70.23 题目分析 首先我们需要开一个结构体来表示学生，并在定义的同时初始化一个结构体数组 a：
struct Student { int id; // id表示学号 double point; // point表示分数 } a[1001]; 然后因为我们需要按照成绩从高到低排序，所以我们需要写一个比较函数用于按照成绩从高到低排序：
bool cmp(Student a, Student b) { return a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e46c58750a8b58a6a05c7460c7e46e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6b1fd5424d4a9462b8a4bcc3fb04c96/" rel="bookmark">
			LCIS（算法竞赛进阶指南 P241，最长公共上升子序列）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.题目链接： LCIS 二.题目大意： 给两个长度为 n 的序列 A,B.
求 A, B 的最长公共上升子序列长度.
三.分析： 令 dp[i, j] 表示 A[1 ~ i] 与 B[1 ~ j] 可以构成以 B[j] 结尾的 LICS 的长度.
当 A[i] != B[j] 时，dp[i, j] = dp[i - 1, j].
当 A[i] == B[j] 时，想要计算 dp[i, j] 只需要遍历 k (0 ≤ k ＜ j)
若 B[k] &lt; A[i]，说明 A[i] 可以接在 dp[i - 1, k] 后面转移为 dp[i, j].
当然，这里要取 dp[i - 1, k] 的最大值.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6b1fd5424d4a9462b8a4bcc3fb04c96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/850c2fc01a44210f0531a50a3eb93856/" rel="bookmark">
			sql学习输出一（sql小白）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个前端最近被安排重做smartbi报表，然后开始自己写sql，来记录些简单的语句，和写时报错需要注意的地方吧，小白，可能本身理解有误。
1、查询
select a,b,c from 表名
(1)多种条件显示自己想要的对应结果
case when a='111' then '字段1'
when a='222' then ‘字段2’
end as 字段名
(2) goup by a,b,c(按字段分组)
分组的字段在前面查询需要一一对应，否则会报错。
(3)order by a,b,c desc(asc) 排序
字段排序不要用count,max后新起的字段名，要用本来有的字段，否则会报错。
(4)函数
count sum max 等等
(5)条件
where a=............
2、修改字段值
update 表名set a = '',b ='' where c = '';
3、插入数据
insert into 表名(字段名1,字段名2,字段名3,...)
values(value1,value2,value3,...);
4、删除数据
delete from 表名 where 条件
5、两个表联合查询
a inner join (取交集) left join （取交集和左边表） right join（取交集和右边表） b on a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/850c2fc01a44210f0531a50a3eb93856/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b42ac184b81cadec23b32347a7bef92d/" rel="bookmark">
			Java基础——Java&#34;多继承&#34;的三种实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java基础——Java"多继承"的三种实现方式 Java语言本身只支持单继承(每个类只能有一个父类)，但单继承的局限性很大，因此，可以通过以下的方式实现"多继承"。 多层继承
内部类
接口
1、多层继承 通过继承的层叠实现多继承，但多层继承一般不要超过3层，代码比较冗余。 class A{ public void getA(){ System.out.println("This is A"); } } class B extends A{ public void getB(){ System.out.println("This is B"); } } class C extends B{ public void getC(){ System.out.println("This is C"); } } public class MultipleInherit { public static void main(String[] args) { // 此时的C通过继承B，也继承了A(B继承着A)，从而实现了"多继承"(C继承了A与B) C c = new C(); c.getA(); c.getB(); c.getC(); } }	输出如下： 2、内部类 使用成员内部类也可实现"多继承" class D{ public void getD(){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b42ac184b81cadec23b32347a7bef92d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2bda91a90d2ac08c8ddc8c1fa1d98d5/" rel="bookmark">
			安装sass时遇到Failed to build gem native extension
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误信息 执行命令: sudo gem install sass时遇到下面的错误信息
Building native extensions. This could take a while... ERROR: Error installing sass: ERROR: Failed to build gem native extension. current directory: /var/lib/gems/2.5.0/gems/ffi-1.11.1/ext/ffi_c /usr/bin/ruby2.5 -r ./siteconf20190522-24821-9c6o4.rb extconf.rb mkmf.rb can't find header files for ruby at /usr/lib/ruby/include/ruby.h extconf failed, exit code 1 Gem files will remain installed in /var/lib/gems/2.5.0/gems/ffi-1.11.1 for inspection. Results logged to /var/lib/gems/2.5.0/extensions/x86_64-linux/2.5.0/ffi-1.11.1/gem_make.out 解决 看了网上的一些解决方案，最后通过装的完整ruby解决的。
原先安装ruby用的命令是: sudo apt install ruby
改用命令sudo apt install ruby-full安装ruby，然后再用命令sudo gem install sass成功安装sass。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2bda91a90d2ac08c8ddc8c1fa1d98d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f95e70b4826589f69f4c4328c091bea/" rel="bookmark">
			\Src\sengine.a(1): error: A1167E: Invalid line start 错误解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人添加了.a库文件到keil5项目中，添加头文件调用静态库
但是编译报…\Src\sengine.a(1): error: A1167E: Invalid line start 错误。
解决方法：
选中库文件.a文件，右键选择Options for File '*****.a’设置文件类型为Library file，就可以编译通过了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eaac71b75218d25dfb6239417581157/" rel="bookmark">
			USDT节点部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		USDT节点部署 前言 Github 地址：https://github.com/OmniLayer/omnicore
下载地址：http://www.omnilayer.org/download.html
安装依赖 yum install boost-devel libevent-devel openssl-devel gcc gcc-c++ qt-devel protobuf-devel qrencode-devel libtool git autoconf automake -y BerkeleyDB 下载链接：https://www.oracle.com/database/technologies/related/berkeleydb-downloads.html
mkdir -p /usr/local/apps/BerkeleyDB/db tar -zxvf db-18.1.32.tar.gz cd db-18.1.32 ./dist/configure --enable-cxx --disable-shared --with-pic --prefix=/usr/local/apps/BerkeleyDB/db make &amp;&amp; make install omnicore 源码安装 Github 地址：https://github.com/OmniLayer/omnicore
安装包安装 下载地址：http://www.omnilayer.org/download.html
tar -zxvf omnicore-0.5.0-x86_64-linux-gnu.tar.gz 在默认位置创建配置文件（默认位置：~/.bitcoin/bitcoin.conf）
mkdir -p ~/.bitcoin cd ~/.bitcoin touch bitcoin.conf vim bitcoin.conf bitcoin.conf 配置文件如下
#数据保存目录 datadir=/usr/local/apps/usdt/data # 使用测试网络 #testnet=1 #后台运行 daemon=1 #所有交易进行索引；否则只保留钱包地址交易索引记录 txindex=1 deprecatedrpc=addwitnessaddress ##开启RPC访问 server=1 rest=1 rpcbind=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5eaac71b75218d25dfb6239417581157/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a463f37cdbc1f5cb719a5cdb9f1ed6c/" rel="bookmark">
			SCPI基本语法和三种通信方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.SCPI基本语法介绍 基本语法包括：
1.语法结构；
2.语法实例/例化。
2.仪器的三种通信方式 ethernet、usb device 、GPIB
其中USB host可以通过选件转接到GPIB。
3.一个疑惑 这次发现通过网线，将示波器、信号发生器通过网线到交换机，与主机PC相连，结果烧坏了一个交换机，更换一个交换机后，温度还是较高。不知道什么原因。
目前最最可疑导致交换机损坏的原因应该是温度，所以保持环境温度适宜，不行的话就给交换机加一个散热扇。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf6fe0a5f51ddfe39569d5e4609dc1bb/" rel="bookmark">
			PyCharm搭建Spark开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装好JDK
下载并安装好jdk-12.0.1_windows-x64_bin.exe，配置环境变量：
新建系统变量JAVA_HOME，值为Java安装路径新建系统变量CLASSPATH，值为 .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;（注意最前面的圆点）配置系统变量PATH，添加 %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin 在CMD中输入：java或者java -version，不显示不是内部命令等，说明安装成功。
2.安装Hadoop，并配置环境变量
下载hadoop：https://www.apache.org/dyn/closer.cgi/hadoop/common/hadoop-2.7.7/hadoop-2.7.7.tar.gz
解压hadoop-2.7.7.tar.gz特定路径，如：D:\adasoftware\hadoop添加系统变量HADOOP_HOME：D:\adasoftware\hadoop在系统变量PATH中添加：D:\adasoftware\hadoop\bin安装组件winutils：将winutils中对应的hadoop版本中的bin替换自己hadoop安装目录下的bin 3.Spark环境变量配置
spark是基于hadoop之上的，运行过程中会调用相关hadoop库，如果没配置相关hadoop运行环境，会提示相关出错信息，虽然也不影响运行。
下载对应hadoop版本的spark：http://spark.apache.org/downloads.html解压文件到：D:\adasoftware\spark-2.4.3-bin-hadoop2.7添加PATH值：D:\adasoftware\spark-2.4.3-bin-hadoop2.7\bin;新建系统变量SPARK_HOME：D:\adasoftware\spark-2.4.3-bin-hadoop2.7; 4.下载安装anaconda
anaconda集成了python解释器和大多数python库，安装anaconda 后不用再安装python和pandas numpy等这些组件了。下载地址。最后将python加到path环境变量中。
5.在CMD中运行pyspark，出现类似下图说明安装配置正常：
出现这种warning是因为JDK版本为12，太高了，但是不影响运行。没有影响。
6.在pycharm中配置spark
打开PyCharm，创建一个Project。然后选择“Run” -&gt;“Edit Configurations”–&gt;点击+创建新的python Configurations 选择 “Environment variables” 增加SPARK_HOME目录与PYTHONPATH目录。
SPARK_HOME:Spark安装目录PYTHONPATH:Spark安装目录下的Python目录 选择 File-&gt;setting-&gt;你的project-&gt;project structure右上角Add content root添加：py4j-some-version.zip和pyspark.zip的路径（这两个文件都在Spark中的python文件夹下）保存即可 7.测试是否配置成功，程序代码如下，创建一个python程序放进去就可以：
import os import sys # Path for spark source folder os.environ['SPARK_HOME'] = "D:\adasoftware\spark" # Append pyspark to Python Path sys.path.append("D:\adasoftware\spark\python") try: from pyspark import SparkContext from pyspark import SparkConf print("Successfully imported Spark Modules") except ImportError as e: print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf6fe0a5f51ddfe39569d5e4609dc1bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70c52a9d5c5dad87406753698c185989/" rel="bookmark">
			关于RecyclerView加载更多时会变得很卡的问题解决！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果使用了notifyDataSetChanged();这个方法刷新RecyclerView的，
改为要使用notifyItemRangeChanged( start，end）开始的item postion，结束的item postion。
原因：
因为notifyDataSetChanged();这个方法刷新的是全部的item，notifyItemRangeChanged( start，end）这个方法刷新的是部分的item。
其他原因的绕道。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/297c469da718f77050c892249a0b6ef4/" rel="bookmark">
			清华镜像pip安装命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在ubuntu系统下
pip3 install 安装包的名字 -i https://pypi.tuna.tsinghua.edu.cn/simple/ 永久设置
pip install pip -U pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bcee12c9cfa8ad607af3ba94569cfb7/" rel="bookmark">
			linux整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.VMware安装linux系统
https://blog.csdn.net/dyl_369/article/details/90602597
2.怎么传文件到虚拟机与共享文件夹的方法
https://blog.csdn.net/u012922284/article/details/22861521
3.通过SSH连接本地linux虚拟机
https://blog.csdn.net/Robin_hc/article/details/94417056
4.Xftp5解决“要继续使用此程序,您必须应用最新的更新或使用新版本
https://www.jianshu.com/p/c520afc14de2
5.Linux 安装多个版本JDK并设置默认版本
https://www.cnblogs.com/Latiny/p/9579102.html
6.Linux创建用户并指定目录为根目录
https://blog.csdn.net/qq_24909089/article/details/81068112
7.linux中chmod更改文件权限命令需要用到sudo命令暂时提升使用权限
sudo chmod 777 代表什么：
三位数字分别代表 user、group、others 的权限，可读(r)、可写(w)、可执行(x)的权限分别用数字 4、2、1
表示，数字7是权限 4、2、1 的和，777 即代表 user、group、others
8.如何配置sudo命令
https://blog.csdn.net/qq_39290007/article/details/81125750
9.启动tomcat同时输出日志
https://blog.csdn.net/lcz_2/article/details/9970481
10.将catalina.out文件按照日期分类
https://blog.csdn.net/Dongguabai/article/details/80225894
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98df71ef0e3ed32a94a87158f2020c21/" rel="bookmark">
			Vue组件化中的data为什么必须是一个函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		了解Vue的朋友都知道在使用组件中
其中的data,必须是一个函数,不然就会报错,这是问什么 ,今天我们就来探究一下,这其中的缘由;
首先是设计好一个组件,如下:
&lt;div class="app"&gt; &lt;h3&gt;这三个组件对象不会相互影响,组件data() 是为一个方法的原因&lt;/h3&gt; &lt;btn1&gt;&lt;/btn1&gt;&lt;btn1&gt;&lt;/btn1&gt;&lt;btn1&gt;&lt;/btn1&gt; &lt;/div&gt; &lt;template id="temp"&gt; &lt;div&gt; &lt;div&gt; {{count}} &lt;/div&gt; &lt;button&gt;&lt;span @click="minus()"&gt;-&lt;/span&gt;&lt;/button&gt; &lt;button&gt;&lt;span @click="add()"&gt;+&lt;/span&gt;&lt;/button&gt; &lt;div&gt;div{添加用户} &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; Vue.component("btn1",{ template:"#temp", data(){ return{ count:0, } }, methods:{ add(){ this.count++; }, minus(){ this.count--; }, } }) &lt;/script&gt; &lt;script&gt; // 这是个实例对象, this 是不能少的; var app = new Vue({ el: '.app', data: {}, methods: { }, }) &lt;/script&gt; \
结果是这样:
分别点击后:
可以发现这三个组件的复用并没有相互之间影响,这也是为什么data,必须是一个函数的原因了,
这里相当于每个组件函数都开辟了一个内存地址,所以不会相互影响;
这里或许有人问了,如果我要同时改变呢?
那又该怎么办呢
只需在最前面中将用const 声明一个ob对象,然后在data中返回;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98df71ef0e3ed32a94a87158f2020c21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b54de420f4011c6c7e7c5e185188b866/" rel="bookmark">
			C&#43;&#43;守则——确定对象被使用前已经被初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++对于初始化这件事是喜怒无常的，比方这行代码：
int x; 又时候C++编译器会将它初始化为0，但有时候却又不一定。如果编译器真的读取到一个为初始化的值时就会导致各种不明确也的伪白兔，情节较轻的话就会终止程序，情节较重的话，就会读取一些伴随及的值，污染了正在进行读取动作的那个对象，最终导致不可测知的程序行为。
事实上关于对象的初始化动作合是一定发生，何时不一定发生是由一些规则的，但是这些规则没必要去浪费时间记，既然你说未初始化有风险，那我就全部初始化好了，全初始化不就没有问题了吗?
内置类型可以给他初始化值，或者通过用户的输入来获取：
int x = 0; const char 8text = "A C-Style string"; double d; std::cin &gt;&gt; d; 内置类型以外的，其初始化就靠构造函数，其规则为：确保每一个成员都被初始化了：
class PhoneNumber {...}; class ABEntry { public: ABEntry(const std::string &amp;name, const std::string &amp;address, const std::list&lt;PhoneNumber&gt; &amp;phone); private: std::string theName; std::string theAddress; std::list&lt;PhoneNumber&gt; thePhones; int numTimeConsulted; }; ABEntry::ABEntry(const std::string &amp;name, const std::string &amp;address, const std::list&lt;PhoneNumber&gt; &amp;phone) { /*这些都是赋值而不是初始化*/ theName = name; theAddress = address; thePhones = phones; numTimesConsulted = 0; } 这是我们自己常用的写法，然鹅编译器是这么做的：在构造函数之前就发生了初始化，然后进入构造函数，最后再是构造函数里面的赋值。我们现在换一种写法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b54de420f4011c6c7e7c5e185188b866/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc1fd2f7b767cbda729254fe61dd3f2/" rel="bookmark">
			Blender雕刻模块：如何在雕刻过程中无缝合并物体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文基于Blender 2.8正式版
在雕刻过程中经常会新建一些物体然后合并进来一起雕刻，但是实际操作中会出现很多意想不到的问题
例如:简单地把两个物体Ctrl + J合并到一起
使用Smooth笔刷无法去掉衔接处的缝隙
即使在缝隙处用Clay Strips笔刷涂上厚厚的一层，也很容易穿帮。
解决方法：使用自带插件BoolTool中的Union无缝合并可以一步到位！ 1. 激活BoolTool BoolTool是Blender自带的老牌插件，在插件页面激活即可。
2. 无缝合并 选择要合并的物体Ctrl + Shift + B调出BoolTool的菜单，选择Union或者直接使用快捷键Shift + Ctrl + 数字键盘+即可。
无缝合并后的物体就可以通过Smooth笔刷轻松去掉衔接处的缝隙了
小结
其实Ctrl + J合并只能算是简单的把两个物体组合到了一个物体并不对拓扑结构做任何改变，而BoolTool中的Ctrl + Shift + 数字键盘+合并相当于进行了布尔运算中合并，自然就浑然一体了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/685024e2b0efa518d98427a0cd0b73a4/" rel="bookmark">
			Blender技巧：生物角色雕刻起形技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文基于Blender 2.8 并参考了AgenZasBrothers的教程Introduction: Sculpting in Blender (Tutorial EN)
技巧一： 带着表面细分修改器起形
1. 新建正方体 2. 加表面细分修改器，2级即可，但是不要应用，直接进入编辑模式继续起形 继续以多边形建模方式起形
这样可以时时观察细分后的效果，并保持起形的速度。
技巧二： 快速拆分独立组件来"拼凑"复杂结构
(书接上文，表面细分修改器仍未被应用)因为是为雕刻做准备，雕刻完毕肯定要重拓扑，所以复杂结构用组合的方式拼凑出来即可。
在编辑模式下，任选一个面Shift + D复制，然后E挤出该面，形成一个独立组件
注意
这时独立组件和原来的部分依然属于同一个物体，如果需要拆分组件，请参考Blender建模模块：分离命令
这样，等大形起得差不多了，再切换到物体模式把表面细分修改器应用掉，进入雕刻模式继续细节雕刻。
注意
应用完表面细分修改器，如果想要合并组件，请参考Blender雕刻模块：如何在雕刻过程中无缝合并物体
小结
这种方法兼顾了多边形建模构造轮廓快和雕刻勾勒细节方便的优点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/952c281856844b5d9e33cc5be4d1c124/" rel="bookmark">
			Blender：雕刻模式常用快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文基于Blender 2.8正式版
命令快捷键说明动态拓扑(DynTopo)开关Ctrl + D动态拓扑(DynTopo)细节Shift + D当动态拓扑开启时有效笔刷半径F按一下就可以无需按住，再点击左键确定笔刷强度Shift + F按一下就可以无需按住，再点击左键确定快速切换光滑(Smooth)笔刷Shift多数笔刷适用快速切换反向笔刷Ctrl多数笔刷适用 建议开启动态拓扑(DynTopo)后设置动态拓扑的笔刷模式为恒定细节(Constant Detail)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dc2145fcafa72a33fe2b3121a214097/" rel="bookmark">
			倒置排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 将一些整数按倒置值排序后输出. 所谓倒置,是指把整数各位倒过来构成一个新数,例如:13倒置成了31.
#include&lt;iostream&gt; #include&lt;cmath&gt; #define t 10000+10 int a[t],b[t]; using namespace std; int main() { int N,s,n,m; cin&gt;&gt;N; for(int i=1;i&lt;=N;i++) { cin&gt;&gt;n; for(int j=1;j&lt;=n;j++) { s=0; cin&gt;&gt;m; a[j]=m; for(int i=1;m!=0;i++) { s=s*10+m%10; m/=10; } b[j]=s; } for(int k=1;k&lt;=n-1;k++) for(int j=1;j&lt;=n-k;j++) if(b[j]&gt;b[j+1]) { swap(b[j],b[j+1]); swap(a[j],a[j+1]); } for(int k=1;k&lt;=n;k++) cout&lt;&lt;a[k]&lt;&lt;" "; cout&lt;&lt;endl; } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ba4e3d0c1b76e441a2202471818a7bf/" rel="bookmark">
			substr函数的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、substr函数格式 (俗称：字符截取函数)
格式1： substr(string string, int a, int b);
格式2：substr(string string, int a) ;
解释：
格式1： 1、string 需要截取的字符串 2、a 截取字符串的开始位置（注：当a等于0或1时，都是从第一位开始截取） 3、b 要截取的字符串的长度 格式2： 1、string 需要截取的字符串 2、a 可以理解为从第a个字符开始截取后面所有的字符串。 实例
1、select substr('HelloWorld',0,3) value from dual; //返回结果：Hel，截取从“H”开始3个字符 2、select substr('HelloWorld',1,3) value from dual; //返回结果：Hel，截取从“H”开始3个字符 3、select substr('HelloWorld',2,3) value from dual; //返回结果：ell，截取从“e”开始3个字符 4、select substr('HelloWorld',0,100) value from dual; //返回结果：HelloWorld，100虽然超出预处理的字符串最长度，但不会影响返回结果，系统按预处理字符串最大数量返回。 5、select substr('HelloWorld',5,3) value from dual; //返回结果：oWo 6、select substr('Hello World',5,3) value from dual; //返回结果：o W (中间的空格也算一个字符串，结果是：o空格W) 7、select substr('HelloWorld',-1,3) value from dual; //返回结果：d （从后面倒数第一位开始往后取1个字符，而不是3个。原因：下面红色 第三个注解） 8、select substr('HelloWorld',-2,3) value from dual; //返回结果：ld （从后面倒数第二位开始往后取2个字符，而不是3个。原因：下面红色 第三个注解） 9、select substr('HelloWorld',-3,3) value from dual; //返回结果：rld （从后面倒数第三位开始往后取3个字符） 10、select substr('HelloWorld',-4,3) value from dual; //返回结果：orl （从后面倒数第四位开始往后取3个字符） （注：当a等于0或1时，都是从第一位开始截取(如：1和2)）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ba4e3d0c1b76e441a2202471818a7bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c0f4f111ed8f9769d7e9d749222b742/" rel="bookmark">
			c&#43;&#43;交替打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;thread&gt; #include &lt;iostream&gt; #include &lt;mutex&gt; #include &lt;condition_variable&gt; std::mutex data_mutex; std::condition_variable data_var; bool flag = true; void printA() { while(1) { std::this_thread::sleep_for(std::chrono::seconds(1)); std::unique_lock&lt;std::mutex&gt; lck(data_mutex) ; data_var.wait(lck,[]{return flag;}); std::cout&lt;&lt;"thread: "&lt;&lt; std::this_thread::get_id() &lt;&lt; " printf: " &lt;&lt; "A" &lt;&lt;std::endl; flag = false; data_var.notify_one(); } } void printB() { while(1) { std::unique_lock&lt;std::mutex&gt; lck(data_mutex) ; data_var.wait(lck,[]{return !flag;}); std::cout&lt;&lt;"thread: "&lt;&lt; std::this_thread::get_id() &lt;&lt; " printf: " &lt;&lt; "B" &lt;&lt;std::endl; flag = true; data_var.notify_one(); } } int main() { std::thread tA(printA); std::thread tB(printB); tA.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c0f4f111ed8f9769d7e9d749222b742/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8b577f4fde5582efcbb7e056b649832/" rel="bookmark">
			Vue | router-view传值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		router-view传值也是父子组件传值
父组件中：
&lt;div&gt; &lt;v-top&gt;&lt;/v-top&gt; &lt;router-view :data1="data1"&gt;&lt;/router-view&gt; &lt;/div&gt; data(){ return { data1:'init', } }, created(){ this.data1 = 'change in created()' }, mounted() { this.data1 = 'change in mounted()'; } 子组件中：
props: ['data1'] mounted(){ console.log(this.data1); } 结果 原因是当父组件mounted函数运行前，页面dom已经完成了加载，即子组件已经加载好，数据也已经传过去了。
而created阶段，可以给数据赋值，但还没有加载dom，因此可以在这一阶段给数据赋值，等待dom加载。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08422fa0bac691a8f48688cfbf37f414/" rel="bookmark">
			实时推送消息(rabbitmq&#43;vue实现stomp协议消息推送)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近公司项目用到实时推送消息，所以把方法附上，各位有不同见解的留言。现在代码附上：
index.html页面内引入js &lt;script type="text/javascript" src="/static/sockjs.min.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/static/webstomp.min.js" charset="utf-8"&gt;&lt;/script&gt; 在utils内新建sysconstant.js(对参数的配置) export const MQ_PROTOCOL = 'ws' //连接协议 export const MQ_IP = '192.168.2.2' //ip export const MQ_PORT = '15674' //端口 export const MQ_ADDRESS = 'ws' export const MQ_ACCOUNT = 'admin' //账号 export const MQ_PASSWORD = 'admin' //密码 export const MQ_SUBSCRIPT = '/exchange/school_inout/school_inout_routingkey' //订阅地址 在页面中使用 import { MQ_PROTOCOL, MQ_IP, MQ_PORT, MQ_ADDRESS, MQ_ACCOUNT, MQ_PASSWORD, MQ_SUBSCRIPT } from '../../utils/sysconstant'; export default{ data (){ return { address: null, //连接地址 client: null, subscribes: {}, } }, beforeDestroy(){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08422fa0bac691a8f48688cfbf37f414/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/463/">«</a>
	<span class="pagination__item pagination__item--current">464/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/465/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>