<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13bb137def3872946ee90b3cf57bed05/" rel="bookmark">
			腾讯云Centos7 python3.6升级到python3.8.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近想要学习Ai错别字算法，自己的电脑运行有特别慢，特意斥巨资花了800大洋在腾讯云买了一台服务器（一个月GPU，真的贵，伤不起）
想要安装Python3.8.1，但是原来有了python2.7和python3.6了 所以只能升级处理了
第一步查询现在python 安装的版本
[root@VM-0-15-centos Python]# whereis python 第二步 下载python3.8.1
wget http://www.python.org/ftp/python/3.8.13/Python-3.8.13.tgz 第三步 解压 安装
tar zxvf Python-3.8.13.tgz #创建一个新的文件 mkdir /usr/local/python3 cd Python-3.8.13 ./configure --prefix=/usr/local/python3 安装 make &amp;&amp; make altinstall 第四步 配置软连接
#查询python软连接 ls -l /usr/bin/python* 删除python软连接 rm -rf /usr/bin/python 删除python3软件 rm -rf /usr/bin/python3 建立 python3的软连接 ln -s /usr/local/bin/python3 /usr/bin/python3 ln -s python3 /usr/bin/python3 查询现在的python 版本
[root@VM-0-15-centos Python]# python -V Python 3.8.13 修改yum的文件 否则会报错
vi /usr/bin/yum #将/usr/bin/python改为/usr/bin/python2 vi /usr/libexec/urlgrabber-ext-down #将/usr/bin/python改为/usr/bin/python2 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/707a8847104f9c20e2b5db1219eb3835/" rel="bookmark">
			springboot整合canal 简单好用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，下载canal,配置mysql开启binlog，配置canal的instance.properties
https://github.com/alibaba/canal/wiki/QuickStart
2,代码里引入pom.xml
&lt;dependency&gt; &lt;groupId&gt;top.javatool&lt;/groupId&gt; &lt;artifactId&gt;canal-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.1-RELEASE&lt;/version&gt; &lt;/dependency&gt; 3实现接口EntryHandler&lt;T&gt;
@Component @CanalTable("user") public class UserHandler implements EntryHandler&lt;User&gt; { /** * 新增操作 * @param user */ @Override public void insert(User user) { //你的逻辑 System.out.println("新增 {}"+user); } /** * 对于更新操作来讲，before 中的属性只包含变更的属性，after 包含所有属性，通过对比可发现那些属性更新了 * @param before * @param after */ @Override public void update(User before, User after) { //你的逻辑 System.out.println("更新 before{}"+before); System.out.println("更新 after{}"+after); } /** * 删除操作 * @param user */ @Override public void delete(User user) { //你的逻辑 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/707a8847104f9c20e2b5db1219eb3835/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7edc25a4da7c670127a881b63cb78fd/" rel="bookmark">
			CSP-J信息学奥赛考试大纲（入门级）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
教学PPT代码视频
2.1.1计算机基础与编程环境
【1】计算机的基本构成（CPU、内存、I/O设备等）【1】Windows、Linux等操作系统的基本概念及其常见操作【1】计算机网络和Internet的基本概念【1】计算机的历史及其在现代社会中的常见应用【1】NOI以及相关活动的历史【1】进制的基本概念与进制转换、字节与字【1】程序设计语言以及程序编译和运行的基本概念【1】使用图形界面新建、复制、删除、移动文件或目录【1】使用Windows系统下的集成开发环境（例如Dev C++等）【1】使用Linux系统下的集成开发环境（例如Code:：Blocks等）【1】g++、gcc等常见编译器的基本使用 2.1.2 C++程序设计
1.程序基本概念
【1】标识符、关键字、常量、变量、字符申、表达式的概念【1】常量与变量的命名、定义及作用【1】头文件与名字空间的定义与理解【1】编辑、编译、解释、调试等概念理解 2.基本数据类型
【1】整数型：int，long long【1】实数型：float，double【1】字符型：char【1】布尔型：bool 3.程序基本语句
【2】cin语句，scanf语句，cout语句，printf语句，赋值语句，复合语句【2】if语句，switch语句，多层条件语句【2】for 语句，while 语句，do while 语句【3】多层循环语句 4.基本运算
【1】算术运算：加、减、乘、除、整除、求余【1】关系运算：大于，大于等于，小于，小于等于，等于，不等于【1】逻辑运算：与（&amp;&amp;）、或（||）、非（！）【1】变量自增与自减运算【1】三目运算【2】位运算：与（&amp;）、或（|）、非（~）异或（^）、左移、右移 5．数学库常用函数
【3】绝对值函数，四舍五入函数，取上整函数，取下整函数，常用三角函数，对数函数，指数函数，平方根函数 6．结构化程序设计
【1】顺序结构、分支结构和循环结构【1】自顶向下、逐步求精的模块化程序设计【2】流程图的概念及流程图描述 7.数组
【1】数组定义，数组与数组下标的含义【1】数组的读入与输出【2】纯一维数组的综合运用【3】纯二维数组与多维数组的综合应用 8．字符串的处理
【2】字符数组与字符串的关系【2】字符数组的综合应用【2】string类定义、相关函数引用【3】string类的综合应用 9.函数与递归
【2】函数定义与调用，形参与实参【3】传值参数与传引用参数·【2】常量与变量的作用范围【2】递归函数的概念、定义与调用 10．结构体类型
【3】结构体的定义及应用 11.指针类型
【4】指针的概念及调用【4】指针与数组【4】字符指针与string类【4】指向结构体的指针 12.文件及基本读写
【2】文件的基本概念，文本文件的基本操作【2】文本文件类型与二进制文件类型【2】文件重定向、文件读写等操作 13.STL模板应用
【3】&lt;algorithm&gt; 中sort函数【4】栈（stack）、队列（queue）、链表（list）、向量（vector）等容器 2.1.3数据结构
1.线性表
【3】链表：单链表、双向链表、循环链表【3】栈【3】队列 2.简单树
【3】树的定义及其相关概念【4】树的父亲表示法【3】二叉树的定义及其基本性质【4】二叉树的孩子表示法【4】二叉树的遍历：前序、中序、后序遍历 3.特殊树
【4】完全二叉树的定义与基本性质【4】完全二叉树的数组表示法【4】哈夫曼树的定义、构造及其遍历【4】二叉排序树的定义、构造及其遍历 4.简单图
【3】图的定义及其相关概念【4】图的邻接矩阵存储【4】图的邻接表存储 2.1.4算法
1.算法概念与描述
·【1】算法概念·【2】算法描述：自然语言描述、流程图描述、伪代码描述 2.人门算法
【1】枚举法【1】模拟法 3，基础算法
【3】贪心法【3】递推法【4】递归法【4】二分法·【4】倍增法 4.数值处理算法
【4】高精度的加法·【4】高精度的减法·【4】高精度的乘法【4】求高精度整数除以单精度整数的商和余数 5.排序算法
【3】排序的基本概念（稳定性等）【3】冒泡排序【3】简单选择排序【3】简单插入排序 6.图论算法
【4】图的深度优先遍历算法【4】图的宽度优先遍历算法【5】洪水填充算法（floodfill） 7.动态规划
【4】动态规划的基本思路【4】简单一维动态规划【5】简单背包类型动态规划【5】简单区间类型动态规划 2.1.5数学
1.数及其运算
【1】数的概念，算术运算（加、减、乘、除、求余）【1】数的进制：二进制、八进制、十六进制和十进制及其转换【2】编码：ASCI码，哈夫曼编码，格雷码 2.初中数学
【1】初中代数【1】初中平面几何 3.初等数论
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7edc25a4da7c670127a881b63cb78fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/023161c2ac7a47a82823fd22ca99cfe6/" rel="bookmark">
			CSP-S信息学奥赛考试大纲（提高级）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
教学PPT代码视频
2.2.1 计算机基础知识与编程环境
1.【5】在Linux系统终端中使用mkdir，cp、rm、mv等命令新建、复制、删除、移动文件或目录
2.【5】在Linux系统终端中使用cd，pwd，ls等命令更改、显示目录路径和查看目录中的文件
3.【5】在Linux系统下使用Gedit，Vim或 Emacs等文本编辑工具编写代码
4.【5】熟悉g++、gcc等编译器以及优化、数学库等常见编译选项
5.【5】在Linux系统终端中运行程序，并使用time令查看程序用时（区分real time，sys time和user time）
6.【5】了解调试工具 gdb及其break, display, continue，step等命令
2.2.1 C++程序设计
21.类（class）
【6】类的概念及简单应用
【6】成员函数和运算符重载
2.STL模板
【5】集合（set）
【5】列表（list），双端队列（deque），优先队列（priority_queue）
【5】多重集合（multiset）
【5】映射（map），多重映射（multimap）
【5】对（pair），元组（tuple）
2.2.2数据结构
1.线性结构
【5】双端栈
【5】双端队列
【5】有序队列
【6】优先队列
【6】倍增表（ST表）
2.集合与森林.
【6】等价类
【6】并查集
【6】树与二叉树的转化--孩子兄弟表示法
3.特殊树
【6】线段树与树状数组
【6】字典树（trie树）
【7】笛卡尔树
【8】二叉平衡树AVL，treap，splay等
【8】基环树
4.常见图
【5】稀疏图
【6】偶图（二分图）
【6】欧拉图
【6】有向无环图
【7】连通图与强连通图
【7】重连通图
5.哈希表
【5】数值哈希函数构造
【6】排列哈希函数构造
【6】字符串哈希函数构造
【6】哈希函数冲突的常用解决方法
2.2.3算法
1.复杂度分析
【6】空间复杂度分析
【6】时间复杂度分析
2.基础算法
【6】分治算法
3.排序算法
【5】归并排序
【5】快速排序
【6】堆排序
【6】树形选择排序（锦标赛排序）
【5】桶排序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/023161c2ac7a47a82823fd22ca99cfe6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b3419c52655e2a589c1f7624ae49b8e/" rel="bookmark">
			OSS文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、输入该网址 https://www.aliyun.com/ ，登录阿里云，没有登录过可以注册(可用支付宝直接扫码登录)
2、搜索OSS
3、点击对象存储OSS选项
4、开通对象存储OSS，进入管理控制台
5、创建Bucket(桶)(记录Bucket名称，后面会用到)
6、可按我这个模板选择，具体详情请参照官方文档
7、点击确定，创建成功
8、记录endpoint
9、点击AccessKey管理
10、创建AccessKey
11、记录keyid、keysecret
12、application.yml加入配置信息
server: port: 8010 spring: application: name: service-oss servlet: multipart: enabled: true max-file-size: 100MB max-request-size: 100MB aliyun: oss: file: endpoint: # 记录的endpoint keyid: # 记录的keyid keysecret: # 记录的keysecret bucketname: # 创建的bucket的名称 13、测试
controller：
@PostMapping("/fileoss") public Result uploadOssFile(MultipartFile file) { //获取上传文件 MultipartFile(图片，文件都可以) //返回上传到oss的路径 String url = ossService.uploadFileAvatar(file); return Result.succ(url); } service：
String uploadFileAvatar(MultipartFile file); serviceImpl：
@Override public String uploadFileAvatar(MultipartFile file) { String endpoint = ConstantPropertiesUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b3419c52655e2a589c1f7624ae49b8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fbd1b633243ae5b64b4ee066e4ac054/" rel="bookmark">
			webrtc-nat 穿越及相关协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 WebRTC nat 穿越及相关协议Nat 类型Full cone NAT（完全锥形NAT）Restricted Cone NAT（地址受限锥形NAT）Port Restricted Cone NAT（端口受限锥形NAT）Symetric NAT（对称NAT） Session Traversal Utilities for NAT (STUN)-NAT会话遍历工具协议文档 RFC 3489 和 RFC 5389相关概念STUN Message HeaderSTUN MethodsBinding Request(0x0001): UDP 传输Shared Secret Request(0x0002): (Reserved; was SharedSecret): TCP 的 TLS 传输 STUN AttributesMAPPED-ADDRESS(0x0001)USERNAME(0x0006)MESSAGE-INTEGRITY(0x0008)ERROR-CODE(0x0009)UNKNOWN-ATTRIBUTES(0x000A)REALM(0x0014)Nonce(0x0015)XOR-MAPPED-ADDRESS(0x0020)SOFTWARE attribute(0x8022)FINGERPRINT(0x8028) Traversal Using Relays around NAT (TURN)协议文档 RFC 5766Relay Extensions to Session Traversal Utilities for NAT (STUN)相关概念Transports：传输方式Allocations:client 请求 server 分配中继地址exchange application data：数据交换Send Mechanism: Send and Data methodsChannels New STUN Methods0x0003 : Allocate (only request/response semantics defined)0x0004 : Refresh (only request/response semantics defined)0x0006 : Send (only indication semantics defined): 将数据从 client 传递 server0x0007 : Data (only indication semantics defined): 将数据从 server 传递 client0x0008 : CreatePermission (only request/response semantics defined0x0009 : ChannelBind (only request/response semantics defined) New STUN AttributesCHANNEL-NUMBER(0x000C)LIFETIME(0x000D)XOR-PEER-ADDRESS(0x0012)DATA(0x0013)XOR-RELAYED-ADDRESS(0x0016)EVEN-PORT(0x0018)：偶数端口REQUESTED-TRANSPORT(0x0019)DONT-FRAGMENT(0x001A)RESERVATION-TOKEN(0x0022) New STUN Error Response Codes Interactive Connectivity Establishment (ICE)协议文档 RFC 5245A Protocol for Network Address Translator (NAT) Traversal for相关概念Controlling Agent：控制方Controlled Agent：被控制方 Gathering Candidate Addresses：收集候选者Sending the Initial Offerfull implementationslite implementationsEncoding the SDP STUN Extensions:four new attributesPRIORITY(0x0024)USECANDIDATE(0x0025)ICE-CONTROLLED(64 位网络字节序无符号整)ICE-CONTROLLING(64 位网络字节序无符号整数) STUN Extensions:New Error Response Codes: 487 (Role Conflict) b 站抓包分析Binding Request to STUN ServerBinding success respose from STUN ServerBinding Request to a PeerBinding Request from a PeerBinding success respose from a ClientBinding success respose from a Peer mediasoup webrtc stun 源码分析接收 stunData解析 stunData：获取 attributeICE Server 处理 参考文献 WebRTC nat 穿越及相关协议 Nat 类型 Full cone NAT（完全锥形NAT） 所有从同一个内网的（IP，端口）发送出来的请求都会被映射到同一个外网（IP，端口），且任何一个外网主机都可以通过访问映射后的公网地址，实现访问位于内网的主机设备功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fbd1b633243ae5b64b4ee066e4ac054/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a55cc70df83357764f59acbe3539a62/" rel="bookmark">
			窗口函数OVER(PARTITION BY)详细用法——语法&#43;函数&#43;开窗范围ROWS和RANGE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、函数写法
二、开窗的窗口范围ROWS与RANGE
1.范围限定用法
2.ROWS和RANGE的区别
(1) ROWS按行数限定
(2) RANGE按数据范围限定
order by 数字
例1 汇总数据范围为：[当前行值,当前行值+3]
例2 汇总数据范围为：[当前行值-3,当前行值]
order by 时间
例1 [当前行日期,当前行日期+2]
例2 [当前行日期-2,当前行日期]
三、函数介绍
1.排序函数
2.聚合函数
3.比较函数
例1 lag 偏移为负数offset=-1
例2 lag取出向前第0行，即偏移为0
例3 lag取出向前第2行，即偏移为2
例4 换个字段，lag取出向前第2行，即向前偏移为2
例5 lead取出向后第2行，即向后偏移2
例6 lead取出向后第2行，即向后偏移2，不加默认值
一、函数写法 函数名(参数) OVER (PARTITION BY子句 ORDER BY子句 ROWS/RANGE子句)
由三部分组成：
函数名：如sum、max、min、count、avg等聚合函数以及lead、lag行比较函数等；
over： 关键字，表示前面的函数是分析函数，不是普通的集合函数；
分组子句：over关键字后面挂号内的内容；
分析子句又由下面三部分组成：
PARTITION BY ：分组子句，表示分析函数的计算范围，不同的组互不相干；
ORDER BY： 排序子句，表示分组后，组内的排序方式；
ROWS/RANGE：窗口子句，是在分组(PARTITION BY)后，组内的子分组（也称窗口），此时分析函数的计算范围窗口，而不是PARTITON。窗口有两种，ROWS和RANGE；
二、开窗的窗口范围ROWS与RANGE 1.范围限定用法 CURRENT ROW: 当前行UNBOUNDED：不受控制的，无限的UNBOUNDED PRECEDING: 区间的第一行UNBOUNDED FOLLOWING：区间的最后一行UNBOUNDED PRECEDING AND UNBOUNED FOLLOWING：针对当前所有记录的前一条、后一条记录，分组中的所有记录PRECEDING：在.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a55cc70df83357764f59acbe3539a62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6b849df1c40c20369588ea82b22a227/" rel="bookmark">
			2023计算机四非保研（复试：东北大学，成电，西电，浙软，中海洋，天大）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 个人情况夏令营情况预推免情况进入复试中国海洋大学（学硕）浙大软院（专硕）天津大学智算（专硕）中科院网络中心（专硕）西电网安院（学硕）东北大学计算机（学硕）成电计算机（专硕） 最终offer 感想 个人情况 本科学校：西北某四非
绩点排名：2/124
四级：453 六级：未过
奖项：蓝桥杯国二，一个水赛国二，数学建模省特，其他省级奖项3,4个，参与过一个校级大创
论文：在投CCF中文B类论文二作（导师一作）
夏令营情况 因为前五学期第3，我们专业保3个，所以最后一学期有门课差点考砸了就没信心了，就没怎么报夏令营，后来发现今年夏令营的bar巨高，报了估计也没几个能入。
入营情况：
主要投了一些末流985，结果夏0营。
PS： 西电今年没有夏令营
预推免情况 进入复试 中国海洋大学（学硕） 不知道什么bar，双非rank1没进复试，我反而进了，211的初始也被筛了，不太懂这个bar。最后时间冲突再加上不想去北方，放弃了复试。
浙大软院（专硕） 今年浙大软院卡rank，学校反而不怎么卡，入营了1000左右，参加机试了800人左右，机试有4道题，中文题面，第一题的关键是gcd，第二题考数学，第三题暴力dfs，注意边界就能过，第四题考了分数拆分。因为数学体面较多，我是数学菜菜，最后排名400+。这里需要说一下，浙大的机试成绩虽然只占15%，但是面试成绩会参考机试成绩，所以机试考的高的话就比较稳。这次招两个方向，软件工程招180人，ai招30人，结果软件工程坚持到面试的人大概360，ai坚持到面试的人280个人，我选错赛道，选了ai，放弃面试。（据说软件递补到了100+，基本上坚持到最后的都能上，等等党赢麻了，不过学费8w真贵，据说延毕率1/3）
天津大学智算（专硕） 去年天大智算超发offer，今年名声太臭了，还弄了一个机试，入复试以后发现应该报未来技术学院，那个鸽双非不严重，鉴于去年发offer以后仍鸽双非，最后没参加智算面试。双非可以考虑未来技术学院，那个bar略低。（风水轮流转，今年天大智算被鸽穿了）
中科院网络中心（专硕） 京四所之一，虽然入复试了，但是看了往年录取名单，发现招30人，还有清北佬，不喜欢研究所再加上和其他学校面试冲突了，放弃面试。
西电网安院（学硕） 典型弱com，导师的权力特别大，联系完老师以后基本上就稳了。我联系完老师以后说有个导师团面试，然后稍微聊了聊，没有很严肃的面试，导师同意以后院面就是走个形式。
东北大学计算机（学硕） 东大和成电是同一天面试，中午才临时做的自我介绍ppt，属实极限了。面试是3分钟的ppt，5分钟的英语+专业面。老师比较和蔼，整体面试的氛围轻松，介绍完ppt以后，让我选一个我最熟悉的项目进行介绍，我选择的论文。最后可能老师对我的论文很感兴趣，用英文问我怎么看待联邦学习？我大概两句话说了联邦学习的定义和要解决的问题，实在是不会用英语说，最后老师还让我不要紧张，慢慢想。最后面试89分，总分排名58名，出乎我的意料，算很高的分数了。
成电计算机（专硕） 成电也是弱com，但是据说以前导师权力太大被举报了（？？？，离谱），所以搞了一个推荐信，要拿到推荐信才能进入复试。复试是280进207，感觉希望还是挺大，面试的话和浙软的面试一样，非常正规的双机位。先是3分钟英文自我介绍，然后问了三个英语问题。第一个问题没听懂，我就按照为什么要选择成电回答了，第二个问题问我什么是深度学习（我的英文问题怎么都这么难），随便答了两句，没怎么准备过，第三个问题问我未来计划。然后就是抽一道数据结构题作答，我的比较简单，是关于链表的一道题。然后就是狂问简历，对着简历一顿输出，问的巨细，甚至问到了我论文中数据集样本的收集方式等等的。最后在专硕中排名11，有些后悔，这个分可以上学硕的。（整体面试给人的压力较大，再加上8分钟的英语，全称都很紧张）
最终offer 成电计算机专硕
东大计算机学硕
西电网安学硕
最终去向： 成电计算机专硕
感想 按照这个趋势，保研过程中的互鸽现象越来越严重，今年中九基本上都穿了，等等党赢麻了。再放几张名场面的图。
感觉对于保研生来说，最好的选择就是拿一个保底，然后再弄一些wl，感觉今年wl基本上都递补到了，入wl即胜利。另外，保研的暑假一定不要完全放开了玩，把408，数据库，编译原理都看一下，一旦拿到本校名额就放松的话，后面的面试会有些尴尬。
最后还有一个计算机的评级图。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41cf8cccf6c983b988190b57472ed003/" rel="bookmark">
			python 循环多个列表出现 for i,i2 in res,res_jg: ValueError: too many values to unpack (expected 2)的错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 我们通过for循环对两个列表进行循环出现ValueError: too many values to unpack (expected 2)的错误
错误提示：
ValueError: too many values to unpack (expected 2) 问题描述 for i,i2 in res,res_jg: print("标题："+i,"价格:",i2) 这个是我们在项目的代码运行以后出现以下的代码：
原因分析： 具体报错的原因不详
解决方案： 将我们原来的代码修改如下：
for i,i2 in zip(res,res_jg): print("标题："+i,"价格:",i2) 修改后的运行结果：
就可以解决ValueError: too many values to unpack (expected 2)的错误
记录报错的解决方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a513a8acf171bd7065afb1175e2cb00d/" rel="bookmark">
			AWK用法全解与sed去掉sql最后一个字段哪一行的逗号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AWK用法全解 一、awk介绍 awk是Linux自带的一个逐行扫描的文本处理工具，支持正则表达式、循环控制、条件判断、格式化输出。AWK自身带有一些变量，可以在书写脚本时调用。
awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时,显得尤为强大简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理, 因为切开的部分使用awk可以定义变量,运算符, 使用流程控制语句进行深度加工与分析。
创始人 Alfred V. Aho、Peter J. Weinberger和Brian W. Kernighan awk由来是姓氏的首字母.
基本语法格式：
awk [options] ‘pattern{action}’ {filenames}
pattern：表示AWK在数据中查找的内容，就是匹配模式
action：在找到匹配内容时所执行的一系列命令
二、基本语法格式 2.1、在shell中使用awk awk [option] 代码块 文件名
option的选项及含义 选项含义使用演示演示说明-F指定文件分隔符awk -F “\n”按 \n 做分隔符-f使用文件中的内容作为命令输入awk -f script.txt使用 script.txt 文件中的内容作为命令-v给变量赋值，支持多个v赋值awk -v Num=num −v Num1=num −v Num1=num1把num的值给Num、num1的值给Num1 awk内置变量 内置变量含义ARGC命令行参数个数ARGV命令行参数排列ENVIRON支持队列中系统环境变量的使用FILENAMEawk浏览的文件名FNR浏览文件的记录数 (行数)FS设置输入域分隔符，等价于命令行 -F选项NF浏览记录的域的个数, 根据分隔符分割后的列数NR已读的记录数, 也是行号OFS输出域分隔符ORS输出记录分隔符RS控制记录分隔符$n$0 变量是指整条记录。 $1 表示当前行的第一个域, $2 表示当前行的第二个域,…
以此类推。$NF$NF是number finally,表示最后一列的信息，跟变量NF是有区别的，变量NF统计
的是每行列的总数 数据准备 cp /etc/passwd ./ 示例 : 默认每行空格切割数据 命令
echo "abc 123 456"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a513a8acf171bd7065afb1175e2cb00d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c863f3911af8848959e363fa1d0664d/" rel="bookmark">
			JAVA基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、面向对象的特征有哪些方面 1.抽象：
抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。
2.继承：
继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。
3.封装：
封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。
4. 多态性：
多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。
2、String是最基本的数据类型吗?
基本数据类型包括byte、int、char、long、float、double、boolean和short。
java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类
3、int 和 Integer 有什么区别
Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。
原始类型封装类
booleanBoolean
charCharacter
byteByte
shortShort
intInteger
longLong
floatFloat
doubleDouble
引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关。
4、String 和StringBuffer的区别
JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。
5、运行时异常与一般异常有何异同？
异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。
6、说出Servlet的生命周期，并说出Servlet和CGI的区别。
Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。
与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。
7、说出ArrayList,Vector, LinkedList的存储性能和特性
ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。
8、EJB是基于哪些技术实现的？并说出SessionBean和EntityBean的区别，StatefulBean和StatelessBean的区别。
EJB包括Session Bean、Entity Bean、Message Driven Bean，基于JNDI、RMI、JAT等技术实现。
SessionBean在J2EE应用程序中被用来完成一些服务器端的业务操作，例如访问数据库、调用其他EJB组件。EntityBean被用来代表应用系统中用到的数据。
对于客户机，SessionBean是一种非持久性对象，它实现某些在服务器上运行的业务逻辑。
对于客户机，EntityBean是一种持久性对象，它代表一个存储在持久性存储器中的实体的对象视图，或是一个由现有企业应用程序实现的实体。
Session Bean 还可以再细分为 Stateful Session Bean 与 Stateless Session Bean ，这两种的 Session Bean都可以将系统逻辑放在 method之中执行，不同的是 Stateful Session Bean 可以记录呼叫者的状态，因此通常来说，一个使用者会有一个相对应的 Stateful Session Bean 的实体。Stateless Session Bean 虽然也是逻辑组件，但是他却不负责记录使用者状态，也就是说当使用者呼叫 Stateless Session Bean 的时候，EJB Container 并不会找寻特定的 Stateless Session Bean 的实体来执行这个 method。换言之，很可能数个使用者在执行某个 Stateless Session Bean 的 methods 时，会是同一个 Bean 的 Instance 在执行。从内存方面来看， Stateful Session Bean 与 Stateless Session Bean 比较， Stateful Session Bean 会消耗 J2EE Server 较多的内存，然而 Stateful Session Bean 的优势却在于他可以维持使用者的状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c863f3911af8848959e363fa1d0664d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c0c451acb3e59e441badf8b55502dfb/" rel="bookmark">
			JAVA基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、面向对象的特征有哪些方面
1.抽象：
抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。
2.继承：
继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。
3.封装：
封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。
4. 多态性：
多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。
2、String是最基本的数据类型吗?
基本数据类型包括byte、int、char、long、float、double、boolean和short。
java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类
3、int 和 Integer 有什么区别
Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。
原始类型封装类
booleanBoolean
charCharacter
byteByte
shortShort
intInteger
longLong
floatFloat
doubleDouble
引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关。
4、String 和StringBuffer的区别
JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。
5、运行时异常与一般异常有何异同？
异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。
6、说出Servlet的生命周期，并说出Servlet和CGI的区别。
Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。
与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。
7、说出ArrayList,Vector, LinkedList的存储性能和特性
ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。
8、EJB是基于哪些技术实现的？并说出SessionBean和EntityBean的区别，StatefulBean和StatelessBean的区别。
EJB包括Session Bean、Entity Bean、Message Driven Bean，基于JNDI、RMI、JAT等技术实现。
SessionBean在J2EE应用程序中被用来完成一些服务器端的业务操作，例如访问数据库、调用其他EJB组件。EntityBean被用来代表应用系统中用到的数据。
对于客户机，SessionBean是一种非持久性对象，它实现某些在服务器上运行的业务逻辑。
对于客户机，EntityBean是一种持久性对象，它代表一个存储在持久性存储器中的实体的对象视图，或是一个由现有企业应用程序实现的实体。
Session Bean 还可以再细分为 Stateful Session Bean 与 Stateless Session Bean ，这两种的 Session Bean都可以将系统逻辑放在 method之中执行，不同的是 Stateful Session Bean 可以记录呼叫者的状态，因此通常来说，一个使用者会有一个相对应的 Stateful Session Bean 的实体。Stateless Session Bean 虽然也是逻辑组件，但是他却不负责记录使用者状态，也就是说当使用者呼叫 Stateless Session Bean 的时候，EJB Container 并不会找寻特定的 Stateless Session Bean 的实体来执行这个 method。换言之，很可能数个使用者在执行某个 Stateless Session Bean 的 methods 时，会是同一个 Bean 的 Instance 在执行。从内存方面来看， Stateful Session Bean 与 Stateless Session Bean 比较， Stateful Session Bean 会消耗 J2EE Server 较多的内存，然而 Stateful Session Bean 的优势却在于他可以维持使用者的状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c0c451acb3e59e441badf8b55502dfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ef80be87fb074e33c191c44e469122d/" rel="bookmark">
			10-34 查询xscj表中的计算机成绩在80至90之间（包含80和90分）的同学的学号，姓名，计算机三项信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查询xscj表中的计算机成绩在80至90之间（包含80和90分）的同学的学号，姓名，计算机三项信息。
表结构: create table xscj ( 学号 varchar(3), 姓名 varchar(4), 计算机 float, 英语 float, 高数 float, 总分 float, 平均分 float ); 表样例 xscj表：
学号姓名计算机英语高数总分平均分001张三90909027090002李四80808024080003王五99999929799004赵六78787823478 输出样例: 学号姓名计算机001张三90002李四80 select 学号,姓名,计算机 from xscj where 计算机 between 80 and 90 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaa8a96d7159b37a3667d905d52c303d/" rel="bookmark">
			10-33 查询xscj表中的学号，姓名，计算机三项信息，结果按计算机成绩的降序排列。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查询xscj表中的学号，姓名，计算机三项信息，结果按计算机成绩的降序排列。
表结构: create table xscj ( 学号 varchar(3), 姓名 varchar(4), 计算机 float, 英语 float, 高数 float, 总分 float, 平均分 float ); 表样例 xscj表：
学号姓名计算机英语高数总分平均分001张三90909027090002李四80808024080003王五99999929799004赵六78787823478 输出样例: 学号姓名计算机003王五99001张三90002李四80004赵六78 select 学号,姓名,计算机 from xscj order by 计算机 desc 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a500ecae75e5bcf625edd87cc57a039/" rel="bookmark">
			c语言四舍五入保留小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c语言四舍五入保留小数 #include&lt;stdio.h&gt; int main() { double sum = 0.0; scanf("%lf",&amp;sum); sum = (sum*100+5)/100.0; printf("%.1lf\n",sum); return 0; } 精华在第7行， 举个例子吧，
eq：sum = 3.6589
sum = sum*100+5 = 370.89
sum/100 = 3.7089
printf（“%.1lf\n”,sum） // .1的意思是保留一位小数
这样结果就为3.7了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c930fae82be4bfe25cc44004e344791/" rel="bookmark">
			解决报错 java 程序包org.springframework.stereotype不存在
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错：java 程序包org.springframework.stereotype不存在 1. 问题描述 运行SpringMVC框架项目时，报错如下： Error:(3, 38) java: 程序包org.springframework.stereotype不存在 2. 解决方法 在网上试了很多方法，只有以下这个方法成功解决！记录一下：
选择报错的moudle，执行 mvn idea:idea
重新运行项目OK
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1829545a11d2c861c10e19e128eaa52/" rel="bookmark">
			NNDL 实验五 前馈神经网络（1）二分类任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pytorch实现
4.1 神经元 4.1.1 净活性值 使用pytorch计算一组输入的净活性值z
净活性值z经过一个非线性函数f(·)后，得到神经元的活性值a
使用pytorch计算一组输入的净活性值，代码参考paddle例题：
import paddle # 2个特征数为5的样本 X = paddle.rand(shape=[2, 5]) # 含有5个参数的权重向量 w = paddle.rand(shape=[5, 1]) # 偏置项 b = paddle.rand(shape=[1, 1]) # 使用'paddle.matmul'实现矩阵相乘 z = paddle.matmul(X, w) + b print("input X:", X) print("weight w:", w, "\nbias b:", b) print("output z:", z) 在飞桨中，可以使用nn.Linear完成输入张量的上述变换。
在pytorch中学习相应函数torch.nn.Linear(features_in, features_out, bias=False)。
实现上面的例子，完成代码，进一步深入研究torch.nn.Linear()的使用。
import torch # 2个特征数为5的样本 X = torch.rand(size=[2, 5]) # 含有5个参数的权重向量 w = torch.rand(size=[5, 1]) # 偏置项 b = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1829545a11d2c861c10e19e128eaa52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d62efdb2669ae73b696bdb7ba8b8767/" rel="bookmark">
			Flink1.16 发布新特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引用前线速看更快更稳更易用：Flink自适应批处理能力演进01 Adaptive Batch Scheduler自动设置作业并行度02 Speculative Execution 发现和缓解热点机器对作业的影响03 Hybrid Shuffle 提供资源利用率和数据传输率04 Dynamic Partition Pruning 过滤无用数据，提高处理效率 Flink 1.16 Preview: Hive SQL如何平迁到Flink SQL01 迁移的动机02 迁移的挑战03 如何迁移04 demo 基于log的通用增量 Checkpoint01 checkpoint 性能优化之路02 解析changelog03 一览State/Checkpoint优化04 总结 Flink CDC + Kafka加速业务实时化01 Flink CDC技术02 Flink+Kafka实时数据集成方案03 Demo：Flink+Kafka实现CDC数据的实时集成和实时分析 Flink Table Store典型应用场景01 介绍Flink Table Store02 应用场景03 Demo04 后续挑战 结语 引用 虽然flink1.16已经发布，但是小编在文章发布日查看了下官网，目前最新稳定版依然是flink1.15.2，生产要用最新版flink1.16的小伙伴，请慎重使用。
flink下载页
flink主页
Flink学习网
下面内容来源于Apache Flink Meetup 北京站，小编只是加以整理。
前线速看 统一API： 对比spark程序开发，flink一套应用开发即可重用在流批环境统一计算：适配多种数据源，可以在streaming warehouse整体概念下计算，一套计算引擎解决多种场景计算统一存储：table store不仅对flink提供存储能力，对spark外部计算引擎同样可以；同时flink也适配了各式的存储中间件 上图着重强调了中国团队对flink1.16的贡献。
sql gateway这个功能超级强大，支持多租户，协议插件化，兼容hive生态，以后flink流批作业都可以通过sql gateway提交到集群了。
上图是状态存储改进。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d62efdb2669ae73b696bdb7ba8b8767/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/986058f682632cfc1938c4f31ed0662f/" rel="bookmark">
			一文讲清楚Nginx location匹配优先级规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx 配置文件中的「server」模块下的子模块 「location」包含了一套与请求 URI 进行匹配的规则，以及「location」匹配成功后的处理逻辑，例如：返回服务器端的静态文件或者实现跳转等功能，可以实现 Nginx 的“动静分离”和“反向代理”等核心功能，所以正确理解「location」匹配规则是非常重要的。以下是Nginx官方文档和翻译文档对「location」模块的解释：
核心模块：Module ngx_http_core_module翻译内容：ngx_http_core_module 模块 一. 语法规则：
location [=|~|~*|^~] /uri/ { … } //红色方框里面的参数为可选项，括号里为指令集
假如 nginx 现在接受到一个 URL 请求：http://www.example.com/static/img/logo.jpg， 这里需要注意，URL从第一个单斜杠后的内容才是「URI」内容：/static/img/logo.jpg，那么location匹配的原理就是用截取的「URI」和location表达式进行匹配和定位，并执行location模块内部的指令集。
一个「location」表达式可以使用「前缀字符串」- prefix string, 或「正则表达式」- regular expression 来定义。
1. 「前缀字符串」：以 = （精确匹配）或 ^~ 修饰符开头或者不带任何修饰符的字符串
location = /static/img/logo.jpg {...} location ^~ /static/img/logo.jpg {...} location /static/img/logo.jpg {...} 2. 「正则表达式」：以“~*”(不区分大小写)，或者“~”(区分大小写)修饰符开头，例如：下面的正则表达式匹配的是以“gif|jpg|jpeg” 文件后缀名结尾的所有URI，\. 代表文件后缀名。
location ~* \.(gif|jpg|jpeg)$ {...} location ~ \.(gif|jpg|jpeg)$ {...} 二. 匹配规则
nginx 首先匹配以「前缀字符串」定义的location，找到匹配成功的最长的前缀字符串，并且记录下来，然后继续匹配「正则表达式」定义的location（按照配置文件里locaton块定义的顺序依次进行匹配）如果匹配成功，则终止匹配。如果「正则表达式」没有匹配成功，则采用之前记录的匹配成功的最长「前缀字符串」的location.如果匹配成功的最长「前缀字符串」含有“^~”修饰符，则终止匹配，即不再继续匹配「正则表达式」定义的location路径。如果location 含有“=”字符，并且与请求的URI精确匹配成功，则终止匹配。 三. 匹配实例
请求URL案例分析：http://www.example.com/static/img/logo.jpg
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/986058f682632cfc1938c4f31ed0662f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eb99992ebaa18e1aab704cfb16194bc/" rel="bookmark">
			UML——时序图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 时序图 按时间顺序显示对象交互的图。顺序图的交互关系表示为一张二维图。其中纵向是代表时间维度，时间向下延伸，按时间依次列出各个对象所发出和接收的消息。水平方向是代表对象的维度，排列着参与交互的各个独立的对象。
2. 构成元素 时序图主要由以下7种元素组成：
角色（actor）对象（object）生命线（LifeLines）消息（Message）控制焦点自关联消息组合片段 下面我将具体展开介绍每一种元素：
1. 角色
系统角色。可以是人或者其它系统和子系统，以一个小人图标表示。
2. 对象
对象位于时序图的顶部,以一个矩形表示。对象的命名方式一般有三种：
（1）对象名和类名。例如：华为手机:手机、loginServiceObject:LoginService；
（2）只显示类名，不显示对象，即为一个匿名类。例如：:手机、:LoginSservice。
（3）只显示对象名，不显示类名。例如：华为手机:、loginServiceObject:
3. 生命线
时序图中每个对象和底部中心都有一条垂直的虚线，这就是对象的生命线(对象的时间线)。以一条垂直的虚线表示。
4. 消息
表示对象之间发送的信息。消息分为三种类型：
（1）同步消息(Synchronous Message)：消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。以一条实线和实心箭头表示。
（2）异步消息(Asynchronous Message)：消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。以一条实线和大于号表示。
（3）返回消息(Return Message)：返回消息表示从过程调用返回。以小于号和虚线表示。
5. 控制焦点
控制焦点代表时序图中在对象时间线上某段时期执行的操作。以一个很窄的矩形表示。
6. 自关联消息
表示方法的自身调用或者一个对象内的一个方法调用另外一个方法。以一个半闭合的长方形+下方实心剪头表示。
7. 组合片段
组合片段用来解决交互执行的条件和方式，它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。组合片段共有13种，名称及含义如下：
组合名称组合含义ref引用其他地方定义的组合片段alt在一组行为中根据特定的条件选择某个交互opt表示一个可选的行为break提供了和编程语言中的break类拟的机制par支持交互片段的并发执行seq强迫交互按照特定的顺序执行strict明确定义了一组交互片段的执行顺序neg用来标志不应该发生的交互region标志在组合片段中先于其他交互片断发生的交互ignore明确定义了交互片段不应该响应的消息consider明确标志了应该被处理的消息assert标志了在交互片段中作为事件唯一的合法继续者的操作数loop说明交互片段会被重复执行 3. 画图推荐 processon
ProcessOn是一个在线作图工具的聚合平台，它可以在线画流程图、思维导图、UI原型图、UML、网络拓扑图、组织结构图等等，您无需担心下载和更新的问题，不管Mac还是Windows，一个浏览器就可以随时随地的发挥创意，规划工作。
4.应用场景 1. 梳理业务流程
软件开发都是为了支撑某个具体的业务。有时候业务的流程会比较复杂，涉及到多种角色，这时就可以使用时序图来梳理这个业务逻辑。这样会使业务看起来非常清晰，代码写起来也是水到渠成的事情了。
2. 梳理开源软件
成熟框架的源代码调用深度都比较深，类之间的调用关系也比较复杂，此时便可以用时序图来梳理框架中这些对象之间的关系。如下图为Tomcat启动流程，通过梳理各个组件之间的关系，更便于记忆。
参考 组合片段https://www.cnblogs.com/54chensongxia/p/13236965.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae8fb49ca33022b2424fa3b4df29473d/" rel="bookmark">
			数据库优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库优化 为什么进行数据库优化呢？ 如今我们的数据量都很大，表的字段也越来越多，如果数据库不进行优化，改变查询速度，查询会很慢，用户进行访问的时候会很影响体验，所以，数据库优化是必要的
数据库优化带来的好处 可以避免网站页面出现访问错误
就比如慢查询很多（产生原因：数据查询慢，表特别大或者是忘加索引）
数据库连接超时的情况（产生原因：数据库连接池满了）
减少很多数据库问题，很多问题都是低效的查询造成的
可以避免因阻塞造成数据无法提交（超时或阻塞）
优化方案 不确定字段长度的时候用varchar代替char 对于一个字段来说，不确定长度varchar更适合，char是定长，数据长度小于char给定的长度，造成浪费，varchar是变长字段，实际长度是数据的长度，节省储存空间，对于查询来说在一个较小的字段内搜索，效率更高。char很适合固定长度的字符串，从检索效率上来说，char &gt; varchar ,所以知道长度的话char较为适合，比如MD5
避免在where子句中使用or来连接条件 如图可看出使用or会导致索引失效，如果条件中有or，只要一个条件没有索引，其他字段有索引也不会使用
用or的情况下
不用索引，进行一次全表扫描就可以了
使用索引，一个走索引，一个不走，结果就是全表扫描+索引扫描+合并，
这样一比较，mysql优化器肯定选择不走索引，也就说明为啥其他字段有索引也不会使用
尽量使用数值替代字符串类型 原因：
1:因为引擎在处理查询和连接时会逐个比较字符串中每一个字符；
2:而对于数字型而言只需要比较一次就够了；
3:字符会降低查询和连接的性能，并会增加存储开销
查询尽量避免返回大量数据 如果查询返回数据量很大，就会造成查询时间过长，网络传输时间过长。
使用explain分析你SQL执行计划 SQL很灵活，一个需求可以很多实现，那哪个最优呢？SQL提供了explain关键字，它可以分析你的SQL执行计划，看它是否最佳。Explain主要看SQL是否使用了索引
EXPLAIN SELECT * FROM student WHERE id = 1 type：
ALL 全表扫描，没有优化，最慢的方式
index 索引全扫描
range 索引范围扫描，常用语&lt;，&lt;=，&gt;=，between等操作
ref 使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中
eq_ref 类似ref，区别在于使用的是唯一索引，使用主键的关联查询
const 当查询是对主键或者唯一键进行精确查询，系统会把匹配行中的其他列作为常数处理
null MySQL不访问任何表或索引，直接返回结果
System 表只有一条记录(实际中基本不存在这个情况)
性能排行：
System &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae8fb49ca33022b2424fa3b4df29473d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fabde7dae91dbd32a7efcf79c20698a3/" rel="bookmark">
			使用adb命令将手机和至电脑上的文件互传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		条件：将手机用USB线连接电脑并选择开发者模式下的文件传输模式
打开cmd窗口 输入
adb devices （查看手机是否已经连接，成功连接会显示设备序列号） 一、电脑传手机 adb push 文件名 /sdcard/download 作用：表示将电脑上文件传到手机sdcard目录下download
二、手机传电脑 命令：adb pull语法：adb pull remote local 其中remote指手机上的文件路径，local指所传文件到电脑上的文件路径 adb pull /sdcard/hello.txt /Users/administrator/Desktop 作用：将手机的sdcard根目录下的hello.txt文件传输至电脑桌面路径下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc8edef58b8899a49cb978fdca2d9681/" rel="bookmark">
			uniapp 动态切换应用图标、名称插件（如新年、国庆等） Ba-ChangeIcon
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态切换应用图标、名称（如新年、国庆等） Ba-ChangeIcon 简介（下载地址） Ba-ChangeIcon 是一款uniapp动态切换应用图标、名称的插件。可实现过年、过节动态切换应用图标的效果，给用户更好的体验。
动态切换应用图标、名称默认支持5种样式配置（更多请联系作者）支持恢复原样式（图标、文字）支持获取当前样式 使用方法 引用 在 script 中引入组件
const changeIcon = uni.requireNativePlugin('Ba-ChangeIcon') 调用示例 在 script 中调用（示例参考，可根据自己业务和调用方法自行修改）
changeIcon() {//切换样式 changeIcon.changeIcon({ aliasSer: this.aliasSer//样式序号，0：原有样式，其他对应配置的样式顺序（1~5） }, (res) =&gt; { console.log(res); if (res.msg) { uni.showToast({ title: res.msg, icon: "none", duration: 3000 }) } }); }, getCurrentSer() {//获取当前样式 changeIcon.getCurrentSer( (res) =&gt; { console.log(res); if (res.currentSer) { this.aliasSer = res.currentSer; } if (res.msg) { uni.showToast({ title: res.msg, icon: "none", duration: 3000 }) } }); }, 应用图标、名称配置 注意：配置更改后，需要重新制作基座才生效，建议提前配置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc8edef58b8899a49cb978fdca2d9681/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62f2b09e75518b2cef6a2dfa79af9dcd/" rel="bookmark">
			一篇搞定vuex（主要看代码&#43;总结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：vuex是什么 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库，
二：vuex什么时候用 我们有一个数据，很多个组件需要用到它，这个时候就用vuex来对它进行管理，此时只需要调用vuex中存储的数据，不需要在每一个组件中编写。
三：vuex的使用 1.不分模块
@/store/index.js
import { createStore } from 'vuex' export default createStore({ // 全局状态初始值 state: { count: 1 }, // 计算state，获取对应的值 getters: { countStatus(state) { return state.count &lt;= 1 } }, // 更新状态的方法,更新state的唯一方法.提交方法：（store.commit(方法名，参数)，触发mutations来修改state） mutations: { setcount(state, num) { state.count = num } }, // 可以异步操作，可以返回promise，更改数据要传递到mutations中去更改 actions: { // content: setcountPromise(content, num) { return new Promise((resolve, reject) =&gt; { if (num &gt; 100) { reject(alert('值不能大于100')) } else { content.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62f2b09e75518b2cef6a2dfa79af9dcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f627c6acbdedf1e7afffb5e94ec2cb24/" rel="bookmark">
			Java 对象的内存布局（HotSpot 实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 对象的内存布局（HotSpot 实现） 作者：Grey
原文地址：
博客园：Java 对象的内存布局（HotSpot 实现）
CSDN：Java 对象的内存布局（HotSpot 实现）
我们可以通过 jol 来查看一下某个对象的内存布局
引入依赖
&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.16&lt;/version&gt; &lt;/dependency&gt; 示例代码如下
import org.openjdk.jol.info.ClassLayout; /** * 对象的内存布局 * @author &lt;a href="mailto:410486047@qq.com"&gt;Grey&lt;/a&gt; * @since */ // 配置VM参数 -XX:+UseCompressedClassPointers public class ObjectModel { public static void main(String[] args) { System.out.println("======T1======="); T1 o = new T1(); String s = ClassLayout.parseInstance(o).toPrintable(); System.out.println(s); System.out.println("======T1======="); System.out.println("======T2======="); T2 o1 = new T2(); String s1 = ClassLayout.parseInstance(o1).toPrintable(); System.out.println(s1); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f627c6acbdedf1e7afffb5e94ec2cb24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb5b325547f87377e4bfd3eb741dae55/" rel="bookmark">
			【Unity】Cursor类——隐藏鼠标、锁定鼠标、设置鼠标图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.隐藏鼠标 using System.Collections; using System.Collections.Generic; using UnityEngine; public class Lesson2 : MonoBehaviour { void Start() { //true：显示 //false：隐藏 Cursor.visible = false; } } 2.锁定鼠标 using System.Collections; using System.Collections.Generic; using UnityEngine;、 public class Lesson2 : MonoBehaviour { void Start() { //None：不锁定 解除锁定 //Locked：锁定，鼠标会被锁定在屏幕的中心点（并且会被隐藏） //Confined：将鼠标限制在窗口范围内 Cursor.lockState = CursorLockMode.Locked; } } 3.设置鼠标图片 把导入的光标图片资源设置成Cursor类型
注意：想要图片不变形，要使用宽高一样的图片
using System.Collections; using System.Collections.Generic; using UnityEngine; public class Lesson2 : MonoBehaviour { //外部拖拽光标图片 public Texture2D tex; void Start() { //参数1 光标图片 外部拖拽的 //参数2 偏移位置 相对图片左上角 //参数3 平台支持的光标模式（硬件或软件）一般用Auto自动模式即可 Cursor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb5b325547f87377e4bfd3eb741dae55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f36ecbbc29073bd11e3a7cb55c3714c/" rel="bookmark">
			记一次程序包android.support.v7.app不存在的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在下载了网上的工程okhttp-utils后，导入到自己的工程中尝试构建的时候报了一个异常：android.support.v7.app不存在的解决。又是一个很奇怪的异常，明明依赖中有导入依赖，可是却报了包找不到的问题。
implementation 'com.android.support:appcompat-v7:22.2.1' 最终在网上找到了解决办法。内容如下：
通过自己碰到这个问题，然后在网上不断寻找解决办法的过程中，发现不同的人都会有不一样的解决方法，下面是我总结的一些比较有用的：
方案1、首先先确认自己是否添加了 android.support.v7.app 的依赖 无法导入这个包，
网上给出的方法都是到Dependencies 中引入包，操作如下：
然后点击ok,但是还是没有什么卵用，依然是原来的样子
但是换成下面的样子就可以了：
方案2、gradle.properties中注释掉启用androidX的代码 新版的Android Studio在创建一个新的项目的时候，会比之前的项目中多配置这2个选项，大概意思是用新的AndroidX这个东西，这就导致老版本的程序包被忽略掉了，所以在使用代码中的import语句会出现如题错误。
删掉那两句就完事了。 方案3、迁移到androidX 如果大家在看完第二篇文章还是没有解决自己的办法的时候，我们可以通过refactor-&gt;migrate to androidX的方法来解决问题，我就是通过这种方法解决的哈哈哈！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e150cd2d5342e52944a5cbb65bef6dd/" rel="bookmark">
			猎人猎物优化算法HPO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原论文解读在这里
代码转自这里
import numpy as np from tqdm import tqdm # 进度条设置 import random from matplotlib import rcParams import math import matplotlib; matplotlib.use('TkAgg') from pylab import * mpl.rcParams['font.sans-serif'] = ['SimHei'] # 指定默认字体 mpl.rcParams['axes.unicode_minus'] = False # 解决保存图像是负号'-'显示为方块的问题 config = { "font.family": 'serif', "mathtext.fontset": 'stix', "font.serif": ['SimSun'], } rcParams.update(config) class HPO(object): def __init__(self, m, T, lb, ub, R, C): self.M= m # 种群个数 self.T = T # 迭代次数 self.lb = lb self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e150cd2d5342e52944a5cbb65bef6dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d5006f27192a953617490dafe5cdb23/" rel="bookmark">
			微信小程序安全区域适配问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述 在微信小程序开发过程中，有些页面的按钮是需要固定在页面底部（如电商详情页中的加入购物车按钮等），如果将底部栏样式直接设置为bottom：0;，那么在iPhone X、iPhone XR、iPhone 12等机型中，就会出现下图所示问题：按钮区域距离底部太近，可点击区域缩小，用户体验感差。
问题复现 解决方案 方案一（最快速） 利用IOS新增的 env() 和 constant() 特性即可解决，开发者不需要自己动态计算高度，只需将如下CSS代码添加至样式中：
示例代码：
&lt;!-- 底部栏 --&gt; &lt;view class="bottom"&gt;&lt;/view&gt; .bottom { position: fixed; bottom: 0; padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom); } 方案二（动态计算） &lt;!-- 底部栏 --&gt; &lt;view class="bottom" style="padding-bottom:{{bottomPadding}}px"&gt;&lt;/view&gt; async onLoad() { const res = await wx.getSystemInfo({}) const bottomPadding = res.screenHeight - res.safeArea.bottom this.setData({ bottomPadding }) } .bottom { position: fixed; bottom: 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2944b224f18846b3a5e59b1caa037b15/" rel="bookmark">
			学院网站分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学院功能： 每日一练 网站第一观感：推荐的内容并不是我感兴趣的点，可能我都不会，或者我对这个方向完全没有兴趣。这部分的推荐是否具有针对性，还是说不管谁进来都是这些内容呢？而且看这个题目不知道去哪里练习。
点进来题目后才发现这是一个编程题目，但是根据题目名称完全不知道里面居然是这样的一个测试题。但是认真想过之后发现这个题目还是可以的。但是跟题目又有什么关系呢？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/672031b8f50a40e43fb5af5610c78152/" rel="bookmark">
			java两个Integer相除求百分比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 java两个Integer相除求百分比并保留两位小数 /** * @Description java两个Integer相除求百分比 * @Author LuoAC * @Date 2022/9/14 16:53 */ public static Float getDivisionTwoNumbers(Integer a , Integer b){ if (b.equals(0)){ return 0F; } float v = a.floatValue() / b.floatValue()*100; //格式化小数 float v1 = (float) (Math.round(v * 100)) / 100; return v1; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0b1175396436d25ebaa90c73986794a/" rel="bookmark">
			springboot上传下载相关文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建文件工具类上传文件导出文件相关注意点 创建文件工具类 @Log4j2 public class FileUtil { /** * 读取文件内容输出str * @param file file * @return String */ public static String convertFile(MultipartFile file){ try { FileInputStream fis = (FileInputStream) file.getInputStream(); byte[] buffer = new byte[100]; StringBuilder sb = new StringBuilder(); while (fis.read(buffer) != -1) { sb.append(new String(buffer)); buffer = new byte[100]; } fis.close(); //可能存在文件转str后,出现部分定义NUL的数据 故进行转义 return sb.toString().replaceAll("\\\00",""); }catch (Exception ex){ log.error(ex.getMessage(),ex); } return null; } /** * 基础校验文件内容 * @param file file * @return xxx */ public xxx checkFileData(MultipartFile file) { //文件为空 if (file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0b1175396436d25ebaa90c73986794a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eb8564a2dadaf6125a92e6a4be62824/" rel="bookmark">
			matlab图像类型的转换九种
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在对图像进行处理时，很多时候对图像的类型有特殊的要求，例如，在对索引图像进行滤波时，必须把它转换为RGB图像，否则光对图像的下标进行滤波，得到的是毫无意义的结果。在MATLAB中，提供了许多图像类型转换的函数，从这些函数的名称就可以看出它们的功能。以下九个函数分别是：
1.dither函数
2.gray2ing函数
3.grayslice函数
4.im2bw函数
5.ind2gray函数
6.ind2rgb函数
7.mat2gray函数
8.rgb2gray函数
9.rgb2ind函数
1.dither函数 用dither函数可实现对图像的抖动。该函数通过颜色抖动（颜色抖动即改变边沿像素的颜色，使像素周围的颜色近似于原始图像的颜色，从而以空间分辨率来换取颜色分辨率）来增强输出图像的颜色分辨率。该函数可以把RGB图像转换成索引图像或把灰度图像转换成二值图像。
%%将RGB图像抖动成索引图像 clc;%clc的作用就是清屏幕 clear;%clear是删除所有的变量 close all;%close all是将所有打开的图片关掉。 I=imread('E:\我的桌面\MATLAB\练习\2.jpg');%绝对路径的 map=pink(512); X=dither(I, map); %将RGB图像抖动成索引图像 subplot(1,2,1), imshow(I); subplot(1,2,2), imshow(X, map); %%利用dither函数将灰度图像抖动成二值图像 clc;%clc的作用就是清屏幕 clear;%clear是删除所有的变量 close all;%close all是将所有打开的图片关掉。 H=imread('E:\我的桌面\MATLAB\练习\2.jpg');%绝对路径的 I = rgb2gray(H) BW=dither(I); %将灰度图像抖动成二值图像 subplot(1,2,1), imshow(I); subplot(1,2,2), imshow(BW); 2.gray2ing函数 gray2ind函数用于灰度图像或二值图像向索引图像的转换。该函数的调用方法如下。[X, map]= gray2ind(I, n)：表示按照指定的灰度级n把灰度图像I转换成索引图像X,map为gray (n), n的缺省值为64。
%%利用gray2ind函数将灰度图像转换成索引图像 clc;%clc的作用就是清屏幕 clear;%clear是删除所有的变量 close all;%close all是将所有打开的图片关掉。 H=imread('E:\我的桌面\MATLAB\练习\2.jpg');%绝对路径的 I = rgb2gray(H); [X, map]=gray2ind(I,32); %将灰度图像转换成索引图像 subplot(1,2,1), imshow(I); subplot(1,2,2), imshow(X, map); 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8eb8564a2dadaf6125a92e6a4be62824/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abc579aa850d1bbd48fde49546462fdb/" rel="bookmark">
			python3.9.7报错“no Module named quaternion”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述：
尝试使用quaternion官网推荐的conda install -c conda-forge quaternion、python -m pip install --upgrade --force-reinstall numpy-quaternion 、python -m pip install --user numpy-quaternion命令安装quaternion库，能够成功安装，并且在site-packages可见。
但是，执行import quaternion时，依旧会报错“no Module named quaternion”.同期还会报numpy has no attribute 'alen'。
几经尝试怀疑quaternion和numpy版本不兼容。于是卸载再重装：
问题解决：
conda remove numpy # 因为使用`conda uninstall numpy`没有卸载干净 pip uninstall quaternion # install python -m pip install --upgrade --no-deps --force-reinstall numpy-quaternion pip install numpy==1.20.3 # 原本的1.23.3没有alen属性 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc7f9dff20784204e00a270252bdcef3/" rel="bookmark">
			Windows server 2019 镜像 中文与英文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		英文
链接：https://pan.baidu.com/s/1s_W2AdQY25vtJ_t0j9u8KQ?pwd=enzy 提取码：enzy --来自百度网盘超级会员V4的分享
中文
链接：https://pan.baidu.com/s/1XqY1zAffEYqmEDB97HdT6g?pwd=enzy 提取码：enzy --来自百度网盘超级会员V4的分享
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f565daf5e393c3cfc83304e109390cbd/" rel="bookmark">
			CANNOT LINK EXECUTABLE问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若希望能够在手机等其他安卓设备跑可执行文件，有时候会出现如下类似的错误提示：
CANNOT LINK EXECUTABLE "./android_test": library "libtensorflowlite_c.so" not found
**现象**：如上述问题出现，即可执行文件android_test，找不到libtensorflowlite_c.so的这个库，所以跑不了，但是libtensorflowlite_c.so 又明明在 设备内，但就是找不了 。
**原因**：系统的库的路径是默认好的，如果自己的库不在默认的路径的库下，就不能够找到，如部分手机的库默认是在/vendor/lib/ 里面的，但是你的库是无法放在里面的，因为权限的问题。
**方法**：在加一个路径就可以了，如下：
# export LD_LIBRARY_PATH=/data/local/tmp/test/lib:$LD_LIBRARY_PATH
意思是，我把libtensorflowlite_c.so 放在/data/local/tmp/test/lib 里面，这样export LD_LIBRARY_PATH后，系统就会在这个路径找到库了。
注意：adb 断开后，这个添加路径的设定就会取消，每次adb 成功后，都需要手动添加库路径，即
export LD_LIBRARY_PATH=/data/local/tmp/test/lib:$LD_LIBRARY_PATH
另外，对于大部分手机，在data/local/tmp/ 路径下，创造文件的话是可以读写的，建议可执行文件可放在这里测试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b26cf4d193d9d2c25e161561c8ac008/" rel="bookmark">
			红外图像、灰度图像、深度图像对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、红外图与灰度图对比： 红外图象 是获取物体红外光的强度，而成的图象灰度图象 是获取物体可见光的强度对于数据格式，是一样的，都是单通道图象而彩色的是3通道图象一般红外探测器送出来的是16位的单通道图像,因为要送显才被转化成8位单通道,如果说是24位的话其实相当于R=G=B各8位。红外图像成像特点：由于红外图像是通过“测量”物体向外辐射的热量而获得的，故与可将光图像相比：分辨率差、对比度低、信噪比低、视觉效果模糊、灰度分布与目标反射特征无线性关系。红外图像和灰度图像本身就不是在同一分类标准下得到的概念。红外图像是红外成像设备采集目标在红外波段的辐射形成的影像，这个图像可以是灰度图像，也可以彩色图像。同样的道理，可见光图像可以是灰度图像，也可以彩色图像。灰度图像是相对彩色图像而言的。灰度图像没有颜色，灰度值由0变化至255时，图像由黑变白。 ————————————————版权声明：本文为CSDN博主「深度菜鸡-达闻西」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_37405118/article/details/106782076 2、深度图与点云图、结构光图对比 1.深度图像也叫距离影像，是指将从图像采集器到场景中各点的距离（深度）值作为像素值的图像。获取方法有：激光雷达深度成像法、计算机立体视觉成像、坐标测量机法、莫尔条纹法、结构光法。
2.点云：当一束激光照射到物体表面时，所反射的激光会携带方位、距离等信息。若将激光束按照某种轨迹进行扫描，便会边扫描边记录到反射的激光点信息，由于扫描极为精细，则能够得到大量的激光点，因而就可形成激光点云。点云格式有*.las ;*.pcd; *.txt等。
深度图像经过坐标转换可以计算为点云数据；有规则及必要信息的点云数据可以反算为深度图像。
3、TOF是通过红外光发射器发射调制后的红外光脉冲，不停地打在物体表面，经反射后被接收器接收，通过相位的变化来计算时间差，进而结合光速计算出物体深度信息。不怎么受环境光干扰，缺点是分辨率暂时都做不高。
4、结构光是通过红外光发射器发射一束编码后的光斑到物体表面，光斑打在物体表面后，由于物体的形状、深度不同，光斑位置不同，通过光斑的编码信息与成像信息，进而计算出物体深度信息。结构光在室外效果很差，光斑成像容易受环境光干扰。
————————————————
版权声明：本文为CSDN博主「hi我是大嘴巴」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_38740463/article/details/107921318
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be71122bb91724414d6572d974125678/" rel="bookmark">
			Kubernetes学习笔记之Node节点篇(四)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Node概念 节点是Kubernetes集群中的工作机器，它们是工作单元，可以是物理机、虚拟机、或云服务器实例。
Kubernetes通过将容器放入在节点(Node)上运行的Pod中来执行工作负载。每个节点上都包含运行Pod所需的所有服务及配置。
2.Node管理 Node本质上不是由Kubernetes集群来创建的，Kubernetes只是管理Node上的资源(如Pod、Deployment)。
2.1.添加节点的方式： 2.1.1节点上的kubelet向控制面执行自动注册；
2.1.2.只用资源清单方式创建一个Node对象(该Node对象需满足运行Pod的所有要求)。
# 示例 { "kind": "Node", "apiVersion": "v1", "metadata": { "name": "192.168.1.10", # 节点的IP地址 "labels": { "name": "k8s-node01" } } } 使用资源清单方式创建Node资源对象时，kubernetes会在内部创建一个Node对象作为节点的表示。kubernetes检查kubelet想API服务器注册节点时使用的
metadata.name字段是否匹配。如果节点时监控的，则该节点可以用来运行Pod，否则直到该节点变为健康之前，所有的集群活动都会忽略该节点。
2.2.节点名称唯一性 节点的名称用来标识Node对象。没有两个Node可以同时使用相同的名称。kubernetes还假定名字相同的资源是同一个对象。就Node而言，隐式假定使用相同名称的实例会具有相同的状态（例如网络配置、根磁盘内容） 和类似节点标签这类属性。这可能在节点被更改但其名称未变时导致系统状态不一致。 如果某个 Node 需要被替换或者大量变更，需要从 API 服务器移除现有的 Node 对象， 之后再在更新之后重新将其加入。
2.3.Node的扩缩容 2.3.1.扩容
在实际生产系统中当遇到集群节点容量不足的情况下，需要添加新节点(需具备Pod运行所需的所有服务)到集群中，对集群实现水平扩展从而达到扩容目的。
2.3.2.缩容
可以通过删除node节点来实现缩容目的,删除前需先将该节点上的所有pod驱逐并将节点设置为不可调度
kubectl delete node k8s-node1 2.4.Node常用操作 2.4.1将节点设置为不可调度
kubectl cordon k8s-node1 2.4.2将节点设置为可调度
kubectl uncordon k8s-node1 2.4.3驱逐节点上Pod
kubectl drain k8s-node1 2.4.4给节点打标签
kubectl label node k8s-node1 key1=value1 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be71122bb91724414d6572d974125678/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/844dc575dbed68e52ef672ab72ec5253/" rel="bookmark">
			sdn与openflow解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着计算机网络规模的不断扩大，互联网已经从早期的局部资源共享平台发展到今天覆盖全球的数据传输通信网络。
这使得互联网在社会基础设施中越来越重要，但其缺陷也越发明显，例如结构和功能日趋复杂、管控能力日趋减弱等。
解决这些问题的关键是亟需网络架构方面的创新，openflow技术概念最早由美国斯坦福大学的NickMcKeown教授提出，是斯坦福大学CleanSlate计划资助的一个开发式协议标准，其后成为GENI计划的子项目。Openflow将控制功能从网络设备中分离出来,在网络设备上维护流表(flowtable)结构，数据分组按照流表进行转发,而流表的生成、维护、配置则由中央控制器进行管理。Openflow的流表结构将网络处理层次扁平化，使得网络数据的处理满足精细处理要求。
你需要多少个SDN控制器?问的好，为此我们需要仔细考虑一些事情。软件定义网络控制器旨在解放流控制管理，意味着它能够用于让政策控制变得更为自动化。虽然不是每个SDN能胜任的设备(节点)都需要一个控制器，不过通过使用SDN控制器企业网络将在综合治理和可视性方面表现更好。
最佳实践是至少预留出一个多余的控制器，同时准备一个额外的备份控制器。就像你的企业网络中的其他控制器一样，无线、声音或是别的什么，备份可以说是一种常识。
探讨用多少SDN控制器合适这个话题，这得就不同的供应商产品来看。思科建议使用三个应用政策基础设施控制器(APIC)在一个集群中互相通信，以实施政策控制和网络管理。思科APIC能够控制一百万台设备上的东西。
对于部署了NSX的企业来说，VMware建议使用奇数的SDN控制器。当然，企业不太可能只需要一个控制器，所以至少就需要部署三个。
针对视频会议的云专线，基于vecloud的骨干网络，通过分布式部署视频会议节点，搭建高清实时交互视频通信平台，为全球客户提供更安全、全终端、跨平台、无缝接入的运营级高清视频会议服务。
似乎“3”是个很有魔力的数字，开源控制器OpenDaylight和ONOS也建议用三个。这是因为在控制平台上有大量处理在进行，两三个数据集的维护产生的重叠和制造的矛盾需要解决。通常就算与控制器的连接断了网络也会继续工作，因为数据平台是分离的，但是在控制器重新连上之前你的网络就无法保持可视性和政策控制了。冗余，可以解决这类烦恼。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54362474bbbce43f9d84647506a8696c/" rel="bookmark">
			10-10 查询姓‘李’的学生记录(MSSQL)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本题目要求编写SQL语句，
检索出stu表中所有姓‘李’的学生记录。
提示：MSSQLServer 评测SQL语句。
表结构: 请在这里写定义表结构的SQL语句。例如：
CREATE TABLE stu( sno char(4) NOT NULL, sname nvarchar(8) NOT NULL, sex smallint DEFAULT NULL, mno char(2) DEFAULT NULL, birdate datetime DEFAULT NULL, memo ntext, PRIMARY KEY (sno) ); 表样例 请在这里给出上述表结构对应的表样例。例如
stu表：
输出样例: 请在这里给出输出样例。例如：
SELECT sno 学号,sname 姓名,sex 性别,mno 专业,birdate 出生日期,memo 备注 FROM stu WHERE sname LIKE N'李%' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa5de5e573d05bf42ae2cc9763c6fb32/" rel="bookmark">
			C&#43;&#43;——构造函数（定义以及调用构造函数的过程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、构造函数 二、调用构造函数（重点）
三、组合
四、类成员初始化的困惑——冒号语法——成员初始化列表
一、构造函数 1.定义对象的时候，自动调用当前类的构造函数
如果程序员没有定义构造函数，则类会提供一个默认的构造函数，给类中的数据成员分配空间。（分配的是栈上的空间)
2.构造的特殊的成员函数，函数名和类名相同，无返回类型，可以带参数（说明构造函数可以重载）
&lt;&lt;能带参数说明可以构成重载&lt;&lt;
#include&lt;iostream&gt; using namespace std; class Table { public: void Set(); void Print(); private: int m_length; int m_width; int m_height; }; void Table::Set() { m_length = 120; m_width = 40; m_height = 80; } void Table::Print() { cout &lt;&lt; m_length &lt;&lt; " " &lt;&lt; m_width &lt;&lt; " " &lt;&lt; m_height &lt;&lt; endl; } //Person p; int main() { Table t; //t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa5de5e573d05bf42ae2cc9763c6fb32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79363cde258328d4c825dbe02f1a773a/" rel="bookmark">
			扫雷游戏源代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扫雷代码 未登录的用户可以在代码段下方复制扫雷源码；
代码解析见扫雷_代码+解析_齐弈的博客-CSDN博客
扫雷游戏代码如下： #include&lt;bits/stdc++.h&gt; #include&lt;windows.h&gt; #include&lt;conio.h&gt; using namespace std; int x,y,l,l2; bool s,c[11][11]; char a[11][11],b[11][11],f; int dx[]={0,-1,1,-1,1,0,-1,1}; int dy[]={-1,-1,-1,0,0,1,1,1}; int q[150][2],hh,tt,kx,ky; bool Map[11][11]; int statistics_1(int j,int i); int statistics_2(int j,int i); void around(int j,int i); void csh(); void color(int r); void gotoxy(int xx,int yy); void _cout(); void _cin(); void _move(); void _cout2(); int main(){ system("title 扫雷"); while(true){ csh(); while(true){ _cout(); if(s){ color(4); printf("\nGame over!\n\n"); break; } if(l==0&amp;&amp;l==l2){ color(14); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79363cde258328d4c825dbe02f1a773a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2e49b2b41c5d2bcf9b650e969d9321a/" rel="bookmark">
			java的byte[]数组转成字符串并且再转回byte[]数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 byte[] bytes=new byte[] {-58,-85,55,7}; Arrays.toString(bytes) /** * 解码byte[]数组的字符串变成byte[] * @param byteAKeyString 数据库byte[]数组的字符串 * @return 转换后的byte[] 字符串 */ private byte[] stringToBytes(String byteAKeyString){ String trim = StringUtils.strip(byteAKeyString,"[]") //去掉两边括号 .replaceAll("\\s*","");//去掉空格 String[] split = trim.split (","); int[] ids = Arrays.asList(split).stream().mapToInt(Integer::parseInt).toArray(); //利用Lambda表达式进行类型转换,转成int数组 byte[] bytes = new byte[ids.length]; for (int i = 0; i &lt; ids.length; i++) { bytes[i]= (byte) ids[i]; } return bytes; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a91d1deb26541bb87ee6f59e591f41c1/" rel="bookmark">
			PUT_LINE没有输出问题解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 DBMS_OUTPUT.PUT_LINE(output)方法用于BEGIN和AND中间，作用是输出结果。
当我使用它时发现，没有打印出结果，查了资料，说是oracle默认是关闭的。 要在sqlplus中执行 :
set serveroutput on; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c8a1789f737f57d93bfabc596b93643/" rel="bookmark">
			PHP FTP 上传文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		$file = $_FILES['file'];//获取文件 $ftpService = ""; //ftp服务端ip地址 $ftpUserName = ""; //ftp用户名 $ftpPwd = ""; //ftp密码 $file_source = $file['tmp_name'];//源文件 $file_name = $file['name'];//源文件名称 $connect = ftp_connect($ftpService) or die('no service'); ftp_set_option($connect, FTP_USEPASVADDRESS, false); //考虑到不同ftp环境，需要加此参数，否则可能会出现连接超时错误 ftp_login($connect, $ftpUserName, $ftpPwd);//登录 ftp_pasv($connect, true);//把被动模式设置为打开或关闭。 在被动模式中，数据连接是由客户机来初始化的，而不是服务器。这在客户机位于防火墙之后时比较有用。 TRUE = 被动模式打开 FALSE = 被动模式关闭 $path = 'image'; $now_time = date('Ymd'); $now_path = $path.'/'.date('Ymd'); $url = $path.'/'.$now_time.'/'.$file_name; $res = ftp_chdir($connect,$now_path);//改变 FTP 服务器上的当前目录。 if(!$res){ ftp_mkdir($connect, $now_path);//创建文件目录 ftp_chdir($connect,$now_path);//改变 FTP 服务器上的当前目录 }else{ $res = ftp_chdir($connect,$now_time);//当前文件是否存在 if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c8a1789f737f57d93bfabc596b93643/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/355c43bc00a9ded4d3bc578f36d2b972/" rel="bookmark">
			滚动高度和位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		滚动高度 window.innerHeight 当前可视区域的高度 onscroll 窗口滚动事件 window.onscroll = function () {} 已滚动的距离
document.documentElement.scrollTop document.body.scrollTop (ie) 解决兼容性问题
var st = document.documentElement.scrollTop || document.body.scrollTop; 已滚动的宽度的距离
var sl = document.documentElement.scrollLeft || document.body.scrollLeft; console.log(sl); 滚动元素的总高度
document.documentElement.scrollHeight 滚动元素的总宽度
document.documentElement.scrollWidth); 滚动到指定位置
document.documentElement.scrollTop = 1000; document.documentElement.scrollLeft = 1000; 或 document.documentElement.scrollTo(1000, 1000) x,y scrollBy 根据当前位置，增加或者减少指定的距离
document.documentElement.scrollBy(-100, -100); scrollIntoView();
scrollIntoView(); 不写参数时，默认为true 当前元素顶部与可视区域顶部对齐 ​ scrollIntoView(false); 为false时，当前元素的底部与可视区域的底部对齐 回到顶部案例 window.onscroll = function() { console.log(document.documentElement.scrollHeight); var st = document.documentElement.scrollTop || document.body.scrollTop; var sh = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/355c43bc00a9ded4d3bc578f36d2b972/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/331f36a1871bf4692bf0df03ee6c0ed5/" rel="bookmark">
			java实现RSA接口参数加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java实现RSA接口参数加密 为什么使用RSA一、加入依赖1、作用2、Base64编码说明3、sun.misc.BASE64加解密跟Apache的commons-codec加解密区别 二、常量三、引用的包四、获取base64加密后密钥对五、RSA加密1、获取公钥2、加密 六、RSA解密1、获取公钥2、加密 七、RSA签名1、签名2、验签 八、测试九、前端加解密十、遇到的问题：RSA解密中文乱码解决,前端加密后端解密； 为什么使用RSA 对称加密：DES加密适用于一体项目、AES加密适用于前后端分离、Base64加密
非对称加密：RSA加密公钥发出去加密，私钥自己解密、Fiddler。
RSA算法的特点是产生一对密钥，用其中的一个密钥对文件加密后所产生的密文只能使用另一个密钥方能解密还原。把加密和解密的密钥分离对于互联网通信安全具有革命性的意义，由此，加密的密钥（公钥）就可以公开在网上传递而不用担心泄密，因为加密后的文件只能由另一个密钥（私钥）方可解密还原。
一、加入依赖 &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.15&lt;/version&gt; &lt;/dependency&gt; 1、作用 添加org.apache.commons.codec.binary.Base64;
2、Base64编码说明 Base64 是一种编码的方式， 并不是安全领域的加密解密算法。
Base64 的目的是把一些二进制符转成普通字符， 方便在网络上传输。
因为有些系统只能使用ASCII字符，有些二进制字符是控制字符，不能直接传送， 需要转换。
Base64 作用将 非ASCII字符转换为ASCII字符。
3、sun.misc.BASE64加解密跟Apache的commons-codec加解密区别 由于Sun内部API sun.misc.BASE64在编译的时候会出现后期可能被删除的潜在风险的警告，然而让我们觉得以后真的删除了，那么程序就肯定报错了，潜在很大的风险。
二、常量 /** * RSA最大加密明文大小 */ private static final int MAX_ENCRYPT_BLOCK = 117; /** * RSA最大解密密文大小 */ private static final int MAX_DECRYPT_BLOCK = 128; /** * 算法 */ private static final String ALGORITHM_NAME = "RSA"; /** * MD5_RSA */ private static final String MD5_RSA = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/331f36a1871bf4692bf0df03ee6c0ed5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8228ed76465a050f504a8f726b834a39/" rel="bookmark">
			Redis夺命十二问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis 是面试中绕不过的槛，只要在简历中写了用过 Redis，肯定逃不过。今天我们就来模拟一下面试官在 Redis 这个话题上是如何一步一步深入，全面考察候选人对于 Redis 的掌握情况。
小二：面试官，你好。我是来参加面试的。
面试官：你好，小二。我看了你的简历，熟练掌握 Redis，那么我就随便问你几个 Redis 相关的问题吧。首先我的问题是，Redis 是单线程还是多线程呢 ？
小二：
Redis 不同版本之间采用的线程模型是不一样的，在 Redis4.0 版本之前使用的是单线程模型，在 4.0 版本之后增加了多线程的支持。
在 4.0 之前虽然我们说 Redis 是单线程，也只是说它的网络 I/O 线程以及 Set 和 Get 操作是由一个线程完成的。但是 Redis 的持久化、集群同步还是使用其他线程来完成。
4.0 之后添加了多线程的支持，主要是体现在大数据的异步删除功能上，例如 unlink key、flushdb async、flushall async 等
面试官：回答的很好，那为什么 Redis 在 4.0 之前会选择使用单线程？而且使用单线程还那么快 ？
小二：
选择单线程个人觉得主要是使用简单，不存在锁竞争，可以在无锁的情况下完成所有操作，不存在死锁和线程切换带来的性能和时间上的开销，但同时单线程也不能完全发挥出多核 CPU 的性能。
至于为什么单线程那么快我觉得主要有以下几个原因：
Redis 的大部分操作都在内存中完成，内存中的执行效率本身就很快，并且采用了高效的数据结构，比如哈希表和跳表。
使用单线程避免了多线程的竞争，省去了多线程切换带来的时间和性能开销，并且不会出现死锁。
采用 I/O 多路复用机制处理大量客户端的 Socket 请求，因为这是基于非阻塞的 I/O 模型，这就让 Redis 可以高效地进行网络通信，I/O 的读写流程也不再阻塞。
面试官：不错，那 Redis 是如何实现数据不丢失的呢 ？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8228ed76465a050f504a8f726b834a39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c48d6b00ee5fb61bd270af67993f1511/" rel="bookmark">
			Vscode编辑器使用npm 进行依赖安装出现npm 不是内部和外部命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vscode编辑器使用npm 进行依赖安装出现npm 不是内部和外部命令 问题描述——Vscode 使用不了 npm 命令 但是在win系统命令窗口可以使用npm命令 解决方法 vscode使用npm如上面
win系统使用命令查看如下面：
问题原因 vscode里面还是 ps命令终端，要改成cmd命令终端：
如下图更改
修改完后 可以点击文件夹打开终端 发现终端是cmd命令终端了
在终端打开
如果还有
vscode中 ‘npm’ 不是内部或外部命令,也不是可运行的程序 或批处理文件。
解决办法：vscode右键 属性-》兼容性-》勾选 以管理员身份运行此程序-》重启电脑即可。
后面在vscode里面打开终端，输入npm -v查看是否能使用
到此
问题解决，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/987b619a2f662781bab9023cbd540bab/" rel="bookmark">
			C&#43;&#43;STL面试详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是C++STL?
C++ STL从广义来讲包括了三类：算法，容器和迭代器。
算法包括排序，复制等常用算法，以及不同容器特定的算法。容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。迭代器就是在不暴露容器内部结构的情况下对容器的遍历。 2.什么时候需要用hash_map？
总体来说，hash_map 查找速度会比 map 快，而且查找速度基本和数据数据量大小无关，属于常数级别;而 map 的查找速度是 log(n) 级别。
并不一定常数就比 log(n) 小，hash 还有 hash 函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑 hash_map。但若你对内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心，hash_map 可能会让你陷入尴尬，特别是当你的 hash_map 对象特别多时，你就更无法控制了。而且 hash_map 的构造速度较慢。
现在知道如何选择了吗？权衡三个因素: 查找速度, 数据量, 内存使用 。
3.STL中的hashtable的底层实现？
STL中的hashtable使用的是开链法解决hash冲突问题，如下图所示。
hashtable中的bucket所维护的list既不是list也不是slist，而是其自己定义的由hashtable_node数据结构组成的linked-list，而bucket聚合体本身使用vector进行存储。hashtable的迭代器只提供前进操作，不提供后退操作
在hashtable设计bucket的数量上，其内置了28个质数[53, 97, 193,…,429496729]，在创建hashtable时，会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量（vector的长度），其中每个bucket所维护的linked-list长度也等于hashtable的容量。如果插入hashtable的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets vector，重新计算元素在新hashtable的位置。
4.vector的底层原理
（1）vector的底层原理
vector底层是一个动态数组，包含三个迭代器，start和finish之间是已经被使用的空间范围，end_of_storage是整块连续空间包括备用空间的尾部。
当空间不够装下数据（vec.push_back(val)）时，会自动申请另一片更大的空间（1.5倍或者2倍），然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间【vector内存增长机制】。
当释放或者删除（vec.clear()）里面的数据时，其存储空间不释放，仅仅是清空了里面的数据。
因此，对vector的任何操作一旦引起了空间的重新配置，指向原vector的所有迭代器会都失效了。
（2）vector中的reserve和resize的区别
reserve是直接扩充到已经确定的大小，可以减少多次开辟、释放空间的问题（优化push_back），就可以提高效率，其次还可以减少多次要拷贝数据的问题。reserve只是保证vector中的空间大小（capacity）最少达到参数所指定的大小n。reserve()只有一个参数。
resize()可以改变有效空间的大小，也有改变默认值的功能。capacity的大小也会随着改变。resize()可以有多个参数。
（3）vector中的size和capacity的区别
size表示当前vector中有多少个元素（finish – start），而capacity函数则表示它已经分配的内存中可以容纳多少元素（end_of_storage – start）。
（4）vector的元素类型可以是引用吗？
vector的底层实现要求连续的对象排列，引用并非对象，没有实际地址，因此vector的元素类型不能是引用。
（5）vector迭代器失效的情况
当插入一个元素到vector中，由于引起了内存重新分配，所以指向原内存的迭代器全部失效。
当删除容器中一个元素后,该迭代器所指向的元素已经被删除，那么也造成迭代器失效。erase方法会返回下一个有效的迭代器，所以当我们要删除某个元素时，需要it=vec.erase(it);。
（6）正确释放vector的内存(clear(), swap(), shrink_to_fit())
vec.clear()：清空内容，但是不释放内存。
vector().swap(vec)：清空内容，且释放内存，想得到一个全新的vector。
vec.shrink_to_fit()：请求容器降低其capacity和size匹配。
vec.clear();vec.shrink_to_fit();：清空内容，且释放内存。
（7）vector 扩容为什么要以1.5倍或者2倍扩容?
根据查阅的资料显示，考虑可能产生的堆空间浪费，成倍增长倍数不能太大，使用较为广泛的扩容方式有两种，以2倍的方式扩容，或者以1.5倍的方式扩容。
以2倍的方式扩容，导致下一次申请的内存必然大于之前分配内存的总和，导致之前分配的内存不能再被使用，所以最好倍增长因子设置为(1,2)之间：
（8）vector的常用函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/987b619a2f662781bab9023cbd540bab/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/227/">«</a>
	<span class="pagination__item pagination__item--current">228/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/229/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>