<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/534ec9f29fc141470170fb8b376f9412/" rel="bookmark">
			kubelet 创建pod流程（代码图解&#43;日志说明）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将从如下方面介绍kubelet创建pod的过程
kubernetes调度pod简介kubelet 创建pod代码图解说明 （本文重点）kubelet 调用cri创建容器说明 （本文重点）通过日志来分析kubelet真实创建日志的全过程 （本文重点） kubernetes调度pod简介 kubernetes（后面简称k8s）主要有三种管理（创建）pod的方式：
一种是直接申明创建一个裸pod另一种是通过controller 来申明创建pod：比如，deployments、replicationcontrollers、daemonsets或者replicasets还有一种是static（静态） pod 这种用的比较少，一般是把pod的申明文件放在对应的kubernetes/manifest 目录下，通常用来创建apiserver，controller-manager，scheduler这类k8s管理组件的pod。 k8s推荐使用controller来管理pod，这符合k8s管理pod的习惯，便于使用k8s相关功能，比如弹性扩缩容，pod故障自动拉起等。 我们也以controller管理的pod为例，简单梳理下k8s创建及调度pod流程，如下图
客户端请求apiserver创建replicasets，apiserver通过认证、鉴权、准入后，会把请求相关信息持久化至etcdController-manager 管理的replicaset controller 通过list-watch机制，watch到有replicasets创建请求，通过label selector发现集群中与这个replicasets 关联的pod当前状态与期望状态不一致，则会进行调协（reconcile）向apiserver发起创建pod请求Scheduler 通过list-watch机制来发现未绑定的pod，并通过预选及优选策略算法，来计算出pod最终可调度的node节点，并通过apiserver将数据更新至etcdKubelet 通过list-watch发现有新的pod bound到本node上，则会发起创建pod相关流程 kubelet 创建pod代码及图解说明 kubelet 简介 Kubelet 有点和controller类似，也是通过list-watch相关信息，或者轮询本地pod相关信息及事件，来触发相关动作，使pod处于”期望状态”，并且向apiserver上报本node（宿主机）及node里所有pod的状态信息。
kubelet 不同于其他controller的一点就是，它是部署在每个node节点上的agent，它需要与apiserver 打交道同样也需要与cri(contain-runtime-interface)打交道来管理node上的容器。所以它需要通过apiserver来watch到对本地pod变更的事件，也需要不断轮询pod状态信息，将状态及时同步给apiserver，所以Kubelet整体工作逻辑是loop监听各类生产者产生的消息或者定时触发消息，来调用相应的消费者（不同的子模块）完成不同的操作，比如watch 到apiserver的请求，PLEG(pod lifecycle event generator)产生的事件，定时触发的任务等
kubelet创建及启动pod流程 kubelet 创建pod代码调用图解 kubelet 创建pod详细说明 kubelet 会listwatch所有namespace下、绑定到本node上的pod，并将信息传入updatechannel。kubelet 的SyncLoop（是kubele的主循环函数，来控制例行循环往复的事情：同步接收、更新、处理pod变更相关信息）下的syncLoopIteration方法会监听多方消息，会监听各个消息源，来触发相应的操作，这个方法会接收前面listwatch到的updatechannel信息，交由对应的handler:如pod创建：调用HandlePodAdditions处理，pod删除调用HandlePodUpdates处理（DELETE is treated as a UPDATE because of graceful deletion.）
HandlePodAdditions 会对pods 进行排序，判断，准入校验，之后调用dispatchWork 把对某个pod的操作 分配给 podWorkers 做异步操作（pod创建、删除、更新）处理
异步操作会调用kubelet syncPod（syncPod is the transaction script for the sync of a single pod.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/534ec9f29fc141470170fb8b376f9412/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/458af216f44ed4c43f357d3320df7575/" rel="bookmark">
			JavaScript代码实现九九乘法表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以三角的形式打印出九九乘法表 ：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;打印九九乘法表&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; document.write("&lt;table &gt;"); for(var i=1;i&lt;10;i++){ document.write("&lt;tr&gt;"); for(var j=1;j&lt;=i;j++){ document.write("&lt;td&gt;"+i+"*"+j+"="+i*j+"&lt;/td&gt;"); } document.write("&lt;/tr&gt;") } document.write("&lt;/table&gt;"); &lt;/script&gt; &lt;/body&gt; 效果如图所示：
此时的九九乘法表实现了基本样式，若想设置边框可以采用引入css方式或者使用表格标签。
采用css设置相应样式：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;打印九九乘法表&lt;/title&gt; &lt;style&gt; div{ border: 1px solid black; width:65px; height:20px; text-align:left; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; document.write("&lt;table &gt;"); for(var i=1;i&lt;10;i++){ document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/458af216f44ed4c43f357d3320df7575/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c26f1711404b19262e3c9c8d9c914b97/" rel="bookmark">
			XML基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、XML概念
二、XML与HTML的比较
三、XML语法
1、文档声明
2、元素定义
3、属性定义
4、文本
5、注释
一、XML概念 XML(Extensible Markup Language)是类似于HTML的标记语言，称为可扩展标记语言。XML用于提供数据描述格式，适用于不同应用程序之间的数据交换，而且这种交换不以预先定义的一组数据结构为前提，增强了可扩展性。
可扩展：没有标签是已经定义的，所有标签都是自定义的； XML功能：
配置文件，用于传输和存储数据；在网络中传输； 二、XML与HTML的比较 XML和HTML都是基于文本的标记语言，在结构上大致相同，都是以标签的形式描述信息。XML不是HTML的升级，也不是HTML的替代品，他们的应用领域和范围完全不同。
HTML用于显示数据，XML用于传输和存储数据。HTML标签不区分大小写，而XML标签严格区分大小写。HTML可以有多个根元素，XML有且只能有一个根元素。HTML中空格是自动过滤的，XML中空格一般不会自动过滤。HTML中标签是预定义的，XML中的标签需要自己定义。 三、XML语法 一个XML文件可以嵌套很多内容，如文档声明、元素定义、属性定义、注释等，这些编写都要遵循一定的语法规范。XML文档的后缀名.xml
1、文档声明 &lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt; 在一个完整的XML文档中，必须包含一个XML文档的声明，并且该声明必须位于文档的第一行。
在IDEA编辑器中，输入 &lt;? 然后回车便可直接得到文档声明。
XML声明中参数介绍：
version：是强制性声明，用于指定遵循XML规范的版本号，并且该属性必须在XML声明中其他属性之前。encoding：用于指定XML文档所使用的编码集。默认值是ISO-8859-1standalone：用于指定该XML文档是否与外部文档嵌套使用。取值yes/no 2、元素定义 XML文档中的主体内容都是由元素（element）组成的，元素是以树状分层结构排列的。
&lt;color&gt;red&lt;/color&gt; 元素遵循的规则：
名称可以包含字母、数字及其他的字符名称不能以字母或标点符号开始名称不能以字母xml开始名称不能包含空格 3、属性定义 属性是对元素的进一步描述和说明，在一个元素中，可以自定义多个属性，属性是依附于元素存在的，并且每个属性都有自己的名称和取值。id属性值唯一。
4、文本 CDATA区可以使数据原样展示。
&lt;![CDATA[数据]]&gt; 5、注释 注释是为了便于阅读和理解，会在XML文档中插入的一些附加信息，不属于XML文档的内容。具体的语法格式如下：
&lt;!--注释信息--&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0d10a188ed6d8bde21d0fa36605351f/" rel="bookmark">
			Android 的编译环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、android 的build系统
android build系统可以分成三大块：
build/core 目录下，系统的框架和核心
device 目录，具体产品的配置文件
android.mk 各个模块的编译文件
**android 5.0 的build 系统开始支持64位系统。
android build 系统核心
build/core 目录下有几十个mk 文件以及一些shell脚本和perl脚本，构成了android build系统的基础和框架。编译命令有以下三个。
. build/envsetup.sh 建立android 编译环境
lunch 打印菜单让用户选择需要编译的模块。
make 编译系统
envsetup.sh 文件的作用
结尾会在device和vendor目录下搜索所有vendorsetup.sh文件的内容。device/lge/hammerhead下存在。
android 的编译命令
lunchlunch&lt;product_name&gt;-&lt;build_variant&gt; 指定当前编译的产品。tapascrootm编译整个源码，但是不用将当前目录切换到源码的根目录。mm编译当前目录下的所有模块，但是不编译它们的依赖模块。mmm编译指定目录下的所有模块，但是不编译它们的依赖模块mma编译当前目录下的所有模块，同时编译它们的依赖模块。mmma编译指定目录下的所有模块，同时编译它们的依赖模块。cgrep对系统所有的Ｃ/Ｃ++文件执行grep命令。ggrep对系统所有的本地的Gradle 文件执行grep命令。jgrep对系统所有Java 文件执行grep文件。resgrep对系统所有xml目录下的 XML文件执行grep命令。sgrep对系统中所有源文件执行grep命令。godir lunch命令的功能
执行完lunch命令后，系统会打印出当前配置所生成的环境变量。这些环境变量将会影响编译过程。
PLATFORM_VERSION_CODENAME=REL 平台版本名称，通常是ＡＯＳＰ（android open source project） PLATFORM_VERSION=6.0.1 android平台版本号 TARGET_PRODUCT=leaderphone16 所编译的产品名称 TARGET_BUILD_VARIANT=userdebug 编译的产品类型（eng、user、userdebug） TARGET_BUILD_TYPE=release 编译的类型（release、debug） TARGET_BUILD_APPS= 编译android系统时，这个变量的值为null。使用build系统编译单个模块时，这个变量的值是所编译模块的路径。 TARGET_ARCH=arm64 编译目标的cpu架构 TARGET_ARCH_VARIANT=armv8-a 编译目标的cpu架构版本 TARGET_CPU_VARIANT=kryo 编译目标的cpu代号 TARGET_2ND_ARCH=arm 编译目标的第二cpu架构 TARGET_2ND_ARCH_VARIANT=armv7-a-neon 编译目标的第二cpu架构版本 TARGET_2ND_CPU_VARIANT=cortex-a53 编译目标的第二 HOST_ARCH=x86_64 编译平台的架构 HOST_OS=linux 编译平台使用的操作系统 HOST_OS_EXTRA=Linux-4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0d10a188ed6d8bde21d0fa36605351f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e3c9cbe168a008d77cf50ae99e639bb/" rel="bookmark">
			【考研数据结构题型分类讲解练习】0-1 答疑--习题篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更新日期：2022年9月25日 最近有个想法，把同学们的疑惑题目整理出来
一、线性表、栈和队列 1. 最不适合作链栈的链表是（以下链表没有头节点）（ ）
A. 只有表头指针、没有表尾指针的循环双链表
B. 只有表尾指针、没有表头指针的循环双链表
C. 只有表尾指针、没有表头指针的循环单链表
D. 只有表头指针、没有表尾指针的循环单链表
树 1. 已知如下所示长度为12的表(5,4,8,1,9,7,6,2,12,11,10,3),按表中元素顺序构造一棵平衡二叉排序树,并求其在等概率的情况下查找成功的干均查找长度。
2. 一棵二叉树的先序、中序和后序序列分别如下，其中有一部分未显示出来。试求出空格处的内容，并画出该二叉树。
先序序列：_ _ C D E _ G H I _ K
中序序列：C B _ _ F A _ J K I G
后序序列：_ E F D B _ J I H _ A
排序 对n个元素进行堆排序，则初始创建堆需要___次筛选
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fc396a587ca7105f20fbf6471a9c85e/" rel="bookmark">
			C&#43;&#43;入门基础(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、引用1、引用概念2、引用特性3、常引用4、使用场景5、传值、传引用效率比较6、引用和指针的区别 二、内联函数1、概念2、特性 三、auto关键字(C++11)auto的使用细则3、auto不能推导的场景 四、 基于范围的for循环(C++11)五、指针空值nullptr(C++11) 一、引用 1、引用概念 引用不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。
#include&lt;iostream&gt; int main() { int a = 10; int&amp; ra = a;//&lt;====定义引用类型 printf("%p\n", &amp;a); printf("%p\n", &amp;ra); return 0; } 我们可以发现ra和a的地址其实是一样的:
另外需要注意:引用类型必须和引用实体是同种类型的，但是
除常量以外。
2、引用特性 1、引用在定义时时必须初始化的
2、一个变量可以有多个引用
3、 引用一旦引用一个实体，再不能引用其他实体
3、常引用 1、当一个非const类型引用const类型时:
我们可以发现是编译不通过的，为什么呢？，我们可以从引用的角度来理解，首先ra是一个可读不可修改的变量，而a如果引用ra了，其实类型a的类型就变成了int，就变成了可读可修改的变量了，这其实就是将ra的权限给放大了，所以编译是不通过的。
2、当const类型引用非const类型时:
这里呢，我们如果不去修改a里面的值是可以通过编译的，因为ra是一个可读可修改的值，让a是一个只可读的，所以a引用了ra变成了只可读的是一种权限的缩小，所以编译器并不会报错。
另外这里还有另一种情况:
当我们用一个int类型的引用去引用一个double类型的时候，我们可以发现如果我们加了const的编译器却不会报错了，这是因为当一个int类型去引用double类型时，其实时会发生隐式类型转换，而产生隐式类型转换产生的变量是具有常性，是因为我们如果加了const就不会报错了。
4、使用场景 1、做参数
void Swap(int&amp; left, int&amp; right) { int temp = left; left = right; right = temp; } 2、做返回值
int&amp; Count() { static int n = 0； n++; // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fc396a587ca7105f20fbf6471a9c85e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0f53ce5f253793ca071795d30d6bf17/" rel="bookmark">
			Windows 10主机上的VMware Workstation出现“VMware Workstation and Device/Credential Guard不兼容”错误解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在使用虚拟机的时候出现了这个错误：Windows 10主机上的VMware Workstation出现“VMware Workstation and Device/Credential Guard不兼容”错误。
一、出现的原因 出现这个错误的原因：
一、是因为Device或Credentials Guard不兼容；
二、是因为Windows的Hyper-v与VMware不兼容的问题。
想要解决出现的这个错误，我们需要去逐个排查问题。（我一开始就想到了我昨天安装Android Studio的时候修改了相关的Hyper-v的内容）
二、解决办法 一：关闭Device/Credentials Guard 1、win+R打开Windows系统的运行窗口，输入gpedit.msc，进入本地组策略编辑器。（在这个步骤里面，win10的家庭版是没有本地组策略编辑器的，这需要我们自行安装本地组策略编辑器或者将我们的win10升级到专业版。后面的步骤是对于家庭版安装本地组策略编辑器，但是安装完之后找不到我们需要用的Device Guard这个模块，说这么多主要是帮助家庭版的电脑安装本地组策略编辑器而已。） 下面操作步骤是对于win10专业版来说的，家庭版的在后面
1）输入gpedit.msc
2）输入gpedit.msc，进入本地组策略编辑器如图所示
3）本地计算机策略——&gt;计算机配置——&gt;管理模板——&gt;系统——&gt;Device Guard——&gt;打开基于虚拟化的安全设置为【已禁用】
4）win+R输入cmd打开命令提示符，输入 bcdedit /set hypervisorlaunchtype off再回车之后重启电脑即可
2、这个步骤是如何给我我们的win10家庭版安装本地组策略编辑器，前面已经说过了就算安装了本地组策略编辑器但是也找不到我们需要的Device Guard这个模块，因为win10 家庭版上没有这个组件！！！所以我下面这个步骤就是帮助家庭版的win10去安装本地组策略编辑器而已，并不是针对于这个错误 1）新建一个记事本输入以下代码：
下面展示一些 内联代码片。
@echo off pushd “%~dp0” dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;List.txt dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;List.txt for /f %%i in (‘findstr /i . List.txt 2^&gt;nul’) do dism /online /norestart /add-package:“C:\Windows\servicing\Packages%%i” pause 如图所示：
2）然后将文件的后缀名改为bat
3）右键单击，以管理员身份运行
4）安装好之后重启我们的电脑，然后再win+R，输入gpedit.msc即可进入本地组策略编辑器了
二：关闭Hyper-v（假如我们关闭Device Guard之后问题还是没有解决或者我们使用的是家庭版的win10的话，接下来的第二个方法便是关闭Hyper-v。） 1）打开控制面板——&gt;程序——&gt;程序和功能——&gt;启用或关闭Windows功能——&gt;关闭Hyper-v
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0f53ce5f253793ca071795d30d6bf17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62aa0a04dcdbe2cbdce7a478eea2f5af/" rel="bookmark">
			阿里云服务器如何部署ssl证书即https的设置，以及为ip部署ssl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、环境二、关于ｓｓｌ证书三、部署ｓｓｌ四、如何给ip部署ssl呢？ 一、环境 阿里云ｅｃｓ服务器
ｌｉｎｕｘ宝塔界面
ｓｓｌ证书
nginx web服务器
二、关于ｓｓｌ证书 １.　ｓｓｌ全称为ecure Sockets Layer 安全套接字协议)
它的作用就是让网站的ｈｔｔｐ协议改为具有加密传输功能的ｈｔｔｐｓ…
2.关于ｓｓｌ如何在阿里云申请，我不再赘述，已有大量类似的文章可供参考。这里只讲如何部署ｓｓｌ证书。
三、部署ｓｓｌ １.进入到数字证书管理服务界面，点击下载，
下载nginx版本的ssl证书，是一个压缩包，里面有各有2个文件—pem、key文件
2.进入到宝塔界面，点击左侧边菜单栏的网站
进入后，选择相应的站点，点击ｓｓｌ下的未部署
3.点击ｓｓｌ，点击当前证书（由于宝塔版本问题，名称和位置可能有差异）
4.将第一部下载的ssl文件解压后，用记事本打开，将相应的文件内容复制到输入框中，再点击保存即可。这样，域名的ssl就配好了。即：举例，http://www.csdn.com 👉https://www.csdn.com
我这里的🔒有个感叹号是由于我访问的是ip而不是域名。
四、如何给ip部署ssl呢？ 1.为什么会有这个问题？
我们都知道，ssl一般是给域名配置的。毕竟在阿里云中要申请免费的证书也是需要域名的。
然而，我想要上线微信小程序，但是微信公众平台要求必须为https开头，即必须要部署好ssl协议。
可是我的域名要备案成功最快也要一个礼拜。怎么办？
那就给ip配一个ssl，也就是像这样子https://121111.11.80:6666
2.怎么配置？
直接将上文中下载的ssl 的nginx版本部署到ip中就好了。
具体操作则为重复第三-3部分。
当然，在此之前，你必须要在你的站点中存在一个ip站点。
如何新建站点，见文章第三点新建ip站点
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/834d5a48ab19dfd62450393023cb605d/" rel="bookmark">
			开源小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://github.com/brenner8023/iKeep
GitHub - ljc-s/photoEdit: 微信小程序云开发，证件照小程序
GitHub - livissnack/doniai-mini-photo: 智能证件照小程序
GitHub - MarxJiao/your-beauty-value: 颜值测试小程序，使用小程序云函数和百度云 ai 接口开发
photo-edit: 微信小程序：图片裁剪、缩放、涂鸦、添加文字、拼长图、拼相框、表情包制作。便捷的图片编辑工具。
https://github.com/rockyxia/teachertoolbox
工具类：
https://github.com/bixyz/supertoolsGitHub - liuyao64/appletForTools: 微信小程序：小西瓜的工具箱
参考首页
https://github.com/rockyxia/teachertoolbox
GitHub - 0604hx/weapp-tools: 基于微信小程序的各类工具（密码本、微信支付账单生成器、IP查询、图片转PDF等），搜索`集成工具集`即可体验小程序
GitHub - WeDaHub/incubator-qrcode: 【云开发应用】【孵化】艺术二维码生成工具小程序
https://github.com/pythias/duo-money
https://github.com/goudan1030/dirnkwater
https://github.com/amazingTest/miniprogram-Diary
GitHub - Mayandev/wetour: 一款旅游打卡小程序，使用云开发技术，taro 构建
GitHub - nichan-13/mini-program_Cloud-MyTravel: 微信小程序云开发-旅游邀请函
https://github.com/maYunLaoXi/yingyinbiclound
https://github.com/LittleChai/littlechai_diary2.0
https://github.com/LittleChai/weapp-diary
https://github.com/xushankun/yhtd-mp
GitHub - baitongda/ShortUrl-Pro: 小程序云开发短网址自带积分系统
GitHub - xlzy520/scenery: 景你所见（小程序已上线）, 定位信息，天气，地图景点标注，云开发，云函数，小程序
GitHub - LiJiaPing09015314/Bookkeeping: 微信小程序 +记账本+云开发 仿鲨鱼记账 个人项目
GitHub - YeeMu/ExamOnline: 开源的在线答题小程序，在线考试小程序，微信答题小程序，可用于内部考核，考试预约，内部评分等，基于云开发，免服务器和域名备案。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/834d5a48ab19dfd62450393023cb605d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/616ecc6ade7ac2f2e06c7f81158ec15a/" rel="bookmark">
			elasticsearch学习（七）：es客户端RestHighLevelClient
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要是对 elasticsearch-rest-high-level-client 是学习总结。
1、es端口： 默认情况下，ElasticSearch使用两个端口来监听外部TCP流量。
9200端口：用于所有通过HTTP协议进行的API调用。包括搜索、聚合、监控、以及其他任何使用HTTP协议的请求。所有的客户端库都会使用该端口与ElasticSearch进行交互。9300端口：是一个自定义的二进制协议，用于集群中各节点之间的通信。用于诸如集群变更、主节点选举、节点加入/离开、分片分配等事项。 以往，9300端口也被用于客户端库的连接，然而这种类型的交互在我们的官方客户端已被废弃，其他地方也不支持。
2、es的java客户端 客户端优点缺点说明Java Low Level Rest Client与ES版本之间没有关系，适用于作为所有版本ES的客户端 Java High Level Rest Client使用最多使用需与ES版本保持一致基于Low Level Rest Client，它提供了更多的接口。注意：7.15版本之后将被弃用TransportClient使用Transport 接口进行通信，能够使用ES集群中的一些特性，性能最好JAR包版本需与ES集群版本一致，ES集群升级，客户端也跟着升级到相同版本过时产品，7版本之后不再支持Elasticsearch Java API Client最新的es客户端文档少 详细的elasticsearch java客户端发展史详见：https://blog.csdn.net/cloudbigdata/article/details/126296206
3、RestHighLevelClient介绍 JavaREST客户端有两种模式：
Java Low Level REST Client：ES官方的低级客户端。低级别的客户端通过http与Elasticearch集群通信。Java High Level REST Client：ES官方的高级客户端。基于上面的低级客户端，也是通过HTTP与ES集群进行通信。它提供了更多的接口。 注意事项：
客户端(Client) Jar包的版本尽量不要大于Elasticsearch本体的版本，否则可能出现客户端中使用的某些API在Elasticsearch中不支持。
4、springboot集成RestHighLevelClient 下面介绍下 SpringBoot 如何通过 elasticsearch-rest-high-level-client 工具操作ElasticSearch。当然也可以通过spring-data-elasticsearch来操作ElasticSearch，而本文仅是 elasticsearch-rest-high-level-client 的案例介绍。
这里需要说一下，能使用RestHighLevelClient尽量使用它，为什么不推荐使用 Spring 家族封装的 spring-data-elasticsearch。主要原因是灵活性和更新速度，Spring 将 ElasticSearch 过度封装，让开发者很难跟 ES 的 DSL 查询语句进行关联。再者就是更新速度，ES 的更新速度是非常快，但是 spring-data-elasticsearch 更新速度比较缓慢。并且spring-data-elasticsearch在Elasticsearch6.x和7.x版本上的Java API差距很大，如果升级版本需要花点时间来了解。spring-data-elasticsearch的底层其实也是基于elasticsearch-rest-high-level-client的api。
4.1、maven依赖 &lt;!--引入es-high-level-client相关依赖 start--&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/616ecc6ade7ac2f2e06c7f81158ec15a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc8ee881281bc2f9c54d6ded79ef97de/" rel="bookmark">
			Cloudcompare 界面解读与界面修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cloudcompare 界面解读与界面修改 引言一、创建主窗体0. 读取全局配置1. 启动画面2. 主界面-mainWindow 二、插件初始化三、界面修改3.1 源码修改3.2 问题总结 四、参考博文 引言 Cloudcompare功能强大，界面让人看着眼花缭乱，但是我们往往只需要部分功能，故尝试对界面进行简化和修改。
一、创建主窗体 0. 读取全局配置 首先读取在上次运行过程中的一些配置，比如界面的样式等等
//restore some global parameters { QSettings settings; settings.beginGroup(ccPS::GlobalShift()); ...... //省略 1. 启动画面 跳过一些不常用代码，直接看splash screen部分
QScopedPointer&lt;QSplashScreen&gt; splash(nullptr); // 创建QSplashScreen QTimer splashTimer; // 倒计时 主界面启动之后会用到 关闭启动画面 ...//省略一些代码 //splash screen QPixmap pixmap(QString::fromUtf8(":/CC/images/imLogoV2Qt.png")); // 启动画面在这里修改 splash.reset(new QSplashScreen(pixmap, Qt::WindowStaysOnTopHint)); splash-&gt;show(); QApplication::processEvents(); 2. 主界面-mainWindow 主界面创建
MainWindow* mainWindow = MainWindow::TheInstance(); // 主界面 mainWindow-&gt;initPlugins(); // 插件 mainWindow-&gt;show(); QApplication::processEvents(); 构造函数部分代码
setWindowTitle(QStringLiteral("窗口标题")); // 设置窗口标题 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc8ee881281bc2f9c54d6ded79ef97de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9151237e2601fd9b00e7e48c391606c0/" rel="bookmark">
			[c语言]while循环语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面我们已经讲过了if-else语句。当条件满足时，if后面的语句会被执行。但是呢，if语句只能进行一次，那么我们有没有什么方法让语句一直循环持续下去呢。while语句可以很好地帮助我们。
while语句 while语句的语法结构如下 while ( 表达式 ) 循环语句 ; while语句的执行流程大致是这样的。
代码输入进while语句后，先判断真假
1.若判断为假（0），则直接跳出语句。
2.若判断为真，则进入循环
比如我们想实现如下操作：在屏幕上打印1-10的数字
#include &lt;stdio.h&gt; int main() { int i = 1; while(i&lt;=10) { printf("%d ", i); i = i+1; } return 0; } break 上面的一些叙述已经大致的让我们对while语句有了一定了解，那么我们下面继续展开对break的介绍。
在前面的switch语句中，break已经出现过他的身影。那么在while语句中，break是否与在switch语句中的用法一致呢？
其实有些差别。让我们回顾一下，在switch语句中，break是让程序跳出自己所在的switch语句中，而在while语句中，当遇到break时，程序直接跳出while语句。
其实在循环中只要遇到 break ，就停止后期的所有的循环，直接终止循环。 所以： while 中的 break 是用于 永久 终止循环的。 一个break只能跳出一层循环。 下面举例
#include &lt;stdio.h&gt; int main() { int i = 1; while(i&lt;=10) { if(i == 5) break; printf("%d ", i); i = i+1; } return 0; } 这个题目比较简单，只要了解了break语句，那么就很容易判断出了最后打印结果是1234
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9151237e2601fd9b00e7e48c391606c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2933dfef4a191c4414257fe7940c26da/" rel="bookmark">
			在 React 中构建一个可拖动的滑块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网站滑块是灵活的用户界面元素，有助于共享多个图像或有效地传达信息，而不会浪费主页上的宝贵空间。
在本文中，我们将演示如何使用react-draggable-slider包在 React 中构建具有可拖动功能的滑块。
跳跃前进：
什么是滑块？
什么是可拖动滑块？
什么是反应可拖动滑块？
React 可拖动滑块演示
创建 React 应用程序
安装 react-draggable-slider 包
创建滑块
定义滑块设置
data
speed
easing
bgColor
showButton
buttonText
buttonHref
buttonTarget
什么是滑块？ 网站滑块是一种幻灯片，可显示在单个空间内水平或垂直排列的一系列图像或项目。图像在定义的时间段内单独显示，在从一个图像或项目到下一个图像或项目的变化之间具有过渡效果。
用户可以使用一组导航控件在滑块图像中导航，并且图像或项目也可以循环播放。滑块可以帮助网站以视觉上吸引人的方式展示单个项目，同时还可以节省屏幕空间。
展示客户推荐的网站滑块可能有利于与新潜在客户建立信任和信誉。滑块还可用于显示不同的服务产品或显示产品的多个图像，以便潜在客户可以从不同角度对其进行可视化。
这种类型的 UI 元素对于长页面的滚动内容来说是一个有吸引力的选择。使用滑块，您可以将信息分组到一个位置，为每个项目之间的循环设置舒适的节奏，甚至添加自动播放功能。
什么是可拖动滑块？ 可拖动的滑块是手动导航的；用户通过按住并向左或向右拖动当前视图中的项目来从一个项目导航到下一个项目。要查看下一个项目，用户按住当前项目并将其拖到左侧。同样，要查看前一个项目，用户按住当前项目并将其拖动到右侧。
什么是反应可拖动滑块？ 要在 React 中创建可拖动的滑块，我们可以从头开始构建它，也可以使用 React 包。
使用 React 包可以提高你的工作效率，因为它会减少你编写代码的时间。但是，这确实意味着您的代码库将依赖于（并且可能容易受到）包的影响。这就是为什么最好选择一个有大型社区贡献的开源包，发现、报告和修复错误，从而保证代码的安全。
超过 20 万开发人员使用 LogRocket 来创造更好的数字体验了解更多 →
对于本文，我们将使用 react-draggable-slider 包。该软件包易于使用，并带有内置的悬停效果。
React 可拖动滑块演示 为了演示在 React 中构建可拖动滑块，我们将设置一个 React 应用程序，安装 react-draggable-slider 包，然后创建滑块并定义滑块设置。
让我们开始吧！
创建 React 应用程序 使用以下命令创建一个 React 应用并为其命名react-draggable-slider：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2933dfef4a191c4414257fe7940c26da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5b3da77f5d99795cb9eed2454874592/" rel="bookmark">
			C&#43;&#43; 本地使用tinyxml2解析Xml文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、基本介绍 TinyXML2是一个开源、简单、小巧、高效的C++ XML解析器，它只有一个.h文件和一个.cpp文件组成，可以轻松集成到其它程序中。非常方便我们使用c++对xml进行处理。
可以读取、修改和保存的文档对象模型(Document Object Model, DOM)。它不能解析DTD(Document Type Definitions, 文档类型定义)或XSL(eXtensible Stylesheet Language, 扩展样式表语言)。在TinyXML2中，XML数据被解析为可以浏览和操作的C++对象，然后写入磁盘和其它输出流。
2、本地编译 首先现在源码：tinyxml2 源码
解压目录：
编译静态库
直接在目录下执行cmake和make就可以编译生成。
编译动态库
如果需要编译动态库，则需要把makefile文件里面的libtinyxml2.a修改成libtinyxml2.so,再执行make指令。则编译libtinyxml2.so
3、tinyxml2 源码解析 我们在使用tinyxml2的时候都是声明使用tinyxml2的命名空间，其内部比较重要的几个类都是继承XMLNode的。
namespace tinyxml2 { class XMLDocument; class XMLElement; class XMLAttribute; class XMLComment; class XMLText; class XMLDeclaration; class XMLUnknown; class XMLPrinter; } 3.1 XMLNode 基础父类 class TINYXML2_LIB XMLNode { friend class XMLDocument; friend class XMLElement; public: const XMLDocument* GetDocument(); XMLDocument* GetDocument(); //转换成特定的子类对象 virtual XMLElement*	ToElement(); virtual XMLText*	ToText(); virtual XMLComment*	ToComment(); virtual XMLDocument*	ToDocument(); virtual XMLDeclaration*	ToDeclaration(); virtual XMLUnknown*	ToUnknown(); virtual const XMLElement*	ToElement(); virtual const XMLText*	ToText(); virtual const XMLComment*	ToComment(); virtual const XMLDocument*	ToDocument(); virtual const XMLDeclaration*	ToDeclaration(); virtual const XMLUnknown*	ToUnknown() ; const char* Value() const; void SetValue( const char* val, bool staticMem=false ); int GetLineNum() const { return _parseLineNum; } const XMLNode*	Parent(); XMLNode* Parent(); bool NoChildren(); const XMLNode* FirstChild(); XMLNode*	FirstChild(); const XMLElement* FirstChildElement( const char* name = 0 ) const; XMLElement* FirstChildElement( const char* name = 0 ); const XMLNode*	LastChild(); XMLNode*	LastChild(); const XMLElement* LastChildElement( const char* name = 0 ) const; XMLElement* LastChildElement( const char* name = 0 ); const XMLNode*	PreviousSibling(); XMLNode*	PreviousSibling(); const XMLElement*	PreviousSiblingElement( const char* name = 0 ) const ; XMLElement*	PreviousSiblingElement( const char* name = 0 ); const XMLNode*	NextSibling(); XMLNode*	NextSibling(); const XMLElement*	NextSiblingElement( const char* name = 0 ) const; XMLElement*	NextSiblingElement( const char* name = 0 ); XMLNode* InsertEndChild( XMLNode* addThis ); XMLNode* LinkEndChild( XMLNode* addThis )	; XMLNode* InsertFirstChild( XMLNode* addThis ); XMLNode* InsertAfterChild( XMLNode* afterThis, XMLNode* addThis ); void DeleteChildren(); void DeleteChild( XMLNode* node ); virtual XMLNode* ShallowClone( XMLDocument* document ); XMLNode* DeepClone( XMLDocument* target ); virtual bool ShallowEqual( const XMLNode* compare ); virtual bool Accept( XMLVisitor* visitor ); void SetUserData(void* userData); void* GetUserData(); //省略部分代码 }; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5b3da77f5d99795cb9eed2454874592/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/252a2aed3a373b394da8a08a5433438b/" rel="bookmark">
			卷积神经网络参数解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单的卷积网络 构建卷积神经网络读取数据卷积网络的介绍与构建准确率评估标准 网络模型的训练和测试 在之前的分类任务中，我们讲述了全连接神经网络（FC）进行分类的方法，但是对于图像数据来说，全连接神经网络并不是一个合适的选择，因为在图像信息当中，每个像素点所代表的信息和其周围的像素点或多或少存在关系。应对这样的情况，卷积神经网络（CNN）是比较合理的选择。本节我们依然使用MNIS数据集来进行卷积神经网络的初步学习。 构建卷积神经网络 读取数据 我们依然分别构建训练集和测试集：
import torch import torch.nn as nn import torch.optim as optim import torch.nn.functional as F from torchvision import datasets,transforms import matplotlib.pyplot as plt import numpy as np # 定义超参数 input_size = 28 # 图像的总尺寸28*28 num_classes = 10 # 标签的种类数 num_epochs = 3 # 训练的总循环周期，由于可供学习数据量不够， # 我们要重复使用训练集进行学习 batch_size = 64 #一个撮（批次）的大小，64张图片 # 训练集 train_dataset = datasets.MNIST(root='./data', train=True, transform=transforms.ToTensor(), # 将读入数据转换成tensor download=True) print(train_dataset) # 查看训练集基本信息 # 测试集 test_dataset = datasets.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/252a2aed3a373b394da8a08a5433438b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55880c66016cfdad86114cf21007819f/" rel="bookmark">
			解决Typora文件夹中的.md文件到另一台笔记本图片丢失问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们第一次使用Typora的时候难免是没有设置图片保存路径的，所以在我们记笔记插入图片的时候，如果是自己截的图就会默认保存到c盘Typora软件自建的某目录，如果是从网络上复制的图片贴到笔记中，则没有存在笔记本上，而是存的网络图片的地址。
所以在更换电脑，只转移.md文件的话，图片是显示不了的（因为新笔记本没有存这些图片，而且就算你把就电脑的图片文件夹复制过来了，也因为.md文件中图片的地址不一致而无法显示）
如果遇到这种问题的朋友们，解决办法也很简单：
第一步：文件---偏好设置
第二步：点图像，按照如下进行修改
第三步：找到自己该文件夹下的随便一个.md文件，右键图片，可以复制到images文件夹了，这样地址存的是相对路径，且该路径下复制了之前的图片，转移的时候只需要把.md文件夹复制就行了（因为通常我们会把images文件夹放到.md文件夹里面）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c56f7028daaf9bb0284872faa08794fa/" rel="bookmark">
			常用的 Linux 服务器性能查看命令有哪些
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）linux常用操作及命令
如何查看 Linux 服务器负载
可以通过执行 w，top，uptime，procinfo 命令，或者访问 /proc/loadavg 文件进行查看
如何查看正在使用的服务和端口
可以通过执行 netstat -tunlp，netstat -antup，lsof -i:PORT 命令进行查看
如何查看服务器进程信息
可以通过执行 ps auxww|grep PID，ps -ef，lsof -p PID，top -p PID 命令进行查看
常用的 Linux 服务器性能查看命令有哪些
命令名称说明top进程监控命令，用来监控系统的整体性能。可以显示系统负载，进程，CPU，内存，分页等信息，常用 shift+m 和 shift+p 来按 memory 和 CPU 使用对进程进行排序。vmstat系统监控命令，重点侧重于虚拟内存，也可以监控 CPU，进程，内存分页以及 IO 的状态信息。例如，vmstat 3 10，每隔3秒输出结果，执行10次。iostat用于输出 CPU 状态和 IO 状态的工具，可以详细展示系统的 IO 信息。例如 iostat -dxmt 10，每10秒以 MB 的格式输出 IO 的详细信息。df用来检查系统的磁盘空间占用状况。例如：df -m，以 MB 为单位展现磁盘使用状况。lsof列举系统中被打开的文件，由于 Linux 是以文件系统为基础，此命令在系统管理中很有帮助。例如：lsof -i：36000，显示使用36000端口的进程 lsof -u root，显示以 root 运行的程序lsof -c php-fpm，显示 php-fpm 进程打开的文件lsof php.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c56f7028daaf9bb0284872faa08794fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54b470076888399493c53d397ad6f940/" rel="bookmark">
			智能家居新标准-Matter，蓝牙BLE技术发挥重要作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着苹果和谷歌的两项重大更新，Matter越来越接近于成为智能家居的普遍标准。在苹果方面，我们看到 iOS 和 iPadOS 16.1 开发者测试版的发布为每个操作系统的“设置”中带来了“Matter Accessories”新选项：
苹果在 WWDC 上首次宣布 iOS 16 将支持 Matter，我们现在开始看到现实世界整合的初步迹象。选择新选项将打开一个页面，该页面将列出已添加到“连接服务”的 Matter组件。当然，目前该列表是空的，因为最终的 Matter 标准要到今年秋天的某个时候才会发布。谷歌本周还推出了 Google Home Developer Console，旨在帮助开发人员构建 Matter 智能家居产品。
低功耗蓝牙在智能家居中起到了重要的作用，可以减少布线。而且，低功耗蓝牙可以收集房间内的数据，并实时监控功能，实现无线智能家居、安防等物联网应用的连接。
低功耗蓝牙在我们平时生活中很是常见，应用范围也比较广，人们生活中的家居用品，如智能控制灯光技术，这种技术不仅是传统意义上的对灯光开关的控制，更随科学技术的发展，人们对灯光的控制要求不仅在开关上面，还包含灯光色彩、种类的变化控制等。如北京奥运会上的灯光表演。
因此，在现时生活中，低功耗蓝牙智能灯光控制技术的应用在很大程度上满足了人们的需要，也可以满足人们的需求 智能家居技术在人们生活中的应用范围很广，依
据应用的地方不同，相关企业智能家居把他们分为以下几个方面。
1、对客厅的控制应用
在客厅中的应用与卧室的控制类似，都能实现对房间内的照明场景及娱乐设施的控制，如通过灯光实现对音响设备的控制等。通过音乐设备实现对窗帘、空调等设备的控制。还可以通过通信设备的使用，实现对家里面电器的控制。
2、对楼道的控制应用
智能家居控制系统不仅是实现灯光的控制，还能根据自然光的亮度，实现对灯光的开关调节。具体可以突出，当自然光的光线较亮时，会将楼道内的灯光亮度调暗。当自然光强度较暗或者没有自然光时，会实现对灯的亮度自动调节。此外，还能帮助人们进行定时提醒，做到定时开灯、定时关灯等。
3、室内方面的应用
具体对房间内的照明控制系统，对此来实现对不同场景的切换与控制;还可以对窗帘、空调等电器设备的智能控制。除此之外，还以可以通过移动设备，对整个房间内的电器及灯具的控制。智能家居控制系统在人们的生活中应用非常广，不仅增强了人们生活的安全性，更提供了人们生活的方便与快捷，使人们在生活过程中具有愉悦的心情，因此受到人们广泛的青睐。
蓝牙低功耗(BLE)技术广泛用于个人电子设备,包括智能手机、健身监测设备、基于位置的移动设备应用服务、娱乐设备以及已内置蓝牙低功耗(BLE)芯片的装置。它的功率非常低,只需要很低的电量消耗就能运行很长时间。我们日常生活中的的蓝牙低功耗(BLE)连接通常需要两个设备配对,但福特的这项创新科技是以蓝牙低功耗(BLE)芯片为信标,无需配对即可感应到范围内多个类似的其它设备。如果一个人正在使用蓝牙低功耗(BLE)设备,该系统则按照其行进速度区分出行人、骑行者等,再基于其行进方向进一步评估碰撞风险。在2.4GHz无线电频段内,蓝牙低功耗(BLE)设备可迅速改变通信频道——即跳频,这样就能尽可能减少干扰,提升可靠性。
伦茨科技拥有自主研发无线射频和低功耗蓝牙BLE5.2芯片并具有全球知识产权，针对AIoT物联网领域和个人消费者，提供蓝牙主控全集成芯片的「软硬件共性」解决方案及核心器件，配套全方位APP软件平台定制开发。所设计的蓝牙芯片方案应用于智能穿戴设备、蓝牙室内导航、智能家居、医疗健康、运动建身、数据传输、远程控制、个人外设及AIoT物联网等场景。（tingting是伦茨科技旗下品牌，主要是提供Apple Find My服务应用于各大物联网产品中）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3db87c51c8c0ef3dd6f93ca1383d19fb/" rel="bookmark">
			阿里云oss分片上传示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oss文件服务器分片上传官方文档参考: 分片上传 - 对象存储 OSS - 阿里云
官方文档写的更加详细，更多内容请参考官方文档
oss分片上传流程 1.初始化分片事件,向oss服务器获取全局唯一的uploadId 获取uploadId,后续分片都需带上uploadId，标识同一个文件对象。另外初始化操作时已经指定文件访问链接,还可以添加一些请求头,如缓存、文件私有访问控制等条件。* 2.开始切片上传 分片一般由前端完成，通过后端将分片上传到oss服务器，上传时也无需按照顺序上传。也可由前端直接上传到oss服务器,此时后端仅需要向前端颁发凭证即可。需要注意的是,在分片上传成功后需保存响应数据，留待第三步使用。* 3.分片上传完成,合并上传 分片上传完成后，需主动通知oss服务器合并文件。* 2.代码示例 开始前准备 依赖导入 &lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;version&gt;3.13.2&lt;/version&gt; &lt;/dependency&gt; sql 文件上传记录表 CREATE TABLE `file_upload_record` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `filename` varchar(255) DEFAULT NULL COMMENT '文件原名称', `md5` varchar(255) DEFAULT NULL COMMENT 'md5', `upload_id` varchar(255) DEFAULT NULL COMMENT 'uploadId', `paths` varchar(255) DEFAULT NULL COMMENT '图片地址', `status` varchar(255) DEFAULT NULL COMMENT '状态:wait/succ', `upload_start_time` datetime DEFAULT NULL COMMENT '上传起始时间', `upload_end_time` datetime DEFAULT NULL COMMENT '上传结束时间', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=39 DEFAULT CHARSET=utf8; 分片上传结果记录表 CREATE TABLE `part_upload_record` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `upload_id` varchar(255) DEFAULT NULL COMMENT '唯一上传id', `part_number` int(11) DEFAULT NULL COMMENT '当前片数', `md5` varchar(255) DEFAULT NULL COMMENT '当前片的md5值', `upload_result` varchar(255) DEFAULT NULL COMMENT '分片上传结果(json)', `upload_time` datetime DEFAULT NULL COMMENT '分片上传时间', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=95 DEFAULT CHARSET=utf8; 请求对象 @Data @ApiModel("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3db87c51c8c0ef3dd6f93ca1383d19fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/911d9107f6cdb98ae5fb60027f0fe603/" rel="bookmark">
			java解决八皇后问题代码,参考以及对步骤的详细思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接上代码:(C++也可以参考)
参考八皇后问题的原代码http://t.csdn.cn/GK01i思路解析在代码里
package Test; public class bahuanghou { public static class TestQueen { private static final int num = 8;// 皇后/棋盘的个数 private static final int[][] Checkerboard = new int[num][num];// 首先定义一个8 * 8 的棋盘 private static int COUNT = 0;// 定义一共有多少种放置皇后的算法 public static final void show() {//打印棋盘 System.out.println("第" + (++COUNT) + "次摆法"); for (int i = 0; i &lt; num; i++) { for (int j = 0; j &lt; num; j++) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/911d9107f6cdb98ae5fb60027f0fe603/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1859772ee95a56d615c76c03851e1a9a/" rel="bookmark">
			[信息学奥赛一本通]题解目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		历年真题
2022年CSP-JS报名时间
NOI与NOIP的区别
CSP-J/S介绍
2022年信息学奥赛介绍
CSP-JS信息学奥赛注意事项
CSP-J信息学奥赛考试大纲（入门级）
排序图文代码详解 冒泡排序 插入排序 选择排序 快速排序 归并排序 桶排序 总结
[语言及算法基础篇]
第一部分C++语言
第一章C++语言入门 Hello,World!（T1001）
输出第二个整数（T1002）
对齐输出（T1003）
字符三角形（T1004）
地球人口承载力估计（T1005）
第二章顺序结构程序设计
第一节 运算符和表达式
A+B问题（T1006）
计算(a+b)*c的值（T1007）
计算(a+b)/c的值（T1008）
带余除法（T1009）
计算分数的浮点数值（T1010） 第二节 常量和变量 甲流疫情死亡率（T1011）
计算多项式的值（T1012）
温度表达转化（T1013）
与圆相关的计算（T1014）
计算并联电阻的阻值（T1015） 第三节 标准数据类型
整型数据类型存储空间大小（T1016）
浮点型数据类型存储空间大小（T1017）
其他数据类型存储空间大小（T1018）
浮点数向零舍入（T1019）
打印ASCII码（T1020）
打印字符（T1021）
整型与布尔型的转换（T1022）
Hello,World!的大小（T1023） 第四节 数据输入输出 保留3位小数的浮点数（T1024）
保留12位小数的浮点数（T1025）
空格分隔输出（T1026）
输出浮点数（T1027）
字符菱形（T1028）
第五节 顺序结构实例 计算浮点数相除的余（T1029）
计算球的体积（T1030）
反向输出一个三位数（T1031）
大象喝水（T1032）
计算线段长度（T1033）
计算三角形面积（T1034）
等差数列末项计算（T1035）
A*B问题（T1036）
计算2的幂（T1037）
苹果和虫子（T1038）
第三章 程序的控制结构
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1859772ee95a56d615c76c03851e1a9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4df63f81856e292e57e865c7c19a9d5/" rel="bookmark">
			头歌数据结构最大因子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 2022.9.23上机
任务描述 本关任务：给定一组整数，共n（1≤n≤5000）个整数，整数的取值范围为1~20000，请确定具有最大素数因子的整数（记住：素数只有因子1和它自身，例如整数7是素数，而整数6可以被2和3整除，6不是素数）。
编程要求 根据提示，在右侧编辑器补充代码，输出具有最大因子的整数。
测试说明 输入格式： 第一行为单个整数n，接下来共n个整数，每一行包含一个整数。
输出格式： 在一行中输出具有最大素数因子的那个整数，如果有多个，则输出最早出现在输入文件中的一个。
输入样例： 4
36
38
40
42
输出样例： 38
样例解释： 36的素数因子为2、3。
38的素数因子为2、19。
40的素数因子为2、5。
42的素数因子为2、3、7。
最大的素数因子为19，所以输出38。
开始你的任务吧，祝你成功！
C++程序` #include&lt;iostream&gt; using namespace std; const int N =20001; int a[N]; int p[N]; int cnt = 0; void init() { for(int i = 0; i &lt;= N - 1; i++) a[i] = 1; a[0] =a[1] = 0; for(int i=2; i &lt;= N - 1; i++){ if(a[i]==1){ p[cnt++] = i; for(int j = i + i; j &lt;= N - 1; j += i) a[j]=0; } } } int main() { init(); int n; cin &gt;&gt; n; int ansp=2; int ansn=1; while(n--) { int val; cin &gt;&gt; val; for(int j=cnt-1; j&gt;=0; j--) { if(val%p[j]==0) { if(p[j]&gt;ansp) { ansp=p[j]; ansn=val; } } } } cout &lt;&lt; ansn &lt;&lt; endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aea7a33f8b1082ea441f1c292136d1d7/" rel="bookmark">
			Arrays.sort()的底层实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Arrays.sort()总览数组长度小于286数组长度小于47数组长度大于等于47数组长度大于等于286 二、总结 前言 最近在leetcode刷题，遇到挺多Arrays.sort()这个API，今天在牛客网看到有面试官问这个API对于快排做了什么优化，那么面向面试学习的我也要去学习一下啦。
本文基于JDK1.8。
一、Arrays.sort()总览 先上答案：jdk1.8之前，Arrays.sort()方法使用的是传统快排的方式进行排序。jdk1.8后，Arrays.sort()方法使用的是双轴快排。
双轴快排(DualPivotQuicksort)的基本思想是：
顾名思义有两个轴元素pivot1，pivot2，且pivot ≤pivot2 将序列分成三段：x &lt; pivot1、pivot1 ≤ x ≤ pivot2、x &gt;pivot2 然后分别对三段进行递归
一幅我觉得很好的流程图。图片以及本文主要内容来自深入理解Arrays.sort()底层实现
sort方法进来后，调用了DualPivotQuicksort.sort()。传统快排（单轴快排）的时间复杂度最差的情况为n²，DualPivotQuicksort（双轴快排）能保证大多数数组排序的时间复杂度保持在O(nlogn) 。
/** * Sorts the specified array into ascending numerical order. * * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm * offers O(n log(n)) performance on many data sets that cause other * quicksorts to degrade to quadratic performance, and is typically * faster than traditional (one-pivot) Quicksort implementations.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aea7a33f8b1082ea441f1c292136d1d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/101bde21d1a03b891b1622b8e98f74ff/" rel="bookmark">
			[C语言] if和else语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，c语言是结构化的程序设计语言。而c语言中的结构大致能分为三种
1.顺序结构 2.选择结构 3.循环结构，而今天想要分享的是选择结构（也叫分支语句）中的一种if else语句
什么是语句？ 当然，在介绍if else语句前，我们要有一个总的概念，什么是语句？
语句是指令式编程语言最小的独立元素，表达程序需要执行的操作
C语言语句可分为以下五类：
1. 表达式语句 2. 函数调用语句 3. 控制语句 4. 复合语句 5. 空语句 而这次，甚至后面几次将要介绍的是控制语句。 控制语句 用于控制程序的执行流程，以实现程序的各种结构方式，它们由特定的语句定义符组成， C 语言有九种控制语句： 也大致可以分为以下三类： 1. 条件判断语句也叫分支语句： if 语句、 switch 语句； 2. 循环执行语句： do while 语句、 while 语句、 for 语句； 3. 转向语句： break 语句、 goto 语句、 continue 语句、 return 语句。 其实简明扼要一点，什么是语句？在c语言中，一个以结尾为；控制的就是一个语句 if else语句的语法结构 if else语句一共有三种语法结构
当然在开始了解if else之前，我们要知道C语言是如何判断真假的
一般来说，在c语言中，非0就是真，0就是假，有了这个前提，我们就能开始了解第一种语法结构
语法结构1. if ( 表达式 ) 语句 ; 在该种语法结构中，if后表达式如果为真，则执行操作。 举例： #include&lt;stdio.h&gt; int main(); { int age = 0; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/101bde21d1a03b891b1622b8e98f74ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/730ae263dff08e95933c8a9ffe578366/" rel="bookmark">
			Python中常见文件操作,纯干货
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python文件操作 一、关于文件二、读写文件简单操作三、文件权限四、文件高级操作五、大文件的读取基本方法常用函数 六、大文件的读取其他方式 一、关于文件 文件的作用：把一些数据储存起来使用文件流程： 打开文件，读写文件，关闭文件 二、读写文件简单操作 1.读取文件
#打开文件 file = open("demo1/1.txt",mode="r") #读取文件 ret = file.read() #file只是变量，read是读取函数 print(ret) #关闭文件 file.close() #第一个参数的文件的路径 #第二个参数mode=访问文件的模型，r表示读，默认是r模式 2.写入文件
2.写文件 write file = open("demo1/1.txt",mode="w") file = open("demo1/111.txt",mode="w") #文件不存在，会自动创建 file = open("demo2/111.txt",mode="w") #不会创建目录 file.write("huangzhi") file.close() 三、文件权限 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。一般用于 非文本文件如图片等。
注意：二进制文件把内容表示为一个特殊的 bytes 字符串类型。
# file = open("demo1/1.txt","rb") file = open("demo1/1.png","rb") ret = file.read() #b'huangzhi' huangzhi print(ret) file.close() r+ 打开一个文件用于读写。文件指针将会放在文件的开头。
file = open("demo1/1.txt","r+") # ret = file.read() #读取全部内容 # print(ret) file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/730ae263dff08e95933c8a9ffe578366/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c2edc656e6322013fedffc974236e52/" rel="bookmark">
			Go语言 数组基本使用及字符串转数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go语言 数组基本使用及字符串转数组 package main import "fmt" func main() { //数组三种建立方式 var num [4] int //var 变量 [max_length] type var num2=[10] int{1,2,3,4} //var 变量=[max_length] type{} 初始化 num3:=[...] int{1:2} // 变量:=[...] type{} 初始化 //数组三种打印方式 //1 println fmt.Println(num) fmt.Println(num2) fmt.Println(num3) //2 for for i:=0;i&lt;4;i++{ num[i]=i fmt.Printf("%d \t",num[i]) //0 1 2 3 } fmt.Println() //3 for := range for index,value :=range(num2){ fmt.Printf("index=%d,value=%d\t",index,value) //index=0,value=1	index=1,value=2	index=2,value=3	index=3,value=4	index=4,value=0	index=5,value=0	index=6,value=0	index=7,value=0	index=8,value=0	index=9,value=0 } fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c2edc656e6322013fedffc974236e52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc54bf2ec7ba69eed9be9dc583e1728d/" rel="bookmark">
			Fiddler&#43;模拟器进行APP抓包及其注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Fiddler+模拟器进行APP抓包 安装Fiddler安装模拟器Fiddler配置模拟器配置导入https证书 成果在配置中常见的问题设置代理后无法联网无法打开自定义规则 安装Fiddler Fiddler
安装模拟器 这里作者用雷电模拟器
Fiddler配置 安装Fiddler后,配置如下
配置完后然后重新打开Fiddler
模拟器配置 导入https证书 我们先可以在本地下载证书
1.先打开Fiddler
然后输入网址 http://localhost:8888/
下载完后会一个证书
双击,然后一直默认点击直到导入成功
然后将这个证书移入模拟器中,
然后点击设置-&gt;安全-&gt;从SD卡安装,找到刚刚共享的证书
到时要你设置密码什么,设置即可
证书这样就ok了然后就是配置网络:
成果 在配置中常见的问题 设置代理后无法联网 如果设置代理前,可以通网,但是设置代理后就不能通网, 那可能是模拟器不允许抓包,你可以直接换一个模拟器或者下载这个模拟器的低版本,这里作者就是用的3.0的雷电模拟器
无法打开自定义规则 使用fiddler script自定义代理规则，系统找不到相应的文件FSE2.exe文件
安装下面步骤即可
1.先查看…\Fiddler\ScriptEditor中目录是否有FSE2.exe
点确定然后重新打开Fiddler即可用了
关注微信公众号【爱上开源】,该公众号会为你提供作者在网上找到有趣的开源项目,会将使用过程写成文章呈现给读者.公众号还提供爬虫和部分计算机资源给读者.如果读者想要什么资源可以私信给我,作者会尽力查询(不要涉嫌违法资源即可) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f63033661e47403b68115f25c3d1833/" rel="bookmark">
			STL 学习总结三 —— vector 容器实现与扩充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 vector 容器实现与扩充1. 底层实现2. 扩容过程size() 和 capacity()扩容机制 vector 容器实现与扩充 1. 底层实现 Vector在堆中分配了一段连续的内存空间来存放元素
三个迭代器
first： 指向的是vector中对象的起始字节位置last：指向的是当前最后一个元素的末尾字节end：指向整个vector容器所占用内存空间的末尾字节 last - first：表示vector容器汇总目前已被使用的内存空间end - last：表示vector 容器目前空闲的内存空间end - first：表示vector容器的容量 2. 扩容过程 如果集合已满，在新增数据时，就需要分配一块更大的内存，将原来的数据复制过去，再插入新增的元素。
所以对vector的任何操作，一旦引起空间重新配置，指向原有vector 的所有迭代器就都失效了。
size() 和 capacity() （1）堆中分配内存，元素连续存放，内存空间只会增加不会减小
​ vector有两个函数，一个是capacity()，在不分配新内存的情况下最多可以保存的元素的个数，另一个是size()返回当前已经存储的数据的个数。
​ （2）对于vector来说，capacity()是永远大于等于size()的
capacity() == size()时，vector就会扩容（capacity翻倍）
扩容机制 固定扩容
机制：
每次扩容的时候在原有capacity基础上加上固定的容量
缺点：
考虑一种极端情况，vector每次添加的元素数量刚好等于每次扩容后增加的容量+1， 就会造成一种情况，每添加一次就需要扩容一次，而每次扩容花费的时间十分高昂，所以固定扩容就会面临多次扩容时间复杂度极高的情况。
优点：
固定扩容方式空间利用率较高
加倍扩容
机制：
每次扩容capacity翻倍
优点：
加倍扩容情况下需要扩容的次数较少，时间复杂度较低
缺点：
空间利用率较低
在实际过程中，通常采用空间换时间的方式。
resize 和 reserve() resize()： 改变当前容器内含有元素的数量（size()）,而不是容器的容量
1. 当`resize(len)`中`len() &gt; v.capacity() `，则数组中的size和capacity均设置为len； 2. 当`resize(len)`中`len &lt;= v.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f63033661e47403b68115f25c3d1833/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea3f74aac3881bb554add79c6a0cd25f/" rel="bookmark">
			使用python serial 库发送16进制数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		def send_data(self, data): # 如果data为字符串 要通过bytes.fromhex(data) 转换为ascii码 发送 # 可以直接将10进制的数组 或者 16进制数组给串口发送 # data = [0x01, 0x05, 0x00, 0x01, 0xff, 0x00, 0xdd, 0xfa] # data = [1, 5, 0, 1, 255, 0, 221, 250] if self.open_com is None: self.open() if (self.isOpen == True): # success_bytes = self.open_com.write(bytes.fromhex(data)) success_bytes = self.open_com.write(data) return success_bytes 这个函数实际传入的data类型可以很多种。注意下面问题即可发送
# 如果data为字符串 要通过bytes.fromhex(data) 转换为ascii码 发送
# 可以直接将10进制的数组 或者 16进制数组给串口发送
# data = [0x01, 0x05, 0x00, 0x01, 0xff, 0x00, 0xdd, 0xfa]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea3f74aac3881bb554add79c6a0cd25f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9353a70c3524dab3515af80a4a90acc/" rel="bookmark">
			Canal安装与配置，推送数据到kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：
canal主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费。所以前提基础是mysql。canal服务监听mysql服务的binlog日志，获取增量变更进行同步
前提说明：
本次安装配置是在公司的dev环境，实现的功能是：canal通过监听mysql服务的binlog日志，并将消息推送到kafka。具体服务器地址不便展示，大家使用自己的服务器地址即可。
配置说明：
mysql:
mysql服务器地址：xxxxx
mysql安装路径：/usr/local/mysql/mysql-8.0.11
mysql配置文件my.cnf路径：/etc
canal:
canal服务器地址：xxxxx
canal安装路径：/usr/local/canal
canal全局配置文件canal.properties：/usr/local/canal/conf
canal具体实例配置文件instance.properties：/usr/local/canal/conf/example
kafka:
kafka集群地址（测试环境）：xxxxxx
第一步：配置Mysql服务
a.首先判断mysql服务是否已经开启binlog，ON代表已开启，OFF代表未开启
如果OFF未开启，则需要在原有的mysql配置文件my.cnf中添加如下配置：
log-bin=mysql-bin # 打开二进制日志功能.
binlog-format=ROW # 日志中会记录每一行数据被修改的形式，
server-id=1 # 表明当前mysql服务器作为主服务器，id标识唯一，不可与其他slave重复
b.重启mysql服务
c.创建canal用户
mysql创建了canal用户,并开启远程连接，相当于模拟一个Mysql的slave
create user canal identified by 'canal';
赋予权限，必不可少
GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'canal'@'%';
flush privileges;
第二步：安装配置canal
a.下载：https://github.com/alibaba/canal/releases
b.解压
c.修改全局配置文件
关键配置文件参数说明：
canal.port = 11111 #对外提供的socket接口。如端口不冲突，使用默认即可
canal.serverMode = kafka # 这一步是关键，选择kafka的推送模式，发送kafka消息
kafka.bootstrap.servers = xxxxxx # 配置kafka服务器地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9353a70c3524dab3515af80a4a90acc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eaac1c0cef61d73c7048c904fa5d732/" rel="bookmark">
			MySQL删除视图（DROP VIEW）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		删除视图是指删除 MySQL 数据库中已存在的视图。删除视图时，只能删除视图的定义，不会删除数据。
基本语法 可以使用 DROP VIEW 语句来删除视图。
语法格式如下：
DROP VIEW &lt;视图名1&gt; [ , &lt;视图名2&gt; …] 其中：&lt;视图名&gt;指定要删除的视图名。DROP VIEW 语句可以一次删除多个视图，但是必须在每个视图上拥有 DROP 权限。
删除视图 【实例】删除 v_students_info 视图，输入的 SQL 语句和执行过程如下所示。
mysql&gt; DROP VIEW IF EXISTS v_students_info; Query OK, 0 rows affected (0.00 sec) mysql&gt; SHOW CREATE VIEW v_students_info; ERROR 1146 (42S02): Table 'test_db.v_students_info' doesn't exist 可以看到，v_students_info 视图已不存在，将其成功删除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/487f4a71032d7573e0c1289240011bbc/" rel="bookmark">
			Java实现多线程小记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java实现多线程小记 日常开发中会有用到多线程的场景，本文记载两种创建多线程的方式。话不多说，直接上代码。。。
package com; /** * @title: ThreadSync * @Author jishanfeng * @Date: 2022/9/21 19:50 * @Version 1.0 */ public class ThreadSync implements Runnable { volatile int tickets = 100; // 火车票 @Override public void run() { //出售火车票 while(true) { method2(); } } private synchronized void method2() { //同步方法的锁对象就是this对象 if (tickets &gt; 0) { try { Thread.sleep(100); //线程休眠 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + ":" + tickets--); } } public static void main(String[] args) { // 创建线程对象 ThreadSync tt = new ThreadSync(); Thread t = new Thread(tt); t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/487f4a71032d7573e0c1289240011bbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44c30e3475a5a6c82badfe16aa7a8ba3/" rel="bookmark">
			VScode编辑器快捷键整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录：VScode编辑器快捷键记录
1. 代码块折叠/展开 操作光标所在文件中的所有代码块： 折叠所有 Ctrl+K+0
展开所有 Ctrl+K+J
仅仅操作光标所处代码块内的代码： 折叠 Ctrl+Shift+[
展开 Ctrl+Shift+]
2.一键整理代码 在Windows环境快捷键：Shift + Alt + F
在Mac环境快捷键：Shift + Option + F
在Ubuntu环境快捷键：Ctrl + Shift + I
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40e3ef91dd3cf9597085bf453749afe3/" rel="bookmark">
			win10系统配置java环境保姆级教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1.进入到配置环境1.1 右键“此电脑”→点击“属性”1.2 进入到此界面后点击“高级系统设置”→“环境变量” 2.☆重点☆进入到环境变量的配置阶段2.1 编辑系统变量 3.测试java环境是否配置成功4.运行java文件5.开启java之旅 前言 下载jdk等步骤就不赘述了。下载好jdk之后，要记住jdk安装的路径。一般默认路径为C:\Program Files\Java\jdk1.8.0_221
1.进入到配置环境 1.1 右键“此电脑”→点击“属性” 1.2 进入到此界面后点击“高级系统设置”→“环境变量” 2.☆重点☆进入到环境变量的配置阶段 2.1 编辑系统变量 第一步： 双击打开Path→在打开的新窗口中点击新建，新增：%JAVA_HOME%\bin
再次新建，新增：%JAVA_HOME%\jre\bin
新增完了后点击确定，就会回到上一级界面了。
第二步： 双击打开CLASSPATH，如果没有就新建一个。
添加加粗部分 .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;
要注意：前面的点**.**也要加上去，很多人配环境就是这里配错了。如果编译环境出现了问题要记得检查这里。添加完后，点击确定即可，会自动回到上一级界面。
第三步： 点击新建，打开新建系统变量窗口，输入新的变量名为JAVA_HOME,变量值为你安装的jdk路径。编辑好后，点击确定。就这样，java环境就配置成功了。
3.测试java环境是否配置成功 先按windows键不动，再R键，在运行窗口输入cmd，然后点击确定，进入cmd窗口
（1）输入java -version，测试java版本
（2）输入java，测试jjdk环境
（3）输入javac，测试jre环境
4.运行java文件 (1)在任意一个盘符，比如 E盘新建一个文本文档命名为Test
(2)将该文本文档的.txt后缀改为 .java
注意： 要出现这样的提示并 点击确定才说明你改后缀成功了，如果没有出现这样的提示请看 （3） 。
（3）如果没有出现文件拓展名警告，则是你没有成功修改后缀。解决办法如下：
在该窗口下，点击查看，把文件拓展名给勾上：然后再进行 （2） 的操作就可以了。
（4）将以下代码复制到刚刚的Test.java文件中，打开java文件只需要点击右键，然后点击编辑即可：
public class Test{ public static void main(String args[]){ System.out.println("Hello Java!"); } } 保存好后进入到cmd界面。
（5）请保证Test.java文件的路径和我一致。我的java文件路径为：E:/Test.java
进入cmd后，输入E:，按回车，就进入到E盘了。请注意cmd输入的任何命令符号必须是英文半角符号！
（6）进入到E盘后，输入 javac.Test.java,该命令的意思是编译Test.java文件为字节码（class）文件。
（7）未出现报错情况下，再次输入java Test
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40e3ef91dd3cf9597085bf453749afe3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a643dded09a94d7b842dbde4a0e839cd/" rel="bookmark">
			【自动驾驶】模型预测控制(MPC)实现轨迹跟踪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 参考资料1. 基本概念1.1 MPC vs optimal control1.2 MPC优点 2. MPC整体流程2.1 预测区间与控制区间2.2 约束2.3 MPC流程2.4 MPC vs. LQR 3. MPC设计4. MPC应用——无人车轨迹跟踪4.1 MPC建模4.2 python代码实现4.2.1 参数4.2.2 运动学模型4.2.3 参考轨迹4.2.4 矩阵拍平4.2.5 角度归一化到[-pi，pi]4.2.6 MPC控制实现4.2.7 主函数 5. MPC开源库/程序 参考资料 bilibili的DR_CAN讲解的MPC模型预测控制器知乎上一个比较通俗易懂的解释模型预测控制轨迹跟踪模型预测控制(MPC)原理与python实现DR_CAN笔记MPCMPC控制笔记 1. 基本概念 模型预测控制（MPC）的核心思想就是以优化方法求解最优控制器，其中优化方法大多时候采用二次规划（Quadratic Programming）。
MPC控制器优化得到的控制输出也是系统在未来有限时间步的控制序列。 当然，由于理论构建的模型与系统真实模型都有误差，所以，实际上更远未来的控制输出对系统控制的价值很低，故MPC仅执行输出序列中的第一个控制输出。
模型(Model)
分为机理模型和基于数据的模型（例如用神经网络训练的一个model）使用基于数据的模型的MPC可以结合model based RL使用。
预测(Predict)
模型就是用来预测的，预测的目的是为了更好的决策
控制(Control)
控制即决策，根据预测来作出决策。
MPC利用一个已有的模型、系统当前的状态和未来的控制量，来预测系统未来的输出，然后与我们期望的系统输出做比较，得到一个损失函数（代价函数），即：
损失函数 = ( 未来输出 ( 模型，当前状态，未来控制量 ) − 期望输出 ) 2 损失函数 = (未来输出(模型，当前状态，未来控制量)-期望输出)^2 损失函数=(未来输出(模型，当前状态，未来控制量)−期望输出)2
由于上式中模型、当前状态、期望输出都是已知的，因此只有未来控制量一个自变量。采用二次规划的方法求解出某个未来控制量，使得损失函数最小，前面提到，这个未来控制量的第一个元素就是当前控制周期的控制量。
1.1 MPC vs optimal control 最优控制（optimal control）指的是在一定的约束情况下达到最优状态的系统表现，其中约束情况通常是实际环境所带来的限制，例如汽车中的油门不能无限大等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a643dded09a94d7b842dbde4a0e839cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/455a354b13f61ead245887add8d1b3bb/" rel="bookmark">
			webrtc如何修改udp端口限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有没有大佬知道怎么限制webrtc打开视频流时该如何在程序内限制能打开的端口范围啊，服务器的安全规则只开放临时端口，所以想把视频流打开的端口限制在临时端口之内
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a0c609910322b994e356bad938b36e4/" rel="bookmark">
			微信小程序 表格组件封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 公司要将一部分的功能转移到微信小程序上去做，其中有一个页面有表格，可是我搜了一下官方并没有表格组件，于是我便自己封装了一个（有参考别人的文章，出处忘记了）
最终效果 代码位置 组件代码 index.wxml
&lt;view class="table-box"&gt; &lt;view class="table"&gt; &lt;view class="tr"&gt; &lt;view class="th" wx:for="{{thead}}" wx:key="index"&gt;{{item.name}}&lt;/view&gt; &lt;/view&gt; &lt;view class="tr" wx:for="{{data}}" wx:for-item="row" wx:key="index"&gt; &lt;view class="td" wx:for="{{thead}}" bindtap="onclick" data-row="{{row}}" wx:key="index"&gt;{{row[item.key]}}&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; ps:这里我其实想把点击事件写到行上的，但是不知道到为什么传输的数据获取不到（微信小程序我是个小白，有大佬知道的话还请指导一下 ο(=•ω＜=)ρ⌒☆）
index.js
Component({ properties: { thead: { type: Array }, data: { type: Array }, onclick: { type: String } }, methods: { onclick(e) { //点击事件，将所点击那一行的数据传输到父组件 this.triggerEvent('getRowData', e.target.dataset.row) }, } }) index.wxss
.table-box{ height: 100%; overflow-x: auto; padding-bottom: 40rpx; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a0c609910322b994e356bad938b36e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f652a48df7ef610f42da74030cd0954/" rel="bookmark">
			mysql可重复执行增加字段脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 mysql可重复执行增加字段脚本
定义可执行存储过程的名称--ADD_TABLE_COLUMN编写IF NOT EXISTS中的脚本语句，查询某个字段是否存在不存在则执行then之后的新增脚本语句--脚本语句自定义call 当前的存储过程--执行当前的存储过程 DELIMITER // CREATE PROCEDURE ADD_TABLE_COLUMN() BEGIN IF NOT EXISTS (SELECT * FROM information_schema.COLUMNS WHERE table_name = 'xxx' AND column_name = 'xxx') THEN ALTER TABLE `xxx数据库名`.`xxx表名` ADD COLUMN `字段名` varchar(32) NULL COMMENT 'xx' AFTER `history_stage`; END IF; END; CALL ADD_TABLE_COLUMN; DROP PROCEDURE ADD_TABLE_COLUMN; // DELIMITER ; mysql可重复执行增加索引脚本
定义可执行存储过程的名称--ADD_TABLE_INDEX编写IF NOT EXISTS中的脚本语句，查询某个index_name是否存在不存在则执行then之后的新增索引脚本语句--索引脚本语句自定义call 当前的存储过程--执行当前的存储过程根据需要获取对应表内已存在的索引，注意，主键索引的名称即为PRIMARY DELIMITER // CREATE PROCEDURE ADD_TABLE_INDEX() BEGIN IF NOT EXISTS (SELECT * FROM information_schema.statistics WHERE table_name = '表名' AND index_name = '索引名称') THEN ALTER TABLE XX表 ADD PRIMARY KEY(id); END IF; END; CALL ADD_TABLE_INDEX; DROP PROCEDURE ADD_TABLE_INDEX; // DELIMITER ; //如果需要获取某个表的所有索引 可执行下方语句后获取Key_name即可 SHOW INDEX FROM TABLE_NAME; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e4f84f81c6b970182a91be3f74135fa/" rel="bookmark">
			OpenCV &#43; Kotlin 实现 USB 摄像头(相机)实时画面、拍照
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pexels-regina-trissteria-13623557.jpg Part1一. 业务背景 我们团队前段时间做了一款小型的智能硬件，它能够自动拍摄一些商品的图片，这些图片将会出现在电商 App 的详情页并进行展示。
基于以上的背景，我们需要一个业务后台用于发送相应的拍照指令，还需要开发一款软件(上位机)用于接收拍照指令和操作硬件设备。
Part2二. 原先的实现方式以及痛点 早期为了快速实现功能，我们团队使用 JavaCV 调用 USB 摄像头(相机)进行实时画面的展示和拍照。这样的好处在于，能够快速实现产品经理提出的功能，并快速上线。当然，也会遇到一些问题。
我列举几个遇到的问题：
软件体积过大
编译速度慢
软件运行时占用大量的内存
对于获取的实时画面，不利于在软件侧(客户端侧)调用机器学习或者深度学习的库，因为整个软件采用 Java/Kotlin 编写的。
Part3三. 使用 OpenCV 进行重构 基于上述的原因，我尝试用 OpenCV 替代 JavaCV 看看能否解决这些问题。
13.1JNI 调用的设计 由于我使用 OpenCV C++ 版本来进行开发，因此在开发之前需要先设计好应用层(我们的软件主要是采用 Java/Kotlin 编写的)如何跟 Native 层进行交互的一些的方法。比如：USB 摄像头(相机)的开启和关闭、拍照、相机相关参数的设置等等。
为此，设计了一个专门用于图像处理的类 WImagesProcess(W 是项目的代号)，它包含了上述的方法。
object WImagesProcess { init { System.load("${FileUtil.loadPath}WImagesProcess.dll") } /** * 算法的版本号 */ external fun getVersion():String /** * 获取 OpenCV 对应相机的 index id * @param pidvid 相机的 pid、vid */ external fun getCameraIndexIdFromPidVid(pidvid:String):Int /** * 开启俯拍相机 * @param index 相机的 index id * @param cameraParaMap 相机相关的参数 * @param listener jni 层给 Java 层的回调 */ external fun startTopVideoCapture(index:Int, cameraParaMap:Map&lt;String,String&gt;, listener: VideoCaptureListener) /** * 开启侧拍相机 * @param index 相机的 index id * @param cameraParaMap 相机相关的参数 * @param listener jni 层给 Java 层的回调 */ external fun startRightVideoCapture(index:Int, cameraParaMap:Map&lt;String,String&gt;, listener: VideoCaptureListener) /** * 调用对应的相机拍摄照片，使用时需要将 IntArray 转换成 BufferedImage * @param cameraId 1:俯拍相机; 2:侧拍相机 */ external fun takePhoto(cameraId:Int): IntArray /** * 设置相机的曝光 * @param cameraId 1:俯拍相机; 2:侧拍相机 */ external fun exposure(cameraId: Int, value: Double):Double /** * 设置相机的亮度 * @param cameraId 1:俯拍相机; 2:侧拍相机 */ external fun brightness(cameraId: Int, value: Double):Double /** * 设置相机的焦距 * @param cameraId 1:俯拍相机; 2:侧拍相机 */ external fun focus(cameraId: Int, value: Double):Double /** * 关闭相机，释放相机的资源 * @param cameraId 1:俯拍相机; 2:侧拍相机 */ external fun closeVideoCapture(cameraId:Int) } 其中，VideoCaptureListener 是监听 USB 摄像头(相机)行为的 Listener。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e4f84f81c6b970182a91be3f74135fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b81fff8644418fe9a4f3cffd8cd0ea94/" rel="bookmark">
			到底什么是IO的驱动能力？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常会听到MCU某I/O的驱动能力是xxmA，那么到底什么是驱动能力呢？如果某IO的驱动能力是5mA，它就输出不了超过5mA的电流了吗？为什么IO的驱动能力有差异呢？
要回答以上问题，需要先了解MCU内部的I/O结构，
(本图来源于STM32F103参考手册）
当输出高电平1时，I/O内部VDD经过PMOS流向I/O引脚，如下图红色箭头所示，
这时驱动能力是指，在输出电流小于等于最大输出电流的情况下，I/O引脚可以正常的输出逻辑1。
P-MOS管的源极(S)接VDD，当MCU输出1时，P-MOS管导通，电流从源极(S)流向漏极(D)。I/O引脚外接负载大小不同，流过P-MOS管的电流、VDS(源漏电压)就会不同。输出电流越大，VDS越大，I/O电压就越小。当电压低到Voh时的这个输出电流，就表示驱动能力。
当输出低电平0时，I/O引脚经过N-MOS流向I/O内部VSS，如下图红色箭头所示
这时驱动能力是指，在小于等于最大输入电流的情况下，I/O引脚可以正常的输出逻辑0。道理同上，流过N-MOS电流越大，N-MOS产生压降越大，I/O口电压越大。当电压达到逻辑0的最高电压Vol时，这时的电流就表示驱动能力。
以上看明白后，文章开头的3个问题也就有了答案，
1）I/O驱动能力是指在同时满足Voh(输出引脚为逻辑1时的最小电压值) 和 Vol(输出引脚为逻辑0时的最大电压值）前提下，最大可以输出和吸收的电流大小。Voh和Vol的值在芯片数据手册中是可以查到的。
2）如果某I/O的驱动能力是5mA，并不是表示它输出不了超过5mA的电流，只是当输出电流超过5mA之后，它的输出电压会下降，电压会小于Voh。
3）I/O驱动能力的差异来源于MOS管自身的特性，要想过电流能力大，MOS管体积就要大，芯片所需的面积就会更大，成本自然也会更高。所以通常MCU只是一部分I/O具有高驱动能力，并不是每一个I/O都做成了高驱动能力。
说了这么多，其实可以用下面这个简单的电路来解释，
MCU的IO引脚上外接一个电阻，只要这个电阻不是太小，那么IO引脚的电压是基本不变的，只是微小的下降。
感兴趣的可以实际测试下，不过要注意别把电流整太大烧坏IO哦。
更多精彩内容：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40fb0e5288fdeb6d22c78255041cbf71/" rel="bookmark">
			有道词典离线数据包位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件版本：9.1.0
位置：C:\Users\用户名\AppData\Local\Yodao\DeskDict\nmt_model
将离线包放入nmt_model文件夹后重新启动有道词典即可断网使用长句翻译。
汉英互译离线包蓝下载：点这里 提取码：40bw
测试如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99b72194d41208b615575f3cf7337a4f/" rel="bookmark">
			如何确定22端口是否开启(确定ssh服务是否开启)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		远程连接必要的信息:
1. IP地址 网络上唯一的 类似家庭住址
10.0.0.200
2. 端口默认的22
端口对应着不同的服务 22--&gt;SSH服务(可以让用户通过远程工具连接我 类似于向日葵 类似QQ远程连接) 端口号类似于去公园 1--&gt;售票 2--&gt;退票 3---&gt;军人老人优先 4--&gt;紧急救援
如何确定22端口是否开启(确定ssh服务是否开启)
使用telnet命令判断22端口是否开启 两种方法: 两种选其一测试 第一种方法 windows 视窗+r 调出运行窗口 ---&gt; 输入cmd回车
在cmd窗口输入: telnet 10.0.0.200 22
如果执行失败: 操作在QQ记录中
第二种方式: 打开xshell 点击+ 进入本地windows的shell界面
[c:\~]$ telnet 10.0.0.200 22
Connecting to 10.0.0.200:22...
Connection established. # 表示连接已经建立成功
To escape to local shell, press 'Ctrl+Alt+]'.
SSH-2.0-OpenSSH_7.4 # SSH的版本号信息
连接失败显示:
[c:\~]$ telnet 10.0.0.200 23
Connecting to 10.0.0.200:23...
Could not connect to '10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99b72194d41208b615575f3cf7337a4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9184c01390e868b8524e84b81941a91f/" rel="bookmark">
			【GAMES-104现代游戏引擎】3、游戏架构（Tick函数，组件模式，事件系统，场景划分算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lecture3 1 游戏对象GO（Game Object）1.1 面向对象的GO1.2 面向组件的GO 2 Tick()函数3 事件（Event）4 场景管理5 总结 1 游戏对象GO（Game Object） 游戏世界中的天空、植被、地形、玩家、NPC等等所有游戏对象都统称为 GO（Game Object）
如何描述一个GO?
1.1 面向对象的GO 一个GO类应该包含属性和行为，比如一个无人机可以如下定义
（为了教学目的 不同于一般游戏引擎，引擎基本上都有一个基类 class Object 作为所有其他对象的基类，Name这种极为通用的属性一般是在Object类中定义的）
根据上方法定义出一个无人机类后，我们还可以派生出一个附带攻击能力的无人机
缺点：面向对象的设计理念在游戏中会很容易出现 菱形继承，比如水陆两栖坦克的爷爷到底是船还是车？这里就引出了新的设计理念： 组件（Component） 1.2 面向组件的GO 组件模式是目前绝大部分引擎所采用的方式（UE、Unity等）
此时我们设计一个无人机就非常灵活，一个无人机类需要什么组件就给他加什么组件，让其拥有飞行器的外表、位移飞行能力、自动索敌AI、飞行动画等等
以C++为例，我们必须定义一个 ComponentBase 基类，因为所有的组件类都需要一个tick()函数，所以设计一个基类一方面方便管理，另一方面提供一个纯虚函数tick()，GameObjectBase 基类也同理。给每个组件子类定义属性和行为，最终全部附加给飞行器类，飞行器就拥有了这所有的组件的功能
现代游戏引擎中每个GO都必须拥有tick()函数，还需要一个最顶层基类统一管理所有GO的生命周期，因此以Unreal Engine为例，他的最顶层的基类为UObject，其下才是 AActor 和 UActorComponent
总之游戏中所有的元素都被称为GO，每一个GO都是由多个组件构成
2 Tick()函数 Tick函数是游戏世界内最重要的一个函数，也是最基本的时间度量单位
如何使游戏世界动起来？—— 每一次tick，都读取一遍输入，走一遍逻辑计算，再走一遍渲染，就能得到新的一帧画面，这样世界就动起来了。
Tick又被分为两种
Object-based Tick：在每个Tick内，调用每个GO的tick()，每个GO再调用自己的每个组件tick()，很直观，不高效
Component-based Tick：现代游戏引擎都是 按照组件系统进行tick 。各个组件系统依次调用Tick函数，比如先将所有Motor组件计算一遍，再计算Controller组件…。这样流水线般的处理方式效率更高
Tick的先后顺序
面向GO的Tick，基本不会出现先后顺序的麻烦问题，因为GO之间如果是绑定的状态，按照逻辑顺序的话应该是 父节点先于子节点执行tick()，但是现代的tick系统都是逐组件批量计算的！面向组件的tick处理方式，一般而言，为了快，像上图这种的，每个组件系统是放到不同线程上计算，这里面就存在非常头疼的时序问题！ 如：对象1给对象2发送一封分手信，对象2也给对象1发送了一封，第二帧的时候，双方同时看到这封分手信，到底是谁甩了谁？不知道。我们没有办法确定哪一方先发送。这就存在不确定性，我们相同的输入，在同一个游戏产生了不确定的结果游戏回放功能是记录的用户的输入，回放时根据记录的输入重新跑一遍游戏，因此同一输入不能产生二义性这时我就们需要一个中介的事件发送器来转发事件，并确定Tick的时序。 其中的小细节非常多，许多组件都是循环依赖互相影响的，总之多线程tick时序问题，需要重点关注 3 事件（Event） GO之间是需要通信的
硬编码（Hardcode）通信（不好用） 以坦克发射炮弹为例，定义一个炮弹对象，在炮管处发射之后，每个tick往前走一点，当碰撞系统计算出 炮弹与地面或者其他GO接触时，炮弹就要发出一个我要炸了事件，在其爆炸时检查周围GO的类型，传入switch中判断类型，是什么GO就执行对应的行为(扣血、消失、破坏等)这种写死的方式很符合直觉，但是当GO类型特别多的时候，这将是一场噩梦
Event事件通信 消息发送与接受，炮弹爆炸，发送事件给目标GO，目标GO在下个tick()进行响应这就通过事件机制达到 解耦合（Decouple） 的效果。本来如果是硬编码，我们需要知道其他所有可能的对象类型包括每个GO中的组件类型，这实在是太复杂了。事件机制只需要发送一个事件给对应的GO，对应的GO自己来处理这个事件即可 商业引擎中的 事件机制 unity中就是简单的注册一个事件ApplyDamage 从一个GO发送消息，所有与其相关的GO如果内部实现了处理函数会接收到消息并处理UE4中会相对复杂一些，注册event的时候，需要反射到蓝图上，所以有些反射代码会比较头疼
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9184c01390e868b8524e84b81941a91f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9d53161d897f8dffd57a88710d4af7b/" rel="bookmark">
			C&#43;&#43;去除字符串空格和换行符（函数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考链接：链接
代码：
string get_string(string res) { //删除换行符 int r = res.find('\r\n'); while (r != string::npos) { if (r != string::npos) { res.replace(r, 1, ""); r = res.find('\r\n'); } } //删除所有空格 res.erase(std::remove_if(res.begin(), res.end(), std::isspace), res.end()); return res; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33bf47b007dd1da9e3f890a66e5bb902/" rel="bookmark">
			element-ui tab切换：切换时，Echarts宽度只有100px，实际宽度改为100%
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近在项目中需要在tab控件上渲染多个echart图表，然后切换查看时，发现图表的宽度不正确，只有100px,效果如下：
代码如下：
&lt;el-tab-pane label="各区" name="area"&gt; &lt;chart&gt;&lt;/chart&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane label="每月" name="month"&gt; &lt;chart&gt;&lt;/chart&gt; &lt;/el-tab-pane&gt; 分析:这种写法会导致页面一次完成渲染，应在切换tab时再进行渲染。
解决方案：切换tab时进行渲染，可用v-if控制echarts显隐。
解决代码如下：
//tabActiveName tab当前tab名称 与key值一致 //consultationTabList: [{ label: '各区', key: 'area' }, { label: '每月', key: 'month' }], //切换事件 handleTabClick //handleTabClick(tab, event) { //const { paneName } = tab; //this.tabActiveName = paneName; //}, //chart 自定义图表 &lt;el-tabs v-model="tabActiveName" @tab-click="handleTabClick"&gt; &lt;el-tab-pane v-for="item in consultationTabList" :label="item.label" :key="item.key" :name="item.key"&gt; &lt;chart v-if="item.key === tabActiveName"&gt;&lt;/chart&gt; &lt;/el-tab-pane&gt; &lt;/el-tabs&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43d8a382e06a09c5e5d5fb7e08708b2a/" rel="bookmark">
			初识c语言（指针）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内存 开始讲内存得先从起源开始，32位计算机中一共有32根地址线（物理线），当地址线全部通上电后，会有高低电平之分，即1或0。此时电信号转化为数字信号，那么就组成了由0和1形成的二进制序列，一共有2的32次方种二进制序列，那么每一种二进制序列皆可作为内存编号（这些编号也被称为 内存单元地址）
内存单元的大小 一个内存单元会有多大？是个好问题，首先我们要知道，每个地址定义一个内存单元，而c语言中，最小单位的字符是char，共占一个字节，而一个字节又是八个比特位，用一个bit来表示一个内存单元的话，未免有点太过细节，于是，便定义一个内存单元为1byte
取出地址 变量是创建内存中的（在内存中分配空间的），每个内存单元都有地址，所以变量也是有地址的。 取出变量地址如下： #include &lt;stdio.h&gt; int main() { int num = 10; &amp;num;//取出num的地址 //注：这里num的4个字节，每个字节都有地址，取出的是第一个字节的地址（较小的地址） printf("%p\n", &amp;num);//打印地址，%p是以地址的形式打印 return 0; 怎么在vs2019查看内存呢 要先按f10开始调试，然后才会有窗口下的一系列操作
在内存上可以直接用&amp;符号，来获取变量的地址（第一个字节的地址）
地址如何储存？ 如题，要储存地址的话，就要定义指针变量
int num = 10; int *p = &amp;num;//p为一个整形指针变量 int*说明p为指针变量，而该指针的变量类型则与取地址后的变量类型一致
解引用操作符 既然上文已经说到了p为指针变量，那么继续沿用
#include &lt;stdio.h&gt; int main() { int num = 10; int *p = &amp;num; *p = 20; return 0; } 此时用printf打印出来num的值时，则表达出20，因为*（解引用操作符）可以通过指针找到指向的对象，即num
解引用操作符通过指针可以直接找到变量num的并改变其大小。
到这里，其实讲白了，指针就是地址。
指针大小 在一台机器上，指针的大小都是相同的
为什么呢，因为指针是表示地址，所以指针的大小取决于地址存储需要多大
而在32位机器上，一共有32个比特位组成一个地址（二进制序列），那么就是4字节
在64位上同理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be9b1ae6ac800193548787b4d3affc5a/" rel="bookmark">
			Python收集excel中的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求描述：数据收集部门下发统一excel模板到各部门，各部门根据实际情况填写数据后交由数据收集部门统一整理后录入系统。
问题点：虽然有统一的模板，但收集上来的数据还是存在差异。比如有的部门很大，统计的时候收集了多个excel，每个excel中又包含了众多的sheet。还存在对模板进行二次加工，比如在最前面插入几列，用于自己的备注，但提交前只是对列做了隐藏，或者添加了自己的sheet，最后提交前也做了隐藏。
所以本次程序需要解决几个点：
1、能够一次性读取文件夹下所有的excel文件，以及excel里非隐藏的sheet；
2、自动判断sheet是否为按照模板填写的有效数据；
3、对因为合并单元格而缺失的数据进行补全；
4、只读取指定的列数据。
前置条件：使用pandas和openpyxl来处理数据。
读取文件夹下所有的excel文件
def listdir(path, list_name): #传入存储的list # 循环目标路径下所有文件目录及名称 for dirpath,dirnames,filenames in os.walk(path): for filename in filenames: # 剔除缓存的表 extName = os.path.splitext(filename) if(extName[0].find("~") &gt;= 0 or extName[0].find("$") &gt;= 0): continue print(os.path.join(dirpath,filename)) list_name.append(os.path.join(dirpath,filename)) 读取文件的内容
#读取excel wb = load_workbook(filename) # 获取workbook中所有非隐藏的表格 all_sheet_name = wb.sheetnames useful_sheet = [i for i in all_sheet_name if wb[i].sheet_state != 'hidden'] 补全缺失的单元格
#补全被合并单元格的数据 fdata['单位'].fillna(method='ffill',inplace=True) 完整的代码如下：
import os import pandas as pd import openpyxl from openpyxl import load_workbook def listdir(path, list_name): #传入存储的list # 循环目标路径下所有文件目录及名称 for dirpath,dirnames,filenames in os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be9b1ae6ac800193548787b4d3affc5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/943877714d59ddc3e31226f58fade37f/" rel="bookmark">
			【堡垒机】jumpserver简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jumpserver 简介什么是堡垒机？JumpServer 概述JumpServer实现的功能1.身份认证（Authentication）2.账号管理（Account）3.授权控制（Authorization）4.安全审计（Audit） 总结【参考】 简介 Jumpserver 是全球首款完全开源、符合 4A 规范（包含认证Authentication 、授权 Authorization、账号 Accounting 和审计 Auditing）的运维安全审计系统，Jumpserver 通过软件订阅服务或者软硬件一体机的方式，向企业级用户交付多云环境下更好用的堡垒机。
什么是堡垒机？ 堡垒机是从跳板机（也叫前置机）的概念演变过来的。早在2000年左右，一些中大型企业为了能对运维人员的远程登录进行集中管理，会在机房部署一台跳板机。
跳板机（前置机）
跳板机其实就是一台unix/windows操作系统的服务器，所有运维人员都需要先远程登录跳板机，然后再从跳板机登录其他服务器中进行运维操作。
但跳板机并没有实现对运维人员操作行为的控制和审计，使用跳板机过程中还是会有误操作、违规操作导致的操作事故，一旦出现操作事故很难快速定位原因和责任人。此外，跳板机存在严重的安全风险，一旦跳板机系统被攻入，则将后端资源风险完全暴露无遗。
堡垒机
人们逐渐认识到跳板机的不足，进而需要更新、更好的安全技术理念来实现运维操作管理。需要一种能满足角色管理与授权审批、信息资源访问控制、操作记录和审计、系统变更和维护控制要求，并生成一些统计报表配合管理规范来不断提升IT内控的合规性的产品。
这就是堡垒机诞生的契机。
堡垒机设计理念
堡垒机主要是有4A理念。
认证（Authen）授权（Authorize）账号（Account）审计（Audit） JumpServer 概述 JumpServer是全球首款完全开源的堡垒机，使用GNU GPL v2.0开源协议，是符合4A的专业运维审计系统。JumpServer使用Python\Django开发，遵循Web 2.0规范，配备了业界领先的web Terminal（web终端，即网页终端）解决方案。JumpServer采用分布式结构，支持多机房跨区域部署，中心节点提供API（接口），各机房部署登录节点，可以横向扩展，并且没有并发限制。JumpServer为互联网企业提供了认证、授权、审计、自动化运维等功能。JumpServer通过调用各种应用程序的模块来实现各种功能。 JumpServer实现的功能 1.身份认证（Authentication） 功能简介用户组、用户添加组方便进行授权，用户是授权和登录的主体，用户可以加入用户组，进行批量管理。资产组、资产、IDC资产就是管理的机器（主机），主机信息简洁完整，用户自定义备注登录，支持自动获取主机的硬件信息，资产同样可以加入资产组，进行批量管理。sudo、系统用户、授权规则支持sudo用户授权，系统用户用于登录客户端，授权规则是将用户、资产和系统用户关联起来。在线历史、登录历史、命令记录、上传下载记录在线实时监控用户操作，统计用户命令记录，录像回放用户操作内容，阻断控制，详细记录用户上传和下载。上传、下载支持文件的上传和下载，实现方式是使用rz（上传）和sz（下载）命令。默认设置默认管理用户，设置包括用户密码密钥，默认信息为了方便添加资产而设计。 2.账号管理（Account） 功能简介集中账号管理用户管理系统用户管理统一密码资产密码托管自动生成密码自动推送密码密码过期设置批量改密（X-PACK）定期批量改密多种密码策略多云纳管（X-PACK）对私有云、公有云资产自动统一纳管收集用户（X-PACK）自定义任务定期收集主机用户密码匣子（X-PACK）统一对资产主机的用户密码进行查看、更新、测试操作 3.授权控制（Authorization） 功能简介多维授权对用户、用户组、资产、资产节点、应用以及系统用户进行授权资产授权资产以树状结构进行展示资产和节点均可灵活授权节点内资产自动继承授权子节点自动继承父节点授权应用授权实现更细粒度的应用级授权MySQL 数据库应用、RemoteApp 远程应用（X-PACK）动作授权实现对授权资产的文件上传、下载以及连接动作的控制时间授权实现对授权资源使用时间段的限制特权指令实现对特权指令的使用（支持黑白名单）命令过滤实现对授权系统用户所执行的命令进行控制文件传输SFTP 文件上传/下载文件管理实现 Web SFTP 文件管理工单管理（X-PACK）支持对用户登录请求行为进行控制组织管理（X-PACK）实现多租户管理与权限隔离 4.安全审计（Audit） 功能简介操作审计用户操作行为审计会话审计在线会话内容审计历史会话内容审计录像审计支持对 Linux、Windows 等资产操作的录像进行回放审计支持对 RemoteApp（X-PACK）、MySQL 等应用操作的录像进行回放审计指令审计支持对资产和应用等操作的命令进行审计文件传输可对文件的上传、下载记录进行审计 总结 JumpServer是一款符合企业实际应用的开源堡垒机软件，功能强大且广受欢迎。
附JumpServer案例：
【参考】 【1】什么是堡垒机？为什么需要堡垒机？——xcbeyond
【2】JumpServer堡垒机——礁之
【3】JumpServer介绍——风雨兼程，披星戴月。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b87db553d300ef7883a74721112839a/" rel="bookmark">
			使用vuepress搭建文档站点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，本地搭建 快速开始同 VuePress 官网：
1，创建新文件夹并进入 mkdir vuepress-test cd vuepress-test 2,初始化项目 yarn init 或者npm init 3, 安装VuePress yarn add -D vuepress 或者 npm install -D vuepress 4，Vuepress默认以docs作为根目录，所以README.md是主页 新建docs文件夹，然后在该文件夹下新建README.md文件。
--- home: true heroImage: /images/logo.PNG heroText: Hero 标题 tagline: Hero 副标题 actionText: 快速上手 → actionLink: /zh/guide/ features: - title: 简洁至上 details: 以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。 - title: Vue驱动 details: 享受 Vue + webpack 的开发体验，在 Markdown 中使用 Vue 组件，同时可以使用 Vue 来开发自定义主题。 - title: 高性能 details: VuePress 为每个页面预渲染生成静态的 HTML，同时在页面被加载的时候，将作为 SPA 运行。 --- ::: slot footer 修改了底部 ::: 5，基础配置 在文档目录下创建一个 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b87db553d300ef7883a74721112839a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/613178727a12d350b44fd5137681bb15/" rel="bookmark">
			【javascript】window.devicePixelRatio 设备像素比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 平时在shader代码中会使用到这个devicePixelRatio，这里记录一下其含义
含义 window.devicePixelRatio = 物理像素 / 逻辑像素
这里物理像素是指电脑分辨率，逻辑像素指的是如css像素
正常人眼可以识别的分辨率为 300PPI，而现在很多设备的分辨率都超过 300PPI，如果设备总是以满分辨率来显示东西就可能造成文字太小无法看清，因此像浏览器这样的软件就会对内容做一次放大后再进行渲染（也就是降低分辨率）：要降低分辨率就需要让像素这个单位变大，因此 PPI 的计算不再使用物理像素，而改用设备独立像素，那么设备独立像素和物理像素之间就存在一个比例差异，这就是 设备像素比。
应用 可以参考该例子，了解其用处https://juejin.cn/post/6885673542642302984
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/229/">«</a>
	<span class="pagination__item pagination__item--current">230/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/231/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>