<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9377714e80c7bb00c8e295ef8618e96/" rel="bookmark">
			vue3&#43;ts报错解决：无法找到模块“xxx.vue”的声明文件 xxx隐式拥有 “any“ 类型。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 出现该错误的原因：typescript 不能识别 .vue 文件
解决方法：
可以在 vite-env.d.ts 文件中添加以下代码，如果没有 vite-env.d.ts ，可以自己新建一个 xxx.d.ts 类型的文件即可
declare module '*.vue' { import { ComponentOptions } from 'vue' const componentOptions: ComponentOptions export default componentOptions } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/413bd46bb595d72fed7a45e9c57b3219/" rel="bookmark">
			mac安装n管理node版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用 npm 安装 n $ npm install -g n 或者 $ brew install n $ n -V（大写的V） 查看 n 是否安装成功 查看已安装的 node 列表 $ n ls 查看官方所有的 node 版本 $ npm view node versions 安装指定版本16.17.0的 node $ n 16.17.0 切换 node 版本(通过上下键选择，回车键确定) $ n 卸载n $ npm uninstall n -g 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c257839fdf7b6f5cadfd3caf3f9b2f59/" rel="bookmark">
			linux服务器安装screen
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 由于实验经常在远程或者本地服务器上跑，为了能让程序在我们关掉窗口后仍能正常跑，通常需要在服务器上安装screen。
本文主要参考了【工具】Linux screen的在线安装和离线安装和使用（训练模型时非常有帮助）_screen tar.gz_我叫鱼大的博客-CSDN博客
第一步：下载screen和ncurses安装包
首先下载screen-4.6.0.tar.gz：下载地址：http://ftp.gnu.org/gnu/screen/
然后下载ncurses-6.1.tar.gz: 下载地址：http://ftp.gnu.org/gnu/ncurses/
第二步：安装ncurses
我在安装的时候报了permission denied的错，所以可以进root模式：
sudo su 然后解压并安装：
tar -zxvf ncurses-6.1.tar.gz cd ncurses-6.1 mkdir build &amp;&amp; cd build ../configure make &amp;&amp; make install 第三步：安装screen
tar -zxvf screen-4.6.0.tar.gz cd screen-4.6.0 mkdir build &amp;&amp; cd build ../configure make &amp;&amp; make install 安装完成之后就可以使用screen了。
# 新建窗口 screen -S 窗口名称 # 查看窗口列表 screen -ls # 恢复离线窗口 screen -r 窗口名称 # 离开并挂起当前窗口，后台扔继续运行 ctrl+a+d # 关闭窗口不再保留 exit 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f38a3d39611823997863cd28ba9d814/" rel="bookmark">
			【STM32单片机】STM32F103 串口1 串口2 串口3 串口4 串口5 初始化，标准库 ，支持printf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 单片机介绍引脚DMA—直接存储器访问串口 引脚串口1，初始化，发送与接收串口2，初始化，发送与接收串口3，初始化，发送与接收串口4，初始化，发送与接收串口5，初始化，发送与接收 单片机介绍 STM32F103RCT6是一款主流性能系列的单片机，采用Arm Cortex-M3内核，具有256K字节的Flash存储器，72 MHz的CPU频率，支持电机控制、USB和CAN等功能。
该产品已经批量生产，10kU的单价为4.0035美元，采用LQFP 64封装，尺寸为10x10x1.4mm。
STM32F103xC、STM32F103xD和STM32F103xE性能系列产品采用高性能的ARM Cortex-M3 32位RISC内核，工作频率为72 MHz。它们拥有高速嵌入式存储器（Flash存储器最高达512K字节，SRAM最高达64K字节），以及广泛的增强型I/O口和外围设备，可以连接两个APB总线。所有这些设备都提供了三路12位ADC、四个通用16位定时器和两个PWM定时器，以及标准和高级通信接口：最多两个I2C接口、三个SPI接口、两个I2S接口、一个SDIO接口、五个串行USART接口、一个USB接口和一个CAN接口。
STM32F103xC/D/E高密度性能系列单片机可在-40℃至+105℃的温度范围内工作，电源电压为2.0至3.6V。它们具有一套全面的省电模式，适用于低功耗应用的设计。
这些特性使得STM32F103xC/D/E高密度性能系列单片机非常适合广泛的应用领域，如电机驱动、应用控制、医疗和便携设备、个人电脑和游戏外围设备、GPS平台、工业应用、可编程逻辑控制器（PLC）、变频器、打印机、扫描仪、报警系统、视频对讲系统和暖通空调系统等。
主要特性包括：
72 MHz的最大频率，每MHz可执行1.25 DMIPS（Dhrystone 2.1）指令
单周期乘法和硬件除法
256至512 K字节的Flash存储器
最多64 K字节的SRAM
灵活的静态存储器控制器，支持紧凑型Flash、SRAM、PSRAM、NOR和NAND存储器
LCD并行接口，支持8080和6800模式
2.0至3.6 V的应用供电和I/O口电压
POR（上电复位）、PDR（电源降低复位）和可编程电压检测器（PVD）
4至16 MHz的晶振和内部8 MHz的出厂修裁RC振荡器
带校准的内部40 kHz RC振荡器
带校准的32 kHz时钟用于RTC（实时时钟）
低功耗模式：休眠、停止和待机
VBAT供电用于RTC和备份寄存器
3路12位、1微秒的A/D转换器（最多21个通道），输入范围为0至3.6 V
三路采样和保持功能，温度传感器
2路12位D/A转换器
支持DMA（直接内存访问）的外设包括定时器、ADC、DAC、SDIO、I2S、SPI、I2C和USART
调试模式：串行线调试（SWD）和JTAG接口，Cortex-M3嵌入式追踪宏单元
最多112个快速I/O口，51/80/112个I/O口，可以映射到16个外部中断向量上，几乎所有的I/O都能耐受5V电平
最多11个定时器，包括四路16位定时器，每个定时器可配置为4路输入捕获/输出比较/脉冲宽度调制（PWM）或脉冲计数器及象限（增量）编码器输入；两路带死区生成和紧急停止功能的16位电机控制PWM定时器；两路看门狗定时器（独立和窗口）；SysTick定时器，用于倒计时的24位；
最多13个通信接口，包括最多2个I2C接口（支持SMBus/PMBus）、最多5个USART接口（支持ISO 7816接口、LIN、IrDA功能、调制解调器控制）、最多3个SPI接口（18 Mbit/s），其中2个带I2S接口复用，CAN接口（2.0B主动型）、USB 2.0全速接口、SDIO接口
CRC（循环冗余校验）计算单元，96位唯一标识符
ECOPACK®封装形式。
引脚 DMA—直接存储器访问 看看资料：
https://doc.embedfire.com/mcu/stm32/f103mini/std/zh/latest/book/DMA.html
DMA控制器包含了DMA1和DMA2，其中DMA1有7个通道，DMA2有5个通道， 这里的通道可以理解为传输数据的一种管道。要注意的是DMA2只存在于大容量产品和互联型产品中。
STM32F103RCT6 是大容量产品。256K。
小容量产品是指闪存存储器容量在16K至32K字节之间的STM32F101xx、STM32F102xx和 STM32F103xx微控制器。
中容量产品是指闪存存储器容量在64K至128K字节之间的STM32F101xx、STM32F102xx和 STM32F103xx微控制器。
大容量产品是指闪存存储器容量在256K至512K字节之间的STM32F101xx和STM32F103xx微控 制器。
互联型产品是指STM32F105xx和STM32F107xx微控制器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f38a3d39611823997863cd28ba9d814/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bab4067949ff5bb8f1e2b8881094749c/" rel="bookmark">
			Selenium 三种等待方式详解 （强制等待、隐式等待、显示等待）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 ①在进行WEB自动化工作时，一般要等待某一页面元素加载完成后，才能对该元素执行操作，否则自动化脚本会抛出找不到元素的错误，这样就要求我们在UI自动化测试的有些场景上加上等待时间。
②等待方式的设置是保证自动化脚本稳定有效运行的一个非常重要的手段。
强制等待 sleep() ①强制等待，设置固定休眠时间。
②python 的 time 包提供了休眠方法 sleep() ； 导入 time 包后就可以使用 sleep() ，进行脚本的执行过程进行休眠。
代码如下：
# coding = utf-8 from time import sleep from selenium import webdriver # 驱动文件路径 driverfile_path = r'D:\coship\Test_Framework\drivers\chromedriver.exe' # 启动浏览器 driver = webdriver.Chrome(executable_path=driverfile_path) # 打开百度首页 driver.get(r'https://www.baidu.com/') # 等待3秒 sleep(3) driver.find_element_by_css_selector("#kw").send_keys("selenium") # 退出 driver.quit() 隐式等待driver.implicitly_wait(time) ①相当于设置全局的等待，在定位元素时，对所有元素设置超时时间。
②设置一个等待时间，如果在这个等待时间内，网页加载完成，则执行下一步；否则一直等待时间截止，然后再执行下一步。这样也就会有个弊端，程序会一直等待整个页面加载完成，直到超时，但有时候我需要的那个元素早就加载完成了，只是页面上有个别其他元素加载特别慢，我仍要等待页面全部加载完成才能执行下一步。
③隐式等待使得 WebDriver 在查找一个 Element 或者 Elements 数组时，每隔一段特定的时间就会轮询一次DOM，如果 Element 或 Elements 数组没有马上被发现的话。默认设置是0。一旦设置，这个隐式等待会在WebDriver对象实例的整个生命周期起作用。
# coding = utf-8 from selenium import webdriver # 驱动文件路径 driverfile_path = r'D:\coship\Test_Framework\drivers\chromedriver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bab4067949ff5bb8f1e2b8881094749c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4b494e816c7a8fd504e04e57110692d/" rel="bookmark">
			Manifest merger failed : Apps targeting Android 12 and higher are required to specify an explicit va
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 感谢阅读 android:exported="true"讲这句话填到清单里面 我的如下： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fc0b1d371209ef725ca3ec8ca4b83c5/" rel="bookmark">
			Sumo中Traci.trafficlight详解（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sumo中Traci.trafficlight详解（上） 记录慢慢学习traci的每一天，希望也能帮到你
文章目录 Sumo中Traci.trafficlight详解（上）Traci.trafficlight信号灯参数讲解1.getAllProgramLogics(self,tlsID)2.getBlockingVehicles(self, tlsID, linkIndex)3.getConstraints(self, tlsID, tripId='')4.getConstraintsByFoe(self, foeSignal, foeId='')5.getControlledLanes(self, tlsID)6.getControlledLinks(self, tlsID)7.getNemaPhaseCalls(self, tlsID)8.getNextSwitch(self, tlsID)9.getPhase(self, tlsID) 、getPhaseDuration(self, tlsID)、getPhaseName(self, tlsID) Traci.trafficlight 导入库
import traci #这里不需要全部导入 信号灯参数讲解 getAllProgramLogics(ID)输入为信号灯ID，其中xml文件中对信号灯的定义方式如下：
&lt;tlLogic id="0" type="static" programID="0" offset="0"&gt; &lt;phase duration="31" state="GrGr"/&gt; &lt;phase duration="6" state="yryr"/&gt; &lt;phase duration="31" state="rGrG"/&gt; &lt;phase duration="6" state="ryry"/&gt; &lt;/tlLogic&gt; 从上面可以得出，第一个id为信号控制所在node的id，信号灯的programID为‘0’，当然这个id可以自己给定，数据类型为字符串(str)，控制类型为static，即定时信号控制，另外在sumo中还有其它的控制类型：
可以自己多多尝试。duration为当前相位持续时间，单位为s；
state为信号相位，即通行权解释，sumo的信号灯配置比较麻烦，这里详细讲解一下：
每一个state代表一个或者多个流线的放行，如gggrrrrgggrrrr代表南北方向通行，东西方向禁行g[0]g[1]g[2]r[3]r[4]r[5]r[6]按照索引位置进行对应。为了方便讲解，这里以上面给的xml文件中的参数进行trafficlight的相关用法及返回值的讲解
&lt;tlLogic id="0" type="static" programID="0" offset="0"&gt; &lt;phase duration="31" state="GrGr"/&gt; &lt;phase duration="6" state="yryr"/&gt; &lt;phase duration="31" state="rGrG"/&gt; &lt;phase duration="6" state="ryry"/&gt; &lt;/tlLogic&gt; 1.getAllProgramLogics(self,tlsID) getAllProgramLogics（self， tlsID）= getCompleteRedYellowGreenDefinition getAllProgramLogics(string) -&gt; list(Logic) 返回值为元组数据,功能等同于getCompleteRedYellowGreenDefinition方法 Returns a list of Logic objects.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fc0b1d371209ef725ca3ec8ca4b83c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42a549aeeaa0a601dcef06a6aa917710/" rel="bookmark">
			Idea中SpringBoot项目重启代码不生效，没有重新编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题 SpringBoot修改代码或配置文件重启项目后不生效，需要每次mvn clean mvn install
二、解决方法 进文件夹删掉.iml文件，在idea中点击Terminal，输入mvn idea:module 生成 项目名称.iml文件，即可解决问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/980f82161845013fd4ad29cb164269e6/" rel="bookmark">
			UniTask保姆级教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、UniTask的简介和安装
https://github.com/Cysharp/UniTask.gitpath=src/UniTask/Assets/Plugins/UniTask
空载性能测试
二、基础用法详解
三、基础用法扩展
四、进阶
五、VContainer简介
六、VContainer基础实例
方便快速查找
一、UniTask的简介和安装 项目地址：GitHub - Cysharp/UniTask: Provides an efficient allocation free async/await integration for Unity.
安装方式：
1.通过unity的PackageManager安装，需要一个支持git包路径查询参数的Unity版本 (Unity &gt;= 2019.3.4f1, Unity &gt;= 2020.1a21). 可以添加这个地址到PackageManager
https://github.com/Cysharp/UniTask.gitpath=src/UniTask/Assets/Plugins/UniTask 2.or add "com.cysharp.unitask": "https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask" to Packages/manifest.json.
如果你想设置一个目标版本，也可以使用*.*.*发布标记指定版本，例如#2.1.0可以这样，https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask#2.1.0
3.
Install via OpenUPM The package is available on the openupm registry. It's recommended to install it via openupm-cli.
openupm add com.cysharp.unitask
空载性能测试 二、基础用法详解 三、基础用法扩展 四、进阶 五、VContainer简介 六、VContainer基础实例 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e4ba7f5289bcec465d4a075db0332fa/" rel="bookmark">
			postman脚本之时间处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：postman 脚本可使用js语法做一些前置处理或后置处理，这里的时间处理一般在Pre-request-Script中
//js获取当前时间戳的三种方法
var timestamp = Date.parse(new Date()); //1616658069000
var timestamp1 = (new Date().valueOf()); //1616658069310
var timestamp2 = new Date().getTime(); //1616658069310var timestamp3 = Math.round(new Date().getTime()/1000); //1616662832
var timestamp0 =pm.variables.replaceIn("{{$timestamp}}") //最简单粗暴的方法,结果 1616666736
console.log(timestamp);
console.log(timestamp1);
console.log(timestamp2);console.log(timestamp3);console.log(timestamp0);
//js将时间戳转换为时间，也可以此基本上做一些加减，表示过去或未来时间
var t = new Date(1616661670810); //Thu Mar 25 2021 16:41:10 GMT+0800 (中国标准时间)
var t1 = t.getFullYear() + "-" + (t.getMonth()+1) + "-" + t.getDate() + " " + t.getHours() + ":" + t.getMinutes() + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e4ba7f5289bcec465d4a075db0332fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e295d2b7c907c599c3cfa65e92ddf47b/" rel="bookmark">
			ArcGIS软件操作——设置坐标系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 在gis领域，如果需要数据进行很好的处理，正确的坐标信息是必不可少的，本文简要介绍如何使用ArcMap对数据设置坐标系。
内容 首先加载数据，图层列表右键调出属性框，如下图1：选择Coordinate System，可以先看看该图层的坐标信息，红色框内Geographic Coordinate Systems是地理坐标系，Projected Coordinate Systems是投影坐标系（地理坐标系统是利用地球表面的经纬度表示；投影坐标系统是将三维地球表面上的经纬度经过数学转换为二维平面上的坐标系统）。这个在小编的地图配准中有提到过，就不再重复赘述了。设置这些坐标信息有两种方式，一种使用ArcToolbox的相应模块去设置，一种就是右键图层属性去设置。
图1
1 ArcToolbox中设置投影坐标信息
点击ArcToolbox工具箱 ，展开Data Management Tools，选择下面的Projections and Transformations，继续展开该树菜单，里面有对Feature、Raster进行投影的工具、有定义投影、创建空间参照等一系列的工具。其中我们一般常用的也就Project、Project Raster、Define Projection这三个。
图2
1.1 Define Projection
点击Define Projection，弹出图3对话框，在Input Dataset or Feature Class中输入需要定义投影的图层，可以是矢量也可以是栅格；Coordinate system中显示Unknown，表明该图层是没有原始坐标系统的，需要对其进行设置，点击UnKnown后面的按钮，设置相应参数（图4），大家有没有发现图4似曾相识啊~~~
图3
图4
在图4中，可以对图层进行坐标系统的设置。这里有三种方式。
1.1.1 直接选择法
在打开的图4对话框中，直接展开Geographic Coordinate Systems或Projected Coordinate Systems进行选择，一般常用的有图5中Geographic Coordinate Systems下的Asia——Beijing1954和Xian1980，还有World下的WGS1984；图6中Projected Coordinate Systems下的Gauss Kruger——Beijing 1954\Xian 1980，其中，可以展开Beijing1954和Xian 1980看看，例如Xian1980里面，大家发现没，有些是“经度形式的——87E、93E，有些是Zone 13、Zone 14 ，有些带有3 Degree字样”，其中这里略微提下，带有3 Degree是用的3度带表示，其它都是6度带形式：经度显示的指的是中央经线，Zone 13是用的带号；具体的信息可以到百度详细了解下3度带与6度带的区别。
但这里最常用的是6度带中央经线的形式，比如乌鲁木齐，主要集中在87E附近，那么我们在给乌鲁木齐地区定义投影的时候，便可以选择以中央经线为87E的来定义，这样左右各扩充3度，完全可以将乌鲁木齐包括进去。这样做的目的是因为越接近中央经线，其变形越小，所以你如果想给某个地区定义选择投影，一定先去了解下这个地区大体的分布范围。
图5
图6
1.1.2 Import导入法
假如你已经有一副定义好投影信息的地图，而且恰巧和你现在需要定义的地图都属于同一区域，那么，你便可以直接使用Import来进行投影信息的导入（图7）。点击Import，在出现的对话框中找到已存在坐标信息的地图文件，直接选择，Add即可。
图7
1.1.3 New新创建法
这种方式不常用，除非在你对地理坐标系统和投影信息有充分的了解，因为里面需要定义大量的参数，然而一个参数的不正确，就会使地图信息出现误差。有兴趣的可以琢磨琢磨这一块。
图8
最后，在定义好相关信息之后，回到初始界面，为该图层定义的坐标信息便显示出来了，直接OK即可。
图9
1.2 Feature、Raster下的Project
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e295d2b7c907c599c3cfa65e92ddf47b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4ba02ad4929754cecef069785cbc29e/" rel="bookmark">
			uniapp退出微信小程序的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 uni.exitMiniProgram() uni.exitMiniProgram()是UniApp提供的方法之一，用于在小程序平台中退出当前小程序应用
该方法还可以接受一个配置项，配置项包含成功和失败的回调函数：
uni.exitMiniProgram({ success: function() { console.log('退出小程序成功'); }, fail: function(err) { console.log('退出小程序失败', err); } }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6075253b9a90fff6edafde3bd29f50ab/" rel="bookmark">
			全网最详细的Ubuntu系统安装教程（Win&#43;Linux双系统）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在安装Linux系统之前，我们需要准备一个U盘，首先我们需要将U盘格式化即清空U盘的内容，然后通过USB制作Linux的安装盘，后续我们将通过U盘安装我们需要的Ubuntu20.04系统，对于其他的Linux系统，我们可以按照类似的方法进行安装。下面本人将以安装Ubuntu20.04系统为例，进行详细的讲解，每一步都将配上图片和文字说明，供大家参考。
一、USB制作Linux启动盘 下面两张图片是制作好的Linux启动盘，大家需要将U盘制作成下面所示的结构。
在插入U盘之前，我们需要下载Ubuntu20.04的映像文件，我们进入Ubuntu发行版本的官网Ubuntu Releases，然后按如下所示的方式进行下载：
Step 1 点击进入Ubuntu20.04的发行版界面：
Step 2 下载ubuntu-20.04.6-desktop-amd64.iso映像文件：
在下载完成Ubuntu20.04的映像文件之后，我们下载一个制作USB启动盘的软件，下载链接为：
Rufus下载链接
考虑到可能下载，读者可以在我的博客主页资源中下载该软件。
下载完成之后，我们插入U盘，接下来，我们需要将U盘制作成Linux启动盘，我们打开软件，无需下载，就能直接运行。
我们选择设备为U盘，在引导类型选择中点击右边蓝框的选择按钮，选择我们之前下载好的Ubuntu映像文件路径，打开映像文件，其他设置默认即可，我们点击开始，就可以进行Linux启动盘的制作了。
二、分配电脑内存给Linux系统 在制作完成U盘启动盘之后，接下来我们需要分配电脑内存给我们将要安装的Linux系统，我们右键Windows徽标键，点击磁盘管理。
然后我们就进入到了Windows系统的磁盘管理界面：
我们选择压缩内存分配给Linux系统的磁盘，比如本人选择的是D盘，将D盘空间一部分分配给Linux系统，然后选中D盘鼠标右键，选择压缩卷，然后根据自己的需要选择压缩容量的大小，压缩的大小（单位为MB，需要将GB转换为MB，比如100GB = 102400MB）即为我们分配给Linux系统的空间大小。
然后点击压缩即可，接下来，我们将在压缩的这部分硬盘空间安装Ubuntu20.04系统。 三、安装Ubuntu20.04系统 Step 1 重启电脑，然后一直按F12，选择USB HDD回车进入
Step 2 选择Ubuntu（一般是第一个），直接按回车进入
然后我们就进入到了Ubuntu的启动过程，请大家耐心等待，过程可能较久，一般需要三四分钟
Step 3 选择中文简体，联网，选择Ubuntu与Windows Boot Manager共存，点击现在安装
在通过U盘启动盘启动Ubuntu系统之后，我们将进入如下界面，我们选择语言为中文简体
然后回车，回车，回车，来到安装类型这个界面，一定一定要小心！请务必选择第一项，Ubuntu和Windows共存，安装双系统，在安装过程中系统会自行创建分区（要是选择了第二项，你的电脑将丢失整个Windows系统的文件，那需要重装Windows系统，丢失的资料难以恢复，得不偿失）
然后就是耐心等待，Ubuntu安装好了之后，我们看到如下界面。回车重启电脑，电脑会弹出一条提示 Please remove USB，这时将U盘拔出，然后按回车，就圆满完成Ubuntu系统的安装啦。
在安装好Ubuntu之后，大家就能根据兴趣好好探索Linux系统啦。
重启之后，我们每次打开电脑，都会进入到一个选择界面，第一个就是我们新安装的Ubuntu系统，然后选择第三行Windows Boot Manager回车就能切换Windows系统啦。Ubuntu启动的时候可能会说有错误，大家不用担心，Ubuntu能安装好并进入系统，就说明安装成功了，Ubuntu重启一般都有错误，只要能启动就能正常使用，无需担心。
总结 安装Linux系统的步骤主要有三步，将USB制作成Linux启动盘、分配硬盘容量给Linux系统，安装Linux系统与Windows组成双系统。在安装Linux的过程中，大家需要小心谨慎，以免将电脑格式化，造成电脑格式化或系统崩溃。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/865466c1b83907104286a670f10d73fb/" rel="bookmark">
			java 面试题汇总整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java有哪四种引用类型 在Java中，有四种引用类型，用于控制对象的生命周期和垃圾回收行为。这些引用类型包括：
强引用（Strong Reference）：
强引用是最常见的引用类型，它们是默认的引用类型。当一个对象具有强引用时，垃圾回收器不会回收这个对象，即使内存不足也不会回收。只有当所有强引用都不再指向某个对象时，垃圾回收器才会回收它。 软引用（Soft Reference）：
软引用用于描述一些还有用但不是必需的对象。当内存不足时，垃圾回收器会尝试回收被软引用引用的对象，但只有在内存真正不足的情况下才会回收。软引用通常用于缓存等场景，以便在内存不足时释放缓存。 弱引用（Weak Reference）：
弱引用用于描述一些非必需的对象，但在下一次垃圾回收时就会被回收。弱引用通过java.lang.ref.WeakReference类来实现。一旦没有强引用引用一个对象，即使还有弱引用引用它，垃圾回收器也会回收该对象。 虚引用（Phantom Reference）：
虚引用是最弱的引用类型，用于监控对象被垃圾回收的情况。虚引用通过java.lang.ref.PhantomReference类来实现。虚引用不会阻止对象被回收，但允许在对象被回收之前执行一些清理操作。 引用类型的选择取决于对象的生命周期和应用程序的需求。强引用用于维持对象的持久性，而软引用和弱引用用于实现缓存和内存敏感的对象，虚引用则用于执行对象的清理操作。理解这些引用类型可以帮助开发人员更好地管理内存和资源。
ThreadLocal 使用的哪种类型的引用 ThreadLocal 使用弱引用（Weak Reference）来管理对象的引用。这意味着当一个对象只被 ThreadLocal 引用时，如果没有其他强引用指向这个对象，垃圾回收器有可能在适当的时候回收该对象。弱引用的使用允许 ThreadLocal 在不再需要对象时自动释放对对象的引用，从而避免潜在的内存泄漏问题。
ThreadLocal 主要用于在每个线程中存储独立的数据，每个线程拥有自己的数据副本。当线程结束时，线程本地存储中的数据会被自动回收，因此使用弱引用确保了在没有外部强引用的情况下，线程局部存储中的数据可以被垃圾回收。
需要注意的是，尽管 ThreadLocal 使用弱引用来管理对象引用，但在某些情况下，如果没有正确清理 ThreadLocal 变量，仍然可能导致内存泄漏问题。因此，使用 ThreadLocal 时需要小心，确保在不再需要线程局部存储中的数据时进行适当的清理或移除。
threadLocal是什么，简单的介绍一下 ThreadLocal 是 Java 中的一个类，用于在多线程环境中创建线程局部变量。线程局部变量是一种特殊的变量，每个线程都拥有自己的副本，互不干扰。简单来说，ThreadLocal 允许你为每个线程存储和维护其自己的数据，这些数据对其他线程是不可见的。
以下是 ThreadLocal 的一些关键特点和用途：
线程隔离：ThreadLocal 变量允许每个线程在其内部存储自己的数据，不会与其他线程共享。这可以用于避免线程之间的数据冲突和竞态条件。
数据共享：ThreadLocal 可以用于在多线程应用程序中共享数据，而不需要显式地传递数据参数或使用全局变量。
线程上下文：ThreadLocal 常用于存储与线程相关的上下文信息，如用户身份认证信息、数据库连接、会话信息等。
线程安全性：由于每个线程都拥有自己的变量副本，ThreadLocal 变量本身在多线程环境中通常是线程安全的。
内存泄漏风险：需要小心管理 ThreadLocal 变量，以防止可能的内存泄漏。如果不及时清理 ThreadLocal 变量，可能会导致不再需要的数据一直存在于内存中。
使用 ThreadLocal 的典型场景包括：
在Web应用程序中存储用户会话信息，以便每个用户的请求都能访问其自己的会话数据。在数据库连接池中管理数据库连接，确保每个线程都有自己的数据库连接，而不需要共享。在日志记录中存储线程特定的上下文信息，如请求ID或用户身份信息。 需要注意的是，虽然 ThreadLocal 可以解决多线程环境中的一些问题，但过度使用它也可能导致代码变得难以理解和维护，因此在使用时需要谨慎考虑，确保合理使用。
子类获取父类的泛型类型 在 Java 中，子类无法直接获取父类的泛型类型参数信息。泛型信息在编译时会被类型擦除，因此在运行时无法直接访问泛型类型参数。但是，可以通过反射来获取泛型类型参数的信息，尽管这需要更复杂的代码。
以下是一个示例，演示了如何使用反射获取父类的泛型类型参数的类型：
import java.lang.reflect.ParameterizedType; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/865466c1b83907104286a670f10d73fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30db5898015dbb3957b1238d18804ed7/" rel="bookmark">
			Kotlin教程 内联函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本章节讲述Kotlin中内联函数的相关知识
简介
在 Kotlin 中， inline函数是一个高阶函数修饰符，当一个函数标记为 inline 时，该函数的字节码将直接复制到调用代码中，这在某些情况下可以提高性能。
即把函数体复制粘贴到函数调用处。
代码
private fun getSum(i1: Int, i2: Int): Int { return i1 + i2 } 普通方法，计算两个数值类型的和。
调用
val result = getSum(10,20) Log.d("KotlinActivity", "result ：$result") 结果
D/KotlinActivity: result ：30 kotlin代码编译成java代码(部分)
getSum声明的是普通方法，编译成java代码后也能看出，就是调用getSum这个普通的方法。
那么我们把上述的getSum改成内联函数，结果会是什么呢？
内联函数
private inline fun getSum(i1: Int, i2: Int): Int { return i1 + i2 } 调用不变，看下结果
D/KotlinActivity: result ：30 结果也不变，看下编译成java代码
也就是说，普通函数getSum改成inline内联函数后，编译成java代码中，调用处没有调用改方法，而是把该函数体复制粘贴到函数调用处。这就是内联函数和普通函数的区别。
总结
内联函数的本质就是：函数体复制粘贴到函数调用处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1012d9f60102da49c46d84c1f0932df1/" rel="bookmark">
			Unet相关知识及网络解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 Unet相关算法SoftmaxLogSoftmaxBatchNorm2dUpsampleConvTranspose2dPad 网络概述网络详解下采样上采样输出 完整网络代码注意点，Sigmoid VS softmax Unet 相关算法 这一部分涉及到的Conv2d二维卷积,，ReLU线性激活，MaxPool2d二维池化，之前文章已提及，这里不在赘述，详情可见上一篇博客
Softmax 归一化到范围0~1，总和为1，常用于将分类网络输出转为对应类别的非线性激活函数，
LogSoftmax 从数学本质上看，就是对Softmax做了log运算。这样产生的就是log probability 而不是 standard probability；
那为什么要log probability呢？
log probability计算更快，结果更稳定，虽然对于人的视角来看，计算结果不直观，但对于计算机在计算方面，效率更高。那又为什么效率高，详情可以看，下面几张图片都来自于链接
Softmax VS LogSoftmax
Why are log probabilities useful?
快：Log(a/b)=loga - logb
稳定：
BatchNorm2d 比较特殊，输入必须是4维，其中一定有batch
主要输入参数
作用：
Var是 torch.var
见论文
训练深度神经网络是复杂的，因为在训练过程中，随着前一层的参数变化，每一层输入的分布都会发生变化。这需要更低的学习率和仔细的参数初始化，从而减慢了训练速度，并使训练具有饱和非线性的模型变得非常困难。我们将这种现象称为 internal covariate shift，并通过normalizing layer inputs来解决这个问题。我们的方法通过将规范化作为模型架构的一部分并对每个训练小批量执行规范化来发挥其优势。批量规范化允许我们使用更高的学习率，并且在初始化时不需要那么小心。在某些情况下，它还起到了正则化因子的作用，消除了Dropout(不知道干嘛的看上篇)的必要性。应用于最先进的图像分类模型，Batch Normalization以减少14倍的训练步骤实现了相同的精度，并以显著的优势击败了原始模型。使用批量归一化网络的集合，我们改进了ImageNet分类的最佳发布结果：达到4.9%的前五名验证误差（和4.8%的测试误差），超过了人类评分者的准确性。
Upsample 可以理解为：插值填充
主要步骤
上采样插值
计算要进行拼接的两个输入参数维度偏差，比如(128,128)，(64,64),diff等于64和64
将维度小的周围填0(nn.functional.pad)，使得输入input1和input2维度一样，然后concat
然后双卷积，注意，此处由于拼接了，所以卷积的输入通道，是函数是两个输入的通道之和
ConvTranspose2d 也是卷积，但是会改变输出shape，也是填充，但不是单单Upsample；等同于Conv2d的计算方式达到Upsample的效果
在Unet网络中，主要与Upsample做区分，具体区别如下
UpSampling2D is just a simple scaling up of the image by using nearest neighbour or bilinear upsampling, so nothing smart.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1012d9f60102da49c46d84c1f0932df1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92d7d13c0647bba332969f670ddc1835/" rel="bookmark">
			Kotlin教程 扩展函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本章节讲述Kotlin中扩展函数的相关知识
简介
Kotlin的扩展函数是一种特殊的函数，允许在不修改原始类定义的情况下向现有类添加新的函数。
代码
/** * 调用String类的reverse方法-反转字符串 * */ private fun String.reverse(): String { return this.reversed() } /** * 调用String类的reverse方法-在和原始字符串相比较-判断字符串是否是回文 * */ private fun String.isPalindrome(): Boolean { return this == this.reversed() } 调用
val str01 = "张三三张" val str02 = "我是李四" val str01_ = str01.reverse() val b01 = str01.isPalindrome() val str02_ = str02.reverse() val b02 = str02.isPalindrome() Log.d("KotlinActivity", "张三三张 反转后的字符串：$str01_") Log.d("KotlinActivity", "张三三张 是否是回文：$b01") Log.d("KotlinActivity", "我是李四 反转后的字符串：$str02_") Log.d("KotlinActivity", "我是李四 是否是回文：$b02") 结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92d7d13c0647bba332969f670ddc1835/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/320cfc7fcc09d0dcbd6692d61604d68d/" rel="bookmark">
			基于Springcloud的基础框架，统一gateWay网关鉴权demo，附下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Springcloud的基础框架，统一gateWay网关鉴权demo，附下载地址 使用方式： 1、搭建nacos环境，修改对应nacos地址
2、修改mysql地址,导入sql语句
###框架内容
Springcloud+Gateway+JWT+Nacos+Fegin+mysql+Mybatis plus
具体功能 基于Springcloud的基础框架，统一gateWay网关鉴权，包含认证授权功能，增加白名单功能，其他服务只完成业务逻辑开发，不做认证和鉴权
接口流程 前端访问请求至网关，网关进行统一认证和鉴权，通过后进行请求转发至指定服务内进行后续数据处理，如果未通过则禁止请求
具体模块作用 spring-auth-server 授权服务：用于账户身份认证，生成token
spring-consumer 消费者服务：包含两种生产者的调用方式：RestTemplate和feign接口形式调用
spring-gateway 统一网关：包含拦截器和JWT认证，前端访问请求到网关，网关通过认证token决定是否将请求进行转发，包含白名单
spring-provider 生产者服务：主要是产生相关接口，供消费者进行调用
效果图 访问网关进行获取token localhost:8092/nacos-auth/user/login
传账户密码test/test
携带token访问服务 localhost:8092/nacos-provider/sysUser/test
无token 无效token 正常token demo下载地址：
点我下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/818a51d952e93e59cdeac82d1668ea0b/" rel="bookmark">
			Excel自学三部曲_Part1：excel中最常用的八大函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、sum—求和二、sumif—单条件求和三、sumifs—多条件求和四、subtotal—根据筛选求和五、if—逻辑判断六、vlookup—连接匹配数据七、match—查找数值在区域中的位置八、index—根据区域的位置返回数值补充1：match、index一起使用—自动根据列名查找数据补充2：sumifs、match、index一起使用—自动根据列名的数据和条件进行求和系列文章 一、sum—求和 sum(number1,number2,…) ——&gt; sum(列名)、sum(行名)
sum(单个或多个单元格) ——&gt; sum(列的名称 如A:A)、sum(行的名称 如1:1)
例1：计算1-8月GMV（对选定区域进行求和）
注：sum('拌客源数据1-8月'!J:J)中的''表示数据来源；！表示所引用数据并非当前工作表；J:J表示整个J列
技巧1：跨表看数据不方便时可以尝试“新建窗口”；这里并非新建数据，而是将同一个工作表数据以2个窗口展示，方便快速基于原数据进行查看、计算、引用。
技巧2：跨表看数据不方便时可以尝试“分屏”：win+左箭头/全部重排；将数据表分成左右两屏，方便快速基于原数据进行查看、计算、引用。
例2：计算1月和8月GMV（可以用逗号对多个区域进行求和）
首先选中B2单元格，冻结首行首列，将“日期”和“GMV”变成相邻的两列方便查看和计算；然后将日期按照升序排列，选中1月对应的GMV，并键入逗号；最后向下翻选中8月对应的GMV。
二、sumif—单条件求和 sumif(range,criteria,[sum_range])
sumif(条件判断所在的区域,条件,[用来求和的数值区域])
例：计算2020-07-01的GMV
以此类推，计算2020-07-07的GMV，可以考虑直接向下拖拽单元格，如下图所示：
因此需要将“日期”列、“求和”列、具体计算列固定住，保证向右拖拽数值不变。
注：Excel中日期与数字的关系：（数字）1=1900-1-1（日期），便于计算特定日期
比如：小明和小兰2022-5-27确定恋爱关系，在一起1000天后的纪念日为：2025-2-20
三、sumifs—多条件求和 sumifs(sum_range,[criteria_range1],[criteria1],[criteria_range2],[criteria2]…)
sumifs(用来求和的数值区域,[条件1判断所在的区域1],[条件1],[条件2判断所在的区域2],[条件2]…)
例1：计算2020-07-01的美团GMV
向下拖拽可计算其它行的数值（无需绝对引用）
例2：计算日环比
环比和同比的区别：
同比=(本期数-同期数)/同期数=本期数/同期数-1
环比=(本期数-上期数)/上期数=本期数/上期数-1
简而言之：环比是与上一个相邻的时间单位相比
同比是与上一年或上一月相同的时间单位相比 例3：计算日同比
日同比分为2种情况：相对于周 or 相对于月
日同比：相对于周
日同比：相对于月
1. 相对于周的日环比计算较为简单，可直接利用Excel中日期与数字的关系：（数字）1=1900-1-1（日期）
2. 相对于月的日环比计算（因为每月有28/29/30/31天）需要用到edate函数，用于返回与指定日期相隔的月份数的日期。edate (start_date，months)，start_date：指定日期，months：加减月份，其中months为正数表示基于start_date后延几个月，负数表示start_date提前几个月。
例4：计算月环比
计算每个月的第一天和最后一天需要用到eomoth函数，用于返回指定日期 之前或之后的月份的最后一天。eomoth(start_date，months)，start_date：指定日期，months：加减月份。
计算每个月的第一天和最后一天
计算当月的美团GMV
注意：
1.像"美团"这样的字符串是文本格式，需要加英文双引号""
2.像大于等于小于等符号也需要添加英文双引号""，并使用&amp;才能与后面的条件相连
3.而条件参数直接引用单元格或者使用函数则不需要英文双引号
计算上个月的第一天和最后一天
计算月环比
四、subtotal—根据筛选求和 subtotal(function_num,ref1,[ref2],…)
subtotal(指定函数,选择区域1,[选择区域2],…)
sum和subtotal的区别：
二者同为求和，只是subtotal函数求取的数值会根据原数据的筛选状态筛选数值变动而变动；而sum函数求取的数值无论原数据如何筛选变动，所求数值都不会改变。
五、if—逻辑判断 if(logical_test,value_if_true,[value_if_false])
if(逻辑比较条件,结果成立时返回的值,[结果不成立时返回的值])
[value_if_false]：该参数选填，没有该参数时，返回值false
if函数
if嵌套举例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/818a51d952e93e59cdeac82d1668ea0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41a4cf36cad6fb86f4c907f6016a2c42/" rel="bookmark">
			2023 最新最细 vite&#43;vue3&#43;ts 多页面项目架构，建议收藏备用！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌻 前言 本文教程 github地址 、码云。 如果对你有帮助，希望能点个star ⭐️⭐️⭐️ 万分感谢😊😊😊
🧱 背景 不久前我司需要重新部署一个前端项目，由我来负责这个项目的搭建。因为这个项目是需要和app混合开发的h5页面，包括以后可能会做一些运营h5，所以自然不能采用常规的SPA单页面应用架构（因为大部分页面耦合度低，全都塞一个项目里的话，即使打开个纯静态页都要跑起来整个项目，严重影响页面的加载速度）.
另外，我们其实已经有混合开发h5项目，采用的gulp工作流，即每个页面都是单独的一个html文件。这种架构的优势很明显，就是体量小，结构清晰等，但是它的缺点也非常明显，例如有些轮子无法使用，组件化、模块化开发非常不便影响开发效率等。
目前此项目已在平稳运行，最近有空闲时间记录一下我搭建项目的过程，同时也希望能帮助到有这方面需求的掘友😊
💡 思路 ** 综合考虑，我决定用vite + vue3 + ts + esint + prettier + stylelint + husky + lint-stage + commitlint 搭建一套多页面项目。
1. 初步定了几个目标：
🍀 支持打包指定子页面，打包后的文件夹：各页面相互独立（各子页面解耦，避免相互影响）🍀 支持启动指定子页面（常规的多页面项目，启动后需要手动拼接页面地址，或者在根目录做一个重定向的页面，总之调试非常不便）🍀 支持指令化新建页面（手动创建页面太麻烦，每次都得复制一份干净的文件夹）🍀 自由选择创建ts页面 / js页面（对于一些重要的页面可以使用ts提高规范性，一些简单的页面则使用js提高开发效率） 2. 本文将从以下几个方面逐步讲解：
项目目录结构新建项目安装依赖及一些基础插件vite配置项修改ts配置多页面入口配置多页面打包配置指令化新建子页面（*重点）多页面架构改造（*重点）完善项目架构 🌈 教程 一、 项目目录结构 ├── README.md ├── .husky //git hook钩子 │ ├── commit-msg //规范 commit message 信息 │ └── verify-commit-msg.mjs //脚本：commitlint 替代方案 ├── dist //打包输出目录 ├── scripts //存放一些脚本 │ ├── template //创建子页面的js模版 │ ├── template-ts //创建子页面的ts模版 │ ├── index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41a4cf36cad6fb86f4c907f6016a2c42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e74ea238cdf1dc031bea4511141b79d4/" rel="bookmark">
			PyQt5&#43;Pyinstaller：从零开始将Python打包成一个程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击名片关注 阿尘blog，一起学习，一起成长
本文主要简单介绍一下用pyqt5编写程序GUI界面，在通过Pyinstaller将python文件进行打包，从而摆脱环境的影响。
一、PyQt5入门 1.1 PyQt5简介 PyQt5 是一个用于创建 GUI 应用程序的 Python 绑定库，它提供了大量的功能和工具，可以快速开发跨平台的应用程序。PyQt5 基于 Qt 开发库，支持许多常见的数据模型和布局，并具有大量的可自定义的组件和样式。使用 PyQt5，可以创建各种类型的应用程序，包括桌面应用程序、移动应用程序和嵌入式应用程序。
PyQt5 的主要特点包括：
支持多种布局和数据模型，方便快速开发应用程序。
具有大量的可自定义的组件和样式，可以创建具有个性化外观的应用程序。
支持多种事件处理和信号槽机制，方便处理用户输入和系统事件。
支持国际化，可以轻松创建多语言应用程序。
具有丰富的文档和示例，方便学习和使用。
1.2 PyQt5的安装 分别通过pip安装一下库
pip install PyQt5 pip install pyqt5-tools pip install PyQt5Designer 1.3 通过Qt desinger构建程序UI 终端运行命令，打开Qt desinger
pyqt5-tools designer 打开结果
一般选择主窗口，其余模板大家可以点点尝试，有预览，选择主窗口后，左边可以选择对应组件拖到中间窗口里面进行设置，右边主要是介绍对象详细信息和编辑对象的属性值等等信息，以下，是我当前创建的
这里简单介绍几个组件，
input组件里面，可以选择一些输入输出框，比如下拉框、复选框、单行文本输入框、多行文本输入框等
另外就是可以展示组件，如标签，文本、进度条等等
当UI设计完成，Ctrl+R可以预览（但是似乎预览和实际运行的有区别）
没问题就保存（一般保存在项目目录里面，我用的pycharm直接打开终端运行）
保存文件格式，filename.ui
不出意外你就可以在你的目录中看到
然后关闭qt designer之后，继续终端运行
pyuic5 -o spider.py spider.ui 就会发现文件已经自动转为python文件了
但是python文件也只是定义了UI，所以运行没有结果
必须要单独编辑运行程序,创建或打开main.py（把原来示例删了，写下面的）
import sys from PyQt5.QtWidgets import QApplication, QMainWindow import spider # 导入UIpython文件 if __name__ == '__main__': # 示例话 app = QApplication(sys.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e74ea238cdf1dc031bea4511141b79d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccac2bdf736c5f395aadaf4cfe846d97/" rel="bookmark">
			vue页面添加水印（可用于H5，APP）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue页面添加水印 背景实现新建vue组件使用效果 尾巴 背景 最近实现了一个小功能，就是给页面添加背景水印。实现思路就是定义一个宽高充满屏幕的组件，然后使用绝对定位并通过层级控制让水印显示在页面的最前端。
实现 代码相对简单，相信有点vue基础的人都能看懂
新建vue组件 watermark.vue
&lt;template&gt; &lt;view class="make"&gt; &lt;view class="list"&gt; &lt;!--这里循环生成水印文字--&gt; &lt;view class="item" v-for="i in 300"&gt; &lt;text&gt;{{ info }}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script setup&gt; const props = defineProps({ info: { type: String, default: '默认水印' } }) &lt;/script&gt; &lt;style lang="scss" scoped&gt; .make { position: fixed; width: 100%; height: 100%; top: 0; left: 0; z-index: 9999; background: rgba(0, 0, 0, 0); pointer-events: none; .list { width: 500%; height: 400%; position: absolute; top: -50%; left: -50%; transform: rotate(-45deg);//旋转水印 display: flex; flex-wrap: wrap; justify-content: space-between; pointer-events: none; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccac2bdf736c5f395aadaf4cfe846d97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c34e347d0d48466f28be2f7497fa5fb/" rel="bookmark">
			（待会删）yyds！疯传全网的AI资源，请低调使用！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着ChatGPT的火热出圈，AI大模型在全球掀起一轮开发浪潮！Google、百度、腾讯等各个科技公司，都在高薪挖掘AI大模型人才！
然而大多数程序员——不熟悉AI领域发展，找不到自己的职业坐标；想要入手系统学习 AI，算法基础还并不扎实，模型背后的数学原理没有太深的了解……
想要入局AI，零成本学习AI大模型技术？
🎁今天为粉丝们争取到了这份宝藏资料——AI大模型资料包！
资料包含：
🔥价值1077元的11本畅销电子书
🔥8篇AI领域经典论文
🔥alpaca（羊驼模型）源码+精讲+解析
资源有限！识别下方二维码
免费领！
👇👇
AI发展势不可挡，有限的时间要看最精华的书！
这些资料都是畅销全球的人工智能、AI相关书籍，包括比尔·盖茨、埃隆·马斯克、谷歌大脑创始人等众多名人推荐！
非常适合：对人工智能感兴趣、想入局AI领域的伙伴阅读。
AI相关的书籍都比较贵，加起来超过1077元！但是无所谓，这些资料一次性！全部免费！给到大家。
👇👇
如何领取资料？
扫瞄下方二维码，
添加老师领资料包，开启AI进阶学习路线
资料有限，限200人，免费领！‍
👇👇
除畅销书籍外，还给大家准备了：8篇AI领域经典论文、alpaca（羊驼模型）源码+精讲+解析
👇经典论文👇
👇alpaca大模型源码👇
🔥 价值1077元电子书+论文+源码
限200人，免费领！
↓长按识别下方二维码↓
添加老师领资料包 开启AI进阶学习路线
👇👇
⬇戳”阅读原文“，数量有限，速来领！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a66f40a53bf22dfa94e1cf93ff917e00/" rel="bookmark">
			将表格数据导入matlab的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将表格数据导入matlab的方法： 由matlab内部功能导入：由Matlab内部函数导入：detectImportOptions函数`opts.VariableNamingRule = 'preserve'`更改要导入的表格：导入后数值变为NaN(Not a Number）： 由matlab内部功能导入： 首先：
点击主页，找到导入数据选项
然后：选择要导入的数据表格，如果找不到可以选择一下文件格式分类，但是可能有些数据表格不支持，但是正常的Exel表格这些应该都没问题
接着：选择后，会出现一个窗口，可以用来选择你所需要导入的表格数据
最后：导入后，系统会默认一个变量来接收，点击即可查看里面存放的数据
由Matlab内部函数导入： 首先：
代码的内容如下： opts = detectImportOptions('D:\Matlab_project\test\附件1：123家有信贷记录企业的相关数据.xlsx'); opts.Sheet = '进项发票信息'; opts.VariableNamingRule = 'preserve'; date_txt1 = readtable('D:\Matlab_project\test\附件1：123家有信贷记录企业的相关数据.xlsx', opts); 上述代码中，我们首先使用detectImportOptions函数来检测导入选项，然后设置工作表的名称和变量命名规则，并将这些选项传递给readtable函数。运行后： 这时候用于接受表格数据的变量是由你自己定义的，好处是以上代码将导入前的工作都做好了，问题出现时也方便查找问题出处便于修改 detectImportOptions函数 detectImportOptions函数 是MATLAB中用于自动检测数据导入选项的功能。它的主要作用是帮助你确定如何正确导入外部数据文件，如CSV、Excel、文本文件等。以下 是detectImportOptions函数的用法和作用： 用法示例：
opts = detectImportOptions('filename.ext');%括号里是文件的地址 作用：
自动检测指定文件中的数据格式和结构，例如列分隔符、列名、数据类型等。
返回一个包含导入选项的结构体（通常命名为opts），其中包括了有关数据文件的信息。
这些选项可以进一步用于readtable、readmatrix等函数，以确保正确导入文件的数据。
通过自动检测数据文件的特性，你可以避免手动指定导入选项，减少出错的可能性。
例如，我们使用了detectImportOptions函数来获取Excel文件的导入选项，然后将这些选项传递给readtable函数，以确保正确读取Excel文件中的数据。
总之： detectImportOptions函数是一个非常有用的工具，可以简化从外部数据文件中导入数据时的配置过程，提高数据导入的准确性。
可以在以下情况下考虑使用detectImportOptions函数：
1. 外部数据文件的结构不确定：当你需要从外部数据文件（如CSV、Excel、文本文件）导入数据时，但不确定文件的结构，例如列名、数据类型或分隔符时，可以使用detectImportOptions来自动识别这些信息。
2. 数据文件结构经常变化：如果你处理的数据文件的结构经常发生变化，或者你需要处理多个不同结构的文件，可以编写一个通用的数据导入脚本，使用detectImportOptions自动适应不同的文件结构。
3. 避免手动配置导入选项：手动配置导入选项可能会出现错误，特别是当你处理大量文件时。使用detectImportOptions可以减少配置错误的可能性，提高代码的可维护性。
4. 快速探索数据：如果你想快速查看数据文件的内容和结构，而不必提前了解文件的详细信息， detectImportOptions可以帮助你快速获取必要的信息。
总之：detectImportOptions是一个在处理外部数据文件时非常有用的工具，特别是当你需要自动识别文件的结构和特性时，它可以简化数据导入的流程，并提高代码的灵活性和鲁棒性 （鲁棒性是指某一个自动系统在系统发生故障时仍然能较好的完成预定工作的能力）。 opts.VariableNamingRule = 'preserve' opts.VariableNamingRule = 'preserve' 这句话的作用是告诉 MATLAB 在导入数据时要保持变量名的原始命名，即不要修改列名的格式或字符，保留列名中的任何空格、特殊字符或大小写。这在数据导入和处理过程中非常重要，因为有些数据文件的列名可能包含空格、特殊字符或区分大小写，如果不设置这个选项，MATLAB 可能会自动修改这些列名以适应其默认的变量命名规则。
更改要导入的表格： 要更改导入的 Excel 表格（Sheet），你可以通过修改 opts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a66f40a53bf22dfa94e1cf93ff917e00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1704da4f32d01333ba84e829eb2a950/" rel="bookmark">
			Unsupported Java. Your build is currently configured to use Java 17.0.6 and Gradle 5.4.1.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		感谢阅读 该错误表明您的项目当前配置为使用不受支持的 Java 版本（Java 17.0.6）和 Gradle 版本（5.4.1）。 解决此问题的方法是升级 Gradle 包装器（Gradle wrapper）到 7.2 版本，并重新导入项目。升级 Gradle 包装器会自动下载并使用指定版本的 Gradle。
请按照以下步骤进行操作：
打开项目文件夹，找到包含 Gradle 相关文件的目录。通常，这个目录名为 “gradle”。
在该目录中，找到名为 “wrapper” 的子目录。
在 “wrapper” 目录中，您会找到一个或多个文件，其中包括名为 “gradle-wrapper.properties” 的文件。
打开 “gradle-wrapper.properties” 文件，并修改其中的 distributionUrl 属性为 Gradle 7.2 的分发地址：
distributionUrl=https\://services.gradle.org/distributions/gradle-7.2-all.zip 保存并关闭文件。
回到 Android Studio，关闭项目并重新打开它。
Android Studio 将自动检测到 Gradle 包装器已更改，并提示您同步项目。点击 “Sync Now”（立即同步）按钮以重新导入项目并使用新的 Gradle 版本。
完成以上步骤后，您的项目将使用更新的 Gradle 版本，并且不再显示不支持的 Java 版本的错误。
请注意，升级 Gradle 版本可能会导致项目中的一些依赖项或插件不兼容。在升级前，请确保您的项目中的所有依赖项和插件都支持所选的 Gradle 版本，并根据需要进行相应的调整。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4400f3cf8e65c2812f82d86e581d109f/" rel="bookmark">
			30道经典笔试SQL题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-- 创建数据库并指定 create database sql_30; use `sql_30`; -- 创建表和插入数据(windows不区分大小写，linux区分大小写) create table student(sid varchar(10),sname varchar(10),sage datetime,ssex nvarchar(10)); insert into student values('01' , '赵雷' , '1990-01-01' , '男'); insert into student values('02' , '钱电' , '1990-12-21' , '男'); insert into student values('03' , '孙风' , '1990-05-20' , '男'); insert into student values('04' , '李云' , '1990-08-06' , '男'); insert into student values('05' , '周梅' , '1991-12-01' , '女'); insert into student values('06' , '吴兰' , '1992-03-01' , '女'); insert into student values('07' , '郑竹' , '1989-07-01' , '女'); insert into student values('08' , '王菊' , '1990-01-20' , '女'); create table course(cid varchar(10),cname varchar(10),tid varchar(10)); insert into course values('01' , '语文' , '02'); insert into course values('02' , '数学' , '01'); insert into course values('03' , '英语' , '03'); create table teacher(tid varchar(10),tname varchar(10)); insert into teacher values('01' , '张三'); insert into teacher values('02' , '李四'); insert into teacher values('03' , '王五'); create table sc(sid varchar(10),cid varchar(10),score decimal(18,1)); insert into sc values('01' , '01' , 80); insert into sc values('01' , '02' , 90); insert into sc values('01' , '03' , 99); insert into sc values('02' , '01' , 70); insert into sc values('02' , '02' , 60); insert into sc values('02' , '03' , 80); insert into sc values('03' , '01' , 80); insert into sc values('03' , '02' , 80); insert into sc values('03' , '03' , 80); insert into sc values('04' , '01' , 50); insert into sc values('04' , '02' , 30); insert into sc values('04' , '03' , 20); insert into sc values('05' , '01' , 76); insert into sc values('05' , '02' , 87); insert into sc values('06' , '01' , 31); insert into sc values('06' , '03' , 34); insert into sc values('07' , '02' , 89); insert into sc values('07' , '03' , 98); # 1、查询 “01” 课程比 “02” 课程成绩高的学生的学号、姓名 -- 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4400f3cf8e65c2812f82d86e581d109f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f04cdd7904ae773ef40eebd6ff877096/" rel="bookmark">
			【易售小程序项目】顶部导航栏和底部导航栏设置&#43;iconfont图标引入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 顶部导航栏和底部导航栏设置创建几个需要底部导航栏切换的页面使用阿里巴巴矢量图标库完成底部导航栏tabBar设置页面顶部导航栏标题 样式优化同项目其他文章 顶部导航栏和底部导航栏设置 在正式开发小程序的功能之前，首先需要确定小程序的主要框架。
创建几个需要底部导航栏切换的页面 我的小程序需要创建的页面是“首页”、“我想要”、“私信”、“我的”，“首页”已经存在于项目中，不需要重复创建。创建过程如下：
创建成功，不仅创建了star.vue，Hbuilder还自动帮助创建了star文件夹
除此之外，还帮助我们在pages.json文件中进行了配置
同理，继续创建其他文件
使用阿里巴巴矢量图标库 官网：阿里巴巴矢量图标库
首先注册账号并登录，然后点击我的项目
创建一个新项目
搜索图标添加到项目中
将想要的图标添加到购物车中
查看购物车
将购物车的图标添加到项目中
下载项目的图标到本地
将下载的文件解压之后，把里面的.ttf文件拿出来
将ttf文件存储到项目的静态资源目录下面
在项目中使用
"tabBar": { "iconfontSrc": "static/icon/iconfont.ttf", "color": "#333", "selectedColor": "#2b92ff", "list": [ { "text": "首页", "pagePath": "pages/index/index", "iconfont": { "text": "\ue67e", "selectedText": "\ue67e" } },{ "text": "我想要", "pagePath": "pages/star/star" },{ "text": "消息", "pagePath": "pages/message/message" },{ "text": "我的", "pagePath": "pages/my/my" } ] } 运行到浏览器中，查看网页效果，图标正常
运行到小程序中，查看效果，非常伤心，并不能正常使用
虽然在tabBar中无法使用iconfont，但是在页面的其他地方还是可以使用的，请继续后面的操作
将复制的在线代码替换掉原有的代码，下图是替换前
下图是替换后
之后，在每个链接前面添加上https
最后在App.vue文件中引入iconfont.css
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f04cdd7904ae773ef40eebd6ff877096/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dd336f65c94d5ab2cc40fc88dca4a5d/" rel="bookmark">
			Nginx安装与部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一,说明二,下载三,Windows下安装1,安装2,启动3,验证 四,Linux下安装1,安装2,启动3,验证 五,Nginx配置 一,说明 Nginx是一款高性能Web和反向代理服务器,提供内存少,高并发,负载均衡和反向代理服务,支持windos和linux系统
二,下载 打开浏览器,输入地址: https://nginx.org/en/download.html,红框左边linux版本,右边windows版本
三,Windows下安装 1,安装 直接解压,放在无中文路径的目录下,比如D盘
2,启动 1,直接双击nginx.exe,启动nginx服务器
2,命令行cd到该目录,通过start nginx,启动nginx服务器
进入目录:D:\nginx-1.24.0 启动:start nginx.exe 停止:nginx.exe -s stop 重新加载:nginx.exe -s reload 验证配置文件: nginx -t 使用配置文件: nginx -c "配置路径" 使用帮助: nginx -h 3,验证 输入http://localhost，访问页面如下表示成功
四,Linux下安装 1,安装 1,下载openssl,zlib,pcre,nginx包,并将每个包通过xftp放入自己定义的目录中
openssl: https://www.openssl.org/source/
zlib: http://www.zlib.net/
pcre: https://sourceforge.net/projects/pcre/files/pcre/8.45/
nginx: https://nginx.org/en/download.html
2,openssl安装
tar -zxvf openssl-3.1.2.tar.gz cd openssl-3.1.2 ./config make &amp;&amp; make install 3,zlib安装
tar -zxvf zlib-1.3.tar.gz cd zlib-1.3 ./configure make &amp;&amp; make install 4,pcre安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dd336f65c94d5ab2cc40fc88dca4a5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b201ad6c385e4c76ed5e2e888026cbfb/" rel="bookmark">
			Java应用CPU占用过高故障排除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 最近测试反馈测试环境接口偶现有访问超时，然后APP提示是网络失败，看了一下测试环境的应用完全没啥问题，一直以为是网络问题。
今天测试有反馈了，赶紧看了一下测试服务器，这次终于有症状了，CPU直接飙到300%了。
尽然问题复现了，直接开干，定位问题
二、解决思路 1、定位问题应用进程 使用top命令，然后按照CPU排序，如下图所示，进程PID为13258的Java应用占用300%的CPU资源。
Java应用造成CPU高的主要原因一般是线程一直处于可运行（Runnable）状态，通常这些线程在执行无阻塞操作、循环、正则或纯粹的计算等任务，
另一个可能造成CPU高的原因是频繁GC
所以现在进程的线程情况
2、查看进程中线程使用情况 使用命令 top -H -p 查看如下图：
#-H：所有线程占用资源情况。 #-p&lt;进程号&gt;：指定进程； top -H -p 13258 发现有三个线程实时CPU占用率较高，并且处理器使用时间非常长，25438线程实际占有处理器的时间甚至达到190分钟。
现在问题已经找到了，就是这三个线程持续占用CPU资源，下面我们再具体看一下这个线程再干嘛
3、查看线程的快照 通过jstack 命令查看线程14689的快照
jstack 13258 |grep "3961" -A 30 jstack后面的参数是PID的值，3961是线程id 14689 的十六进制。
可以通过以下命令把线程id转成16进制
printf "%x\n" 14689 通过观察输出，可以看到线程长期处于可运行状态，直接根据堆栈信息找到对应的代码。
4、最后 找到对应代码修改后基本就解决问题了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3093d1f95b6241adf491c4bc4599df4/" rel="bookmark">
			使用Sumo以及traci实现交叉口信号灯自适应控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Sumo以及traci实现交叉口信号灯自适应控制 文章目录 使用Sumo以及traci实现交叉口信号灯自适应控制 使用Sumo以及traci实现交叉口信号灯感应控制一、什么是交叉口感应控制二、Traci中的感应控制实现流程1.感应控制逻辑2.仿真过程 使用Sumo以及traci实现交叉口信号灯感应控制 Sumo作为比较常用的交通仿真软件，常用于各范围的路网仿真。今天研究一下怎么通过Python和Traci结合，实现交叉口信号灯自适应控制。
一、什么是交叉口感应控制 交通信号控制方式是应用于道路交通信号控制系统，为控制和调整交通流运行状态，按照交通信号控制方案所执行的特定控制方式。国标《道路交通信号控制系统术语》（GB/T 31418-2015)、行标《《道路交通信号控制方式 第1部分：通用技术条件》（GA/T 527.1-2015）、美国《Signal Timing Mannual》对感应控制（actuated）和自适应控制(adaptive)都做了相关定义和描述。标准中对“感应控制”的描述为道路交通信号控制机根据检测器测得的交通流信息来调节信号显示时间的控制方式。
以行业标准《道路交通信号控制方式 第1部分：通用技术条件》（GA/T 527.1-2015）种描述的“单点感应控制”：根据交通流检测器测定到达交叉口进口道的交通需求，对预先设定的交通信号控制方案进行执行相位的信号配时优化调整，也可选择执行预设相位、优化相序，以减少停车延误、排队长度为目标。
根据检测器布设方式，可以将感应控制分为半感应控制和全感应控制。半感应控制只在部分进口道上设置检测器，这种情况下交叉口仅部分相位有感应请求。而全感应控制在所有进口道上都设置检测器，这种情况下交叉口所有相位均有感应请求。结合控制范围，可以将感应控制划分为单点感应控制和干线感应协调控制。自适应控制可以划分为单点自适应控制、干线自适应控制、区域自适应控制。
二、Traci中的感应控制实现流程 1.感应控制逻辑 感应控制实现逻辑如下：
def run(): """execute the TraCI control loop""" step = 0 # we start with phase 2 where EW has green traci.trafficlight.setPhase("0", 2) while traci.simulation.getMinExpectedNumber() &gt; 0: traci.simulationStep() if traci.trafficlight.getPhase("0") == 2: # we are not already switching if traci.inductionloop.getLastStepVehicleNumber("0") &gt; 0: # there is a vehicle from the north, switch traci.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3093d1f95b6241adf491c4bc4599df4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/269a807b9ad6b562961eb6daf91c4c50/" rel="bookmark">
			解决‘mysql‘ 不是内部或外部命令，也不是可运行的程序或批处理文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题描述：解决方案：图文版本： 问题描述： 在查看MYSQL版本号时，打开cmd界面输入“mysql -u root -p”和“mysql --help”时，
出现了：“mysql’ 不是内部或外部命令，也不是可运行的程序或批处理文件”'的提示语句。
解决方案： 按顺序依次打开：此电脑(右键)——属性——高级系统设置——高级——环境变量——系统变量——path
选中后点击编辑选择新建，输入内容：
C:\Program Files\MySQL\MySQL Server 8.0\bin （这是文件默认安装位置，如有调整地址，请对应修改）
输入完成后，全部点击确定退出
图文版本： 按照顺序打开，我的电脑–属性–高级系统设置
在系统属性-高级这一界面中选择环境变量
打开后再用户变量和系统变量选择系统变量
在系统变量这一栏下拉找到path，选中后点击编辑。
在新界面中选择新建，
添加：
C:\Program Files\MySQL\MySQL Server 8.0\bin 随后全部点击确定退出，
再打开cmd界面的时候即可使用mysql -u root -p指令。
至此，结束
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1279f0f4f469d607f0cbd109e2fcd0bd/" rel="bookmark">
			C&#43;&#43;学习笔记——结构体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、结构体的定义和简单使用 定义结构体一定要用 struct+类型名称
//结构体的定义和简单使用 #include&lt;iostream&gt; #include &lt;string&gt; using namespace	std; //1、创建学生数据类型：学生包括（姓名，年龄，分数） //自定义的数据类型，一些类型的集合组成的一个类型 //语法 struct 类型名称{ 成员列表} struct Student { //成员列表 //姓名 string name; //年龄 int age; //分数 int score; }s3;	//顺便创建结构体变量 //2、通过学生类型创建具体学生 int main() { //2.1 struct Student s1 //struct关键字可以省略 Student s1; //给s1属性赋值，通过一个 . 访问结构体变量中的属性 s1.name = "张三"; s1.age = 18; s1.score = 100; cout &lt;&lt; "姓名：" &lt;&lt; s1.name &lt;&lt; "年龄：" &lt;&lt; s1.age &lt;&lt; "分数：" &lt;&lt; s1.score &lt;&lt; endl; //2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1279f0f4f469d607f0cbd109e2fcd0bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/477ece8048c9bf230824b6d435630078/" rel="bookmark">
			安装Ubuntu系统，将U盘当作启动盘后写保护怎么恢复？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载ChipGenius 插入写保护的U盘，打开ChipGenius.exe后可以扫描到U盘，如下图中的E:盘就是我插入的U盘（我的PC上只有C、D两个分区）；
ChipGenius的作用 下载ChipGenius是为了获取U盘的设备信息：重点是主控型号这一条；
下载主控型号对应的量产工具 如上图中我的U盘主控型号为PS2251-09，那就去搜索PS2251-09的量产工具；
点击Update后，会出现扫描到的U盘，然后点击Start等待量产工具加载完毕后就可以了；
注意 1、如果点击Update（中文版的是更新或扫描按钮），没有出现对应的U盘，说明量产工具下载错了；
2、如果点击Start后瞬间变红（显示Error），也是量产工具有问题，设置16 Ports就可以，如果还不行，重新找个英文原版同型号的量产工具试试，我的就是这个问题，更换了英文原版的后就可以恢复了：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71c2b857fbdfd489fd779eab4fe5c054/" rel="bookmark">
			iOS练手项目知识点汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础理解篇 Objective-C是一种面向对象的编程语言，它支持元编程。元编程是指编写程序来生成或操纵其他程序的技术。
Objective-C中，元编程可以使用Objective-C的动态特性来实现。例如可以使用Objective-C的运行时函数来动态地创建类、添加属性和方法等等。
#import &lt;Foundation/Foundation.h&gt; @interface MyClass : NSObject @property (nonatomic, strong) NSString *name; - (void)printName; @end @implementation MyClass - (void)printName { NSLog(@"%@", self.name); } @end int main(int argc, const char * argv[]) { @autoreleasepool { MyClass *myObj = [[MyClass alloc] init]; [myObj printName]; // 动态添加属性和方法 [[myObj class] addMethod:@selector(sayHello:) withSignature:@"v"]; [[myObj class] addProperty:@"age" withType:@integerValue withAttribute:NONE]; // 动态调用方法 ((void (*)(id, SEL))[[myObj class] performSelector:@selector(sayHello:) withObject:nil]))(myObj, @selector(sayHello:)); // 动态添加属性 ((void (*)(id, SEL, id))[[myObj class] performSelector:@selector(setProperty:forKey:) withObject:[NSNumber numberWithInt:100] forKey:@"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71c2b857fbdfd489fd779eab4fe5c054/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bacd647d3f73644a9560464e71556dd/" rel="bookmark">
			LOGI M240已经连接过旧设备，怎么重新处于发现模式连接新设备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鼠标底部有个圆形复位按钮，长按，然后重新用电脑设置–》蓝牙
此时应该可以重新发现鼠标，点击连接即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49c2fbbb5010f213196cbf9b84e98414/" rel="bookmark">
			Android学习之路(12) setContentView详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 setContentView我们在Activity中经常见到，它的作用就是把我们的布局文件放在Activity中显示，下面我们根据源码分析setContentView是如何做到的
二、源码分析 1.两种setContentView 注意Activity的setContentView和AppCompatActivity的setContentView是有一些区别的，所以我们要分析两钟setContentView，下面先分析Activity的
2.Activity的setContentView (1).从Activity的setContentView这个方法开始
public void setContentView(@LayoutRes int layoutResID) { getWindow().setContentView(layoutResID); initWindowDecorActionBar(); } 可以看到第一句getWindow().setContentView(layoutResID)，这个getWindow是获取当前Activity的Window，在Android中Window的实现类是phoneWindow,所以我们要看phoneWindow的setContentView
顺便提一下Activity的window的创建时机是在Activity的attach方法:
(2).继续跟踪到phoneWindow的setContentView
public void setContentView(int layoutResID) { // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) { installDecor(); //⭐这句关键流程 } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) { mContentParent.removeAllViews(); } if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) { final Scene newScene = Scene.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49c2fbbb5010f213196cbf9b84e98414/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aa6f656352742317eb0e8d177f7a097/" rel="bookmark">
			Ubuntu20.04快速添加或删除SWAP分区一、SWAP分区的作用 当Linux系统在消耗完物理内存时，后台程序的内存就会从物理内存移动到SWAP空间，一般创建的Ubuntu虚拟机都不会去自动创
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、SWAP分区的作用 当Linux系统在消耗完物理内存时，后台程序的内存就会从物理内存移动到SWAP空间，一般创建的Ubuntu虚拟机都不会去自动创建SWAP交换分区。
首先先验证下SWAP交换分区是否存在
sudo swapon --show
如果什么都没有输出，那说明不存在SWAP交换分区，反之则输出相应内容。（以下是我创建好SWAP交换分区后的输出内容）
二、创建SWAP交换分区文件 1.先创建一个SWAP文件（我创建的容量是4G） sudo fallocate -l 4G /swapfile
2.为SWAP文件设置权限 sudo chmod 600 /swapfile
3.设置Linux 的 SWAP区域 sudo mkswap /swapfile
4.激活SWAP文件 sudo swapon /swapfile
5.如果需要让创建好的SWAP交换分区永久生效，需要将swapfile 文件的路径写到/etc/fstab文件中 sudo vi /etc/fstab
然后在文件最后一行输入:
/swapfile swap swap defaults 0 0
6.验证一下 sudo swapon --show
或者
sudo free -m
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fb2596f173d6a051648c54d90955f90/" rel="bookmark">
			【SVM分类】基于卷积神经网络结合支持向量机CNN-SVM的数据分类附matlab代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，matlab项目合作可私信。
🍎个人主页：Matlab科研工作室
🍊个人信条：格物致知。
更多Matlab仿真内容点击👇
智能优化算法 神经网络预测 雷达通信 无线传感器 电力系统
信号处理 图像处理 路径规划 元胞自动机 无人机 ❤️ 内容介绍 SVM分类是一种常用的机器学习算法，它在数据分类问题中表现出色。然而，随着卷积神经网络（CNN）的兴起，研究者们开始探索将CNN与SVM相结合的方法，以进一步提高数据分类的准确性和效率。在本文中，我们将介绍一种基于卷积神经网络结合支持向量机的数据分类方法——CNN-SVM。
卷积神经网络是一种广泛应用于图像识别和计算机视觉领域的深度学习模型。它通过多层卷积和池化操作，能够有效地提取图像中的特征信息。CNN在图像分类任务中取得了巨大的成功，但是在处理大规模数据集时，其计算复杂度较高，训练时间较长。这就为我们引入SVM提供了契机。
支持向量机是一种二分类模型，它通过在特征空间中构建一个最优超平面，将不同类别的数据点分开。SVM在处理高维数据时具有较好的泛化能力，并且能够有效地处理大规模数据集。然而，SVM本身不能直接处理图像数据，因为图像数据是高维的，且具有空间结构。因此，我们需要将CNN与SVM相结合，以充分利用两种模型的优势。
CNN-SVM的基本思想是，在训练过程中，我们首先使用CNN提取图像的特征，然后将这些特征作为SVM的输入。具体而言，我们可以将CNN的最后一层卷积层的输出作为特征向量，然后使用SVM进行分类。这种方法的好处是，我们可以利用CNN的特征提取能力，将图像数据转化为低维的特征向量，从而降低了数据的维度。这不仅减少了SVM的计算复杂度，还提高了分类的准确性。
在实际应用中，我们可以使用预训练的CNN模型，如VGG16或ResNet，来提取图像的特征。然后，我们将这些特征输入到SVM中进行训练和分类。通过这种方式，我们可以充分利用CNN在大规模数据集上训练的能力，同时又能够利用SVM在高维数据上的优势。
然而，CNN-SVM也存在一些挑战和限制。首先，由于CNN和SVM是两个不同的模型，它们的训练过程是分离的，因此需要额外的计算资源和时间。其次，CNN-SVM在处理大规模数据集时，可能会面临内存和计算资源的限制。此外，CNN-SVM的性能还受到CNN模型的选择和SVM参数的调整等因素的影响。
综上所述，基于卷积神经网络结合支持向量机的数据分类方法——CNN-SVM，是一种有潜力的分类算法。它能够充分利用CNN在图像特征提取方面的优势，同时又能够利用SVM在高维数据上的优势。然而，我们在使用CNN-SVM时需要注意其计算和资源的要求，并且需要对模型进行合理的选择和参数调整。希望通过进一步的研究和实践，我们能够进一步提高CNN-SVM的性能，使其在更广泛的数据分类问题中发挥作用。
🔥核心代码 %% 清空环境变量warning off % 关闭报警信息close all % 关闭开启的图窗clear % 清空变量clc % 清空命令行​%% 导入数据res = xlsread('数据集.xlsx');​%% 划分训练集和测试集temp = randperm(357);​P_train = res(temp(1: 240), 1: 12)';T_train = res(temp(1: 240), 13)';M = size(P_train, 2);​P_test = res(temp(241: end), 1: 12)';T_test = res(temp(241: end), 13)';N = size(P_test, 2);​%% 数据归一化[p_train, ps_input] = mapminmax(P_train, 0, 1);p_test = mapminmax('apply', P_test, ps_input );t_train = T_train;t_test = T_test ;​%% 转置以适应模型p_train = p_train'; p_test = p_test';t_train = t_train'; t_test = t_test';​%% 创建模型c = 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fb2596f173d6a051648c54d90955f90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccbb466b67f9d52002b5e2b3678d2df7/" rel="bookmark">
			org.apache.ibatis.ognl.TokenMgrError: Lexical error at line 1, column 6. Encountered: “\uff01“ (652
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.报错信息
org.apache.ibatis.ognl.TokenMgrError: Lexical error at line 1, column 6. Encountered: "\uff01" (65281), after : "" 2.原因： xml中的SQL语句 存在 中文符号
3.解决：SQL语句中的 中文符号 改成英文符号即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1940cdc9b3473718259738c935856909/" rel="bookmark">
			idea编写mapper.xml中sql语句提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 开启提示步骤： 最后一步 File–&gt;Settings–&gt;Languages &amp; FrameworksFile–&gt;SQL Dialects
开启后： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9454425855e5fcd7ebb70199ce869ee3/" rel="bookmark">
			No primary or single unique constructor found for interface java.util.List
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题描述
前端 请求的参数 是 query形式， 参数在url中
报错信息：
java.lang.IllegalStateException: No primary or single unique constructor found for interface java.util.List 2.解决办法
controller中的 请求方法 参数 加上 @RequestParam
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d39a94ffc3ed7847b961c5e496107c8/" rel="bookmark">
			JavaScript实现系统级别的取色器、EyeDropper、try、catch、finally
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 效果图htmlJavaScript关键代码EyeDroppertry...catch颜色值相减(色差)的传送门 效果图 html &lt;div class="d_f fd_c ai_c"&gt; &lt;button id="idBtn" class="cursor_pointer"&gt;开始取色&lt;/button&gt; &lt;div id="idBox" class="m_t_20 w_168 h_68 d_f fd_c jc_c ta_c fw_700"&gt;&lt;/div&gt; &lt;/div&gt; JavaScript (function () { let btn = document.querySelector('#idBtn'); btn.onclick = async () =&gt; { let idBox = document.querySelector('#idBox'), dropper = new EyeDropper(); idBox.style.backgroundColor = ''; idBox.style.border = `6px solid transparent`; idBox.innerHTML = ''; try { let { sRGBHex } = await dropper.open(), { hexadecimal, rgb } = subtractColors('ffffff', sRGBHex), { r, g, b } = hexToRgb(sRGBHex); idBox.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d39a94ffc3ed7847b961c5e496107c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5727cc91268a94422ebac800c51cdee9/" rel="bookmark">
			IPC进程间通信及示例代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 什么是进程通信 进程通信（ InterProcess Communication，IPC）就是指进程之间的信息交换。实际上，进程的同步与互斥本质上也是一种进程通信（这也就是待会我们会在进程通信机制中看见信号量和 PV 操作的原因了），只不过它传输的仅仅是信号量，通过修改信号量，使得进程之间建立联系，相互协调和协同工作，但是它缺乏传递数据的能力。
虽然存在某些情况，进程之间交换的信息量很少，比如仅仅交换某个状态信息，这样进程的同步与互斥机制完全可以胜任这项工作。但是大多数情况下，进程之间需要交换大批数据，比如传送一批信息或整个文件，这就需要通过一种新的通信机制来完成，也就是所谓的进程通信。
再来从操作系统层面直观的看一些进程通信：我们知道，为了保证安全，每个进程的用户地址空间都是独立的，一般而言一个进程不能直接访问另一个进程的地址空间，不过内核空间是每个进程都共享的，所以进程之间想要进行信息交换就必须通过内核。
下面就来我们来列举一下 Linux 内核提供的常见的进程通信机制：
管道（也称作共享文件）消息队列（也称作消息传递）共享内存（也称作共享存储）信号量和 PV 操作信号套接字（Socket） 二. 管道 1.匿名管道 管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。如果想实现相互通信（全双工通信），我们需要创建两个管道才行。另外，通过管道符 | 创建的管道是匿名管道，用完了就会被自动销毁。并且，匿名管道只能在具有亲缘关系（父子进程）的进程间使用。也就是说，匿名管道只能用于父子进程之间的通信。
在 Linux 的实际编码中，是通过 pipe 函数来创建匿名管道的，若创建成功则返回 0，创建失败就返回 -1：
#include&lt;sys/types.h&gt; #include&lt;stdio.h&gt; #include&lt;unistd.h&gt; #include&lt;errno.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; int main(void) { pid_t pid1; int fields[2]; char buffer[80]; char s[100]; char ss[100]; if(pipe(fields)!=0){ fprintf(stderr,"Createpipe error:%s\n\a",strerror(errno)); exit(1); } if((pid1=fork())&lt;0)printf("fork child error!\n"); /* 子进程写入数据 */ if(pid1==0){ printf("fork child,child is sending a message !\n"); char s[]="hello!\n"; write(fields[1],s,sizeof(s)); exit(0) } /* 父进程读取数据 */ else { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5727cc91268a94422ebac800c51cdee9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/085c60f70ffa7f3b5c18fe6bb1edc246/" rel="bookmark">
			AutoSAR CP 飞阅TIME
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是autosar
autosar 做了什么
Foundation、CP、AP
CLASSIC PLATFORM （CP）
ADAPTIVE PLATFORM
基于autosar 开发
SWC
Port
Runnables
RTE
BSW
MCAL
CDD
I/O Hardware Abstraction
Communication Hardware Abstraction
Memory Hardware Abstraction
Onboard Device Abstraction
Crypto Hardware Abstraction
Crypto Services
Communication Services
Memory Services
System Services
LIBRARY
AUTOSAR 的多核处理
AUTOSAR 的 safety 功能
AUTOSAR 的ICC（Implementation Conformance Class）
AUTOSAR 的三种接口
1. AUTOSAR Interface
2. Standardized AUTOSAR Interface
3. Standardized Interface
什么是autosar AUTOSAR(AUTomotive Open System ARchitecture)，中文是“汽车开放系统架构”，是一家致力于制定汽车电子软件标准的联盟。他们制定了一套专门用于汽车的开放性的框架和行业标准，它将用作管理将来的应用程序和标准软件模块中功能的基本基础结构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/085c60f70ffa7f3b5c18fe6bb1edc246/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db6948b5a9f2b4e85a19ac8203443e56/" rel="bookmark">
			redis代替session登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(69条消息) 基于session登录问题_bubbleJessica的博客-CSDN博客
session共享问题：多台Tomcat并不共享session的存储空间，当请求切换到不同的tomcat服务时导致数据丢失问题
使用redis替代session的解决方案是：数据共享，内存存储，key value结构
redis这里为什么不能用code作为key
因为session有一个特点每一个不同的浏览器发起请求都有一个独立的session，也就是说tomcat里内部维护很多的session，那么不同浏览器携带的手机号来的时候都是自己独立的session那么利用code作为key但是互相之间不干扰没有问题
而redis则不同，redis是一个共享的内存空间，不管是谁来发请求，服务端只有一个redis，那么大家都往这里面去存，不同手机号来用code作为key存取互相就覆盖了呀，验证码就丢失了很多，那肯定有很多人对不上所以就出现问题，我们必须确保每一个不同的手机号做验证时保存的key是不一样的，那干脆用手机号作为key就解决了
注意：hashmap已经判断为null，要判断的话使用isEmpty()方法 session有效期30分钟，不进行任何操作就剔除 package com.hmdp.service.impl; import cn.hutool.core.bean.BeanUtil; import cn.hutool.core.lang.UUID; import cn.hutool.core.util.RandomUtil; import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.hmdp.dto.LoginFormDTO; import com.hmdp.dto.Result; import com.hmdp.dto.UserDTO; import com.hmdp.entity.User; import com.hmdp.mapper.UserMapper; import com.hmdp.service.IUserService; import com.hmdp.utils.RegexUtils; import lombok.extern.slf4j.Slf4j; import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.stereotype.Service; import javax.annotation.Resource; import javax.servlet.http.HttpSession; import java.util.Map; import java.util.concurrent.TimeUnit; import static com.hmdp.utils.RedisConstants.*; import static com.hmdp.utils.SystemConstants.USER_NICK_NAME_PREFIX; /** * &lt;p&gt; * 服务实现类 * &lt;/p&gt; * * @author 虎哥 * @since 2021-12-22 */ @Slf4j @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService { @Resource private StringRedisTemplate stringRedisTemplate; @Override public Result sendCode(String phone, HttpSession session) { // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db6948b5a9f2b4e85a19ac8203443e56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3eaf3d5e69f1b93484727759e4c23bc/" rel="bookmark">
			常用的windows快捷命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows+shift+S 系统快捷截屏
Ctrl+小键盘'+'　该快捷键可将当前页面放大10%
Ctrl+小键盘'-' 该功能当前页面缩小10%
Ctrl+Alt+Delete 调出任务管理器窗口 Alt+tab调出所有窗口，方便用于切换窗口
win+d 关闭所有窗口，回到桌面
Ctrl+C 复制
Ctrl+V 粘贴
Ctrl+Z 返回
Ctrl+S 保存
Ctrl+A 全选
Alt+Tab（切换应用程序）
Win + Tab：实现3D效果切换窗口
Ctrl+F（查找）
Win+i（打开“Windows设置”）
Win+L（锁屏）
Win+X (电脑综合管理)
F11 最大化或最小化活动窗口
dos命令窗口运行命令
control打开电脑全部设置
regedit打开电脑注册表
输入 mstsc即可快捷打开远程桌面连接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9010e94ddd4b092ca4539e5eb48b428/" rel="bookmark">
			电脑端微信dat文件怎么打开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1-2
电脑端的微信，在聊天过程中收发的图片都是以DAT文件保存在电脑里，加密的，一般是不能直接打开的。
但是图片在电脑中占用的空间非常大，如果是平常工作的微信，会接收到很多图片，时间一长，硬盘容易塞满。
如果是视频和文件，可以直接清理，因为它不加密，可以直接打开的，留下有用的，删除没用的。
但是图片是加密的，看不到图片内容的话，不敢贸然清理，容易删除重要文件，有没什么办法转成图片后再清理？
这就是本次推荐的小工具《天才小网管DAT转JPG》，它可以把微信电脑版加密的DAT文件转成JPG图片文件，并且附带了一个清理工具，当你完成了手工清理之后，可以使用清理工具快速清理DAT文件。
该工具可以点下面这里获取：
https://www.qinyuanyang.com/zb_users/upload/2020/11/20201121092628160592198813775.zip
以下是工具使用说明。
1，首先在微信中按如下操作点击【菜单】【设置】，打开微信的设置窗口
2，然后在设置窗口中点击【文件管理】【打开文件夹】
3，电脑会打开一个文件夹，这个文件夹里就保存在微信聊天的DAT图片，如果你的微信已经登录不了了，也可以的，在电脑里找到【WeChat Files】文件夹，这个文件夹一般在【此电脑】【文档】里，如果这里没有，再找找其它地方即可
4，双击【FileStorage】文件夹，里会有一些文件夹，具体内容如下
5，在【Image】文件夹里有图片（6月前），在【MsgAttach】里也有（6月后），下面用工具转一下看看，打开《天才小网管DAT转JPG》工具
6，软件打开后是这样，需要选一个DAT文件目录、要转换的月份、转成图片后保存到哪个文件夹
7，如果你已经整理好很多DAT文件在一个文件夹里了，就不用转月份了，以下是转【MsgAttach】文件夹里的图片的使用方法
7.1 选择【MsgAttach】文件夹
7.2 因为这个文件夹里的DAT文件非常混乱，所以选择要转换的月份
7.3 选择一个转换后要保存图片的文件夹
8，最后点【一键转换】，稍等片刻就好了。
9，最后在保存目录里可以看到转换好的图片。
10，如果需要清理DAT文件，在你手动清理完JPG图片后，使用清理工具清理即可，具体使用方法在清理工具中有说明，操作简单。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f94ab9e6bd358c574f7888ebd1d7958/" rel="bookmark">
			mybatiplus代码生成器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.pom文件引入
2.引入模板引擎
3.注意
新版本，老版本配置和用法都不太一样，此处暂不展示；另外也可以尝试一下MyBatis-Flex 总之mybatisplus有的或者收费的，它都有MyBatis-Flex 是什么 - MyBatis-Flex 官方网站
1.pom文件引入 mysql lombok插件安装自己所需 到仓库找： https://mvnrepository.com/
&lt;dependency&gt;
&lt;groupId&gt;com.baomidou&lt;/groupId&gt;
&lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
&lt;version&gt;3.5.3.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;mysql&lt;/groupId&gt;
&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
&lt;artifactId&gt;lombok&lt;/artifactId&gt;
&lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
2.引入模板引擎 freemaker 或者另外的模板引擎velocity；推荐freemaker
&lt;dependency&gt;
&lt;groupId&gt;org.freemarker&lt;/groupId&gt;
&lt;artifactId&gt;freemarker&lt;/artifactId&gt;
&lt;/dependency&gt;
或者
&lt;dependency&gt;
&lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;
&lt;artifactId&gt;velocity&lt;/artifactId&gt;
&lt;version&gt;1.7&lt;/version&gt;
&lt;/dependency&gt;
import com.baomidou.mybatisplus.generator.FastAutoGenerator; import com.baomidou.mybatisplus.generator.config.OutputFile; import com.baomidou.mybatisplus.generator.config.rules.DateType; import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine; import java.util.ArrayList; import java.util.Collections; public class CodeUtils { public static void main(String[] args) { ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;(); strings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f94ab9e6bd358c574f7888ebd1d7958/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8828038413f7dbd865c9d93d71d1ce90/" rel="bookmark">
			大屏可视化方案--简单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 为大家介绍一个非常好用的大屏解决方案——autofit.js。
可根据窗口大小进行自动适配。
官网地址：autofit.js | 最易用的自适应工具
下面是使用方法
1.npm下载
npm i autofit.js 2.在项目中引入
import autofit from 'autofit.js' 3.init(）初始化，注意：要在mounted（）里
mounted() { autofit.init({ designHeight: 1080,//高度 designWidth: 1920,//宽度 // renderDom: '#app', resize: true }) } 以上三步，大屏适配就已经完成了
以上使用的是默认参数，可根据实际情况调整，可选参数有
* - el：渲染的dom，默认是 "#app"，必须使用id选择器 * - dw：设计稿的宽度，默认是 1920 * - dh：设计稿的高度，默认是 929 ，如果项目以全屏展示，则可以设置为1080 * - resize：是否监听resize事件，默认是 true * - ignore：忽略缩放的元素（该元素将反向缩放），参数见readme.md * - transition：过渡时间，默认是 0 * - delay：默认是 0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/542ba96d850d38cdef3e97a0aa50b305/" rel="bookmark">
			笔试题-计算公式优先级&#43;运算符运算&#43;运算符执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.xch.test04; /** * 笔试题测试 * * @author XuChenghe * @date 2023/8/31 16:03 */ public class Test08 { public static void main(String[] args) { f1(); System.out.println(); f2(); System.out.println(); f3(); } /** * 计算公式优先级 */ public static void f1() { int x = 10; System.out.println(x += x -= x *= x); // 运算符优先级一致，则按结合性(计算顺序)从右到左，运算前y赋值后不会随计算而变化(始终为10) int y = 10; System.out.println(y += (y -= (y *= y))); System.out.println("y = " + y); // 最终回填y=-80 // 原义拆分 int z = 10; int z1 = z * z; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/542ba96d850d38cdef3e97a0aa50b305/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/93/">«</a>
	<span class="pagination__item pagination__item--current">94/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/95/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>