<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/913ade7b3860da9b5c8a1f5f126381fd/" rel="bookmark">
			vue与Ajax
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.VUE 以前说过了vue的安装配置以及基本结构，今天来说一下它的基本操作
1.1 MVVM思想 首先要说的就是它的一个重要思想MVVM的思想
M: model 数据层
V: view 视图层
VM: 视图数据的控制层
流程:
1. Model变化, 虚拟DOM操作内存数据变化. 所以页面变化.
2. View变化, 虚拟DOM操作内存数据变化, 数据变化.
1.2 var/let/const var 没有作用域的概念 容易出现安全性问题. 成员变量let 作用于var类似, 有作用域的概念 局部变量const 定义常量 1.3v-text/v-html {{msg}} 当页面没有渲染成功时.以原标签展现.v-text 当页面没有渲染完成,则不予展现.v-html 将html代码片段 渲染展现 v-html操作如下：当作html来解析，否则就是字符串
div: "&lt;h3&gt;我是一个标题标签&lt;/h3&gt;" &lt;div v-html="div"&gt;&lt;/div&gt; 1.4 v-model双向绑定 遇到文本框可以获取信息的就进行双向绑定
范围：1.文本框 2.单选框 3.多选框 4.下拉框 5.文本域
用户输入变化，则data数据区变化，数据区变化则文本框展现变化
1.5 @click事件绑定 遇到按钮进行事件绑定执行所绑定的方法
1.6分支结构 v-if=”条件“
v-else-if=”条件“
v-else（最后执行）
1.7for循环 v-for=”每个数据的名称 in 要循环遍历的数据名称“
v-for=”每个数据的名称，i in 要循环遍历的数据名称“ -----i是循环的下标，标识第几次循环
1.8输入框常用功能标签 v-model.trim 去空格（只能去除头和尾，不能去除中间的空格）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/913ade7b3860da9b5c8a1f5f126381fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7b571d914e46c8a5938e240e1a8ccde/" rel="bookmark">
			miniconda 安装 配置 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装
- 下载对应的安装包 https://docs.conda.io/en/latest/miniconda.html#macosx-installers
- 按提示完成安装操作
2、配置
- 去掉默认进入base环境的配置
conda config --set auto_activate_base false - 设置搜索时显示通道地址
conda config --set show_channel_urls true 3、conda更换清华源
- 打开 ~/.condarc，粘贴并保存以下内容，执行conda clean -i 清理索引缓存后立即生效
channels: - defaults show_channel_urls: true default_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 4、使用
- 环境管理常用命令
conda --version # 查看conda版本 conda update conda # 更新conda至最新版本，也会更新其它相关包 conda info --envs # 查看安装的环境列表 conda activate env_name # 切换至环境 conda deactivate # 退出当前环境 conda info # 查看当前环境的信息 conda create --name your_env_name python=3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7b571d914e46c8a5938e240e1a8ccde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10b27ae9bcd106f4c3adf575b1b55fb4/" rel="bookmark">
			台式电脑学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		预算 16000元（拼多多现价15499，待双十一或双十二再入手应该能再便宜点，同样有百亿补贴）
CPU 英特尔® 酷睿™ i7-11700F 处理器（16M 高速缓存，睿频至高可达 4.90 GHz）
K能超频，F不带核显（插了独显就不用核显），KF不带核显能超频，不超频的话带F就可以，下面是官网的介绍（注意如果买K版则下面的主板要改）
https://www.intel.cn/content/www/cn/zh/products/sku/212280/intel-core-i711700f-processor-16m-cache-up-to-4-90-ghz/specifications.html
重点关注如下要点：
建议客户价格$298.00 - $308.00 ，则308x7.1=2186.8RMB
最大内存大小（取决于内存类型）128 GB
内存类型DDR4-3200 ，最高3200MB/S
不买i9是因为要秉承次高档/款优先的原则
https://www.intel.cn/content/www/cn/zh/products/sku/212047/intel-core-i711700k-processor-16m-cache-up-to-5-00-ghz/specifications.html
$399.00 - $409.00，取400美元就是2840元RMB
散热 MC-2 120 CPU一体水冷
这个没所谓，能散热就行，看介绍http://mjapi.qztsw.cn/item/index/iid/575743872229
注意到价格249RMB
主板 华硕TUF GAMING B560M-PLUS电竞特工
https://www.asus.com.cn/store/product-4326.html
注意到899RMB，如果CPU带K版要换Z590的主板（直接贵近两千）
https://www.asus.com.cn/store/product-3813.html
￥2699
显卡 华硕/丽台GeForc RTX™3080Ti 12G
https://www.nvidia.cn/geforce/graphics-cards/30-series/rtx-3080-3080ti/
https://item.jd.com/100022009682.html
注意到10999RMB（RTX™3080Ti强烈意愿想入手，至于内存和硬盘可以后面自己补）
不买3090是因为要秉承次高档/款优先的原则
内存 海盗船复仇者16G DDR4 3200
16G够用了（当然32G更好），注意1条16G是单通道，2条8G是双通道更快
若原先是1条16G，后追加1条16G改双通道，要在BIOS中设置Dcts mMode为Ganged并保存
https://item.jd.com/46273915594.html?cu=true&amp;utm_source=baidu-juhe&amp;utm_medium=kong&amp;utm_campaign=t_1000151230_juhe#crumb-wrap
注意689RMB
SSD 西数_BLACK SN850-500G NVME M.2
500G够用了（当然1TB更好），https://item.jd.com/100009210509.html#crumb-wrap
注意919RMB
机箱 海盗船 4000D 中塔机箱 白
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10b27ae9bcd106f4c3adf575b1b55fb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/354a2256cb36cbe9506084f1a97138b1/" rel="bookmark">
			碳排放的研究综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		能源消费CO2排放研究综述.pdf
碳排放的估算 碳排放清单估算方法 使用IPCC 清单和能源统计年鉴来估计能源消费所产生的碳排放。通常使用能源燃烧的CO2排放系数*能源消耗量
可分为3类：
– 分部门计算的一般方法。自下而上。使用IPCC默认的排放因子
– 分部门计算的实际方法。使用根据区域和行业特性得到的排放因子。
– 基于能源表现消费量的参考方法。自上而下。根据官方能源统计数据估算能源消费碳排放量
一般使用能源表现消费量的参考方法。碳排放因子采取IPCC的缺省值。能源消费量的估计难点在于其独立的行政区划和能源统计标准。
在《能源统计报表》中有 3 种数据可以用来估算能源消费 CO 2 排放：“能源平衡表”、“分行业能源消费总量”、“分行业终端能源消费量”。
基于能源表观消费量的 3 种能源消费碳排放核算方法。
– 方法一从能源的投入产出、加工转换视角，基于能源平衡表估算CO 2 排放，图2所示是北京以原煤为例的能源平衡关系。
– 方法二从生产视角计算一次能源消费的 CO 2 排放。
– 方法三是从使用视角，计算分类终端生产的CO 2 排放。
生命周期估算方法 评价产品整个生命周期对环境影响的方法与人类生产活动相关的 CO 2 排放可以分为个人CO 2 排放、产品CO 2 排放、企业 CO 2 排放、区域 CO 2 排放等 4 个层面。生命周期法(包括“自上而下”、“自下而上”)被运用到 CO 2 排放的估算中，通常测度的是单一产品或企业产品(产品碳排放和非生产性活动碳排放)和区域碳排放从“摇篮到坟墓”的整个生命周期中因燃料使用以及制造和运输过程中产生的碳排放。生命周期法的使用通常需与投入产出方法相结合。 投入产出估算方法 碳排放强度的研究 CO 2 排放强度的高低一般情况下取决于化石能源的碳排放系数、化石能源的结构、化石能源在能源消费总量中的比例、能源强度以及技术进步、经济增长、经济结构变化、农村工业化和城市化进程等，但 CO 2 排放强度的高低并不表明效率高低。
碳排放绩效的研究 CO 2 排放绩效实质上是一种投入产出效率，它是由经济发展过程、能源资本和劳动力投入、经济产出等诸要素共同作用的结果，在测度过程中要突出其“全要素”特点，必须考虑 CO 2 生产过程中相关要素投入产出的指标才更为合理.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/354a2256cb36cbe9506084f1a97138b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/911e7b3f4a43a66a9d382e403b7f0a6a/" rel="bookmark">
			homebrew常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		brew install brew uninstall/rm/remove brew update 自动升级homebrew（从github下载最新版本） brew outdated 检测已经过时的软件 brew upgrade 升级所有已过时的软件，即列出的以过时软件 brew upgrade &lt;formula&gt; 升级指定的软件 brew pin &lt;formula&gt; 禁止指定软件升级 brew unpin &lt;formula&gt; 解锁禁止升级 brew upgrade --all 升级所有的软件包，包括未清理干净的旧版本的包 brew cleanup -n 列出需要清理的内容 brew cleanup &lt;formula&gt; 清理指定的软件过时包 brew cleanup 清理所有的过时软件 brew uninstall &lt;formula&gt; 卸载指定软件 brew uninstall &lt;fromula&gt; --force 彻底卸载指定软件，包括旧版本 brew list 显示所有的已安装的软件 brew search text 搜索本地远程仓库的软件，已安装会显示绿色的勾 brew search /text/ 使用正则表达式搜软件 参考：
1、https://cloud.tencent.com/developer/article/1867824
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a21cec5f4e3916eee8fe06a7e819adc/" rel="bookmark">
			结合maven认识mybatis(数据库图片待补充但初学也能看)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.什么是MyBatis MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。
上面是MyBatis官方的简介,我们把这段话说的直白一点,什么是MyBatis,为什么要用MyBatis
MyBatis是让你写的java程序对数据库进行增删改查的一个工具。
java对数据库进行增删改查的工具很多，较之于其他工具，mybatis容易上手，而且开发起来也很简单，同时与spring的组合也非常容易。
目前各大互联网公司多是使用mybatis。
所以,废话不多说,我们直接开始吧
二.测试用的数据库和表 既然是一个对数据库进行操作的工具,所以,我们首先准备好数据库和表
三.建立Maven工程 给Maven小白稍微介绍以下,如果熟悉Maven的,你可以看一下2.pom.xml文件,导入相关包,或者直接跳过这段内容
1.Maven工程的基本结构 你可以建立一个简单的java工程进行测试,不过这样子的话,你需要自己去导入相关的jar包,不过其实也不多,关键的就两个,一个MySql的连接jar包,一个MyBatis的jar包,不过还是强烈建议大家直接使用Maven工程.不过可能你还没有接触过Maven,无所谓,常用的开发工具IntelliJ IDEA和最新的Eclipse都默认安装了Maven插件,直接创建Maven工程就好了没使用过Maven工程也无所谓,知道下面两点,其实我们就可以无障碍的写代码了
日常使用Maven常用的功能其实就是自动帮我们导入相关的关联包
Maven是一个工程构建工具,简单来说,就是我们的Java工程要按照Maven规定的模式创建,java源文件应该放在什么位置,配置文件,测试文件该放在什么位置等等都有规定
上面展示的就是一个刚刚创建好的Maven工程的基本结构,接下来,我们在IntelliJ IDEA中创建一个Maven工程
这个样子创建好之后,就是上面Maven项目第一个截图的样子了
2.修改pom.xml文件,导入相关包 在标签中加入相应包的Maven标签,就能自动引入了
3.查找相关包的dependency标签 当然每个包相应的maven标签是什么也不用纠结,你可以在maven repository网站中搜索对应的包名就行了比如你要查找mybatis的包
搜索出很多mybatis相关内容,我们只是使用原始的mybatis包,选择第一个
选择你需要的mybatis版本,这里的版本划分的很细,其实并不重要,你随便选一个版本都可以
当你修改好pom.xml文件之后,IntelliJ IDEA会在右下角提示你是否在pom.xml文件修改后自动导入相关包
我们选择
Enable Auto-Import
就可以了
四.MyBatis配置文件 上面主要是和maven相关的,接下来才是MyBatis最重要的内容我们要使用MyBatis,肯定需要相关配置,现在主流的其实就两种XML配置文件,以及注解配置,我们先来看一下通过XML配置文件实现的过程下面是整个工程的结构
1.在resources目录中加入mybatis-configuration.xml文件 其实不用我多解释,大家也看的出来,现在这里主要配置的是数据库连接的相关内容,当然现在这里只是一个很简单的配置,后面我们还需要做修改
注意:mysql默认端口是3306,我这里由于使用了Docker映射出来的端口,所以端口做出了修改,你不必和我一样
2.定义表所对应的实体类 package com.yingside.bean;public class User { private int id; private String userTel; private String username; private String password; private String registrationTime; public int getId() { return id; } public void setId(int id) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a21cec5f4e3916eee8fe06a7e819adc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ed295d28ebd0065a6e84b765c21ac55/" rel="bookmark">
			mysql中的时间类型和比较大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql中的时间类型和比较大小 一、时间类型二、时间比较 一、时间类型 mysql有五大时间类型：
datetime 可以存储年月日时分秒类型的时间，如果在设计字段的时候可以设置获取当前时间，插入数据的时候，如果没有对该赋值，mysql会自动获取当前的时间填充
timestamp 可以存储年月日时分秒类型的时间，跟 datetime 一样，也可以存储时间戳，timestamp 的精度是14位，存储也是14位，但是如果设置了自己需要的精度，那么 mysql 会将14位处理成设置的精度进行显示，底层存储仍然是14位精度。timestamp 有一个比较有趣的字段，受当前时区的影响。如果某条记录的字段被修改（不包括datestamp字段），那么 datestamp 字段可以自动更新为数据修改的时间，所以也可以用来代替 updated_time 字段（我习惯用 updated_time 字段名来记录某条数据被修改的时间，方便查看）
在创建新记录和修改某条记录的时候都对该类型的字段更新为当前时间： ...... TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP 在创建新记录的时候把这个类型的字段设置为当前时间，当以后修改的时候，不再更新： ..... TIMESTAMP DEFAULT CURRENT_TIMESTAMP 在创建新记录的时候把这个字段设置为0，以后修改的时候更新该字段： ..... TIMESTAMP ON UPDATE CURRENT_TIMESTAMP 在创建新记录的时候把这个类型的字段字段设置为给定值，以后修改的时候也会更新该字段： ..... TIMESTAMP DEFAULT ‘yyyy-mm-dd hh:mm:ss' ON UPDATE CURRENT_TIMESTAMP date 可以存储年月日时间
time 可以存储时分秒时间
year 可以存储年份
二、时间比较 java中的常用的 Date 类本身提供了 before， after方法比较时间的先后，mysql中时间的比较灵活，可以直接使用 &lt;、&gt;、= 进行比较，适应所有时间字段，但是格式需要相同，也可以使用 between and 来进行比较。
还有一个比较灵活的，之前工作中，有这么个场景，有一个时间字段在 java 是String 类型，需要作为参数到 sql 语句中和时间类型的字段比较，一般我都是使用 MySQL 自带的 str_to_date(str, format) 函数将字符串先转化为时间类型再比较，后来发现其实时间类型的字段可以和字符串类型的字段直接进行比较，不用转为相同类型，省去了转化的时间，当然时间格式也要一样。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ed295d28ebd0065a6e84b765c21ac55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fc21033f0b04eb939ed0ac8934c7cf4/" rel="bookmark">
			FileWriter和FileReader
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考了CSDN两位博主的文章，以下附上原文链接：
版权声明：本文为CSDN博主「玩人」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/jeryjeryjery/article/details/72626238
原文链接：https://blog.csdn.net/szlg510027010/article/details/88974559
FileWriter和FileReader都是用来实现 字符读写到文件 的 IO类。
一、FileWriter 1.主要的构造函数有： FileWriter(String fileName) //用文件路径名来构造FileWrite //覆盖掉原来已有的内容 FileWriter(String fileName, true) //用文件路径名来构造FileWrite //从文件尾部以追加的方式写入数据 FileWriter(FileDesecriptor fd) //用文件描述符来构造FileWrite //覆盖掉原来已有的内容 FileWriter(FileDesecriptor fd,true) //用文件描述符来构造FileWrite //以追加的方式来写入数据 FileWriter(File file) //用File对象来构造FileWriter //覆盖掉原来已有的内容 FileWriter(File file,true) //用File对象来构造FileWriter //从文件尾部开始写 2.write() 的5种重载方式： write(int args) ： 写入数字，利用ASCII 码表或者Unicode表转化write(String str) ：写入字符串write(String str,int offset,int count)：写入字符串的一部分write(char[] array) ： 写入字符数组write(char[] array , int offset , int count) ：写入字符数组的一部分 3.write() 的用法：创、写、关 例：
FileWrite fw = new FileWrite("D:\\file1.txt") //创：new一个对象 fw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fc21033f0b04eb939ed0ac8934c7cf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b1c812c1b633d929fe77bf11701f3d3/" rel="bookmark">
			java8的stream对map存多个属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中间操作无状态 首先新建一个实体类
@Data @NoArgsConstructor @AllArgsConstructor public class User{ private String name; private String address; private String age; } 实例化两个对象放入list集合中
List&lt;User&gt; list1 = new ArrayList&lt;User&gt;(); User user = new User("pg1","北京1","2"); User user1 = new User("pg","北京","1"); list1.add(user); list1.add(user1); Map&lt;String, String&gt; map = list1.stream().collect(Collectors.toMap(User::getAddress, User::getName)); System.out.println(map); 执行过程结果：
1.抽取对象的code作为key，name作为value转化为map集合 再加一个user对象
User user2 = new User("pg3","北京","1"); list1.add(user2) (k1,k2)-&gt;k2 意思是遇到相同的key时取第二个值
(k1,k2)-&gt;k1 意思是遇到相同的key时取第一个值
Map&lt;String, String&gt; collect = list1.stream(). collect(Collectors.toMap(User::getAddress, User::getName, (k1, k2) -&gt; k2)); System.out.println(collect); 执行结果为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b1c812c1b633d929fe77bf11701f3d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/210cab3c46de319cf112d68a0bee1dcd/" rel="bookmark">
			Ubuntu BASH命令提示符样式添加git分支信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 PS1 是bash 中的一个环境变量,用来设置命令提示符，通过修改该环境变量可以在BASH命令提示符中添加上git分支信息
配置效果 配置方法 在~/.bashrc添加如下脚本 # 在~/.bashrc添加如下脚本 function parse_git_branch { git branch 2&gt; /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\ \(\1\)/' } # setting prompt with git branch export PS1="\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[32m\]\$(__git_ps1)\[\033[00m\]\n\$" 执行source ~/.bashrc刷新环境变量 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f4af6119b5abd20e8fa81ee0a732f58/" rel="bookmark">
			WSL2 Ubuntu版本升级提示Command terminated with exit status 1的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win10 WSL2 Ubuntu 18.04升级到20.04失败，提示Command terminated with exit status 1错误，查阅资料后发现是snapd兼容问题导致的，卸载后升级即可成功
升级失败log Reading cache Checking package manager Reading package lists... Done Building dependency tree Reading state information... Done Hit http://mirrors.163.com/ubuntu bionic InRelease Hit http://mirrors.163.com/ubuntu bionic-updates InRelease Hit http://mirrors.163.com/ubuntu bionic-backports InRelease Hit http://mirrors.163.com/ubuntu bionic-security InRelease Fetched 0 B in 0s (0 B/s) Reading package lists... Done Building dependency tree Reading state information... Done Restoring original system state Aborting Reading package lists... Done Building dependency tree Reading state information.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f4af6119b5abd20e8fa81ee0a732f58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93f3b491f21cabcbded1f7d1d6069476/" rel="bookmark">
			HFM 经典模式表结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载外网+自己理解
科目 1、表名中 HFM_ 是应用名称
2、如果出现重复数据是因为hfm_account_desc表中存在多种语言，筛选语言即可去重
select par.label FPARENT, -- Parent ch.label FCHILD, -- Child de.description FDESCRIPTION, -- Description decode(ch.accounttype, 0, 'Revenue', 1, 'Expense', 2, 'Asset', 3, 'Liability', 4, 'Balance', 5, 'Flow', 7, 'CurrencyRate', '') FACCTTYPE, decode(ch.iscalculated, 0, 'False', 'True') FISCALCULATED, -- HFM IsCalculated decode(ch.isconsolidated, 0, 'False', 'True') FISCONSOL, -- HFM IsConsolidated decode(ch.isicp, 0, 'N', 'Y') FISICP, -- HFM IsICP plg.label FPLUG, -- HFM PlugAccount ch.numdecimalplaces FDEC, -- HFM DecimalPlaces decode(ch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93f3b491f21cabcbded1f7d1d6069476/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3794e66dea35fc7b629b4623a1cbeb10/" rel="bookmark">
			字符串数字如何相加而不是合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 字符串数字如何相加---parseInt()、Number() parseInt（）方法可查看https://blog.csdn.net/freshlover/article/details/19034079
Number() 转载于:https://www.cnblogs.com/yiyi17/p/9449160.html
1）如果是Boolean值，true和false将分别转换为1和0。
2）如果是数字值，只是简单的传入和返回。
3）如果是null值，返回0。
4）如果是undefined,返回NaN。
5）如果是字符串，遵循下列规则：
如果是字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即“1”变成1，“123”会变成123，而“011”会变成11（前导的零被忽略了）；如果字符串中包含有效的浮点格式，如“1.1”，则将其转换为对应的浮点数值（同样也会忽略前导零）；如果字符串中包含有效的十六进制格式，例如"0xf"，则将其他转换为相同大小的十进制整数值；如果字符串是空的（不包含任何字符），则将其转换为0；如果字符串中包含除上述格式之外的字符，则将其他转换成NaN. 6)如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用的对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。
求百分比并保留两位小鼠 Math.round(num / total * 10000) / 100.00 + "%" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b863cb281428fdae626b2cbb783774b/" rel="bookmark">
			Sqoop抽取Postgresql数据到HDFS和Hive时数据量增多
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、现象：
postgresql源表数据量：
抽取到HDFS上和Hive之后数据量：
2、原因：
使用sqoop从pg库导出数据至HDFS或Hive时，如果数据中包含Hive指定的列分隔符，如”\001”或”\t”，那么在Hive中就会导致数据错位；如果数据中包含换行符”\n”，那么就会导致原先的一行数据，在Hive中变成了两行或多行数据，导致数据量增多。
正常的：
3、解决：
在sqoop执行import导入命令时添加参数–hive-drop-import-delims，作用是在导入时从字符串字段中删除”\n”、”\r”和”\01”。或者使用参–hive-delims-replacement，作用是在导入时将字符串字段中的”\n”、”\r”和”\01”替换为指定字符串。
命令：
sqoop import --D tez.queue.name=$queue_name --connect p g s q l h d s c d b c o n n e c t i o n / pgsql_hdsc_db_connection/ pgsqlh​dscd​bc​onnection/pg_db_name --username $pg_uname --password p g u p a s s w d − − t a r g e t − d i r / o r i g i n d a t a / pg_upasswd --target-dir /origin_data/ pgu​passwd−−target−dir/origind​ata/pg_db_name/ 1 / 1/ 1/db_date --delete-target-dir --num-mappers 1 --fields-terminated-by “\t” --hive-drop-import-delims --null-string ‘\N’ --null-non-string ‘\N’ --query “$2”’ and $CONDITIONS;’
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/528fbcc8be1a528c53ae89a538b98750/" rel="bookmark">
			shell脚本分析日志文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、需求说明二、脚本代码 一、需求说明 系统有报错文件error.log，现在需要每十分钟查看一次报错文件的内容，如果新增的报错中出现 ‘ERROR’关键字，需要提醒管理员 二、脚本代码 #! /bin/sh # 获取十分钟前的时间戳 enddate=$(date -d "10 minute ago" +%s) # 这里分二步 # 1. awk命令：获取error.log日志文件中包含 ERROR 关键字的行，行里面读取第一列和第二列（时间和分钟） # 2. cat命令：按行读取文件中最新的100行数据 awk '/ERROR/ {print $1,$2}' log_error.log | cat | tail -n 100 | while read line do # 截去右边.开始之后的右边所有数据，此步已省略 info=${line%.*} # 将info转化为时间戳 infodate=`date -d "$line" +%s` # 时间戳对比，如果日志的时间戳大于或等于十分钟前的时间戳，那么通知管理员 if [ "$infodate" -ge "$enddate" ]; then # 干你想干的 # 通知脚本没有写 echo $line fi done 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccb220c82ca3dd5a050f3a1fb2d71572/" rel="bookmark">
			Name node is in safe mode.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在抽取pg库数据时任务失败，报错：
com.aliyun.emr.flow.agent.common.exceptions.EmrFlowException:
###[E30001,STORAGE]: Failed to access the storage, cause: org.apache.hadoop.hdfs.server.namenode.SafeModeException: Cannot create directory /emr-flow/emr-header-1.cluster-233371/caches/FJI-AEDD85D149FECB19_0. Name node is in safe mode.
Resources are low on NN. Please add or free up more resources then turn off safe mode manually. NOTE: If you turn off safe mode before adding resources, the NN will immediately return to safe mode. Use “hdfs dfsadmin -safemode leave” to turn safe mode off. NamenodeHostName:emr-header-1.cluster-233371
org.apache.hadoop.hdfs.server.namenode.FSNamesystem.newSafemodeException(FSNamesystem.java:1394)
org.apache.hadoop.hdfs.server.namenode.FSNamesystem.checkNameNodeSafeMode(FSNamesystem.java:1381)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccb220c82ca3dd5a050f3a1fb2d71572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5efe932f6ba67dc26863df03280ca1b8/" rel="bookmark">
			is running beyond physical memory limits. Current usage: 1.0 GB of 1 GB physical memory used......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、任务执行报错截图：
1、错误分析：显示物理内存和虚拟内存的占用情况
Container [pid=24845,containerID=container_1625047493764_0479_01_000001] is running beyond physical memory limits. Current usage: 1.0 GB of 1 GB physical memory used; 6.6 GB of 4.9 TB virtual memory used. Killing container.
2、原因：
资源不够，提交的应用被kill掉。由于系统分配物理内存1G，hive执行时需要1.0G。可能是物理内存溢出（分为map和reduce两种可能）
3、解决：
调节参数。在mapred-site.xml配置中设置mapreduce的内存分配大小：
根据服务器的实际内存规格，现调大参数mapreduce.map.memory.mb的值为5120（根据实际情况调整）
根据服务器的实际内存规格，现调大参数mapreduce.reduce.memory.mb的值为5120（根据实际情况调整）
保存，部署配置生效。重新执行hive脚本，不再报错。
注意：有的在调整完这两个参数之后问题解决了，但是有的就会遇到其它的问题，比如任务可以跑起来了，但是mapreduce任务却运行卡住，memory.mb这种参数不用给这么大，调整回去1024或者2048。调整太大到时候更起不来，申请不到几个map和reduce，可能就是占用的太大了导致reduce没有资源去启动就一直卡着。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3e08f4b849df3351f961b94eb04628c/" rel="bookmark">
			使用C&#43;&#43; 多线程交替打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//无锁实现 #include &lt;iostream&gt; #include &lt;thread&gt; using namespace std; int number; const int MAXNUM = 10; // 输出范围：1 - MAXNUM // 打印奇数 void add_1() { while (1) { if (number % 2 == 0) { int temp_number = number; // 读出 number temp_number = temp_number + 1; // 加1 cout &lt;&lt; "mythread_1: " &lt;&lt; temp_number &lt;&lt; endl; // 输出 number = temp_number; // 写回 number if (temp_number == MAXNUM - 1) { break; } } } cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3e08f4b849df3351f961b94eb04628c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faa4988cf176b4d81ad406bc70f8c1c9/" rel="bookmark">
			massif——程序堆内存分析工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.安装教程 sudo apt-get install massif-visualizer
sudo apt-get install valgrind
2.使用方法 2.1 在roslaunch文件中增加launch-prefix，
例如：
&lt;node name="cartographer_node" pkg="cartographer_ros" type="cartographer_node" launch-prefix="valgrind --tool=massif --time-unit=B --trace-children=yes --massif-out-file=/home/aicrobo/massif.out.%p" args=" -configuration_directory $(find cartographer_ros)/configuration_files -configuration_basename backpack_2d_localization.lua -load_state_filename $(arg load_state_filename)" output="screen"&gt; &lt;remap from="echoes" to="horizontal_laser_2d" /&gt; &lt;/node&gt; 2.2 程序运行后，使用massif-visualizer查看结果
~$ massif-visualizer massif.out.15836 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/357fca601d43a4f7d05d053bc86402bc/" rel="bookmark">
			记录JPA并发save时遇到的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在JPA中，使用save方法时是这样的：如果我们save的对象指定了主键，那么会根据主键先进行一次查询，如果查询记录不存在则执行insert语句，如果查询记录存在则执行update语句。
问题现象 业务场景是这样的：当某个用户钱包流水发生变化时，我们会先查询用户钱包是否存在（新注册的用户一开始没有钱包），如果存在则直接更新钱包余额，并添加一条流水，如果用户钱包不存在，则新生成钱包，再更新钱包余额，最后添加流水。
当同一个用户同时产生多条流水时，现在的流程则可能出现问题。
伪代码 // 查询用户钱包是否存在 User u = select(userId); if(u == null){ // 不存在则生成钱包，初始化钱包余额为0 jpa.save(u); } // 添加流水 addFlow(u); // 更新钱包余额 update(u); 问题分析 问题就发生在当第一个线程save成功后，第二个线程再执行时，save就会变成update，并且会覆盖第一个线程所执行的操作。
解决方法 只要让自定义save方法，就是insert操作就可以了，当第2个线程save时，会报主键冲突，然后第2个线程再重试一次，再次查询钱包是否存在时，就可以查询到了，然后就不用再生成钱包了，直接更新余额即可（更新余额幂等性）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c30da19d3189e13dcea4ca57c163235c/" rel="bookmark">
			微信小程序canvas大小、定位适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序canvas大小、定位适配 在微信小程序canvas开发中,遇到一种情况：在iPhone X调好的定位大小，把机型调整为iPhone 5，由于iPhone5屏幕较小，canvas画出的内容就会错乱，这就要考虑不同设备兼容的问题，需要做适配（可参照以下方法）：
//适配前代码： let that = this; let ctx = wx.createCanvasContext('mycanvas', that); ctx.font = `normal normal bold 20px PingFang SC`; ctx.fillStyle = '#333'; ctx.fillText('name', 60, 60); ctx.draw(); //以上代码中文字name的字体大小是20px,定位的位置是x=60;y=60,这个定位在不同机型，不同屏幕大小显示的位置不一样，如果屏幕较小，偏移就较明显，字体可能也会比较大。 //适配后代码： let that = this; let ctx = wx.createCanvasContext('mycanvas', that); ctx.font = `normal normal bold ${parseInt(that.fitSize(20))}px PingFang SC`; ctx.fillStyle = '#333'; ctx.fillText('name', that.fitSize(60), that.fitSize(60)); ctx.draw(); //适配方法封装 /**canvas绘制文字适配 * @params coordinate 坐标值或大小 */ fitSize: function (coordinate) { let that = this; let windowWidth = that.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c30da19d3189e13dcea4ca57c163235c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06d5d7ba6e1dc40c6147df6db40c7052/" rel="bookmark">
			go-error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go 语言通过内置的错误接口提供了非常简单的错误处理机制。
error类型是一个接口类型，这是它的定义：
type error interface { Error() string } 我们可以在编码中通过实现 error 接口类型来生成错误信息。
函数通常在最后的返回值中返回错误信息。使用errors.New 可返回一个错误信息。
package main import ( "fmt" "strings" ) type stringError struct { strErr string } func (strEr *stringError) Error() string { return strEr.strErr + " is not _" } func isblank(s string) (string, string) { if strings.Compare(s, "_") != 0 { ss := stringError{s} return "wrong！", ss.Error() } return "Yes!", s + " is _" } func divide(i,j int)(rs int,string){ if j == 0{ return } } //errors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06d5d7ba6e1dc40c6147df6db40c7052/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e6cedec982ca7e8d9ab5b213ace13cb/" rel="bookmark">
			vscode cortex-debug openocd stm32配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境变量 安装mingw gcc -v mingw32-make -v 这里可以到bin目录下将mingw32-make.exe改名为make.exe
安装arm gcc toolchain arm-none-eabi-gcc -vc 安装openocd openocd -v vscode 插件安装 C/C++
ARM
Cortex-Debug
Cortex-Debug: Device Support Pack - STM32F4
配置 Ctrl+Shift+P
c_cpp_properties.json .vscode\c_cpp_properties.json是用于对C/C++语言的语法提示等的配置，其中include路径和宏定义可以参照makefile添加。
{ "configurations": [ { "name": "STM32", "includePath": [ "${workspaceFolder}/**", "D:/Program Files (x86)/GNU Arm Embedded Toolchain/9 2020-q2-update/**" ], "defines": [ "_DEBUG", "UNICODE", "_UNICODE", "USE_HAL_DRIVER", "STM32F401xE" ], "windowsSdkVersion": "10.0.17763.0", "compilerPath": "", "cStandard": "c99", "cppStandard": "c++17", "intelliSenseMode": "clang-x64", "browse": { "path": [ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e6cedec982ca7e8d9ab5b213ace13cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16afe5ba8b4cf516ed77abcfb9bc7b37/" rel="bookmark">
			30多个Java实战项目，全部在这里了。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		把一些Java项目全部分类汇总一些，大家需要可以自取。
微服务 推荐 7 个牛哄哄 Spring Cloud 实战项目
Spring Boot + Security + MyBatis + Thymeleaf + Activiti 快速开发平台项目
带工作流的springboot后台管理项目，一个企业级快速开发解决方案
介绍 6 款热门的 SpringCloud 微服务开源项目，总有适合你的！
推荐几个springboot学习教程和实战项目！
电商项目 推荐一个非常火爆的电商开源项目！
推荐两个项目！
47K Star 的SpringBoot+MyBatis+docker电商项目，附带超详细的文档！
推荐一个基于 SpringCloud 设计精良的网上商城
Vue2.5.1+Spring支持分销、团购、秒杀、优惠券、微信商城项目，源码免费分享
支付项目 一个整理支付宝、微信等支付项目的github仓库推荐：https://github.com/hello-java-maker/sihai-maven-ssm-alipay
推荐几个支付项目！
一个Github项目搞定微信、QQ、支付宝等第三方登录
Java博客项目 一款高颜值的 SpringBoot+JPA 博客项目
推荐一款Java开发的精美个人博客
想要搭建个人博客？这4个Java 开源博客系统，真香
后台管理系统 一款超炫酷后台权限管理系统
白嫖他悟空CRM项目 ，部署了直接用起来
12个非常适合做外包项目的开源后台管理项目
基于 Springboot 2.0 + LayUI 开发的物流管理系统
Java学生宿舍管理系统，即将毕业的兄弟有福了！
超优 Vue+Element+Spring 中后端解决方案
GitHub 上 6 款牛哄哄的后台模板
前后端分离项目 13K点赞都基于 Vue+Spring 前后端分离管理系统ELAdmin，大爱
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16afe5ba8b4cf516ed77abcfb9bc7b37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b6f9eaa1c18aa2e602229cc50d1294f/" rel="bookmark">
			Vue单文件组件data使用函数的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果不使用函数（点击查看官网介绍）
因为在普通写法写的是一个对象，是个引用数据类型，如果用单文件组件开发的时候，每个组件的数据应当是独立的，如果公用一个对象的话，在一个文件里修改数据，其他使用该组件页面也会跟着有变化，所以采用闭包的形式返回私有对象来使用（在Vue内部，会把每一个实例对象data调用之后返回值赋给实例身上的data，因为每个data内部返回的数据都为一个独立的对象，所以在每次通过闭包的形式访问data会形成独立的空间去存放）
第一步 function Component() {} Component.prototype.data = { a: 1, b: 2, }; let cp1 = new Component(); let cp2 = new Component(); console.log(cp1.data.a);//1 console.log(cp2.data.a);//1 在这里定义了一个构造函数Component(),给原型对象上添加了一个data属性，为一个对象
第二步 cp1.data.a = 3; console.log(cp1.data.a);//3 console.log(cp2.data.a);//3 在这一步我们证明了他们的原型对象上的data为一个对象，cp1和cp2这两个实例化对象的data指向的为同一个对象，所以修改一个，其他的也会进行修改的原因，这就是为什么不用对象的根本原因
怎么解决呢？
第三步 function Component() { this.data = this.data(); } Component.prototype.data = function() { return { a: 1, b: 2, }; }; let cp1 = new Component(); let cp2 = new Component(); cp1.data.a = 3; console.log(cp1.data.a);//3 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b6f9eaa1c18aa2e602229cc50d1294f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eae468517f30777fbcae6c9b74c3c343/" rel="bookmark">
			pyodps配置问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用pyodps运行SQL语句，在测试环境中能执行出结果，在生产环境反复执行就是没有结果，无奈求助dataworks大佬，这才发现是hive兼容模式的问题，导致日期解析出错！！！
opds添加代码
--打开MaxCompute 2.0数据类型 set odps.sql.type.system.odps2=true; --打开Decimal 2.0数据类型 set odps.sql.decimal.odps2=true; --Hive兼容模式 set odps.sql.hive.compatible=true; pyodps 修改代码
o.execute_sql(sql_inc,hints={'odps.sql.type.system.odps2':'true','odps.sql.decimal.odps2':'true','odps.sql.hive.compatible':'true'}) o.execute_sql(sql_all,hints={'odps.sql.type.system.odps2':'true','odps.sql.decimal.odps2':'true','odps.sql.hive.compatible':'true'}) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d08608bb169bf086d2f7a7ab07e9bbd/" rel="bookmark">
			基于Redisson实现Redis分布式锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 基于Redisson实现Redis分布式锁 https://riemann.blog.csdn.net/article/details/104763755
@Controller public class RedisLockController { private static final Logger LOGGER = LoggerFactory.getLogger(RedisLockController.class); @Resource private RedissonClient redissonClient; @Resource private StringRedisTemplate stringRedisTemplate; @RequestMapping("/deduct_stock_2") @Transactional public ApiResult deductStock() { String lockKey = "lockKey"; RLock rLock = redissonClient.getLock(lockKey); try { rLock.lock(); int stockNum = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock")); if (stockNum &gt; 0) { int realStockNum = stockNum - 1; stringRedisTemplate.opsForValue().set("stock", realStockNum + ""); LOGGER.info("扣减成功，剩余库存：{}", realStockNum); } else { LOGGER.info("扣减失败，库存不足"); } } finally { rLock.unlock(); } return new ApiResult(); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffc567e0fc5e078a9465cb3f8b414a72/" rel="bookmark">
			spark源码bug fix: Block broadcast_465 not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spark源码bug fix: Block broadcast_465 not found 前言一、spark源码bug fix: Block broadcast_465 not found二、问题描述2.问题分析 总结 前言 使用spark
一、spark源码bug fix: Block broadcast_465 not found 示例：pandas 是基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。
二、问题描述 21/08/25 20:26:18 ERROR spark.TaskContextImpl: Error in TaskCompletionListener java.lang.IllegalStateException: Block broadcast_465 not found at org.apache.spark.storage.BlockInfoManager$$anonfun$1.apply(BlockInfoManager.scala:288) at org.apache.spark.storage.BlockInfoManager$$anonfun$1.apply(BlockInfoManager.scala:288) at scala.Option.getOrElse(Option.scala:121) at org.apache.spark.storage.BlockInfoManager.unlock(BlockInfoManager.scala:287) at org.apache.spark.storage.BlockManager.releaseLock(BlockManager.scala:657) at org.apache.spark.broadcast.TorrentBroadcast$$anonfun$org$apache$spark$broadcast$TorrentBroadcast$$releaseLock$1.apply(TorrentBroadcast.scala:246) at org.apache.spark.broadcast.TorrentBroadcast$$anonfun$org$apache$spark$broadcast$TorrentBroadcast$$releaseLock$1.apply(TorrentBroadcast.scala:246) at org.apache.spark.TaskContext$$anon$1.onTaskCompletion(TaskContext.scala:123) at org.apache.spark.TaskContextImpl$$anonfun$markTaskCompleted$1.apply(TaskContextImpl.scala:97) at org.apache.spark.TaskContextImpl$$anonfun$markTaskCompleted$1.apply(TaskContextImpl.scala:95) at scala.collection.mutable.ResizableArray$class.foreach(ResizableArray.scala:59) at scala.collection.mutable.ArrayBuffer.foreach(ArrayBuffer.scala:48) at org.apache.spark.TaskContextImpl.markTaskCompleted(TaskContextImpl.scala:95) at org.apache.spark.scheduler.Task.run(Task.scala:112) at org.apache.spark.executor.Executor$TaskRunner.run(Executor.scala:322) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffc567e0fc5e078a9465cb3f8b414a72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58a329b4a9c03953f5f3cec873c01eb4/" rel="bookmark">
			VS报错：license 许可证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题版本：vs2017+intel parallel studio xe 2018 update 3破解版
问题：
A license for (Comp-FW) could not be found.
could not checkout license
原因：安装时用的.lic文件过期了 解决方法：我没有新的.lic，安装了其他版本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bcb155eb1de1edc8113d7024f367e0b/" rel="bookmark">
			VS出错：无法正常监视变量 undefined 未定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题版本：vs2013+ivf
问题：监视窗口显示大量undefined未定义问题（当时没截图，和下图相似，但不只是标识符）
解决方法：重装其他版本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92386e5c405e4a9240fadb9685267ad8/" rel="bookmark">
			解决“: no such file or directory, scandir ‘..\node_modules\node-sass\vendor“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 分析我的原因： 当你下载完@vue/cli 全局时候 ，在重新构建项目的时候，就不用下载了，直接回构建就可以了 但是，在你构建项目的时候，会出现报错，解决办法，如下：
重新构建一下npm rebuild node-sass包~
npm rebuild node-sass 报错的信息也是通过网上查找的，看了他的信息以后，项目就构建成功了。
这个是我看的他的信息，解决的~~~
https://blog.csdn.net/qq_39490750/article/details/112605060
图片没有及时截取，这个报错会提示你说丢失文件，但是你重新构建一下就行了。还有就是在生活中或者在学习中一定要稳住心态，没有过不去的坎，一起加油！ 谢谢~~~ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb9643768989dd197597e0de95628d31/" rel="bookmark">
			【C&#43;&#43;】VS 旧版本代码转移到新版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打开VS-文件-新建-项目-筛选器（C++ Windows）-空项目-下一步
2.项目名称-位置-创建
3.将原有的.h和.cpp复制到该位置下
4.右键-添加-现有项- 选中扩展名为.h和.cpp的文件
5.将需要调用的文件（如，txt等等），放在.sln所在文件夹 6.运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e71b088efba31eed0505a11b2f090996/" rel="bookmark">
			使用Lombok并在类中添加注释@builder，建造者模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在看别人的项目时，我发现会有这样一种写法。
借助外部工具使用建造者模式
从使用的角度看，我觉得它很好用，代码也很好看。事实上，我们都把逻辑写到domain类中，这需要时间来写。
我的第一印象是，一定有一种方法可以通过一次点击就生成这样一个通用的东西，所以我把目标瞄准了Lombok。
当然，如果我们使用Lombok并在类中添加注释@builder，我们就可以使用builder模式的代码了，这非常方便。
我想了一下现在的IDEA那么强大一定可以生成Builder。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7777b117c5ec0ea26a729f0337f7cd21/" rel="bookmark">
			数据结构(数组)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构笔记 向数组中添加元素向数组的尾部添加元素在数组的头部添加在指定位置添加元素 更改数组的容积获取指定位置的元素修改指定位置的元素是否包含指定的元素内容删除指定位置的元素移除头部元素移除尾部元素删除指定的元素 数组最大的优点：快速查询。
数组最好应用于索引有语义的情况。
并非所有有语义的数字都可以作为数组的索引，例xaaacaacsaaacsaawcacc
//统计每个字符出现的次数 String str="xaaacaacsaaacsaawcacc"; int[]counts=new int[26]; for (int i=0;i&lt;str.length();i++){ char c=str.charAt(i); counts[c-'a']++; } for (int item:counts){ System.out.println(item); } //方法二 Map&lt;Character,Integer&gt;map=new HashMap&lt;&gt;(); for (int i=0;i&lt;str.length();i++){ char c=str.charAt(i); if(!map.containsKey(c)){ map.put(c,1); }else{ map.put(c,map.get(c)+1); } System.out.print(c); } 向数组中添加元素 向数组的尾部添加元素 /** * 向数组的尾部添加元素 * @param ele 元素内容 */ public void addTail(T ele) { add(this.size, ele); } 在数组的头部添加 // 在数组的头部添加 public void addHead(T ele) { add(0, ele); } 在指定位置添加元素 /** * 在指定位置添加元素 * @param index 索引 * @param ele 内容 */ public void add(int index, T ele) { if (index &lt; 0 || index &gt; size) { throw new IllegalArgumentException("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7777b117c5ec0ea26a729f0337f7cd21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fb041f40d7f9a7800bbbf483f16d4a4/" rel="bookmark">
			Aviator规则表达式引擎介绍及源码跟踪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Aviator规则表达式引擎介绍及源码跟踪 Aviator规则表达式引擎分类Aviator原理及特点Aviator解析性能执行配置推荐最佳实践源码跟踪编译：执行：读取缓存： 应用场景思考实践案例：1.工作流逻辑判定2.数据处理及转换 Aviator 规则表达式引擎分类 编译型规则表达式引擎：预先编译成可执行对象,运行时多次执行；解释型规则表达式引擎：不需要预先进行编译,在运行时,要先进行解释再运行。 Aviator原理及特点 Aviator 的基本过程是将字符串表达式直接翻译成对应的 java 字节码执行，整个过程最多扫两趟（开启执行优先模式，如果是编译优先模式下就一趟），这样就保证了它的性能超越绝大部分解释性的表达式引擎，测试也证明如此；其次，除了依赖 commons-beanutils 这个库之外（用于做反射）不依赖任何第三方库，因此整体非常轻量级，整个 jar 包大小哪怕发展到现在 5.0 这个大版本，也才 430K。同时， Aviator 内置的函数库非常“节制”，除了必须的字符串处理、数学函数和集合处理之外，类似文件 IO、网络等等你都是没法使用的，这样能保证运行期的安全，如果你需要这些高阶能力，可以通过开放的自定义函数来接入。因此总结它的特点是：
高性能轻量级开放能力：包括自定义函数接入以及各种定制选项一些比较有特色的特点：
1.支持运算符重载
2.原生支持大整数和 BigDecimal 类型及运算，并且通过运算符重载和一般数字类型保持一致的运算方式。
3.原生支持正则表达式类型及匹配运算符 =~
4.支持lambda ，可以灵活地处理各种集合 Aviator解析 AviatorScript 编译和执行的入口是 AviatorEvaluatorInstance 类，该类的一个实例就是一个编译和执行的单元。
AviatorEvaluator.getInstance() 返回一个全局共享的AviatorEvaluatorInstance 类，没有定制化的需求，该默认引擎已足够我们本次的讲解。
AviatorEvaluatorInstance 入口常用Api：
public final class AviatorEvaluatorInstance { //编译字符串表达式，cacheKey缓存标识，cached-是否缓存 public Expression compile(final String cacheKey, final String expression, final boolean cached) //编译aviatorScript脚本文件，cacheKey缓存标识，cached-是否缓存 public Expression compileScript(final String cacheKey, final File file, final boolean cached) throws IOException //执行字符串表达式，env环境变量，cached-是否缓存Expression对象 public Object execute(final String expression, final Map&lt;String, Object&gt; env, final boolean cached) } 示例1、执行字符串表达式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fb041f40d7f9a7800bbbf483f16d4a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90ed301b94d802671dcb92234ddc1763/" rel="bookmark">
			给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本思路：想要合并多个升序的链表，前提是需要会合并两个升序排列的链表。具体的方法在之前的博文中有提及合并两个有序的链表
大概的思路和合并两个有序数组基本相同，就是在链表的最开始确定两个指针，根据指针来确定哪个链表的元素更小一点，将小的哪个链表移入到合并的链表中并后移以为，然后继续比较最前面的指针，重复以上的步骤直到一个链表为空，说明另外一个链表中存在的数都是最大的数，只需要将他们连接到合并链表的后面就完成了。
合并多个链表就是循环合并两个链表的过程，我们合并第一个第二个链表生成一个新的链表，然后用这个新生成的链表去合并第三个链表以此类推。。。。代码如下：
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode mergeKLists(ListNode[] lists) { ListNode head = null; if(lists == null || lists.length == 0){ return head; } head = lists[0]; for(int i = 0;i &lt; lists.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90ed301b94d802671dcb92234ddc1763/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f6eff742b6e5ca23e98dcedd15869d4/" rel="bookmark">
			LCIS（最长公共上升子序列）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 给定两个长度分别为n和m的序列A和B，求两个序列的最长公共上升子序列长度。
例如：
1 5 3 6 3 2 7 3 6 2 和 9 6 2 3 1 5 3 3 6 1 的最长上升子序列的长度为3。
题目分析 这是一道LIS和LCS的综合题目。
【状态定义】： d p [ i ] [ j ] dp[i][j] dp[i][j]表示序列 A [ 1 : i ] A[1:i] A[1:i]和序列 B [ 1 : j ] B[1:j] B[1:j]构成的以 B [ j ] [ B[j][ B[j][为结尾的LCIS长度。
【状态转移】 为：
A [ i ] ≠ B [ j ] A[i] ≠ B[j] A[i]​=B[j] ： d p [ i ] [ j ] = d p [ i − 1 ] [ j ] dp[i][j] = dp[i-1][j] dp[i][j]=dp[i−1][j] (可以理解为将 A [ i ] A[i] A[i]扔掉) A [ i ] = B [ j ] A[i] = B[j] A[i]=B[j] ： d p [ i ] [ j ] = m a x { d p [ i − 1 ] [ k ] } dp[i][j] = max\{ dp[i-1][k]\} dp[i][j]=max{dp[i−1][k]} , k k k 满足： k ∈ [ 0 , j ) , B [ k ] &lt; B [ j ] k∈[0,j) ,B[k]&lt;B[j] k∈[0,j),B[k]&lt;B[j]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f6eff742b6e5ca23e98dcedd15869d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bcc52378c94d3d8dcae6601c451320f/" rel="bookmark">
			Meshroom安装中的两个坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Meshroom是一款基于AliceVision框架开发的免费、开源的三维重建软件。它可以根据不同方位拍摄的照片重建三维模型
Meshroom的github上有Windows和Linux的打包文件，按教程下载解压后即可使用。但我在安装时还是遇到了两个问题：
点击Meshroom.exe后闪出命令行窗口，使用cmd执行后报错：
qt.qpa.plugin: Could not find the Qt platform plugin “windows“ in ““
解决方法：
将PySide2plugins目录加入到QT_QPA_PLATFORM_PLUGIN_PATH环境变量里面。
lib &gt; PySide2 &gt; plugins
可参考：https://blog.csdn.net/weixin_40922744/article/details/111355088
添加路径后打开仍然报错：“This application failed to start because no qt platform plugin could be initialized.”
解决方法：
meshroom所在路径不能含有中文（严格说不嫩含非ASCII码）。
参考：https://github.com/alicevision/meshroom/issues/304
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc99297eeefca186a9af17e666a1e04c/" rel="bookmark">
			web实现点击左侧导航，右侧加载不同的网页（这种布局多用于后台管理系统）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）实现方法：采用ajax实现点击左侧菜单，右侧加载不同网页（在整个页面无刷新的情况下实现右侧局部刷新，用到ajax注意需要在服务器环境下运行，从HBuilder自带的服务器中打开浏览效果即可）
（2）原理：ajax的局部刷新原理：通过.load()重新加载页面中的某一部分，巧妙的借助data-*的自定义属性来存储数据，点击的时候修改锚点，因为地址有变，所以刷新的时候仍然会保持当前的页面内容而不是切换到第一个。
（3）适用场景：遇到ajax局部刷新的需求也有很多，有时候比较简单，当内容较少，适合做成选项卡；如果网页的左侧有一个列表，点击列表使右侧的内容进行切换，如果右侧的内容过多，不适合做选项卡，这时候用.load()局部刷新最好不过了，在项目中经常使用到流程管理后台，便是左右结构布局，这个时候，简单的demo示例如下
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;title&gt;ajax局部刷新&lt;/title&gt; &lt;style&gt; .userMenu { float: left; width: 200px; } #content { float: left; } &lt;/style&gt; &lt;meta charset="utf-8"/&gt; &lt;script src="http://code.jquery.com/jquery-1.8.0.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="userWrap"&gt; &lt;ul class="userMenu"&gt; &lt;li class="current" data-id="center"&gt;用户中心&lt;/li&gt; &lt;li data-id="account"&gt;账户信息&lt;/li&gt; &lt;li data-id="trade"&gt;交易记录&lt;/li&gt; &lt;li data-id="info"&gt;消息中心&lt;/li&gt; &lt;/ul&gt; &lt;div id="content"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; $(function() { $(".userMenu").on("click", "li", function() { var sId = $(this).data("id"); //获取data-id的值 window.location.hash = sId; //设置锚点 loadInner(sId); }); function loadInner(sId) { var sId = window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc99297eeefca186a9af17e666a1e04c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e448ceb4c99422e71609a68b44d08bed/" rel="bookmark">
			stm32cubemx 串口（详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		stm32cubemx 串口（详细） 完整的工程已上传到码云：
gitee（码云）
一、软件配置 1、将串口1配置为异步模式，并使能中断。 2、USART1配置窗口介绍 Mode描述硬件引脚支持外设Asynchronous异步模式TXD、RXDUSART、UARTSynchronous同步模式TXD、RXD、CKUSARTSingle Wire (Half-Duplex)半双工单线模式TXDUSART、UARTMultiprocessor Communication多处理器通讯模式TXD、RXDUSART、UARTIrDA红外解码通信TXD、RXDUSART、UARTLIN总线通信TXD、RXDUSART、UARTSmartCard智能卡模式TXDUSART、UARTSmartCard with Card Clock带时钟智能卡模式TXD、CKUSART 其中UART(Universal Asynchronous Receiver/Transmitter)为通用异步收发器
USART：（Universal Synchronous/Asynchronous Receiver/Transmitter）通用同步/异步串行接收/发送器USART是一个全双工通用同步/异步串行收发模块，该接口是一个高度灵活的串行通信设备。
二、HAL库串口相关的函数 串口的发送和接收函数：
//串口轮询模式发送,使用超时管理机制 HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout); //串口轮询模式发送,使用超时管理机制 HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout); //串口中断模式发送 HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size); //串口中断模式接收 HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size); //串口DMA模式发送 HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size); //串口DMA模式接收 HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size); /** * @param huart Pointer to a UART_HandleTypeDef structure that contains * the configuration information for the specified UART module.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e448ceb4c99422e71609a68b44d08bed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed017533dab5fd2ce32b5eb232362b82/" rel="bookmark">
			抽象数据类型 ADT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5. 抽象数据类型（ADT） 抽象数据类型 (ADT，Abstract Data Type)是指一个 数学模型 以及定义在此数学模型上的一组操作。 它通常是对数据的某种抽象，定义了数据的 取值范围 及其结构形式，以及对 数据操作 的集合 。抽象数据类型是描述数据结构的一种理论工具，其目的是使人们能够独立于程序的实现细节来理解数据结构的特性。
抽象数据类型 （ abstract data type ） 是从数据使用者的角度去看数据类型。抽象数据类型是对数据的一种抽象描述，是一种数学上的约束。数据结构是ADT的底层实现。
就相当于程序员看数据，只管有什么方法，会得到什么结果，而不管底层是怎么操作空间的，怎么赋值的
如 JS 数组 ：
学习数据结构，就是要研究其底层是如何实现的 ，增加数据怎么分配空间 ， 怎么插入数据 ，怎么删除数据 ，是链式存储还是线性存储。
描述抽象数据类型的标准格式 ： ADT 抽象数据类型名 Data 数据元素之间的逻辑关系的定义 Operation 操作 endADT // 相当于把数据类型给抽象出来
ADT ( 叫什么 ) Data （数据元素是什么类型 ， 数据之间有什么关系） Operation （这个数据类型有什么操作） endADT (抽象结束) 如抽象数组
ADT Array Data 线性数组Array的数据对象集合为[a1,a2,a3,a4,...,an] , 由有限个元素有序组成 ， 数据类型可以是字符串或数字。当有2个以上元素时，除首尾每个元素都有一个前驱和一个后继， 第一个元素只有后继 ， 最后一个元素只有一个前驱。可以没有或只有一个元素。 Operation length 返回数组长度 slice(starL,endL) 截取出数组的部分数组 push(new) 在末尾加入新的元素 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed017533dab5fd2ce32b5eb232362b82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d17e54d9f728cdf137d5ecc9323d21a0/" rel="bookmark">
			python logging 日志轮转文件不删除问题的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python logging 日志轮转文件不删除问题的解决方法
参考文章：
（1）python logging 日志轮转文件不删除问题的解决方法
（2）https://www.cnblogs.com/tsw123/p/8978790.html
备忘一下。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ea97b50a9ca0a849711fc701116b787/" rel="bookmark">
			【Spring Cloud】目录！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.简介
2.微服务架构设计
3.Eureka服务注册
5.Consul服务注册
6.Ribbon服务调用
7.OpenFeign服务调用
8.Hystrix断路器
9.Gateway网关
10.Config分布式配置中心
11.Bus消息总线
12.SpringCloud Stream消息驱动
13.SpringCloud Sleuth分布式请求链路追踪
14.SpringCloud Alibaba入门简介
15.SpringCloud Alibaba Nacos服务注册和配置中心
16.SpringCloud Alibaba Sentinel实现熔断与限流
17.SpringCloud Alibaba Seata处理分布式事务
18.打包部署jar包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/637ccfaa20492113cf8dc9b7a86f5b34/" rel="bookmark">
			Tableau——用条形图或环形图来呈现进度百分比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、适用场合： 在仪表板上放一个呈现进度百分比的图表
二、操作步骤： （一）百分比条形图：
1.创建计算字段：
“2018年订单数”：countd(if year([订单日期])=2018 then [订单 Id] end )
“总订单数”：countd([订单 Id])
“2018年订单数占比”：[2018年订单数]/[总订单数]
2.建立图表：先将“维度”当中的“度量值”拖入“列”当中，再将“度量”中的“度量名称”拖入标记卡中的“颜色”中，然后你的画布中会出现这样的图形
3.移除其他度量值胶囊：在“度量值”标记卡中，找到两个我们只需要的字段“2018年订单数”和“总订单数”，而将除此之外的其他度量值胶囊全部移除
4.修正计算字段：在“度量值”选项卡中，双击“总订单数”胶囊，修改为“[总订单数]-[2018年订单数]”
5.修改后，你的界面是如下这样的。我们可以观察发现，现在的条形图是合理的
6.修改格式：双击右侧的图例颜色，以编辑颜色。我们将这两种条设置成符合我们正常逻辑的颜色，比如2018年订单数为红色，减数为灰色
7.设置完颜色后，画布是如下这样的。我们发现红色和灰色放反了位置
8.出现这种情况的话，我们可以通过拖拽“度量值”标记卡中胶囊的顺序，以更改图形顺序
9.创建新的工作表：更改此工作表名称为“条形”，并且再创立一个工作表，命名为“百分数”。直接将我们事先创建好的计算字段“2018年订单数占比”拖拽到“文本”标记卡中
10.再修改该字段胶囊的数字格式为“百分比”
11.将两个工作表放入容器：创建完这两个工作表后，我们将它们同时放到一个仪表板中的垂直容器里，并且隐藏标题和轴
12.选中百分数的工作表，将它设置成“整个视图”
13.然后再右键百分数区域，设置格式，转到左边“设置对齐方式格式”
14.更改“默认值”-“区”的水平对齐为“居中”
15.完成：
（二）百分比环形图：
1.创建计算字段：
“广东省销售额”：sum(if [省/自治区]=‘广东’ then [销售额] end )
“广东省销售额占比”：[广东省销售额]/sum([销售额])
2.建立图表：在没有执行任何操作的时候，先更改标记卡中的图形类型为“饼图”
3.将 “维度”当中的“度量值”拖入“角度”当中，再将“度量”中的“度量名称”拖入 “颜色”中，然后你的画布中会出现这样的图形
4.移除其他度量值胶囊：在“度量值”标记卡中，移除除字段“广东省销售额”和“总和(销售额)”之外的其他度量值胶囊
5.“度量值”选项卡中只有我们需要的两项
6.修正计算字段：与百分比条形图一样，我们想要呈现的百分比饼图，有颜色的部分应该是逻辑正确数，而没有颜色或者灰色的部分应该是（总量-逻辑正确数）才对。所以我们需要在“度量值”选项卡中，双击“总和(销售额)”胶囊，修改为“SUM([销售额])-[广东省销售额]”（引用字段可以直接从数据窗格中拖拽进来）
7.修改后，你的界面是如下这样的。我们可以观察发现，现在的饼图是合理的，饼图的角度发生了变化
8.修改格式：更改页面视图为“整个视图”
然后双击右侧图例的颜色块，以编辑颜色；我们将这两种颜色设置成符合我们认知规律的颜色，比如广东省销售额为蓝色，减数为灰色
9.制作环形图：
1）创建饼图：
（1）打开 Tableau Desktop，链接“示例-超市”数据源，新建工作表。
（2）将字段“销售额”拖放至行，将字段“类别”拖放至列。单击右上角“智能推荐”卡，选择：饼图
2）使用双轴：
（1）将字段“记录数”拖放至行，并重复操作一次，在行中可以看到两个“记录数”胶囊。
*Tableau 2020.4 及以上版本用户，数据窗格没有“记录数”字段，可自行创建一个计算字段：记录数（如下图）
（2）分别右键单击行上的两个“记录数”胶囊，在下拉菜单中选择：度量（总和）-最小值
（3）展示如下：
（4）右键单击纵轴，在下拉菜单中选择：双轴
（5）两个饼图重叠到了一起，呈现如下效果：
3）创建环形：
*此时，有 3 个“标记”卡：全部、最小（记录数）、最小（记录数）2。
（1）打开“最小（记录数）2”“标记”卡，将里面的胶囊全部拖走。然后单击“颜色”卡，在弹框中将颜色设置为：白色；再单击“大小”卡，往左拖动鼠标，将白色圆饼变小，成为圆环的内饼
（2）最后，将字段“类别”和“销售额”拖放至“最小（记录数）”“标记”卡的标签中，右键单击该标记卡中的“总和（销售额）”胶囊，在下拉菜单中选择：快速表计算-合并百分比。再将“销售额”拖放至“最小（记录数）2”“标记”卡的标签中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/637ccfaa20492113cf8dc9b7a86f5b34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92f0c77524ef7cb834804a064738c341/" rel="bookmark">
			Gradle 团队发布了Gradle 7.2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Gradle 团队近日发布 Gradle 7.2，Gradle 是一个类似于 Maven 项目的自动化构建工具，支持依赖管理和多项目。Gradle 抛弃了 Maven 基于 XML 的繁琐配置，取而代之的是Gradle 采用了特定语言 Groovy 的配置，大大简化了构建代码的行数,易于人工维护程序。
来源于网络 升级说明 通过更新包装器将切换为 Gradle 7.2：
./gradlew wrapper --gradle-version=7.2
或者参阅 Gradle 7.x 升级指南，了解升级到 Gradle 7.2 时的弃用、重大更改和其他注意事项。
有关 Java、Groovy、Kotlin 和 Android 兼容性，请参阅完整的兼容性说明。
增加新功能和可用性改进。 对 Scala 项目的工具链支持复制文件时保留转义序列改进了基于 HTTP 标头的身份验证的凭据处理支持 dependencies 并 dependencyInsight 配置名称缩写版本目录改进声明子访问器声明插件版本 性能改进 Gradle 7.2 还对性能进行了优化：
完善操作系统之间的构建缓存命中率支持 Groovy 和 Scala 项目的配置缓存 远程构建缓存的可靠性改进 出现临时网络错误时可自动重试上传默认跟随重定向使用 Expect-Continue 避免冗余上传 此外，Gradle 7.2 还修复了共计 51 个 issue。
更新详情查看链接：https://docs.gradle.org/7.2/release-notes.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f9064184c2e46c745a4d4bf3c9a81b2/" rel="bookmark">
			按键FIFO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* * @Author: John Luo * @Date: 2021-08-25 10:54:28 * @LastEditTime: 2021-08-25 13:01:24 * @LastEditors: John Luo * @Description: 1. 自定义IsKeyDown()函数 * 2. gp_InitKeyVar()赋值函数指针 * 3. 连按功能需要打开长按功能 * @FilePath: \61F14x_UART\gp_key.c */ #include "gp_key.h" #include "SYSCFG.h" static KEY_T s_tBtn[KEY_COUNT]; static KEY_FIFO_T s_tKey; /* 需要自己定义 *****************************************/ static uint8_t IsKeyDown0(void) { if (KEY0 == 0) return 1; else return 0; } static uint8_t IsKeyDown1(void) { if (KEY1 == 0) return 1; else return 0; } static uint8_t IsKeyDown2(void) { if (KEY2 == 0) return 1; else return 0; } static uint8_t IsKeyDown3(void) { if (KEY3 == 0) return 1; else return 0; } /********************************************************/ /** * @description: * @param {KEY_ID_E} _ucKeyID * @param {uint16_t} _LongTime * @param {uint8_t} _RepeatSpeed * @return {*} */ static void gp_SetKeyParam(KEY_ID_E _ucKeyID, uint16_t _LongTime, uint8_t _RepeatSpeed) { s_tBtn[_ucKeyID].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f9064184c2e46c745a4d4bf3c9a81b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f8364d3a47adc4ba16a3e3176e11a8c/" rel="bookmark">
			Nacos原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Provider APP：服务提供者
Consumer APP：服务消费者
Name Server：通过VIP（Virtual IP）或DNS的方式实现Nacos高可用集群的服务路由
Nacos Server：Nacos服务提供者，里面包含的Open API是功能访问入口，Conig Service、Naming Service 是Nacos提供的配置服务、命名服务模块。Consitency Protocol是一致性协议，用来实现Nacos集群节点的数据同步，这里使用的是Raft算法（Etcd、Redis哨兵选举）
Nacos Console：控制台
注册中心的原理 服务实例在启动时注册到服务注册表，并在关闭时注销
服务消费者查询服务注册表，获得可用实例
服务注册中心需要调用服务实例的健康检查API来验证它是否能够处理请求
心跳机制：
从上述代码看,所谓心跳机制就是客户端通过schedule定时向服务端发送一个数据包 ,然后启动-个线程不断检测服务端的回应,如果在设定时间内没有收到服务端的回应,则认为服务器出现了故障。Nacos服务端会根据客户端的心跳包不断更新服务的状态。
注册原理：
Nacos提供了SDK和Open API两种形式来实现服务注册。
Open API：
SDK：
这两种形式本质都一样，底层都是基于HTTP协议完成请求的。所以注册服务就是发送一个HTTP请求：
对于nacos服务端，对外提供的服务接口请求地址为nacos/v1/ns/instance，实现代码咋nacos-naming模块下的InstanceController类中：
从请求参数汇总获得serviceName（服务名）和namespaceId（命名空间Id）
调用registerInstance注册实例
创建一个控服务（在Nacos控制台“服务列表”中展示的服务信息），实际上是初始化一个serviceMap，它是一个ConcurrentHashMap集合
getService，从serviceMap中根据namespaceId和serviceName得到一个服务对象
调用addInstance添加服务实例
根据namespaceId、serviceName从缓存中获取Service实例
如果Service实例为空，则创建并保存到缓存中
通过putService()方法将服务缓存到内存
service.init()建立心跳机制
consistencyService.listen实现数据一致性监听
service.init ( )方法的如下图所示，它主要通过定时任务不断检测当前服务下所有实例最后发送心跳包的时间。如果超时,则设置healthy为false表示服务不健康,并且发送服务变更事件。
在这里请大家思考一一个问题,服务实例的最后心跳包更新时间是谁来触发的?实际上前面有讲到, Nacos客户端注册服务的同时也建立了心跳机制。
putService方法，它的功能是将Service保存到serviceMap中：
继续调用addInstance方法把当前注册的服务实例保存到Service中：
总结：
Nacos客户端通过Open API的形式发送服务注册请求
Nacos服务端收到请求后，做以下三件事：
构建一个Service对象保存到ConcurrentHashMap集合中
使用定时任务对当前服务下的所有实例建立心跳检测机制
基于数据一致性协议服务数据进行同步
Nacos服务地址动态感知原理 可以通过subscribe方法来实现监听，其中serviceName表示服务名、EventListener表示监听到的事件：
具体调用方式如下：
或者调用selectInstance方法，如果将subscribe属性设置为true，会自动注册监听：
Nacos客户端中有一个HostReactor类，它的功能是实现服务的动态更新，基本原理是：
客户端发起时间订阅后，在HostReactor中有一个UpdateTask线程，每10s发送一次Pull请求，获得服务端最新的地址列表
对于服务端，它和服务提供者的实例之间维持了心跳检测，一旦服务提供者出现异常，则会发送一个Push消息给Nacos客户端，也就是服务端消费者
服务消费者收到请求之后，使用HostReactor中提供的processServiceJSON解析消息，并更新本地服务地址列表
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40d2db7e142d94cdb8b40d65d1e4f41b/" rel="bookmark">
			Android ：约束布局ConstraintLayout 之 Chains 链式约束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ConstraintLayout Chains 链式约束1. 链 简介( 1 ) Chains ( 链 ) 简介 2. 创建 链 及 分析 生成的代码( 1 ) 创建水平链( 2 ) 链创建后的代码及样式( 3 ) 链创建后 生成的 代码 3. 链头 及 链的间距( 1 ) 链头设置( 2 ) 链 间距 4. 链 的 三种风格( 1 ) 链 风格设置( 2 ) 链 的 三种风格( 3 ) CHAIN_SPREAD 样式 代码示例 及 效果( 4 ) CHAIN_SPREAD_INSIDE 样式 代码示例 及 效果( 5 ) CHAIN_PACKED 样式 代码示例 及 效果 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40d2db7e142d94cdb8b40d65d1e4f41b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5210e074bbf21b37985973f0f5ed816/" rel="bookmark">
			MFC的表格控件List Control的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表格控件List Control的使用 控件变量的使用
相当于这个控件的一个别名，可以当做对象来使用，方便调用该控件的一些函数。
为列表控件设置控件变量
右键列表控件—&gt;添加控件变量
初始化列表的样式
m_allstudent.SetExtendedStyle(m_allstudent.GetExtendedStyle() | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);
// 参数为：整行选择、网格线；此样式表现为点击某行时，为蓝色选中状态
设置表头
m_allstudent.InsertColumn(0, _T("学号"), LVCFMT_CENTER, 0);
第一个参数为第几列（列从1开始计算，而不是0）、第二个位列的名字、第三个为内容居中、第四个是宽度
创建行
m_allstudent.InsertItem(i, _T("")); // 首先创建一个行，接下来在这个行插入每列的值
设置行的每列值
m_allstudent.SetItemText(i, 0, sno); // 设置第2列(姓名)
第一个参数为第几行、第二个位第几列（列从0开始计算，而不是1）、第三个为内容
完整代码例子
注意：列表这些值显示是在对话框程序的初始化函数OnInitDialog()中进行的，子对话框是没有初始化函数，需要自己添加，添加方法一：根据第一个对话框可以自己动手敲代码复制。方法二：对话框界面右键选择类向导添加。
BOOL CMyBrowseDlg::OnInitDialog()//初始化函数，初始化列表数据 { CDialogEx::OnInitDialog(); //1、初始化列表样式。参数为：整行选择、网格线 m_allstudent.SetExtendedStyle(LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES); //2、建立表头，即为每列起名字。注意列是从1开始 m_allstudent.InsertColumn(1, _T("学号"), LVCFMT_CENTER, 150); m_allstudent.InsertColumn(2, _T("姓名"), LVCFMT_CENTER, 100); m_allstudent.InsertColumn(3, _T("年龄"), LVCFMT_CENTER, 50); //3、先创建行，再为改行每列赋值。注意列是从0开始 m_allstudent.InsertItem(i, _T("")); // 首先创建一个行，接下来在这个行插入每列的值 m_allstudent.SetItemText(i, 0, sno[i]); // 设置第1列(学号) m_allstudent.SetItemText(i, 1, sname[i]); // 设置第2列(姓名) m_allstudent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5210e074bbf21b37985973f0f5ed816/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ec248b68f811b31a1c0c4938410ebc9/" rel="bookmark">
			❤️ 互联网大厂面试高频算法题汇总 ❤️ —— ❤️ 二分专场 (一) ❤️
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、前言2、题目汇总3、二分模板4、二分流程5、二分高频题详解5.1、LeetCode 33. 搜索旋转排序数组5.2、LeetCode 704. 二分查找5.3、LeetCode 69. x 的平方根5.4、LeetCode 4. 寻找两个正序数组的中位数5.5、LeetCode 153. 寻找旋转排序数组中的最小值5.6、LeetCode 162. 寻找峰值5.7、LeetCode 34. 在排序数组中查找元素的第一个和最后一个位置 1、前言 二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法，可以在数据规模的对数时间复杂度内完成查找。二分查找可以应用于数组，是因为数组具有有随机访问的特点，并且数组是有序的。二分查找体现的数学思想是「减而治之」，可以通过当前看到的中间元素的特点推测它两侧元素的性质，以达到缩减问题规模的效果。
二分查找也是面试中经常考到的问题，虽然它的思想很简单，但写好二分查找算法并不是一件容易的事情。因此我汇总了近期互联网大厂面试的高频二分题目，数据来源于CodeTop ，题解来源于我的LeetCode高频面试题专栏，7道高频二分题详解帮助面试者更有针对性地准备面试中的二分算法题。
2、题目汇总 题目难度最近考察时间频率掌握程度LeetCode 33. 搜索旋转排序数组中等2021-08-1965⭐⭐⭐LeetCode 704. 二分查找容易2021-08-2047⭐⭐⭐LeetCode 69. x 的平方根容易2021-08-2337⭐⭐⭐LeetCode 4. 寻找两个正序数组的中位数困难2021-08-2127⭐⭐⭐LeetCode 153. 寻找旋转排序数组中的最小值中等2021-08-1422⭐⭐⭐LeetCode 162. 寻找峰值中等2021-08-1720⭐⭐⭐LeetCode 34. 在排序数组中查找元素的第一个和最后一个位置中等2021-08-1218⭐⭐⭐ 3、二分模板 版本1
当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1，计算mid时不需要加1。
C++/java代码模板：
int bsearch_1(int l, int r) { while (l &lt; r) { int mid = (l + r)/2; if (check(mid)) r = mid; else l = mid + 1; } return l; } 版本2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ec248b68f811b31a1c0c4938410ebc9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/330/">«</a>
	<span class="pagination__item pagination__item--current">331/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/332/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>