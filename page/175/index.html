<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8674f8c4bcbefe5984594744f58a12ce/" rel="bookmark">
			Java&#43;TestNG&#43;Maven&#43;Selenium的web自动化测试脚本环境的搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境搭建 1、安装java环境
a、 安装JDK
b、安装eclipse
c、安装maven
参考：http://www.cnblogs.com/s1328/p/4620812.html
2、安装eclipse下的testng插件
Eclipse中点击Help-&gt;Install new software -&gt; 点击Add
在Location输入 http://beust.com/eclipse
选中Testng版本，点击Next，按照提示安装，安装完之后重启Eclipse
3、安装firefox插件
a、fireBug插件，帮你定位页面元素
b、firePath插件，可以直接告诉你页面元素的Xpath
下面需要在Eclipse里为我们要做的web自动化测试创建一个Eclipse工程
你需要按照File - New - Project - Maven - Maven Project来创建Maven工程
这里为了简单起见，你可以直接去GitHub拿我创建好的工程
https://github.com/zhangting85/simpleWebtest
不会用GitHub的同学只要打开这个连接然后点击Download ZIP这个按钮就可以下载到创建好的工程源代码。
然后在Eclipse里按照File - Import… - Maven - Existing Maven Projects来导入刚刚下载的源代码。
工程结构详解：
一个最简单的标准maven工程，源代码放在src/main/java目录下，测试代码放在src/test/java目录下；
maven还创建了一个pom.xml，负责替你管理所有这个工程所依赖的jar包。
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;simple-webtest&lt;/groupId&gt; &lt;artifactId&gt;simple-webtest&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;simple-webtest&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.testng&lt;/groupId&gt; &lt;artifactId&gt;testng&lt;/artifactId&gt; &lt;version&gt;6.8.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt; &lt;artifactId&gt;selenium-java&lt;/artifactId&gt; &lt;version&gt;2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8674f8c4bcbefe5984594744f58a12ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32cc6aaa4b99aff6195a90625fc33005/" rel="bookmark">
			在 Linux 上给用户赋予指定目录的读写权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更简单的，其实直接把文件件的拥有者改为当前组，然后添加文件夹权限即可，即：
# 将目录/opt 及其下面的所有文件、子目录的文件主改成 liuhai chown -R liuhai:liuhai /opt #给目录opt设置权限 chmod 760 /opt 注：liuhai:liuhai中，第二个是组名，如果创建用户时不指定，默认为users.
更多详细可见Linux 给用户 赋某个文件夹操作的权限_linux给指定用户文件夹权限_dhq_blog的博客-CSDN博客
使用用户组来为用户赋予指定目录的读写权限
如果用户已经拥有了默认的用户组（通常组名与用户名相同），或者已经所属某个用户组，就可以简单的通过变更文件夹的所属用户组来完成。
# chgrp -R storm /usr/local
1
如果想重新建立用户及用户组，并且重新设置权限，需要按照下面步骤操作。
1、创建用户
# useradd restart1025
1
2、设置密码
# passwd restart1025
1
3、创建用户组
# groupadd storm
1
4、设置用户所属用户组
# usermod -aG storm restart1025 # add restart1025 to storm
# groups restart1025 # check restart1025 groups
1
2
5、 将目录的所属用户组变更为storm：
# chgrp -R storm /usr/local
1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32cc6aaa4b99aff6195a90625fc33005/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c49756b703f1eb830fad595a074625d/" rel="bookmark">
			Linux永久挂载硬盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天来记录一下在centos7下挂载磁盘后，重启服务器磁盘挂载失效的解决办法。
1、查看linux下的挂载硬盘
df -h 2、查看系统的硬盘
lsblk 3、格式化磁盘
mkfs -t ext4 /dev/sdb 4、挂载磁盘
mount /dev/sdb /data 5、编辑 /etc/fstab文件，增加一行
vim /etc/ fstab /dev/sdb /data ext4 defaults 0 0 6、执行自动挂载
sudo mount -a 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bae0c7b4c1c9df06e6585ab8a7e0f217/" rel="bookmark">
			埃氏筛与欧拉筛（线性筛）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、埃氏筛与欧拉筛（线性筛）
1、问题描述
2、基本思路
（1）埃氏筛法
（2）欧拉筛法
三、题例
1、上链接
2、简单思路
3、代码
（1）埃氏筛python版
（2）欧拉筛python版
一、前言 对于学计算机的同学来说，学习算法是一件非常重要的事情，废话不多讲，我们来讲讲“埃氏筛与欧拉筛（线性筛）问题”。
二、埃氏筛与欧拉筛（线性筛） 1、问题描述 如题，给定一个范围 n，有 q 个询问，每次输出第 k 小的素数。
具体可见下面题目链接。
2、基本思路 先在 1~n 中筛选出所有素数（质数），然后再做判断。
显然朴素的判断素数的方法时间复杂度高，不可取。
下面介绍两种时间复杂度较低的方法，即埃氏筛法和欧拉筛法。（但是这个世界上没有天上掉馅饼的事情，我降低了时间复杂度，那么就必然要牺牲空间）
（1）埃氏筛法 首先将2到n范围内的整数写下来。
其中2是最小的素数，将表中所有的2的倍数划去。
表中剩下的最小的数字就是3，他不能被更小的数整除，所以3是素数。
再将表中所有的3的倍数划去…… 以此类推，如果表中剩余的最小的数是m，那么m就是素数。
然后将表中所有m的倍数划去，像这样反复操作，就能依次枚举n以内的素数。
埃氏筛法的时间复杂度是0(n*log(logn))。
埃氏筛法的基本思想 ：
从2开始，将每个质数的倍数都标记成合数，以达到筛选素数的目的。
因为随便一个合数的约数都不会大于自己，且必然存在有约数是素数的情况，那么我对规定范围内的数进行从小到大的判断，正好是能“划掉大的合数”且不会出现遗漏。
埃氏筛核心代码：
static final int N = 1e7 + 5; static int[] st = new int[N]; public static void E_sieve(int n){ for(int i = 2; i &lt;= n; i++) { if(st[i] == 0) { for(int j = 2 * i; j &lt;= n; j += i) st[j] = 1; // j是i的一个倍数，j是合数，筛掉。 } } } 优化后的埃氏筛：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bae0c7b4c1c9df06e6585ab8a7e0f217/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9adef6d74844c3568cda28e29923a806/" rel="bookmark">
			预处理命令使用详解----#if、#endif、#undef、#ifdef、#else、#elif
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自 蓝海人——预处理命令使用详解----#if、#endif、#undef、#ifdef、#else、#elif
预处理命令使用详解----#if、#endif、#undef、#ifdef、#else、#elif 预处理命令#include（文件包含命令）#define（宏定义命令）#undef#if（条件编译）#ifdef#ifndef#elif#endifdefined函数（与if等结合使用） 预处理命令 在接触#if、#undef这类预处理指令前，大部分都都接触过#define、#include等预处理命令，通俗来讲预处理命令的作用就是在编译和链接之前，对源文件进行一些文本方面的操作，比如文本替换、文件包含、删除部分代码等，这个过程叫做预处理（在编译之前对源文件进行简单加工）
（#define是一种宏定义命令，是预处理命令的一种）
#include（文件包含命令） #include的用法有两种，尖括号&lt;&gt;和双引号""
第一种----尖括号
#include &lt;stdio.h&gt; 第二种----双引号
#include "stdio.h" 使用尖括号和双引号的区别在于头文件的搜索路径
尖括号：编译器会到系统路径下查找头文件
双引号：编译器会先在当前目录下查找头文件，如果没有找到，再到系统路径下查找
注意事项：
1、一个 #include 命令只能包含一个头文件
2、同一个头文件可以被多次引入，多次引入的效果和一次引入的效果相同，因为头文件在代码层面有防止重复引入的机制
3、头文件包含允许嵌套
（头文件只能包含变量和函数的声明，不能包含定义，否则在多次引入时会引起重复定义错误）
#define（宏定义命令） 格式：#define 标识符 字符串
并不是所有情况下#define所定义的字符串都会被替换，有一种特殊情况：被替换的字符串在""内
代码示例：
#include &lt;stdio.h&gt; #define MAX 10 int main() { printf("MAX"); } 还有需要注意的一点是，不管是在某个函数内，还是在所有函数之外（不太建议把#define写在函数内），#define作用域都是从定义开始直到整个文件结尾（这一点和typedef就区别很大）
#define（宏定义）----由预处理器来处理
typedef----在编译阶段由编译器处理
代码举例：
#include &lt;stdio.h&gt; void fun(); int main() { #define MAX int MAX a = 10; printf("%d", a); fun(); } void fun() { MAX b = 10; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9adef6d74844c3568cda28e29923a806/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03ddc64de1fff4b4e5265a88281728b0/" rel="bookmark">
			ubuntu服务器版本搭建Hadoop集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验环境：
虚拟化软件：VMware® Workstation 16 Pro
镜像：ubuntu-22.04.2-live-server-amd64.iso
Hadoop版本：hadoop-3.3.4.tar.gz
ubuntu镜像链接
hadoop文件链接
配置虚拟机
（1）新建虚拟机，选择实验镜像【ubuntu-22.04.2-live-server-amd64.iso】
（2）调整硬件配置，配置如图
安装操作系统
（1）选择虚拟机语言，键盘布局
语言：English
键盘布局：美式键盘（ANSI）布局
（2）选择安装类型
保持默认选择 Ubuntu Server，选择 Done 继续
（3）网络配置
在 NAT 模式下，默认采用 DHCP 方式为虚拟机动态分配 IP 地址，我们需要让虚拟机主动“认领”属于自己的静态 IP 地址。
1）记录当前ip地址：192.168.110.142/24
图 1 原始IP地址 记录当前ip地址是为了确定网络前缀，如本机的网络前缀为192.168.110，方便后续配置子网掩码和网关。
2）设置网络
·使用方向键选中图1所示界面的 [ens33 eth - ▶︎]，回车进入子菜单
·选择 Edit IPv4
·选择 Automatic (DHCP)
·选择 Manual
·填写所有字段，保持 IPv4 地址前三段不变：
图 2 配置namenode网络 ·选择 Save 保存设置 ·等待屏幕底部 Applying changes 动画消失后，选择 Done 完成网络配置
3）代理服务器设置
代理服务器在使用企业网络时通常有用，本实验不需要，直接选择 Done 继续实验。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03ddc64de1fff4b4e5265a88281728b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/076a9018e0215584ae31d66c2c2a466f/" rel="bookmark">
			idea修改代码后不生效解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		idea修改代码后不生效解决方案
修改tomca tconf\context.xml
增加reloadable=“true”
如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52a75acb227b64e1b94c45c12b009785/" rel="bookmark">
			Spring Security 多因素认证（MFA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Security 系列文章开始更新了！工程地址为github.com/ReLive27/sp…，如果你对此系列感谢趣，可以点击关注作者获取最新文章发布信息。
多因素身份验证是一种提高产品安全性的方法，它通过要求用户提供除用户名和密码之外的第二种形式的身份验证来增加额外的安全层。
在本文中，我们将使用 TOTP（基于时间的一次性密码）作为第二种身份识别形式。此 TOTP 由用户移动设备上的应用程序生成，例如 Google 身份验证器。
💡 注意：如果不想读到最后，可以在这里查看源码。喜欢的话别忘了给项目一个star哦！
多因素身份验证的工作原理 当用户启用多因素身份验证时，将生成一个密钥并以 QR 码的形式发送给用户，用户将使用身份验证器应用程序对其进行扫描。
登录过程现在需要几个步骤：
1.用户输入用户名和密码。
2.身份验证服务验证用户名和密码。
3.用户通过身份验证器应用程序扫描 QR 码。
4.用户输入验证器应用程序生成的一次性密码。
5.身份验证服务使用生成的密钥验证一次性密码，并将 JWT 令牌发送给用户。
让我们深入了解实施。
一次性密码管理器 我们在 pom.xml 文件中引入该库 用于生成密钥并验证一次性密码。
&lt;dependency&gt; &lt;groupId&gt;dev.samstevens.totp&lt;/groupId&gt; &lt;artifactId&gt;totp-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.7.1&lt;/version&gt; &lt;/dependency&gt; DefaultTotpManager 包装了TOTP库，它有以下操作：
public class DefaultTotpManager implements MfaAuthenticationManager { @Override public String generateSecret() {} @Override public String getUriForImage(String label, String secret, String issuer) throws QrGenerationException {} @Override public boolean validCode(String secret, String code) {} } 首先，生成密钥，第二，生成密钥的二维码图像 URI，最后，validCode 验证提供的代码是正确的还是错误的代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52a75acb227b64e1b94c45c12b009785/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b76e9160198dd83c2952c5d1f25713f/" rel="bookmark">
			python win7安装指定版本playwright
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 # python386 -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple playwright==1.12.0 # python386 -m playwright install # 安装完后会报错， 把_dtls.py 下的@attr.frozen 都注释掉 。 # 这个版本可能会缺少 api-ms-win-core-com-l1-1-0.dll 到网上下载，放到C:\Windows\System32 ， # 然后regsvr32 api-ms-win-core-winrt-error-l1-1-0.dll from playwright.sync_api import sync_playwright url ="https://www.baidu.com" def filterResponse(response): print(response.url) print(response.body) # 创建浏览器 with sync_playwright() as pw: # 创建一个webkit, # headless=True后台执行抓包 browser = pw.chromium.launch(headless=False) page = browser.new_page() page.on("websocket", filterResponse) page.goto(url, timeout=0) page.wait_for_timeout(100000000) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc058ac18517e6bffaebfa6b277c62a3/" rel="bookmark">
			TSBS 是什么？为什么时序数据库 TDengine 会选择它作为性能对比测试平台？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TSBS 是一个时序数据处理（数据库）系统的性能基准测试平台，提供了 IoT、DevOps 两个典型应用场景，它由 Timescale 开源并负责维护。作为一个性能基准测试平台，TSBS 具有便捷、易用、扩展灵活等特点，涵盖了时序数据的生成、写入（加载）、多种类别的典型查询等功能，并能够自动汇总最终结果。由于其开放开源的特点，得到了众多数据库厂商的支持，作为专业的产品性能基准测试平台被若干数据库厂商广泛使用。
以下的性能基准报告均使用了 TSBS 作为基础 Benchmark 平台，我们从时间跨度和发布厂商的知名度同时来看，就能发现，基础测试平台 TSBS 已经具备了很高的认可度：
2018 年 11 月，VictoriaMetrics 的创始人 Aliaksandr Valialkin 发布 《High-cardinality TSDB benchmarks: VictoriaMetrics vs TimescaleDB vs InfluxDB》，将 VictoriaMetrics 与 TimescaleDB、InfluxDB 进行性能对比。
2018 年 11 月，文章《ClickHouse Crushing Time Series》中对比了 TimescaleDB, InfluxDB, ClickHouse 在时序数据场景下的性能。
2020 年 3 月，Cloudera 在网站博客中发布《Benchmarking Time Series workloads on Apache Kudu using TSBS》，在 DevOps场景 中对比了 Apache Kudu, InfluxDB, VictoriaMetrics, ClickHouse 等整体性能表现。
2020 年 3 月， Redis 发布了基于 TSBS 的性能报告《RedisTimeSeries Version 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc058ac18517e6bffaebfa6b277c62a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12a1dc781bd83fa7b88b6a591b5ad2aa/" rel="bookmark">
			轻松玩转Makefile | 基础用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文通过几个简单的示例，可以快速了解Makefile的基本使用方法，适用于编译我们平时练习所编写的小量代码。
1. make命令 Makefile文件内容: all为目标，这里没有依赖的文件，这条命令是打印(echo)出“Hello Makefile”这行文字
all: echo "Hello Makefile" 运行make后，终端打印的内容
$ make echo "Hello Makefile" Hello Makefile 可以看到，Makefile的命令也打印在了终端，要想不输出命令的内容，可以在命令前面加上@
make可以指定要生成的目标，如果不指定，则默认第一个目标，我们将Makefile文件内容修改一下
all: @echo "Hello Makefile" test: @echo "Hello Test" 运行不同的命令，可以看到不同的打印信息
$ make Hello Makefile $ make all Hello Makefile $ make test Hello Test 2. 生成文件 假设现在有两个文件fun.c和main.c，需要利用Makefile生成一个可执行文件app。
fun.c的内容
#include &lt;stdio.h&gt; void fun() { printf("This is fun()!\n"); } main.c的内容
extern void fun(); int main() { fun(); return 0; } Makefile的内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12a1dc781bd83fa7b88b6a591b5ad2aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8daac25a31d93009b7d4761b7d611095/" rel="bookmark">
			【GeoScene Enterprise授权方案】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GeoScene Enterprise授权方案 WindowsPortalServerDatastore LinuxPortal页面方式命令行方式 ServerDatastore GeoScene Enterprise日常运维涉及到更新许可。Enterprise组件包括portal，server和datastore。Windows和Linux的授权方式稍有不同，将在下文中详细列出。 Windows Portal Server Datastore Linux Portal portal的授权方式包括两种。一种是直接在页面进行授权，另一种是通过命令行进行授权。
页面方式 直接按照图上所示的功能区选择授权即可。
命令行方式 首先需要在root用户的前提下将许可文件的权限修改为geoscene enterprise的安装账户。
chown -R geoscene:geoscene /home/geoscene/GeoScene_Enterprise_Portal_30_405445_20230110.json
切换geoscene安装账户后，cd进入portal安装目录/tools/importlicense，运行更新许可命令。
./importlicense.sh -u geoscene -p portaladmin -lf /home/geoscene/GeoScene_Enterprise_Portal_30_405445_20230110.json
Server 首先需要将server的许可的权限修改为geoscene enterprise的安装账户。
chown -R geoscene:geoscene /home/geoscene/svr_advance.ecp
切换geoscene安装账户后，cd进入server安装目录/tools，运行授权命令authorizeSoftware。
./authorizeSoftware -f /home/geoscene/svr_advance.ecp
Datastore 切换geoscene安装账户，cd进入datastore安装目录/tools，运行授权命令。
./updatelicense.sh
整个授权过程完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/183465a357b5c545090db7091324e5a5/" rel="bookmark">
			SpringCloudAlibaba io.seata.common.exception.FrameworkExceptioncan not register RM,err:can not conne
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用seata启动微服务后，启动不起来，并报上述错误
解决方案：先在nacos上查看本机服务IP和端口
把现在seata服务关掉，重新启动时候加上 -h （本机ip）
例如：
后面端口可加可不加，部署集群时候会用，单机忽略。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58c9bc572a560858ca15a7610d54762b/" rel="bookmark">
			Mybatis-plus逻辑删除更新字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MybatisPlus版本 &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-extension&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; 创建LogicBatchDeleteWithFill public class LogicBatchDeleteWithFill extends AbstractMethod { private static final String MAPPER_METHOD = "batchDeleteWithFill"; @Override public MappedStatement injectMappedStatement(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo) { String sql; SqlMethod sqlMethod = SqlMethod.LOGIC_DELETE; if (tableInfo.isWithLogicDelete()) { List&lt;TableFieldInfo&gt; fieldInfos = tableInfo.getFieldList().stream() .filter(i -&gt; i.getFieldFill() == FieldFill.UPDATE || i.getFieldFill() == FieldFill.INSERT_UPDATE) .collect(toList()); if (CollectionUtils.isNotEmpty(fieldInfos)) { String sqlSet = "SET " + fieldInfos.stream().map(i -&gt; i.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58c9bc572a560858ca15a7610d54762b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe89867339934ad0ebddd5febbe1a364/" rel="bookmark">
			K8S、kubernetes no resolver defined to resolve could not be resolved (3: Host not found) 问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始 最近在使用openResty搭建一个动态代理功能，遇到了死命的问题，弄了几天才弄好，遂记录下来。
openResty 如果不熟悉的人可以把它理解成nginx环境是在K8S容器内部curl http://openresty-svc/data-dashboard/card/myClueList （请求的命令） 下面是我配置的 nginx.conf
http { server { listen 80; server_name openresty; location / { # 声明一个变量 host_xxxx ，并给它设置值 # 这个xdx-wahaha-online-service-svc 是我K8S里的一个内部服务 set $host_xxxx "xdx-wahaha-online-service-svc"; proxy_pass http://$host_xxxx:8080; } } } no resolver defined to resolve xxxx 发起一个请求，报了下面的错误
2023/02/28 19:56:07 [error] 6#6: *3 no resolver defined to resolve xdx-wahaha-online-service-svc, client: 172.27.3.63, server: openresty, request: "GET /data-dashboard/card/myClueList HTTP/1.1", host: "openresty-svc" 翻译过来就是 没有定义解析器来解析DNS
在nginx里面如果 proxy_pass 里面使用了变量，就必须定义一个解析器。
正常情况 如果是在正常的环境下（我上面是在 K8S里面，属于内部环境），只需要配置固定的解析器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe89867339934ad0ebddd5febbe1a364/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61433d48569d4ca59abbde22ef8ea2b9/" rel="bookmark">
			小程序最新获取用户信息登录（头像昵称填写）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;view&gt; &lt;view class="top" v-if="!userInfo.avatarUrl"&gt; &lt;!-- 获取用户昵称input --&gt; &lt;input type="nickname" class="weui-input" placeholder="请输入昵称" @blur='getInputValue' /&gt; &lt;!-- 点击获取用户头像 --&gt; &lt;button type="primary" open-type='chooseAvatar' @chooseavatar="getUserInfo"&gt;获取用户信息&lt;/button&gt; &lt;/view&gt; &lt;view v-else&gt; &lt;!-- 展示用户昵称和头像 --&gt; &lt;view&gt; {{userInfo.nickName}}&lt;/view&gt; &lt;image :src="userInfo.avatarUrl" mode=""&gt;&lt;/image&gt; &lt;button type="primary" @click="outLogin"&gt;退出登录&lt;/button&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { props: { }, data() { return { userInfo: { nickName: '', avatarUrl: '' } }; }, methods: { // 点击按钮获取用户信息 getUserInfo(e) { // console.log(e.detail); this.userInfo.avatarUrl = e.detail.avatarUrl // 将获取到的用户信息同步存储到storage中 uni.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61433d48569d4ca59abbde22ef8ea2b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4ae1f8c00245511214584ad8dbefe66/" rel="bookmark">
			主成分分析、最小噪声分离、缨帽变换和独立成分分析之间的异同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 不同点：
PCA是通过正交变化将相关变量转换为不相关变量的过程，按照信息量（方差）大小排列；
MNF相当于进行两次PCA（第一次对图像噪声进行PCA，第二次对噪声分离后的图像进行PCA），并按照信噪比大小进行排列；
TCT 是基于图像物理特征进行的固定转换，变换后坐标轴指向与地面景物有密切关系的方向；
ICA是PCA的一种扩展，用来从多维统计数据中找到隐含因素或成分的方法。
相同点：
都是基于PCA的方法进行的变换；都能实现图像去噪、特征提取，达到提高图像增强的效果；都是基于图像特征分析变换。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79f734da7d749eb0aba77592312b9cfb/" rel="bookmark">
			为什么 NodeJS 是构建微服务的最佳选择？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是微服务 微服务是一种应用架构，它将每个应用功能都放在自己的服务中，与其他服务隔离。这些服务是松散耦合的，可独立部署。
这种架构的出现是为了解决旧的 Web 应用开发的单体方法。在单体软件中，所有的东西都是作为一个单元构建的，所有的业务逻辑都被归入一个广泛的应用。
这种方法使更新代码库的过程变得复杂化，因为它影响到整个系统，即使是最小的代码改动也需要构建和部署整个软件的新版本。此外，哪怕你只想扩展应用的某个特定功能，却需要扩展整个应用来实现它。
微服务解决了单体系统所面临的这些挑战，它将应用从一个整体分割成几个小部分。
什么时候应该使用微服务？ 从本质上讲，微服务架构解决了庞大、复杂应用的快速开发问题。
对于“哪个更好？”这一问题，目前还没有通用的答案。答案取决于各种情况，因为每一种情况都有其好处和缺点。
下面是一些微服务架构的优点和缺点，你可能对此已经有所了解：
优点 语言不可知性：微服务并不限于特定的编程语言，每个微服务都可以用不同的语言来编写，以支持选定的通信协议。
可扩展性：由于微服务和它的职责可以由开发者共同承担，所以如果有一个大的团队参与到这个项目中，应用就会变得更加易于维护。
无限迭代：由于开发者不会被其他组件所束缚，所以在微服务上迭代会变得更加简单。
单元测试：由于微服务是独立的应用，它的重点是特定的功能，因此，开发者可以很轻松地编写测试脚本，以验证该特定功能。
缺点 要作为一个整体来管理是很困难的：凯撒大帝有一句名言“分而治之”（divide et impera，拉丁语），即使在这里也可以大规模应用，但是要谨慎，因为过多的活动部分会变得难以管理。
难以追踪：如果架构变得过于复杂，微服务之间的通信渠道会非常多，出现错误后会很难追溯并确定故障点。
需要大量的专业知识：构建和部署微服务要求非常高的计划和协调方面的软技能。
具有挑战性的测试：测试是一把双刃剑，因为微服务作为一个整体更难测试。集成和端到端的测试同样会有挑战。
审计日志：可能更难获得和调查。
在架构方面，SaaS 微服务非常适合，因为微服务是 SaaS 应用的一个不错的选择。由于这类应用想要用户付钱买单，那么它就需要提供高可用的服务，因此将软件分成小块可以加快恢复速度。同时，SaaS 应用的发展主要是由其社区推动，所以，它也会受到很多变化的影响，而通过微服务和解耦，开发者可以获得了灵活性，这是单体架构无法提供的。
单体应用程序可能难以水平扩展，因为你必须复制整个应用程序，如果它依赖于单个数据库，这个过程将变得更加困难。另一边，微服务却可以根据单个服务进行扩展、复制或负载平衡。比如，如果你需要发送更多的电子邮件，你只需要扩展负责电子邮件功能的微服务。今天你有 10 个用户，明天你有 1000 个；SaaS 应用可以在短时间内维持大规模的增长，这就是为什么他们的架构必须要以最经济的方式进行轻松扩展的原因。
这样还可以减少资源的消耗，因此可以减少账单。所以，可以肯定地说，微服务是 SaaS 企业架构的下一个阶段。
弄清你是否需要微服务的最好方法是问自己：我有关于单体应用的问题吗？如果有的话，或许你应该考虑转向微服务。如果没有，那就坚持下去——没有必要把时间花在一个根本不存在的问题上。
微服务通信是如何工作的？ 由于服务之间彼此独立，所以与微服务的通信需要好好选择。通信协议的使用不当会造成应用的性能下降，大家必须根据自己应用的具体需求来选择通信协议。
有两种通信方式可以选择：同步通信和异步通信，这是请求 - 响应和基于事件的模式的基础。
在第一种情况下，即同步方式，客户端发送请求并等待响应。这种方法有一个缺陷，那就是它是一个阻塞模式。但是，如果你有一个读操作非常多的应用时，那就不一定了，因为你的应用更倾向从外部读取和接受信息。在这种情况下，使用同步方式可能是一个很好的选择，特别是当它涉及实时数据时。
我们的另一个选择是异步通信，这是一个非阻塞模式。如果你想要一种有弹性的微服务，那么，与同步通信相比，异步通信是一种更好的选择。在这种情况下，客户端会发送一个请求，收到请求的确认，并将其遗忘。这种方法最适用于大量写操作、无法承受数据记录丢失的应用。
下面是一些涉及微服务通信的解决方案，你可以从中选择：
基于 HTTP 的 REST
基于 HTTP/2 的 REST
WebSocket
TCP 套接字
UDP 数据包
好好考虑最适合自身需求的通信协议，因为这将使应用响应更快、效率更高。
为什么 NodeJS 用于微服务？ 在构建微服务时，有很多顶级编程语言可供选择。NodeJS 就是其中之一。那么，为什么 NodeJS 是最佳选择呢？
单线程 &amp; 异步：NodeJS 使用事件循环来执行代码，允许异步代码被执行，从而使服务器能够使用非阻塞机制来响应。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79f734da7d749eb0aba77592312b9cfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f311733054c7ffabf9d38035c9681b4/" rel="bookmark">
			远程连接AWS服务器的MySQL参考教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		连接AWS服务器 云服务器上安装MySQL参考教程
linux-安装MySQL：https://blog.csdn.net/xhmico/article/details/125197747云端服务器(linux版)部署mysql：https://blog.csdn.net/m0_51406695/article/details/123886966linux云服务器从零开始安装mysql：https://blog.csdn.net/weixin_48451662/article/details/121988914
补：AWS 亚马逊 EC2 云服务有关的教程在 AWS EC2 上运行 MySQL 数据库——初学者教程：https://towardsdatascience.com/running-mysql-databases-on-aws-ec2-a-tutorial-for-beginners-4301faa0c247官方连接到运行 MySQL 数据库引擎的数据库实例：https://docs.aws.amazon.com/zh_cn/AmazonRDS/latest/UserGuide/USER_ConnectToInstance.htmlUbuntu18.04安装mysql（AWS云）：https://www.cnblogs.com/rainbowcpu/p/11923051.html 连接AWS服务器上的MySQL参考教程
使用Amazon RDS 创建和连接MySQL数据库：https://aws.amazon.com/cn/getting-started/hands-on/create-mysql-db/MySQL : Deploy , Configure and remote access the MySQL on EC2，展示了完整的EC2创建MySQL过程但未展示数据库写入操作：https://www.youtube.com/watch?v=sxkjps_ZyM0最后3分钟展示了Amazon RDS可以在外边创建数据表、插入数据操作： https://www.youtube.com/watch?v=fhDhfG9MEF8AWS RDS with MySQL Workbench，也是最后展示了RDS的写入数据 ：https://www.bilibili.com/video/BV1x34y147eG/?spm_id_from=333.337.search-card.all.click&amp;vd_source=6f4d58f2911ca74aae4c08e71feb11f0官网的连接EC2的例子，但依然没有展示写入数据的例子：https://aws.amazon.com/cn/premiumsupport/knowledge-center/rds-mysql-ssh-workbench-connect-ec2/# 使用的是TCP/IP的方式远程连接MySQL 我们需要知道远程服务器的IP地址hostname和MySQL的username和password。
改动 TCP/IP连接时出现以下问题：
mysqli_connect(): (HY000/2002): 由于目标计算机积极拒绝,无法连接。
解决：
修改远程MySQL访问设置
sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf 将 bind-address = 127.0.0.1和下一句mysqlx-bind-address
改为 0.0.0.0
AWS S3 存储桶访问 https://www.youtube.com/watch?v=39X5WdZbEwQ&amp;list=LL&amp;index=1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa547bd4b2d7dd0103e7b2016af412d1/" rel="bookmark">
			dependency walker工具简介及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dependency walker工具 简介使用 简介 官方概述： Dependency Walker is a free utility that scans any 32-bit or 64-bit Windows module (exe, dll, ocx, sys, etc.) and builds a hierarchical tree diagram of all dependent modules. For each module found, it lists all the functions that are exported by that module, and which of those functions are actually being called by other modules. Another view displays the minimum set of required files, along with detailed information about each file including a full path to the file, base address, version numbers, machine type, debug information, and more.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa547bd4b2d7dd0103e7b2016af412d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1019f697932ad54bfe717419bc01109/" rel="bookmark">
			【ssm框架】从0开始搭建ssm框架（idea版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSM（Spring+SpringMVC+MyBatis）框架集由Spring、MyBatis两个开源框架整合而（SpringMVC是Spring中的部分内容），常作为数据源较简单的web项目的框架。
一、 环境介绍 先创建一个web工程。这里使用SSM最终完成一个员工信息的增删改查。
项目配置 Server.服务器版本: Apache Tomcat/8.5.86maven：3.8jdk：1.8SSM框架：spring+mybatis+springmvc springMVC：视图层，界面层，负责接收请求，显示处理结果；
spring：业务层，管理service、dao，工具类对象的；
mybatis：持久层，访问数据库的；
用户发起请求---------springmvc接收----spring中的service对象-----mybatis处理数据
实现步骤： （1）创建maven web项目
（2）加入依赖
springmvc，spring，mybatis三个框架的依赖，Jackson依赖，mysql驱动，druid连接池，thymeleaf-spring5整合依赖，servlet依赖等
（3）写web.xml文件
​ 1、注册DispatcherServlet，目的：创建springmvc的容器对象,才能创建controller类对象；创建的是servlet，才能接收用户的请求；
​ 2、注册spring的监听器：contextloaderlistener，目的：创建spring的容器对象，才能创建service，dao等对象
​ 3、注册字符集过滤器，解决post请求乱码的问题
（4）、创建包 ： controller包，service，dao，实体类包
（5）写springmvc、spring、mybatis的配置文件
resources：
springmvc配置文件
spring配置文件
mybatis配置文件
数据库的属性配置文件
（6）、写java代码
（7）、写前端页面
二、XML 方式整合ssm框架 2.1 先创建一个maven项目的web工程。 （1）在idea中，依次单击 File -&gt; New -&gt; Project -&gt; New Project
新建maven项目，点击"Create"
（2）项目所有目录如图所示
2.2 添加maven依赖 （1）修改maven依赖，添加依赖包
pom.xml文件 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;ssm&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1019f697932ad54bfe717419bc01109/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5c0d42bd338dfa299b62901f7d19f69/" rel="bookmark">
			RT-Thread源码分析3：内核对象模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前情提要内核对象模型的基本数据结构内核对象控制块的数据结构内核对象容器的数据结构 内核对象管理方式对象操作的主要函数rt_object_get_information(type)rt_object_init(*object, type, *name)rt_object_detach(object)rt_object_is_systemobject(object)rt_object_get_type(object)rt_object_find(*name, type) 关于作者 前情提要 源码文件：RT-Thread Nano V3.1.3\src\object.c （源文件修改日期：2018-01-25）
RT-Thread官网：https://www.rt-thread.org/
RT-Thread内核采用面向对象的设计思想进行设计，系统级的基础设施都是一种内核对象，例如线程，信号量，互斥量，定时器等。
对象容器中包含了每类内核对象的信息，包括对象类型，大小等。
对象容器给每类内核对象分配了一个链表，所有的内核对象都被链接到该链表上。
如图 RT-Thread 的内核对象容器及链表如下图所示：
从面向对象的观点，可以认为每一种具体对象是抽象对象的派生，继承了基本对象的属性并在此基础上扩展了与自己相关的属性。
在对象管理模块中，定义了通用的数据结构struct rt_object，用来保存各种对象的共同属性，各种具体对象只需要在此基础上加上自己的某些特别的属性，就可以清楚的表示自己的特征。
这种设计方法的优点有：
提高了系统的可重用性和扩展性，增加新的对象类别很容易，只需要继承通用对象的属性再加少量扩展即可。提供统一的对象操作方式，简化了各种具体对象的操作，提高了系统的可靠性。 由对象控制块 rt_object 派生出来的有：
线程对象、内存池对象、定时器对象、设备对象和 IPC对象（Inter-Process Communication）；由 IPC对象派生出信号量、互斥量、事件集、邮箱、消息队列、信号等。
简单的说，在RT-Thread中，所有具体对象数据结构的根就是rt_object；
内核对象模型的基本数据结构 内核对象模型有两个数据结构：内核对象控制块、内核对象容器
内核对象控制块的数据结构 /** * Base structure of Kernel object */ struct rt_object { char name[RT_NAME_MAX]; /**&lt; name of kernel object */ rt_uint8_t type; /**&lt; type of kernel object */ rt_uint8_t flag; /**&lt; flag of kernel object */ #ifdef RT_USING_MODULE	/* 请忽略module成员 */ void *module_id; /**&lt; id of application module */ #endif rt_list_t list; /**&lt; list node of kernel object */ }; typedef struct rt_object *rt_object_t; /**&lt; Type for kernel objects.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5c0d42bd338dfa299b62901f7d19f69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a0afb49740bc68ab3f4411703f7a020/" rel="bookmark">
			Windows系统部署瀚高数据库并在SuperMap iDesktop中使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一：Windows系统部署瀚高数据库二：对数据库进行PostGIS扩展三：SuperMap iDesktop中新建HighGoDB数据库型数据源 作者：kxj
前言 瀚高数据库是一款对象-关系型数据库，拥有非常丰富的数据库基本功能，涵盖了所有主流数据库的核心特性，能够满足企业级应用的基本需求。它采用开源数据库 PostgreSQL 内核技术，在此 PostgreSQL 社区版之上做了一系列的研发和优化。
目前iDesktop支持新建HighGoDB数据库型数据源，桌面所在机器无需安装客户端，远程服务端必须保证本机有访问权限。Linux系统部署瀚高数据库并在SuperMap iDesktop中使用可以参考博客：SuperMap GIS基础软件中数据库使用指南中HighGo数据源部分内容，今天咱们来讲一讲Windows系统部署瀚高数据库并在SuperMap iDesktop中使用过程。
一：Windows系统部署瀚高数据库 本文以6.0.4版本瀚高数据库为例，安装包获取：链接：https://pan.baidu.com/s/1zGBEHXvn7piprvK1c5Chnw
提取码：2dq3
如需其他版本数据库安装包，请前往瀚高数据库官网获取：https://www.highgo.com/
Windows系统部署瀚高数据库
1.安装包解压之后，执行setup.exe.
2.勾选“我接受协议”，点击下一步，设置数据库安装目录（注意安装路径，不要包含中文，也尽量不要包含特殊符号。这里默认会是“6.0.4”，建议改为“604”或其他不带特殊符号的路径。）
3.选择需要安装的组件，点击下一步，设置用户密码等信息。点击下一步执行安装。
4.安装完成。
二：对数据库进行PostGIS扩展 数据库部署完成之后必须对数据库进行PostGIS扩展，iDesktop才能正常连接数据库。不同版本数据库对应不同版本的PostGIS扩展插件，本文提供数据库版本对应PostGIS扩展插件可以通过以下链接获取：
https://pan.baidu.com/s/1Qt-vFKHXu75cvBbGO88OaA
提取码：17g7
其他版本数据库对应的PostGIS扩展插件请联系瀚高数据库获取。对数据库进行PostGIS扩展步骤如下：
1.解压PostGIS扩展插件包，将插件包的内容复制到数据库安装目录下（注意：复制之前需要关闭数据库，可以在系统服务中找到hgdb-enterprise-6.0.4手动结束）。
2.修改makepostgisdb_using_extensions.bat，修改内容如下：
4.修改完成之后，启动数据库，执行makepostgisdb_using_extensions.bat脚本。
5.打开数据库检查PostGIS扩展是否成功，打开对应数据库的public模式下系统信息的扩展查看是否有如下扩展。至此PostGIS扩展完成。
三：SuperMap iDesktop中新建HighGoDB数据库型数据源 启动SuperMap iDesktop，在工作空间管理器中选中“数据源”右键，选择“新建数据库型数据源”，选择HighGoDB引擎，填写相关参数，点击创建即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c8ff9ea23a860447bf260135968698b/" rel="bookmark">
			【MinIO】文件断点续传和分块合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【MinIO】文件断点续传和分块合并 文章目录 【MinIO】文件断点续传和分块合并0. 准备工作1. 检查文件是否存在1.1 定义接口1.2 编写实现方法 2. 检查分块文件是否存在2.1 定义接口2.2 编写实现方法 3. 上传分块文件接口3.1 定义接口3.2 编写实现方法 4. 合并分块文件接口4.1 定义接口4.2 编写实现方法 下图是上传视频的整体流程： 由图可知，我们需要在前端定义四个接口。
检查文件是否存在接口检查分块文件是否存在接口上传分块文件接口合并分块文件接口 0. 准备工作 编写一个配置类，向Spring容器中注入一个minio客户端。
@ConfigurationProperties(prefix = "minio") @Data public class MinioConfig { private String endpoint; private String accessKey; private String secretKey; @Bean public MinioClient minioClient() { MinioClient minioClient = MinioClient.builder() .endpoint(endpoint) .credentials(accessKey, secretKey) .build(); return minioClient; } } 1. 检查文件是否存在 1.1 定义接口 @ApiOperation(value = "文件上传前检查文件") @PostMapping("/upload/checkfile") public RestResponse&lt;Boolean&gt; checkfile(@RequestParam("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c8ff9ea23a860447bf260135968698b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2abd988789bb8f196df3dab271e90823/" rel="bookmark">
			第一章 面向对象编程技术概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容提要：
本章主要概述面向对象编程技术的基本概念和基本特征，目的是让读者尽早理解对象与类的概念，对面向对象编程技术的抽象、封装、继承、多态进行初步了解，以方便后面更深入的学习。本章举例介绍 了 Visual Studio 2019 集成开发环境下 C++程序的编译、连接与运行过程。由于书中的例程都要用到 C
++标准库，因此本章最后对 C++标淮库的主要内容进行了简单介绍。本章涉及不少新的概念或名词，读者暂时理解不了也无须着急，通过后面的学习会逐渐掌握
1.1 两种编程方法举例 1.1.1 面向过程编程方法 面向过程是一种以事件为中心的编程思想，编程的时候把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数。
举个例子，下五子棋，面向过程的设计思路是首先分析解决这个问题的步骤：
（1）开始游戏（2）黑子先走（3）绘制画面（4）判断输赢（5）轮到白子（6）绘制画面（7）判断输赢（8）返回步骤（2） （9）输出最后结果。
用函数实现上面一个一个的步骤，然后在下五子棋的主函数里依次调用上面的函数（不同的编程语言有不同的调用方法，我这里写的是直接调用）：
下五子棋{ 开始游戏（）； 黑子先走（）； 绘制画面（）； 判断输赢（）； 轮到白子（）； 绘制画面（）； 判断输赢（）； 返回到 黑子先走（）； 输出最后结果； } 可见，面向过程始终关注的是怎么一步一步地判断棋局输赢的，通过控制代码，从而实现函数的顺序执行。
1.1.2 面向对象编程方法 面向对象编程是将程序设计为对象之间通过消息进行通信的相互协作。这里的对象，是指具有唯一地址的、占据计算机一块内存区域的实体，和现实世界中的对象一样，由属性和行为构成。
其中，属性用数据表示，用来描述对象的静态特征；行为通过函数代码实现，用来描述对象的动态功能，是作用于数据上的一些操作（过程、行为、功能、方法、算法等）。
所以，面向对象编程中的对象是数据结构和算法的封装体。
在下五子棋的例子中，用面向对象的方法来解决的话，首先将整个五子棋游戏分为三个对象:
（1）黑白双方，这两方的行为是一样的。
（2）棋盘系统，负责绘制画面
（3）规则系统，负责判定犯规、输赢等。
然后赋予每个对象一些属性和行为：
（4）第一类对象（黑白双方）负责接受用户输入，并告知第二类对象（棋盘系统）棋子布局的变化，棋盘系统接收到了棋子的变化，并负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。
可以看出，面向对象是以功能来划分问题，而不是以步骤解决。比如绘制画面这个行为，在面向过程中是分散在了多个步骤中的，可能会出现不同的绘制版本，所以要考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘系统这个对象中出现，从而保证了绘图的统一。 在设计面向对象程序时，应该更加关注的是抽象数据类型（类）的定义和类对象的创建与使用：
类与对象是面向编程的两个重要概念。类与对象的关系即数据类型与变量之间的关系，一个类可以创建多个对象，而每个对象只能是某一个类的对象。类规定了可以用于存储什么数据，而对象用于实际存储数据，每个对象可以存储不同的数据。
类是封装对象的属性和行为的载体，反过来说，具有相同属性和行为的一类实体被称为类。而对象是类的一个具体的体现，例如，把雁群比作大雁类，那么大雁类就具备了喙、翅膀和爪等属性，觅食、飞行和睡觉等行为，而一只要从北方飞往南方的大雁则被视为大雁类的一个对象。如下图：
1.2面向对象编程的基本特征 面向对象设计具有三大基本特征：封装、继承和多态。
1.2.1封装 封装是面向对象编程的核心思想，其将对象的属性和行为封装起来。而将对象的属性和行为封装起来的载体就是类，类通常对客户隐藏其实现细节，这就是封装的思想。例如，用户使用计算机，只需要使用手指敲击键盘就可以实现一些功能，而无须知道计算机内部是如何工作的。
采用封装思想保证了类内部数据结构的完整性，使用该类的用户不能直接看到类中的数据结构，而只能执行类允许公开的数据，这样就避免了外部对内部数据的影响，提高了程序的可维护性。
1.2.2继承 以平行四边形为例，如果把平行四边形看作四边形的延伸，那么平行四边形就复用了四边形的属性和行为，同时添加了平行四边形特有的属性和行为，如平行四边形的对边平行且相等。我们可以把平行四边形类看作是继承四边形类后产生的类，其中，将类似于平行四边形的类称为子类，将类似于四边形的类称为父类或超类。值得注意的是，在阐述平行四边形和四边形的关系时，可以说平行四边形是特殊的四边形，但不能说四边形是平行四边形。所以，继承是实现重复利用的重要手段，子类通过继承复用了父类的属性和行为的同时，又添加了子类特有的属性和行为。
1.2.3多态 将父类对象应用于子类的特征就是多态。比如创建一个螺丝类，螺丝类有两个属性：粗细和螺纹密度；然后再创建了两个类，一个是长螺丝类，一个是短螺丝类，并且它们都继承了螺丝类。这样长螺丝类和短螺丝类不仅具有相同的特征（粗细相同，且螺纹密度也相同），还具有不同的特征（一个长，一个短，长的可以用来固定大型支架，短的可以固定生活中的家具）。即，一个螺丝类衍生出不同的子类，子类继承父类特征的同时，也具备了自己的特征，并且能够实现不同的效果，这就是多态化的结构。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e2dd8caac51408d543cdd75ebe2f6a6/" rel="bookmark">
			Java 19新特性：虚拟线程(Virtual Threads )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDK19马上就要发布了，今天我们来谈一谈JDK 19的新特性虚线程，它属于JEP 425 Project Loom(425: Virtual Threads (Preview))。这可能是JDK 19中最值得期待的预览特性之一。
我们知道Java阻塞平台线程的代价很高，这就是为什么要不惜一切代价避免这种情况，以及为什么要基于回调编写响应式代码。响应式代码做得很好，但它使代码难以阅读和测试，这显然不是理想的情况。使用JDK19和虚拟线程，阻塞线程变得如此廉价，以至于我们不再需要编写响应式代码，我们 的老式阻塞同步代码也可以很好地工作！下面让我们来看一下这一切是如何工作的？以及为什么我们不应该再担心阻塞一个虚拟线程？
创建虚拟线程 public static void main(String[] args) throws Exception { var platformThread = Thread.ofPlatform() .unstarted(() -&gt; System.out.println(Thread.currentThread())); platformThread.start(); platformThread.join(); var virtualThread = Thread.ofVirtual() .unstarted(() -&gt; System.out.println(Thread.currentThread())); virtualThread.start(); virtualThread.join(); System.out.println("Class = " + virtualThread.getClass()); } ### 输出 Thread[#22,Thread-0,5,main] VirtualThread[#23]/runnable@ForkJoinPool-1-worker-1 Class = class java.lang.VirtualThread Thread类中添加了两个工厂方法：ofPlatform()和ofVirtual()。首先调用了ofPlatform(),从这我们可以直接创建一个已启动的线程，或者一个未启动的线程， 这里我们调用unstarted()，然后打印当前线程信息，看看它输出什么。运行这个线程，我们需要调用start(),因为这是一个未启动的线程。如果我们想在控制台看到结果，最好调用.join()，确保主线程不会在此任务运行结束之前退出，应用程序也不会随之退出。.ofVirtual()的使用和ofPlatform()一样，最后打印了.ofVirtual()产生线程的类名。
通过打印消息，我们可以得知：通过ofPlatform()创建的是普通的平台线程，通过.ofVirtual()创建的是虚线程，而且虚线程具体的类为VirtualThread。
VirtualThread package java.lang; final class VirtualThread extends BaseVirtualThread { // ... } package java.lang; sealed abstract class BaseVirtualThread extends Thread permits VirtualThread, ThreadBuilders.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e2dd8caac51408d543cdd75ebe2f6a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94130ae09df83e4638dccf1bbeb535ab/" rel="bookmark">
			Spring常见面试题汇总（超详细回答）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是Spring框架？ Spring框架是一个开源的Java应用程序开发框架，它提供了很多工具和功能，可以帮助开发者更快地构建企业级应用程序。通过使用Spring框架，开发者可以更加轻松地开发Java应用程序，并且可以更加灵活地组织和管理应用程序中的对象和组件。
Spring框架的核心思想是依赖注入（DI）和面向切面编程（AOP）。依赖注入（DI）可以帮助我们更好地组织和管理应用程序中的对象，使得应用程序更加松耦合，易于扩展和维护。面向切面编程（AOP）可以帮助我们更好地管理应用程序中的横切关注点，比如日志、事务、安全等，使得应用程序更加模块化和可维护。
除了核心容器以外，Spring框架还提供了很多其他的组件和框架，比如Spring MVC可以帮助我们更加轻松地开发Web应用程序，Spring JDBC可以帮助我们更加轻松地访问和操作数据库，Spring ORM可以帮助我们更加轻松地使用ORM框架等等。
总的来说，Spring框架可以帮助我们更加轻松地开发Java应用程序，提高开发效率，减少代码冗余和重复，使得应用程序更加灵活和易于维护。
spring官网地址：https://spring.io/
2.Spring包含哪些模块 Spring框架包含了很多模块，以下是一些重要的Spring模块：
Spring Core：Spring框架的核心模块，提供了依赖注入（DI）和控制反转（IoC）的功能，用于管理对象之间的依赖关系。
Spring MVC：基于MVC（Model-View-Controller）模式的Web框架，提供了用于处理请求、响应以及Web应用程序其他方面的API。
Spring Data：Spring框架的数据访问层模块，提供了通用的数据访问抽象层和一些特定数据访问技术的实现，如JPA、Hibernate等。
Spring Security：Spring框架的安全模块，提供了基于Spring框架的认证和授权功能，可以保护Web应用程序免受各种攻击。
Spring Integration：Spring框架的集成模块，提供了一些集成技术的实现，如消息队列、Web服务、FTP等。
Spring Batch：Spring框架的批处理模块，提供了处理大规模数据批处理的功能，包括事务处理、并发处理、失败处理等。
Spring Cloud：Spring框架的云原生模块，提供了在云环境下构建微服务应用程序所需的一些基础设施和工具，如服务注册、配置中心、断路器等。
除了以上列举的模块，Spring框架还包含了很多其他的模块，比如Spring WebFlux、Spring Test、Spring WebSocket等，每个模块都提供了一些特定的功能和工具，可以帮助开发者更加方便地开发Java应用程序。
3.什么是IOC? 如何实现的？ IoC（Inversion of Control）是一种设计模式，它将对象之间的依赖关系的管理交给框架来处理，从而实现对象之间的松耦合和可维护性。
传统的编程模式中，对象之间的依赖关系是由对象自己来管理的，当对象A需要对象B的协助完成某个功能时，对象A会主动创建对象B，然后在适当的时候调用对象B的方法。这种方式会导致对象之间的依赖关系紧密耦合，使得代码难以维护和扩展。
在Spring框架中，实现IoC的方式是通过依赖注入（Dependency Injection，DI）来实现的。DI有三种实现方式：
构造函数注入（Constructor Injection）：通过构造函数来注入依赖对象。
属性注入（Setter Injection）：通过setter方法来注入依赖对象。
接口注入（Interface Injection）：通过接口方法来注入依赖对象。
当我们定义一个Bean时，可以通过注解或XML配置文件来定义Bean之间的依赖关系，然后由容器来动态注入依赖对象，使得对象之间的依赖关系更加松散，易于维护和扩展。
具体实现过程如下：
定义Bean：通过注解或XML配置文件来定义Bean，并在Bean的构造函数、属性或方法上使用特定的注解，表明Bean所依赖的其他Bean。
加载配置文件：启动应用程序时，IoC容器会读取并解析配置文件，将其中的Bean定义加载到容器中。
创建Bean：当需要使用某个Bean时，IoC容器会根据配置文件中的定义，创建该Bean的实例。
注入依赖：当IoC容器创建一个Bean时，它会检查该Bean所依赖的其他Bean是否已经创建，如果已经创建，则会将依赖的Bean注入到该Bean中，否则会等待所依赖的Bean创建完成后再注入依赖。
返回Bean：当IoC容器完成Bean的创建和依赖注入后，将该Bean返回给调用方使用。
实现IoC的原理是通过控制反转（Inversion of Control，IoC）来实现的。
控制 ：指的是对象创建（实例化、管理）的权力
反转 ：控制权交给外部环境（Spring 框架、IoC 容器）
传统的编程模式中，对象之间的依赖关系是由对象自己来管理的，当一个对象需要使用另一个对象时，需要自己创建并管理另一个对象。而IoC的思想是将对象之间的依赖关系的管理交给框架来处理，对象只需要定义它们所需的依赖关系，框架会在运行时动态地注入依赖对象，从而实现对象之间的松耦合和可维护性。因此，实现IoC的核心思想是将对象的创建和对象之间的依赖关系的管理交给框架来处理。
4.什么是AOP? 有哪些AOP的概念？ AOP（Aspect-Oriented Programming）是一种编程思想，它通过将应用程序分解成多个切面，来实现对应用程序进行横向切割的目的，从而实现代码的复用和系统的解耦。
AOP的核心思想是将与业务逻辑无关的代码，如日志、事务、异常处理等，从业务逻辑代码中分离出来，形成独立的模块，以便于复用和维护。
AOP的一些概念如下：
切面（Aspect）：切面是一个模块化的横切关注点，它通过对某个点进行拦截，来实现对目标对象的增强。
连接点（Join Point）：连接点是在应用程序执行过程中能够插入切面的点，例如方法调用或异常处理等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94130ae09df83e4638dccf1bbeb535ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d76c0f4d7c5208d5912306236743993/" rel="bookmark">
			win电脑C/D盘清理技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dir /AD 查看当前路径下的所有文件夹 ; 1. 下载 和安装 磁盘文件占用空间分析工具TreeSize Free 可以查看某个目录下的每个文件/文件夹占用的磁盘空间大小， 大文件夹使用win自带 的右键属性查看大小会耗时很久。 2. 把自己安装在C盘的占内存的大型软件移动到D/E盘，除了回收站和tmp/temp,其它的要慎重清理，有可能是系统文件。 1. 常见的C盘的大文件夹 C: ——$RecycleBin 回收站：把需要的文件还原，再清空回收站 ——Program Files&lt;DIR&gt;（占6GB）：64位的软件程序 ——Program Files(x86)&lt;DIR&gt;（占7.4GB）：32位的软件程序 ——ProgramData&lt;DIR&gt;（占1.2GB）系统文件夹 ——tmp&lt;DIR&gt; 用户使用电脑程序时生成的临时文件,可以全选删除 ——Windows&lt;DIR&gt; win系统的核心文件 ——assembly（占1.5GB） ——Fonts（占632MB）系统自带的字体，不要删 ——Installer&lt;DIR&gt;（占1.48GB）:安装应用程序的配置信息。 ——Microsoft.NET（占1.0GB） ——servicing&lt;DIR&gt;（占1.2GB）服务，不要动。 ——Packages&lt;DIR&gt;（占130MB） ——Sessions&lt;DIR&gt;（占940MB） ——SoftwareDistribution&lt;DIR&gt;（占4.3GB） ——download&lt;DIR&gt;（占940MB）用户下载的文件,可以全选删除 ——System32&lt;DIR&gt;（占6.4GB） ——SysWOW64&lt;DIR&gt;（占1.5GB） ——Temp&lt;DIR&gt; ——WinSxS&lt;DIR&gt;（占10.7GB）主要包含的是 Windows 共享文件、系统备份、已禁用的功能文件以及缓存和临时数据等，不要随便删除，会导致系统崩溃。 ——Users 用户&lt;DIR&gt; ——Administrator&lt;DIR&gt;（占5.5GB） --.Neo4jDesktop（占1.37GB）把它删除后重新安装到D盘 --AppData（占5.3GB） 隐藏的系统文件夹，存储关于已安装应用程序的各种配置文件（包括有关应用程序设置的信息、用户登录软件的帐户的配置文件）、用于程序正常运行的临时文件、应用程序日志、关于已保存的应用程序用户和会议的信息。删除它会导致某些软件需要重新激活，极个别软件需要重新安装。 --文档(24Mb) --桌面(21Mb) ——Default&lt;DIR&gt;（占360MB） --AppData（占56.3MB） --桌面(占358MB) 2. C盘 清理技巧 2.1 删除用不到的缓存文件 ”回收站”、“临时文件”和“缩略图”，把需要的文件恢复，再清空回收站。
按下“win”+“i” 键，打开“设置”--系统---存储， 开启存储感知，删除C盘临时文件和废弃文件；
打开电脑右键选中C盘之后，选择“属性”进入。最后在C盘属性窗口下点击“磁盘清理”。，扫描完成时 勾选 需要清理的垃圾文件以及旧windows安装版本（“设置日志文件”、“Windows 更新清理”、“Windows升级日志文件”），点“确定” 。 清理磁盘中的垃圾文件---微软补丁以及旧系统等文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d76c0f4d7c5208d5912306236743993/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/762ee526d3243c8b8dc0999bb80207e9/" rel="bookmark">
			JAVA学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、JAVA概述1. 基础2. 转义字符：3. 注释4. 常见错误 二、变量1. +号的使用2. 数据类型浮点数使用陷阱：字符型 3. 数据类型转换a. 自动数据类型转换b. 强制类型转换 三、运算符1. 算术运算符2. 关系运算符3. 逻辑运算符4. 赋值运算符5. 三元运算符6. 运算符优先级7. 标识符命名规则和规范8. 进制（很重要的基本功）9. 反码补码原码 四、控制结构1. Switch语句2. for循环for循环的执行顺序 3. 多重循环 五、数组、排序和查找1. 数组数组初始化：数组注意细节数组赋值（*）![在这里插入图片描述](https://img-blog.csdnimg.cn/5e97417778b541fc91c459e82e36993d.png)二维数组的内存形式 2. 排序冒泡排序 六、面向对象（基础）1. 类与对象对象在内存中存在形式(*）类和对象的内存分配机制（*）方法调用机制方法传参机制（*） 2. 递归3. 方法重载4. 可变参数5. 作用域6. 构造器/构造方法构造器细节含构造器的对象创建流程分析 7. this8. 本章习题 七、面向对象（中级）1. IDEA常用快捷键模板 2. 包3. 访问修饰符4. 封装（*）5. 继承（*）继承的本质（**）super关键字方法重写/覆盖 6. 多态对象的多态（*）![在这里插入图片描述](https://img-blog.csdnimg.cn/a1b953f32ac54c729542cdee31b2ae4c.png)instanceOf动态绑定机制（**）多态数组多态参数 7. Object类==和equals的区别toString 8. 断点调试 八、面向对象（高级）1. 类变量和类方法类变量类方法 2. main方法IDEA给main传参数 3. 代码块4. final5. 抽象类6. 接口7. 内部类1. 局部内部类2. 匿名内部类3. 成员内部类4. 静态内部类 一、JAVA概述 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/762ee526d3243c8b8dc0999bb80207e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42ce8628ab5875b968293febc6921171/" rel="bookmark">
			Error updating database. Cause:java.sql.SQLException: Lock wait timeout exceeded； try 清除数据库执行时间较长的任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SELECT * FROM information_schema.`PROCESSLIST` WHERE TIME &gt; 1000 AND USER = 'dimsusr' ORDER BY TIME DESC;
kill id ；
Error updating database. Cause:java.sql.SQLException: Lock wait timeout exceeded; try restartingtransaction select * from information_schema.innodb_trx
查看 trx_mysql_thread_id
show processlist
kill 100070;
引起的问题：并发下spring事务造成了死锁。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a279ff2cb6362c68b245a7b83260b599/" rel="bookmark">
			Mac Apple Silicon M1/M2 homebrew miniforge conda pytorch yolov5深度学习环境搭建并简单测试MPS GPU加速
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 开始安装零，获取代理一，配置代理配置zsh走代理配置git走代理 二，安装homebrew三，安装miniforge四，创建conda环境五，安装pytorch六，运行yolov5六，测试Apple Silicon的MPS GPU加速测试yolov5的mps加速测试resnet50的mps加速对比测试1080ti，3700x总结 开始安装 笔者使用的是一台M2版本的Macbook Air，虽然苹果作为深度学习的训练机不太合适，但是由于macbook作为打字机实在是无可挑剔，所以使用macbook调试一下pytorch的代码再放到集群上训练或者直接在mac上调试运行代码都是不错的体验，本文以在mac上直接调试yolov5为目标，大概记录一下步骤。
零，获取代理 这一步就是大家八仙过海各显神通的时候了😄
或者直接使用国内源安装，可以参考Homebrew国内如何自动安装（国内地址）（Mac &amp; Linux）
以下过程都是基于有代理的情况下的安装过程，基本无痛
一，配置代理 总之开启代理后，除了浏览器可以走代理访问之外，还需要配置zsh和git走代理，否则homebrew的安装会比较痛苦。
配置zsh走代理 #首先创建~/.zshrc vim ~/.zshrc 加入本地代理的端口地址，例如127.0.0.1:8080
function onproxy() { export no_proxy="localhost,127.0.0.1,localaddress,.localdomain.com" export http_proxy="http://127.0.0.1:8080" export https_proxy=$http_proxy export all_proxy=socks5://127.0.0.1:8080 echo -e "\033[32mproxy on!\033[0m" } function offproxy(){ unset http_proxy unset https_proxy unset all_proxy echo -e "\033[31mproxy off!\033[0m" } 然后source一下
source ~/.zshrc 运行一下onproxy开启代理（后面也要记得重启terminal的时候运行开一下，或者写到.zshrc里）
onproxy 测试一下是不是成功
curl -vv https://www.google.com 如果返回报文中有status 200 OK等字样就说明现在配置成功，但是ping依然是不能正常使用代理的，所以即便配置了代理，ping google还是不行的。
配置git走代理 将git也配置一下走代理：
git config --global http.proxy http://127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a279ff2cb6362c68b245a7b83260b599/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccef356caffb07d414ea1168e48d2997/" rel="bookmark">
			nn.CrossEntropyLoss()和手算交叉熵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 以计算[[17.95,13.84],[14.96,17.59]]的交叉熵数值，label为[0,1] 为例，手动方法为：
与使用nn.CrossEntropyLoss()函数计算结果不同，可能是由于两种方法的实现细节不同所致。总之计算可以分为3步 ：
首先，将模型输出应用softmax函数，将输出转换为概率分布。然后，将标签转换为类别索引。在本例中，标签为[0, 1]，将转换为类别索引[0, 1]。最后，计算交叉熵损失，公式如下
. 在第二步计算时，nn.CrossEntropyLoss()函数在计算log softmax时会减去一个常数，这个常数的值是输入中的最大值。这个常数的引入会使得最终的交叉熵结果发生偏移。因此和手动算的不一样。
可以通过
max_val = torch.max(input, dim=1).values
log_softmax = F.log_softmax(input, dim=1)
log_softmax -= max_val.view(-1, 1)
然后代入公式可以得到结果0.0226 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0e2563ab02063e8411e187054f51122/" rel="bookmark">
			NIO基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NIO NIO基础 non-blocking io 非阻塞IO
三大组件 Channel channel 有一点类似于 stream，它就是读写数据的双向通道，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层
常见的 Channel 有
FileChannel（文件）DatagramChannel（UDP）SocketChannel（TCP）ServerSocketChannel（TCP） Buffer buffer 则用来缓冲读写数据，常见的 buffer 有
ByteBuffer（抽象类） MappedByteBuffer（实现类）DirectByteBufferHeapByteBuffer ShortBufferIntBufferLongBufferFloatBufferDoubleBufferCharBuffer Selector selector 单从字面意思不好理解，需要结合服务器的设计演化来理解它的用途
多线程版设计
⚠️ 多线程版缺点
内存占用高线程上下文切换成本高只适合连接数少的场景 线程池版设计
⚠️ 线程池版缺点
阻塞模式下，线程仅能处理一个 socket 连接仅适合短连接场景 selector 版设计
selector 的作用就是配合一个线程来管理多个 channel，获取这些 channel 上发生的事件，这些 channel 工作在非阻塞模式下，不会让线程吊死在一个 channel 上。适合连接数特别多，但流量低的场景（low traffic）
调用 selector 的 select() 会阻塞直到 channel 发生了读写就绪事件，这些事件发生，select 方法就会返回这些事件交给 thread 来处理
ByteBuffer 有一普通文本文件 data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0e2563ab02063e8411e187054f51122/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7d31ad4ceecdccf8ae901585a92e9ff/" rel="bookmark">
			SpringBoot本地文件上传和oss文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot本地文件上传和oss文件上传+富文本编辑 一.本地上传 链接: springboot后端接收参数的几种方法
链接: 文件上传外部博客链接
链接: 文件上传外部博客链接
把用户的文件通过javaio流程复制到服务器的过程，称之为文件上传。
01.搭建一个springboot工程 02.准备一个页面文件上传的页面 后端 controller 的写法 package com.dailyblue.java.controller; import org.springframework.util.ResourceUtils; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.multipart.MultipartFile; import javax.servlet.http.HttpServletRequest; import java.io.File; import java.io.IOException; @RestController @RequestMapping("/upload") public class UploadController { @PostMapping public String upload(@RequestParam("file") MultipartFile file, HttpServletRequest request) throws Exception { // file:上传文件 // 获取到 images 的具体路径 // String realPath = request.getRealPath("images"); String realPath = ResourceUtils.getURL("classpath:").getPath() + "/static/images"; System.out.println("上传的文件地址是：" + realPath); // 服务器中对应的位置 // 产生唯一的文件名称 String fileName = UUID.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7d31ad4ceecdccf8ae901585a92e9ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32637dc55624082193a5e023bf7096da/" rel="bookmark">
			Linux磁盘扩容 直接给 / 分区（或者某一分区）扩容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 直接给 / 分区（或者某一分区）扩容，直接在原有磁盘上增大空间 查看磁盘空间大小，目前 / 分区大小为50G，并且只有一块磁盘 df -h
fidsk -l
2. 给/dev/vda 增加50G的空间，/dev/vda 目前为100G fdisk -l
3. 对磁盘分区 fdisk /dev/vda 使用fdisk /dev/vda ，输入n 新建分区，然后一直回车，最后输入 w 保存配置；
创建完成之后，可输入 p 查看；/dev/vda3 即为新建的分区
fdisk /dev/vda 4. 系统识别新增的分区 partprobe
输入partprobe 让系统识别新增的分区，然后创建物理卷，使用pvcreate /dev/vda3
5. 创建物理卷 pvcreate /dev/vda3
6. 扩展卷组 查看卷组信息
vgdisplay 扩展 / 的大小，增加50G，
lvresize -L +50G /dev/mapper/centos-root
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d96bbbd43990de81ca0179770ef09853/" rel="bookmark">
			knife4j(UI)文档-代码用例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		示例1
/** * 导出用户 */ @SneakyThrows @GetMapping("export-user") @ApiOperationSupport(order = 13) @ApiOperation(value = "导出用户", notes = "传入user") public void exportUser(@ApiIgnore @RequestParam Map&lt;String, Object&gt; user, BladeUser bladeUser, HttpServletResponse response) { QueryWrapper&lt;User&gt; queryWrapper = Condition.getQueryWrapper(user, User.class); if (!SecureUtil.isAdministrator()){ queryWrapper.lambda().eq(User::getTenantId, bladeUser.getTenantId()); } queryWrapper.lambda().eq(User::getIsDeleted, BladeConstant.DB_NOT_DELETED); List&lt;UserExcel&gt; list = userService.exportUser(queryWrapper); response.setContentType("application/vnd.ms-excel"); response.setCharacterEncoding(Charsets.UTF_8.name()); String fileName = URLEncoder.encode("用户数据导出", Charsets.UTF_8.name()); response.setHeader("Content-disposition", "attachment;filename=" + fileName + ".xlsx"); EasyExcel.write(response.getOutputStream(), UserExcel.class).sheet("用户数据表").doWrite(list); } 示例2
/** * 查询单条 */ @ApiOperationSupport(order =2) @ApiOperation(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d96bbbd43990de81ca0179770ef09853/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b45a192cd48d68a79f0daf43eecc3ade/" rel="bookmark">
			MySQL —— 基本查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 向表中插入数据2. 查询操作2.1 全列查询2.2 指定列查询2.3 查询字段带表达式2.4 为查询结果指定别名2.5 去重操作 3. where 条件3.1 比较运算符和逻辑预算符的运用3.2 like的细节3. 3 null查询 4. 对查询的结果进行排序4.1 对单一字段进行排序4.2 对多个字段排序4.3 对字段排序结果进行分页 5. 更改表中的数据5.1 更新单列数据5.2 更新多列的数据 6. 删除表中数据6.1 删除表中一个数据或或者多个数据6.2 删除全表的数据6.3 截断表，不可以恢复的删除 7. 去重操作8. 聚合函数 前言： 本文主要讲解MySQL中对表进行一些基本的查询操作，同时在讲一些对表的其他操作，所谓其他操作就是之前博客里面没有涉及到的。 1. 向表中插入数据 向表中插入数据再补充一下，如果插入的数据和主键或者唯一键冲突了的情况。
先创建 mysql&gt; create table students (id int unsigned primary key auto_increment, sn int not null unique comment '学号', name varchar(20) not null, qq varchar(20))character set utf8; Query OK, 0 rows affected (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b45a192cd48d68a79f0daf43eecc3ade/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ac2cfa0309cc399314d73dcc526bc29/" rel="bookmark">
			XILINX文档索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下文档均已机器翻译完
文档关键词全称UG058Aurora 8B10BAurora 8B10B Bus Functional Model User GuideUG585Zynq-7000Zynq-7000 SoC Technical Reference ManualUG897System GeneratorUser Guide Model-Based DSP Design Using System GeneratorUG948System GeneratorTutorial Model-Based DSP Design Using System GeneratorUG958System GeneratorReference Guide Model-Based DSP Design Using SystemGeneratorPB051Polar Encoder DecoderPolar Encoder Decoder v1.0PG003Image Enhancement IPImage Enhancement v8.0LogiCORE IP Product GuidePG014YCrCb to RGBYCrCb to RGB Color-Space Converter v7.1LogiCORE IP Product GuidePG015ImageLogiCORE IP Image Characterization v3.00aProduct GuidePG019AXI XADCLogiCORE IP AXI XADC v1.00aProduct GuidePG020AXI VideoAXI Video Direct Memory Access v6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ac2cfa0309cc399314d73dcc526bc29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/045f5ac59871de4d88d59d616d8dbb3c/" rel="bookmark">
			Xilinx的常见文档类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Xilinx的常见文档按类型分为：
封装规格： 说明xilinx器件的PCB封装以及提供封装信息，文档以BG开头。 开发套件技术文档： 向设计人员提供xilinx各类开发板以及原理图，使用方法以及参考设计。 白皮书： 官方的设计方法，实现细节以及解决方案，是一切设计的基础，文档以WP开头。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e064d4962ff24b0322fa5838fcb0f91c/" rel="bookmark">
			15、Linux：IP及端口检查命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本机IP：10.129.49.102，连接测试主机：10.129.49.104
一、查询IP 1、查询当前服务器的 IP 信息 ifconfig ---或使用： ip addr 请注意，ifconfig 命令用于查询时，主要查询 IP 地址，子网掩码和MAC地址等三类信息。当然，ifconfig 命令还可用于临时修改 IP 信息，只不过服务器一旦重启，配置则会失效。
临时配置 IP 地址，格式如下：
ifconfig 网卡名称 IP地址 临时配置IP地址，广播地址，子网掩码等信息，格式如下：
ifconfig 网卡名称 192.168.xx.xx broadcast 192.168.1.255 netmask 255.255.255.0 2、查询出口 IP 地址 curl cip.cc 出口 IP 也称外网 IP（公网 IP），它是路由器连接其他网络端口的 IP，如果自己在内网要发送信息到外部并被识别，需要配置公网 IP 地址。
二、查看端口号 1、lsof 命令 lsof（list open files）是一个列出当前系统打开文件的工具，该命令可进行系统监控、网络信息查看等，但需要 root 用户权限求执行。
用于端口号情况查看的常用命令，有：
# 【按端口查】查询指定端口号情况 lsof -i :端口号 # 【按用户查】查询该用户下的端口情况 lsof -a -u 用户名 -i # 【按协议类型查】查询IPv4协议有关的端口情况 lsof -i 4 # 【按tcp查】查看所有tcp端口情况 lsof -i tcp # 【按tcp查】查看tcp端口9001情况 lsof -i tcp:9001 # 【按udp查】查看所有udp端口情况 lsof -i udp # 【按udp查】查看udp端口121情况 lsof -i udp:121 2、netstat 命令 netstat 命令用于显示网络状态，Linux 服务器默认都装有这个命令。用于端口号情况查看的常用命令，有：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e064d4962ff24b0322fa5838fcb0f91c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1cfc0a5e0d28f8352e69597d7bd3bc4/" rel="bookmark">
			VM ubuntu长时间没有操作，出现黑屏，无法唤醒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章:1. 不息屏或者设置屏幕保护
VM ubuntu长时间没有操作，出现黑屏，无法唤醒 前言一、方法一（设置屏幕保护，设置不息屏） 前言 我在使用VM虚拟机运行Ubuntu时，长时间开着虚拟机没有操作，会出现黑屏的问题，再次进入后依然黑屏且无法唤醒，这样每次都需要重新启动虚拟机。
网上看到有说简单方式，可以设置屏幕保护或者设置不息屏来解决此类问题；设置后，发现没有出现黑屏问题；
一、方法一（设置屏幕保护，设置不息屏） 2.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3371c962024162b2042c7788b1ac7ab/" rel="bookmark">
			如何把已安装的nodejs高版本降级为低版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows如何把已安装的nodejs高版本降级为低版本 第一步：先清空本地安装的node.js版本
1.按健win+R弹出窗口，键盘输入cmd,然后敲回车（或者鼠标直接点击电脑桌面最左下角的win窗口图标弹出，输入cmd再点击回车键）
然后进入命令控制行窗口，并输入where node查看之前本地安装的node的路径
2.找到上面找到的路径，将node.exe所在的父目录里面的所有东西都删除
3.为了彻底删除之前安装的node.js，鼠标点击电脑左面最左下角的win窗口图标弹出，输入“控制面板”再点击回车键进入，进入控制面板后，找到所安装的node.js并卸载。
第二步：安装nvm管理工具（先关掉360等软件，不然会弹出警告！）
1.从官网下载安装包 https://github.com/coreybutler/nvm-windows/releases，下载红框里面的那个
2.将下载下来的压缩包进行解压（随便解压到任一你喜欢的位置），解压文件夹里面是一个.exe文件
3.开始进行nvm安装：
(1) 鼠标双击nvm-setup.exe文件，选择“我接受…”那一行，点击next
(2) 可以根据自身情况自定义选择路径盘，路径不要出现空格或中文符号（路径最好是在路径盘的根目录下，如C盘、D盘下的根目录），我自己选择D盘根目录。选好后点击next
(3) 选择node.js的安装位置，可以根据自身情况自定义选择路径盘，路径不要出现空格或中文符号（路径最好是在路径盘的根目录下新建一个文件夹，如C盘、D盘下的根目录），我自己在D盘根目录下新建一个nodejs文件夹。选好后点击next
(4) 最后一步，点击install即可安装完成
2.nvm安装完成后，检验是否安装成功，进入命令控制行窗口（进入方法见前面），
输入命令nvm v查看，如果出现版本号，即安装成功（如果安装不成功，查看之前自己安装的node.js有没有删除彻底、安装nvm工过程有没有漏掉什么！）。
3.接下来就是安装node.js版本
(1) 输入命令行nvm ls anaillable查看可用的node.js版本号
(2) 输入命令行nvm install node版本号(例如：nvm install 12.17.0)即可安装对应版本以及自动安装对应的npm版本。除了上面显示的node.js版本，其他版本号也可以下载，只不过有些可以准确下载，有些会出现npm版本不会自动下载。
(3) 安装成功后，输入命令行nvm use node版本号（例如：nvm use 12.17.0）即可选择你本地所使用的Node.js版本，使用此命
令行可以根据你自己的需要随意切换node.js版本运行。
使用管理员身份运行（框搜索cmd，右键选择管理员身份运行）cmd再执行nvm use node版本号。
安装完成后可以分别输入命令行node -v和npm -v，检验node.js以及对应npm是否安装成功，如果可以显示版本号这说明安装成功。
(4) 输入命令行nvm ls查看你安装的所有node.js版本号，以及你当前所选择的node.js运行版本
(4) 如果想删除某node.js版本的话，输入命令行nvm uninstall node版本号（例如：nvm use 12.17.0）即可删除对应版本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95f44c3217d5f5246d03a8b4dd33bf90/" rel="bookmark">
			axios配置：错误重试以及设置拦截器，以Csdn为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端开发项目是，必不可少的就是要能发送数据请求，而常用安装请求的js库就非Axios莫属了。 接下来，就开始进行配置。下面以对csdn请求为例。 // request 对axios进行业务的 简单封装 const axios = require('axios'); const baseHeadersMiddleware = require('./baseHeadersMiddleware'); const getAutoRetryInterceptor = require('./getAutoRetryInterceptor'); // 创建axios的默认配置 const instance = axios.create({ baseURL: 'https://blog.csdn.net', // api的域名或者公共前缀 withCredentials: true, // 跨域请求是否携带cookie， 默认为false }); // 增加默认的请求头 instance.defaults.headers.common['Content-Type'] = 'application/json'; // 使用base请求头中间件 做请求拦截器 instance.interceptors.request.use(baseHeadersMiddleware); // 对返回数据进行处理 instance.interceptors.response.use(response =&gt; { const config = response.config; // 这里是请求配置，如果ignoreInterceptors或者noDataCode 满足，就直接返回response if (config.ignoreInterceptors || config.noDataCode) { return response; } // 从返回头 获取需要的数据 const { code } = response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95f44c3217d5f5246d03a8b4dd33bf90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72c59d8c607955645a50f71d126b307e/" rel="bookmark">
			图像处理步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本步骤 1、图像预处理，包括高斯滤波，图像去噪，图像增强等
2、图像分割
3、孔洞填充
4、连通域标记
5、特征提取
6、结果输出
二、图像的预处理 为了方便计算，系统通常将获取的图片灰度化。将彩色图像转化成为灰度图像的过程就称为图像的灰度化处理。彩色图像中R、G、B三个分量的值决定了具体的像素点。一个像素点可以有上千万种颜色。而灰度图像是一种彩色图像，但是它的特点在于R、G、B三个分量具体的值是一致的。灰度图中每个像素点的变化区间是0到255，由于方便计算，所以在实际工程处理中会先将各种格式的图像转变成灰度图像。在保留图像轮廓和特征的基础上，灰度图仍然能够反映整幅图像轮廓和纹理。在Opencv里面有实现图像灰度化的接口。调用OpenCV中的cvSmooth函数进行中值滤波处理，以去除细小毛刺。
三、图像分割 将图像分离为目标像素和背景像素，初始分割之后一般需要进行形态学处理才能满足使用要求。
常用分割方法：直接输入；硬阈值分割；软阈值分割。
常用形态学处理：连通、膨胀、腐蚀、开操作、闭操作、顶帽变换、击中与不击中变换、交集、差异、骨架、边界等。
阈值分割又包括：
1）简单阈值分割threshold
适用范围：目标与背景之间存在灰度差（如果环境稳定，阈值可以在离线状态下一次确定）
2）动态阈值分割dyn_threshold
适用范围：背景不均一无法确定全局阈值、目标经常表现为比背景局部亮一些或者暗一些。这时候需要通过其领域来找到一个合适的阈值进行分割。
确定其领域的方法是：通过一些平滑滤波算子来确定领域，例如mean_image或者binomial_filter
3）自动全局阈值方法bin_threshold
四、孔洞填充 我们在进行图像分割后，分割结果有时会有一些小孔洞，如图1所示，其中黑白两色表示两种不同的类别。一般情况下，这些孔洞属于错分情况，为了优化结果，我们通常对这些孔洞进行填充。
填充结果如图2所示，三个孔洞均被填充。 五、连通域标记 进行连通域标记之前的图像一般是经过阈值分割处理为二值图像。二值图像中可能有多个连通区域，进行 图像检测的吋候往往关心的是每个连通域各自的特性，为了提取不同区域的特征，就需要使用连通域标记 的方法把不同的连通域区分开來。连通区域标记算法通常应用在图像分析领域，例如，在光学字符识别中对字符分割提取、医学图像处理中提取感兴趣的目标和视频图像中对运动的前景目标进行分割和提取等等。
下面是一个二值图像被标记后，比较形象的显示效果
六、特征提取 特征是一个数字图像中“有趣”的部分，它是许多计算机图像分析算法的起点。特征提取是图象处理中的一个初级运算，也就是说它是对一个图像进行的第一个运算处理。它检查每个像素来确定该像素是否代表一个特征，一般提取的是边缘、角，文理等。
七、缺陷检测六大基本方法 1. blob + 特征
2. blob + 特征+ 差分
3. 频域 + 空间域
4. 光度立体法
5. 特征训练（分类器，机器学习）
6. 测量
参考：
Halcon案例之BLOB分析_山水之间2018的博客-CSDN博客_blob分析
使用Opencv的车牌识别_lvquanye9483的博客-CSDN博客_车牌识别opencv
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0fc45baa71f115f19940b05aea0d4ab/" rel="bookmark">
			【MinIO】MinIO分块上传和分块合并demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【MinIO】MinIO分块上传和分块合并demo 文章目录 【MinIO】MinIO分块上传和分块合并demo1. 分块上传demo2. 分块合并demo 1. 分块上传demo //测试文件分块方法 @Test public void testChunk() throws IOException { //源文件 File sourceFile = new File("d:/develop/bigfile_test/nacos.avi"); //输出路径 String chunkPath = "d:/develop/bigfile_test/chunk/"; File chunkFolder = new File(chunkPath); //路径不存在则创建 if (!chunkFolder.exists()) { chunkFolder.mkdirs(); } //分块大小 long chunkSize = 1024 * 1024 * 1; //分块数量 long chunkNum = (long) Math.ceil(sourceFile.length() * 1.0 / chunkSize); System.out.println("分块总数：" + chunkNum); //缓冲区大小 byte[] b = new byte[1024]; //使用RandomAccessFile访问文件 RandomAccessFile raf_read = new RandomAccessFile(sourceFile, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0fc45baa71f115f19940b05aea0d4ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa98853b7259557c2e297a304d17c1f4/" rel="bookmark">
			论文阅读：NeRF&#43;&#43;: ANALYZING AND IMPROVING NEURAL RADIANCE FIELDS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中文标题：分析并提升神经辐射场 提出问题 把NeRF生成的视角图像投影到一个球模型上（体密度在球面上为1，其余为零），这个模型可以很好解释训练集（左2），但是一旦推广到其他视角（右2），球模型就无法得到正确的颜色（右1）。（这里的球模型上的点在不同方向上有不同的颜色）对于一个任意的、不正确的形状，我们可以表明存在一系列的辐射场，它可以完美地解释训练图像，但却不能很好地推广到新的测试视图。 创新点 提出了一种新的空间参数化方案，我们称之为倒球面参数化，它允许NeRF处理一类新的无界场景。假设有两个相关因素影响了NeRF：1)不正确的几何形状迫使辐射场具有更高的内在复杂性（即更高的频率），而相比之下，2)NeRF的特定MLP结构隐含地编码了表面反射率的平滑BRDF。 论文分析 为什么NeRF可以避免这种退化解？因素1：当σ偏离了正确的形状时，c通常必须相对于d成为一个高频函数，才能重建输入的图像。对于正确的形状，表面光场通常会更平滑（实际上，对于兰伯特材料是恒定的）。在有限的容量MLP下，不正确形状所需的更高复杂度更难表示。因素2： 特别地，NeRF的特定MLP结构编码了一个隐式的先验，有利于光滑的表面反射函数，其中c在任何给定的表面点x上相对于d是光滑的(线性)。这个MLP结构，将场景位置x和观看方向d不对称：d注入到网络接近MLP，这意味着有更少的MLP参数，以及更少的非线性激活，参与创建视图依赖的影响。此外，用于编码观察方向的傅里叶特征只包含低频分量。换句话说，对于一个固定的x，辐射c（x，d）对d有有限的表达性。
如果将NeRF的输入(x,d)同时输入网络，效果变差。 算法简介 倒置球面参数化：高的动态深度范围导致了NeRF的体积场景表示中严重的分辨率问题，因为为了合成逼真的图像，在等式中的在前景和背景区域都需要足够的分辨率，这对于根据三维空间的欧氏参数化来简单地采样点来实现是具有挑战性的。我们用倒球参数化来解决这个限制，便于自由视角合成。我们首先分区场景分成两个空间，一个内部单元球和外部体积由一个反向的球覆盖内部体积的补充（见图6插图和图7的真实场景以这种方式建模）。内部空间包含前景和所有摄像机，而外部卷包含环境的其余部分。
对于一个3D点 ( x , y , z ) , r = x 2 + y 2 + z 2 &gt; 1 (x,y,z), r = \sqrt{x^2+y^2+z^2} &gt; 1 (x,y,z),r=x2+y2+z2 ​&gt;1 时单位球外的一点，可以被重参数为 ( x ′ , y ′ , z ′ , 1 / r ) , x ′ + y ′ + z ′ = 1 ( 0 &lt; 1 / r &lt; 1 ) , , x ′ , y ′ , z ′ ∈ [ − 1 , 1 ] (x',y',z',1/r), x'+y'+z' = 1(0&lt;1/r&lt;1),,x',y',z' \in [-1,1] (x′,y′,z′,1/r),x′+y′+z′=1(0&lt;1/r&lt;1),,x′,y′,z′∈[−1,1]。与欧几里得空间不同，物体可以与原点保持无限的距离，重参数化的四重数中的所有数字都是有界的。这不仅提高了数值的稳定性，而且还尊重了更远的物体应该得到更低的分辨率的事实。因此，渲染公式可以改写为： ( 0 , t ′ ) (0,t') (0,t′)属于球内， ( t ′ , ∞ ) (t',∞) (t′,∞)为球外。 参考文献： [1] Zhang K, Riegler G, Snavely N, et al.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa98853b7259557c2e297a304d17c1f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae89ee5c1bad3049beb833105146e6b8/" rel="bookmark">
			Win11 文件夹打开慢或卡顿解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 目前是 2023/2/27, 我的 Win11 系统点开一个文件夹要等待 2-3 秒才能加载出来, 使用体验极差。网上查阅大量资料, 有些人在系统更新后这个情况就消失了, 但是我这一直存在, 系统也是当前的最新版, 没有修复。
目前得出的结论是, 因为 Win11 的工具栏占用了过多的资源, 需要检索的内容过多导致的, 如下图所示。
这里的解决办法, 网上也有很多, 大致就是回退到 Win10 的资源管理器, 我也采用的是这种办法, 暂时过渡, 看后期更新会不会修复这个 BUG。
解决办法 改为 Win10 资源管理器并重启资源管理器生效
reg add "HKCU\Software\Classes\CLSID\{d93ed569-3b3e-4bff-8355-3c44f6a52bb5}\InprocServer32" /f /ve taskkill /f /im explorer.exe &amp; start explorer.exe 修改回 Win11 资源管理器
reg delete "HKCU\Software\Classes\CLSID\{d93ed569-3b3e-4bff-8355-3c44f6a52bb5}" /f taskkill /f /im explorer.exe &amp; start explorer.exe * 注意: 这里还需要关闭 Win10 的工具栏, 速度才最快, 如下图所示。
* 如果不想回退, 按 F11 进入文件资源管理器的全屏模式, 速度就会恢复正常, 适合轻度用户使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae89ee5c1bad3049beb833105146e6b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baa49dea51bc4b198fec282b55e886d1/" rel="bookmark">
			AndroidStudio打包HBuilderX的H5&#43;项目为安卓App【一次过，无任何异常报错】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.查看HBuilderX的版本号
2.下载Dcloud上对应的安卓SDK
3.下载完安卓SDK后，我们解压它，注意不要放在任何有中文组成的文件夹中【是否有中文决定于你鼠标单击上面路径后，第一张图还没鼠标单击，第二张已鼠标单击，以操作后为准，操作后没有中文即可！！！】
4.打开如下文件夹，删除__UNI__A文件夹
5.HBuilderX生成一个MUI项目
6.生成本地app资源
7.复制步骤6的资源文件夹到步骤4的空文件夹里
8.Android Studio打开以下项目
9.写两个批处理文件
10.双击运行批处理文件create.bat生成证书
11. 运行批处理文件look.bat，查看证书的信息【我这里输入了刚刚设置的密码123456】，先别急着关这个窗口
12.浏览器进入Dcloud开发者中心【开发者中心】
13. 回到Android Studio
14.将我们之前用批处理文件create.bat生成的证书test.keystore放到simpleDemo文件夹下
15.需要到如图文件中修改appid到与资源包一致
16. 打包成Apk
17.打包完毕后，查看Apk位置
​编辑
18.由于我的电脑安装了夜神模拟器，可以直接点开此Apk运行，同学们有其他模拟器的应该也可以直接运行，如果没有的话可以传输到手机上试一试
​编辑
19.运行结果
20.注意事项
前提：AndroidStudio,HBuilderX,JDK&gt;=1.8并配置好环境变量
1.查看HBuilderX的版本号 得到
2.下载Dcloud上对应的安卓SDK 注意一定要和自己的HBuilderX对应好版本，下载时如果没有百度网盘会员请选用和彩云下载，那个更快一些。
3.下载完安卓SDK后，我们解压它，注意不要放在任何有中文组成的文件夹中【是否有中文决定于你鼠标单击上面路径后，第一张图还没鼠标单击，第二张已鼠标单击，以操作后为准，操作后没有中文即可！！！】 4.打开如下文件夹，删除__UNI__A文件夹 5.HBuilderX生成一个MUI项目 修改index.html为【就是往里边加一点东西而已】
6.生成本地app资源 7.复制步骤6的资源文件夹到步骤4的空文件夹里 资源文件
复制到步骤4刚清空的文件夹
8.Android Studio打开以下项目 改视图为项目视图
展开文件夹simpleDemo
9.写两个批处理文件 批处理文件1【create.bat】用于生成证书
内容为
keytool -genkey -alias testalias -keyalg RSA -keysize 2048 -validity 36500 -keystore test.keystore 批处理文件2【look.bat】用于查看证书信息
内容为
keytool -list -v -keystore test.keystore pause 10.双击运行批处理文件create.bat生成证书 要注意的是，你在输入密码的时候光标不会有移动的变化，但是你的在输入状态的，不要管他，输入完毕按下回车，这里我以密码为123456示例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/baa49dea51bc4b198fec282b55e886d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e3f1e50be5c9828a5df9d1a317c8efc/" rel="bookmark">
			Java小案例——制作万年历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java小案例——万年历（打印一个简单的日历） 今天我们用Java来实现一个小的案例，输入年和月，打印当月的日历。 实现如下效果：
但是我们并不能确定用户输入的当前年份下当月的第一天是星期几，现在有一个线索提供如下：
1900年1月1日 – 星期一
我们通过这个线索来获取从1900年1月1日到输入年和输入月的总天数，然后用这个总天数与7做余数，通过余数来确定输入年月的第一天是星期几（整除就将余数设置为7）
首先我们需要通过调用Scanner类来提示用户输入正确的年份和月份：
while(true){ System.out.println("请输入年份："); int year = scanner.nextInt(); if (year &lt; 0) { System.out.println("请输入正确的年份!"); continue; } System.out.println("请输入月份："); int month = scanner.nextInt(); if (month &lt; 0 || month &gt; 12) { System.out.println("请输入正确的月份!"); continue; } } 那么怎么计算总天数呢？我的思路是：把年和月拆分出来，先算1900~输入年的总天数，再算1月到输入月的总天数
// 获取年的总天数 int allDaysOfYear = 0; for (int i = 1900; i &lt; year; i++) { if (i % 4 == 0 &amp;&amp; i % 100 != 0 || i % 400 == 0) {// 闰年 allDaysOfYear += 366; } else {// 平年 allDaysOfYear += 365; } } // 获取月的总天数 int allDaysOfMonth = 0; for (int i = 1; i &lt; month; i++) { switch (i) { case 1:case 3:case 5:case 7:case 8:case 10:case 12: allDaysOfMonth += 31; break; case 4:case 6:case 9:case 11: allDaysOfMonth += 30; break; case 2: if (year % 4 == 0 &amp;&amp; year % 100 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e3f1e50be5c9828a5df9d1a317c8efc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/553129a574df905dae97c081178ece16/" rel="bookmark">
			双目相机&#43;YOLOv5跟踪超声探头，获取三维超声点云数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双目相机+YOLOv5跟踪超声探头，获取三维超声点云数据 本代码用于采集超声点云数据。技术路径为双目相机+YOLOv5实时跟踪超声探头，保存其三维坐标，同时与超声探头采集的超声信号进行匹配。
''' by lcz 2022.11.2 ''' # 导入依赖 import random from utils.torch_utils import select_device, time_sync from utils.general import ( check_img_size, non_max_suppression, apply_classifier, scale_coords, xyxy2xywh, strip_optimizer, set_logging) from utils.dataloaders import LoadStreams, LoadImages, letterbox from models.common import DetectMultiBackend import torch.backends.cudnn as cudnn import torch import pyrealsense2 as rs import math import yaml import argparse import os import numpy as np import sys import time import matplotlib.pyplot as plt import csv import cv2 # 读取信号函数 def read_signal(): txt_local = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/553129a574df905dae97c081178ece16/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/174/">«</a>
	<span class="pagination__item pagination__item--current">175/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/176/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>