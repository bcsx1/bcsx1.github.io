<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c7d396f03c7d1b12a304b5bd8f849a9/" rel="bookmark">
			Win10任务栏软件图标变成白色如何解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法1：
1、“win”+“R键”弹出运行窗口，输入%APPDATA%\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar
2、，将没有图标的程序的快捷方式放入到弹出的TaskBar文件夹中
3、重新运行该程序
若未恢复图标，在任务栏上右键点击【固定到任务栏】再取消固定，可以发现图标显示正常。
解决方法2：
可以清理一下图标的缓存，将以下代码复制到记事本另存为：清理图标缓存.bat 文件，然后双击运行此批处理文件即可。
@echooff color0A taskkill/f/imexplorer.exe attrib-h-s-r”%userprofile%\AppData\Local\IconCache.db“ del/f”%us 解决方法3：
同时按Windows键+R键打开运行对话框，输入ie4uinit.exe -show然后回车即可修复。
解决方法4：
将以下代码复制到记事本另存为：清理图标缓存.bat 文件，然后双击运行此批处理文件即可。
reg delete “HKEY_CURRENT_USER\Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\TrayNotify” /va /f taskkill /f /im explorer.exe &amp; start explorer.exe 注意：要新建一个记事本（后缀为.txt），把上述代码复制进去之后保存，更改后缀名为.bat文件，然后双击该.bat文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f8e0c66eafa89be28b341fe7e7add6a/" rel="bookmark">
			长短期记忆网络 LSTM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 1. LSTM介绍1.1 什么是LSTM1.2 LSTM相较于RNN的优势1.3 LSTM的结构图1.3.1 LSTM的核心思想1.3.2 LSTM的遗忘门1.3.3 LSTM的输入门1.3.4 LSTM的输出门 1.4 LSTM的优缺点1.5 如何计算 LSTM 的参数量？1.6 LSTM与GRU相比怎么样呢？ 2. nn.LSTM()2.1 nn.LSTM()的参数解释2.2 nn.LSTM()的输入输出 1. LSTM介绍 1.1 什么是LSTM 长短期记忆（Long short-term memory, LSTM）是一种特殊的RNN，主要是为了解决长序列训练过程中的梯度消失和梯度爆炸问题。简单来说，就是相比普通的RNN，LSTM能够在更长的序列中有更好的表现。
1.2 LSTM相较于RNN的优势 举个表现更好的例子：
我们想预测’full’之前系动词的单复数情况，显然full是取决于第二个单词’cat‘的单复数情况，而非其前面的单词food。
根据RNN的结构，随着数据时间片的增加，RNN丧失了学习连接如此远的信息的能力。如下图所示，越到后面，前面单词的信息就越来越少了。
根据LSTM的结构，能够解决RNN的长期依赖问题，是因为LSTM引入了门（gate）机制用于控制特征的流通和损失。对于上面的例子，LSTM可以做到在t9时刻将t2时刻的特征传过来，这样就可以非常有效的判断t9时刻使用单数还是复数了。 1.3 LSTM的结构图 从下图我们可以看到相较于RNN模型，LSTM好想复杂了好多。这正式因为引入了门机制来控制特征的流通和损失，因此LSTM能够在更长的序列中，相较于RNN有更好的表现。
其中，Ct-1 表示过去的记忆， Ct 表示当前时刻神经元的状态，ht-1 表示输入，ht表示输出，Xt表示当前输入。C表示长期记忆，h可以看做是短期记忆，x代表事件信息，也就是输入。这个些很重要！！！！！
现在来看看里面详细的样子
1.3.1 LSTM的核心思想 LSTM主线就是这条顶部水平贯穿的线，也就是长期记忆C线（细胞状态），达到了序列学习的目的。而h可以看做是短期记忆，x代表事件信息,也就是输入。
LSTM具有其中三个门，以保护和控制单元状态。LSTM通过“门”（gate）来控制丢弃或者增加信息，从而实现遗忘或记忆的功能。“门”是一种使信息选择性通过的结构，由一个sigmoid函数和一个点乘操作组成。sigmoid函数的输出值在[0,1]区间，0代表完全丢弃，1代表完全通过。
1.3.2 LSTM的遗忘门 顾名思义，这个遗忘门就是决定要不要以往的信息，遗忘门控制之前记忆状态的输入幅度。
遗忘门的任务就是接受一个长期记忆 Ct-1（上一个单元模块传过来的输出）并决定要保留和遗忘Ct-1的哪个部分。
例如，在语言模型中，我们想要通过一个词来预测下一个词，单元模块cell 中可能包含某个属性在下一个模块单元不需要，就可以将这个属性在单元模块cell 中遗忘（丢弃）。
1.3.3 LSTM的输入门 输入门控制输入（新记忆）的输入幅度，决定要让多少新的信息加入到cell 状态中。
输入门包括两个部分：
1、sigmoid层，决定那些信息需要更新。（图中第一个公式）
2、tanh层，创建一个新的候选值（candidate）向量，生成候选记忆。（图中第二个公式）
下面，我们把这两个部分联合起来对 cell 状态进行更新。
我们将旧状态Ct-1乘以ft，忘把一些不想保留的信息忘掉，然后加上输入的Ct∗it来形成新的状态Ct。根据我们决定更新每个状态值的程度进行缩放。
1.3.4 LSTM的输出门 输出门控制最终记忆的输出幅度，这个输出主要是依赖于 cell 状态 Ct。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f8e0c66eafa89be28b341fe7e7add6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46d85c8f91a6f06d262b84c603482b48/" rel="bookmark">
			C&#43;&#43;素数判定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		质数_百度百科
定义：
素数（也成质数）是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。
1.
循环，将n除以2---n-1的整数，如果有其中一个数运算后的余数==0，n不为素数。
#include&lt;iostream&gt; using namespace std; int main() { int n; cin&gt;&gt;n; bool flag=1; for(int i=2;i&lt;n;i++){ if(n%i==0){ flag=0; break; } } if(flag)cout&lt;&lt;"YES"; else cout&lt;&lt;"NO"; return 0; } 2.
开根号：
素数的因子只有1和它本身。 如果数c不是素数，则还有其他因子。设a,b.定有一个大于sqrt(c) ，一个小于sqrt(c) 。所以m一定有一个小于等于其平方根的因数，那么验证素数时就只需要验证到其平方根就可以了。
#include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n; cin&gt;&gt;n; bool flag=1; for(int i=2;i&lt;sqrt(n);i++){ if(n%i==0){ flag=0; break; } } if(flag)cout&lt;&lt;"YES"; else cout&lt;&lt;"NO"; return 0; } 3.
埃氏筛法 埃拉托斯特尼筛法_百度百科
要得到自然数n以内的全部素数，必须把不大于根号n的所有素数的倍数剔除，剩下的就是素数。 #include&lt;bits/stdc++.h&gt; using namespace std; bool flag[104]; int main() { memset(flag,1,sizeof(flag)); flag[1]=0; for(int i=2;i&lt;=sqrt(100);i++){ if(flag[i]){ for(int j=2;j*i&lt;=100;j++)flag[i*j]=0; } } for(int i=1;i&lt;=100;i++){ if(flag[i])cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46d85c8f91a6f06d262b84c603482b48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ff401e328b864c42645006de9f758dd/" rel="bookmark">
			C# wpf 自定义标题栏及无边框窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		wpf自定义标题栏系列 第一章 自定义标题栏（本章）
第二章 添加窗口阴影
第三章 style中定义标题栏
第四章 style使用参数及模板定义标题栏
文章目录 wpf自定义标题栏系列前言一、步骤1.设置窗口属性2.客户区定义标题栏 二、示例总结 前言 我们日常开发的时候，经常会遇到需要自定义标题栏的UI设计，采用特定颜色的标题栏或者特定样式的按钮，这个时候就需要自定义标题栏了，wpf中自定义标题栏还是相对容易的。
一、步骤 1.设置窗口属性 我们要把窗口本身的标题栏去除，因为标题栏不属于我们能控制的部分，我们能控制的只有窗口的客户区域。
ResizeMode="NoResize" WindowStyle="None" 如果需要异型窗口，比如圆角边框或者工具条，则需要加上下面2个属性设置。 AllowsTransparency="True" Background="Transparent" 2.客户区定义标题栏 我们可以在客户区的顶部添加一个容器作为标题栏。
&lt;StackPanel&gt; &lt;!--标题栏--&gt; &lt;Grid Background="Gray" Height="50" &gt; &lt;/Grid&gt; &lt;!--客户区--&gt; &lt;/StackPanel&gt; 二、示例 界面代码
&lt;Window x:Class="WpfApp1.MainWindow" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:sys="clr-namespace:System;assembly=mscorlib" xmlns:local="clr-namespace:WpfApp1" mc:Ignorable="d" Title="MainWindow" Height="370" Width="650" AllowsTransparency="True" Background="Transparent" ResizeMode="NoResize" WindowStyle="None" &gt; &lt;StackPanel Margin="10" Background="White"&gt; &lt;StackPanel.Effect&gt; &lt;DropShadowEffect ShadowDepth="0" BlurRadius="10" Opacity="0.8"/&gt; &lt;/StackPanel.Effect&gt; &lt;!--标题栏--&gt; &lt;Grid Background="Gray" Height="50" &gt; &lt;StackPanel Margin="0,0,10,0" HorizontalAlignment="Right" Orientation="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ff401e328b864c42645006de9f758dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef717d32cee0f9e98009b076a6d5fe99/" rel="bookmark">
			快速学会ansible的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、自定义环境2、在控制主机上安装ansible 1、自定义环境 准备大于等于三台主机
角色主机名ip地址组名控制主机server.example.com192.168.189.129server受控主机/被管节点node1.example.com192.168.189.134node1受控主机/被管节点node2.example.com192.168.189.135node2 (1)配置ip
给三台主机配置静态IP
nmcli c mo ens160 ipv4.addresses 172.25.250.100/24 ipv4.gateway 192.168.189.2 ipv4.dns 8.8.8.8 ipv4.method manual connection.autoconnect yes nmcli connection up ens160 # 重启连接 (2)多台主机配置主机名并且确保多台主机能够通过主机名互访
hostnamectl set-hostname server.example.com hostnamectl set-hostname node1.example.com hostnamectl set-hostname node2.example.com 在每台主机的/etc/hosts中配置
192.168.189.129 server.example.com 192.168.189.134 node1.example.com 192.168.189.135 node2.example.com (3) 多台主机通过ssh远程连接实现免密登陆
生成秘钥
ssh-keygen -t rsa -P '' -q -f ~/.ssh/id_rsa 将公钥钥拷贝到另外两台主机的用户家目录下的/.ssh/authorized_keys 中（没有的话，创建）
scp /root/.ssh/id_rsa.pub root@node1.example.com:/root/.ssh/authorized_keys scp /root/.ssh/id_rsa.pub root@node2.example.com:/root/.ssh/authorized_keys (4) 如果是通过普通用户管理受控主机，需要通过sudo提权。
2、在控制主机上安装ansible (1)配置epel扩展源
release 一般带这个东西指的是软件厂库.repo
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef717d32cee0f9e98009b076a6d5fe99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d46b3c856d17cece80cb46b1766b0ec2/" rel="bookmark">
			仿射变换和变换矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、2D图像的仿射变换
仿射变换包括 平移、旋转、错切、放缩（各向同性和各向异性）
欧式变换（刚体变换）包括 平移和旋转
相似变换包括平移、旋转、放缩（各向同性）
相似变换矩阵有4个自由度 s,θ,tx,ty：
仿射变换矩阵有6个自由度：
所有变换矩阵只需关注一点：坐标系的变化，即基向量和原点的变化；坐标系变化到哪里，坐标系中的所有点也跟着做同样的变化； 参考：
https://www.cnblogs.com/shine-lee/p/10950963.html
二、3D图像的仿射变换
2d变换矩阵推广到3d，其他变换矩阵推广较为简单，只介绍旋转变换矩阵和错切变换矩阵
绕x轴旋转：
绕y轴旋转： 绕z轴旋转：
错切变换矩阵：
参考：
3D仿射变换矩阵推导_l491337898的博客-CSDN博客_三维仿射变换
【深度好文】3D坐标系下的点的转换矩阵（平移、缩放、旋转、错切） - 知乎 (zhihu.com) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9edeff2278af49aeb9f2a1fc2112279/" rel="bookmark">
			通过id class ref 获取元素的高度和宽度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 dom 结构
&lt;div id="id1" class="class1" ref="ref1" style="width: 100px; height: 100px;"&gt;&lt;/div&gt; 通过 id 获取高度宽度
let widthid1 = document.getElementById("id1").offsetWidth let heightid = document.getElementById("id1").offsetHeight 通过class 获取高度宽度
let widthclass1 = document.getElementsByClassName("class1").offsetWidth let heightclass1 = document.getElementsByClassName("class1").offsetHeight 通过ref 获取高度宽度
let widthref1 = this.$refs.ref1.offsetWidth let heightref1 = this.$refs.ref1.offsetHeight 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7e0db343c830eed1afe13cbd892d50a/" rel="bookmark">
			IntersectionObserver用于监听页面元素出现消失的api
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们需要监听目标元素是否进入视口时，需要监听scroll事件，大量的计算会造成性能问题
IntersectionObserver API 是异步的，不随着目标元素的滚动同步触发。 即只有线程空闲下来，才会执行观察器。这意味着，这个观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。
直接放一个例子
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body{ margin: 0; padding: 0; height: 100vh; width: 100vw; overflow-x: hidden; } .flex{ display: flex; } .top-fixed{ top: 0; position: fixed; } .placeholder1{ width: 100%; } #box1{ height: 200px; overflow-y: auto; border: 1px solid #aaa; width: 60%; /* margin-bottom:500px; */ } .box1-placeholder{ height: 105vh; } #box2{ height: 100px; background-color: blue; margin-top: 300px; width: 60%; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7e0db343c830eed1afe13cbd892d50a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a53a2439667fab702e1a983edd4f45d/" rel="bookmark">
			JDK 8 中Stream流中去重的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JDK 8 中Stream流中去重的方法
1.简单的去重,可以使用distinct()方法去重,该方法是通过比较equals和hashcode值去去重,
2.复杂的去重,
例如,在一个JavaBean的集合中,去除某个属性重复的对象
@Override public List&lt;RptDayMonthTargetVO&gt; queryTarget() { List&lt;RptDayMonthTarget&gt; list = targetService.selectMonthTarget(); //数据去重-根据Bean对象的SupplierId属性去重 List&lt;RptDayMonthTarget&gt; dbList = list.stream().filter(distinctByKey(RptDayMonthTarget::getSupplierId)).collect(Collectors.toList());return voList; } private static &lt;T&gt; Predicate&lt;T&gt; distinctByKey(Function&lt;? super T, ?&gt; keyExtractor) { Map&lt;Object,Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;(); return t -&gt; seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd3e0d76bf6abaa3356fe8d8d990757b/" rel="bookmark">
			【自动控制原理】滞后补偿器_Lag Compensator-笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从稳态误差的角度入手。
先来看一个简单的单位反馈系统
求它的稳态误差，要用到终值定理
例如：一个系统的传递函数为
则
它的稳态误差为
我们把这个系统在simulink里看一下。
下面考虑加一个补偿器。
即前边所有式子都要乘上一个 .
稳态误差为
滞后补偿器
把博德图画出来我们就可以知道相位是有滞后的。
分很多种情况，下面列出两种：
然后放到simulink中，整体👇
运行👇
新增的极点和零点到根上的一个点，产生的角度是差别不大的。
即，新增的一对零点和极点靠近虚轴时，不会对原有系统的根轨迹产生大的影响。
这样就能尽可能地保持原有瞬态响应。
相反，如果两个点距离差别非常大，就会对原有瞬态响应产生非常大的影响。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87571f0aa5bb88ac815821e259c631d1/" rel="bookmark">
			C语言扫雷（递归展开）（详细注释）（完整代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、功能实现
1.雷盘初始化与打印
雷盘定义
初始化雷盘
打印雷盘
随机布置雷
2.玩家排查雷
获取坐标周围雷数
递归展开
胜负判断
显示雷位置
二、游戏试玩
三、游戏完整代码
game.h test.c
game.c
扫雷大家应该都知道，翻开一个格子，显示的数字就是周围 8 格所含的雷数。例如，红色框框里的1周围8格就只有一个雷。
我们定义两个数组来实现，show数组存放玩家看到的棋盘，mine数组存放隐藏的雷盘
这两个数组搭配使用，就能计算某个位置周围的雷数，并且修改show数组来显示这个位置的雷数。
但是如果计算边缘格子周围的雷数时，数组会越界。
我们只要在周围留一圈就能解决这个问题
如下图所示，假设我们要玩 9x9 的大小，我们的数组大小就定义为 11x11
一、功能实现 1.雷盘初始化与打印 雷盘定义 初始化雷盘 初始化show，mine两个数组，show 存放 '*' , mine存放 '0'
void init_board(char board[ROWS][COLS], int rows, int cols, char set) { int i = 0; int j = 0; for (i = 0; i &lt; rows; i++) { for (j = 0; j &lt; cols; j++) { board[i][j] = set; } } } 打印雷盘 //打印show雷盘 void display_board(char board[ROWS][COLS], int row, int col) { int i = 0; int j = 0; //这里打印上面一行数字 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87571f0aa5bb88ac815821e259c631d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f78d0eaa6916d5dc4e713a8973e1ed3/" rel="bookmark">
			【Linux】CentOS 虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 虚拟机 一、下载 CentOS 镜像二、新建 CentOS 虚拟机三、启动虚拟机，完成初始化 声明：该篇文章中涉及图片，但不知道什么原因，图片复制到文章中后清晰度大大降低，如果影响了大家的查阅，还请见谅。 一、下载 CentOS 镜像 可以在官网下载 CentOS 镜像，但是官网下载速度较慢，我选择使用阿里云来下载，速度较快一些，下载地址： CentOS镜像下载 。点击简介中提供的下载地址。 选择要下载的版本。 往下滑动鼠标，找到 isos 文件夹，点击进入。 选择 x86_64，点击进入。 找到 dvd1.iso 文件点击下载，之后就是漫长的等待，等待镜像下载完毕。 二、新建 CentOS 虚拟机 我使用的工具是 VMware，接下来会演示如何在该工具上新建 CentOS 虚拟机。进入 VMware，点击创建新的虚拟机。 进入新建向导，选择典型方式。当然也会有人选择自定义的方式，可以根据自己的需要进行选择，不过本次演示是按照典型的方式进行的。 选择稍后安装操作系统，点击下一步。 操作系统选择 Linux，版本选择 CentOS 8 64 位，点击下一步。 自定义虚拟机名称和安装位置，选择完毕后点击下一步。 默认的最大磁盘大小为 20 GB，我在此改为了 200 GB，此处只是设置其最大容量，并不是说一定要电脑就有这么空间。我选择将虚拟磁盘存储为单个文件，更好管理。 此时已经简单配置好了虚拟机，可以点击自定义硬件进行更加详细的配置，也可以点击完成，完成虚拟机的创建工作。之后也会有专门的界面对硬件进行配置。在此，我选择直接点击自定义硬件配置相关内容。配置内存，我选择的是 2 GB，这个可以根据自己电脑的配置进行选择，如果你的电脑配置很高，可以适当的提高。 配置处理器数量，同样根据自己的业务需求以及电脑配置进行选择。 配置镜像文件，找到你镜像文件存放的地址，选择下载好的镜像文件。 点击完成，完成虚拟机的创建工作。 三、启动虚拟机，完成初始化 当创建好虚拟机之后，你将会看到如下界面，点击开启虚拟机启动。 语言选择 English 英语，点击 Continue。 键盘和语言我们无需修改，点击 Time &amp; Date 修改时间，改为中国时间。 选择上海即可。 选择 System 下的 Installation Destination 进行分区设置。 Storage Configuration 选择 Custom 自定义，点击 Add a disk 创建分区。 点击 + 号新建分区。 指定分区名和空间大小，点击 Add mount point 完成添加。 大家可以根据自己的需要来自定义分区，分区设置完成后，点击左上角的 Done 完成设置，此时会弹出一个框，选择 Accept 接受即可。 设置网络，点击 System 下的 Network 。 打开网络按钮。 设置 Root 用户的登录密码。 如果需要创建除 root 外的其他用户，可以点击 User Creation 创建。 至此，我们已经完成了所有的配置，点击右下角的 Begin Installation 开始安装。 经过漫长的等待后，终于安装好了，点击 Reboot System 进行重启。 首次启动，需要同意协议，就是我们常遇到的我同意以上协议。 输入登录密码登录。 接下来会有一个欢迎界面，进行一些偏好和隐私设置，可以根据自身情况选择，具体图片就不再展示了。当创建好虚拟器且完成了初始化工作后，我们就可以进行相应的业务开发了。最后，还是想请问下大家，有没有什么方式，可以解决复制图片到 CSDN 文章中清晰度降低的问题，非常感谢。 👉 以上就是文章的全部内容啦，诸佬如果有任何建议都可以提哦。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f78d0eaa6916d5dc4e713a8973e1ed3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/857a1298da3a1e359ca5ebe7a6994f64/" rel="bookmark">
			Windows10安装rdkit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前我尝试使用WIndows10从源码编译安装rdkit，但是尝试了很久都失败了。于是，我又重新尝试使用conda安装。
创建一个新的conda环境，然后运行
conda install -c rdkit rdkit 我的python版本是3.8.13，亲测可以成功安装。
安装完之后，再安装torch，可以参考PyTorch
我的配置是
安装torch后测试，可以使用GPU运算
最后，我们再安装PyG。参考下面的命令就可以顺利安装
Installation — pytorch_geometric documentation
最终，我换了个思路，终于顺利安装成功rdkit和pyg了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/217c3081d1a9889051a5b8b2567b8999/" rel="bookmark">
			JAVA字符串相乘和相除相关算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.main方法简写 psvm public static void main(String[] args) { } 1.保留整数 代码如下（示例）：
public static void main(String[] args) { String a = "122"; String b = String.valueOf(Math.round(Float.valueOf(a) * Float.valueOf(3))); System.out.println("b-----------"+b); } 输出：
b-----------366 2.保留小数 代码如下（示例）：
public static void main(String[] args) { String a = "122"; DecimalFormat df = new DecimalFormat("0.0"); String c = df.format(Float.valueOf(a) / Float.valueOf(3)); System.out.println("c----------"+c); } 输出：
c----------40.7 总结 例如：以上就是今天要讲的内容，本文仅仅简单介绍了java字符串乘除算法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fed24f8745a8c44bf3f7f7bc33b060b2/" rel="bookmark">
			SQL去重的三种方法汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL去重的三种方法汇总
这里的去重是指：查询的时候, 不显示重复，并不是删除表中的重复项
1.distinct去重
注意的点：distinct
只能一列去重，当distinct后跟大于1个参数时，他们之间的关系是&amp;&amp;(逻辑与)关系，只有全部条件相同才会去重
弊端：当查询的字段比较多时，distinct会作用多个字段，导致去重条件增多
select distinct UserResult from Table1
2.group by去重
去重原理：将重复的行进行分组，相同的数据只显示第一行
弊端：使用group by后，所有查询字段都需要使用聚合函数，比较繁琐
select min(UserName)UserName,min(UserSex)UserSex,min(UserSubject)UserSubject,min(UserResult)UserResult from Table1
group by UserResult
3.row_number() over (parttion by 分组列 order by 排序列)
弊端：小孟还不知道
去重原理：现根据重复列进行分组，分组后再进行排序，不同的组序号为1，相同的组序号为2，排除为2的就达到了去重效果
select *from
(
–查询出重复行
select *,row_number() over (partition by UserResult order by UserResult desc)num from Table1
)A
where A.num=1
这里安利第三个，row_number(),稳一些！
先自我介绍一下，小编13年上师交大毕业，曾经在小公司待过，去过华为OPPO等大厂，18年进入阿里，直到现在。深知大多数初中级java工程师，想要升技能，往往是需要自己摸索成长或是报班学习，但对于培训机构动则近万元的学费，着实压力不小。自己不成体系的自学效率很低又漫长，而且容易碰到天花板技术停止不前。因此我收集了一份《java开发全套学习资料》送给大家，初衷也很简单，就是希望帮助到想自学又不知道该从何学起的朋友，同时减轻大家的负担。添加下方名片，即可获取全套学习资料哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09d0e3bd51632d4c218417b3886a4fc0/" rel="bookmark">
			SQL Server如何建表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		–五个约束
–非空 not null
–主键 primary key
–唯一 unique
–检查 check
–默认 default
–主键自增 identity
表约束
主键约束：值不能为null,且不能重复
非空约束：不能为null
默认约束：默认为xx
检查check约束：判断（男和女）
唯一约束：不能重复，可以能为null
–create 创建
–table 表
–建表语句
create table student(
–格式：列名 类型 约束
);
字符全部都是 单引号 ’
或者 or , 并且 and
第一种建表方法： 1.右键《数据库》，新建数据库。 2.取好名称后，点击确定。 3.选择刚刚建好的数据库，点击旁边的小加号展开。 4.右键《表》，新建一个表。 5.填写《列名、数据类型、约束》。 6.填写完成后，按住《Ctrl+s》进行保存，输入好表名称后点击确定。 7.找到刚刚建好的表，没有找到的话，右键《表》点击刷新后可找到。然后右键选择编辑前200行。 8.然后里面就可以输入你想要的内容了。 第二种建表方法： **1.**右键之前建好的《数据库》，选择新建查询。 2.以下就是代码格式，《列名、类型、约束》，注意：代码全部使用英文输入，每行结束后必须打上逗号（,）注意是英文的，最后一行结束不需要逗号（,）。图二注意：一定要选择好你建好的《数据库》。 3**.点击执行后，显示图二上的内容后表示执行成功。** 4.右键刚刚保存的表，选择编辑前200行，没有找到的，右键《表》点击刷新可找到。 5.因为我刚刚代码上写的是约束是主键和主键自增，所以sid可以不用填，它会自己增加1，我们直接填写name（姓名）和sex（性别）即可。注意：sex我们设置的是检查约束，检查的是男或女，所以只能填写男或女，其他会报错。 以上便是SQL Server两种建表流程。 先自我介绍一下，小编13年上师交大毕业，曾经在小公司待过，去过华为OPPO等大厂，18年进入阿里，直到现在。深知大多数初中级java工程师，想要升技能，往往是需要自己摸索成长或是报班学习，但对于培训机构动则近万元的学费，着实压力不小。自己不成体系的自学效率很低又漫长，而且容易碰到天花板技术停止不前。因此我收集了一份《java开发全套学习资料》送给大家，初衷也很简单，就是希望帮助到想自学又不知道该从何学起的朋友，同时减轻大家的负担。添加下方名片，即可获取全套学习资料哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf7d64166337f2b72b8e0a4593a108a3/" rel="bookmark">
			如何修复 TrustManager 实施方式不安全的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/*问题描述：*/ googleplay已上架的应用收到安全警示或版本更新时遭拒绝更新，但是不会因此强制下架应用，此漏洞其违反了google开发者协议第4.4的相关规定。 /*问题难易度*/ * * * /*导致问题的原因*/
自定义接口X509TrustManager中
public void checkServerTrusted(X509Certificate[] chain,String authType) throws java.security.cert.CertificateException {}方法中默认允许了所有的证书。
/*问题解决方法*/
1.有很多实际项目中会运用到多个第三方SDK，而遇到这个问题大多自己的代码中全局搜索并不会搜索到自定义 X509TrustManager 接口的 checkServerTrusted方法。问题就在于第三方的jar中，我不能确定问题到底存在于哪个SDK中所以我用了最笨的方法逐个排查删除jar包和逐个替换更新，每排除一个就上传一次就这样我被拒绝更新了三次。
2.本人遇到中Mob的ShareSDK 版本V2.7.4以下版本 而ShareSDK 官方更新文档中也明确注明了修复了此问题这个版本的发布日期：2016-07-11
http://wiki.mob.com/sharesdk-android-%E6%9B%B4%E6%96%B0%E5%8E%86%E5%8F%B2/
3.图灵机器人涉及的包为 tulingSDK1.x.jar tulinghttp1.0.jar而早些版本为tulingmanager.jar
4.百度语音合成（TTS）com.baidu.speechsynthesizer_1.0.0.jar
5.举例更新ShareSDK
(1)下载最新版本的ShareSDK ShareSDK-Android-2.7.x
(2)进入ShareSDK解压目录，打开“Share SDK for Android”目录，找到“QuickIntegrater.jar” 重新输入包名生成项目的替换文件。
(3)从生成好的项目包中的四个文件夹assets,libs,res,src到自己项目中对应的文件逐个Remove并替换。
6.问题代码段 SSLContext sslContext = SSLContext.getInstance("TLS"); public SSLSocketFactoryEx(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException { super(truststore); TrustManager tm = new X509TrustManager() { public X509Certificate[] getAcceptedIssuers() { return null; } @Override
public void checkClientTrusted(X509Certificate[] chain, String authType) throws java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf7d64166337f2b72b8e0a4593a108a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38fe03b83492871a694474c85d765a07/" rel="bookmark">
			C&#43;&#43; 静态库、动态库制作和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、C++ 静态库1、静态库的命名规则2、静态库的制作过程3、静态库的使用 二、动态库1、动态库命名规则2、动态库制作过程3、动态库的使用4、动态库的加载5、配置环境变量 总结 前言 库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数和类。
库是一种特殊的程序，编写库和编写一般程序差别不大，只是库不能单独运行
库文件有两种，一种是动态库(共享库，dll) 一种是静态库（lib），都在链接阶段加入到可执行文件中，区别在于：静态库在程序链接阶段静态库文件内容被复制到程序中，动态库在程序链接阶段没有复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。静态中不能再包含其他的静态库和动态库，动态库可以包含其他的动态库和静态库。调用动态库中的函数时，根据函数映射表找到该函数并存入堆栈中，如果程序（也可以是其他程序）对同一函数有多处调用，执行时，这个函数只会有一份拷贝，静态库中的函数有多处调用会保存多个拷贝。
库的好处：1、代码保密，2、方便部署和分发。
一、C++ 静态库 1、静态库的命名规则 Linux：libxxx.a。lib为前缀，是固定的；xxx是自己起的库的名字；.a为后缀是固定的。Windows：libxxx.lib 2、静态库的制作过程 gcc -c 编译获得.o文件;将.o文件打包，使用ar（archive）工具 打包命令：
ar rcs libxxx.a xx.o xx.o
r - 将文件插入备存文件
c - 建立备存文件
s - 索引
3、静态库的使用 通过使用头文件建立函的声明，在编译主函数时，使用以下命令
gcc -o app main.c -I ./头文件路径 -l 静态库名 -L ./静态库路径 二、动态库 1、动态库命名规则 Linux：libxxx.so。lib为前缀，是固定的；xxx是自己起的库的名字；.so为后缀是固定的。Windows：libxxx.dll 2、动态库制作过程 gcc -c 编译获得.o文件，得到和位置无关的代码，这将改变编译器生成特定操作的代码的方式，包括变量（全局、静态）、常量的访问以及获取函数的地址，这些改变可以让代码运行时放置到任意一个虚拟地址处。动态库在链接阶段不会打包到可执行程序中，而是把动态库的一些信息加载到可执行文件中。
gcc -c -fpic/fPIC xx.c xxx.c得到动态库
gcc -shared xx.o xxx.o -o libxxx.so 3、动态库的使用 通过使用头文件建立函的声明，在编译主函数时，使用以下命令
gcc -o app main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38fe03b83492871a694474c85d765a07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e39fbf266880e38e088d2d3312b7ea8/" rel="bookmark">
			PostMan测试接口-----上传文件、导出excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PostMan测试接口实现如下功能：
（1）上传文件
（2）导出excel
一、PostMan测试接口实现上传文件 当测试接口需要上传文件时，我们依然可以借助Postman。
1.接口地址填写正确
2.将接口请求方式设置为Post
3.设置Headers
Content-Type:multipart/form-data
4.Body选择form-data
5.key右侧下拉选择file,value点击Select Files 选择要上传的文件
6.点击Send发送请求
二、PostMan测试接口实现导出excel文件 最近有导出Excel的接口要测试，而且项目加了权限不方便在浏览器直接测试后端接口，于是在postman上测试导出Excel方法，直接点击Send按钮会生成一堆乱码：
后来折腾了一会，发现Send按钮还有一个下拉选项Send and Download，点击这个问题就解决了：
点击 Send and Download 按钮，
然后选择Excel文件保存的位置：
点击保存即可！！！
先自我介绍一下，小编13年上师交大毕业，曾经在小公司待过，去过华为OPPO等大厂，18年进入阿里，直到现在。深知大多数初中级java工程师，想要升技能，往往是需要自己摸索成长或是报班学习，但对于培训机构动则近万元的学费，着实压力不小。自己不成体系的自学效率很低又漫长，而且容易碰到天花板技术停止不前。因此我收集了一份《java开发全套学习资料》送给大家，初衷也很简单，就是希望帮助到想自学又不知道该从何学起的朋友，同时减轻大家的负担。添加下方名片，即可获取全套学习资料哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/407d2e9cb8f3a2717ef605187e405840/" rel="bookmark">
			Mac M1 goland无法调试 Failed to launch: could not launch process: EOF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装步骤：
1、官网安装arm64版本golang；
确保这个选项正确：GOARCH=arm64
2、官网安装支持m1的goland版本
这里选择最新版本的安装即可
3、安装arm64版本dlv
&gt;&gt; git clone https://github.com/go-delve/delve &gt;&gt; cd delve &gt;&gt; go install github.com/go-delve/delve/cmd/dlv &gt;&gt;&gt; dlv version &gt;&gt; cd $GOPATH/bin &gt;&gt; mkdir macarm &gt;&gt; cp dlv macarm 打开goland，配置dlv的执行路径： 选 help&gt;&gt;Edit Custom Properties
# custom GoLand properties (expand/override 'bin/idea.properties') dlv.path=$(你的GOPATH)/bin 问题产生：debug报错提示 Failed to launch: could not launch process: EOF
原因：从Mac Pro直接迁移了开发环境到Mac M1，里面的Command Line Tool Tools工具不匹配
解决办法：
删除本地的 Library:
$ sudo rm -rf /Library/Developer/CommandLineTools 然后安装 https://developer.apple.com/download/more/ 下载最新的稳定版: Command_Line_Tools_for_Xcode_13.2.dmg。这当中的过程是先删除、再重启、再安装。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/407d2e9cb8f3a2717ef605187e405840/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95629a84870192b38e604511668b1936/" rel="bookmark">
			mybatis插入数据，返回新增数据的id值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、自增主键情况下插入数据获取自增主键值 mybatis为我们提供了一个方法，能够插入数据时获取自动生成的值，并且把取的值赋值给实体类的某一属性
设置方法：
要求：主键必须是自增的
&lt;insert id = "insert" useGeneratedKeys = "true" keyProperty = "id"&gt; SQL语句 &lt;/insert&gt; useGeneratedKeys = true　//是否返回自增主键值
keyProperty = “xxx”　//将值赋给哪个属性，这个属性是方法参数中的
此时就是插入数据的实体类点.getId()可以得到
2、主键非自增的情况下获取主键值 一般我们使用来实现。一个块中只能有一个
下面我们了解一下selectKey中的属性
resultType：这个我们就不用解释了，返回类型
order：它有两个取值：1、BEFORE在添加之前查询　2、AFTER在添加之后查询　//这两个都是全大写
keyProperty：将取值赋值给方法参数，如果方法参数是实体类，一般赋值给实体类的字段
keyColumn：对应表的列名
一个selectKey中必须要有 resultType，order，keyProperty
after示例：查询最后一次添加的主键
&lt;insert id = "insertEmp"&gt; &lt;selectKey resultType = "integer" order = "AFTER" keyProperty = "eid" &gt; select last_insert_id() //查询最后一次添加的主键,mysql函数 &lt;/selectKey&gt; insert into dept(id,deptname) values(#{id},#{deptname}) &lt;/insert&gt; before示例：假设Id不是自增长，我们希望在insert之前获取mysql的UUID添加到数据表作为主键Id
&lt;insert id = "insertDept"&gt; &lt;selectKey resultType = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95629a84870192b38e604511668b1936/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf1b7f8693e16f946c7d5c2b7f15ba67/" rel="bookmark">
			什么是跨域？什么是同源策略？如何解决Ajax跨域问题？什么是JSONP？JSONP怎么请求数据？什么是Proxy？Proxy怎么请求数据？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跨域 什么是跨域？ 跨域就是指浏览器不能执行其他网站的脚本。这是由浏览器的同源策略造成的，是浏览器对javascript施加的安全限制
浏览器为了用户的信息安全，网页中有一个网络请求技术：AJAX 在网络请求时 请求的网址 和当前页面的网址不是同一台服务器就会被拒绝接受服务器发送的数据
例如：a页面想获取b页面资源，如果a、b页面的协议或域名或端口或子域名不同，只要有其中一项不同，那么所进行的访问行动都是跨域的，而浏览器为了安全问题一般都限制了跨域访问，也就是不允许跨域请求资源
注意：跨域限制访问，其实是浏览器的限制，这一点很重要
什么是同源策略？ 同源策略：指协议，域名（ip），端口（port）三者都要相同代表同源，只要有其中一个不同就会产生跨域
注意：网址中的pathname参数并不参与同源判断
例如： 同源 https://www.baidu.com/index.html
https://www.baidu.com/home
异源（协议不一样） http://www.baidu.com/index.html
https://www.baidu.com/ajax
异源（端口(port)不一样） http://www.baidu.com/index.html
http://www.baidu.cn/ajax
异源（域名(IP)不一样） http://www.baidu.com/index.html
http://www.sina.com/index.html
同源 这个虽然看着似乎不一样，但是经过DNS解析后，域名和IP就是一样的，所以也是同源的
端口号随便写的
baidu的DNS解析为 119.75.217.109:8080
http://www.baidu.com/index.html
http://119.75.217.109:8080/ajax
如何解决Ajax跨域问题？ 我们只需要在头部加一行下列的代码，即可解决这个问题
res.setHeader("Access-Control-Allow-Origin","*")
router是自己封装的一个函数，用来做网络请求读取文件的，没有封装这种类似功能的函数就需要自己先去写一下，http网络请求，fs模块读取文件
实例 var router=require("./router.js") router.get("/ajax1",function(req,res){ res.setHeader("Access-Control-Allow-Origin","*") res.end('{"name":"karen",age:20}') }) &lt;body&gt; &lt;h1&gt;成都&lt;/h1&gt; &lt;button onclick="fn()"&gt;跨域ajax请求&lt;/button&gt; &lt;script&gt; function fn(){ var xhr=new XMLHttpRequest() xhr.open("get","http://192.168.43.132:8080/ajax1") xhr.send() xhr.onreadystatechange=function(){ if(xhr.readyState==4&amp;&amp;xhr.status==200){ console.log(xhr.responseText) } } }	&lt;/script&gt; &lt;/body&gt; 什么是JSONP？ JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题
由于同源策略，一般来说位于非同一服务器的的网页是无法相互沟通的，而 HTML 的&lt;script&gt;元素是一个例外
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf1b7f8693e16f946c7d5c2b7f15ba67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/656a58d7d1ccf4fb419e6928fa5e9dc5/" rel="bookmark">
			[详解C语言]一文带你玩转C语言小游戏---扫雷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：大家好我是zoroxs 📃个人主页：c/c++学习之路
🔥💖如果觉得博主的文章还不错的话，请👍三连支持一下博主哦
扫雷小游戏 ✅作者简介：大家好我是zoroxs📕1.游戏整体思路📗2.扫雷双雷盘设计📘3.往棋盘中放雷📙4.扫雷📓5.判断成败📔6.测试函数编写📒7.代码拼接7.1📄game.h7.2📃game.c7.3📑test.c 📚8.总结 C语言能写很多的小游戏，可以很好地加深我们对学过知识的印象，更可以增加我们对学习的兴趣。 上次带大家写了一个三子棋，今天带大家再来写一个人人皆知的扫雷，这游戏，反正从小到大我是一局都没赢过，今天我们就用C语言来实现小时候特别爱玩的游戏 📕1.游戏整体思路 打印雷盘往雷盘中放置雷接受用户输入坐标，扫雷_判断是否踩到雷，踩到雷----&gt;恭喜他被炸死， _没踩雷，在对应位置显示周围有几颗雷直到踩雷或者所有非雷位置都被走过，游戏结束 📗2.扫雷双雷盘设计 很关键的地方在于雷盘的设计，我们假设要99的雷盘，那我们要存储雷还有用户是否排过，周围又有几个雷，用一个99的二维数组可以实现。
给大家提供一个崭新的思路，
我们这里使用两个同样的二维数组来存储:
一个存储雷的位置，有雷是1，无雷是0，
_另一个当成展示雷盘，没扫过就是*，扫过就显示周围有几颗雷的数字_**
像这种靠墙壁的，计算它周围有几颗雷比较复杂，我们这里有一个妙手。
_我们如果要用9*9的雷盘，就弄成11*11的数组，我们展示的时候只展示9*9就可以了，这样每一个墙壁周围都有一层格子，极大方便了我们的计算。_
我们需要两个函数来帮我们实现一下棋盘，大家看之前的三子棋就知道，初始化，打印，必备
我们来看一下声明，这里需要注意的是，我们要初始化两个雷盘，初始化的字符不一样，所以参数需要把初始化的字符传进去
//初始化雷盘 void init_board(char board[ROWS][COLS], int row, int col, char ch); //打印雷盘 void display_board(char board[ROWS][COLS], int row, int col); 我们来看一下代码实现
//初始化雷盘 void init_board(char board[ROWS][COLS], int row, int col, char ch) { int i = 0; int j = 0; for (i = 0; i &lt; row; i++) { for (j = 0; j &lt; col; j++) { board[i][j] = ch; } } } void display_board(char board[ROWS][COLS], int row, int col) { int i = 0; int j = 0; //打印行号 for (i = 0; i &lt;= row; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/656a58d7d1ccf4fb419e6928fa5e9dc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caff040ba380eb65a8db3d494c7efda1/" rel="bookmark">
			51单片机外设篇：DS18B20
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		温度传感器 测温度的方式：物理（汞柱、气压）、电子（金属电性能随温度变化）
早期：热敏电阻（模拟接口）
现代：专用sensor（数字接口，如I2C、DS18B20的单总线接口等）
DS18B20是一种常见的数字温度传感器，其控制命令和数据都是以数字信号的方式输入输出，相比较于模拟温度传感器，具有功能强大、硬件简单、易扩展、抗干扰性强等特点。
测温范围：-55°C 到 +125°C
通信接口：1-Wire（单总线）
其它特征：可形成总线结构、内置温度报警功能、可寄生供电。
引脚及应用电路：
单总线（1-Wire BUS）是由Dallas公司开发的一种通用数据总线：
一根通信线：DQ，异步、半双工
单总线只需要一根通信线即可实现数据的双向传输，当采用寄生供电时，还可以省去设备的VDD线路，此时，供电加通信只需要DQ和GND两根线。
DS18B20的基本特征
内置集成ADC，外部数字接口单总线数字接口，布线成本低温度范围宽、精确率高（相对）数字值温度分辨率位数可软件设置温度阈值报警功能，且阈值可内置存储掉电不丢失温度采集速度快（750ms）内置唯一64位序列码，CPU可以单线串联无限多个DS18B20支持VDD供电，或通过数据总线及内部电容实现寄生电源供电 综合评价：
DS18B20是很多年前的东西了
现在趋向于温度+湿度的综合传感器
现实应用一般低端用热敏电阻、热电偶，高端用精密传感器
学习重点和难点是单总线协议的时序编程实现
注意18B20直接读出绝对温度值不需要参考点。
单总线协议 首先搞清楚你的系统是单点还是多点DS18B20规定总线上的数据是LSB的（一个字节是从最低位开始传输的）单总线硬件连接要求：漏极开路式+5K欧姆的上拉电阻（见上方的图）总线低电平超过480us，从设备将被复位 1-Wire总线系统即一个总线主设备控制一个或多个从设备。DS18B20始终是一个从设备。当总线上只有一个从设备时，此系统被称为“单节点”系统；当总线上有多个从设备连接时，此系统被称之为“多节点”系统。
1-Wire总线上所有的命令或者数据的发送接收都是遵循低位先发送的原则。
单总线协议标准执行步骤
主机必须按照单总线协议设定好的完整序列和DS18B20通信，每个回合包含3个步骤：初始化+ROM操作指令+功能操作指令。顺序不能错也不能省略任何一个。
DS18B20自己本身不会主动去进行温度测量，而是需要主控CPU主动发起一个温度转换的过程，这么设计是因为温度转换本身是要耗电的，所以设计为平时待机等待温度转换命令后才去进行温度AD转换。
主控CPU和DS18B20之间的通信是分周期的，譬如我们要让DS18B20进行温度转换就是一个周期。这个周期包含一个初始化+N个命令。（每个周期的开始都要有一个初始化，然后跟着N个命令）
初始化过程主要是探测目标DS18B20是否存在，若存在将芯片初始化。
命令很重要。所以DS18B20是一个典型的“命令-响应”型外设。学习这种外设的关键是命令集。
ROM操作指令
DS18B20支持多个芯片串联在一根总线上，也就是所谓的单总线协议，所以必须要主控CPU要能够区分总线上多个18B20，因此有个ROM操作指令来完成这个任务。
ROM操作指令和温度采集一点关系都没有，所以当我们总线上只有一个18B20的时候ROM操作指令我们不需要去管。
一旦系统中单总线上有多个18B20，那么我们必须借助ROM操作指令来区分多个18B20，而且这个区分过程可能需要多条ROM指令来完成。
如果系统中只有一个18B20，那么就用一条skip rom命令（0xCC）就可以跳过这个阶段。
功能指令
ROM操作指令目的是为了在单总线上多个18B20中挑选到那个当前我们要操作的18B20，而功能指令是为了和选定的18B20通信从而获取温度。
初始化：
初始化就是：主设备先拉低数据总线超过480us以发出一个复位脉冲，然后从设备DS18B20收到复位脉冲后内部进行硬件复位，复位完成后回复主设备一个存在脉冲，主设备收到了存在脉冲后就认为从设备已经准备好，初始化完成。（确认设备存在）
ROM命令
当总线上的主设备检测到了存在脉冲后，就可以执行ROM命令。这些命令是对每个设备独一无二的64位ROM编码进行操作的，当总线上连接有多个设备时，可以通过这些命令识别各个设备。这些命令同时也可以使主设备确定该总线上有多少个什么类型的设备或者有温度报警信号的设备。总共包含有5种ROM命令，每个命令的长度都是8 Bit。主设备在执行DS18B20功能命令之前必须先执行一个适当的ROM命令。（找到具体的设备）
DS18B20功能命令
当总线上的主设备通过ROM命令确定了哪个DS18B20能够进行通信时，主设备可以向其中一个DS18B20发送功能命令。这些命令使得主设备可以向DS18B20的暂存寄存器写入或者读出数据，初始化温度转换及定义供电模式。（具体的操作）
DS18B20 详见：DS18B20数据手册-中文版 - 知乎
DS18B20采用严谨的1-Wire总线通信协议来保证数据的完整性。该协议定义多个信号形式：复位脉冲，存在脉冲，写0，写1，读0，读1。主设备执行除了存在脉冲外的所有其他信号。
初始化程序—复位和存在脉冲
与DS18B20所有的通信都是由初始化序列开始的，该序列包括从主设备发出的复位脉冲及从DS18B20响应的存在脉冲组成。当DS18B20响应复位信号的存在脉冲后，则其向主设备表明其在该总线上，并且已经做好操作命令。
在初始化序列期间，总线上的主设备通过拉低1-Wire总线超过480us来发送（TX）复位脉冲。之后主设备释放总线而进入接收模式（RX）。当总线释放后，5kΩ左右的上拉电阻将1-Wire总线拉至高电平。当DS18B20检测到该上升边沿信号后，其等待15us至60us后通过将1-Wire总线拉低60us至240us来实现发送一个存在脉冲。
读/写时段
主设备通过写时段向DS18B20中写入数据，通过读时段从DS18B20中读取数据。1-Wire总线上每一个读写时段只能传送一个位的数据。
写时段
写时段有两种情况：“写1”时段和“写0”时段。主设备通过写1时段来向DS18B20中写入逻辑1以及通过写0时段来向DS18B20中写入逻辑0。每个写时段最小必须有60us的持续时间且独立的写时段间至少有1us的恢复时间。两个写时段都是由主设备通过将1-Wire总线拉低来进行初始化。
为了形成写1时段，在将1-Wire总线拉低后，主设备必须在15us之内释放总线。当总线释放后，5kΩ的上拉电阻将总线拉至高。为了形成写0时段，在将1-Wire总线拉低后，在整个时段期间主设备必须一直拉低总线（至少60us）。
在主设备初始化写时段后，DS18B20将会在15us至60us的时间窗口内对总线进行采样。如果总线在采样窗口期间是高电平，则逻辑1被写入DS18B20；若总线是低电平，则逻辑0被写入DS18B20。
读时段
仅在读时段期间DS18B20才能向主设备传送数据。因此，主设备在执行完读暂存寄存器[BEh]或读取供电模式[B4h]后，必须及时地生成读时段，这样DS18B20才能提供所需的数据。此外，主设备可以在执行完转换温度[44h]或拷贝EEPROM[B8h]命令后生成读时段，以便获得DS18B20功能命令的操作信息。
每个读时段最小必须有60us的持续时间且独立的写时段间至少有1us的恢复时间。读时段通过主设备将总线拉低超过1us再释放总线来实现初始化。当主设备初始化完读时段后，DS18B20将会向总线发送0或者1。DS18B20通过将总线拉至高来发送逻辑1，将总线拉至低来发送逻辑0。当发送完0后，DS18B20将会释放总线，则通过上拉电阻该总线将会恢复到高电平的闲置状态。从DS18B20中输出的数据在初始化读时序后仅有15us的有效时间。因此，主设备在开始改读时段后的15us之内必须释放总线，并且对总线进行采样。
代码实现 #include "ds18b20.h" #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caff040ba380eb65a8db3d494c7efda1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e8384aa15877cd1398993a3473d66d1/" rel="bookmark">
			json schema实际运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 根据实际需求，发现前后端都需要对数据进行校验，且校验字段较多。为避免在代码中加入繁琐的判断，且能前后端保持统一标准，我们使用JSON schema规范来进行数据的校验。
二、JSON Schema 2.1 定义 json-schema 中文意思是 JSON的模式。定义一个JSON的规范，对数据的格式进行约束。比如数据的类型，数字number，字符串 string, 对象Object；数字的大小和区间范围；是否要求必填等等；
2.2 例子 2.2.1 要求 如下是一个校验字段fieldA，fieldB,fieldC的样例。我们要求fieldA是字符串，且值为testString；fieldB是数字类型，大于0(不等于0)；三个字段为必填字段。
{ "type": "object", "properties": { "fieldA": { "type": "string", "enum": [ "testString" ] }, "fieldB": { "type": "number", "exclusiveMinimum": 0 } }, "required": [ "fieldA", "fieldB", "fieldC" ] } 2.2.2 待验证数据 { "fieldA": "test", "fieldB": 0 } 2.2.3 验证 在线验证地址 https://jsonschemalint.com/#!/version/draft-07/markup/json
2.3 版本 json schema 存在多个版本，当前最新版本为draft-07。 不同版本之间规范也不同。部分实现json schema框架默认draft4，可能大家使用过程中会造成麻烦。为了统一规范，可以在后续实现中，显式设置版本号。当然也可是每条检验规范显示设置一个版本号，不过那样太麻烦了。
版本exclusiveMaximumexclusiveMaximumdraft-04取值为 true false,与minimum结合使用，举例 a&gt;0,则exclusiveMaximum: true, minimum:0取值为 true false,与maximum结合使用，举例 a&lt;0,则exclusiveMaximum: true, maximum:0draft-07数字，举例 a&gt;0,则exclusiveMinimum : 0数字，举例 a&lt;0,则exclusiveMaximum: 0 三、实现 第二部分只是定义了一个规范，现在讲述一下如何实现。虽然JSON schema是脱离语言的，但是实现还是跟语言相关的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e8384aa15877cd1398993a3473d66d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40f3723270f82a58a28a56d25b861876/" rel="bookmark">
			[h264 @ 0x1f5690] error while decoding MB 91 56, bytestream -5（未解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RV1126下，用C++ opencv 打开rtsp视频流获取图像帧 程序执行一段时间后，程序报错，获取到的图像帧为空，报错信息如下：
[h264 @ 0x1f5690] cabac decode of qscale diff failed at 91 56
[h264 @ 0x1f5690] error while decoding MB 91 56, bytestream -5 目前还没有找到解决办法，只能在每次图像帧为空时，重新打开视频流
if(cur_frame.empty()){ coutRed("[ERROR][detection.cpp][detectYolov5RknnUchar] The frame is empty."); // break; sprintf(info, "[INFO][detection.cpp][detectYolov5RknnUchar] Reopening %s ......", rtsp_url.c_str()); coutGreen(info); capture.open(rtsp_url); if(!capture.isOpened()){ coutRed("[ERROR][detection.cpp][detectYolov5RknnUchar] Failed to open the rtsp video stream: " + rtsp_url); return "ERROR"; } continue; } 有好的解决方法的大佬求教……
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1d5e12a50bfd87cc9a7eee8098bfecf/" rel="bookmark">
			虚拟机使用scp传输文件密码错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两台虚拟机使用scp传输文件夹出密码错误如下：
但保证此时密码是正确的！
尝试使用sftp问题顺利解决
sftp 传输虚拟机目录（例如：sftp root@192.168.0.0） cd 进入目的目录下 put -r 传输文件地址 具体参考：
https://linuxize.com/post/how-to-use-linux-sftp-command-to-transfer-files/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2053544e6239acc43e94a9ba224adb2/" rel="bookmark">
			PIL篇---python 实现PIL模块在图片画线写字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python 实现PIL模块在图片画线写字 from PIL import Image, ImageDraw, ImageFont # get an image base = Image.open('2022-07-19-09-48-05.jpeg').convert('RGBA') # make a blank image for the text, initialized to transparent text color txt = Image.new('RGBA', base.size, (255,255,255,0)) # get a font 需要在C:\Windows\Fonts拷贝一份字体文件 当前脚本路径下 fnt = ImageFont.truetype('simhei.ttf', 40) # get a drawing context d = ImageDraw.Draw(txt) # 需要修改 box的位置 box = tuple((1203,694,1339,867)) d.rectangle(box, fill=None, outline="red", width=5) # draw text, half opacity (255,0,255,255) 其中（255，0，255）是颜色，最后的255 是深浅 d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2053544e6239acc43e94a9ba224adb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43f8218d138eba816ad93b24fa637289/" rel="bookmark">
			java.lang.ClassNotFoundException com.microsoft.sqlserver.jdbc.SQLServerDriver问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在java连接数据库时，遇到“java.lang.ClassNotFoundException:com.microsoft.sqlserver.
jdbc.SQLServerDriver”问题，网上找了许多方法，最终解决。
1. 下载驱动jar包
由于使用的是SQL Server 2016，网上找的jar包都是旧版本的，找了很久才找到sqljdbc42.zip；
适用SQLServer2016版本的数据库加载驱动包-SQLServer文档类资源-CSDN下载
2. 开启Telnet服务
打开控制面板，点击程序和功能，之后点击启用或关闭Windows功能，勾选Telnet客户端
3. 导入刚刚的sqljdbc42.jar包
1）复制到WEB-INF&gt;lib下面，没有lib的新建一个；
2）点击Add as Library；
3） 重新启动运行，会发现已经可以了。
先自我介绍一下，小编13年上师交大毕业，曾经在小公司待过，去过华为OPPO等大厂，18年进入阿里，直到现在。深知大多数初中级java工程师，想要升技能，往往是需要自己摸索成长或是报班学习，但对于培训机构动则近万元的学费，着实压力不小。自己不成体系的自学效率很低又漫长，而且容易碰到天花板技术停止不前。因此我收集了一份《java开发全套学习资料》送给大家，初衷也很简单，就是希望帮助到想自学又不知道该从何学起的朋友，同时减轻大家的负担。添加下方名片，即可获取全套学习资料哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18cea0ace2598f6e108d646f5cd5d14f/" rel="bookmark">
			E8前端相关知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		E8前端标签积累收集 页面通用标签 引入标准jsp标签页引入产品标准功能代码铺助脚本控件浏览按钮布局控件必填校验下拉组件编辑表格与分页表格报表弹出框组件右键菜单weaverTree树形组件 日期控件开关组件菜单的点击事件 页面通用标签 &lt;!--指定页面编码--&gt; &lt;%@ page language="java" contentType="text/html; charset=UTF-8" %&gt; &lt;!--引入相关的包类--&gt; &lt;%@ page import="weaver.general.Util,weaver.hrm.common.*,weaver.conn.*" %&gt; &lt;!--引入表单标签--&gt; &lt;%@ taglib uri="/WEB-INF/weaver.tld" prefix="wea"%&gt; &lt;%@ taglib uri="/browserTag" prefix="brow"%&gt; &lt;!--引入浏览按钮标签--&gt; &lt;%@ taglib uri="/WEB-INF/tld/browser.tld" prefix=“brow”%&gt; 引入标准jsp标签页 /** 高级搜索 **/ &lt;script language=javascript src="/js/ecology8/docs/docSearchInit_wev8.js"&gt;&lt;/script&gt; /** 右键菜单 **/ &lt;%@ include file="/systeminfo/RightClickMenuConent_wev8.jsp" %&gt; /**暂时不知道有什么作用**/ &lt;%@ include file="/systeminfo/RightClickMenu_wev8.jsp" %&gt; /**页面功能控制权限**/ &lt;%@ include file="/systeminfo/init.jsp" %&gt; &lt;!--引入系统页面，用于判断是否登录，以及获取user对象--&gt; &lt;%@ include file="/systeminfo/init_wev8.jsp" %&gt; 引入产品标准功能代码 &lt;% //判断是否有对应的权限，有则显示该菜单 if(HrmUserVarify.checkUserRight("HrmCountriesAdd:Add", user)){ RCMenu += "{"+SystemEnv.getHtmlLabelName(82,user.getLanguage())+",javascript:doAdd();,_self} " ; /*标签显示菜单名，如 82 为新增*/ RCMenuHeight += RCMenuHeightStep; } %&gt; /*多语言标签 */ &lt;%=SystemEnv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18cea0ace2598f6e108d646f5cd5d14f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/397f274d4b6b35c336d2a77ec2c5b9d3/" rel="bookmark">
			crontab执行定时任务报错的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景：一个sh脚本，手动执行是正常的，但是只要crontab启动就会提示java版本不匹配（Unsupported major.minor version 52.0）。所有的文件都是用了绝对路径还是不行，猜测是crontab执行java -jar时候，没有检测到环境变量。
于是在sh脚本的前面协商如下：
#!/bin/sh . /etc/profile . ~/.bash_profile 定时任务执行成功！那就是说明crontab不会默认的去读取该用户的环境变量，配置好即可。
#通常用作注释，但是#!放在一起就标志着这是一个shell script，其后的路径指出了用来解释这个script的程序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/883db0f23fa79931b31553c318f825b6/" rel="bookmark">
			c&#43;&#43;debug 调试，当前不会命中断点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里只针对几个方面的问题进行讨论.
vscode调试在某种层面上确实是比较麻烦的一种debug。
通常来说，debug当前不会命中断点有两种提示：
1.还未为文档加载任何符号
2.源代码与原始版本不同
在这里我们注重记录一下对于断点还未为文档加载任何符号这个问题的解决。
检查VS的调试模式。VS的调试分为两种，Debug和Release。Debug是专门真对检查程序的bug而设置的一种模式。Release模式对程序的编译进行了优化，一般用于程序发布。
首先我们需要在工具-&gt;选项内将两个选项关闭：
1.仅我的代码取消选中
2.要求源文件原始版本完全匹配
另外我们需要着重配置项目的一些c++优化以及链接器的配置
1.右击项目点击属性-&gt;配置属性-&gt;c/c++ -&gt;常规 将调试信息格式修改为程序数据库
2.右击项目点击属性-&gt;配置属性-&gt;c/c++ -&gt;优化将优化改为禁用，这里主要针对release的调试，因为对于release编译器会自动将其设置为最大化速度进行编译
3.最后右击项目点击属性-&gt;配置属性-&gt;链接器 -&gt;调试 调试内的生成调试信息改为是（/debug）
这样才能输出调试信息
设置结束后，可以运行打断点尝试一下，有一说一，在做调试前一定要做好这些前提工作，不然编译器真的很坑。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50368297b319b73ce6e29415b965cf0f/" rel="bookmark">
			用C语言来实现五子棋小游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、五子棋的准备工作
二、五子棋的具体实现
1.棋盘
2.人机对战
2.1 玩家下棋
2.2 电脑下棋
2.3 判断输赢
三、总结
一、五子棋的准备工作 我们在写一个项目的时候，首先第一步就是应该规划一个项目应该有哪些文件，然而五子棋的代码逻辑比较简单，这里我就分了三个文件来写：
game.h(这个文件用来存储头文件和函数的声明)， game.c(这个文件用来存储具体的实现代码)， test.c(这个文件用来测试我们的代码) 第二步就是规划一个项目应该有哪些功能或者说有哪些机制，比如说五子棋，他可能就有人机对战，玩家下一步，电脑下一步，判断棋盘有没有一片区域是连成一块的，这些都是我们要考虑到的，并且把他们一个个封装成函数，整个逻辑就可以运行起来，下面是具体要实现的一些功能的函数并且还有相应的头文件，我都放到game.h里面了
#pragma once #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; //棋盘的长度和宽度 #define ROW 5 #define COL 5 //初始化 void board_init(char arr[ROW][COL], int row, int col); //打印 void board_display(char arr[ROW][COL], int row, int col); //玩家下棋 void player_move(char arr[ROW][COL], int row, int col); //电脑下棋 computer_move(char arr[ROW][COL], int row, int col); //判断是否赢了 char is_win(char arr[ROW][COL], int row, int col); 二、五子棋的具体实现 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50368297b319b73ce6e29415b965cf0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1669a0d39503c1bf25946ef290e319a/" rel="bookmark">
			postgresql数据库结合django设置日期时间默认当前时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Django模型来创建PostgreSQL-DB。创建时间字段设置datetime类型，在其中设置当前时间作为默认值。但是，当在Django之外检查数据库时，默认的时间戳并没有出现。因为，django设置的日期时间默认值是针对ORM模型的，而不是直接对应的数据库，无论我们设djangomodel层中把创建时间的字段类型默认值设置成auto_now_add=True或default=timezone.now都是不起作用的，如果postgresql不使用ORM模型来进行数据的插入或查询是不起作用的，比如GraphQL查询，它是数据库层面的查询，不管是创建、修改或者查询，数据库中创建时间的字段是没有默认值的，所以插入数据的时候创建时间是没有默认值的，但我们的数据库表是通过django的model层创建生成的，这种情况下我们需要通过一些特殊的方式进行解决。
先创建一个空的数据迁移文件并手动更改表。使用以下方法初始化数据迁移：
python manage.py makemigrations --empty app_name 更改生成的文件并使用以下命令指定默认值：
# Generated by Django 3.2.11 on 2022-08-01 10:48 from django.db import migrations class Migration(migrations.Migration): dependencies = [ ('app_name', 'migration_name'), ] operations = [ migrations.RunSQL( 'ALTER TABLE table_name ALTER COLUMN created_at SET DEFAULT CURRENT_TIMESTAMP'; ) ] 这样做的好处是Django管理迁移时会执行相应的迁移文件从而可以实现添加一个默认值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdbe4bed74d001f69655d920c021d7a3/" rel="bookmark">
			【Dart】dart之mixin探究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于dart中是没有interface的，在dart中我们需要定义接口的话用的是class关键字
implements是把某个class当做接口来实现要求我们重写这个class的所有方法
注意：implements会将class的实现抹掉就不存在默认实现一说，而dart也是不允许多继承的。
extends表示继承某个class，可以继承父类实现了的方法
mixin实际上也是面向对象编程中的概念，用户与Mixin不是“is-a”的关系，而是“-able”关系
Mixin是面向对象程序设计语言中的类，提供了方法的实现。其他类可以访问mixin类的方法而不必成为其子类。[1]Mixin有时被称作"included"而不是"inherited"。mixin为使用它的class提供额外的功能，但自身却不单独使用（不能单独生成实例对象，属于抽象类）。因为有以上限制，Mixin类通常作为功能模块使用，在需要该功能时“混入”，而且不会使类的关系变得复杂。
dart语言里面我们可以使用with关键字实现mixin,将一个或者多个class混入另一个类:
class Base1 { void foo1() { print("foo1"); } } class Base2 { void foo2() { print("foo2"); } } class Child2 with Base1, Base2 { } 没错,通过with多个类,可以实现类似多继承的效果。
既然允许with多个类,那么如果这些类中有个相同方法,那会出现什么事情？
实际上kotlin、java8使用接口的默认实现也会出现一样的问题，他们的处理方法是当出现相同方法的时候实现类需要手动指定使用哪个接口的默认实现,要不然编译会报错:
// java8 interface IBase1 { default void foo() { System.out.println("1"); } } interface IBase2 { default void foo() { System.out.println("2"); } } class Child implements IBase1, IBase2 { @Override public void foo() { IBase2.super.foo(); } } //kotlin interface IBase1 { fun foo() { println("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdbe4bed74d001f69655d920c021d7a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/378488b35a10f44d920b3af07c48916e/" rel="bookmark">
			Navicat 连接Oracle时提示oracle library is not loaded的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Navicat 连接Oracle时提示oracle library is not loaded的问题解决 笔者使用的Navicat Premium 12启动界面截屏：
请注意是64位的。笔者win7 64位系统。
连接Oracle时提示“oracle library is not loaded”。
解决方法：
1.前往“http://www.oracle.com/technetwork/database/database-technologies/instant-client/downloads/index.html”
2.选择与自己系统匹配的“Instant Client”。
我的是64位的软件，所以我选择第一个“Instant Client for Microsoft Windows(x64)”，如果你的软件是32位的 ，就选择第二个。
3.按照图示选择“Accept License Agreement”，然后点击“ instantclient-basic-windows.x64-x.x.x.x.zip”。这里的"x.x.x.x"是版本号，这个不重要，理论上任何版本都行的。注意，这时候需要你登录Oracle账号，没有可以直接注册个，不麻烦。
4.如果没有登录，则会跳转到下面的登录界面。没有账户就注册个账户，有就直接输入账号跟密码，点击“登录”按钮就会自动下载那个zip压缩包了。
5.下载好压缩包后解压，并将解压后的目录放在一个没有中文字符的路径之下，这样做是为了防止程序出错。我把它放在了："D:ORACLE"目录下了。
6.打开Navicat Premium程序，打开“工具 - 选项 - 环境 - OCI环境 - OCI library (oci.dll)”，然后将你刚才下载的文件夹中的oci.dll文件的完整目录填上，点击确定。
7.重启Navicat Premium程序进行测试双击oracle数据库，发现现在可以连接了，完成。
注意：特别注意：
配置完后一定要重新启动Navicat Premium程序，否则配置无法生效！！重要的事情说三遍！！！
配置完后一定要重新启动Navicat Premium程序，否则配置无法生效！！重要的事情说三遍！！！
配置完后一定要重新启动Navicat Premium程序，否则配置无法生效！！重要的事情说三遍！！！
近来有几个朋友说按照我的方法无法解决问题，你可以试一下安装我安装的版本。
---------------------
原文：https://blog.csdn.net/gxp1182893781/article/details/79815573
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40b74b50fa60ac46a7c4f98ee225da46/" rel="bookmark">
			最长公共上升子序列(LCIS)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前置知识 LCS
LIS
注意： 刚开始看这个问题的时候，第一反应是先求出LCS再求出LCS的LIS，事实上这是有问题的，我们并不能保证这么求出的LCIS是最长的,比如下面这个例子
Example
a:7 1 5 6 4 2 7
b:7 1 5 4 6 7 2
按照递归的取“最长公共子序列”,取出：
7 1 5 6 2
此序列的“最长上升子序列”为：
1 5 6 (len=3)
但原序列的“最长公共上升子序列”为：
1 5 6 7 (len=4)
求解 设第一个串为a，第二个串为b
首先确定dp状态f[i, j],表示前a串前i个字符和b串前j个字符且以b[j]为结尾的LCIS状态方程：
对于当处于(a[i], b[j]) 状态时 ,由于dp状态就决定了，b[j]是一定作为这个状态下LICS的结尾的，所以对于a[i]，就有两种情况，将其纳入LCIS或者不纳入，首先先说不讲a[i]纳入LCIS的情况
（1）若是 a[i] != b[j] ，显然是一定不能讲a[i]与b[j]进行配对的，那么问题就缩小成了前a的前i - 1个字符与b的前j个字符且以b[j]结尾的LCIS，即f[i - 1, j]也就是说 ，i之前的以b[j]结尾的序列自然没有改变，仍然是长度仍然是f[i−1][j]; 若是a[i] == b[i] 如果不想要a[i]与b[j]进行配对，是不是也会得到上面的结果，故当
不讲a[i]与b[j]配对(或无法配对)时，f[i, j] = f[i - 1, j] （2）当a[i] == b[j]且它们进行配对时，就要在a串前i - 1个字符和b的前j - 1个字符中找到一个最长的序列，设这个序列以t结尾且b[t] &lt; b[j]，是不是就等价于
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40b74b50fa60ac46a7c4f98ee225da46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31ef1906b2140492dfc1c5ab892a79ba/" rel="bookmark">
			一文彻底搞懂激光雷达原理！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击下方卡片，关注“自动驾驶之心”公众号
ADAS巨卷干货，即可获取
最近一直在搞激光雷达相关东西，今天把了解的激光雷达知识做一个框架整理，顺便梳理了一下行业里面激光雷达相关公司，一起学习，欢迎交流！
一、基础知识 激光雷达成像可以简单理解为使用激光发射部件向一定视场角FOV（Field Of View）内发射光线，同时使用接收部件接收范围内反射回的光线，利用已知和获取的发射光线与反射光线的相关信息，直接计算或推导出反射点的信息（速度、距离、高度、反射强度等）。
激光发射和返回示意
点云强度、高度、方位、距离 见上图，可以看到激光雷达形成的点云图是由一个一个点组成的。如果动图无法查看可以链接到原文阅读！
相关缩写：
dToF：direct Time-of-Flight直接测量光的飞行时间；
iToF：indirect Time-of-Flight通过测量相位偏移来间接测量光的飞行时间；
PLD：脉冲激光二极管，一种激光雷达发光元件；
APD：雪崩光二极管，一种激光雷达感光元件；
SPAD：Single Photon Avalanche Diode单光子雪崩二极管，一种激光雷达感光元件；
SiPM：Silicon photomultiplier硅光电倍增管，一种激光雷达感光元件；
CMOS：Compound metal Oxided Semiconductor 复合金属氧化物半导体，一种摄像头感光元件；
CCD：Charge Coupled Device电荷耦合器件，一种摄像头感光元件；
CIS：CMOS image sensor互补金属氧化物半导体图像传感器；
OPA：Optical Phased Arrays 光学相控阵；
FPA：Focal Plane Array焦平面阵列；
WD：Wavelength Disperion波长色散；
MEMS：Micro-Electro-Mechanical System 微机电系统；
二、技术原理 激光雷达探测的具体技术可以分为TOF飞行时间法与相干探测方法。其中ToF方法可以进一步区分为iToF和dToF方法；
1、飞行时间（ToF）探测方法 通过直接计算发射及接收电磁波的时间差测量被测目标的距离；
ToF雷达原理 2、相干探测方法（如：FMCW） 通过测量发射电磁波与返回电磁波的频率变化解调出被测目标的距离及速度；
FMCW雷达原理示意图 三、激光雷达的FOV FOV指激光雷达能够探测到的视场范围，可以从垂直和水平两个维度以角度来衡量范围大小，下图比较形象的展示了激光雷达FOV范围，之所以要提到FOV是因为后面不同的技术路线基本都是为了能够实现对FOV区域内探测。
垂直FOV：常见的车载激光雷达通常在25°，形状呈扇形；
水平FOV：常见的机械式激光雷达可以达到360°范围，通常布置于车顶；常见的车载半固态激光雷达通常可以达到120°范围，形状呈扇形，可布置于车身或车顶；
FOV示意图 四、技术路线 从功能模块可以把激光雷达分为激光器、扫描部分、感光芯片三部分，每一部分又可以进一步细分为下图：
激光雷达主要构成部分 根据激光雷达扫描部分有无运动部件将其分类为机械式、半固态、纯固态三种类型的激光雷达是我们最为熟知的分类方法。
1、激光器 由于激光器发射的光线需要投射至整个FOV平面区域内，除了面光源可以直接发射整面光线外，点光源则需要做二维扫描覆盖整个FOV区域，线光源需要做一维扫描覆盖整个FOV区域。其中点光源根据光源发射的形式又可以分为EEL（Edge-Emitting Laser边发射激光器）和VCSEL（Vertical-Cavity Surface-Emitting Laser垂直腔面发射激光器）两种，二者区别在于EEL激光平行于衬底表面发出（如图1），VCSEL激光垂直于衬底表面发出（如图2）。
EEL与VCSEL发射对比 其中VCSEL式易于进行芯片式阵列布置，通常使用此类光源进行阵列式布置形成线光源（一维阵列）或面光源（二维阵列），VCSEL光源剖面图与二维阵列光源芯片示意图如下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31ef1906b2140492dfc1c5ab892a79ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8893185f7c8f81aa555529571bcf96fa/" rel="bookmark">
			长链接概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		websocket 基础理解 webSocket是一种网络传输协议，可在单个TCP连接上进行全双工通信，位于OSI模型的应用层。WebSocket协议在2011年由IETF标准化为RFC 6455，后由RFC 7936补充规范。Web IDL中的WebSocket API由W3C标准化。WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。
通过上述对websocket的定义,我们知道如下几个关于websocket特点:
websocket 是一种网络传输协议
websocket 是基于tcp 协议的
websocket 是全双工的 (客户端和服务端都可以主动通信)
websocket 是持久性连接
补充关于websocket 的特点 :
大部分编程语言都能实现websocket服务端和客户端
websocket 协议得到了当前绝大部分浏览器的支持(web浏览器作为websocket的客户端)
与http协议兼容,默认的工作端口是 80(http) 和 443(https)
websocket 是一个应用层协议 , 但是websocket必须依赖HTTP协议进行第一次握手 , 握手成功之后数据直接从TCP通道传输 , 此时就和HTTP无关了
General Request URL: ws://127.0.0.1/echo Request Method: GET Status Code: 101 Switching Protocols Response Headers HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: c/LP8JsVmZWV/EB3lgGDVmVQWVA= Request Headers GET ws://127.0.0.1/echo HTTP/1.1 Host: 127.0.0.1 Connection: Upgrade Pragma: no-cache Cache-Control: no-cache User-Agent: Mozilla/5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8893185f7c8f81aa555529571bcf96fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5421af429a5c05aade09fb096e3d0aa/" rel="bookmark">
			【html5】网页播放器Video的创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、需求 创建一个自己的播放器控件
二、源码 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Video Demo-By_Even-2022-4-29&lt;/title&gt; &lt;style type="text/CSS"&gt; #header{ background-color: black; color: white; text-align: center; padding: 5px; } #nav{ line-height: 30px; background-color: #eeeeee; height: 300px; width: 100px; float: left; padding: 5px; } #section{ width: 800px; float: left; padding: 10px; } #footer{ background-color: black; color: white; clear: both; text-align: right; padding: 5px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;video width="320" height="240" controls="controls"&gt; &lt;source src="/i/movie.ogg" type="video/ogg"&gt; &lt;source src="/i/movie.mp4" type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5421af429a5c05aade09fb096e3d0aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96375b1781dd820a2b0e6876ec1d0bf0/" rel="bookmark">
			Optimal Boundary Value Problem (OBVP) 学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 Boundary value problem (BVP)：给出机器人在起始点与终止点的状态，设计出一条状态转移的轨迹。是stated sampled lattice planning的基础，在motion planning技术栈中的位置如下。
Optimal boundary value problem：按某种原则设计出一条最优轨迹。
建模 对于二维/三维空间中的机器人，通常在每个维度上分别进行轨迹设计。此处以三维空间中的无人机为例，考察其在一个轴向的运动。
无人机状态 s = ( p , v , a ) s=(p, v, a) s=(p,v,a)
使用jerk作为控制输入： u = j u=j u=j
状态方程：
s ˙ = f s ( s , u ) = ( v , a , j ) \dot{s}=f_s(s,u)=(v,a,j) s˙=fs​(s,u)=(v,a,j)
目标：最小化jerk二次方的积分，即
min ⁡ J : = 1 T ∫ 0 T j ( t ) 2 d t \min J : = \frac{1}{T}\int_{0}^{T}j(t)^{2}dt minJ:=T1​∫0T​j(t)2dt
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96375b1781dd820a2b0e6876ec1d0bf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/889ba76a4d315404723a03d09302d66d/" rel="bookmark">
			常用Windows快捷键大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. 简要 要将电脑玩的溜，快捷键是必须要掌握的技能，本文汇总了一些常用的快捷键，相信加以练习，一定能提高你的工作效率。
笔者将常用快捷键分为四个系列，如下所示：
Win 系列Ctrl 系列Alt 系列F 系列 本文主要参考了https://blog.csdn.net/Viewinfinitely/article/details/117253119
1. Win 系列 1、Win + L：直接锁屏
2、Win + E：打开文件资源管理器
3、Win + Tab：3D窗口切换
4、Win + X：一次调出众多功能
5、Win + D：往返桌面和窗口
6、Win + R：运行界面
2. Ctrl 系列 1、Ctrl + W：关闭窗口，相当于x
2、Ctrl + D：删除选中项
3、Ctrl + 鼠标拖动：快速复制文件
4、Ctrl + N：新建一个窗口
5、Ctrl + O：打开文件
6、Ctrl + F：查找
7、Ctrl + Shift + N：新建文件夹
8、Ctrl + ⬅/➡：光标移动到该行头部、尾部
9、Ctrl + Home/End：光标移动到窗口顶部/底部
10、Ctrl + C/X/V/Z/A/S：复制、剪切、粘贴、全选、保存
3. Alt 系列 1、Alt + F4：关闭应用/关机
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/889ba76a4d315404723a03d09302d66d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d827357d57da8072e0765e9e77cc5a8c/" rel="bookmark">
			BUUCTF_Misc题目题解记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BUUCTF刷题Misc篇 文章目录 BUUCTF刷题Misc篇前言一、ningen二、小明的保险箱三、爱因斯坦四、easycap五、隐藏的钥匙六、另外一个世界总结 前言 仅记录解题步骤，方便自己没事儿的时候拿出来强化一下记忆，俗话说好记性不如烂笔头，祝我早日卷赢同事（？
有没有和我一样用M1芯片，装不了工具，用不惯虚拟机，做不动杂项（那就更不要说pwn了）的大冤种？看过来呜呜呜呜呜……
一、ningen 1.下载的附件是一张图片(.jpg)，在macOS下的“终端”输入命令：
strings 图片文件名.jpg
可以看到显示的内容最后有txt文件。
2.到kali下用命令：
binwalk -e 图片文件名.jpg
就可以分离出压缩文件9721.zip，可以看到压缩包里面有一个ningen.txt文件，需要密码才能打开。
3.接下来可以在Windows下用Advanced Archive Password Recovery(ARCHPR)爆破密码啦，但我因为某个原因把win11虚拟机删除了，所以就还是在kali下，借助的是fcrackzip工具，按照题目中密码是四位数字的提示，用命令：
fcrackzip -b -c ‘1’ -l 4 -u 9721.zip
据说这里-b代表爆破模式，-c '1’代表是用数字爆破，-l 4代表爆破长度是4位
(真是不如win下用图形化来得快啊呜呜呜但是敲命令行酷啊
然后瞬间就爆破出密码了，放图纪念~
拿这个密码打开txt文件，拿到flag{b025fc9ca797a67d2103bfbc407a6d5f}
二、小明的保险箱 1.下载附件是一个有着保险箱图案的jpg图片文件
2.本mac用户的思维定势流程：先用strings命令看看里面会有啥东西
3.上一步中果然看到这里面也有txt文件，那就丢进kali用 binwalk -e 分离一下文件
4.果然可以得到上一步分离出的一个rar压缩文件
5.到这里就尴尬了，fcrackzip只能破解zip密码啊
6.然后就去找有没有能爆破rar文件密码的工具，看到了rarcrack，以为和fzipcrack差不多呢结果差挺多……用命令：
rarcrack 1381F.rar —threads 20 --type rar
这个工具用的命令是真的无语，直接开始爆破的话是字母数字混着的，从两位到三位慢慢爆破，眼看这四位纯数字明明很简单却怕是要爆破失败，就赶紧去搜了搜，发现是在爆破开始后桌面上会出现一个.xml文件，修改这个文件的内容只剩下数字就行了，然后发现下面一行是current可能表示的是当前爆破到多少了，就手动改成从四位数字0000开始吧。
PS：我理解的这个工具的用法就是先开始爆破，开始爆破后稍等一下就结束爆破，然后去按自己的需求修改xml文件再重新开始爆破。
还有就是这里threads我是试了个20，好像提示的是现在的情况适合12，最后就是还需要指明文件type是rar。
用密码打开rar中的txt，拿到flag{75a3d68bf071ee188c418ea6cf0bb043}
这里十分建议还是用win下的ARCHPR吧！
三、爱因斯坦 1.得到一个压缩包，解压后有一张爱因斯坦的图片，老套路strings看一下图片文件的内容，有flag.txt
2.去kali用binwalk -e分离出压缩包，是个zip
3.想去爆破密码，然后一想，不对啊没给关于密码的提示，试了四位数字也没爆破出来
4.去找别人wp，知道了是在Windows下对图片文件右键属性，选择详细信息之后看到备注里面this_is_not_password
5.用this_is_not_password作为解压密码，打开了flag.txt拿到flag{dd22a92bf2cceb6c0cd0d6b83ff51606}
后来想了下mac下能咋办呢？发现可以用Stegsolve里的文件格式分析：
四、easycap 1.题目附件是压缩包，解压后里面是一个pcap文件，直接用wireshark打开
2.看到全是TCP流
3.本人目前的知识储备就是只知道找到其中一条，右键，追踪流
4.没想到随便点一条去追踪流都能看到flag……
五、隐藏的钥匙 strings 图片名.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d827357d57da8072e0765e9e77cc5a8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e7fb980af5c292b9b3d58be35a608ae/" rel="bookmark">
			图像处理流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、计算机视觉是什么？二、图像处理流程三、环境配置 前言 随着人工智能的不断发展，机器学习这门技术也越来越重要，很多人都开启了学习机器学习，我也是这其中的一员。我是初入深度学习的小白一枚！学的是图像处理，也就是计算机视觉方向！
提示：以下是本篇文章正文内容，下面案例可供参考
一、计算机视觉是什么？ 计算机视觉是用计算机模拟人眼对目标进行识别、跟踪和测量，并对图形和图像进行识别、解释和处理，即实现计算机“看得懂”
二、图像处理流程 三、环境配置 这里是我对环境配置的理解，具体操作可以看B站up主，我是土堆的视频操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9755f2ec5b6a9bb2826253ff4776687/" rel="bookmark">
			[详解C语言]一文带你玩转C语言小游戏---三子棋
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：大家好我是zoroxs 📃个人主页：c/c++学习之路
🔥💖如果觉得博主的文章还不错的话，请👍三连支持一下博主哦
三子棋 ✅作者简介：大家好我是zoroxs📕1.游戏整体思路📗2.棋盘设计📘3.玩家下棋实现📙4.电脑下棋实现📓5.判断输赢📔6.测试函数编写📒7.游戏代码与测试代码拼接📚8.总结 今天来讲解一下三子棋，大家小时候应该都玩过，记得之前上课和同桌画来画去玩这个被老师骂，哈哈哈， 给大家说一下三子棋的规则----三子成杀 将正方形对角线连起来，相对两边依次摆上三个双方棋子，只要将自己的三个棋子走成一条线，对方就算输了
📕1.游戏整体思路 这就是游戏大体思路，图应该有些问题，我来给大家简述一下游戏思路
打印 3*3 棋盘玩家下棋判断是否三子成杀电脑下棋判断是否三子成杀 我们在这里规定：
玩家下棋的子用 ’ * ‘表示，电脑下棋的 棋子’ # ’
三个* 先成玩家胜，###先成电脑胜，如果棋盘下满了，还没分出胜负，则平局
📗2.棋盘设计 下棋必不可少的两个东西，就是棋盘和棋子，我们先来设计一下棋盘 3 * 3的棋盘,我们很容易就想到了前边学过的二维数组，没学过的朋友可以看我之前博客传送门
就像这样子的，没下棋之前棋盘是空的，空并不是无，我们这里用空格填充的二维数组，我们把最边界的几个横线省略掉，来看一下VS下的调试
就像这样棋盘就设计好了， 这其实就是一个二维数组，只不过匹配的打印了很多线
那我们来总结一下，我们需要
一个字符的二维数组 3 * 3将二维数组初始化为全空格打印相匹配的横竖线 我们需要两个函数来帮我们完成， 一个初始化，一个打印，我们起为
void init_board(char board[ROW][COL], int row, int col);
void display_board(char board[ROW][COL], int row, int col);
我们来实现一个这两个函数
void init_board(char board[ROW][COL], int row, int col) { int i = 0; int j = 0; for (i = 0; i &lt; row; i++) { for (j = 0; j &lt; col; j++) { board[i][j] = ' '; } } } //在这里打印的时候我们可以把横线和数值看做一行，进行判断 void display_board(char board[ROW][COL], int row, int col) { int i = 0; int j = 0; for (i = 0; i &lt; row; i++) { for (j = 0; j &lt; col; j++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9755f2ec5b6a9bb2826253ff4776687/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0294e72c5936ecf107f1b38856b69800/" rel="bookmark">
			Kafka设计原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.Controller选举机制1.1 Kafka Controller1.2 Controller选举机制 2.Partition分区副本选举Leader机制3.消费Offset记录机制4.Consumer Rebalance5.HW和LEO6.Kafka索引文件 1.Controller选举机制 1.1 Kafka Controller 在Kafka集群中会有一个or多个Broker，其中有一个Broker会被选举成为Kakka控制器，它负责管理整个集群中所有分区和副本的状态。
- 当某个分区的Leader副本出现故障时，由控制器复杂为分区选举新的Leader副本。 - 当检测到某个分区的ISR集合发生变化时，由控制器负责通知所有的Broker更新元数据信息。 - 当Topic增加分区数量时，由控制器复杂让新的分区通知其它Broker感知到。 1.2 Controller选举机制 当Kafka集群启动的时候，会自动选举一个Broker作为控制器，选举的过程就是让每一个Broker去zookeeper中创建一个 /controller的临时节点，创建成功的Broker就成为控制器。控制器通过注册watcher机制去监听zk的各种节点来监控集群的各种元数据状态。
2.Partition分区副本选举Leader机制 控制器感知到分区Leader所在的Broker挂了以后，控制器从ISR列表中选出第一个Broker作为Leader。副本节点进入ISR集合有两个条件：
- 副本节点不能产生网络脑裂，必须能和zookeeper保持会话以及跟Leader副本网络连接。 - 副本鞥能够复制Leader的写提交，并且不能落后太多(同步时间区域间隔不能太大)。 3.消费Offset记录机制 每一个Consumer会定期将自己消费分区的Offset提交给kafka，key = 消费者组ID + Topic + 分区号，value = 当前Offset的值。kafka定期清理topic里的消息，最后保留最新的数据。
4.Consumer Rebalance 消费负载的触发点有三：
- 消费者数量发生变化，例如新consumer加入或consumer关闭。 - topic添加了分区 - 消费者组订阅了更多的topic kafka在rebalance过程中，消费者无法消费消息，这对kafka的吞吐性能造成影响。
kafka的rebalance分配有3种策略：
- `Range`：默认的分配策略，根据分区号排序来进行分配。 - `Round-Robin`：轮询分配，例如1,4,7、2,5,8这样分配模式。 - `Sticky`：和轮询类似，但是重新负载的时候会遵守均匀分配等原则。 5.HW和LEO HW：HighWatermark高水位，取的是ISR中最小的LEO(log end offset)作为HW。对于Leader新写入的消息，consumer不能立即消费，Leader会等待该消息被所有的ISR节点同步后更新HW，此时消息才能够被消费者消费，这样就保证了如果Leader所在的Broker节点挂了，该消息仍然可以从新选举的Leader中获取。
kafka的复制机制并不是完全的同步复制模式，但也不是单纯的异步复制。而是通过引入ISR的方式来确保数据不丢失和保证吞吐量。kafka确保消息不丢失的参数：ACKS：
- acks = 0：表示Producer不需要等待任何确认收到的信息。 - acks = 1：至少等待Leader成功将数据写入本地Log，但是并没有等待所有Flollower是否成写入，如果此时Flollower没有同步成功，此时Leader又挂机，则消息会丢失。 - acks = all：Leader需要等待所有备份节点都成功写入日志，这种方式不会丢失数据。 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0294e72c5936ecf107f1b38856b69800/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4be18761fef7f22c5bb0decbf5d992ea/" rel="bookmark">
			typescript ‘props‘ is declared but its value is never read 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以修改tsconfig.json文件的noUnusedParameters为false即可
noUnusedParameters:false
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/734738859cda910f9740ce5e93dd435c/" rel="bookmark">
			UFS3.0协议学习Note(一)-什么是UFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		愿每一个认真学习的人都能拥有快乐的明天！
List 一、什么是UFS二、UFS接口三、协议架构四、UFS封装 一、什么是UFS UFS = Universal Flash Storage(通用闪存存储)
针对这个名字，有两层意思 存储接口协议名称；
使用了这该存储协议的存储设备；
发展历程
协议规范 电气接口
用基于MIPI M-PHY的高级差分接口；M-PHY作为物理层，MIPI UniPro作为链路层，二者结合形成UFS接口的互联；存储器件的特性
低功耗、高数据吞吐量、低电磁干扰、大容量存储器子系统效率的优化；系统架构
参考 INCITS T10(SCSI) SAM 标准，命令协议基于 INCITS T10(SCSI) SPC 和 SBC 标准； 二、UFS接口 传输方式
差分串行多通道数据传输（UFS快的基础）传输方向 全双工+异步
传输特点 支持命令队列，主机一下可以发若干个命令给设备;
(eg:W1+R，UFS设备可以并行处理这两个命令; - 由于协议支持全双工操作，主机传输写命令W1的数据给设备的同时，设备也可以把读命令R2的数据返回给主机)； 版本&amp;速率
三、协议架构 分层示意图
层作用 层作用UFS命令集 (UCS) 层（应用层）处理UFS使用的小型机系统接口 (SCSI) 命令UFS传输协议 (UTP) 层执行更高层UFS协议信息单元 (UPIU) 命令的生成和处理UFS Inerconnect (UIC) 层处理UFS主机与设备间的连接，其中包含针对链路层的MIPI UniPro和针对物理层的MIPI M-PHY。UIC层提供了UIC IO控制服务接入点(UIO_SAP)，与UniPro中的设备管理实体(DME)_SAP相对应 四、UFS封装 Note：顶层视图
参
考文档
1.UFS3.0 Spec
2.蛋蛋读UFS之一：UFS简介
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98672c37dcc25389dfce469ad88b080f/" rel="bookmark">
			Bus Hound总线分析工具的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		愿每一个认真学习的人都能拥有快乐的明天！
目录 Bus Hound一、软件参数详细介绍1.Capture：数据抓取菜单2.Save：保存菜单3.Setting：设备设置菜单4.Devices：设备控制选取菜单 二、抓取数据1.设备选择2.设置3.抓包4.数据保存 三、发送命令 Bus Hound Bus Hound is the premier software bus analyzer for capturing I/O, protocol, and performance measurements. You can also send commands to devices from a graphical interface. Bus Hound is a 100% software product and especially suited to inspecting host side protocol. --For https://perisoft.net/bushound/
总：用来捕获软件总线数据，还可以发送命令。
Bus Hound是一款强大的总线分析工具，支持USB、NVMe、火线、SATA等设备数据抓取；
一、软件参数详细介绍 1.Capture：数据抓取菜单 抓取到的数据包进行解析
Device：设备号，标识USB设备；
Address：FireWire异步地址或通道号，一般空白；
Length： 数据长度，单位Byte；
Phase： 捕获类型（Phases to Capture中的选项）
Data： 数据，显示的最大长度可在Setting中进行修改；
Description： 阶段捕获数据描述，数据转码显示；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98672c37dcc25389dfce469ad88b080f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b4b192800cb1e487a4229a5cc2a6f87/" rel="bookmark">
			C#用户登录界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; using System.Data.SqlClient; namespace LoginProject { public partial class FrmLogin : Form { public FrmLogin() { InitializeComponent(); } private void btnYes_Click(object sender, EventArgs e) { SqlConnectionStringBuilder scsb = new SqlConnectionStringBuilder(); scsb.DataSource = "SK-20220626HGWR"; scsb.InitialCatalog = "test"; scsb.UserID = "sa"; scsb.Password = "123456"; string user_id = txtUser.Text; string user_pwd = txtPwd.Text; if (user_pwd==""||user_id=="" ) { MessageBox.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b4b192800cb1e487a4229a5cc2a6f87/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/246/">«</a>
	<span class="pagination__item pagination__item--current">247/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/248/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>