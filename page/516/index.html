<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6e6ed9014a189b682fef29bf780d2bf/" rel="bookmark">
			AUC用于二分类为啥比accuracy更常用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多机器学习的模型对于分类问题的预测结果都是概率，如果计算accuracy，需要把概率转换为类别，这就需要手动设置一个阈值。高于该阈值放入A类，低于该阈值放入B类。该阈值很大程度上影响accuracy的计算。AUC可以避免将概率转换成类别。
ROC：x轴-FP，y轴-TP
AUC的含义：从所有1（0）样本中随机选择一个样本，放入分类器进行预测，预测1--&gt;1的概率为p1，预测0--&gt;1的概率为p0. p1&gt;p0的概率就是AUC
人工智能
机器学习：一种实现人工智能的方法
深度学习：一种实现机器学习的技术
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/895744e1f550c5add16128f61fe299d2/" rel="bookmark">
			Linux安装hadoop和HDFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上传大数据包centos6.5-hadoop-2.6.4.tar.gz hadoop包下载地址:https://download.csdn.net/download/weixin_39549656/10313902 安装在root目录下的apps目录下
# tar -zxvf centos6.5-hadoop-2.6.4.tar.gz -C apps/ 更改配置文件 配置文件 进入$HADOOP_HOME/etc/hadoop 1.修改hadoop-env.sh 2.java路径命令 which java,因为是JAVA_HOME,路径把bin/java 去掉 更改HDFS配置文件只需要更改下面两个文件 vi core-site.xml 在configuration标签中添加文件系统的类型,我们选择默认的文件系统HDFS 下面的生成临时文件存放目录 &lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://192.168.33.100:9000/&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/root/hdptmp/&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 修改hdfs-site.xml 文件(也可以什么都不用配置)
vi hdfs-site.xml 初始化NAMENODE Namenode的机器上运行时会记录一些数据，数据的记录有一个特定的目录结构，那么应该在namenode启动之前先构造出这样一个目录：
$HADOOP_HOME/bin/hadoop namenode -format 将hadoop文件下的命令配置到环境变量中
vi etc/profile 环境变量文件结尾处添加
export HADOOP_HOME=/root/apps/hadoop-2.6.4/ export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin 重新加载配置文件命令
source /etc/profile 执行初始化命令
hadoop namenode -format 出现下面 红框内的意思是”生成文件保存位置文件夹”说明执行成功了 启动HDFS 启动namenode节点
hadoop-daemon.sh start namenode 查看是否成功
jps 查看监听端口号
netstat -nltp 9000.是之前设置它自己的进程,50070是对外提供服务的端口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/895744e1f550c5add16128f61fe299d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db611e9460edd4cf2d18a0b3965dfe90/" rel="bookmark">
			牛顿迭代与二分查找开平方
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		牛顿迭代 不要被牛顿的大名唬住，牛顿迭代其实就是一种求近似解的方法。求解过程就是对曲线做切线，然后在切线与x轴交点，然后在这个点做x轴垂线，垂线到曲线交点继续做切线，一直重复上述步骤。然后切线与曲线交点就会慢慢的趋近于X轴与曲线交点。x轴与曲线交点就是曲线方程的根，但是直线方程的跟比较好计算，计算出最近的直线方程根，约等于曲线的根。大概做曲线切线的过程如下
公式推到过程 假设曲线 f(x) f ( x ) ，则曲线斜率 f′(x) f ′ ( x ) 曲线上 (xn,f(xn)) ( x n , f ( x n ) ) 点的切线方程 y=f′(xn)(x−xn)+f(xn) y = f ′ ( x n ) ( x − x n ) + f ( x n ) 求上述方程的根（函数 f f 的一个根（或称零点）是ff的定义域 D D 中适合f(x)=0f(x)=0的元素 x x ），若求切线与xx轴焦点 x x ，则有以下方程f′(xn)(x−xn)+f(xn)=0f′(xn)(x−xn)+f(xn)=0 解方程可得 x=xn−f(xn)f′(xn) x = x n − f ( x n ) f ′ ( x n ) 所以切线的根为 xn−f(xn)f′(xn) x n − f ( x n ) f ′ ( x n ) 由于下一个切线点是在上边求出点做 x x 轴垂线获得，可以推到出下一个点xn+1=xn−f(xn)f′(xn)xn+1=xn−f(xn)f′(xn) 依次计算 x1 x 1 、 x2 x 2 、 x3 x 3 ……，那么序列将无限逼近方程的根。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db611e9460edd4cf2d18a0b3965dfe90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d630b6f95e296bcc44b995c3a0b9e23/" rel="bookmark">
			代码片段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、数组合并
有时候用concat并不好，因为原先两个数组不变，而返回新的数组，进行多次合并的时候，会很浪费内存;
用for循环的话，显得臃肿：for(i in b){a.push(b[i])};
一行代码：a.push.apply(a,b) 例如：a.push.apply(a,[1,2,3]);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea133316d4f00636f044dd8fbb72adf1/" rel="bookmark">
			Linux下如何检测内存泄漏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux检测程序内存泄漏
1.安装valgrind：
这是一款开源的程序内存检测工具，mtrace为内存分配函数（malloc, realloc, memalign,free）安装hook函数。这些hook函数记录内存的申请和释放的trace信息。 Valgrind详解：
Valgrind包括以下一些工具： 1.Memcheck:这是valgrind应用最广泛的工具，一个重量级的内存检查器，能够给发现开发中绝大多数的内存错误使用的情况，比如：使用未初始化 2.callgrind：它主要用来检查程序中函数中调用过程中出现的问题 3.cachegrind：它主要用来检查程序中缓存使用出现的问题 4.Helgrind：它主要用来检查多线程中出现的竞争问题 5.Massif:它主要用来检查程序中堆栈使用中出现的问题 6.Extension:可以使用core提供的 功能，自己编写特定的内存调试工具 2.mtrace命令 man 3 mtrace 可以在man 手册中查看该函数
mtrace 也有对应的命令，其使用方式为：
一．将环境变量MALLOC_TRACE设置为所需输出文件的路径名 二．在需要检测的源代码中引入mcheck.h头文件
1．在分配内存之前调用mtrace(); ，一般在main函数的开头调用
2．在结束检测的地方调用muntrace(); ，一般在return之前调用
3．编译程序时需要加上-g 选项
#include &lt;stdio.h&gt; #include &lt;malloc.h&gt; #include &lt;mcheck.h&gt; int main() { mtrace(); int *p = NULL; p =(int *)malloc(sizeof(int) * 1); //free(p);//未free，内存泄漏 muntrace(); return 0; } 4.内存泄漏信息将在MALLOC_TRACE环境变量指定的文件中报告，需要使用mtrace命令将信息转换。 结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ce05b4432d9b8b6b9109491d1a838ff/" rel="bookmark">
			记录一个单线程调用写出现的&#34;死锁&#34;问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题的现象是出现一个pthread_mutex_t 互斥锁在init成功后, 在 pthread_mutex_lock 的时候出现死锁, 然后程序卡住一直执行不下去, 但是调用的地方只有在一个线程中, 没有多线程同时调用pthread_mutex_lock的情况 ;
这种情况下, 调查一般死锁的思路是完全没用的,而且会怀疑人生,所以必须要像寒战里刘杰辉破案一样, 要更宏观的去找原因,O(∩_∩)O哈哈~; 发现这个问题时,当时用的是打印 pthread_mutex_t 的 __data.__ownwer成员发现是一个很大的数,完全不像一个线程id;
这种"神奇"的bug现象下,rootcause完全跟线程,互斥所没有一点毛的关系, 而真正的原因是调用程序和被调用程序使用的头文件不一致而造成的内存破坏, 更确切的举例说, 比如, 被调用方的的一个C++类的的定义改变了,增加,删除或修改了几个成员, 但是成员函数接口都没有变, 而只是数据成员变了,并且成员函数内部实现变了; 这时候,如果调用这个类的代码跟这个类的实现不在一个库中, 也就是分别编译的, 那么如果只更新编译了被调用方, 而不使用新的头文件重新编译调用方的话, 整个程序执行就可能有问题; 因为在这个例子中,调用方直接使用被调用的那个类的对象变量作为自己类的成员变量, 而不是使用的被调用类的指针作为自己类的数据成员, 在这个例子中,就看出了指针使用的好处; 直接使用类对象的情况下,相当于自己类的内存布局中包含了调用类的内存, 而当上述头文件不一致的情况发生时, 在运行时,自己的类内存的布局还是原来旧的布局, 而被调用类的库已经更新了,这时候被调用类的库的执行代码会按新的内存布局来访问现在的调用类的内存中的被调类内存,显然会写出错,于是造成各种很奇怪的问题,最终原因都是头文件不一致导致的内存破坏;这种问题经常发现在系统集成的测试中,一般单独的测试不太容易测到; 一个号称自己擅长系统集成的人或公司,应该对这种问题特别了解;
那么从编程和系统集成的角度扩展开来时, 两个类存在包含关系时, 最好不要用类对象直接作为成员变量, 做好用指针+interface的方式, 可以配合上只能指针等形式, 这样, 能够保证调用类的内存不会被被调用类的内存而影响; 因为被调用类的内存的分配就和此时调用类的构造和初始化分配是分开的; 从而这种集成是更松耦合的; 从原理上,指针这种类型的使用, 也是从系统角度去管理内存,因为指针实际指向的内存情况由系统来负责, 把更多的事情交给能够在第一时间发现任何组件变化的系统来做, 才是更符合系统集成的思路, 才能更容易发现和解决问题,而且也才是更鲁棒的系统集成方式;
智能指针使用的一些总结;
默认的智能指针应该是unique_ptr。unique_ptr意味着所有权。单个unique_ptr离开作用域时，会立即释放底层内存, 只有需要共享资源时，才使用shared_ptr。 最后一个shared_ptr离开作用域时，才会释放这块内存;
数据只有两种: 数组和非数组:
与unique_ptr不同，标准库并不提供shared_ptr&lt;T[]&gt;，因此，使用shared_ptr处理数组时需要显示指定删除行为，例如：
1 2 3 4 5 6 shared_ptr&lt; string&gt; ptr1( new string[ 10], []( string *p ) { delete[] p; }); shared_ptr&lt; string&gt; ptr2( new string[ 10], std::default_delete&lt; string[]&gt;() ); 对于效率上, 最好不要直接使用智能指针访问数组数据。可行得办法是使用智能指针管理数组内存，但是使用原始指针访问数组数据;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ce05b4432d9b8b6b9109491d1a838ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/040e6101d331524c4ee7c7886fd06459/" rel="bookmark">
			c#自动获取对应的串口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是根据设备VID和PID匹配对应的串口，也可以根据设备的GUID匹配；具体实现返回类似字符串类似“COM1”。
注释部分可以打印出该设备的所有信息，方便查看选择自己需要的进行扩展。
/// &lt;summary&gt; /// VID+PID gets the serial port /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private string searchDevicesRegistry() { string[] available_spectrometers = SerialPort.GetPortNames(); ManagementObjectCollection.ManagementObjectEnumerator enumerator = null; string commData = ""; ManagementObjectSearcher mObjs = new ManagementObjectSearcher("root\\CIMV2", "SELECT * FROM WIN32_PnPEntity"); try { enumerator = mObjs.Get().GetEnumerator(); while (enumerator.MoveNext()) { ManagementObject current = (ManagementObject)enumerator.Current; if (Strings.InStr(Conversions.ToString(current["Caption"]), "(COM", CompareMethod.Binary) &lt;= 0) { continue; } //foreach (var property in current.Properties) //{ // Console.WriteLine(property.Name + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/040e6101d331524c4ee7c7886fd06459/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/812063a5cc08e5521317fa97d8d8df10/" rel="bookmark">
			CSS传统布局基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘自 https://mp.weixin.qq.com/s/-LcNZWFFty2lWuND6uuNNA 传统布局方案：浮动、定位等手段 flex布局方案 grid布局方案 传统布局方案来源于CSS2，兼容性好 flex方案通过父元素单方面配置相关的CSS属性来决定子元素的布局规则， 且大多数情况下无需子元素的参与，学习成本低，代码更加简练。但是要到 IE10才开始支持 ，且需要使用-ms-前缀（IE11无需）。 grid布局方案由微软提出，由IE10开始支持，但需要使用-ms-后缀（IE11+ 不再需要）。 目前传统布局方案对用户最友好，有一定适用性，这里讲的就是传统布局方案。 box-sizing（CSS3属性） box-sizing是CSS3属性，在IE8+（包含IE8）开始支持，在W3C标准中,box-sizing 的值仅有content-box和border-box（firefox则额外支持padding-box）。 当box-sizing的值为content-box（默认值）时，有： width = content-width; height = content-height; 当box-sizing的值为border-box时，有： width = content-width + padding-left + padding-right + border-left-width + border-right-width; height = content-height + padding-top + padding-bottom + border-top-height + border-bottom-height; 块级元素 1、独占一行（width默认100%，hieght为0）； 2、可以设置任何尺寸相关的属性（width、padding、margin和border）； 行内级元素 可置换行内元素：其展示内容是通过元素的src、value等属性或CSS content属性从外部 引入得到的，可被替换的。随着内容来源或数量的变化，可置换元素本身也会有水平和垂 直方向上尺寸的变化。典型的可替换元素有&lt;img&gt;、&lt;object&gt;、&lt;video&gt;、&lt;embed&gt;，表单 类的可替换元素有&lt;textarea&gt;和&lt;input&gt;，某些元素只在一些特殊情况下表现为可替换元素。 例如&lt;audio&gt; 、&lt;object&gt;、&lt;canvas&gt;和&lt;applet&gt;.. 特别地，通过CSS contenr属性来插入的对象又被称作匿名可置换元素。 不可置换行内元素 “不可置换行内元素”其实就是我们常见的行内元素，有&lt;a&gt;和&lt;span&gt;等。“不可置换行内元素” 是相对于“可置换行内元素”的，其展示的内容是在CSS作用域范围内的，是不可替换的。 行内级元素有如下几个布局特性： 1、在一行内可以与多个同类型的元素按从左到右的顺序排列； 2、不可置换行内元素不能设置width、height和垂直方向上的margin，而可置换行内元素则可以； 3、在水平和垂直方向上的对齐方式，行内级元素分别受父元素的text-align属性和自身vertical-align 属性的控制 （父元素是table-cell元素时，也受父元素的vertical-align属性控制） ，在水平方向上默认左对齐，在垂直方向上默认在行框的baseline基线上显示 （“行框”的概念，会在后面深入讲解)； 行内块级元素 1、排列方式与行内级元素同，不独占一行，在一行内按从左到右的顺序排列； 2、水平和垂直方向上的对齐方式与行内级元素同； 3、和块级元素一样，可以设置任何尺寸属性（但width默认为0）； 格式化上下文 是一个独立封闭的渲染区域，在这个区域的所有元素，从区域的顶部起，一个接一个地根据自身的布局特性进行排列。 创建BFC元素的方式有如下几种（摘自MDN BFC）： 根元素或其它包含它的元素浮动元素 (元素的 float 不是 none)绝对定位元素 (元素的 position 为 absolute 或 fixed)内联块 (元素具有 display: inline-block)表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性)表格标题 (元素具有 display: table-caption, HTML表格标题默认属性)overflow 值不为 visible 的块元素display: flow-rootcontain为以下值的元素: layout, content, 或 strict弹性项 (display: flex 或 inline-flex元素的子元素)网格项 (display: grid 或 inline-grid 元素的子元素)多列容器 (元素的 column-count 或 column-width 不为 auto， 包括 column-count: 1的元素)column-span: all 应当总是会创建一个新的格式化上下文，即便具有 column-span: all 的元素并不被包裹在一个多列容器中。 BFC元素有如下特性： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/812063a5cc08e5521317fa97d8d8df10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/208076880a5a2edd987f07dc4ef701dc/" rel="bookmark">
			求最大公因数和最小公倍数   java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：给出两个数字a和b求出他的最大公因数和最小公倍数。 解析： 看到这题的时候一开始我还是觉得挺简单的，但是仔细一想却无从下手，于是乎我只能百度抠破脑袋终于想出来了 最小公倍数的公式为 ：
(a∗b)/(最大公倍数) ( a ∗ b ) / ( 最 大 公 倍 数 ) 所以我们只需要求出最大公因数就可以求出最小公倍数了
一、辗转相除法（欧几里得算法） 证明就需要大家去百度一下了。这里我们只写算法 思路：取两个数中最大的数做除数，较小的数做被除数，用最大的数除较小数，如果余数为0，则较小数为这两个数的最大公约数，如果余数不为0，用较小数除上一步计算出的余数，直到余数为0，则这两个数的最大公约数为上一步的余数。 1、递归
private static int gcd(int a,int b) { return (b==0)?a:gcd(b,a%b); } 2、非递归形式
private static int gcd(int a, int b) { int rem = 0; while (b != 0) { rem= a % b; a = b; b = rem; } return a; } 二、相减法（更相减损法） 思路：取两个数中的最大的数做减数，较小的数做被减数，用最大的数减去小数，如果结果为0，则被减数就是这两个数的最大公约数，如果结果不为0，则继续用这两个数中最大的数减较小的数，直到结果为0，则最大公约数为被减数。
private static int gcd(int a, int b) { while (a !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/208076880a5a2edd987f07dc4ef701dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50463d874b8a2c672211038f164c79a7/" rel="bookmark">
			jquery-1.11.1.js:9183Uncaught TypeError: Cannot read property &#39;msie&#39; of undefined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		$.browser在jQuery1.9里被删除了，jQuery1.9里对不少API做了废弃或者删除，所以项目的js代码里用到JQ1.9及以后的版本的时候，$.browser的地方就会报这个错。看谷歌Console里就会提示“Cannot read property msie of undefined”这个错误。幸运的是，jQuery社区考虑到了这么做给开发人员带来的麻烦，在1.9同时也推出了一个新插件jQuery Migration，该插件可以检查出在1.9之后被废弃或者删除的API，恢复原有功能，从而保证已有的js代码能在最新的jQuery下正常运行。
首先还是引用JQ的新版本，比如jquery-1.11.3.min.js
&lt;script src="http://code.jquery.com/jquery-1.11.3.js"&gt;&lt;/script&gt;
只需要在jQuery引用后加上一行对jQuery Migration的引用即可
&lt;script src="http://code.jquery.com/jquery-migrate-1.1.1.js"&gt;&lt;/script&gt;
注意：
jquery-migrate-1.1.1.js的引入一定要在jquery-1.11.3.js后面
原文：点击打开链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fb58a88202dd397da00df52c18d6e61/" rel="bookmark">
			解决Jquery异常:Uncaught ReferenceError: jQuery is not defined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.js路径问题,确保script的src引用路径正确
2.页面jquery.js的引用位置问题,如果导入了其它与jquery有关的js文件,那么jquery.js必须在其它js的前面
原文链接：点击打开链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60f9f38958ed69a441e4ec60e02b56a5/" rel="bookmark">
			reportlab 库生成带有表格的PDF报表文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用reportlab 库生成PDF文件的确很方便，对于简单的PDF文件的生成，可以直接使用最基本的一些drawXXX()方法来实现，具有可参见我的另一篇文章（https://blog.csdn.net/cloveses/article/details/79224057）但有时我们需要生成带有表格的报表，经过阅读官方文档，发现reportlab 库可以直接支持生成表格，而且还可以完成较为复杂的表格的生成。现就相关使用方法介绍如下：
一、生成PDF基本流程
1.导入相关的对象：
from reportlab.lib.styles import getSampleStyleSheet,ParagraphStyle from reportlab.platypus import Paragraph, SimpleDocTemplate, Spacer,Table,TableStyle,PageBreak from reportlab.pdfbase import pdfmetrics from reportlab.lib import colors from reportlab.pdfbase.ttfonts import TTFont from reportlab.lib.pagesizes import A4 2.生成简单文档模板
doc = SimpleDocTemplate(file_name,pagesize=(A4[1],A4[0]),topMargin = 15,bottomMargin = 15) #后面参数中pagesize为文档页面尺寸，topMargin/bottomMargin为文档上/下页边距，当然还有一些其他参数，可参考官方文档。 3.建立页面中需要渲染的各种元素，如段落文本、表格等，并放入一个列表中。
elements = [] pa = Paragraph('TEXT',stylesheet['Normal']) elements.append(pa) ... 4.调用简单文档模板对象的方法，传入要渲染元素的列表，生成PDF文件。
doc.build(elements) 二、常用的基本元素主要有：
Paragraph 文本段落 Paragraph(text,style)
Spacer 垂直空间留白 Spacer(width, height)
Table 表格 Table(data)
PageBreak 插入分页 PageBreak()
Image 图片 Image(filename, width=None, height=None)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60f9f38958ed69a441e4ec60e02b56a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47e48d356ecab84ddade3b7b4183fb02/" rel="bookmark">
			SSM到Spring Boot从零开发校园商铺平台---2、Logback配置与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章：
1、环境搭建及测试- - -附免费视频教程
专栏14篇，参看：https://blog.csdn.net/column/manage/40843
GitHub地址：https://github.com/tyronczt/imooc-o2o
线上演示地址：http://o2o.tyronblog.com:8088/o2o/front/index
先上效果图：
附上配置文件 logback.xml ：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!--scan: 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。 scanPeriod: 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 debug: 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt; &lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;!-- 定义参数常量 --&gt; &lt;!-- TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR --&gt; &lt;property name="log.level" value="debug"/&gt; &lt;!-- 每天生成一个日志文件，保存30天的日志文件 --&gt; &lt;property name="log.maxHistory" value="30"/&gt; &lt;!-- ${catalina.base}表示Tomcat实例的根目录 --&gt; &lt;property name="log.filePath" value="${catalina.base}/logs/webapp"/&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;property name="log.pattern" value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{55} -%msg%n"/&gt; &lt;!-- 把日志输出到控制台 --&gt; &lt;appender name="consoleAppender" class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47e48d356ecab84ddade3b7b4183fb02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9363658f94901a4156d2977874ec9c8/" rel="bookmark">
			原本就有mysql，安装phpstudy使用里面自带的mysql导致原来的没服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑中之前安装了mysql，正常服务中，但做项目的需要，安装了phpStudy，它里面自带了mysql，启动phpstudy里面的mysql后在用原来的就没服务了，
到电脑管理服务中也没有发现mysql的服务。
那么你要以管理员方式打开dos窗口，进入自己安装的mysql文件夹中进入bin目录，输入：
mysqld.exe -install 出现：Service successfully installed.
接下来启动mysql：
net start mysql 出现：MySQL 服务正在启动 .. MySQL 服务已经启动成功。
然后自己安装的mysql就可以使用了。
转载于:https://www.cnblogs.com/xsmile/p/8642829.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2221298cf69683ce509ccb18e0bc025e/" rel="bookmark">
			如何调试tomcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ 我前面大多数文章都是以Tomcat源代码为基础，分析其某个功能的实现等细节，最近有不少朋友在群里询问怎样调试Tomcat的源码，今天以Tomcat源码为例，来总结下源码调试的方式。
例如问题的处理过程，大致是发现问题，分析问题，解决问题。源码的调试我们简单总结下：
获取源代码
Tomcat的源代码下载方式也比较多
从github上下载(https://github.com/apache/tomcat)
从Tomcat的SVN服务器下载(http://svn.apache.org/repos/asf/tomcat/)
从Tomcat官网下载(http://tomcat.apache.org/download-80.cgi)
每个版本的下载页最下方都会有对应的源码压缩包供下载，如下图
将源码导入IDE
这个工作每个Developer应该都没有问题，我们不过多写这个。
添加依赖
导入到IDE之后，许多文件都会提示红X，提示缺少依赖的jar文件。此时可以通过添加系统中已有的相关文件，如果是此Maven形式组织工程，可以直接添加相应的依赖。
运行应用
这一步需要先找到应用的入口，即Main-Class，之后执行该类即可。当然，有些应用在运行时需要必要的输入参数，Tomcat就需要指定catalina.home。
这类入口应用，可以通过以下方式寻找：
如果应用是以jar文件的形式提供，那么在它的META-INF目录内下会有一个
MANIFEST.MF文件。该文件中可以指定类似如下的内容：
如果jar文件中没指定，或者应用是以脚本的形式启动，可以从脚本中寻找其默认执行的类，例如Tomcat的启动脚本catalina.bat中，就包含这样的内容：
set MAINCLASS=org.apache.catalina.startup.Bootstrap
通过上述方式确定主类之后，根据需要配置相应的VM参数及应用自身的参数，代码就跑起来了。之后根据想要了解的内容，设置断点，开启Debug之旅吧。
以上是通用的步骤，具体到Tomcat，我们来谈一起具体的方式方法。
以工程形式调试
以Eclipse为例
首先创建一个工程Java工程。
导入源码文件，此处可以有如下方式：
全部拷贝进来
以link source方式引入。(右击项目，在build Path中选择Link source)
将已安装的Tomcat的lib下的jar文件添加到项目依赖中，再添加其它需要的jar文件，例如ant.jar
设置主类
设置参数
点击Debug，程序跑起来了，开始调试吧。
以Attach方式调试
新建工程，将源码导入。此时可以把Tomcat以debug的方式启动。为了在第一时间将代码Attach到进程中，需要设置jpda启动后自动暂停，等待应用连接。
可以在脚本文件catalina.bat中直接设置
set JPDA_OPTS=-agentlib:jdwp=transport=%JPDA_TRANSPORT%,address=%JPDA_ADDRESS%,server=y,suspend=%JPDA_SUSPEND%
直接把上面红色内容改成y即可，也可以先在命令行中设置一下
之后执行命令
catalina.bat jpda start
默认的连接端口是8000
之后，项目中直接以远程调试的方式进行即可，
此时即可进行Tomcat的源代码调试，如果在一启动的时候就想跟踪流程，可以先在Bootstrap中增加断点，开始调试吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc997c88de9193f8acf2fd78f25ad40f/" rel="bookmark">
			erlang源码在linux上编译安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上这方面的资料不少，这篇是为了回应上篇，在上篇rabbitmq安装的过程中有个小插曲，我用源码安装了erlang，写下来为了方便以后查看。
1.介绍 erlang是一种编程语言，rabbitmq的运行需要在这个环境中，所以需要安装这个。具体的百度下，百科说的挺详细。
2.环境 系统：Centos7(安装的时候我勾选了开发人员工具) 3.安装过程 源码下载地址： http://erlang.org/download/otp_src_20.0.tar.gz（这个是20.0版的） 从上面的地址下载下来的安装包是这个样子的：
otp_src_20.0.tar.gz 上面的是一个压缩包，用的是gzip压缩和tar打包（从后缀名判断），所以我用下面的命令解压缩（命令看不懂的朋友可以看下鸟哥的Linux私房菜 基础学习篇(第三版)-清晰版 的第九章，写的真心不错，很基础）： tar -zvx -f otp_src_20.0.tar.gz 这个会报错： gzip: stdin: not in gzip format tar: Child returned status 1 tar: Error is not recoverable: exiting now 上面的错误是在说这个文件按不是用gzip的压缩方式压缩的，奇怪了一般的*.tar.gz都是这个按这个压缩方式打包的啊，然后我有试了下用bzip2的解压缩方式解压： tar -jvx -f otp_src_20.0.tar.gz 还是报同样的错误！！！！！！！！！！
这两种一般可以解开大部分压缩包，我就烦躁了，直接打开包看看，估计是没有压缩。
tar -xv -f otp_src_20.0.tar.gz 哈哈哈，果然是这样子，解开了，这个后缀真害人，没有按正常的规矩命名. 下面开始编译准备：
otp源码在linux中编译安装需要对应的编译环境，下面是在线安装便编译环境的命令：
yum install gcc glibc-devel make ncurses-devel openssl-devel autoconf yum install unixODBC unixODBC-devel 我将上面的编译环境安装完成后开始编译： ./configure --prefix=/usr/local/erlang --enable-hipe --enable-threads --enable-smp-support --enable-kernel-poll --without-javac 上面这个是编译配置和检查； 上面的运行如果没有报错的话就可以执行下面的命令了：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc997c88de9193f8acf2fd78f25ad40f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2b1969c9cbe70d94c165f857cd21907/" rel="bookmark">
			遥感图像——几何畸变和几何校正
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 遥感图像数据的级别 遥感图像数据是分级别的。其中， 零级：对应原始数据；一级：经过了初步的辐射校正；二级：经过了系统的几何校正。
1 几何畸变 遥感成像过程中，传感器生成的图像像元相对于地面目标物的实际位置发生了挤压、拉伸、扭曲和偏移等问题。 几何畸变产生的原因：1）传感器内部因素；2）遥感平台因素；3）地球因素。 因为存在几何畸变所以我们提出了几何校正这一应对策略。
2 几何校正 2.1 几何校正的必要性 Q：那为什么几何畸变存在就要几何校正呢？ 这是因为几何畸变会给基于遥感图像的定量分析、变化检测、图像融合、地图测量或更新等处理带来误差，所以需要针对图像的几何畸变进行校正，也就是几何校正。 ———————————————————————————————————— 几何校正说到底就是为了使畸变图像中像元点的位置和基准图像对应的像元在同一个位置，这是最理想的了。但是这个过程一般都会有误差，也就是只能寻求畸变图像大致同基准图像中对应像元的位置一致。
2.2 几何校正的类型 几何精校正需要用到地面控制点做精密校正。 遥感图像的几何校正分为几何粗校正和几何精校正。 几何粗校正是根据产生畸变的原因，利用空间位置变化关系，采用计算公式和取得的辅助参数进行的校正，又称为系统几何校正。 几何精校正是指利用地面控制点做的精密校正。几何精校正不考虑引起畸变的原因，直接利用地面控制点建立起像元坐标与目标物地理坐标之间的数学模型，实现不同坐标系统中像元位置的变换。
2.2.1 根据地面控制点来源的不同，几何精校正可分为图像到图像的几何校正、图像到地图的几何校正和具有已知几何信息的几何校正。 其中图像到图像的几何校正是最常用的一种方式。如图为图像到图像几何校正前的地面控制点的选取，地面控制点在2幅不同的图像上要选在同一个地方。 正如前面描述的几何校正的目的一样，这里选好了地面控制点以后，从该图的实际出发，就是要把畸变图像旋转成基准图像那个样子。
2.3 几何校正的过程 几何校正涉及2个过程：1）空间位置的变换（坐标变换）；2）灰度值的重采样。
2.3.1 几何校正——坐标变换的方式 坐标变换中间接法最为常用 坐标变换有直接法和间接法，直接法是通过原始图像依次计算出每个像元在输出图像中的坐标。虽然直接法输出的像元值大小不会发生变化，但是输出图像中的像元分布不均匀。所以一般正向的推导并不合适。直接法的示意图如下： 而间接法是由输出图像出发，依次计算其中各像元在原始图像中的位置，然后计算原始图像中该位置的像素值。这时可能会出现，计算出的像元点的位置并不是整数，其灰度值可利用其邻近的点的加权来求得。间接法的示意图如下： 该方法能保证校正后图像的像元在空间上均匀分布，但需要进行灰度重采样，间接法最为常用。 总结一下，坐标变换的直接法是原始图像到输出图像，而间接法是输出图像到原始图像。
2.3.2 坐标变换——重采样 重采样的原因正如上面使用间接法提到的那样，因为从输出图像的某像元的位置（行列都是整数的）推导到其在原始图像的位置（行列未必是整数），因为图像中只有行列为整数的时候才有灰度值，这是由图像的本质决定的。而正因为推导时出现如图中红色圈出来的点，我们需要为之赋灰度值。所以才有了灰度重采样来解决这个问题。
2.3.3 地面控制点的选择 坐标变换中地面控制点的选择：1）地面控制点在图像要很明显，2）地面控制点上的地物不随时间而变化，3）在没有做过地形校正的图像上选择控制点就应该在同一地形高度上进行，4）地面控制点应当均匀地分布在整幅图像内，且要有一定的数量保证。 几何校正的结果一般通过地面控制点坐标变换前后的欧氏距离（RMS）来评价。 2.3.4 重采样方法 最近邻法，双线性插值，三次卷积法，依次能产生更加平滑的图像，视觉效果好，但是对于图像光谱信息的保持，会依次减弱。所以如果后续还需要使用重采样之后的图像，比如说用于分类，植被覆盖度计算等，建议使用最近邻法保持光谱信息。 ———————————————————————————————————— 具体来说， 最近邻法的优点是方法简单，处理速度快，不会改变原始栅格的值，但处理后的图像不够平滑。 双线性插值法比最近邻法的结果更加光滑，但是会改变原来的栅格值，且会丢失一些微小的特征。适用于表示某种现象分布、地形表面的连续数据。 三次卷积法能使图像变得平滑，视觉效果好，但是会破坏图像的光谱信息，当不需要再进行基于光谱分析的数据处理，而只是用于制图表达可采用此方法。
正射校正 正摄校正不仅能够实现常规的几何校正的功能，还能通过测量高程点（即点的高度）和DEM来消除地形起伏引起的图像几何畸变，提高图像的几何精度。正射校正的图像具有精确的空间位置。 正射校正的模型如下： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/828de35fa64ebda7e17bd0f73a97cad4/" rel="bookmark">
			关于论文撰写的总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于论文撰写的总结 日期：2018-3-20 地点：甘肃 ⋅ ⋅ 兰州
对于《学术世界》公众号上有关于论文书写的文章，大多部分是关于中文论文上的格式要求或者英文论文的语法要求，但根据我对不同外文期刊或者会议论文的了解，不同的期刊论文的格式不尽相同，可以根据不同的期刊要求做出对应的格式修改即可。因此在本篇论文中不再总结论文撰写的具体细节，而是简单总结一下论文的整体构成及其书写思路。
最近在准备写第一篇小论文，由于非英语本土人士，英文描述表达上可能不符合外文书写要求，需要参考总结外文文献的书写规范。本文是在参考文献《Science research writing for non-native speakers of English》1后写出的一篇小总结。文献2中详尽的阐述了英文论文基本架构、书写的主要思路和英文常用句式语法等，在本文中主要总结论文的基本架构。
一般而言，一篇论文的基本架构如下图所示：
注意到上图的形状，由宽-&gt;窄-&gt;宽。这意味着所开始研究的课题是从一个宽的角度切入，这个角度可以是一个应用或者是一个科学领域，然后再切入到感兴趣的某个/某几个研究点。中间部分是通过设计模型进行实验得到结果的过程。最后是对结果进行总结，同时讨论认为本文可能继续拓展和研究的方向。 接下来，将会对基本框架的各个部分进行概括性的描述，分别是：
摘要（Abstract）引言（Introduction）相关研究（Related work）方法/模型（Methodology/model）实验（Experiments）结论/讨论（Conclusion/Discussion） 摘要 摘要是对全文进行极其精简的概括，令读者对文章有一个初步性的了解。
摘要的基本写法是：
首先肯定所研究的问题的重要性-&gt;现有研究存在不足之处-&gt;对此提出了什么样的方法-&gt;该方法是怎么做的(首先，…；其次，…；然后，…；最后，…)-&gt;实验结果表明你的方法的有效性(具体可表现在某些评判标准上，或者你的结果是state of the art等)。
引言 引言部分是让读者能够了解到论文的思路的开口，一般这一部分是对你所研究的课题上他人所完成的一些成果的概括（前人工作的解决方式的优缺点，如A论文解决了什么，什么待解决。B论文解决了什么，但代价太高，比如性能较差等）。同时，表明你在这个研究课题上所做的工作以及贡献(注意contribution一定要准确清楚地指明出来，但千万不能overclaim)。
引言的基本写法是：
阐述你正在研究的应用或者科学领域下该课题的重要性-&gt;存在的一些问题/现象-&gt;目前相应的一些研究成果-&gt;这些研究成果尚存在的一些待解决的问题-&gt;本文针对该问题进行的研究/提出了一些新的可能的解决方案-&gt;该方法具备的创新之处/贡献之处-&gt;该研究获得了什么样的结果/结论。
相关研究 站在巨人的肩膀之上，能够帮助我们看得更远。当你在做一个热门的问题的时候，必然有许多很好的研究成果已经被发表了，通过阅读文献可以帮助我们了解到什么是对我们有帮助的，同时也是在帮助我们避开已有的研究。
在这一部分，主要是介绍本文涉及的研究方法，在以往有什么样的类似或者经典的工作，比较这些论文，阐述她们各自的优缺点-&gt;进行过渡，本文较以往的工作有何创新之处或者值得研究的地方。
方法/模型 模型和方法这一部分是全文最核心的地方，这一部分的阐述应包含详细有效的细节（包括你自己做的或者利用现有的），能够让读者进行复现并获得近似的结果。
在阐述模型这一部分时，你需要问自己三个问题3：
How do I start the Methodology/Experimentssection? What type of sentence should I begin with?What type of information should be in this section, and in what order?How do I end this section? 针对第一个问题，个人理解为是“总-&gt;分”的形式来阐述，开头用简洁的几句话对完整的模型或者方法进行概括，给人一个总的印象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/828de35fa64ebda7e17bd0f73a97cad4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e54acce6443d2263c70a57306530daa7/" rel="bookmark">
			一个轻量级的分布式定时任务调度平台-Cloudtask
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CloudTask 什么是Cloudtask？
Cloudtask 是一个轻量级的分布式定时任务管理平台，它非常轻量小巧，使用简单，我们可以上传、暂停/启动任务，克隆一个任务，修改任务的执行命令，或者查看任务的调度状态、执行日志，开发人员可以采用自己最熟悉的编程语言来编写任务程序，可以是一个控制台程序，也可以是一段 shell 脚本，上传至平台后设置定时执行规则即可。
设计方案
Cloudtask采用前后端分离设计，后端为无状态服务，通过 `Zookeeper` 实现集群各节点间的发现与协调，节点以心跳方式注册到注册中心，中心服务器统一管理着所有集群，任务调度以集群方式进行分配，具有良好的可扩展性，任务分配信息按集群划分并将分配数据存储到 `Zookeeper` 节点，保持分配数据的一致性。
项目主页
https://github.com/Cloudtask/cloudtask
更多文档
https://cloudtask.github.io/cloudtask
演示地址
http://104.225.159.143:8091
主要特性
- 分布式：采用 `Zookeeper` 实现注册中心，节点与任务分布；
- 跨平台：支持 `Windows` 和 `Linux` 两个平台的部署；
- 任务定时：严格按照任务调度周期执行，同一时间点同一任务只会调度触发一次执行，保持状态一致性；
- 任务控制：可以随时手动启动、停止某一个任务；
- 并行调度：集群中各个节点并行调度本地各自的任务；
- 弹性扩展：节点以环型结构组成集群，加入退出集群更灵活，部分任务会根据节点重新分配；
- 故障转移：当出现节点故障宕机时，为避免集群任务调整抖动，只对故障节点的任务进行转移；
- 运维管理：通过前端站点集中管理所有任务与集群信息，包括用户权限管理；
- 事件通知：若任务执行失败，或集群节点离线，系统会以事件邮件通知运维者；
- 信息收集：节点会将任务执行结果回馈到中心服务器，日志展示更直观；
- 稳定保障：在服务器无波动的情况下，并不会重新分配任务；
组件介绍
- CloudTask InitConfig
- CloudTask Web
- CloudTask Center
- CloudTask Agent
功能预览
前端登录
Dashboard
集群状态
任务列表
License
Cloudtask 基于 Apache Licence 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e54acce6443d2263c70a57306530daa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f709f691cba7dcbe3e68fce824a53dd1/" rel="bookmark">
			为什么拉普拉斯算子具有旋转不变性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.数学证明
2.利用图像证明
可以看出 拉普拉斯算子为周边四个元素和减去中间元素，也可以添加对角的45度方向的，则就是周边8个元素减去中间的元素。但是通常是会用中间元素减去周边元素。可以看出与周边的元素的顺序无关，即旋转不变性
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c706719266f798d738cc7e6a1ef0b29b/" rel="bookmark">
			adb刷机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用adb命令刷机 1. 将下载的adb工具包解压到合适的地方 2. 所在盘空白处按住Shift并右键鼠标，打开命令窗口，跳转到adb文件夹cd 路径\adb 3. 输入adb version回车，显示ADB工具的版本 4. 输入adb devices后，手机解锁BL(bootloader)后序列号没有显示，如果未解锁会返回一串序列号 5. 通过USB端进行ROM刷机包刷机操作
adb sideload &lt;file_location&gt; &lt;file_location&gt;为刷机包所在位置，如果路径较长，可以利用鼠标拖拽安装包，回车即可等待ADB自动完成操作 6. 操作完成后，手机会自动回到recovery主界面，选择reboot system now重启开机 附录 （1）安装apk adb install &lt;apk文件路径&gt;（可拖拽） （2）卸载软件 adb uninstall &lt;软件名&gt; （3）从电脑上发送文件到设备 adb push &lt;本地路径&gt; &lt;远程路径&gt; （4）从设备上下载文件到电脑 adb pull &lt;远程路径&gt; &lt;本地路径&gt; （5）重启到recovery adb reboot recovery （6）重启到fastboot adb reboot bootloader （7）重启手机至系统 adb reboot
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a46ebbfcac1650ba1343a80c80700f6b/" rel="bookmark">
			基于 SpringMVC 的 POST 提交表单出现 405 错误的解决方法之一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象 利用 SpringMVC 后端框架，在页面利用表单 (method="post") 提交数据，结果页面报 405 错误，提示 "Request method 'POST' not supported"。
前提 若以下前提和你的项目不匹配，那解决方案可能不适用于你的项目中哦！
全部前端页面采用 html 文件Spring 4.3.13 版本（低于请更新。啰嗦一句，团队更新框架不仅置入新功能，而且会修复旧版本的bug，Spring框架的mvn仓库网址）Controller 类用到 @Controller 和 @RequestMapping 注解 实验 为了方便理解，ViewResolver的后缀先设为空： /resource/html/文件夹内容： Controller 类代码： first.html 页面的表单代码 步骤重现 往地址栏中输入 http://……（省略）/myProfile/setting，在表单处输入数据。数据会被发送至 registerUser 方法并处理。 （数据被成功传输至后台，证明 System.out.println(user); 之前并无出错）
3. 无法跳转至 first.html，并报 405 错误。
分析 由于使用的是 html 文件，它并不支持响应头带有 post 的应答包，所以会报错。
解决方案
若条件允许，使用 jsp 等能够接收 post 应答包的页面文件。（快捷，但不建议，jsp 会增加前后端耦合）使用 “redirect:映射路径”进行跳转： 以上两种方案皆可完成跳转，并正常运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c792d66a2f4925c183a0ee93ca6c9c5/" rel="bookmark">
			特征点检测FAST算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.FAST基本算法 用一句话来讲FASTN算法的原理就是：若一个像素周围有一定数量的像素与该点像素值不同，则认为其为角点。步骤如下： 1）在图像中任选一点p， 假定其像素（亮度）值为 Ip 2）以r为半径画圆，覆盖p点周围的M个像素，如下图所示: r=3， M=16 3）设定阈值t，如果这周围的16个像素中有连续的N个像素的像素值减去 Ip−t 或者有连续的N个像素都大于 Ip+t ， 如果t=0，那么就可以理解为：有连续N个像素大于或小于Ip的灰度值。那么这个点就被判断为角点。 由于在检测特征点时是需要对图像中所有的像素点进行检测，然而图像中的绝大多数点都不是特征点，如果对每个像素点都进行上述的检测过程，那显然会浪费许多时间，因此论文中采用了一种进行非特征点判别的方法。如上图中，对于每个点都检测第1、5、9、13号像素点，如果这4个点中至少有3个满足都比 Ip+t Ip+t
大或者都比 Ip−t Ip−t
小，则继续对该点进行16个邻域像素点都检测的方法，否则则判定该点是非特征点（也不可能是角点，如果是一个角点，那么上述四个像素点中至少有3个应该和点相同），直接剔除即可。 这种做法在大幅减少了判断特征点的运算量，提升了算法的运行速度。但是还是存在一些问题，如下： （1）当我们使用的 n&lt;12 n&lt;12
时就不能通过上面说明的方法对非角点进行快速过滤； （2）这样检测出来的特征点不是最优的，因为这种检测方法暗含了对特征周围的像素分布的假定； （3）忽略了上述的前4个检测的结果分析； （4）检测得到的特征点容易挤在一起。 2.非极大值抑制
针对算法(4)的缺点：很可能大部分检测出来的点彼此之间相邻，我们要去除一部分这样的点。为了解决这一问题，可以采用非最大值抑制的算法：假设P，Q两个点相邻，分别计算两个点与其周围的16个像素点之间的差分和为V，去除V值较小的点，即把非最大的角点抑制掉。
3.基于机器学习的特征点检测算法
针对（1)(2)(3)的缺点：作者使用机器学习的特征点检测方法，这种检测方法解决了上面的前3个问题
具体算法如下：
首先选取你进行角点提取的应用场景下很多张的测试图片。运行FAST角点检测算法来获取测试图片集上的所有角点特征。对于每个角点，我们把它邻域圆上的16个点存储下来保存在一个vector内，处理所有步骤2中得到的角点，并把它们存储在 P P中。对于图像上的点 p p,它周围邻域圆上位置为 x,x∈{1…16} x,x∈{1…16}的点表示为 p→x p→x，可以用下面的判断公式将该点 p→x p→x分为3类： Sp→x=⎧⎩⎨⎪⎪d,s,b,Ip→x≤Ip–tIp−t≤Ip→x&lt;Ip+tIp+t≤Ip→x(darker)(similar)(brighter) Sp→x={d,Ip→x≤Ip–t(darker)s,Ip−t≤Ip→x&lt;Ip+t(similar)b,Ip+t≤Ip→x(brighter) 设 P P为训练图像集中所有像素点的集合，我们任意16个位置中的一个位置 x x，可以把集合 P P分为三个部分 Pd,Ps Pd,Ps和 Pb Pb，其中 Pd Pd的定义如下， Ps Ps和 Pb Pb的定义与其类似 Pb={p∈P:Sp→x=b} Pb={p∈P:Sp→x=b} 换句话说，对于任意给定的位置 x x，它都可以把所有图像中的点分为三类，第一类 Pd Pd包括了所有位置 x x处的像素在阈值 t t下暗于中心像素，第二类 Ps Ps包括了所有位置 x x处的像素在阈值 t t下近似于中心像素， Pb Pb包括了所有位置 x x处的像素在阈值 t t下亮于中心像素。定义一个新的布尔变量 Kp Kp，如果 p p是一个角点，那些 Kp Kp为值，否则为假。使用ID3算法（决策树分类器）来查询每一个子集。递归计算所有的子集直到 Kp Kp的熵为0;被创建的决策树就用于于其他图片的FAST检测。 那么问题来了，什么样角度的角点都能检测到吗？如下图：有三种角点，分别是45°角，90°角和135°角。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c792d66a2f4925c183a0ee93ca6c9c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35debe6beb0ffbc1a7608d5fd04fe941/" rel="bookmark">
			LeetCode 56. Merge Intervals（合并重叠区间）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：
Given a collection of intervals, merge all overlapping intervals. For example, given [1,3],[2,6],[8,10],[15,18], return [1,6],[8,10],[15,18].
分析：
题意：给出一些整型区间集合，返回合并重叠区间之后的结果。
思路：这是一道经典的贪心算法作业调度问题的变种，关键是把所有区间（[start, end]）根据end进行从小到大排序。之后进行如下操作：
① 对于第i个区间（i属于1→n - 1）分别跟第j个区间（j属于i - 1→0）逆序进行比较。Ⅰ. 如果i区间的start小于等于j区间的end，说明存在重叠现象，我们更新i区间的start为i、j两区间的start较小值，同时把j区间的start、end均置为-1（[-1, -1]表示该区间已经被合并，不复存在）；Ⅱ. 如果i区间的start大于j区间的end，说明没有重叠，跳出当前比较循环。
② 比较所有i区间（i属于1→n - 1）之后，我们遍历一遍0→n - 1，把所有不是[-1, -1]的区间加入答案中，并返回。
代码：
#include&lt;bits/stdc++.h&gt; using namespace std; struct Interval{ int start; int end; Interval(): start(0), end(0){} Interval(int s, int e): start(s), end(e){} }; // sort + greedy class Solution { private: static int cmp(const Interval a, const Interval b){ if(a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35debe6beb0ffbc1a7608d5fd04fe941/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d3d5ea8e72874c5dbd1bc0e70da7eb8/" rel="bookmark">
			ARM指令:BIC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rd, Rn, Oprand2 BIC（位清除）指令对 Rn 中的值 和 Operand2 值的反码按位进行逻辑“与”运算。 (注意:ARM官方网站有误, 写的是补码) BIC 是 逻辑”与非” 指令, 实现的 Bit Clear的功能 举例: BIC R0, R0 , #0xF0000000
将 R0 高4位清零 BIC R1, R1, #0x0F
将R1 低4位清0 RSB 反向减法 Rn, Operand2 RSB（反向减法）指令可从 Operand2 中的值减去 Rn 中的值。 这是很有用的，因为有了该指令，Operand2 的选项范围就会更大。 例如: RSB r4, r4, #1280 从1280中减去 R4 RSB R4, R0, #0×46 从0×46 中 减去 R0, 放入R4 转自zyn919的博客：http://blog.csdn.net/yueniaoshi/article/details/7578714
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54d850f7a01326bd40f279dac933689a/" rel="bookmark">
			ADS软件的使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ADS2015软件使用教程——数据导出方法 1.打开软件 2.新建工作站 3 新建工程界面，选择NEXT 4 先给新的工作站起个名字，然后选择NEXT 5 然后选择工作站中所用的库，这里我选择了模拟/射频库，然后选择NEXT 6 这里还可以修改工作站名字，我这里修改成123了，选择NEXT 7 这里选择最小尺寸，然后选择NEXT 8 然后选中Finish 9 进入工作站后，点击鼠标右键，然后选择New Schematic 10 然后建立Cell，这里取名：123，然后点击OK 11 进入新建Cell，选择库，在相应的库中选择需要的元器件 12 选择适合的库，然后搭建需要的仿真电路 13 电路搭建好后，选择仿真元件 14 仿真电路结果曲线，选择了曲线图显示 15 按图中顺序操作 16 选择OK 17.需要将构成曲线的具体参数导出来 按下面的操作进行： 首先将曲线图选中，然后选择File，然后选择Export，然后选择Write selected。。。
18 导出处.TXT文件 END
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1416cab8069082c1f5a0a8f593c02434/" rel="bookmark">
			解决Driver/library version mismatch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器更新nvidia driver 版本之后，经常会出现
1 Failed to initialize NVML: Driver/library version mismatch.&lt;br&gt; 这个问题出现的原因是kernel mod 的 Nvidia driver 的版本没有更新，一般情况下，重启机器就能够解决，如果因为某些原因不能够重启的话，也有办法reload kernel mod。
简单来看，就两步
unload nvidia kernel modreload nvidia kernel mod 执行起来就是
sudo rmmod nvidia sudo nvidia-smi nvidia-smi 发现没有 kernel mod 会将其自动装载。
但是事情远远不是这么简单，一般情况下都会遇到卸载失败。
1 2 $ sudo rmmod nvidia rmmod: ERROR: Module nvidia is in use by: nvidia_modeset nvidia_uvm 这时，就要一点一点的卸载整个驱动了，首先要知道现在kernel mod 的依赖情况，首先我们从错误信息中知道，nvidia_modeset nvidia_uvm 这两个 mod 依赖于 nvidia, 所以要先卸载他们
1 2 3 4 5 $lsmod | grep nvidia nvidia_uvm 647168 0 nvidia_drm 53248 0 nvidia_modeset 790528 1 nvidia_drm nvidia 12144640 152 nvidia_modeset,nvidia_uvm 12144640 152 nvidia_modeset,nvidia_uvm 可以看到 nvidia 被使用了152词，我们可以先卸载 nvidia_uvm 和 nvidia_modeset
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1416cab8069082c1f5a0a8f593c02434/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93ed34801caa9d195447254ef9ec4028/" rel="bookmark">
			python安装OpenCV后import cv2报错解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在python安装完成后，运行pip install opencv-python安装成功后，import cv2时会失败
看到有人给出下载https://www.lfd.uci.edu/~gohlke/pythonlibs/中的wheel包后再用pip安装，但是我发现还是会失败！
最好的解决办法是，先下载对应python版本的anaconda，然后在anaconda文件的scripts目录下用pip 安装 wheel文件，然后把anaconda的安装路径加入到环境变量中
最后在IDE中将python解释器指向anaconda中的python路径，最后就完美的安装成功了！
转载于:https://www.cnblogs.com/robert-zhang/p/8618301.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb9f89b6470caafc62a1b09769b7bc82/" rel="bookmark">
			jQuery获取链接参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 公司前端页面，之前公司前端竟然是用split函数分割链接来获取参数，真的无语了，这完全是没理解链接是干嘛的呀
搜了一个用正则匹配获取参数的方法
上代码： //获取url中的参数 function getUrlParam(name) { var reg = new RegExp("(^|&amp;)" + name + "=([^&amp;]*)(&amp;|$)"); //构造一个含有目标参数的正则表达式对象 var r = window.location.search.substr(1).match(reg); //匹配目标参数 if (r != null) { return unescape(r[2]); } return null; //返回参数值 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2a5a4d1d0f0fa59a5e2febe890a1f03/" rel="bookmark">
			不可重复读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 不可重复读 编辑 本词条缺少 信息栏、 名片图，补充相关内容使词条更完整，还能快速升级，赶紧来 编辑吧！ 不可重复读，是指在数据库访问中，一个 事务范围内两个相同的查询却返回了不同数据。 这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。 一种更易理解的说法是：在一个事务内，多次读同一个数据。在这个事务还没有结束时，另一个事务也访问该同一数据。那么，在第一个事务的两次读数据之间。由于第二个事务的修改，那么第一个事务读到的数据可能不一样，这样就发生了在一个事务内两次读到的数据是不一样的，因此称为不可重复读，即原始读取不可重复。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/112579e55e553e53199dc342526b1f97/" rel="bookmark">
			Ftp上传常见错误和解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ftp连接常见问题
Ftp 是管理维护网站资料 的重要手段,经常有一些客户提出Ftp上传的疑问.现在总结常见错误和解决方案如下(以FlashFxp为例)
1. Ftp服务器连接失败，分为以下四种情况。
a).连接被拒, 错误信息如下:
[右] 正在连接到 www.chumoshu.com -&gt; DNS=www.chumoshu.com IP=218.13.164.102 PORT=21[右] 连接失败 (连接被拒)
原因:这是因为客户在作Ftp上传时 填写错了Ftp服务器造成这个问题.解决:在Ftp上传时记得一定要使用我司的Ftp服务器(例如www.7428.com.cn等)
b).FTP用户登入失败 错误信息如下:
[右] 正在连接到 www.7428.com.cn -&gt; DNS=www.7428.com.cn IP=211.155.224.184 PORT=21[右] 已连接到 www.7428.com.cn (Ftp服务器连接成功)[右] 220 Serv-U FTP Server v6.2 for WinSock ready...[右] USER test [右] 331 User name okay, need password.[右] PASS (隐藏)[右] 530 Not logged in.
原因:这是用户填写错误的FTP服务器、Ftp用户名/或Ftp密码解决:请您核对您的Ftp 信息（开通空间时，系统会把FTP信息发到你邮箱里，你可以查看一下邮件）。如果您忘记Ftp密码。可以在“用户中心－－－虚拟主机管理－－－控制面板”里重设Ftp密码。
c).用户本地上网问题，错误信息如下（下面以s501.72dns.com这台服务器为例）:
无法解析主机：www.7428.com.cn
C:\&gt;ping www.7428.com.cnPing request could not find host s501.72dns.com.please check the name and try again.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/112579e55e553e53199dc342526b1f97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10f311914919a636e36b1d8ea8cc2807/" rel="bookmark">
			Weakly Supervised Action Localization by Sparse Temporal Pooling Network
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要
我们提出了一种使用卷积的未修剪视频的弱监督时间动作定位算法 神经网络。我们的算法预测给定视频级别标签的人类动作的时间间隔，而不需要动作的时间定位信息。 这个目标是通过提出一种新颖的深度神经网络来实现的，该网络通过视频片段的自适应时间汇集来识别动作并识别与动作相关联的稀疏关键片段集合。我们设计网络的损失函数包含两个术语 - 一个用于分类错误，另一个用于选定片段的稀疏性。在识别出针对关键段的稀疏关注权重后，我们使用时间类激活映射来提取时间提议，以估计本地化目标操作的时间间隔。所提出的算法在THUMOS14数据集上达到了最先进的精度，并且即使在监控能力较弱的情况下也能在ActivityNet1.3上表现出色。 1.介绍
视频中的动作识别是诸如事件检测，视频摘要，视频中的视觉问题回答等任务所必需的高级视频理解的关键问题。许多研究人员在过去的几十年中一直在广泛研究这个问题。行动认可的主要挑战是缺乏适当的视频表示方法。与卷积神经网络（CNNs）在与图像相关的许多视觉识别任务中几乎立竿见影的成功相反，由于数据的固有复杂结构，高计算量，缺乏建模知识 时间信息等等。这个问题意味着基于深度学习的表示方法[15,25,31,36]并不比依靠手工制作视觉特征的方法好得多[18,32,33]。因此，许多现有的算法试图通过结合手工和学习功能来实现最高水平的性能。 这个问题的另一个问题是缺乏视频理解所需的注释。大多数现有技术都假设视频级分类的修剪视频，或者依赖动作间隔的注释来进行时间定位。由于未修剪的视频通常包含与其类别标签有关的大量不相关的帧，因此视频表示学习和动作分类可能会因从原始视频中提取显着信息而面临挑战而失败。另一方面，注释大规模数据集以进行动作检测的代价非常昂贵且耗时，使得开发具有这种标签运行的竞争性算法更加实用。 我们的目标是暂时将未修剪的视频中的操作本地化。为此，我们提出了一种新的深层神经网络，它能够选择对动作识别有用的帧稀疏子集，其中损失函数测量每个视频中帧选择的分类错误和稀疏性。对于本地化，采用时间类激活映射（THE-CAM）来生成一维时间动作提议并计算目标动作在时间域中的定位。请注意，我们不会在训练过程中利用目标数据集中的任何时间信息，并仅根据视频级的动作类标签来学习模型。 我们的算法概述如图1所示。 图1： 我们的算法针对视频采用双流输入 - RGB和光流 - 并行执行动作分类和定位。 为了进行本地化，从两个流计算时间类激活映射（T-CAM）并用于生成一个从时域定位目标动作的时间动作提议。 这篇文章的主要贡献:
•我们引入了原理性深层神经网络架构，用于对未修剪的视频进行弱监督动作识别和定位，其中从网络识别的稀疏子帧中检测动作。
•我们提出一种技术来计算时间类激活映射，然后使用学习的注意力权重对时间动作建议进行本地化目标动作。
•所提出的弱监督动作定位技术在THUMOS14 [14]上实现了最新的准确性，并在ActivityNet1.3 [12]的首次公开评估中表现出色。
本文的其余部分安排如下。 我们在第2节中讨论相关工作，并在第3节中描述我们的动作局部化算法。第4节介绍了我们的实验的细节，第5节总结本文
2相关工工作 (略)
3 Proposed 算法
我们仅基于视频级动作标签描述了我们的弱监督时间动作定位算法。这个目标是通过设计一个基于稀疏子段的视频分类的深度神经网络和识别与目标类别相关的时间间隔来实现的。
3.1大致想法
我们声称可以通过识别一系列呈现重要动作组件的关键片段来从视频中识别动作。我们的算法提出了一种新颖的深度神经网络，使用一组具有代表性和独特的片段来预测每个视频的类别标签，以针对从输入视频自动选择的动作。请注意，所提出的深层神经网络是为分类而设计的，但能够测量每个分段在预测分类标签中的重要性。在每个视频中查找相关类别之后，我们通过计算各个片段的时间关注度，生成时间行为建议，以及汇总相关建议来估计与所标识的动作相对应的时间间隔。我们的方法仅依赖于视频级别标签来执行时间动作本地化，并提供了一种方法来提取关键段并确定与目标动作相对应的适当时间间隔。使用我们的框架，可以在单个视频中识别和本地化多个操作。图2说明了我们的弱监督动作识别组件的深层神经网络架构。我们描述了我们的算法的每个步骤如下。 图2：我们的弱监督时间动作定位的神经网络架构。 我们首先使用预训练网络从一组均匀采样的视频片段中提取特征表示。 注意模块生成对应于各个特征的注意力权重，这些特征被用于通过时间加权平均池合计算视频级表示。 该表示被赋予分类模块，并且在这个注意权重向量上施加l1损失来强制执行稀疏约束。
3.2. Action Classification
为了预测每个视频中的类别标签，我们首先从输入视频中采样一组视频片段，并使用预训练的卷积神经网络从每个片段提取特征表示。 然后将这些表示中的每一个呈现给由两个全连接（FC）层和位于两个FC层之间的ReLU层组成的注意模块。 第二个FC层的输出被赋予一个S形函数，迫使生成的注意力权重在0和1之间归一化。然后使用这些注意力权重调整时间平均池 - 特征向量的加权总和 - 创建视频级别表示。 我们通过FC和S形图层传递这个表示来获得分类分数。 形式上，Xt∈Rm是从时间t中心的视频片段提取的m维特征表示，λt是相应的关注权值。 视频等级表示（由表示）对应于注意加权时间平均池，这是由公式：
其中λ = (λ1, . . . , λT )T是来自sigmoid函数的标量输出的矢量以标准化激活范围，并且T是为分类而配置的视频段的总数。 注意力权重向量λ以类不可知的方式用稀疏性约束来学习。这有助于识别与任何感兴趣的动作相关的时间片段并估计动作候选者的时间间隔。
该网络中的损失函数由分类损失和稀疏损失两个项组成。
其中Lclass表示在视频级别上计算的分类损失，稀疏性是稀疏损失，β是控制这两个项之间的权衡的常数。分类损失是基于ground-truth和之间标准的多标签交叉熵损失（经过如图2所示的几个层次之后），而稀疏损失则由l1注意力损失权重为||λ|| 1。由于我们对每个注意权重λt都应用了一个Sigmoid函数，所有的注意权值都可能有接近0-1的二进制值，这是由于“l1损失”造成的。请注意，集成稀疏损失与我们声称可以通过视频中关键段的稀疏子集识别动作是一致的。
3.3. Temporal Class Activation Mapping 为了确定与目标事件相对应的时间间隔，我们首先提取一些行动间隔候选。 基于[46]中的想法，我们推导出时间域中的一维类激活映射，称为时间类激活映射（T-CAM）。 通过Wc(k)表示分类模型参数w中的第k个元素，对应于类c。类c的最后sigmoid层的输入是
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10f311914919a636e36b1d8ea8cc2807/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fea2b7f3511542e502bbf017ee3b97c/" rel="bookmark">
			正则表达式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.“/”是定界符，“/”定界符之间的部分就是将要在目标对象中进行匹配的模式。同时为了正则更加灵活，引入了元字符，即“+”， “*”，以及 “?”。
（1）“+”元字符规定其前导字符必须在目标对象中连续出现一次或多次
比如：/php+/，能够与“phpp”匹配，即字母ph后面连续出现一个或多个字母p的字符串相匹配。
（2）“*”元字符规定其前导字符必须在目标对象中出现零次或连续多次
比如：/php*/能够与“phpddt”相匹配，即ph后面可以有0个或多个p
（3）“?”元字符规定其前导对象必须在目标对象中连续出现零次或一次。
比如：/php?/能够“pher”匹配，即phh后面可以有0个或者1个p
其他重要的元字符：
\s：用于匹配单个空格符，包括tab键和换行符；
\S：用于匹配除单个空格符之外的所有字符；
\d：用于匹配从0到9的数字；
\w：用于匹配字母，数字或下划线字符；
\W：用于匹配所有与\w不匹配的字符；
. ：用于匹配除换行符之外的所有字符。
示例：/\s+/用于匹配目标对象中的一个或多个空格字符
2.定位符用于规定匹配模式在目标对象中的出现位置。常用的有“^”, “$”, “\b” 以及 “\B”
(1)“^”定位符规定匹配模式必须出现在目标字符串的开头
(2)“$”定位符规定匹配模式必须出现在目标对象的结尾
(3)\b定位符规定匹配模式必须出现在目标字符串的开头或结尾的两个边界之一
(4)“\B”定位符则规定匹配对象必须位于目标字符串的开头和结尾两个边界之内
3.php的正则匹配模式非常灵活，可以指定某一范围 例如：
/[A-Z]/
上述正则表达式将会与从A到Z范围内任何一个大写字母相匹配。
/[a-z]/
上述正则表达式将会与从a到z范围内任何一个小写字母相匹配。
/[0-9]/
上述正则表达式将会与从0到9范围内任何一个数字相匹配。
/([a-z][A-Z][0-9])+/
上述正则表达式将会与任何由字母和数字组成的字符串
4.可以同时与多种模式选择匹配
如/phpddt.com|phpddt|100/可以与“phpddt.com” “phpddt” “100”相匹配
5.否定符 “[^]”规定目标对象中不能存在模式中所规定的字符串
例如:[^phpddt]匹配除了phpddt字符外的所有东西。
正则表达式常用函数吧！（非常重要）
&lt;?php //preg_match("正则表达式","字符串")用于在字符串中查找匹配项 $email = "987047679@qq.com"; if (preg_match("/^([a-zA-Z0-9])+([.a-zA-Z0-9_-])*@([.a-zA-Z0-9_-])+([.a-zA-Z0-9_-]+)+([.a-zA-Z0-9_-])$/",$email)){ echo '匹配成功&lt;hr /&gt;'; }else { echo '匹配失败&lt;hr /&gt;'; } //preg_quote("字符串") 在每个有正则表达式语法前面加入一个转义字符即\ $str = "php点点通是一个学习php的网站，(⊙o⊙)…"; echo preg_quote($str); echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fea2b7f3511542e502bbf017ee3b97c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f33cd4528a133c8f4a3ab47622b67b24/" rel="bookmark">
			return语句的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果在while循环和if语句中return会导致循环中断 return语句用于退出函数，向调用方返回一个表达式。
return在不带参数的情况下（或者没有写return语句），默认返回None。
None是一个特殊的值，它的数据类型是NoneType。NoneType是Python的特殊类型，它只有一个取值None。
它不支持任何运算也没有任何内建方法，和任何其他的数据类型比较是否相等时永远返回false，也可以将None赋值给任何变量。。。
执行到return语句时，会退出函数，return之后的语句不再执行。但将return语句放在try语句块中，是个例外。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd90da321368abf2434af310d4a7304d/" rel="bookmark">
			VMware-workstation14下安装centos6.4系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备工作：
虚拟机：VMware-workstation14，
centos版本：CentOS-6.4-x86_64-minimal.iso
下载地址：点击打开链接
VMware-workstation14下安装centos6.4系统
打开已经安装好的虚拟机：
然后开启虚拟机，开始安装系统：
配置主机名和网络配置：这里设置网络自动连接则虚拟机就自动配置了网络连接方式为：
设置主机名和网络配置：注意这里设置网络连接为自动连接，则虚拟机的网络设置为NAT模式(这样的好处就是设置了永久IP地址，当你在公司使用的网络，回家用是无线网络，这自动连接获得的IP地址保存不变)
到处系统安装完成，并测试能正常登录
注意：因为在上诉安装中选择了配置网络，模式为自动连接故查看下网络连接：默认设置了NAT模式网络
通过命令查看下网络IP地址：自动分配了192.168.174.128IP地址(该IP地址为用永久静态IP地址)
网络连接方式说明：
桥接模式：是连接真实网络地址
NAT模式：是连接VMware Network Adapter VMnet8网络，该模式既可以连接VMware虚拟网络也可以连接真实网络
仅主机模式：是连接VMware Network Adapter VMnet1网络，该模式只能连接本地虚拟网络
本地测试网络连接是否正常：cmd命令下，如下截图表示网络连接正常
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8615dfaf1eeb8769188470066c3a40c/" rel="bookmark">
			小知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 xml布局里需要将textview的下面属性设置下：
android:ellipsize="end" android:singleLine="true" 其中： android:ellipsize=”start”—–省略号显示在开头 android:ellipsize=”end”——省略号显示在结尾 android:ellipsize=”middle”—-省略号显示在中间 " android:ellipsize=”marquee”–以横向滚动方式显示(需获得当前焦点时) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21cad3e8dcad6682ae01a7f5b4927aa9/" rel="bookmark">
			MySQL case when 用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 的 case when 的语法有两种：
简单函数
CASE [col_name] WHEN [value1] THEN [result1]…ELSE [default] END搜索函数
CASE WHEN [expr] THEN [result1]…ELSE [default] END 这两种语法有什么区别呢？
简单函数 CASE [col_name] WHEN [value1] THEN [result1]…ELSE [default] END： 枚举这个字段所有可能的值*
SELECT NAME '英雄', CASE NAME WHEN '德莱文' THEN '斧子' WHEN '德玛西亚-盖伦' THEN '大宝剑' WHEN '暗夜猎手-VN' THEN '弩' ELSE '无' END '装备' FROM user_info; 搜索函数 CASE WHEN [expr] THEN [result1]…ELSE [default] END：搜索函数可以写判断，并且搜索函数只会返回第一个符合条件的值，其他case被忽略
# when 表达式中可以使用 and 连接条件 SELECT NAME '英雄', age '年龄', CASE WHEN age &lt; 18 THEN '少年' WHEN age &lt; 30 THEN '青年' WHEN age &gt;= 30 AND age &lt; 50 THEN '中年' ELSE '老年' END '状态' FROM user_info; 聚合函数 sum 配合 case when 的简单函数实现多表 left join 的行转列 注：曾经有个爱学习的路人问我，“那个sum()只是为了好看一点吗？”，left join会以左表为主，连接右表时，得到所有匹配的数据，再group by时只会保留一行数据，因此case when时要借助sum函数，保留其他列的和。如果你还是不明白的话，那就亲手实践一下，只保留left join看一下结果，再group by，看一下结果。例如下面的案例：学生表/课程表/成绩表 ，三个表left join查询每个学生所有科目的成绩，使每个学生及其各科成绩一行展示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21cad3e8dcad6682ae01a7f5b4927aa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/127561f91b4a2f210625e4140948c24e/" rel="bookmark">
			vb.net限制文本框只能输入数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编制计算类程序时文本框一般都用于输入数字数据，此时可以通过以下步骤来确保用户输入数据的正确性：
首先添加好文本框控件TextBox后把属性IMEMode的值改成Disable，这样在该文本框中就不能使用中文输入法了。然后对文本框的KeyPress事件添加以下代码
Private Sub TextBox1_KeyPress(ByVal sender As Object, ByVal e As System.Windows.Forms.KeyPressEventArgs) Handles Textbox1.KeyPress If Char.IsDigit(e.KeyChar) Or e.KeyChar = Chr(8) Then e.Handled = False Else e.Handled = True End If End Sub 其中e.KeyChar是键盘输入的键对应的字符，IsDigit函数可以判断是否为0到9的数字，Chr(8)为退格键，当e.Handled为True时，程序认为该KeyPress事件已经被处理过了，文本框的内容也就不会发生变化了。从以上程序中不难看出，此时文本框只能接受数字和退格键，也就是说这个文本框是用来输入整数的。
如果文本需要输入小数的话，就要能够输入小数点"."，而且小数点只能输入一次，此时可以将上面的函数改为下面的格式：
Private Sub TextBox1_KeyPress(ByVal sender As Object, ByVal e As System.Windows.Forms.KeyPressEventArgs) Handles Textbox1.KeyPress If Char.IsDigit(e.KeyChar) or e.KeyChar = Chr(8) or e.KeyChar = "." Then If e.KeyChar = "." And InStr(TextBox1.Text, ".") &gt; 0 Then e.Handled = True Else e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/127561f91b4a2f210625e4140948c24e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f10b246d604e3d38f128f21c2bd62a83/" rel="bookmark">
			简单又实用的外链发布平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一、友谊链接 1、手动友谊链接 所谓手动友谊链接就是应用工夫进行网站与网站间的进行交流友谊链接，个中相关交流友谊链接的细节可以参照文章“交流友谊链接的规范准则”进行交流相关友谊链接，由于友谊链接交流太多会招致网站权重导出太大，所以到达必然数目时就中止交流，还交流友谊链接时不要一天交流太多，细水长流才是网站优化之道。 2、自助友谊链接 当前有良多网站树立了相关主动友谊链接平台，我不太看好，毕竟那是吃亏的工作。 3、链接交流平台 0460友谊链接平台、go9go友谊链接平台、ZlinkZ站链站、友谊链接平台、渝海友谊链接平台、365友谊链接交流平台、admin5、友谊链接平台等。 https://www.7428.com.cn 第二、博客外链发布 博客类网站、新浪博客、网易博客、博客网、搜狐博客、腾讯博客、和讯博客、51博客、博客大巴、凤凰博报、天际博客…… 第三、贴吧外链发布 百度贴吧、搜狗说吧、天际来吧。 第四、空间外链发布 百度空间、51空间。 第五、问答外链发布 最为知名的就是百度晓得相关百度晓得操作运用可以参考前几天总结的相关文章“若何应用百度晓得进行网站优化”，搜搜问问、雅虎常识堂、天际问答、新浪喜欢问、搜狗问答。 第六、类书签珍藏外链发布 如：百度搜藏、雅虎珍藏、乐收、好网角、QQ书签、新浪书签、世界之窗、收集珍藏夹、115珍藏夹、360口袋、新浪ViVi珍藏夹、百度搜藏、和讯部落、Digg、Teein帖易中文聚合门户、抓虾、共享书签、新摄影、乐收、高兴珍藏家、365Key、Diglog、收客网、趣摘网、人人网、Web2.0周刊、协客、收集书签、中国发掘、骨头统录网、新闻小分队、麦布查找引擎、易游inu-社会化收集珍藏夹、无聊吧、纯我、我们的收集珍藏夹、一览、Hellodigi、结易思然–jecio博客摘客、央库*专注于珍藏、图书漂流网、广聚网、天天画报、火柴网、英语网摘、逗摘、咚咚网、我地皮、千签网、newhots、Flinkr、世界图摘、我摘、MyShare、美娃~西西、葫芦藤、10ask、揭阳红亭社区、每日导航网、迪格网、天极网摘、站长网摘) https://sports.5420.com.cn　第七、论坛外链发布 就是人人都在做而且有效的论坛类相关整顿如：站长买卖论坛、掉队站长论坛、站长论坛、中国站长网、好站长网、站长论坛、站长论坛、天极论坛、迅雷论坛、我要啦计算、阿里妈妈论坛、站长交流、上海站长论坛、站长论坛、牛站长论坛、站长论坛、草根网论坛、中国小我站长论坛、我拉网论坛、动网官方论坛、傲游论坛、能做的论坛多只又多，然则好的发上去不删贴的这个需求人人渐渐去发现。当然最好论坛外链发布要数当局网站论坛了，由于那边面没什么人治理权重还高. 第八、信息平台外链发布 比方58同城、慧聪、赶集、等B2B信息类型网站特殊是权重高有跟相关查找引擎协作的网站。 第九、目次网站外链发布 说真话当前我的网站还没有经过相关的目次收录，这块比拟难审核比拟紧所以假如通但是照样少花点工夫在这里。如：DMOZ、Yahoo目次、第一摘网站目次、Coodir、傻目次、孙悟空提交、SEEK114、迪优网提交、中文分类目次 第十、社交收集外链发布 分享网站、校内网、百度博客收录提交、谷歌博客收录提交、雅虎博客收录提交、搜搜博客收录提交、搜狗博客收录提交、新浪喜欢问博客收录提交、新浪博客更新告诉提交、有道博客收录提交、奇虎博客收录提交、奇虎博客更新告诉提交、中文RSS查找收录提交、Icerocket博客提交进口、中文RSS查找引擎。
https://www.7428.cn
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4058fa65eab96382b092c1f10ae3449/" rel="bookmark">
			ubuntu安装lxml
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu安装lxml，可以参考一下
先执行
sudo apt-get install libxml2-dev libxslt-dev python-dev
然后执行
sudo easy_install lxml
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60338a5a58354680d0ee746c3efeba8d/" rel="bookmark">
			java垃圾收集器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		堆中几乎存放着Java世界中所有的对象实例，垃圾收集器在对堆进行回收前首先要确定哪些对象还活着，哪些对象已经死去。
1，判断对象是否已死 1.1引用计数算法 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1，当引用失效时，计数器就减1；任何时刻计数器都为0的对象是不可能在被使用的。
引用计数算法无法对象之间循环引用的问题。
1.2 根搜索算法 通过一系列名为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索走过的路径称为引用链（Reference Chain）,当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
在Java中，下面几种对象可以作为GC Roots：
虚拟机栈（栈帧中的本地变量表）中引用的对象；方法区中类静态属性引用的对象；方法区中常量引用的对象；本地方法栈中JNI（即Native方法）引用的对象； 1.3 java中的引用类型 有强到弱分为强引用（Strong Reference）,软引用（Soft Reference），弱引用(Weak Reference)和虚引用(Phantom Reference) 四种。
强引用（Strong Reference）：就是指在程序代码中普遍存在的，类似Object obj = new Object()这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 强引用具备以下三个个特点：
1. 强引用可以直接访问目标对象；
2. 强引用所指向的对象在任何时候都不会被系统回收。JVM宁愿抛出OOM异常也不回收强引用所指向的对象； 3. 强引用可能导致内存泄露；
软引用（Soft Reference）：是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 JDK 1.2 之后，提供了 SoftReference 类来实现软引用。弱引用(Weak Reference)： 用来描述非必须的对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发送之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。一旦一个弱引用对象被垃圾回收器回收，便会加入到一个注册引用队列中。在 JDK 1.2 之后，提供了 WeakReference类来实现弱引用。 软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。
虚引用(Phantom Reference)：虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个持有虚引用的对象，和没有引用几乎是一样的，随时都有可能被垃圾回收器回收。当试图通过虚引用的get()方法取得强引用时，总是会失败。并且，虚引用必须和引用队列一起使用，它的作用在于跟踪垃圾回收过程。在 JDK 1.2 之后，提供了 PhantomReference类来实现虚引用。 2，垃圾收集算法 （1）标记-清除算法 标记-清除（Mark-Sweep）算法是最基础的收集算法，算法名字表明这个算法的垃圾收集过程包括两步：标记和清除。前面介绍的判定垃圾的过程就是标记过程，在标记过后的清除过程中会清理标记为垃圾的对象。后序的垃圾收集算法都是在这个算法的基础上改进而成的。这个算法有两个不足：一个就是标记和清除的效率不高；第二个是空间问题，标记清除后会产生大量不连续的内存碎片，空间碎片太多的话可能导致以后分配大块内存时失败的问题，这样就会触发另一次垃圾收集操作。算法的执行过程如下图：
（2）复制算法 复制算法是为了解决标记-清除算法效率不高的问题的，它将可用内存按照容量分为大小相等的两部分，每次只使用其中的一块。当一块的内存用完了，就将还存活的对象复制到另一块，然后再把已经使用过的内存空间一次性清理掉。这样使得每次是对整个半区进行内存回收，内存分配时也不需要考虑内存碎片的问题，只要移动堆顶指针，按顺序进行分配就好。算法的执行过程如下图：
不过这个算法使得内存只能一半能用，代价太高了。现在的虚拟机都采用这种方法来回收新生代，不过不是1:1分配的，而是将堆内存分为以块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和一个Survivor空间。当回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor中，然后清理Eden和使用过的Survivor空间。HotSpot虚拟机默认的Eden和Survivor比例是8:1，即Eden占堆的80%空间，Survivor占10%的空间，每次只能使用90%的堆空间。
不过，我们并不能保证每次回收只有不多于10%的对象存活，当Survivor空间不够时，需要使用其他内存空间（老年代）进行分配担保，即如果Survivor空间不够，存活的对象直接进入老年代。
（3）标记-整理算法 复制收集算法在对象存活率较高时就需要进行较多的复制操作，效率就会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都存活的极端情况，所以在老年代中一般不使用这种算法。
根据老年代的特点，可以使用另一种标记-整理（Mark-Compact）算法，标记过程和标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是整理存活的对象，将存活的对象都向一端移动，然后直接清理掉边界外的内存。算法的执行过程如下：
这样，也没有了内存碎片的问题。
（4）分代收集算法 现在的虚拟机都使用“分代收集”算法，这种算法只是根据对象的存活周期的不同将内存划分为几块。一般把Java堆空间分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法。在新生代，每次垃圾收集都会有大量的对象死去，只有少量存活，这样就可以选择复制算法，只需复制少量存活的对象就可以完成垃圾收集。在老年代中，对象的存活率高、没有额外的空间对它进行分配担保，就必须采用标记-清除或标记-整理算法来进行回收。
3，HotSpot虚拟机中的垃圾收集器 （1）Serial收集器 Serial收集器是最基本的、历史最悠久的收集器，曾经是JDK 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60338a5a58354680d0ee746c3efeba8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4874871383fb145d9358f5c8ef281aa4/" rel="bookmark">
			树与二叉树系列（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文，记录下树常见的一些操作，纯代码文章：
通常，认真掌握树的遍历的方式，对于树的一些算法，基本都可以迎刃而解了。
package tree.binarytree; import java.util.LinkedList; public class TreeTraverse { public static void main(String[] args) { TreeNode root = TreeBuilder.createBinTree(); preOrder(root); System.out.println(); inOrder(root); System.out.println(); postOrder(root); System.out.println(); System.out.println(getDepth(root)); System.out.println(); levelTraverse(root); System.out.println(); System.out.println("非递归前序遍历:"); preOrderNonRecursion(root); System.out.println(); System.out.println("非递归中序遍历:"); inOrderNonRecursion(root); } /** * @description 前序遍历 * @param root */ public static void preOrder(TreeNode root) { if (root != null) { System.out.print(root.value + " "); preOrder(root.lChild); preOrder(root.rChild); } } /** * @description 非递归版本的前序遍历 * @param root */ public static void preOrderNonRecursion(TreeNode root) { LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); if (null !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4874871383fb145d9358f5c8ef281aa4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6ca0ead0cbe9e25443e79fb0e6d7e34/" rel="bookmark">
			[git] git merge 冲突解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 在用git进行源代码版本维护的时候，常常会进行各代码版本之前区别的查看，例如在每次提交改动前进行git diff 可以看到源文件代码相对相应版本或是远程仓库的改动情况，如果有冲突还需要进行merge即整合改动的代码到指定版本（例如远程分支）。
从git difftool &amp; mergetool 工具开始 – Beyond Compare 在对复杂代码版本之间进行diff时，如果没有difftool 是不可想象的，如果有一个好用并且自己比较熟悉的Compare-比较工具往往会让你事半功倍，Window下的Diff工具有很多，WinMerge(免费),Araxis Merge(收费)，装了TortoiseSVN的话，也带有一个Diff工具TortioseIDiff，SourceGear MergeDiff，支持Windows，Mac，Linux，也非常好用，在这里我介绍比较常用的Beyond Compare.
下载安装Beyond Compare 下载和安装Beyond Compare工具，这里就不赘述了，网上搜搜。
创建启动Beyond Compare脚本 在Git的安装路径的\cmd路径下创建以下两个脚本，前面的路径名为安装后的Beyond Compare.exe的实际路径名，这是为了让git能找到比较工具，例如Beyond Compare安装路径 "D:\Software_install\Beyond\Beyond Compare 3\BCompare.exe" "$1" "$2" | cat。
创建git-difftool-bcomp-wrapper.sh # place this file in the Windows Git installation directory /cmd folder
# be sure to add the ../cmd folder to the Path environment variable
# diff is called by git with 7 parameters:
# path old-file old-hex old-mode new-file new-hex new-mode
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6ca0ead0cbe9e25443e79fb0e6d7e34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cadf6194f44ecc8d89bfed1c19335009/" rel="bookmark">
			PAT ：1121. Damn Single (25)  第二个测试点过不去 希望能有知道的大佬指点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		"Damn Single (单身狗)" is the Chinese nickname for someone who is being single. You are supposed to find those who are alone in a big party, so they can be taken care of.
Input Specification:
Each input file contains one test case. For each case, the first line gives a positive integer N (&lt;=50000), the total number of couples. Then N lines of the couples follow, each gives a couple of ID's which are 5-digit numbers (i.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cadf6194f44ecc8d89bfed1c19335009/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/946ca5092f11633f5b4374618c6afdf8/" rel="bookmark">
			QT及opencv的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu16.04.3 下安装Qt5.9.1 OpenCV3.2.0 (包括OpenCV_contrib)完美版 原创 2017年10月15日 12:08:11 标签：ubuntu /opencv /qt5 1.安装Qt5.9.1 Qt官网址：https://download.qt.io/official_releases/qt/ 根据自己的需要选择版本，这里我选择的是qt-opensource-linux-x64-5.9.1.run下载之后通过ctrl+alt+t打开终端，输入下面的代码：
sudo apt-get update cd DownLoads chmod +x ./qt-opensource-linux-x64-5.9.1.run sudo ./qt-opensource-linux-x64-5.9.1.run 1234 即可出现图形化安装，按步骤安装即可。安装完后还要修改一些配置。在终端输入以下代码：
sudo vim /usr/lib/x86_64-linux-gnu/qt-default/qtchooser/default.conf 1 进入后按i,进行编辑。 修改第一行为gcc_64的bin目录，第二行为Qt5.9.1目录的路径，完成后保存退出。（按ESC，然后：，最后输入wq，Enter即可） 之后，在终端输入以下代码：
sudo apt-get install libgl1-mesa-dev 1 Qt5.9.1安装完成。
2. 安装OpenCV3.2.0(包括opencv_contrib) 安装opencv的依赖库
sudo apt-get -y install build-essential cmake pkg-config sudo apt-get -y install libjpeg62-dev sudo apt-get -y install libtiff4-dev libjasper-dev sudo apt-get -y install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev sudo apt-get install git libgtk2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/946ca5092f11633f5b4374618c6afdf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5be44da0931d19ee472b14494b54570a/" rel="bookmark">
			Unity打安卓包 Android 所有错误解决方案大全(几乎囊括所有打包错误 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chinar blog ：www.chinar.xin
Unity打包出错解决方案 本文提供全流程，中文翻译
Chinar 的初衷是将一种简单的生活方式带给世人 使有限时间 具备无限可能 Chinar —— 心分享、心创新！
助力快速解决 Unity 打包中常见错误
给新手节省宝贵的时间，避免采坑！ 文章目录 1 Name not set —— 未设置修改包名 / 公司名 / 项目名 2 SDK Tools —— Unity版本低，需要安卓工具版本也应低些 3 AR Vuforia Android TV —— Vuforia AR 发开中，打包安卓报错 4 Quote UnityEditor —— 脚本引用 UnityEditor，导致无法打包 5 Socket: bind failed, error: —— 套接字绑定失败 5 In continuous update —— 持续更新中.... 支持 May Be —— 开发者，总有一天要做的事！ 1 Name not set —— 未设置修改包名 / 公司名 / 项目名 错误发生场景
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5be44da0931d19ee472b14494b54570a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba2fea45de863ca7e62bb8b657587a6c/" rel="bookmark">
			Android开发之——Advanced profiling is unavable for the selected process
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Android Studio从3.0版本新增了许多功能，例如：Android Profiler (其中包含了： CPU Profiler、Memory Profiler、Network Profiler )，使用之前，先检查Profiler的配置是否正确，否则你可能无法使用此功能。
接下来，我们将讲解如何配置Profiler
问题 本文主要分以下两个问题进行讲解，如果开发中按此配置仍无法解决，欢迎留言
Device not supportAdvanced profiling is unavable for the selected process Device not support 硬件支持 Android Profiler要求设备的版本必须大于android 5.0(Api 21)，否则无法使用此功能。
问题描述 如下图，当设备版本低于API21时，会出现如图现象
解决办法 使用大于android 5.0(API21)的设备
Advanced profiling is unavable for the selected process 问题描述 当问题一解决后，你可能遇到这样的问题“Advanced profiling is unavable for the selected process”
解决办法 当出现上图问题时，我们可从以下几方面解决
Enable advanced profiling配置编译版本和目标版本 Enable advanced profiling
依次打开 Run-&gt;Edit Configurations-&gt;Android app-&gt;app-&gt;profling 勾选如下图复选框 配置编译版本和目标版本
按照如下图，将编译版本和目标版本改为API26以下(包含API26)
同步项目
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba2fea45de863ca7e62bb8b657587a6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e06b23234cfc7bc865c5e3147d205e08/" rel="bookmark">
			高斯日记（日期计算）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数学家高斯有个好习惯：无论如何都要记日记。 他的日记有个与众不同的地方，他从不注明年月日，而是用一个整数代替，比如：4210
后来人们知道，那个整数就是日期，它表示那一天是高斯出生后的第几天。这或许也是个好习惯，它时时刻刻提醒着主人：日子又过去一天，还有多少时光可以用于浪费呢？
高斯出生于：1777年4月30日。
在高斯发现的一个重要定理的日记上标注着：5343，因此可算出那天是：1791年12月15日。
高斯获得博士学位的那天日记上标着：8113 请你算出高斯获得博士学位的年月日。
提交答案的格式是：yyyy-mm-dd, 例如：1980-03-21
#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; typedef long long ll; using namespace std; /* 计算日期暴力 */ const int maxn=20; int mon[maxn]={0,31,28,31,30,31,30,31,31,30,31,30,31}; struct Date{ int y,m,d; }now; /* 3.闰年的判断 四年一闰,百年不闰,四百年再闰. If（n%4==0&amp;&amp;n%100!=0||n%400==0） Printf("yes\n"); */ int is_run(int year){ if(year%4==0&amp;&amp;year%100!=0||year%100==0) return 1; return 0;	} /* 这道题讲的是出生的第一天，我们也算做是第一天 比如说我们是第三天，我们以0.0当做第三天的开始，那么我们1-3，中间只有两个间隔，我们的第三天，才刚开始 */ int main(){ now.y=1777,now.m=4,now.d=30; int n; scanf("%d",&amp;n); n--; while(n--){ now.d++; if(now.m==2&amp;&amp;now.d==28){//特判二月 if(is_run(now.y)) mon[2]=29; else mon[2]=28; } if(now.d&gt;mon[now.m]){//进位 now.m++; if(now.m&gt;12){//再进位 now.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e06b23234cfc7bc865c5e3147d205e08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95018fcbef065553287bd59658a1d6b5/" rel="bookmark">
			线性表（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了学习好数据结构，准备把书上的算法都亲自敲一遍，每天都要敲一些，是对自己的承诺吧。
1：已知一个线性表，其中的元素递增有序排列，设计一个算法，插入一个元素x(int型)；保证该顺序表依然递增有序排列，这里，假设每次都能够插入成功：
解答：线性表分为两种，数组和链表；这道题，其实就是插入排序的一部分逻辑。
package linetable; public class InsertElement { public static void main(String[] args) { int[] array = new int[] { 1, 3, 5, 7, 9 }; insertElement(array, 10); System.out.println("\n"); Node first = new Node(1); first.setNextNode(new Node(3).setNextNode(new Node(5).setNextNode(new Node(7).setNextNode(new Node(9))))); insertElement(first, 4); while (first != null) { System.out.print(first.element + " "); first = first.nextNode; } } /** * * @param root */ public static void insertElement(Node root, int index) { while (null !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95018fcbef065553287bd59658a1d6b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ee3a7b430f1f35b6e864922e3aef6cc/" rel="bookmark">
			遥感图像的空间分辨率，光谱分辨率等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 模数转换 模拟图像向数字图像的转换就叫做模数转换。 模数转换由采样和量化2步组成，采样是空间位置的离散化，量化是电磁辐射能量的离散化。下面用一幅图像来展示这个过程。 正因为遥感图像也是一种数字图像，所以也遵从着模数转换。 它的基本的质量评判有空间分辨率，辐射分辨率，时间分辨率，光谱分辨率。 空间分辨率 空间分辨率：数字图像像元所能分辨目标的尺寸大小，其单位是PPI（piexls per inch）。 决定因素：采样密度，采样间隔越小，空间分辨率越高，图像越清晰。即选取采样点之间的间隔。 卫星遥感图像的空间分辨率基本不变的，因为总是同一个卫星的产物的缘故。 那么究竟空间分辨率是如何计算的呢？可以通过以下的公式计算： 辐射分辨率 辐射分辨率：指传感器探测元件在接收光谱信号时所能分辨的最小辐射度差。 也就是说传感器能够区分辐射差的能力，比如区分能力为辐射差1，那么地物辐射每相隔1辐射能量才能区分开，其中不足的就会被量化为同一个灰度。但是当传感器区分能力为辐射差0.1时，你能每隔0.1就量化为一种灰度，从而看出在同一地区，区分辐射差越敏感，则图像中灰度的区分度就越多。 决定因素：量化能力，量化级越多，图像层次越丰富，辐射分辨率越高。 辐射分辨率：OLI（2^12）&gt; TM（256）&gt; MSS（64） 从中也可以看出，辐射分辨率也是和具体的卫星有关。
时间分辨率 时间分辨率：指对同一区域进行重复观测的最小时间间隔。 决定因素与卫星的回归周期有关，即由遥感卫星决定。 那么究竟时间分辨高好还是低好？这取决于具体的应用，如： 气象卫星 短周期（小时） ；植物动态（中周期） ；城市扩展土地利用（长周期）。
光谱分辨率 光谱分辨率：指传感器在接收目标地物辐射能量时所使用的波段数目（通道数）、波长位置和波段间隔。 下面贴一张landsat8 的波段信息： 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/515/">«</a>
	<span class="pagination__item pagination__item--current">516/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/517/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>